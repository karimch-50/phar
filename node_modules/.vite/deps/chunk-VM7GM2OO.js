import {
  get,
  set
} from "./chunk-54ADOYDD.js";
import {
  ifDefined
} from "./chunk-2BWIX5N6.js";
import {
  screenReaderOnly
} from "./chunk-TTWJGM74.js";
import {
  fieldButton
} from "./chunk-MI4WOW4I.js";
import {
  ElementMixin
} from "./chunk-MWSAWSJ3.js";
import {
  DisabledMixin
} from "./chunk-CRXJMMF2.js";
import {
  SlotController
} from "./chunk-6C6BQOMD.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-BBNA52CT.js";
import {
  LitElement
} from "./chunk-25Y4ITXF.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import {
  html
} from "./chunk-QO3ZNG6F.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";

// node_modules/@vaadin/side-nav/theme/lumo/vaadin-side-nav-item-styles.js
var sideNavItemStyles = css`
  :host {
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  [part='link'] {
    width: 100%;
    gap: var(--lumo-space-xs);
    padding: var(--lumo-space-s);
    padding-inline-start: calc(var(--lumo-space-s) + var(--_child-indent, 0px));
    border-radius: var(--lumo-border-radius-m);
    transition: background-color 140ms, color 140ms;
    cursor: var(--lumo-clickable-cursor, default);
    min-height: var(--lumo-icon-size-m);
  }

  [part='link'][href] {
    cursor: pointer;
  }

  :host([disabled]) [part='link'] {
    color: var(--lumo-disabled-text-color);
  }

  [part='toggle-button'] {
    margin-inline-end: calc(var(--lumo-space-xs) * -1);
    width: var(--lumo-size-s);
    height: var(--lumo-size-s);
  }

  :host([has-children]) [part='content'] {
    padding-inline-end: var(--lumo-space-s);
  }

  @media (any-hover: hover) {
    [part='link']:hover {
      color: var(--lumo-header-text-color);
    }

    [part='toggle-button']:hover {
      color: var(--lumo-body-text-color);
    }
  }

  [part='link']:active:focus {
    background-color: var(--lumo-contrast-5pct);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
    transform: rotate(-90deg);
    transition: transform 140ms;
  }

  :host([dir='rtl']) [part='toggle-button']::before {
    transform: rotate(90deg);
  }

  :host([expanded]) [part='toggle-button']::before {
    transform: none;
  }

  @supports selector(:focus-visible) {
    [part='link'],
    [part='toggle-button'] {
      outline: none;
    }

    [part='link']:focus-visible,
    [part='toggle-button']:focus-visible {
      border-radius: var(--lumo-border-radius-m);
      box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }
  }

  [part='link']:active {
    color: var(--lumo-header-text-color);
  }

  slot:not([name]) {
    margin: 0 var(--lumo-space-s);
  }

  slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    padding: 0.1em;
    flex-shrink: 0;
    color: var(--lumo-contrast-60pct);
  }

  :host([disabled]) slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    color: var(--lumo-disabled-text-color);
  }

  :host([current]) slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    color: inherit;
  }

  slot[name='children'] {
    --_child-indent: calc(var(--_child-indent-2, 0px) + var(--vaadin-side-nav-child-indent, var(--lumo-space-l)));
  }

  slot[name='children']::slotted(*) {
    --_child-indent-2: var(--_child-indent);
  }

  :host([current]) [part='content'] {
    background-color: var(--lumo-primary-color-10pct);
    color: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    border-radius: var(--lumo-border-radius-m);
  }
`;
registerStyles("vaadin-side-nav-item", [fieldButton, sideNavItemStyles], { moduleId: "lumo-side-nav-item" });

// node_modules/@open-wc/dedupe-mixin/src/dedupeMixin.js
var appliedClassMixins = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins.set(mixedClass, mixin);
    return mixedClass;
  };
}

// node_modules/@vaadin/component-base/src/polylit-mixin.js
var caseMap = {};
var CAMEL_TO_DASH = /([A-Z])/gu;
function camelToDash(camel) {
  if (!caseMap[camel]) {
    caseMap[camel] = camel.replace(CAMEL_TO_DASH, "-$1").toLowerCase();
  }
  return caseMap[camel];
}
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}
function parseObserver(observerString) {
  const [method, rest] = observerString.split("(");
  const observerProps = rest.replace(")", "").split(",").map((prop) => prop.trim());
  return {
    method,
    observerProps
  };
}
function getOrCreateMap(obj, name) {
  if (!Object.prototype.hasOwnProperty.call(obj, name)) {
    obj[name] = new Map(obj[name]);
  }
  return obj[name];
}
var PolylitMixinImplementation = (superclass) => {
  class PolylitMixinClass extends superclass {
    static createProperty(name, options) {
      if ([String, Boolean, Number, Array].includes(options)) {
        options = {
          type: options
        };
      }
      if (options.reflectToAttribute) {
        options.reflect = true;
      }
      super.createProperty(name, options);
    }
    static getOrCreateMap(name) {
      return getOrCreateMap(this, name);
    }
    /**
     * @protected
     * @override
     */
    static finalize() {
      super.finalize();
      if (Array.isArray(this.observers)) {
        const complexObservers = this.getOrCreateMap("__complexObservers");
        this.observers.forEach((observer) => {
          const { method, observerProps } = parseObserver(observer);
          complexObservers.set(method, observerProps);
        });
      }
    }
    static addCheckedInitializer(initializer) {
      super.addInitializer((instance) => {
        if (instance instanceof this) {
          initializer(instance);
        }
      });
    }
    static getPropertyDescriptor(name, key, options) {
      const defaultDescriptor = super.getPropertyDescriptor(name, key, options);
      let result = defaultDescriptor;
      this.getOrCreateMap("__propKeys").set(name, key);
      if (options.sync) {
        result = {
          get: defaultDescriptor.get,
          set(value) {
            const oldValue = this[name];
            this[key] = value;
            this.requestUpdate(name, oldValue, options);
            if (this.hasUpdated) {
              this.performUpdate();
            }
          },
          configurable: true,
          enumerable: true
        };
      }
      if (options.readOnly) {
        const setter = defaultDescriptor.set;
        this.addCheckedInitializer((instance) => {
          instance[`_set${upper(name)}`] = function(value) {
            setter.call(instance, value);
            if (options.sync) {
              this.performUpdate();
            }
          };
        });
        result = {
          get: defaultDescriptor.get,
          set() {
          },
          configurable: true,
          enumerable: true
        };
      }
      if ("value" in options) {
        this.addCheckedInitializer((instance) => {
          const value = typeof options.value === "function" ? options.value.call(instance) : options.value;
          if (options.readOnly) {
            instance[`_set${upper(name)}`](value);
          } else {
            instance[name] = value;
          }
        });
      }
      if (options.observer) {
        const method = options.observer;
        this.getOrCreateMap("__observers").set(name, method);
        this.addCheckedInitializer((instance) => {
          if (!instance[method]) {
            console.warn(`observer method ${method} not defined`);
          }
        });
      }
      if (options.notify) {
        if (!this.__notifyProps) {
          this.__notifyProps = /* @__PURE__ */ new Set();
        } else if (!this.hasOwnProperty("__notifyProps")) {
          const notifyProps = this.__notifyProps;
          this.__notifyProps = new Set(notifyProps);
        }
        this.__notifyProps.add(name);
      }
      if (options.computed) {
        const assignComputedMethod = `__assignComputed${name}`;
        const observer = parseObserver(options.computed);
        this.prototype[assignComputedMethod] = function(...props) {
          this[name] = this[observer.method](...props);
        };
        this.getOrCreateMap("__complexObservers").set(assignComputedMethod, observer.observerProps);
      }
      if (!options.attribute) {
        options.attribute = camelToDash(name);
      }
      return result;
    }
    /** @protected */
    firstUpdated() {
      super.firstUpdated();
      if (!this.$) {
        this.$ = {};
      }
      this.renderRoot.querySelectorAll("[id]").forEach((node) => {
        this.$[node.id] = node;
      });
    }
    /** @protected */
    ready() {
    }
    /** @protected */
    updated(props) {
      if (this.constructor.__observers) {
        this.__runObservers(props, this.constructor.__observers);
      }
      if (this.constructor.__complexObservers) {
        this.__runComplexObservers(props, this.constructor.__complexObservers);
      }
      if (this.__dynamicObservers) {
        this.__runComplexObservers(props, this.__dynamicObservers);
      }
      if (this.constructor.__notifyProps) {
        this.__runNotifyProps(props, this.constructor.__notifyProps);
      }
      if (!this.__isReadyInvoked) {
        this.__isReadyInvoked = true;
        this.ready();
      }
    }
    /**
     * Set several properties at once and perform synchronous update.
     * @protected
     */
    setProperties(props) {
      Object.entries(props).forEach(([name, value]) => {
        const key = this.constructor.__propKeys.get(name);
        const oldValue = this[key];
        this[key] = value;
        this.requestUpdate(name, oldValue);
      });
      if (this.hasUpdated) {
        this.performUpdate();
      }
    }
    /** @protected */
    _createMethodObserver(observer) {
      const dynamicObservers = getOrCreateMap(this, "__dynamicObservers");
      const { method, observerProps } = parseObserver(observer);
      dynamicObservers.set(method, observerProps);
    }
    /** @private */
    __runComplexObservers(props, observers) {
      observers.forEach((observerProps, method) => {
        if (observerProps.some((prop) => props.has(prop))) {
          if (!this[method]) {
            console.warn(`observer method ${method} not defined`);
          } else {
            this[method](...observerProps.map((prop) => this[prop]));
          }
        }
      });
    }
    /** @private */
    __runObservers(props, observers) {
      props.forEach((v, k) => {
        const observer = observers.get(k);
        if (observer !== void 0 && this[observer]) {
          this[observer](this[k], v);
        }
      });
    }
    /** @private */
    __runNotifyProps(props, notifyProps) {
      props.forEach((_, k) => {
        if (notifyProps.has(k)) {
          this.dispatchEvent(
            new CustomEvent(`${camelToDash(k)}-changed`, {
              detail: {
                value: this[k]
              }
            })
          );
        }
      });
    }
    /** @protected */
    _get(path, object) {
      return get(path, object);
    }
    /** @protected */
    _set(path, value, object) {
      set(path, value, object);
    }
  }
  return PolylitMixinClass;
};
var PolylitMixin = dedupeMixin(PolylitMixinImplementation);

// node_modules/@vaadin/component-base/src/url-utils.js
function containsQueryParams(actual, expected) {
  return [...expected.entries()].every(([key, value]) => {
    return actual.getAll(key).includes(value);
  });
}
function matchPaths(actual, expected) {
  const base = document.baseURI;
  const actualUrl = new URL(actual, base);
  const expectedUrl = new URL(expected, base);
  return actualUrl.origin === expectedUrl.origin && actualUrl.pathname === expectedUrl.pathname && containsQueryParams(actualUrl.searchParams, expectedUrl.searchParams);
}

// node_modules/@vaadin/side-nav/src/vaadin-side-nav-base-styles.js
var sideNavItemBaseStyles = css`
  :host {
    display: block;
  }

  :host([hidden]),
  [hidden] {
    display: none !important;
  }

  :host([disabled]) {
    pointer-events: none;
  }

  [part='content'] {
    display: flex;
    align-items: center;
  }

  [part='link'] {
    flex: auto;
    min-width: 0;
    display: flex;
    align-items: center;
    text-decoration: none;
    color: inherit;
    font: inherit;
  }

  button {
    -webkit-appearance: none;
    appearance: none;
    flex: none;
    position: relative;
    margin: 0;
    padding: 0;
    border: 0;
    background: transparent;
  }

  [part='children'] {
    padding: 0;
    margin: 0;
    list-style-type: none;
  }

  :host(:not([has-children])) button {
    display: none !important;
  }

  slot[name='prefix'],
  slot[name='suffix'] {
    flex: none;
  }

  slot:not([name]) {
    display: block;
    flex: auto;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;
var sideNavBaseStyles = css`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: inherit;
    width: 100%;
    margin: 0;
    padding: 0;
    background-color: initial;
    color: inherit;
    border: initial;
    outline: none;
    font: inherit;
    text-align: inherit;
  }

  [part='children'] {
    padding: 0;
    margin: 0;
    list-style-type: none;
  }
`;

// node_modules/@vaadin/side-nav/src/vaadin-side-nav-children-mixin.js
var ChildrenController = class extends SlotController {
  constructor(host, slotName) {
    super(host, slotName, null, { observe: true, multiple: true });
  }
  /**
   * @protected
   * @override
   */
  initAddedNode() {
    this.host.requestUpdate();
  }
  /**
   * @protected
   * @override
   */
  teardownNode() {
    this.host.requestUpdate();
  }
};
var SideNavChildrenMixin = (superClass) => class SideNavChildrenMixin extends superClass {
  static get properties() {
    return {
      /**
       * The object used to localize this component.
       *
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * The object has the following structure and default values:
       * ```
       * {
       *   toggle: 'Toggle child items'
       * }
       * ```
       *
       * @type {SideNavI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            toggle: "Toggle child items"
          };
        }
      },
      /**
       * Count of child items.
       * @protected
       */
      _itemsCount: {
        type: Number,
        value: 0
      }
    };
  }
  constructor() {
    super();
    this._childrenController = new ChildrenController(this, this._itemsSlotName);
  }
  /**
   * List of child items of this component.
   * @protected
   */
  get _items() {
    return this._childrenController.nodes;
  }
  /**
   * Name of the slot to be used for children.
   * @protected
   */
  get _itemsSlotName() {
    return "children";
  }
  /** @protected */
  firstUpdated() {
    super.firstUpdated();
    this.addController(this._childrenController);
  }
  /**
   * @protected
   * @override
   */
  willUpdate(props) {
    super.willUpdate(props);
    this._itemsCount = this._items.length;
  }
  /**
   * @protected
   * @override
   */
  updated(props) {
    super.updated(props);
    if (props.has("_itemsCount")) {
      this.toggleAttribute("has-children", this._itemsCount > 0);
    }
    if (props.has("_itemsCount") || props.has("i18n")) {
      this._items.forEach((item) => {
        item.i18n = this.i18n;
      });
    }
  }
};

// node_modules/@vaadin/side-nav/src/vaadin-side-nav-item.js
var SideNavItem = class extends SideNavChildrenMixin(DisabledMixin(ElementMixin(ThemableMixin(PolylitMixin(LitElement))))) {
  static get is() {
    return "vaadin-side-nav-item";
  }
  static get properties() {
    return {
      /**
       * The path to navigate to
       */
      path: String,
      /**
       * The list of alternative paths matching this item
       *
       * @type {!Array<string>}
       */
      pathAliases: {
        type: Array,
        value: () => []
      },
      /**
       * Whether to show the child items or not
       *
       * @type {boolean}
       */
      expanded: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },
      /**
       * Whether the path of the item matches the current path.
       * Set when the item is appended to DOM or when navigated back
       * to the page that contains this item using the browser.
       *
       * @type {boolean}
       */
      current: {
        type: Boolean,
        value: false,
        readOnly: true,
        reflectToAttribute: true
      }
    };
  }
  static get styles() {
    return [screenReaderOnly, sideNavItemBaseStyles];
  }
  constructor() {
    super();
    this.__boundUpdateCurrent = this.__updateCurrent.bind(this);
  }
  /** @protected */
  get _button() {
    return this.shadowRoot.querySelector("button");
  }
  /**
   * @protected
   * @override
   */
  firstUpdated() {
    super.firstUpdated();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "listitem");
    }
  }
  /**
   * @protected
   * @override
   */
  updated(props) {
    super.updated(props);
    if (props.has("path") || props.has("pathAliases")) {
      this.__updateCurrent();
    }
    if (props.has("disabled") || props.has("_itemsCount")) {
      this._items.forEach((item) => {
        item.disabled = this.disabled;
      });
    }
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__updateCurrent();
    window.addEventListener("popstate", this.__boundUpdateCurrent);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("popstate", this.__boundUpdateCurrent);
  }
  /** @protected */
  render() {
    return html`
      <div part="content" @click="${this._onContentClick}">
        <a
          id="link"
          ?disabled="${this.disabled}"
          tabindex="${this.disabled || this.path == null ? "-1" : "0"}"
          href="${ifDefined(this.disabled ? null : this.path)}"
          part="link"
          aria-current="${this.current ? "page" : "false"}"
        >
          <slot name="prefix"></slot>
          <slot></slot>
          <slot name="suffix"></slot>
        </a>
        <button
          part="toggle-button"
          ?disabled="${this.disabled}"
          @click="${this._onButtonClick}"
          aria-controls="children"
          aria-expanded="${this.expanded}"
          aria-labelledby="link i18n"
        ></button>
      </div>
      <ul part="children" role="list" ?hidden="${!this.expanded}" aria-hidden="${this.expanded ? "false" : "true"}">
        <slot name="children"></slot>
      </ul>
      <div class="sr-only" id="i18n">${this.i18n.toggle}</div>
    `;
  }
  /** @private */
  _onButtonClick(event) {
    event.stopPropagation();
    this.__toggleExpanded();
  }
  /** @private */
  _onContentClick() {
    if (this.path == null && this.hasAttribute("has-children")) {
      this.__toggleExpanded();
    }
  }
  /** @private */
  __toggleExpanded() {
    this.expanded = !this.expanded;
  }
  /** @private */
  __updateCurrent() {
    this._setCurrent(this.__isCurrent());
    if (this.current) {
      this.expanded = this._items.length > 0;
    }
  }
  /** @private */
  __isCurrent() {
    if (this.path == null) {
      return false;
    }
    return matchPaths(document.location.pathname, this.path) || this.pathAliases.some((alias) => matchPaths(document.location.pathname, alias));
  }
};
defineCustomElement(SideNavItem);

export {
  PolylitMixin,
  sideNavBaseStyles,
  SideNavChildrenMixin
};
/*! Bundled license information:

@vaadin/component-base/src/polylit-mixin.js:
  (**
   * @license
   * Copyright (c) 2021 - 2024 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/component-base/src/url-utils.js:
  (**
   * @license
   * Copyright (c) 2023 - 2024 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/side-nav/src/vaadin-side-nav-base-styles.js:
  (**
   * @license
   * Copyright (c) 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/side-nav/src/vaadin-side-nav-children-mixin.js:
  (**
   * @license
   * Copyright (c) 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/side-nav/src/vaadin-side-nav-item.js:
  (**
   * @license
   * Copyright (c) 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/side-nav/theme/lumo/vaadin-side-nav-item.js:
  (**
   * @license
   * Copyright (c) 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-VM7GM2OO.js.map
