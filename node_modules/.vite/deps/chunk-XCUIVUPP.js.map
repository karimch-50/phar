{
  "version": 3,
  "sources": ["../../@vaadin-component-factory/vcf-pdf-viewer/pdfjs/dist/network.js"],
  "sourcesContent": ["import { c as assert, l as createPromiseCapability, n as stringToBytes } from './util.js';\r\nimport { v as validateRangeRequestCapabilities, e as extractFilenameFromHeader, c as createResponseStatusError } from './network_utils.js';\r\nimport './display_utils.js';\r\n\r\n/* Copyright 2012 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nif (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\r\n  throw new Error('Module \"./network.js\" shall not be used with MOZCENTRAL builds.');\r\n}\r\n\r\nconst OK_RESPONSE = 200;\r\nconst PARTIAL_CONTENT_RESPONSE = 206;\r\n\r\nfunction getArrayBuffer(xhr) {\r\n  const data = xhr.response;\r\n\r\n  if (typeof data !== \"string\") {\r\n    return data;\r\n  }\r\n\r\n  const array = stringToBytes(data);\r\n  return array.buffer;\r\n}\r\n\r\nclass NetworkManager {\r\n  constructor(url, args) {\r\n    this.url = url;\r\n    args = args || {};\r\n    this.isHttp = /^https?:/i.test(url);\r\n    this.httpHeaders = this.isHttp && args.httpHeaders || {};\r\n    this.withCredentials = args.withCredentials || false;\r\n\r\n    this.getXhr = args.getXhr || function NetworkManager_getXhr() {\r\n      return new XMLHttpRequest();\r\n    };\r\n\r\n    this.currXhrId = 0;\r\n    this.pendingRequests = Object.create(null);\r\n  }\r\n\r\n  requestRange(begin, end, listeners) {\r\n    const args = {\r\n      begin,\r\n      end\r\n    };\r\n\r\n    for (const prop in listeners) {\r\n      args[prop] = listeners[prop];\r\n    }\r\n\r\n    return this.request(args);\r\n  }\r\n\r\n  requestFull(listeners) {\r\n    return this.request(listeners);\r\n  }\r\n\r\n  request(args) {\r\n    const xhr = this.getXhr();\r\n    const xhrId = this.currXhrId++;\r\n    const pendingRequest = this.pendingRequests[xhrId] = {\r\n      xhr\r\n    };\r\n    xhr.open(\"GET\", this.url);\r\n    xhr.withCredentials = this.withCredentials;\r\n\r\n    for (const property in this.httpHeaders) {\r\n      const value = this.httpHeaders[property];\r\n\r\n      if (typeof value === \"undefined\") {\r\n        continue;\r\n      }\r\n\r\n      xhr.setRequestHeader(property, value);\r\n    }\r\n\r\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\r\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\r\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\r\n    } else {\r\n      pendingRequest.expectedStatus = OK_RESPONSE;\r\n    }\r\n\r\n    xhr.responseType = \"arraybuffer\";\r\n\r\n    if (args.onError) {\r\n      xhr.onerror = function (evt) {\r\n        args.onError(xhr.status);\r\n      };\r\n    }\r\n\r\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\r\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\r\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\r\n    pendingRequest.onDone = args.onDone;\r\n    pendingRequest.onError = args.onError;\r\n    pendingRequest.onProgress = args.onProgress;\r\n    xhr.send(null);\r\n    return xhrId;\r\n  }\r\n\r\n  onProgress(xhrId, evt) {\r\n    const pendingRequest = this.pendingRequests[xhrId];\r\n\r\n    if (!pendingRequest) {\r\n      // Maybe abortRequest was called...\r\n      return;\r\n    }\r\n\r\n    if (pendingRequest.onProgress) {\r\n      pendingRequest.onProgress(evt);\r\n    }\r\n  }\r\n\r\n  onStateChange(xhrId, evt) {\r\n    const pendingRequest = this.pendingRequests[xhrId];\r\n\r\n    if (!pendingRequest) {\r\n      // Maybe abortRequest was called...\r\n      return;\r\n    }\r\n\r\n    const xhr = pendingRequest.xhr;\r\n\r\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\r\n      pendingRequest.onHeadersReceived();\r\n      delete pendingRequest.onHeadersReceived;\r\n    }\r\n\r\n    if (xhr.readyState !== 4) {\r\n      return;\r\n    }\r\n\r\n    if (!(xhrId in this.pendingRequests)) {\r\n      // The XHR request might have been aborted in onHeadersReceived()\r\n      // callback, in which case we should abort request.\r\n      return;\r\n    }\r\n\r\n    delete this.pendingRequests[xhrId]; // Success status == 0 can be on ftp, file and other protocols.\r\n\r\n    if (xhr.status === 0 && this.isHttp) {\r\n      if (pendingRequest.onError) {\r\n        pendingRequest.onError(xhr.status);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const xhrStatus = xhr.status || OK_RESPONSE; // From http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.2:\r\n    // \"A server MAY ignore the Range header\". This means it's possible to\r\n    // get a 200 rather than a 206 response from a range request.\r\n\r\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\r\n\r\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\r\n      if (pendingRequest.onError) {\r\n        pendingRequest.onError(xhr.status);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    const chunk = getArrayBuffer(xhr);\r\n\r\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\r\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\r\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\r\n      pendingRequest.onDone({\r\n        begin: parseInt(matches[1], 10),\r\n        chunk\r\n      });\r\n    } else if (chunk) {\r\n      pendingRequest.onDone({\r\n        begin: 0,\r\n        chunk\r\n      });\r\n    } else if (pendingRequest.onError) {\r\n      pendingRequest.onError(xhr.status);\r\n    }\r\n  }\r\n\r\n  getRequestXhr(xhrId) {\r\n    return this.pendingRequests[xhrId].xhr;\r\n  }\r\n\r\n  isPendingRequest(xhrId) {\r\n    return xhrId in this.pendingRequests;\r\n  }\r\n\r\n  abortRequest(xhrId) {\r\n    const xhr = this.pendingRequests[xhrId].xhr;\r\n    delete this.pendingRequests[xhrId];\r\n    xhr.abort();\r\n  }\r\n\r\n}\r\n/** @implements {IPDFStream} */\r\n\r\n\r\nclass PDFNetworkStream {\r\n  constructor(source) {\r\n    this._source = source;\r\n    this._manager = new NetworkManager(source.url, {\r\n      httpHeaders: source.httpHeaders,\r\n      withCredentials: source.withCredentials\r\n    });\r\n    this._rangeChunkSize = source.rangeChunkSize;\r\n    this._fullRequestReader = null;\r\n    this._rangeRequestReaders = [];\r\n  }\r\n\r\n  _onRangeRequestReaderClosed(reader) {\r\n    const i = this._rangeRequestReaders.indexOf(reader);\r\n\r\n    if (i >= 0) {\r\n      this._rangeRequestReaders.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  getFullReader() {\r\n    assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\r\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\r\n    return this._fullRequestReader;\r\n  }\r\n\r\n  getRangeReader(begin, end) {\r\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\r\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\r\n\r\n    this._rangeRequestReaders.push(reader);\r\n\r\n    return reader;\r\n  }\r\n\r\n  cancelAllRequests(reason) {\r\n    if (this._fullRequestReader) {\r\n      this._fullRequestReader.cancel(reason);\r\n    }\r\n\r\n    for (const reader of this._rangeRequestReaders.slice(0)) {\r\n      reader.cancel(reason);\r\n    }\r\n  }\r\n\r\n}\r\n/** @implements {IPDFStreamReader} */\r\n\r\n\r\nclass PDFNetworkStreamFullRequestReader {\r\n  constructor(manager, source) {\r\n    this._manager = manager;\r\n    const args = {\r\n      onHeadersReceived: this._onHeadersReceived.bind(this),\r\n      onDone: this._onDone.bind(this),\r\n      onError: this._onError.bind(this),\r\n      onProgress: this._onProgress.bind(this)\r\n    };\r\n    this._url = source.url;\r\n    this._fullRequestId = manager.requestFull(args);\r\n    this._headersReceivedCapability = createPromiseCapability();\r\n    this._disableRange = source.disableRange || false;\r\n    this._contentLength = source.length; // Optional\r\n\r\n    this._rangeChunkSize = source.rangeChunkSize;\r\n\r\n    if (!this._rangeChunkSize && !this._disableRange) {\r\n      this._disableRange = true;\r\n    }\r\n\r\n    this._isStreamingSupported = false;\r\n    this._isRangeSupported = false;\r\n    this._cachedChunks = [];\r\n    this._requests = [];\r\n    this._done = false;\r\n    this._storedError = undefined;\r\n    this._filename = null;\r\n    this.onProgress = null;\r\n  }\r\n\r\n  _onHeadersReceived() {\r\n    const fullRequestXhrId = this._fullRequestId;\r\n\r\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\r\n\r\n    const getResponseHeader = name => {\r\n      return fullRequestXhr.getResponseHeader(name);\r\n    };\r\n\r\n    const {\r\n      allowRangeRequests,\r\n      suggestedLength\r\n    } = validateRangeRequestCapabilities({\r\n      getResponseHeader,\r\n      isHttp: this._manager.isHttp,\r\n      rangeChunkSize: this._rangeChunkSize,\r\n      disableRange: this._disableRange\r\n    });\r\n\r\n    if (allowRangeRequests) {\r\n      this._isRangeSupported = true;\r\n    } // Setting right content length.\r\n\r\n\r\n    this._contentLength = suggestedLength || this._contentLength;\r\n    this._filename = extractFilenameFromHeader(getResponseHeader);\r\n\r\n    if (this._isRangeSupported) {\r\n      // NOTE: by cancelling the full request, and then issuing range\r\n      // requests, there will be an issue for sites where you can only\r\n      // request the pdf once. However, if this is the case, then the\r\n      // server should not be returning that it can support range requests.\r\n      this._manager.abortRequest(fullRequestXhrId);\r\n    }\r\n\r\n    this._headersReceivedCapability.resolve();\r\n  }\r\n\r\n  _onDone(args) {\r\n    if (args) {\r\n      if (this._requests.length > 0) {\r\n        const requestCapability = this._requests.shift();\r\n\r\n        requestCapability.resolve({\r\n          value: args.chunk,\r\n          done: false\r\n        });\r\n      } else {\r\n        this._cachedChunks.push(args.chunk);\r\n      }\r\n    }\r\n\r\n    this._done = true;\r\n\r\n    if (this._cachedChunks.length > 0) {\r\n      return;\r\n    }\r\n\r\n    for (const requestCapability of this._requests) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    }\r\n\r\n    this._requests.length = 0;\r\n  }\r\n\r\n  _onError(status) {\r\n    const url = this._url;\r\n    const exception = createResponseStatusError(status, url);\r\n    this._storedError = exception;\r\n\r\n    this._headersReceivedCapability.reject(exception);\r\n\r\n    for (const requestCapability of this._requests) {\r\n      requestCapability.reject(exception);\r\n    }\r\n\r\n    this._requests.length = 0;\r\n    this._cachedChunks.length = 0;\r\n  }\r\n\r\n  _onProgress(data) {\r\n    if (this.onProgress) {\r\n      this.onProgress({\r\n        loaded: data.loaded,\r\n        total: data.lengthComputable ? data.total : this._contentLength\r\n      });\r\n    }\r\n  }\r\n\r\n  get filename() {\r\n    return this._filename;\r\n  }\r\n\r\n  get isRangeSupported() {\r\n    return this._isRangeSupported;\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return this._isStreamingSupported;\r\n  }\r\n\r\n  get contentLength() {\r\n    return this._contentLength;\r\n  }\r\n\r\n  get headersReady() {\r\n    return this._headersReceivedCapability.promise;\r\n  }\r\n\r\n  async read() {\r\n    if (this._storedError) {\r\n      throw this._storedError;\r\n    }\r\n\r\n    if (this._cachedChunks.length > 0) {\r\n      const chunk = this._cachedChunks.shift();\r\n\r\n      return {\r\n        value: chunk,\r\n        done: false\r\n      };\r\n    }\r\n\r\n    if (this._done) {\r\n      return {\r\n        value: undefined,\r\n        done: true\r\n      };\r\n    }\r\n\r\n    const requestCapability = createPromiseCapability();\r\n\r\n    this._requests.push(requestCapability);\r\n\r\n    return requestCapability.promise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    this._done = true;\r\n\r\n    this._headersReceivedCapability.reject(reason);\r\n\r\n    for (const requestCapability of this._requests) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    }\r\n\r\n    this._requests.length = 0;\r\n\r\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\r\n      this._manager.abortRequest(this._fullRequestId);\r\n    }\r\n\r\n    this._fullRequestReader = null;\r\n  }\r\n\r\n}\r\n/** @implements {IPDFStreamRangeReader} */\r\n\r\n\r\nclass PDFNetworkStreamRangeRequestReader {\r\n  constructor(manager, begin, end) {\r\n    this._manager = manager;\r\n    const args = {\r\n      onDone: this._onDone.bind(this),\r\n      onProgress: this._onProgress.bind(this)\r\n    };\r\n    this._requestId = manager.requestRange(begin, end, args);\r\n    this._requests = [];\r\n    this._queuedChunk = null;\r\n    this._done = false;\r\n    this.onProgress = null;\r\n    this.onClosed = null;\r\n  }\r\n\r\n  _close() {\r\n    if (this.onClosed) {\r\n      this.onClosed(this);\r\n    }\r\n  }\r\n\r\n  _onDone(data) {\r\n    const chunk = data.chunk;\r\n\r\n    if (this._requests.length > 0) {\r\n      const requestCapability = this._requests.shift();\r\n\r\n      requestCapability.resolve({\r\n        value: chunk,\r\n        done: false\r\n      });\r\n    } else {\r\n      this._queuedChunk = chunk;\r\n    }\r\n\r\n    this._done = true;\r\n\r\n    for (const requestCapability of this._requests) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    }\r\n\r\n    this._requests.length = 0;\r\n\r\n    this._close();\r\n  }\r\n\r\n  _onProgress(evt) {\r\n    if (!this.isStreamingSupported && this.onProgress) {\r\n      this.onProgress({\r\n        loaded: evt.loaded\r\n      });\r\n    }\r\n  }\r\n\r\n  get isStreamingSupported() {\r\n    return false;\r\n  }\r\n\r\n  async read() {\r\n    if (this._queuedChunk !== null) {\r\n      const chunk = this._queuedChunk;\r\n      this._queuedChunk = null;\r\n      return {\r\n        value: chunk,\r\n        done: false\r\n      };\r\n    }\r\n\r\n    if (this._done) {\r\n      return {\r\n        value: undefined,\r\n        done: true\r\n      };\r\n    }\r\n\r\n    const requestCapability = createPromiseCapability();\r\n\r\n    this._requests.push(requestCapability);\r\n\r\n    return requestCapability.promise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    this._done = true;\r\n\r\n    for (const requestCapability of this._requests) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    }\r\n\r\n    this._requests.length = 0;\r\n\r\n    if (this._manager.isPendingRequest(this._requestId)) {\r\n      this._manager.abortRequest(this._requestId);\r\n    }\r\n\r\n    this._close();\r\n  }\r\n\r\n}\r\n\r\nexport { PDFNetworkStream };\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AA0BA,SAAS,eAAe,KAAK;AAC3B,QAAM,OAAO,IAAI;AAEjB,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,cAAc,IAAI;AAChC,SAAO,MAAM;AACf;AAnCA,IAuBM,aACA,0BAaA,gBAgLA,kBAiDA,mCAoMA;AA1cN;AAAA;AAAA;AACA;AACA;AAiBA,QAAI,OAAO,aAAa,eAAe,SAAS,KAAK,YAAY,GAAG;AAClE,YAAM,IAAI,MAAM,iEAAiE;AAAA,IACnF;AAEA,IAAM,cAAc;AACpB,IAAM,2BAA2B;AAajC,IAAM,iBAAN,MAAqB;AAAA,MACnB,YAAY,KAAK,MAAM;AACrB,aAAK,MAAM;AACX,eAAO,QAAQ,CAAC;AAChB,aAAK,SAAS,YAAY,KAAK,GAAG;AAClC,aAAK,cAAc,KAAK,UAAU,KAAK,eAAe,CAAC;AACvD,aAAK,kBAAkB,KAAK,mBAAmB;AAE/C,aAAK,SAAS,KAAK,UAAU,SAAS,wBAAwB;AAC5D,iBAAO,IAAI,eAAe;AAAA,QAC5B;AAEA,aAAK,YAAY;AACjB,aAAK,kBAAkB,uBAAO,OAAO,IAAI;AAAA,MAC3C;AAAA,MAEA,aAAa,OAAO,KAAK,WAAW;AAClC,cAAM,OAAO;AAAA,UACX;AAAA,UACA;AAAA,QACF;AAEA,mBAAW,QAAQ,WAAW;AAC5B,eAAK,IAAI,IAAI,UAAU,IAAI;AAAA,QAC7B;AAEA,eAAO,KAAK,QAAQ,IAAI;AAAA,MAC1B;AAAA,MAEA,YAAY,WAAW;AACrB,eAAO,KAAK,QAAQ,SAAS;AAAA,MAC/B;AAAA,MAEA,QAAQ,MAAM;AACZ,cAAM,MAAM,KAAK,OAAO;AACxB,cAAM,QAAQ,KAAK;AACnB,cAAM,iBAAiB,KAAK,gBAAgB,KAAK,IAAI;AAAA,UACnD;AAAA,QACF;AACA,YAAI,KAAK,OAAO,KAAK,GAAG;AACxB,YAAI,kBAAkB,KAAK;AAE3B,mBAAW,YAAY,KAAK,aAAa;AACvC,gBAAM,QAAQ,KAAK,YAAY,QAAQ;AAEvC,cAAI,OAAO,UAAU,aAAa;AAChC;AAAA,UACF;AAEA,cAAI,iBAAiB,UAAU,KAAK;AAAA,QACtC;AAEA,YAAI,KAAK,UAAU,WAAW,QAAQ,SAAS,MAAM;AACnD,cAAI,iBAAiB,SAAS,SAAS,KAAK,KAAK,IAAI,KAAK,MAAM,CAAC,EAAE;AACnE,yBAAe,iBAAiB;AAAA,QAClC,OAAO;AACL,yBAAe,iBAAiB;AAAA,QAClC;AAEA,YAAI,eAAe;AAEnB,YAAI,KAAK,SAAS;AAChB,cAAI,UAAU,SAAU,KAAK;AAC3B,iBAAK,QAAQ,IAAI,MAAM;AAAA,UACzB;AAAA,QACF;AAEA,YAAI,qBAAqB,KAAK,cAAc,KAAK,MAAM,KAAK;AAC5D,YAAI,aAAa,KAAK,WAAW,KAAK,MAAM,KAAK;AACjD,uBAAe,oBAAoB,KAAK;AACxC,uBAAe,SAAS,KAAK;AAC7B,uBAAe,UAAU,KAAK;AAC9B,uBAAe,aAAa,KAAK;AACjC,YAAI,KAAK,IAAI;AACb,eAAO;AAAA,MACT;AAAA,MAEA,WAAW,OAAO,KAAK;AACrB,cAAM,iBAAiB,KAAK,gBAAgB,KAAK;AAEjD,YAAI,CAAC,gBAAgB;AAEnB;AAAA,QACF;AAEA,YAAI,eAAe,YAAY;AAC7B,yBAAe,WAAW,GAAG;AAAA,QAC/B;AAAA,MACF;AAAA,MAEA,cAAc,OAAO,KAAK;AACxB,cAAM,iBAAiB,KAAK,gBAAgB,KAAK;AAEjD,YAAI,CAAC,gBAAgB;AAEnB;AAAA,QACF;AAEA,cAAM,MAAM,eAAe;AAE3B,YAAI,IAAI,cAAc,KAAK,eAAe,mBAAmB;AAC3D,yBAAe,kBAAkB;AACjC,iBAAO,eAAe;AAAA,QACxB;AAEA,YAAI,IAAI,eAAe,GAAG;AACxB;AAAA,QACF;AAEA,YAAI,EAAE,SAAS,KAAK,kBAAkB;AAGpC;AAAA,QACF;AAEA,eAAO,KAAK,gBAAgB,KAAK;AAEjC,YAAI,IAAI,WAAW,KAAK,KAAK,QAAQ;AACnC,cAAI,eAAe,SAAS;AAC1B,2BAAe,QAAQ,IAAI,MAAM;AAAA,UACnC;AAEA;AAAA,QACF;AAEA,cAAM,YAAY,IAAI,UAAU;AAIhC,cAAM,+BAA+B,cAAc,eAAe,eAAe,mBAAmB;AAEpG,YAAI,CAAC,gCAAgC,cAAc,eAAe,gBAAgB;AAChF,cAAI,eAAe,SAAS;AAC1B,2BAAe,QAAQ,IAAI,MAAM;AAAA,UACnC;AAEA;AAAA,QACF;AAEA,cAAM,QAAQ,eAAe,GAAG;AAEhC,YAAI,cAAc,0BAA0B;AAC1C,gBAAM,cAAc,IAAI,kBAAkB,eAAe;AACzD,gBAAM,UAAU,2BAA2B,KAAK,WAAW;AAC3D,yBAAe,OAAO;AAAA,YACpB,OAAO,SAAS,QAAQ,CAAC,GAAG,EAAE;AAAA,YAC9B;AAAA,UACF,CAAC;AAAA,QACH,WAAW,OAAO;AAChB,yBAAe,OAAO;AAAA,YACpB,OAAO;AAAA,YACP;AAAA,UACF,CAAC;AAAA,QACH,WAAW,eAAe,SAAS;AACjC,yBAAe,QAAQ,IAAI,MAAM;AAAA,QACnC;AAAA,MACF;AAAA,MAEA,cAAc,OAAO;AACnB,eAAO,KAAK,gBAAgB,KAAK,EAAE;AAAA,MACrC;AAAA,MAEA,iBAAiB,OAAO;AACtB,eAAO,SAAS,KAAK;AAAA,MACvB;AAAA,MAEA,aAAa,OAAO;AAClB,cAAM,MAAM,KAAK,gBAAgB,KAAK,EAAE;AACxC,eAAO,KAAK,gBAAgB,KAAK;AACjC,YAAI,MAAM;AAAA,MACZ;AAAA,IAEF;AAIA,IAAM,mBAAN,MAAuB;AAAA,MACrB,YAAY,QAAQ;AAClB,aAAK,UAAU;AACf,aAAK,WAAW,IAAI,eAAe,OAAO,KAAK;AAAA,UAC7C,aAAa,OAAO;AAAA,UACpB,iBAAiB,OAAO;AAAA,QAC1B,CAAC;AACD,aAAK,kBAAkB,OAAO;AAC9B,aAAK,qBAAqB;AAC1B,aAAK,uBAAuB,CAAC;AAAA,MAC/B;AAAA,MAEA,4BAA4B,QAAQ;AAClC,cAAM,IAAI,KAAK,qBAAqB,QAAQ,MAAM;AAElD,YAAI,KAAK,GAAG;AACV,eAAK,qBAAqB,OAAO,GAAG,CAAC;AAAA,QACvC;AAAA,MACF;AAAA,MAEA,gBAAgB;AACd,eAAO,CAAC,KAAK,oBAAoB,yDAAyD;AAC1F,aAAK,qBAAqB,IAAI,kCAAkC,KAAK,UAAU,KAAK,OAAO;AAC3F,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,eAAe,OAAO,KAAK;AACzB,cAAM,SAAS,IAAI,mCAAmC,KAAK,UAAU,OAAO,GAAG;AAC/E,eAAO,WAAW,KAAK,4BAA4B,KAAK,IAAI;AAE5D,aAAK,qBAAqB,KAAK,MAAM;AAErC,eAAO;AAAA,MACT;AAAA,MAEA,kBAAkB,QAAQ;AACxB,YAAI,KAAK,oBAAoB;AAC3B,eAAK,mBAAmB,OAAO,MAAM;AAAA,QACvC;AAEA,mBAAW,UAAU,KAAK,qBAAqB,MAAM,CAAC,GAAG;AACvD,iBAAO,OAAO,MAAM;AAAA,QACtB;AAAA,MACF;AAAA,IAEF;AAIA,IAAM,oCAAN,MAAwC;AAAA,MACtC,YAAY,SAAS,QAAQ;AAC3B,aAAK,WAAW;AAChB,cAAM,OAAO;AAAA,UACX,mBAAmB,KAAK,mBAAmB,KAAK,IAAI;AAAA,UACpD,QAAQ,KAAK,QAAQ,KAAK,IAAI;AAAA,UAC9B,SAAS,KAAK,SAAS,KAAK,IAAI;AAAA,UAChC,YAAY,KAAK,YAAY,KAAK,IAAI;AAAA,QACxC;AACA,aAAK,OAAO,OAAO;AACnB,aAAK,iBAAiB,QAAQ,YAAY,IAAI;AAC9C,aAAK,6BAA6B,wBAAwB;AAC1D,aAAK,gBAAgB,OAAO,gBAAgB;AAC5C,aAAK,iBAAiB,OAAO;AAE7B,aAAK,kBAAkB,OAAO;AAE9B,YAAI,CAAC,KAAK,mBAAmB,CAAC,KAAK,eAAe;AAChD,eAAK,gBAAgB;AAAA,QACvB;AAEA,aAAK,wBAAwB;AAC7B,aAAK,oBAAoB;AACzB,aAAK,gBAAgB,CAAC;AACtB,aAAK,YAAY,CAAC;AAClB,aAAK,QAAQ;AACb,aAAK,eAAe;AACpB,aAAK,YAAY;AACjB,aAAK,aAAa;AAAA,MACpB;AAAA,MAEA,qBAAqB;AACnB,cAAM,mBAAmB,KAAK;AAE9B,cAAM,iBAAiB,KAAK,SAAS,cAAc,gBAAgB;AAEnE,cAAM,oBAAoB,UAAQ;AAChC,iBAAO,eAAe,kBAAkB,IAAI;AAAA,QAC9C;AAEA,cAAM;AAAA,UACJ;AAAA,UACA;AAAA,QACF,IAAI,iCAAiC;AAAA,UACnC;AAAA,UACA,QAAQ,KAAK,SAAS;AAAA,UACtB,gBAAgB,KAAK;AAAA,UACrB,cAAc,KAAK;AAAA,QACrB,CAAC;AAED,YAAI,oBAAoB;AACtB,eAAK,oBAAoB;AAAA,QAC3B;AAGA,aAAK,iBAAiB,mBAAmB,KAAK;AAC9C,aAAK,YAAY,0BAA0B,iBAAiB;AAE5D,YAAI,KAAK,mBAAmB;AAK1B,eAAK,SAAS,aAAa,gBAAgB;AAAA,QAC7C;AAEA,aAAK,2BAA2B,QAAQ;AAAA,MAC1C;AAAA,MAEA,QAAQ,MAAM;AACZ,YAAI,MAAM;AACR,cAAI,KAAK,UAAU,SAAS,GAAG;AAC7B,kBAAM,oBAAoB,KAAK,UAAU,MAAM;AAE/C,8BAAkB,QAAQ;AAAA,cACxB,OAAO,KAAK;AAAA,cACZ,MAAM;AAAA,YACR,CAAC;AAAA,UACH,OAAO;AACL,iBAAK,cAAc,KAAK,KAAK,KAAK;AAAA,UACpC;AAAA,QACF;AAEA,aAAK,QAAQ;AAEb,YAAI,KAAK,cAAc,SAAS,GAAG;AACjC;AAAA,QACF;AAEA,mBAAW,qBAAqB,KAAK,WAAW;AAC9C,4BAAkB,QAAQ;AAAA,YACxB,OAAO;AAAA,YACP,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AAEA,aAAK,UAAU,SAAS;AAAA,MAC1B;AAAA,MAEA,SAAS,QAAQ;AACf,cAAM,MAAM,KAAK;AACjB,cAAM,YAAY,0BAA0B,QAAQ,GAAG;AACvD,aAAK,eAAe;AAEpB,aAAK,2BAA2B,OAAO,SAAS;AAEhD,mBAAW,qBAAqB,KAAK,WAAW;AAC9C,4BAAkB,OAAO,SAAS;AAAA,QACpC;AAEA,aAAK,UAAU,SAAS;AACxB,aAAK,cAAc,SAAS;AAAA,MAC9B;AAAA,MAEA,YAAY,MAAM;AAChB,YAAI,KAAK,YAAY;AACnB,eAAK,WAAW;AAAA,YACd,QAAQ,KAAK;AAAA,YACb,OAAO,KAAK,mBAAmB,KAAK,QAAQ,KAAK;AAAA,UACnD,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MAEA,IAAI,WAAW;AACb,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,IAAI,mBAAmB;AACrB,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,IAAI,uBAAuB;AACzB,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,IAAI,gBAAgB;AAClB,eAAO,KAAK;AAAA,MACd;AAAA,MAEA,IAAI,eAAe;AACjB,eAAO,KAAK,2BAA2B;AAAA,MACzC;AAAA,MAEA,MAAM,OAAO;AACX,YAAI,KAAK,cAAc;AACrB,gBAAM,KAAK;AAAA,QACb;AAEA,YAAI,KAAK,cAAc,SAAS,GAAG;AACjC,gBAAM,QAAQ,KAAK,cAAc,MAAM;AAEvC,iBAAO;AAAA,YACL,OAAO;AAAA,YACP,MAAM;AAAA,UACR;AAAA,QACF;AAEA,YAAI,KAAK,OAAO;AACd,iBAAO;AAAA,YACL,OAAO;AAAA,YACP,MAAM;AAAA,UACR;AAAA,QACF;AAEA,cAAM,oBAAoB,wBAAwB;AAElD,aAAK,UAAU,KAAK,iBAAiB;AAErC,eAAO,kBAAkB;AAAA,MAC3B;AAAA,MAEA,OAAO,QAAQ;AACb,aAAK,QAAQ;AAEb,aAAK,2BAA2B,OAAO,MAAM;AAE7C,mBAAW,qBAAqB,KAAK,WAAW;AAC9C,4BAAkB,QAAQ;AAAA,YACxB,OAAO;AAAA,YACP,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AAEA,aAAK,UAAU,SAAS;AAExB,YAAI,KAAK,SAAS,iBAAiB,KAAK,cAAc,GAAG;AACvD,eAAK,SAAS,aAAa,KAAK,cAAc;AAAA,QAChD;AAEA,aAAK,qBAAqB;AAAA,MAC5B;AAAA,IAEF;AAIA,IAAM,qCAAN,MAAyC;AAAA,MACvC,YAAY,SAAS,OAAO,KAAK;AAC/B,aAAK,WAAW;AAChB,cAAM,OAAO;AAAA,UACX,QAAQ,KAAK,QAAQ,KAAK,IAAI;AAAA,UAC9B,YAAY,KAAK,YAAY,KAAK,IAAI;AAAA,QACxC;AACA,aAAK,aAAa,QAAQ,aAAa,OAAO,KAAK,IAAI;AACvD,aAAK,YAAY,CAAC;AAClB,aAAK,eAAe;AACpB,aAAK,QAAQ;AACb,aAAK,aAAa;AAClB,aAAK,WAAW;AAAA,MAClB;AAAA,MAEA,SAAS;AACP,YAAI,KAAK,UAAU;AACjB,eAAK,SAAS,IAAI;AAAA,QACpB;AAAA,MACF;AAAA,MAEA,QAAQ,MAAM;AACZ,cAAM,QAAQ,KAAK;AAEnB,YAAI,KAAK,UAAU,SAAS,GAAG;AAC7B,gBAAM,oBAAoB,KAAK,UAAU,MAAM;AAE/C,4BAAkB,QAAQ;AAAA,YACxB,OAAO;AAAA,YACP,MAAM;AAAA,UACR,CAAC;AAAA,QACH,OAAO;AACL,eAAK,eAAe;AAAA,QACtB;AAEA,aAAK,QAAQ;AAEb,mBAAW,qBAAqB,KAAK,WAAW;AAC9C,4BAAkB,QAAQ;AAAA,YACxB,OAAO;AAAA,YACP,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AAEA,aAAK,UAAU,SAAS;AAExB,aAAK,OAAO;AAAA,MACd;AAAA,MAEA,YAAY,KAAK;AACf,YAAI,CAAC,KAAK,wBAAwB,KAAK,YAAY;AACjD,eAAK,WAAW;AAAA,YACd,QAAQ,IAAI;AAAA,UACd,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MAEA,IAAI,uBAAuB;AACzB,eAAO;AAAA,MACT;AAAA,MAEA,MAAM,OAAO;AACX,YAAI,KAAK,iBAAiB,MAAM;AAC9B,gBAAM,QAAQ,KAAK;AACnB,eAAK,eAAe;AACpB,iBAAO;AAAA,YACL,OAAO;AAAA,YACP,MAAM;AAAA,UACR;AAAA,QACF;AAEA,YAAI,KAAK,OAAO;AACd,iBAAO;AAAA,YACL,OAAO;AAAA,YACP,MAAM;AAAA,UACR;AAAA,QACF;AAEA,cAAM,oBAAoB,wBAAwB;AAElD,aAAK,UAAU,KAAK,iBAAiB;AAErC,eAAO,kBAAkB;AAAA,MAC3B;AAAA,MAEA,OAAO,QAAQ;AACb,aAAK,QAAQ;AAEb,mBAAW,qBAAqB,KAAK,WAAW;AAC9C,4BAAkB,QAAQ;AAAA,YACxB,OAAO;AAAA,YACP,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AAEA,aAAK,UAAU,SAAS;AAExB,YAAI,KAAK,SAAS,iBAAiB,KAAK,UAAU,GAAG;AACnD,eAAK,SAAS,aAAa,KAAK,UAAU;AAAA,QAC5C;AAEA,aAAK,OAAO;AAAA,MACd;AAAA,IAEF;AAAA;AAAA;",
  "names": []
}
