import "./chunk-3GO5JVIW.js";
import "./chunk-WWKQS7HW.js";
import "./chunk-75LLYA4O.js";
import {
  getDefaultOptions,
  toInteger
} from "./chunk-Z5UCBTGL.js";
import {
  requiredArgs,
  toDate
} from "./chunk-SS6PZAAV.js";
import {
  customElement,
  property,
  query
} from "./chunk-CXSICU4N.js";
import {
  LitElement
} from "./chunk-25Y4ITXF.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import {
  html,
  nothing
} from "./chunk-QO3ZNG6F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/date-fns/_lib/requiredArgs/index.js
var require_requiredArgs = __commonJS({
  "node_modules/date-fns/_lib/requiredArgs/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = requiredArgs2;
    function requiredArgs2(required, args) {
      if (args.length < required) {
        throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/isDate/index.js
var require_isDate = __commonJS({
  "node_modules/date-fns/isDate/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isDate2;
    var _index = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function isDate2(value) {
      (0, _index.default)(1, arguments);
      return value instanceof Date || _typeof(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/toDate/index.js
var require_toDate = __commonJS({
  "node_modules/date-fns/toDate/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toDate3;
    var _index = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function toDate3(argument) {
      (0, _index.default)(1, arguments);
      var argStr = Object.prototype.toString.call(argument);
      if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
        return new Date(argument.getTime());
      } else if (typeof argument === "number" || argStr === "[object Number]") {
        return new Date(argument);
      } else {
        if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
          console.warn(new Error().stack);
        }
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/isValid/index.js
var require_isValid = __commonJS({
  "node_modules/date-fns/isValid/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValid2;
    var _index = _interopRequireDefault(require_isDate());
    var _index2 = _interopRequireDefault(require_toDate());
    var _index3 = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isValid2(dirtyDate) {
      (0, _index3.default)(1, arguments);
      if (!(0, _index.default)(dirtyDate) && typeof dirtyDate !== "number") {
        return false;
      }
      var date = (0, _index2.default)(dirtyDate);
      return !isNaN(Number(date));
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/toInteger/index.js
var require_toInteger = __commonJS({
  "node_modules/date-fns/_lib/toInteger/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toInteger3;
    function toInteger3(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }
      var number = Number(dirtyNumber);
      if (isNaN(number)) {
        return number;
      }
      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/addMilliseconds/index.js
var require_addMilliseconds = __commonJS({
  "node_modules/date-fns/addMilliseconds/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addMilliseconds2;
    var _index = _interopRequireDefault(require_toInteger());
    var _index2 = _interopRequireDefault(require_toDate());
    var _index3 = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function addMilliseconds2(dirtyDate, dirtyAmount) {
      (0, _index3.default)(2, arguments);
      var timestamp = (0, _index2.default)(dirtyDate).getTime();
      var amount = (0, _index.default)(dirtyAmount);
      return new Date(timestamp + amount);
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/subMilliseconds/index.js
var require_subMilliseconds = __commonJS({
  "node_modules/date-fns/subMilliseconds/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = subMilliseconds2;
    var _index = _interopRequireDefault(require_addMilliseconds());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_toInteger());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function subMilliseconds2(dirtyDate, dirtyAmount) {
      (0, _index2.default)(2, arguments);
      var amount = (0, _index3.default)(dirtyAmount);
      return (0, _index.default)(dirtyDate, -amount);
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCDayOfYear/index.js
var require_getUTCDayOfYear = __commonJS({
  "node_modules/date-fns/_lib/getUTCDayOfYear/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCDayOfYear;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MILLISECONDS_IN_DAY2 = 864e5;
    function getUTCDayOfYear(dirtyDate) {
      (0, _index2.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY2) + 1;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/startOfUTCISOWeek/index.js
var require_startOfUTCISOWeek = __commonJS({
  "node_modules/date-fns/_lib/startOfUTCISOWeek/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = startOfUTCISOWeek;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function startOfUTCISOWeek(dirtyDate) {
      (0, _index2.default)(1, arguments);
      var weekStartsOn = 1;
      var date = (0, _index.default)(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCISOWeekYear/index.js
var require_getUTCISOWeekYear = __commonJS({
  "node_modules/date-fns/_lib/getUTCISOWeekYear/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCISOWeekYear;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_startOfUTCISOWeek());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getUTCISOWeekYear(dirtyDate) {
      (0, _index2.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = (0, _index3.default)(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = (0, _index3.default)(fourthOfJanuaryOfThisYear);
      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/startOfUTCISOWeekYear/index.js
var require_startOfUTCISOWeekYear = __commonJS({
  "node_modules/date-fns/_lib/startOfUTCISOWeekYear/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = startOfUTCISOWeekYear;
    var _index = _interopRequireDefault(require_getUTCISOWeekYear());
    var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
    var _index3 = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function startOfUTCISOWeekYear(dirtyDate) {
      (0, _index3.default)(1, arguments);
      var year = (0, _index.default)(dirtyDate);
      var fourthOfJanuary = /* @__PURE__ */ new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = (0, _index2.default)(fourthOfJanuary);
      return date;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCISOWeek/index.js
var require_getUTCISOWeek = __commonJS({
  "node_modules/date-fns/_lib/getUTCISOWeek/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCISOWeek;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
    var _index3 = _interopRequireDefault(require_startOfUTCISOWeekYear());
    var _index4 = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MILLISECONDS_IN_WEEK2 = 6048e5;
    function getUTCISOWeek(dirtyDate) {
      (0, _index4.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var diff = (0, _index2.default)(date).getTime() - (0, _index3.default)(date).getTime();
      return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/defaultOptions/index.js
var require_defaultOptions = __commonJS({
  "node_modules/date-fns/_lib/defaultOptions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getDefaultOptions = getDefaultOptions3;
    exports.setDefaultOptions = setDefaultOptions3;
    var defaultOptions = {};
    function getDefaultOptions3() {
      return defaultOptions;
    }
    function setDefaultOptions3(newOptions) {
      defaultOptions = newOptions;
    }
  }
});

// node_modules/date-fns/_lib/startOfUTCWeek/index.js
var require_startOfUTCWeek = __commonJS({
  "node_modules/date-fns/_lib/startOfUTCWeek/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = startOfUTCWeek;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_toInteger());
    var _index4 = require_defaultOptions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function startOfUTCWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      (0, _index2.default)(1, arguments);
      var defaultOptions = (0, _index4.getDefaultOptions)();
      var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
      }
      var date = (0, _index.default)(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCWeekYear/index.js
var require_getUTCWeekYear = __commonJS({
  "node_modules/date-fns/_lib/getUTCWeekYear/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCWeekYear;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_startOfUTCWeek());
    var _index4 = _interopRequireDefault(require_toInteger());
    var _index5 = require_defaultOptions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      (0, _index2.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var year = date.getUTCFullYear();
      var defaultOptions = (0, _index5.getDefaultOptions)();
      var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
      }
      var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = (0, _index3.default)(firstWeekOfNextYear, options);
      var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = (0, _index3.default)(firstWeekOfThisYear, options);
      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/startOfUTCWeekYear/index.js
var require_startOfUTCWeekYear = __commonJS({
  "node_modules/date-fns/_lib/startOfUTCWeekYear/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = startOfUTCWeekYear;
    var _index = _interopRequireDefault(require_getUTCWeekYear());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    var _index3 = _interopRequireDefault(require_startOfUTCWeek());
    var _index4 = _interopRequireDefault(require_toInteger());
    var _index5 = require_defaultOptions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function startOfUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      (0, _index2.default)(1, arguments);
      var defaultOptions = (0, _index5.getDefaultOptions)();
      var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      var year = (0, _index.default)(dirtyDate, options);
      var firstWeek = /* @__PURE__ */ new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = (0, _index3.default)(firstWeek, options);
      return date;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getUTCWeek/index.js
var require_getUTCWeek = __commonJS({
  "node_modules/date-fns/_lib/getUTCWeek/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getUTCWeek;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_startOfUTCWeek());
    var _index3 = _interopRequireDefault(require_startOfUTCWeekYear());
    var _index4 = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MILLISECONDS_IN_WEEK2 = 6048e5;
    function getUTCWeek(dirtyDate, options) {
      (0, _index4.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      var diff = (0, _index2.default)(date, options).getTime() - (0, _index3.default)(date, options).getTime();
      return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/addLeadingZeros/index.js
var require_addLeadingZeros = __commonJS({
  "node_modules/date-fns/_lib/addLeadingZeros/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = addLeadingZeros3;
    function addLeadingZeros3(number, targetLength) {
      var sign = number < 0 ? "-" : "";
      var output = Math.abs(number).toString();
      while (output.length < targetLength) {
        output = "0" + output;
      }
      return sign + output;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/format/lightFormatters/index.js
var require_lightFormatters = __commonJS({
  "node_modules/date-fns/_lib/format/lightFormatters/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_addLeadingZeros());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var formatters2 = {
      // Year
      y: function y(date, token) {
        var signedYear = date.getUTCFullYear();
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return (0, _index.default)(token === "yy" ? year % 100 : year, token.length);
      },
      // Month
      M: function M(date, token) {
        var month = date.getUTCMonth();
        return token === "M" ? String(month + 1) : (0, _index.default)(month + 1, 2);
      },
      // Day of the month
      d: function d(date, token) {
        return (0, _index.default)(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function a(date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaa":
            return dayPeriodEnumValue;
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      // Hour [1-12]
      h: function h(date, token) {
        return (0, _index.default)(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function H(date, token) {
        return (0, _index.default)(date.getUTCHours(), token.length);
      },
      // Minute
      m: function m(date, token) {
        return (0, _index.default)(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function s(date, token) {
        return (0, _index.default)(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function S(date, token) {
        var numberOfDigits = token.length;
        var milliseconds2 = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds2 * Math.pow(10, numberOfDigits - 3));
        return (0, _index.default)(fractionalSeconds, token.length);
      }
    };
    var _default = formatters2;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/format/formatters/index.js
var require_formatters = __commonJS({
  "node_modules/date-fns/_lib/format/formatters/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_getUTCDayOfYear());
    var _index2 = _interopRequireDefault(require_getUTCISOWeek());
    var _index3 = _interopRequireDefault(require_getUTCISOWeekYear());
    var _index4 = _interopRequireDefault(require_getUTCWeek());
    var _index5 = _interopRequireDefault(require_getUTCWeekYear());
    var _index6 = _interopRequireDefault(require_addLeadingZeros());
    var _index7 = _interopRequireDefault(require_lightFormatters());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    var formatters2 = {
      // Era
      G: function G(date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return localize.era(era, {
              width: "abbreviated"
            });
          case "GGGGG":
            return localize.era(era, {
              width: "narrow"
            });
          case "GGGG":
          default:
            return localize.era(era, {
              width: "wide"
            });
        }
      },
      // Year
      y: function y(date, token, localize) {
        if (token === "yo") {
          var signedYear = date.getUTCFullYear();
          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, {
            unit: "year"
          });
        }
        return _index7.default.y(date, token);
      },
      // Local week-numbering year
      Y: function Y(date, token, localize, options) {
        var signedWeekYear = (0, _index5.default)(date, options);
        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token === "YY") {
          var twoDigitYear = weekYear % 100;
          return (0, _index6.default)(twoDigitYear, 2);
        }
        if (token === "Yo") {
          return localize.ordinalNumber(weekYear, {
            unit: "year"
          });
        }
        return (0, _index6.default)(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function R(date, token) {
        var isoWeekYear = (0, _index3.default)(date);
        return (0, _index6.default)(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function u(date, token) {
        var year = date.getUTCFullYear();
        return (0, _index6.default)(year, token.length);
      },
      // Quarter
      Q: function Q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          case "Q":
            return String(quarter);
          case "QQ":
            return (0, _index6.default)(quarter, 2);
          case "Qo":
            return localize.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "QQQ":
            return localize.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          case "QQQQQ":
            return localize.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return localize.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone quarter
      q: function q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          case "q":
            return String(quarter);
          case "qq":
            return (0, _index6.default)(quarter, 2);
          case "qo":
            return localize.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "qqq":
            return localize.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          case "qqqqq":
            return localize.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return localize.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Month
      M: function M(date, token, localize) {
        var month = date.getUTCMonth();
        switch (token) {
          case "M":
          case "MM":
            return _index7.default.M(date, token);
          case "Mo":
            return localize.ordinalNumber(month + 1, {
              unit: "month"
            });
          case "MMM":
            return localize.month(month, {
              width: "abbreviated",
              context: "formatting"
            });
          case "MMMMM":
            return localize.month(month, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return localize.month(month, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone month
      L: function L(date, token, localize) {
        var month = date.getUTCMonth();
        switch (token) {
          case "L":
            return String(month + 1);
          case "LL":
            return (0, _index6.default)(month + 1, 2);
          case "Lo":
            return localize.ordinalNumber(month + 1, {
              unit: "month"
            });
          case "LLL":
            return localize.month(month, {
              width: "abbreviated",
              context: "standalone"
            });
          case "LLLLL":
            return localize.month(month, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return localize.month(month, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Local week of year
      w: function w(date, token, localize, options) {
        var week = (0, _index4.default)(date, options);
        if (token === "wo") {
          return localize.ordinalNumber(week, {
            unit: "week"
          });
        }
        return (0, _index6.default)(week, token.length);
      },
      // ISO week of year
      I: function I(date, token, localize) {
        var isoWeek = (0, _index2.default)(date);
        if (token === "Io") {
          return localize.ordinalNumber(isoWeek, {
            unit: "week"
          });
        }
        return (0, _index6.default)(isoWeek, token.length);
      },
      // Day of the month
      d: function d(date, token, localize) {
        if (token === "do") {
          return localize.ordinalNumber(date.getUTCDate(), {
            unit: "date"
          });
        }
        return _index7.default.d(date, token);
      },
      // Day of year
      D: function D(date, token, localize) {
        var dayOfYear = (0, _index.default)(date);
        if (token === "Do") {
          return localize.ordinalNumber(dayOfYear, {
            unit: "dayOfYear"
          });
        }
        return (0, _index6.default)(dayOfYear, token.length);
      },
      // Day of week
      E: function E(date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "EEEEE":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "EEEE":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Local day of week
      e: function e(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "e":
            return String(localDayOfWeek);
          case "ee":
            return (0, _index6.default)(localDayOfWeek, 2);
          case "eo":
            return localize.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "eee":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "eeeee":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "eeee":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone local day of week
      c: function c(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "c":
            return String(localDayOfWeek);
          case "cc":
            return (0, _index6.default)(localDayOfWeek, token.length);
          case "co":
            return localize.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "ccc":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          case "ccccc":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          case "cccc":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // ISO day of week
      i: function i(date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
          case "i":
            return String(isoDayOfWeek);
          case "ii":
            return (0, _index6.default)(isoDayOfWeek, token.length);
          case "io":
            return localize.ordinalNumber(isoDayOfWeek, {
              unit: "day"
            });
          case "iii":
            return localize.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "iiiii":
            return localize.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "iiiiii":
            return localize.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "iiii":
          default:
            return localize.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM or PM
      a: function a(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "aaaaa":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM, PM, midnight, noon
      b: function b(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token) {
          case "b":
          case "bb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "bbbbb":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function B(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Hour [1-12]
      h: function h(date, token, localize) {
        if (token === "ho") {
          var hours = date.getUTCHours() % 12;
          if (hours === 0)
            hours = 12;
          return localize.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return _index7.default.h(date, token);
      },
      // Hour [0-23]
      H: function H(date, token, localize) {
        if (token === "Ho") {
          return localize.ordinalNumber(date.getUTCHours(), {
            unit: "hour"
          });
        }
        return _index7.default.H(date, token);
      },
      // Hour [0-11]
      K: function K(date, token, localize) {
        var hours = date.getUTCHours() % 12;
        if (token === "Ko") {
          return localize.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return (0, _index6.default)(hours, token.length);
      },
      // Hour [1-24]
      k: function k(date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0)
          hours = 24;
        if (token === "ko") {
          return localize.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return (0, _index6.default)(hours, token.length);
      },
      // Minute
      m: function m(date, token, localize) {
        if (token === "mo") {
          return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: "minute"
          });
        }
        return _index7.default.m(date, token);
      },
      // Second
      s: function s(date, token, localize) {
        if (token === "so") {
          return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: "second"
          });
        }
        return _index7.default.s(date, token);
      },
      // Fraction of second
      S: function S(date, token) {
        return _index7.default.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function X(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token) {
          case "X":
            return formatTimezoneWithOptionalMinutes2(timezoneOffset);
          case "XXXX":
          case "XX":
            return formatTimezone2(timezoneOffset);
          case "XXXXX":
          case "XXX":
          default:
            return formatTimezone2(timezoneOffset, ":");
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function x(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "x":
            return formatTimezoneWithOptionalMinutes2(timezoneOffset);
          case "xxxx":
          case "xx":
            return formatTimezone2(timezoneOffset);
          case "xxxxx":
          case "xxx":
          default:
            return formatTimezone2(timezoneOffset, ":");
        }
      },
      // Timezone (GMT)
      O: function O(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort2(timezoneOffset, ":");
          case "OOOO":
          default:
            return "GMT" + formatTimezone2(timezoneOffset, ":");
        }
      },
      // Timezone (specific non-location)
      z: function z(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort2(timezoneOffset, ":");
          case "zzzz":
          default:
            return "GMT" + formatTimezone2(timezoneOffset, ":");
        }
      },
      // Seconds timestamp
      t: function t(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1e3);
        return (0, _index6.default)(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function T(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return (0, _index6.default)(timestamp, token.length);
      }
    };
    function formatTimezoneShort2(offset, dirtyDelimiter) {
      var sign = offset > 0 ? "-" : "+";
      var absOffset = Math.abs(offset);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;
      if (minutes === 0) {
        return sign + String(hours);
      }
      var delimiter = dirtyDelimiter || "";
      return sign + String(hours) + delimiter + (0, _index6.default)(minutes, 2);
    }
    function formatTimezoneWithOptionalMinutes2(offset, dirtyDelimiter) {
      if (offset % 60 === 0) {
        var sign = offset > 0 ? "-" : "+";
        return sign + (0, _index6.default)(Math.abs(offset) / 60, 2);
      }
      return formatTimezone2(offset, dirtyDelimiter);
    }
    function formatTimezone2(offset, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || "";
      var sign = offset > 0 ? "-" : "+";
      var absOffset = Math.abs(offset);
      var hours = (0, _index6.default)(Math.floor(absOffset / 60), 2);
      var minutes = (0, _index6.default)(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }
    var _default = formatters2;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/format/longFormatters/index.js
var require_longFormatters = __commonJS({
  "node_modules/date-fns/_lib/format/longFormatters/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var dateLongFormatter = function dateLongFormatter2(pattern, formatLong) {
      switch (pattern) {
        case "P":
          return formatLong.date({
            width: "short"
          });
        case "PP":
          return formatLong.date({
            width: "medium"
          });
        case "PPP":
          return formatLong.date({
            width: "long"
          });
        case "PPPP":
        default:
          return formatLong.date({
            width: "full"
          });
      }
    };
    var timeLongFormatter = function timeLongFormatter2(pattern, formatLong) {
      switch (pattern) {
        case "p":
          return formatLong.time({
            width: "short"
          });
        case "pp":
          return formatLong.time({
            width: "medium"
          });
        case "ppp":
          return formatLong.time({
            width: "long"
          });
        case "pppp":
        default:
          return formatLong.time({
            width: "full"
          });
      }
    };
    var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong) {
      var matchResult = pattern.match(/(P+)(p+)?/) || [];
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }
      var dateTimeFormat;
      switch (datePattern) {
        case "P":
          dateTimeFormat = formatLong.dateTime({
            width: "short"
          });
          break;
        case "PP":
          dateTimeFormat = formatLong.dateTime({
            width: "medium"
          });
          break;
        case "PPP":
          dateTimeFormat = formatLong.dateTime({
            width: "long"
          });
          break;
        case "PPPP":
        default:
          dateTimeFormat = formatLong.dateTime({
            width: "full"
          });
          break;
      }
      return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
    };
    var longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    var _default = longFormatters;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js
var require_getTimezoneOffsetInMilliseconds = __commonJS({
  "node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getTimezoneOffsetInMilliseconds3;
    function getTimezoneOffsetInMilliseconds3(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/protectedTokens/index.js
var require_protectedTokens = __commonJS({
  "node_modules/date-fns/_lib/protectedTokens/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
    exports.isProtectedWeekYearToken = isProtectedWeekYearToken;
    exports.throwProtectedError = throwProtectedError;
    var protectedDayOfYearTokens = ["D", "DD"];
    var protectedWeekYearTokens = ["YY", "YYYY"];
    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }
    function throwProtectedError(token, format3, input) {
      if (token === "YYYY") {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format3, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === "YY") {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format3, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === "D") {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format3, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === "DD") {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format3, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      }
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatDistance/index.js
var require_formatDistance = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatDistance/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    var formatDistance2 = function formatDistance3(token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count.toString());
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result;
        } else {
          return result + " ago";
        }
      }
      return result;
    };
    var _default = formatDistance2;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/_lib/buildFormatLongFn/index.js
var require_buildFormatLongFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildFormatLongFn/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildFormatLongFn;
    function buildFormatLongFn(args) {
      return function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format3 = args.formats[width] || args.formats[args.defaultWidth];
        return format3;
      };
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatLong/index.js
var require_formatLong = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatLong/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_buildFormatLongFn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var dateFormats = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    var timeFormats = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    var formatLong = {
      date: (0, _index.default)({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: (0, _index.default)({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: (0, _index.default)({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
    var _default = formatLong;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatRelative/index.js
var require_formatRelative = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/formatRelative/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    var formatRelative2 = function formatRelative3(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    };
    var _default = formatRelative2;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/_lib/buildLocalizeFn/index.js
var require_buildLocalizeFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildLocalizeFn/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildLocalizeFn;
    function buildLocalizeFn(args) {
      return function(dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
        var valuesArray;
        if (context === "formatting" && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;
          var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }
        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        return valuesArray[index];
      };
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/_lib/localize/index.js
var require_localize = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/localize/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_buildLocalizeFn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var eraValues = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    var quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    var monthValues = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };
    var dayValues = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    };
    var dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      var rem100 = number % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + "st";
          case 2:
            return number + "nd";
          case 3:
            return number + "rd";
        }
      }
      return number + "th";
    };
    var localize = {
      ordinalNumber,
      era: (0, _index.default)({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: (0, _index.default)({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: (0, _index.default)({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: (0, _index.default)({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: (0, _index.default)({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
    var _default = localize;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/_lib/buildMatchFn/index.js
var require_buildMatchFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildMatchFn/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildMatchFn;
    function buildMatchFn(args) {
      return function(string) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);
        if (!matchResult) {
          return null;
        }
        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
          return pattern.test(matchedString);
        }) : findKey(parsePatterns, function(pattern) {
          return pattern.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value,
          rest
        };
      };
    }
    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }
      return void 0;
    }
    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }
      return void 0;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/_lib/buildMatchPatternFn/index.js
var require_buildMatchPatternFn = __commonJS({
  "node_modules/date-fns/locale/_lib/buildMatchPatternFn/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = buildMatchPatternFn;
    function buildMatchPatternFn(args) {
      return function(string) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var matchResult = string.match(args.matchPattern);
        if (!matchResult)
          return null;
        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);
        if (!parseResult)
          return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value,
          rest
        };
      };
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/_lib/match/index.js
var require_match = __commonJS({
  "node_modules/date-fns/locale/en-US/_lib/match/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_buildMatchFn());
    var _index2 = _interopRequireDefault(require_buildMatchPatternFn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match = {
      ordinalNumber: (0, _index2.default)({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
          return parseInt(value, 10);
        }
      }),
      era: (0, _index.default)({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: (0, _index.default)({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: (0, _index.default)({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: (0, _index.default)({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: (0, _index.default)({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
    var _default = match;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/locale/en-US/index.js
var require_en_US = __commonJS({
  "node_modules/date-fns/locale/en-US/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_formatDistance());
    var _index2 = _interopRequireDefault(require_formatLong());
    var _index3 = _interopRequireDefault(require_formatRelative());
    var _index4 = _interopRequireDefault(require_localize());
    var _index5 = _interopRequireDefault(require_match());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var locale = {
      code: "en-US",
      formatDistance: _index.default,
      formatLong: _index2.default,
      formatRelative: _index3.default,
      localize: _index4.default,
      match: _index5.default,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    var _default = locale;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/defaultLocale/index.js
var require_defaultLocale = __commonJS({
  "node_modules/date-fns/_lib/defaultLocale/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _index = _interopRequireDefault(require_en_US());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = _index.default;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/date-fns/format/index.js
var require_format = __commonJS({
  "node_modules/date-fns/format/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = format3;
    var _index = _interopRequireDefault(require_isValid());
    var _index2 = _interopRequireDefault(require_subMilliseconds());
    var _index3 = _interopRequireDefault(require_toDate());
    var _index4 = _interopRequireDefault(require_formatters());
    var _index5 = _interopRequireDefault(require_longFormatters());
    var _index6 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
    var _index7 = require_protectedTokens();
    var _index8 = _interopRequireDefault(require_toInteger());
    var _index9 = _interopRequireDefault(require_requiredArgs());
    var _index10 = require_defaultOptions();
    var _index11 = _interopRequireDefault(require_defaultLocale());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    function format3(dirtyDate, dirtyFormatStr, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
      (0, _index9.default)(2, arguments);
      var formatStr = String(dirtyFormatStr);
      var defaultOptions = (0, _index10.getDefaultOptions)();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _index11.default;
      var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
      }
      var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
      }
      if (!locale.localize) {
        throw new RangeError("locale must contain localize property");
      }
      if (!locale.formatLong) {
        throw new RangeError("locale must contain formatLong property");
      }
      var originalDate = (0, _index3.default)(dirtyDate);
      if (!(0, _index.default)(originalDate)) {
        throw new RangeError("Invalid time value");
      }
      var timezoneOffset = (0, _index6.default)(originalDate);
      var utcDate = (0, _index2.default)(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale,
        _originalDate: originalDate
      };
      var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
        var firstCharacter = substring[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
          var longFormatter = _index5.default[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      }).join("").match(formattingTokensRegExp).map(function(substring) {
        if (substring === "''") {
          return "'";
        }
        var firstCharacter = substring[0];
        if (firstCharacter === "'") {
          return cleanEscapedString(substring);
        }
        var formatter = _index4.default[firstCharacter];
        if (formatter) {
          if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(substring)) {
            (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
          }
          if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(substring)) {
            (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
          }
          return formatter(utcDate, substring, locale.localize, formatterOptions);
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        return substring;
      }).join("");
      return result;
    }
    function cleanEscapedString(input) {
      var matched = input.match(escapedStringRegExp);
      if (!matched) {
        return input;
      }
      return matched[1].replace(doubleQuoteRegExp, "'");
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/assign/index.js
var require_assign = __commonJS({
  "node_modules/date-fns/_lib/assign/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assign2;
    function assign2(target, object) {
      if (target == null) {
        throw new TypeError("assign requires that input parameter not be null or undefined");
      }
      for (var property2 in object) {
        if (Object.prototype.hasOwnProperty.call(object, property2)) {
          ;
          target[property2] = object[property2];
        }
      }
      return target;
    }
    module.exports = exports.default;
  }
});

// node_modules/date-fns/_lib/cloneObject/index.js
var require_cloneObject = __commonJS({
  "node_modules/date-fns/_lib/cloneObject/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cloneObject4;
    var _index = _interopRequireDefault(require_assign());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function cloneObject4(object) {
      return (0, _index.default)({}, object);
    }
    module.exports = exports.default;
  }
});

// node_modules/tltv-timeline-element/dist/src/model/Resolution.js
var Resolution;
(function(Resolution2) {
  Resolution2[Resolution2["Hour"] = 1] = "Hour";
  Resolution2[Resolution2["Day"] = 2] = "Day";
  Resolution2[Resolution2["Week"] = 3] = "Week";
})(Resolution || (Resolution = {}));

// node_modules/tltv-timeline-element/dist/src/util/elementUtil.js
function getWidth(element) {
  if (!element) {
    return 0;
  }
  if (element.getBoundingClientRect()) {
    let rect = element.getBoundingClientRect();
    return rect.right - rect.left;
  } else {
    return element.offsetWidth;
  }
}
function getHeight(element) {
  if (!element) {
    return 0;
  }
  if (element.getBoundingClientRect()) {
    let rect = element.getBoundingClientRect();
    return rect.bottom - rect.top;
  } else {
    return element.offsetHeight;
  }
}
function getRight(element) {
  if (!element) {
    return 0;
  }
  if (element.getBoundingClientRect()) {
    var rect = element.getBoundingClientRect();
    return rect.right;
  } else {
    return element.offsetLeft + element.offsetWidth;
  }
}
function getLeft(element) {
  if (!element) {
    return 0;
  }
  if (element.getBoundingClientRect()) {
    var rect = element.getBoundingClientRect();
    return rect.left;
  } else {
    return element.offsetLeft;
  }
}

// node_modules/tltv-gantt-element/dist/src/gantt-timeline-mixin.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GanttTimelineMixin = (base) => {
  class GanttTimelineMixin2 extends base {
    async getTimeline() {
      let continueWhenTimelineReady = function(resolve, isReady, notReady) {
        requestAnimationFrame(() => isReady() ? resolve() : notReady(resolve, notReady));
      };
      await new Promise((resolve) => requestAnimationFrame(() => continueWhenTimelineReady(resolve, () => this._timeline, continueWhenTimelineReady)));
      return this._timeline;
    }
    getTimeZone() {
      return this._timeline.getAttribute("timezone");
    }
  }
  __decorate([
    query("#timeline")
  ], GanttTimelineMixin2.prototype, "_timeline", void 0);
  return GanttTimelineMixin2;
};

// node_modules/date-fns-tz/esm/format/index.js
var import_format = __toESM(require_format(), 1);

// node_modules/date-fns-tz/esm/_lib/tzIntlTimeZoneName/index.js
function tzIntlTimeZoneName(length, date, options) {
  var dtf = getDTF(length, options.timeZone, options.locale);
  return dtf.formatToParts ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date);
}
function partsTimeZone(dtf, date) {
  var formatted = dtf.formatToParts(date);
  for (var i = formatted.length - 1; i >= 0; --i) {
    if (formatted[i].type === "timeZoneName") {
      return formatted[i].value;
    }
  }
}
function hackyTimeZone(dtf, date) {
  var formatted = dtf.format(date).replace(/\u200E/g, "");
  var tzNameMatch = / [\w-+ ]+$/.exec(formatted);
  return tzNameMatch ? tzNameMatch[0].substr(1) : "";
}
function getDTF(length, timeZone, locale) {
  if (locale && !locale.code) {
    throw new Error(
      "date-fns-tz error: Please set a language code on the locale object imported from date-fns, e.g. `locale.code = 'en-US'`"
    );
  }
  return new Intl.DateTimeFormat(locale ? [locale.code, "en-US"] : void 0, {
    timeZone,
    timeZoneName: length
  });
}

// node_modules/date-fns-tz/esm/_lib/tzTokenizeDate/index.js
function tzTokenizeDate(date, timeZone) {
  var dtf = getDateTimeFormat(timeZone);
  return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function partsOffset(dtf, date) {
  try {
    var formatted = dtf.formatToParts(date);
    var filled = [];
    for (var i = 0; i < formatted.length; i++) {
      var pos = typeToPos[formatted[i].type];
      if (pos >= 0) {
        filled[pos] = parseInt(formatted[i].value, 10);
      }
    }
    return filled;
  } catch (error) {
    if (error instanceof RangeError) {
      return [NaN];
    }
    throw error;
  }
}
function hackyOffset(dtf, date) {
  var formatted = dtf.format(date);
  var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
  return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
}
var dtfCache = {};
function getDateTimeFormat(timeZone) {
  if (!dtfCache[timeZone]) {
    var testDateFormatted = new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z"));
    var hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
    dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return dtfCache[timeZone];
}

// node_modules/date-fns-tz/esm/_lib/newDateUTC/index.js
function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
  var utcDate = /* @__PURE__ */ new Date(0);
  utcDate.setUTCFullYear(fullYear, month, day);
  utcDate.setUTCHours(hour, minute, second, millisecond);
  return utcDate;
}

// node_modules/date-fns-tz/esm/_lib/tzParseTimezone/index.js
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE = 6e4;
var patterns = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};
function tzParseTimezone(timezoneString, date, isUtcDate) {
  var token;
  var absoluteOffset;
  if (!timezoneString) {
    return 0;
  }
  token = patterns.timezoneZ.exec(timezoneString);
  if (token) {
    return 0;
  }
  var hours;
  token = patterns.timezoneHH.exec(timezoneString);
  if (token) {
    hours = parseInt(token[1], 10);
    if (!validateTimezone(hours)) {
      return NaN;
    }
    return -(hours * MILLISECONDS_IN_HOUR);
  }
  token = patterns.timezoneHHMM.exec(timezoneString);
  if (token) {
    hours = parseInt(token[2], 10);
    var minutes = parseInt(token[3], 10);
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
    return token[1] === "+" ? -absoluteOffset : absoluteOffset;
  }
  if (isValidTimezoneIANAString(timezoneString)) {
    date = new Date(date || Date.now());
    var utcDate = isUtcDate ? date : toUtcDate(date);
    var offset = calcOffset(utcDate, timezoneString);
    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);
    return -fixedOffset;
  }
  return NaN;
}
function toUtcDate(date) {
  return newDateUTC(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  );
}
function calcOffset(date, timezoneString) {
  var tokens = tzTokenizeDate(date, timezoneString);
  var asUTC = newDateUTC(
    tokens[0],
    tokens[1] - 1,
    tokens[2],
    tokens[3] % 24,
    tokens[4],
    tokens[5],
    0
  ).getTime();
  var asTS = date.getTime();
  var over = asTS % 1e3;
  asTS -= over >= 0 ? over : 1e3 + over;
  return asUTC - asTS;
}
function fixOffset(date, offset, timezoneString) {
  var localTS = date.getTime();
  var utcGuess = localTS - offset;
  var o2 = calcOffset(new Date(utcGuess), timezoneString);
  if (offset === o2) {
    return offset;
  }
  utcGuess -= o2 - offset;
  var o3 = calcOffset(new Date(utcGuess), timezoneString);
  if (o2 === o3) {
    return o2;
  }
  return Math.max(o2, o3);
}
function validateTimezone(hours, minutes) {
  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
}
var validIANATimezoneCache = {};
function isValidTimezoneIANAString(timeZoneString) {
  if (validIANATimezoneCache[timeZoneString])
    return true;
  try {
    new Intl.DateTimeFormat(void 0, { timeZone: timeZoneString });
    validIANATimezoneCache[timeZoneString] = true;
    return true;
  } catch (error) {
    return false;
  }
}

// node_modules/date-fns-tz/esm/format/formatters/index.js
var MILLISECONDS_IN_MINUTE2 = 60 * 1e3;
var formatters = {
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, localize, options) {
    var timezoneOffset = getTimeZoneOffset(options.timeZone, date);
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, localize, options) {
    var timezoneOffset = getTimeZoneOffset(options.timeZone, date);
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, localize, options) {
    var timezoneOffset = getTimeZoneOffset(options.timeZone, date);
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, localize, options) {
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return tzIntlTimeZoneName("short", date, options);
      case "zzzz":
      default:
        return tzIntlTimeZoneName("long", date, options);
    }
  }
};
function getTimeZoneOffset(timeZone, originalDate) {
  var timeZoneOffset = timeZone ? tzParseTimezone(timeZone, originalDate, true) / MILLISECONDS_IN_MINUTE2 : originalDate.getTimezoneOffset();
  if (Number.isNaN(timeZoneOffset)) {
    throw new RangeError("Invalid time zone specified: " + timeZone);
  }
  return timeZoneOffset;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
function formatTimezone(offset, dirtyDelimeter) {
  var delimeter = dirtyDelimeter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(Math.floor(absOffset % 60), 2);
  return sign + hours + delimeter + minutes;
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimeter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimeter);
}
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
var formatters_default = formatters;

// node_modules/date-fns-tz/esm/toDate/index.js
var import_toInteger = __toESM(require_toInteger(), 1);
var import_getTimezoneOffsetInMilliseconds = __toESM(require_getTimezoneOffsetInMilliseconds(), 1);

// node_modules/date-fns-tz/esm/_lib/tzPattern/index.js
var tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
var tzPattern_default = tzPattern;

// node_modules/date-fns-tz/esm/toDate/index.js
var MILLISECONDS_IN_HOUR2 = 36e5;
var MILLISECONDS_IN_MINUTE3 = 6e4;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var patterns2 = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: tzPattern_default
};
function toDate2(argument, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  if (argument === null) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : (0, import_toInteger.default)(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
    return new Date(argument);
  } else if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var parseYearResult = parseYear(dateStrings.date, additionalDigits);
  var year = parseYearResult.year;
  var restDateString = parseYearResult.restDateString;
  var date = parseDate(restDateString, year);
  if (isNaN(date)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (date) {
    var timestamp = date.getTime();
    var time = 0;
    var offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    if (dateStrings.timeZone || options.timeZone) {
      offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));
      if (isNaN(offset)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    } else {
      offset = (0, import_getTimezoneOffsetInMilliseconds.default)(new Date(timestamp + time));
      offset = (0, import_getTimezoneOffsetInMilliseconds.default)(new Date(timestamp + time + offset));
    }
    return new Date(timestamp + time + offset);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function splitDateString(dateString) {
  var dateStrings = {};
  var parts = patterns2.dateTimePattern.exec(dateString);
  var timeString;
  if (!parts) {
    parts = patterns2.datePattern.exec(dateString);
    if (parts) {
      dateStrings.date = parts[1];
      timeString = parts[2];
    } else {
      dateStrings.date = null;
      timeString = dateString;
    }
  } else {
    dateStrings.date = parts[1];
    timeString = parts[3];
  }
  if (timeString) {
    var token = patterns2.timeZone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timeZone = token[1].trim();
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var patternYYY = patterns2.YYY[additionalDigits];
  var patternYYYYY = patterns2.YYYYY[additionalDigits];
  var token;
  token = patterns2.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
  if (token) {
    var yearString = token[1];
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    };
  }
  token = patterns2.YY.exec(dateString) || patternYYY.exec(dateString);
  if (token) {
    var centuryString = token[1];
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    };
  }
  return {
    year: null
  };
}
function parseDate(dateString, year) {
  if (year === null) {
    return null;
  }
  var token;
  var date;
  var month;
  var week;
  if (dateString.length === 0) {
    date = /* @__PURE__ */ new Date(0);
    date.setUTCFullYear(year);
    return date;
  }
  token = patterns2.MM.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    if (!validateDate(year, month)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month);
    return date;
  }
  token = patterns2.DDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    var dayOfYear = parseInt(token[1], 10);
    if (!validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, 0, dayOfYear);
    return date;
  }
  token = patterns2.MMDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    var day = parseInt(token[2], 10);
    if (!validateDate(year, month, day)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month, day);
    return date;
  }
  token = patterns2.Www.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    if (!validateWeekDate(year, week)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week);
  }
  token = patterns2.WwwD.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    var dayOfWeek = parseInt(token[2], 10) - 1;
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  }
  return null;
}
function parseTime(timeString) {
  var token;
  var hours;
  var minutes;
  token = patterns2.HH.exec(timeString);
  if (token) {
    hours = parseFloat(token[1].replace(",", "."));
    if (!validateTime(hours)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR2;
  }
  token = patterns2.HHMM.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(",", "."));
    if (!validateTime(hours, minutes)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR2 + minutes * MILLISECONDS_IN_MINUTE3;
  }
  token = patterns2.HHMMSS.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    var seconds = parseFloat(token[3].replace(",", "."));
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR2 + minutes * MILLISECONDS_IN_MINUTE3 + seconds * 1e3;
  }
  return null;
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  week = week || 0;
  day = day || 0;
  var date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  if (month < 0 || month > 11) {
    return false;
  }
  if (date != null) {
    if (date < 1) {
      return false;
    }
    var isLeapYear2 = isLeapYearIndex(year);
    if (isLeapYear2 && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
      return false;
    }
    if (!isLeapYear2 && date > DAYS_IN_MONTH[month]) {
      return false;
    }
  }
  return true;
}
function validateDayOfYearDate(year, dayOfYear) {
  if (dayOfYear < 1) {
    return false;
  }
  var isLeapYear2 = isLeapYearIndex(year);
  if (isLeapYear2 && dayOfYear > 366) {
    return false;
  }
  if (!isLeapYear2 && dayOfYear > 365) {
    return false;
  }
  return true;
}
function validateWeekDate(year, week, day) {
  if (week < 0 || week > 52) {
    return false;
  }
  if (day != null && (day < 0 || day > 6)) {
    return false;
  }
  return true;
}
function validateTime(hours, minutes, seconds) {
  if (hours != null && (hours < 0 || hours >= 25)) {
    return false;
  }
  if (minutes != null && (minutes < 0 || minutes >= 60)) {
    return false;
  }
  if (seconds != null && (seconds < 0 || seconds >= 60)) {
    return false;
  }
  return true;
}

// node_modules/date-fns-tz/esm/format/index.js
var tzFormattingTokensRegExp = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var matches = formatStr.match(tzFormattingTokensRegExp);
  if (matches) {
    var date = toDate2(options.originalDate || dirtyDate, options);
    formatStr = matches.reduce(function(result, token) {
      if (token[0] === "'") {
        return result;
      }
      var pos = result.indexOf(token);
      var precededByQuotedSection = result[pos - 1] === "'";
      var replaced = result.replace(
        token,
        "'" + formatters_default[token[0]](date, token, null, options) + "'"
      );
      return precededByQuotedSection ? replaced.substring(0, pos - 1) + replaced.substring(pos + 1) : replaced;
    }, formatStr);
  }
  return (0, import_format.default)(dirtyDate, formatStr, options);
}

// node_modules/date-fns-tz/esm/formatInTimeZone/index.js
var import_cloneObject = __toESM(require_cloneObject(), 1);

// node_modules/date-fns-tz/esm/utcToZonedTime/index.js
function utcToZonedTime(dirtyDate, timeZone, options) {
  var date = toDate2(dirtyDate, options);
  var offsetMilliseconds = tzParseTimezone(timeZone, date, true);
  var d = new Date(date.getTime() - offsetMilliseconds);
  var resultDate = /* @__PURE__ */ new Date(0);
  resultDate.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
  resultDate.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
  return resultDate;
}

// node_modules/date-fns-tz/esm/formatInTimeZone/index.js
function formatInTimeZone(date, timeZone, formatStr, options) {
  var extendedOptions = (0, import_cloneObject.default)(options);
  extendedOptions.timeZone = timeZone;
  extendedOptions.originalDate = date;
  return format(utcToZonedTime(date, timeZone), formatStr, extendedOptions);
}

// node_modules/date-fns-tz/esm/zonedTimeToUtc/index.js
var import_cloneObject2 = __toESM(require_cloneObject(), 1);

// node_modules/tltv-gantt-element/dist/src/gantt-step-base.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GanttStepBase = class extends LitElement {
  constructor() {
    super(...arguments);
    this.resizable = true;
    this.movable = true;
    this.backgroundColor = "#fff";
    this.stepWidth = "0px";
    this.stepLeft = "0px";
    this.stepHeight = "30px";
    this.resizableSteps = true;
  }
  updateLeft() {
    this.style.setProperty("--gantt-step-left", this.stepLeft);
    this.style.removeProperty("left");
    this.style.removeProperty("visibility");
  }
  updateWidth() {
    this.style.setProperty("--gantt-step-width", this.stepWidth);
    this.style.removeProperty("width");
  }
  getStepHeight() {
    return parseInt(this.stepHeight, 10);
  }
};
__decorate2([
  property({ reflect: true })
], GanttStepBase.prototype, "caption", void 0);
__decorate2([
  property({ reflect: true, type: Boolean })
], GanttStepBase.prototype, "resizable", void 0);
__decorate2([
  property({ reflect: true, type: Boolean })
], GanttStepBase.prototype, "movable", void 0);
__decorate2([
  property()
], GanttStepBase.prototype, "uid", void 0);
__decorate2([
  property({
    reflect: true,
    converter: {
      fromAttribute: (value, type) => {
        return toDate2(value);
      },
      toAttribute: (value, type) => {
        return format(value, "yyyy-MM-dd'T'HH:mm:ss");
      }
    }
  })
], GanttStepBase.prototype, "start", void 0);
__decorate2([
  property({
    reflect: true,
    converter: {
      fromAttribute: (value, type) => {
        return toDate2(value);
      },
      toAttribute: (value, type) => {
        return format(value, "yyyy-MM-dd'T'HH:mm:ss");
      }
    }
  })
], GanttStepBase.prototype, "end", void 0);
__decorate2([
  property()
], GanttStepBase.prototype, "backgroundColor", void 0);
__decorate2([
  property()
], GanttStepBase.prototype, "stepWidth", void 0);
__decorate2([
  property()
], GanttStepBase.prototype, "stepLeft", void 0);
__decorate2([
  property()
], GanttStepBase.prototype, "stepHeight", void 0);
__decorate2([
  property()
], GanttStepBase.prototype, "position", void 0);
__decorate2([
  property({ reflect: true, type: Boolean })
], GanttStepBase.prototype, "resizing", void 0);
__decorate2([
  property({ reflect: true, type: Boolean })
], GanttStepBase.prototype, "moving", void 0);
__decorate2([
  property({ reflect: true, type: Boolean })
], GanttStepBase.prototype, "resizableSteps", void 0);

// node_modules/tltv-gantt-element/dist/src/gantt-substeps-base.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GanttSubStepsBase = class extends GanttStepBase {
  constructor() {
    super();
    this.substep = false;
    this._substeps = [];
  }
  firstUpdated(changedProperties) {
    super.firstUpdated(changedProperties);
    this._setupForSubStep();
  }
  handleSlotchange(e) {
    let slot = e.target;
    this._substeps = slot.assignedElements({ flatten: true }).filter((element) => element instanceof GanttStepElement).map((element) => element);
    this._substeps.forEach((substep, index) => {
      substep._setupForSubStep();
      substep.position = index;
    });
    if (!this._substeps.length) {
      this._setupForSubStep();
    }
    console.log(`GanttSubStepsBase.handleSlotchange ended with ${this._substeps.length} step(s)`);
  }
  _setupForSubStep() {
    if (this.substep = this.parentElement instanceof GanttStepElement) {
      this.classList.add("substep");
      this.owner = this.parentElement;
      this.owner.classList.add("has-sub-steps");
    } else {
      this.classList.remove("has-sub-steps");
    }
  }
  async calculateSubStepLeft(timeline) {
    await this.owner.updateComplete;
    let ownerStepWidth = getWidth(this.owner);
    return timeline.getLeftPositionPercentageStringForDateRange(this.start, ownerStepWidth, this.owner.start, this.owner.end);
  }
  async calculateSubStepWidth(timeline) {
    await this.owner.updateComplete;
    let range = this.owner.end.getTime() - this.owner.start.getTime();
    return timeline.getWidthPercentageStringForDateIntervalForRange(this.end.getTime() - this.start.getTime(), range);
  }
  hasSubSteps() {
    return this.classList.contains("has-sub-steps");
  }
  getSubSteps() {
    return this._substeps;
  }
};
__decorate3([
  property()
], GanttSubStepsBase.prototype, "substep", void 0);
__decorate3([
  property()
], GanttSubStepsBase.prototype, "owner", void 0);

// node_modules/tltv-gantt-element/dist/src/gantt-step-element.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GanttStepElement = class GanttStepElement2 extends GanttSubStepsBase {
  static get styles() {
    return css`
        :host {
            position: absolute;
            height: var(--gantt-step-height);
            z-index: 1;
            -webkit-touch-callout: none;
            touch-action: pan-y;
            -ms-touch-action: pan-y;
            -webkit-border-radius: 3px;
            -moz-border-radius: 3px;
            border-radius: 3px;
            box-shadow: 2px 0 3px rgba(0, 0, 0, 0.14), 0 0 0 1px rgba(0, 0, 0, 0.07);
            background-color: var(--gantt-step-background-color);
            left: var(--gantt-step-left);
            width: var(--gantt-step-width);
            user-select: none;
        }

        :host([moving]) {
            cursor: move;
        }

        :host([resizing]) {
            cursor: e-resize;
        }

        .step-label {
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            margin: 3px;
        }
        :host(.has-sub-steps:hover) > .step-label {
            width: 100%;
            background-color: rgba(246, 255, 99, 0.3);
            border-radius: 6px;
            transform: translate(0,-22px);
        }
        :host(.has-sub-steps:first-child:hover) {
            z-index: 2;
        }
        :host(.has-sub-steps:first-child:hover) > .step-label {
            transform: translate(0, 22px);
        }
        :host(.has-sub-steps:hover) > .step-label:hover {
            cursor: move;
        }
        :host(.has-sub-steps) {
            background-color: rgba(246, 255, 99, 0.3) !important;
        }
        :host(.has-sub-steps) > .step-label {
            position: absolute;
            max-width: 100%;
        }

        :host([resizablesteps][resizable]:not(.has-sub-steps)):before,
        :host([resizablesteps]) ::slotted(gantt-step-element[resizable]):before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 10px;
            height: 100%;
            cursor: e-resize;
          }
          :host([resizablesteps][resizable]:not(.has-sub-steps)):after,
          :host([resizablesteps]) ::slotted(gantt-step-element[resizable]):after {
              content: "";
              position: absolute;
              right: 0;
              top: 0;
              width: 10px;
              height: 100%;
              cursor: e-resize;
          }
          
        :host(.step.invalid) {
            visibility: hidden;
        }
        `;
  }
  constructor() {
    super();
  }
  firstUpdated(changedProperties) {
    super.firstUpdated(changedProperties);
    this.classList.add("step");
    this.style.visibility = "hidden";
    this.style.setProperty("--gantt-step-height", this.stepHeight);
    this.addEventListener("touchstart", this._handleTouchStart);
    this.addEventListener("mousedown", this._handleMouseDown);
  }
  render() {
    this.style.setProperty("--gantt-step-background-color", this.backgroundColor);
    this.style.setProperty("--gantt-step-height", this.stepHeight);
    return html`
        <div class="step-label" part="step-label">${this.caption}</div>
        <slot @slotchange=${this.handleSlotchange}></slot>
        `;
  }
  update(changedProperties) {
    if (changedProperties.has("start") || changedProperties.has("end")) {
      this.recalculateLeft();
      this.recalculateWidth();
    }
    if (changedProperties.has("position")) {
      this.initUidByPosition();
    }
    super.update(changedProperties);
  }
  initUidByPosition() {
    if (this.uid) {
      return;
    }
    if (this.substep) {
      if (!this.owner.uid) {
        this.ownerUidUpdated();
        return;
      }
    }
    this.updateUid();
  }
  async ownerUidUpdated() {
    await this.owner.updateComplete;
    this.uid = `${this.owner.uid}-${this.position}`;
  }
  updateUid() {
    this.uid = this.substep ? `${this.owner.uid}-${this.position}` : `${this.position}`;
  }
  /** Synchronize properties from the gantt that are not handled automatically and are required by css, e.g. resize icon. */
  syncPropertiesFromGantt() {
    this.getGanttElement().then((gantt) => {
      this.resizableSteps = gantt.resizableSteps;
    });
  }
  recalculateLeft() {
    this.getGanttElement().then((gantt) => gantt.getTimeline().then((timeline) => {
      if (this.substep) {
        this.calculateSubStepLeft(timeline).then((newLeft) => {
          this.stepLeft = newLeft;
          this.updateLeft();
        });
      } else {
        this.stepLeft = timeline.getLeftPositionPercentageStringForDate(this.start, gantt.getContentWidth());
        this._substeps.forEach((substep) => substep.refresh());
        this.updateLeft();
      }
    }));
  }
  recalculateWidth() {
    this.getGanttElement().then((gantt) => gantt.getTimeline().then((timeline) => {
      if (this.substep) {
        this.calculateSubStepWidth(timeline).then((newWidth) => {
          this.stepWidth = newWidth;
          this.updateWidth();
        });
      } else {
        if (gantt.isContentOverflowingVertically()) {
          let rangeEnd = timeline.getDateForLeftPosition(gantt.getContentWidth());
          this.stepWidth = timeline.getWidthPercentageStringForDateIntervalForRange(this.end.getTime() - this.start.getTime(), rangeEnd.getTime() - timeline.internalInclusiveStartDateTime.getTime());
        } else {
          this.stepWidth = timeline.getWidthPercentageStringForDateInterval(this.end.getTime() - this.start.getTime());
        }
        this._substeps.forEach((substep) => substep.refresh());
        this.updateWidth();
      }
    }));
  }
  refresh() {
    this.syncPropertiesFromGantt();
    this.recalculateLeft();
    this.recalculateWidth();
  }
  async getGanttElement() {
    let getEl = () => this.parentElement;
    let test = () => {
      let el = this.parentElement;
      let result = el && el.isConnected;
      return result && el.getTimeline;
    };
    if (this.substep) {
      getEl = () => this.parentElement.parentElement;
      test = () => {
        let el = this.parentElement;
        let result = el && el.isConnected;
        if (result) {
          el = el.parentElement;
          result = el && el.isConnected;
        }
        return result && el.getTimeline;
      };
    }
    let continueWhenGanttReady = function(resolve, isReady, notReady) {
      requestAnimationFrame(() => isReady() ? resolve() : notReady(resolve, isReady, notReady));
    };
    await new Promise((resolve) => requestAnimationFrame(() => continueWhenGanttReady(resolve, test, continueWhenGanttReady)));
    return getEl();
  }
  _handleTouchStart(event) {
    this.getGanttElement().then((gantt) => gantt.handleTouchStart(event));
  }
  _handleMouseDown(event) {
    this.getGanttElement().then((gantt) => gantt.handleMouseDown(event));
  }
};
GanttStepElement.RESIZE_WIDTH = 10;
GanttStepElement = __decorate4([
  customElement("gantt-step-element")
], GanttStepElement);

// node_modules/tltv-gantt-element/dist/src/util/ganttUtil.js
function getPointForEvent(event, container) {
  if (event instanceof MouseEvent) {
    return [event.pageX + container.scrollLeft, event.pageY + container.scrollTop];
  } else if (event instanceof TouchEvent) {
    if (event.touches.length > 0) {
      return [event.touches[0].pageX + container.scrollLeft, event.touches[0].pageY + container.scrollTop];
    } else if (event.changedTouches.length > 0) {
      return [event.changedTouches[0].pageX + container.scrollLeft, event.changedTouches[0].pageY + container.scrollTop];
    }
  }
  return null;
}
function getPageX(event, container) {
  return getPointForEvent(event, container)[0];
}
function getPageY(event, container) {
  return getPointForEvent(event, container)[1];
}
function getElementHeightWithMargin(div) {
  let height = Math.round(getHeight(div));
  let marginHeight = 0;
  marginHeight = getMarginByComputedStyle(div);
  return height + Math.round(marginHeight);
}
function getMarginByComputedStyle(elem) {
  let cs = elem.ownerDocument.defaultView.getComputedStyle(elem);
  let size;
  if (cs) {
    size = parseInt(cs.getPropertyValue("margin-top")) + parseInt(cs.getPropertyValue("margin-bottom"));
  } else {
    size = 0;
  }
  return size;
}

// node_modules/tltv-timeline-element/dist/src/model/Weekday.js
var Weekday;
(function(Weekday2) {
  Weekday2[Weekday2["First"] = 0] = "First";
  Weekday2[Weekday2["Between"] = 1] = "Between";
  Weekday2[Weekday2["Last"] = 2] = "Last";
})(Weekday || (Weekday = {}));

// node_modules/tltv-timeline-element/dist/src/model/blockRowData.js
var BlockRowData = class {
  constructor() {
    this.blocks = /* @__PURE__ */ new Map();
    this.blockLength = /* @__PURE__ */ new Map();
  }
  size() {
    return this.blocks.size;
  }
  getBlock(key) {
    return this.blocks.get(key);
  }
  getBlockEntries() {
    return this.blocks.entries();
  }
  setBlock(key, element) {
    this.blocks.set(key, element);
  }
  getBlockLength(key) {
    return this.blockLength.get(key);
  }
  setBlockLength(key, length) {
    this.blockLength.set(key, length);
  }
  clear() {
    this.blocks.clear();
    this.blockLength.clear();
  }
};

// node_modules/tltv-timeline-element/dist/src/util/dateTimeUtil.js
var DateTimeConstants = class {
};
DateTimeConstants.DAYS_IN_WEEK = 7;
DateTimeConstants.HOURS_IN_DAY = 24;
DateTimeConstants.DAY_INTERVAL = 24 * 60 * 60 * 1e3;
DateTimeConstants.HOUR_INTERVAL = 60 * 60 * 1e3;
function toNormalDate(zonedDate, adjustment) {
  return new Date(zonedDate.getTime() - adjustment);
}
function adjustToMiddleOfDay(zonedDate, timeZone) {
  let hourStr = formatInTimeZone(zonedDate, timeZone, "HH");
  let h = parseInt(hourStr);
  let addHours2 = 12 - h;
  return new Date(zonedDate.getTime() + addHours2 * DateTimeConstants.HOUR_INTERVAL);
}
function getDSTAdjustedDate(previousIsDST, zonedDate, dstAdjustment) {
  let isDST = dstAdjustment > 0;
  if (previousIsDST && !isDST) {
    return new Date(zonedDate.getTime() + dstAdjustment);
  } else if (!previousIsDST && isDST) {
    return new Date(zonedDate.getTime() - dstAdjustment);
  }
  return zonedDate;
}

// node_modules/tltv-timeline-element/dist/src/model/DefaultLocaleDataProvider.js
var DefaultLocaleDataProvider = class {
  constructor(locale, timeZone, firstDayOfWeek, twelveHourClock) {
    this.locale = "en-US";
    this.timeZone = "Europe/London";
    this.twelveHourClock = false;
    this.firstDayOfWeek = 1;
    this.monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    this.weekDayNames = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
    this._offsetCache = /* @__PURE__ */ new Map();
    this.locale = locale;
    this.timeZone = timeZone;
    this.firstDayOfWeek = firstDayOfWeek;
    this.twelveHourClock = twelveHourClock;
    this.browserTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  getMonthNames() {
    return this.monthNames;
  }
  getWeekdayNames() {
    return this.weekDayNames;
  }
  getFirstDayOfWeek() {
    return this.firstDayOfWeek;
  }
  formatDate(date, pattern) {
    return formatInTimeZone(date, this.getTimeZone(), pattern);
  }
  formatTime(date, pattern) {
    return formatInTimeZone(date, this.getTimeZone(), pattern);
  }
  isTwelveHourClock() {
    return this.twelveHourClock;
  }
  getLocale() {
    return this.locale;
  }
  getTimeZone() {
    return this.timeZone;
  }
  getDaylightAdjustment(zonedDate) {
    return this._getDaylightAdjustment(zonedDate, this.getTimeZone());
  }
  _getDaylightAdjustment(zonedDate, timezone) {
    let fullYear = zonedDate.getFullYear();
    let janOffset = this._getOffset(fullYear, "01", this._offsetCache, timezone);
    let julOffset = this._getOffset(fullYear, "07", this._offsetCache, timezone);
    if (janOffset !== julOffset) {
      let maxOffset = Math.max(janOffset, julOffset);
      let targetOffset = this._getTimezoneOffset(zonedDate, timezone);
      if (targetOffset < maxOffset) {
        let minOffset = Math.min(janOffset, julOffset);
        return maxOffset - minOffset;
      }
    }
    return 0;
  }
  _getDaylightSavingTime(fullYear, timezone) {
    let janOffset = this._getOffset(fullYear, "01", this._offsetCache, timezone);
    let julOffset = this._getOffset(fullYear, "07", this._offsetCache, timezone);
    if (janOffset !== julOffset) {
      let maxOffset = Math.max(janOffset, julOffset);
      let minOffset = Math.min(janOffset, julOffset);
      return maxOffset - minOffset;
    }
    return 0;
  }
  isDaylightTime(zonedDate) {
    let fullYear = zonedDate.getFullYear();
    let janOffset = this._getOffset(fullYear, "01", this._offsetCache, this.getTimeZone());
    let julOffset = this._getOffset(fullYear, "07", this._offsetCache, this.getTimeZone());
    if (janOffset !== julOffset) {
      let maxOffset = Math.max(janOffset, julOffset);
      let targetOffset = this.getTimezoneOffset(zonedDate);
      return targetOffset < maxOffset;
    }
    return false;
  }
  getTimezoneOffset(zonedDate) {
    return this._getTimezoneOffset(zonedDate, this.getTimeZone());
  }
  _getTimezoneOffset(zonedDate, timezone) {
    let offset = formatInTimeZone(zonedDate, timezone, "xxx");
    if (offset && offset.length === 6) {
      let hour = offset[1] + offset[2];
      if (hour === "24") {
        hour = "00";
      }
      let tzOffset = parseInt(hour) * 60 + parseInt(offset[4] + offset[5]);
      if (offset[0] === "-") {
        tzOffset = -1 * tzOffset;
      }
      return tzOffset * 6e4;
    }
    return 0;
  }
  _getOffset(fullYear, month, cache, timezone) {
    const key = `${fullYear}-${month}-${timezone}`;
    if (!cache.has(key)) {
      let targetDate = /* @__PURE__ */ new Date(`${fullYear}-${month}-01T00:00:00Z`);
      cache.set(key, this._getTimezoneOffset(targetDate, timezone));
    }
    return cache.get(key);
  }
};

// node_modules/date-fns/esm/startOfWeek/index.js
function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/startOfISOWeek/index.js
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}

// node_modules/date-fns/esm/getISOWeekYear/index.js
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/startOfISOWeekYear/index.js
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/formatDistanceStrict/index.js
var MILLISECONDS_IN_MINUTE4 = 1e3 * 60;
var MINUTES_IN_DAY = 60 * 24;
var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;

// node_modules/date-fns/esm/getISOWeek/index.js
var MILLISECONDS_IN_WEEK = 6048e5;
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

// node_modules/date-fns/esm/getOverlappingDaysInIntervals/index.js
var MILLISECONDS_IN_DAY = 24 * 60 * 60 * 1e3;

// node_modules/tltv-timeline-element/dist/src/timeline-element.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TimelineElement_1;
var TimelineElement = TimelineElement_1 = class TimelineElement2 extends LitElement {
  constructor() {
    super(...arguments);
    this.resolutionWeekDayblockWidth = 4;
    this.resolution = Resolution.Day;
    this.timeZone = "Europe/London";
    this.locale = "en-US";
    this.firstDayOfWeek = 1;
    this.twelveHourClock = false;
    this.monthRowVisible = true;
    this.yearRowVisible = true;
    this.blocksInRange = 0;
    this.resolutionBlockCount = 0;
    this.firstResBlockCount = 0;
    this.lastResBlockCount = 0;
    this.spacerBlocks = [];
    this.yearRowData = new BlockRowData();
    this.monthRowData = new BlockRowData();
    this.dayRowData = new BlockRowData();
    this.dayWidthPercentage = 0;
    this.dayOrHourWidthPx = 0;
    this.resBlockMinWidthPx = 0;
    this.resBlockWidthPx = 0;
    this.resBlockWidthPercentage = 0;
    this.minResolutionWidth = -1;
    this.calcPixels = false;
    this.positionLeft = 0;
    this.setPositionForEachBlock = false;
    this.firstWeekBlockHidden = false;
    this.ie = false;
    this.directlyInsideScrollContainer = true;
    this.previousContainerScrollLeft = 0;
    this.previousContainerScrollTop = 0;
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.scrollContainer && this.scrollHandler) {
      this.scrollContainer.addEventListener("scroll", this.scrollHandler);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.scrollContainer && this.scrollHandler) {
      this.scrollContainer.removeEventListener("scroll", this.scrollHandler);
    }
  }
  static get styles() {
    return css`
      :host {
        display: block;
        overflow: hidden;
        position: relative;
        
        --no-user-select: {
					-webkit-user-select: none;
					-khtml-user-select: none;
					-moz-user-select: none;
					-ms-user-select: none;
          user-select: none;
        }
      }
      :host([hidden]) {
        display: none;
      }
      
      .year,
			.month,
			.day {
				padding-left: 2px;
				text-overflow: ellipsis;
				white-space: nowrap;
		   	border-right: 1px solid #A9A9A9;
		    box-sizing: border-box;
		    -moz-box-sizing: border-box;
		    -webkit-box-sizing: border-box;
			}
			.year.spacer,
			.month.spacer,
			.day.spacer {
				padding-left: 0px;
			}

			.month:nth-of-type(even),
			.day:nth-of-type(even) {
			    background-color: #ddd;
			}
			.col.even {
			    background-color: #ccc;
			}

			.col {
        position: var(--timeline-col-position);
				left: var(--timeline-col-left);
				height: 100%;
				float: left;
				overflow: hidden;
				border-right: 1px solid #A9A9A9;
				background-color: var(--timeline-col-background-color, #ddd);
				font-size: var(--timeline-col-font-size, 10px);
				text-align: center;
				box-sizing: border-box;
				-moz-box-sizing: border-box;
				-webkit-box-sizing: border-box;
				-webkit-touch-callout: none;
				@apply --no-user-select;
			}

      .c-col {
				width: var(--timeline-col-center-width);
			}

			.f-col {
				width: var(--timeline-col-first-width);
			}

			.l-col {
				width: var(--timeline-col-last-width);
      }
      
			.col.w {
				text-align: left;
			}

			.col.weekend {
				background-color: var(--timeline-col-weekend, #ccc);
			}

			.col.measure {
			    // Change min-width to adjust grid's cell width with day and hour-resolution.
				//min-width: 40px;
			}
			.col.w.measure {
				// Change min-width to adjust grid's cell width with week-resolution.
				//min-width: 70px;
			}

			.row {
				width: 100%;
				float: left;
				overflow: hidden;
				height: var(--timeline-row-height, 15px);
				font-size: var(--timeline-row-font-size, 10px);
				background-color: var(--timeline-row-background, #d0d0d0);
				-ms-flex-pack: justify;
				-webkit-touch-callout: none;
				@apply --no-user-select;
			}
    `;
  }
  render() {
    return html`
      ${this.yearBlocks()}
      ${this.monthBlocks()}
      ${this.dayBlocks()}
      <div id="resolutionDiv" class="row resolution"></div>`;
  }
  yearBlocks() {
    if (this.yearRowVisible) {
      return this.timelineBlocks(this.yearRowData, TimelineElement_1.STYLE_YEAR);
    }
    return nothing;
  }
  monthBlocks() {
    if (this.monthRowVisible) {
      return this.timelineBlocks(this.monthRowData, TimelineElement_1.STYLE_MONTH);
    }
    return nothing;
  }
  dayBlocks() {
    if (this.isDayRowVisible) {
      return this.timelineBlocks(this.dayRowData, TimelineElement_1.STYLE_DAY);
    }
    return nothing;
  }
  shouldUpdate(changedProperties) {
    return changedProperties.has("resolution") || changedProperties.has("startDateTime") || changedProperties.has("endDateTime") || changedProperties.has("locale") || changedProperties.has("timeZone") || changedProperties.has("firstDayOfWeek") || changedProperties.has("twelveHourClock") || changedProperties.has("yearRowVisible") || changedProperties.has("monthRowVisible") || changedProperties.has("monthNames") || changedProperties.has("weekdayNames");
  }
  willUpdate(changedProps) {
    if (changedProps.has("resolution")) {
      this.minResolutionWidth = -1;
    }
    if (changedProps.has("resolution") || changedProps.has("startDateTime") || changedProps.has("timeZone")) {
      this.firstDayOfRange = null;
      if (this.resolution === Resolution.Hour) {
        this.internalInclusiveStartDateTime = toDate2(this.startDateTime, { timeZone: this.timeZone });
      } else {
        this.internalInclusiveStartDateTime = toDate2(this.startDateTime.substring(0, 10) + "T00:00:00.000", { timeZone: this.timeZone });
      }
    }
    if (changedProps.has("resolution") || changedProps.has("endDateTime") || changedProps.has("timeZone")) {
      if (this.resolution === Resolution.Hour) {
        this.internalInclusiveEndDateTime = toDate2(this.endDateTime.substring(0, 13) + ":59:59.999", { timeZone: this.timeZone });
      } else {
        this.internalInclusiveEndDateTime = toDate2(this.endDateTime.substring(0, 10) + "T23:59:59.999", { timeZone: this.timeZone });
      }
    }
    this.updateTimeLine(this.resolution, this.internalInclusiveStartDateTime, this.internalInclusiveEndDateTime, new DefaultLocaleDataProvider(this.locale, this.timeZone, this.firstDayOfWeek, this.twelveHourClock));
  }
  updated(changedProps) {
    if (!this.resolution || !this.internalInclusiveStartDateTime || !this.internalInclusiveEndDateTime) {
      return;
    }
    if (this.resolution !== Resolution.Day && this.resolution !== Resolution.Week && this.resolution !== Resolution.Hour) {
      console.log("TimelineElement resolution " + (this.resolution ? Resolution[this.resolution] : "null") + " is not supported");
      return;
    }
    console.log("TimelineElement Constructed content.");
    this.updateWidths();
    console.log("TimelineElement is updated for resolution " + Resolution[this.resolution] + ".");
    this.registerScrollHandler();
  }
  /**
   * <p>
   * Updates the content of this component. Builds the time-line and calculates
   * width and heights for the content (calls in the end
   * {@link #updateWidths()}). This should be called explicitly. Otherwise the
   * component will be empty.
   * <p>
   * Date values should always follow specification in {@link Date#getTime()}.
   * Start and end date is always required.
   *
   * @param resolution
   *            Resolution enum (not null)
   * @param startDate
   *            Time-line's start date. (inclusive; not null)
   * @param endDate
   *            Time-line's end date. (inclusive; not null)
   * @param localeDataProvider
   *            Data provider for locale specific data. month names, first day
   *            of week etc.
   *
   */
  updateTimeLine(resolution, startDate, endDate, localeDataProvider) {
    if (!localeDataProvider) {
      console.log("TimelineElement requires ILocaleDataProvider. Can't complete update(...) operation.");
      return;
    }
    this.clear();
    console.log("TimelineElement content cleared.");
    if (!resolution || !startDate || !endDate) {
      return;
    }
    console.log("TimelineElement Updating content.");
    this.localeDataProvider = localeDataProvider;
    this.resolution = resolution;
    this.resetDateRange(startDate, endDate);
    this.lastDayOfWeek = localeDataProvider.getFirstDayOfWeek() == 1 ? 7 : Math.max((localeDataProvider.getFirstDayOfWeek() - 1) % 8, 1);
    this.monthNames = this.monthNames || localeDataProvider.getMonthNames();
    this.weekdayNames = this.weekdayNames || localeDataProvider.getWeekdayNames();
    if (this.minResolutionWidth < 0) {
      this.minResolutionWidth = this.calculateResolutionMinWidth();
    }
    if (this.resolution === Resolution.Day || this.resolution === Resolution.Week) {
      this.prepareTimelineForDayOrWeekResolution(this.internalInclusiveStartDateTime, this.internalInclusiveEndDateTime);
    } else if (this.resolution === Resolution.Hour) {
      this.prepareTimelineForHourResolution(this.internalInclusiveStartDateTime, this.internalInclusiveEndDateTime);
    }
  }
  resetDateRange(startDate, endDate) {
    this.internalInclusiveStartDateTime = startDate;
    this.internalInclusiveEndDateTime = endDate;
    this.normalStartDate = this.toNormalDate(this.internalInclusiveStartDateTime);
    this.normalEndDate = this.toNormalDate(this.internalInclusiveEndDateTime);
    this.firstDayOfRange = this.firstDayOfRange || this.internalInclusiveStartDateTime.getDay() + 1;
    this.firstHourOfRange = this.firstHourOfRange || parseInt(this.localeDataProvider.formatTime(this.internalInclusiveStartDateTime, "HH"));
  }
  registerScrollHandler() {
    if (this.scrollHandler) {
      return;
    }
    let timeline = this;
    this.scrollContainer = this.setupScrollContainer();
    this.scrollHandler = function(e) {
      window.requestAnimationFrame(function() {
        let container = timeline.scrollContainer;
        let sl = container.scrollLeft || container.scrollX;
        let st = container.scrollTop || container.scrollY;
        if (sl != timeline.previousContainerScrollLeft) {
          timeline.setScrollLeft(sl);
          timeline.previousContainerScrollLeft = sl;
        }
        if (st != timeline.previousContainerScrollTop) {
          timeline.previousContainerScrollTop = st;
        }
      });
    };
    this.scrollContainer.addEventListener("scroll", this.scrollHandler);
  }
  setupScrollContainer() {
    let scrollContainer;
    if (this.scrollContainerId) {
      scrollContainer = this.getParentElement(this).querySelector("#" + this.scrollContainerId);
      if (!scrollContainer) {
        scrollContainer = document.querySelector("#" + this.scrollContainerId);
      }
      if (scrollContainer) {
        scrollContainer.style.overflowX = "auto";
      }
    }
    if (!scrollContainer) {
      scrollContainer = this.getParentElement(this);
      this.directlyInsideScrollContainer = true;
      if (scrollContainer === document.body) {
        return window;
      }
    }
    return scrollContainer;
  }
  clear() {
    this.spacerBlocks = [];
    this.yearRowData.clear();
    this.monthRowData.clear();
    this.dayRowData.clear();
  }
  calculateResolutionMinWidth() {
    let resDivMeasure = document.createElement("div");
    resDivMeasure.classList.add(TimelineElement_1.STYLE_ROW, TimelineElement_1.STYLE_RESOLUTION);
    let resBlockMeasure = document.createElement("div");
    if (this.resolution === Resolution.Week) {
      resBlockMeasure.classList.add(TimelineElement_1.STYLE_COL, TimelineElement_1.STYLE_WEEK, TimelineElement_1.STYLE_MEASURE);
    } else {
      resBlockMeasure.innerText = "MM";
      resBlockMeasure.classList.add(TimelineElement_1.STYLE_COL, TimelineElement_1.STYLE_MEASURE);
    }
    resDivMeasure.appendChild(resBlockMeasure);
    this.shadowRoot.appendChild(resDivMeasure);
    let width = resBlockMeasure.clientWidth;
    if (this.resolution === Resolution.Week) {
      width = width / DateTimeConstants.DAYS_IN_WEEK;
    }
    width = width < this.resolutionWeekDayblockWidth ? this.resolutionWeekDayblockWidth : width;
    this.shadowRoot.removeChild(resDivMeasure);
    return width;
  }
  registerHourResolutionBlock() {
    this.blocksInRange++;
    this.resolutionBlockCount++;
  }
  registerDayResolutionBlock() {
    this.blocksInRange++;
    this.resolutionBlockCount++;
  }
  registerWeekResolutionBlock(index, weekDay, lastBlock, firstWeek) {
    if (index == 0 || weekDay === Weekday.First) {
      this.resolutionBlockCount++;
    }
    if (firstWeek && (weekDay === Weekday.Last || lastBlock)) {
      this.firstResBlockCount = index + 1;
    } else if (lastBlock) {
      this.lastResBlockCount = (index + 1 - this.firstResBlockCount) % 7;
    }
    this.blocksInRange++;
  }
  timelineBlocks(rowData, style) {
    const itemTemplates = [];
    for (let entry of rowData.getBlockEntries()) {
      itemTemplates.push(html`${entry[1]}`);
    }
    if (this.isAlwaysCalculatePixelWidths()) {
      itemTemplates.push(html`${this.createSpacerBlock(style)}`);
    }
    return itemTemplates;
  }
  /**
  * Returns true if Widget is set to calculate widths by itself. Default is
  * false.
  *
  * @return
  */
  isAlwaysCalculatePixelWidths() {
    return this.calcPixels;
  }
  createSpacerBlock(className) {
    let block = document.createElement("div");
    block.classList.add(TimelineElement_1.STYLE_ROW, TimelineElement_1.STYLE_YEAR, TimelineElement_1.STYLE_SPACER);
    block.innerText = " ";
    block.style.display = "none";
    this.spacerBlocks.push(block);
    return block;
  }
  /** Clears Daylight saving time adjustment from the given time. */
  toNormalDate(zonedDate) {
    return toNormalDate(zonedDate, this.localeDataProvider.getDaylightAdjustment(zonedDate));
  }
  getDSTAdjustedDate(previousIsDST, zonedDate) {
    return getDSTAdjustedDate(previousIsDST, zonedDate, this.localeDataProvider.getDaylightAdjustment(zonedDate));
  }
  getParentElement(node) {
    var parent = node.parentNode;
    if (!parent || parent.nodeType != 1) {
      parent = null;
    }
    return parent;
  }
  getDay(date) {
    let adjusted = adjustToMiddleOfDay(date, this.localeDataProvider.getTimeZone());
    return this.localeDataProvider.formatDate(adjusted, "d");
  }
  getYear(date) {
    return this.localeDataProvider.formatDate(date, "yyyy");
  }
  getMonth(date) {
    let m = this.localeDataProvider.formatDate(date, "M");
    return parseInt(m) - 1;
  }
  isWeekEnd(dayCounter) {
    return dayCounter == 1 || dayCounter == 7;
  }
  key(prefix, rowData) {
    return prefix + "_" + rowData.size();
  }
  newKey(prefix, rowData) {
    return prefix + "_" + (rowData.size() + 1);
  }
  addBlock(current, target, date, rowData, operation) {
    let key;
    if (target !== current) {
      current = target;
      key = this.newKey("" + current, rowData);
      operation(target, key, date);
    } else {
      key = this.key("" + current, rowData);
      rowData.setBlockLength(key, rowData.getBlockLength(key) + 1);
    }
    return current;
  }
  addDayBlock(currentDay, date) {
    let day = this.getDay(date);
    return this.addBlock(currentDay, day, date, this.dayRowData, (day2, key, date2) => {
      this.addDayBlockElement(key, this.formatDayCaption(day2, date2));
    });
  }
  addMonthBlock(currentMonth, date) {
    let month = this.getMonth(date);
    return this.addBlock(currentMonth, "" + month, date, this.monthRowData, (target, key, date2) => {
      this.addMonthBlockElement(key, this.formatMonthCaption(month, date2));
    });
  }
  addYearBlock(currentYear, date) {
    let year = this.getYear(date);
    return this.addBlock(currentYear, year, date, this.yearRowData, (year2, key, date2) => {
      this.addYearBlockElement(key, this.formatYearCaption(year2, date2));
    });
  }
  addMonthBlockElement(key, text) {
    this.createTimelineBlock(key, text, TimelineElement_1.STYLE_MONTH, this.monthRowData);
  }
  addYearBlockElement(key, text) {
    this.createTimelineBlock(key, text, TimelineElement_1.STYLE_YEAR, this.yearRowData);
  }
  addDayBlockElement(key, text) {
    this.createTimelineBlock(key, text, TimelineElement_1.STYLE_DAY, this.dayRowData);
  }
  createTimelineBlock(key, text, styleSuffix, rowData) {
    let div = document.createElement("div");
    div.classList.add(TimelineElement_1.STYLE_ROW, styleSuffix);
    div.innerText = text;
    rowData.setBlockLength(key, 1);
    rowData.setBlock(key, div);
    return div;
  }
  formatDayCaption(day, date) {
    if (!this.dayFormat || this.dayFormat === "") {
      return day;
    }
    return this.localeDataProvider.formatDate(date, this.dayFormat);
  }
  formatYearCaption(year, date) {
    if (!this.yearFormat || this.yearFormat === "") {
      return year;
    }
    return this.localeDataProvider.formatDate(date, this.yearFormat);
  }
  formatWeekCaption(date) {
    if (!this.weekFormat || this.weekFormat === "") {
      return "" + getISOWeek(date);
    }
    return this.localeDataProvider.formatDate(date, this.weekFormat);
  }
  formatMonthCaption(month, date) {
    if (!this.monthFormat || this.monthFormat === "") {
      return this.monthNames[month];
    }
    return this.localeDataProvider.formatDate(date, this.monthFormat);
  }
  getWeekday(dayCounter) {
    if (dayCounter === this.localeDataProvider.getFirstDayOfWeek()) {
      return Weekday.First;
    }
    if (dayCounter === this.lastDayOfWeek) {
      return Weekday.Last;
    }
    return Weekday.Between;
  }
  prepareTimelineForHourResolution(startDate, endDate) {
    let timeline = this;
    this.firstDay = true;
    let hourCounter = this.firstHourOfRange;
    this.prepareTimelineForHour(DateTimeConstants.HOUR_INTERVAL, startDate, endDate, {
      registerResolutionBlock(index, date, currentYear, lastTimelineBlock) {
        timeline.registerHourResolutionBlock();
        hourCounter = Math.max((hourCounter + 1) % 25, 1);
      }
    });
  }
  prepareTimelineForHour(interval, startDate, endDate, resBlockRegisterer) {
    this.blocksInRange = 0;
    this.resolutionBlockCount = 0;
    this.firstResBlockCount = 0;
    this.lastResBlockCount = 0;
    let currentYear = null;
    let currentMonth = null;
    let currentDay = null;
    let pos = startDate;
    let end = endDate;
    let index = 0;
    let lastTimelineBlock = false;
    let date;
    while (pos.getTime() <= end.getTime()) {
      date = pos;
      let nextHour = new Date(pos.getTime() + interval);
      lastTimelineBlock = nextHour.getTime() > end.getTime();
      resBlockRegisterer.registerResolutionBlock(index, date, currentYear, lastTimelineBlock);
      if (this.yearRowVisible) {
        currentYear = this.addYearBlock(currentYear, date);
      }
      if (this.monthRowVisible) {
        currentMonth = this.addMonthBlock(currentMonth, date);
      }
      if (this.isDayRowVisible()) {
        currentDay = this.addDayBlock(currentDay, date);
      }
      pos = nextHour;
      index++;
    }
  }
  prepareTimelineForDayOrWeekResolution(startDate, endDate) {
    let timeline = this;
    let dayCounter = this.firstDayOfRange;
    let weekday;
    let firstWeek = true;
    this.prepareTimelineForDayOrWeek(DateTimeConstants.DAY_INTERVAL, startDate, endDate, {
      registerResolutionBlock: function(index, date, currentYear, lastTimelineBlock) {
        weekday = timeline.getWeekday(dayCounter);
        if (timeline.resolution === Resolution.Week) {
          timeline.registerWeekResolutionBlock(index, weekday, lastTimelineBlock, firstWeek);
          if (firstWeek && (weekday === Weekday.Last || lastTimelineBlock)) {
            firstWeek = false;
          }
        } else {
          timeline.registerDayResolutionBlock();
        }
        dayCounter = Math.max((dayCounter + 1) % 8, 1);
      }
    });
  }
  prepareTimelineForDayOrWeek(interval, startDate, endDate, resBlockRegisterer) {
    this.blocksInRange = 0;
    this.resolutionBlockCount = 0;
    this.firstResBlockCount = 0;
    this.lastResBlockCount = 0;
    let currentYear = null;
    let currentMonth = null;
    let currentDay = null;
    let pos = adjustToMiddleOfDay(startDate, this.localeDataProvider.getTimeZone());
    let end = endDate;
    let index = 0;
    let lastTimelineBlock = false;
    let date;
    let isDST = false;
    let isPreviousDst = this.localeDataProvider.isDaylightTime(startDate);
    while (!lastTimelineBlock) {
      let date2 = getDSTAdjustedDate(isPreviousDst, pos, this.localeDataProvider.getDaylightAdjustment(pos));
      pos = date2;
      isDST = this.localeDataProvider.isDaylightTime(date2);
      let d = new Date(date2.getTime() + interval);
      lastTimelineBlock = getDSTAdjustedDate(isDST, d, this.localeDataProvider.getDaylightAdjustment(d)).getTime() > end.getTime();
      resBlockRegisterer.registerResolutionBlock(index, date2, currentYear, lastTimelineBlock);
      if (this.yearRowVisible) {
        currentYear = this.addYearBlock(currentYear, date2);
      }
      if (this.monthRowVisible) {
        currentMonth = this.addMonthBlock(currentMonth, date2);
      }
      if (this.isDayRowVisible()) {
        currentDay = this.addDayBlock(currentDay, date2);
      }
      isPreviousDst = isDST;
      pos = new Date(pos.getTime() + interval);
      index++;
    }
  }
  isDayRowVisible() {
    return this.resolution === Resolution.Hour;
  }
  /**
  * Get actual width of the timeline.
  *
  * @return
  */
  getResolutionWidth() {
    if (!this.isTimelineOverflowingHorizontally()) {
      return this.calculateTimelineWidth();
    }
    let width = this.getResolutionDivWidth();
    if (this.isAlwaysCalculatePixelWidths() && this.containsResBlockSpacer()) {
      width = width - getWidth(this.resSpacerDiv);
    }
    return width;
  }
  /**
  * Calculate the exact width of the timeline. Excludes any spacers in the
  * end.
  *
  * @return
  */
  calculateTimelineWidth() {
    let last = this.getLastResolutionElement();
    if (last === null) {
      return 0;
    }
    let r = getRight(last);
    let l = getLeft(this.getFirstResolutionElement());
    let timelineRealWidth = r - l;
    return timelineRealWidth;
  }
  /*
   * Get width of the resolution div element.
   */
  getResolutionDivWidth() {
    if (!this.isTimelineOverflowingHorizontally()) {
      return getWidth(this.resolutionDiv);
    }
    return this.blocksInRange * this.minResolutionWidth;
  }
  /**
  * Calculate matching left offset in percentage for a date (
  * {@link Date#getTime()}).
  *
  * @param date
  *            Target date in milliseconds.
  * @param contentWidth
  *            Width of the content that the given 'date' is relative to.
  * @return Left offset in percentage.
  */
  getLeftPositionPercentageForDate(date, contentWidth) {
    let timelineLeft = this.getLeftPositionForDate(date);
    let relativeLeft = this.convertRelativeLeftPosition(timelineLeft, contentWidth);
    let width = this.getResolutionWidth();
    return 100 / width * relativeLeft;
  }
  /**
   * Calculate CSS value for 'left' property matching left offset in
   * percentage for a date ( {@link Date#getTime()}).
   * <p>
   * May return '2.123456%' or 'calc(2.123456%)' if IE;
   *
   * @param date
   *            Target date in milliseconds.
   * @param contentWidth
   *            Width of the content that the given 'date' is relative to.
   * @return Left offset as a String value.
   */
  getLeftPositionPercentageStringForDate(date, contentWidth) {
    let timelineLeft = this.getLeftPositionForDate(date);
    let relativeLeft = this.convertRelativeLeftPosition(timelineLeft, contentWidth);
    let width = this.getResolutionWidth();
    let calc = this.createCalcCssValue(width, relativeLeft);
    if (calc != null) {
      return calc;
    }
    return 100 / width * relativeLeft + "%";
  }
  getLeftPositionPercentageStringForDateRange(date, rangeWidth, rangeStartDate, rangeEndDate) {
    let rangeLeft = this.getLeftPositionForDateRange(date, rangeWidth, rangeStartDate, rangeEndDate);
    let width = rangeWidth;
    let calc = this.createCalcCssValue(width, rangeLeft);
    if (calc != null) {
      return calc;
    }
    return 100 / width * rangeLeft + "%";
  }
  /**
   * Calculate CSS value for 'width' property matching date interval inside
   * the time-line. Returns percentage value. Interval is in milliseconds.
   * <p>
   * May return '2.123456%' or 'calc(2.123456%)' if IE;
   *
   * @param interval
   *            Date interval in milliseconds.
   * @return
   */
  getWidthPercentageStringForDateInterval(interval) {
    let range = this.internalInclusiveEndDateTime.getTime() - this.internalInclusiveStartDateTime.getTime();
    return this.getWidthPercentageStringForDateIntervalForRange(interval, range);
  }
  /** @see #getWidthPercentageStringForDateInterval(long) */
  getWidthPercentageStringForDateIntervalForRange(interval, range) {
    let calc = this.createCalcCssValue(range, interval);
    if (calc != null) {
      return calc;
    }
    return 100 / range * interval + "%";
  }
  /**
   * Calculate matching left offset in pixels for a date (
   * {@link Date#getTime()}).
   *
   * @param date
   *            Target date in milliseconds.
   * @return Left offset in pixels.
   */
  getLeftPositionForDate(date) {
    return this.getLeftPositionForDateRange(date, this.getResolutionWidth(), this.internalInclusiveStartDateTime, this.internalInclusiveEndDateTime);
  }
  getLeftPositionForDateRange(date, rangeWidth, rangeStartDate, rangeEndDate) {
    let width = rangeWidth;
    let range = rangeEndDate.getTime() - rangeStartDate.getTime();
    if (range <= 0) {
      return 0;
    }
    let p = width / range;
    let offset = date.getTime() - rangeStartDate.getTime();
    let left = p * offset;
    return left;
  }
  /**
   * Calculate matching date ({@link Date#getTime()}) for the target left
   * pixel offset.
   *
   * @param left
   *            Left offset in pixels.
   * @return Date in a milliseconds or null if timeline width is invalid (<=0).
   */
  getDateForLeftPosition(left) {
    return this.getDateForLeftPositionNoticeDST(left, this.resolution === Resolution.Hour);
  }
  getDateForLeftPositionNoticeDST(left, noticeDST) {
    let width = this.getResolutionWidth();
    if (width <= 0) {
      return null;
    }
    let range = this.normalEndDate.getTime() - this.normalStartDate.getTime();
    if (noticeDST) {
      range = this.adjustDateRangeByDST(range);
    }
    let p = range / width;
    let offset = p * left;
    let date = new Date(this.internalInclusiveStartDateTime.getTime() + offset);
    console.log("Zoned: " + this.localeDataProvider.formatDate(date, "dd. HH:mm") + "  DST: " + this.localeDataProvider.getDaylightAdjustment(date) / 6e4);
    return date;
  }
  /**
   * Convert left position for other relative target width.
   *
   * @param left
   * @param contentWidthToConvertFor
   * @return
   */
  convertRelativeLeftPosition(left, contentWidthToConvertFor) {
    let width = this.getResolutionWidth();
    if (width <= 0 || contentWidthToConvertFor <= 0) {
      return 0;
    }
    let relativePosition = 1 / contentWidthToConvertFor * left;
    let timelineLeft = relativePosition * width;
    return timelineLeft;
  }
  adjustDateRangeByDST(range) {
    let dstStart = this.localeDataProvider.getDaylightAdjustment(this.internalInclusiveStartDateTime);
    let dstEnd = this.localeDataProvider.getDaylightAdjustment(this.internalInclusiveEndDateTime);
    if (dstStart > dstEnd) {
      range -= Math.abs(dstStart - dstEnd);
    } else if (dstEnd > dstStart) {
      range += Math.abs(dstEnd - dstStart);
    }
    return range;
  }
  /**
   * Set horizontal scroll position for the time-line.
   *
   * @param left
   *            Scroll position in pixels.
   */
  setScrollLeft(left) {
    if (this.positionLeft === left) {
      return;
    }
    this.positionLeft = left || 0;
    if (!this.directlyInsideScrollContainer) {
      this.style.left = -this.positionLeft + "px";
    }
    this.lazyResolutionPaint = setTimeout(() => this.fillVisibleTimeline(), 20);
  }
  /**
   * Re-calculates required widths for this widget.
   * <p>
   * Re-creates and fills the visible part of the resolution element.
   */
  updateWidths() {
    if (this.resolutionDiv == null) {
      console.log("TimelineElement is not ready for updateWidths() call. Call update(...) instead.");
      return;
    }
    console.log("TimelineElement Started updating widths.");
    while (this.resolutionDiv.firstChild) {
      this.resolutionDiv.removeChild(this.resolutionDiv.lastChild);
    }
    this.setMinWidth(this.blocksInRange * this.minResolutionWidth);
    this.updateTimelineOverflowingHorizontally();
    this.createTimelineElementsOnVisibleArea();
    this.fillVisibleTimeline();
    this.removeResolutionSpacerBlock();
    this.dayWidthPercentage = 100 / this.blocksInRange;
    this.dayOrHourWidthPx = this.calculateDayOrHourResolutionBlockWidthPx(this.blocksInRange);
    this.resBlockMinWidthPx = this.minResolutionWidth;
    this.resBlockWidthPx = this.calculateActualResolutionBlockWidthPx(this.dayOrHourWidthPx);
    this.resBlockWidthPercentage = 100 / this.resolutionBlockCount;
    let pct = this.createCalcCssValue(this.resolutionBlockCount, null);
    if (this.resolution === Resolution.Week) {
      this.resBlockMinWidthPx = DateTimeConstants.DAYS_IN_WEEK * this.minResolutionWidth;
      this.resBlockWidthPercentage = this.dayWidthPercentage * DateTimeConstants.DAYS_IN_WEEK;
      pct = this.createCalcCssValue(this.blocksInRange, DateTimeConstants.DAYS_IN_WEEK);
    }
    this.updateResolutionBlockWidths(pct);
    if (this.yearRowVisible) {
      this.updateBlockWidths(this.yearRowData);
    }
    if (this.monthRowVisible) {
      this.updateBlockWidths(this.monthRowData);
    }
    if (this.isDayRowVisible()) {
      this.updateBlockWidths(this.dayRowData);
    }
    if (this.isAlwaysCalculatePixelWidths()) {
      this.updateSpacerBlocks(this.dayOrHourWidthPx);
    }
    console.log("TimelineElement Widths are updated.");
  }
  updateBlockWidths(rowData) {
    for (let entry of rowData.getBlockEntries()) {
      this.setWidth(entry[1], rowData.getBlockLength(entry[0]));
    }
  }
  updateSpacerBlocks(dayWidthPx) {
    let spaceLeft = this.getResolutionDivWidth() - this.blocksInRange * dayWidthPx;
    if (spaceLeft > 0) {
      for (let e of this.spacerBlocks) {
        e.style.removeProperty("display");
        e.style.width = spaceLeft + "px";
      }
      this.resSpacerDiv = this.createResolutionBlock();
      this.resSpacerDiv.classList.add(TimelineElement_1.STYLE_SPACER);
      this.resSpacerDiv.style.width = spaceLeft + "px";
      this.resSpacerDiv.innerText = " ";
      this.resolutionDiv.appendChild(this.resSpacerDiv);
    } else {
      this.hideSpacerBlocks();
    }
  }
  hideSpacerBlocks() {
    for (let e of this.spacerBlocks) {
      e.style.display = "none";
    }
  }
  /**
   * Set minimum width (pixels) of this widget's root DIV element. Default is
   * -1. Notice that
   * {@link #update(Resolution, long, long, int, int, LocaleDataProvider)}
   * will calculate min-width and call this internally.
   *
   * @param minWidth
   *            Minimum width in pixels.
   */
  setMinWidth(minWidth) {
    this.minWidth = minWidth;
    this.style.minWidth = this.minWidth + "px";
    this.resolutionDiv.style.minWidth = this.minWidth + "px";
  }
  /**
   * Returns true if the timeline is overflowing the parent's width. This
   * works only when this widget is attached to some parent.
   *
   * @return True when timeline width is more than the parent's width (@see
   *         {@link Element#getClientWidth()}).
   */
  isTimelineOverflowingHorizontally() {
    return this.timelineOverflowingHorizontally;
  }
  /**
  * Update horizontal overflow state.
  */
  updateTimelineOverflowingHorizontally() {
    this.timelineOverflowingHorizontally = getWidth(this.resolutionDiv) > getWidth(this.getParentElement(this));
  }
  createTimelineElementsOnVisibleArea() {
    let blocks = this.resolutionBlockCount;
    if (this.isTimelineOverflowingHorizontally()) {
      blocks = Math.floor(getWidth(this.getParentElement(this)) / this.calculateMinimumResolutionBlockWidth());
      if (this.resolutionBlockCount < blocks) {
        blocks = this.resolutionBlockCount;
      } else {
        blocks += 2;
      }
    }
    let element = null;
    for (let i = 0; i < blocks; i++) {
      switch (this.resolution) {
        case Resolution.Hour:
          element = this.createHourResolutionBlock();
          break;
        case Resolution.Day:
          element = this.createDayResolutionBlock();
          break;
        case Resolution.Week:
          element = this.createWeekResolutionBlock();
          break;
      }
      this.resolutionDiv.appendChild(element);
    }
    console.log(`TimelineElement Added ${blocks} visible timeline elements for resolution ${Resolution[this.resolution]}`);
  }
  calculateMinimumResolutionBlockWidth() {
    if (this.resolution === Resolution.Week) {
      return DateTimeConstants.DAYS_IN_WEEK * this.minResolutionWidth;
    }
    return this.minResolutionWidth;
  }
  createResolutionBlock() {
    let resBlock = document.createElement("div");
    resBlock.classList.add("col");
    return resBlock;
  }
  createHourResolutionBlock() {
    let resBlock = this.createResolutionBlock();
    resBlock.classList.add("h", TimelineElement_1.STYLE_CENTER);
    return resBlock;
  }
  createDayResolutionBlock() {
    let resBlock = this.createResolutionBlock();
    resBlock.classList.add(TimelineElement_1.STYLE_CENTER);
    return resBlock;
  }
  createWeekResolutionBlock() {
    let resBlock = this.createResolutionBlock();
    resBlock.classList.add("w", TimelineElement_1.STYLE_CENTER);
    return resBlock;
  }
  fillVisibleTimeline() {
    if (this.isTimelineOverflowingHorizontally()) {
      this.showResolutionBlocksOnView();
    } else {
      this.showAllResolutionBlocks();
    }
  }
  showResolutionBlocksOnView() {
    let positionLeftSnapshot = this.positionLeft;
    let datePos = positionLeftSnapshot;
    this.firstWeekBlockHidden = false;
    let left = Math.floor(positionLeftSnapshot);
    if (positionLeftSnapshot > 0 && this.resBlockWidthPx > 0) {
      let overflow = 0;
      let firstResBlockShort = this.isFirstResBlockShort();
      overflow = this.getScrollOverflowForResolutionBlock(positionLeftSnapshot, left, firstResBlockShort);
      left = Math.floor(positionLeftSnapshot - overflow);
      datePos = this.adjustLeftPositionForDateDetection(left);
    }
    if (datePos < 0) {
      datePos = positionLeftSnapshot;
    }
    let leftDate;
    let noticeDst = this.resolution === Resolution.Hour;
    leftDate = this.getDateForLeftPositionNoticeDST(datePos, noticeDst);
    let containerWidth = getWidth(this.getParentElement(this));
    this.fillTimelineForResolution(leftDate, new Date(Math.min(this.internalInclusiveEndDateTime.getTime(), this.getDateForLeftPositionNoticeDST(datePos + containerWidth, noticeDst).getTime())), left);
    this.style.setProperty("--timeline-col-position", "relative");
    this.style.setProperty("--timeline-col-left", left + "px");
    console.log(`TimelineElement Updated visible timeline elements for horizontal scroll position ${left} (plus ${datePos - left} to center-of-first-block)`);
  }
  showAllResolutionBlocks() {
    this.style.setProperty("--timeline-col-position", "relative");
    this.style.setProperty("--timeline-col-left", "0px");
    this.fillTimelineForResolution(this.internalInclusiveStartDateTime, this.internalInclusiveEndDateTime, 0);
  }
  fillTimelineForResolution(startDate, endDate, left) {
    if (this.resolution === Resolution.Day || this.resolution === Resolution.Week) {
      this.fillTimelineForDayResolution(startDate, endDate, left);
    } else if (this.resolution == Resolution.Hour) {
      this.fillTimelineForHourResolution(startDate, endDate, left);
    } else {
      console.log("TimelineElement resolution " + (this.resolution != null ? Resolution[this.resolution] : "null") + " is not supported");
      return;
    }
    console.log("TimelineElement Filled new data and styles to visible timeline elements");
  }
  isFirstResBlockShort() {
    return this.firstResBlockCount > 0 && (this.resolution === Resolution.Week && this.firstResBlockCount < DateTimeConstants.DAYS_IN_WEEK);
  }
  isLastResBlockShort() {
    return this.lastResBlockCount > 0 && (this.resolution === Resolution.Week && this.lastResBlockCount < DateTimeConstants.DAYS_IN_WEEK);
  }
  getScrollOverflowForResolutionBlock(positionLeftSnapshot, left, firstResBlockShort) {
    let overflow;
    if (firstResBlockShort && left <= this.getFirstResolutionElementWidth()) {
      overflow = this.getScrollOverflowForShortFirstResolutionBlock(positionLeftSnapshot);
    } else {
      overflow = this.getScrollOverflowForRegularResoultionBlock(positionLeftSnapshot, firstResBlockShort);
    }
    return overflow;
  }
  getScrollOverflowForRegularResoultionBlock(positionLeftSnapshot, firstResBlockShort) {
    let overflow;
    let firstBlockWidth = this.getFirstResolutionElementWidth();
    let positionLeft = positionLeftSnapshot - (firstResBlockShort ? firstBlockWidth : 0);
    overflow = positionLeft % this.resBlockWidthPx;
    if (firstResBlockShort) {
      overflow += firstBlockWidth;
      this.firstWeekBlockHidden = true;
    }
    return overflow;
  }
  getScrollOverflowForShortFirstResolutionBlock(positionLeftSnapshot) {
    let overflow;
    overflow = positionLeftSnapshot % this.getFirstResolutionElementWidth();
    if (overflow == 0) {
      overflow = this.getFirstResolutionElementWidth();
    }
    return overflow;
  }
  /**
   * Returns a width of the first resolution block.
   *
   * @return
   */
  getFirstResolutionElementWidth() {
    if (this.isFirstResBlockShort()) {
      if (this.isTimelineOverflowingHorizontally()) {
        return this.firstResBlockCount * this.minResolutionWidth;
      } else {
        return getWidth(this.getFirstResolutionElement());
      }
    } else {
      if (this.isTimelineOverflowingHorizontally()) {
        return this.resBlockMinWidthPx;
      } else {
        return getWidth(this.getFirstResolutionElement());
      }
    }
  }
  getFirstResolutionElement() {
    if (this.resolutionDiv.hasChildNodes()) {
      return this.resolutionDiv.firstElementChild;
    }
    return null;
  }
  getLastResolutionElement() {
    let div = this.resolutionDiv;
    if (!div) {
      return null;
    }
    let nodeList = div.childNodes;
    if (!nodeList) {
      return null;
    }
    let blockCount = nodeList.length;
    if (blockCount < 1) {
      return null;
    }
    if (this.containsResBlockSpacer()) {
      let index = blockCount - 2;
      if (blockCount > 1 && index >= 0) {
        return this.resolutionDiv.childNodes.item(index);
      }
      return null;
    }
    return this.resolutionDiv.lastChild;
  }
  containsResBlockSpacer() {
    return this.resSpacerDiv != null && this.resSpacerDiv.parentElement && this.resSpacerDiv.parentElement === this.resolutionDiv;
  }
  removeResolutionSpacerBlock() {
    if (this.containsResBlockSpacer()) {
      this.resSpacerDiv.parentNode.removeChild(this.resSpacerDiv);
    }
  }
  /*
  * Calculates either day or hour resolution block width depending on the
  * current resolution.
  */
  calculateDayOrHourResolutionBlockWidthPx(blockCount) {
    let dayOrHourWidthPx = Math.round(this.resolutionDiv.clientWidth / blockCount);
    while (blockCount * dayOrHourWidthPx < this.resolutionDiv.clientWidth) {
      dayOrHourWidthPx++;
    }
    return dayOrHourWidthPx;
  }
  /*
  * Calculates the actual width of one resolution block element. For example:
  * week resolution will return 7 * dayOrHourBlockWidthPx.
  */
  calculateActualResolutionBlockWidthPx(dayOrHourBlockWidthPx) {
    if (this.resolution === Resolution.Week) {
      return DateTimeConstants.DAYS_IN_WEEK * dayOrHourBlockWidthPx;
    }
    return dayOrHourBlockWidthPx;
  }
  /**
  * Adjust left position for optimal position to detect accurate date with
  * the current resolution.
  */
  adjustLeftPositionForDateDetection(left) {
    let datePos;
    if (this.resolution === Resolution.Week) {
      datePos = left + this.dayOrHourWidthPx / 2;
    } else {
      datePos = left + this.resBlockWidthPx / 2;
    }
    return datePos;
  }
  createCalcCssValue(v, multiplier) {
    if (this.ie) {
      let percents = 100 / v * multiplier;
      return "calc(" + percents + "%)";
    }
    return null;
  }
  updateResolutionBlockWidths(pct) {
    if (this.setPositionForEachBlock) {
      if (!this.isTimelineOverflowingHorizontally()) {
        this.resolutionDiv.style.display = "flex";
      } else {
        this.resolutionDiv.style.removeProperty("display");
      }
      let firstResBlockIsShort = this.isFirstResBlockShort();
      let lastResBlockIsShort = this.isLastResBlockShort();
      let count = this.resolutionDiv.childElementCount;
      if (this.containsResBlockSpacer()) {
        count--;
      }
      let lastIndex = count - 1;
      let i;
      let resBlock;
      for (i = 0; i < count; i++) {
        resBlock = this.resolutionDiv.childNodes.item(i);
        if (firstResBlockIsShort && i == 0) {
          this.setWidth(resBlock, this.firstResBlockCount);
        } else if (lastResBlockIsShort && i == lastIndex) {
          this.setWidth(resBlock, this.lastResBlockCount);
        } else {
          this.setWidthPct(this.resBlockWidthPx, pct, resBlock);
        }
      }
    } else {
      let center = this.getWidthStyleValue(pct);
      let first = center;
      let last = center;
      if (this.isFirstResBlockShort()) {
        first = this.getWidth(this.firstResBlockCount);
      }
      if (this.isLastResBlockShort()) {
        last = this.getWidth(this.lastResBlockCount);
      }
      this.style.setProperty("--timeline-col-center-width", center);
      this.style.setProperty("--timeline-col-first-width", first);
      this.style.setProperty("--timeline-col-last-width", last);
    }
  }
  getWidth(multiplier) {
    if (this.isTimelineOverflowingHorizontally()) {
      return multiplier * this.minResolutionWidth + "px";
    } else {
      if (this.isAlwaysCalculatePixelWidths()) {
        return multiplier * this.dayOrHourWidthPx + "px";
      } else {
        return this.getCssPercentageWidth(this.blocksInRange, this.dayWidthPercentage, multiplier);
      }
    }
  }
  setWidth(element, multiplier) {
    if (this.isTimelineOverflowingHorizontally()) {
      element.style.width = multiplier * this.minResolutionWidth + "px";
    } else {
      if (this.isAlwaysCalculatePixelWidths()) {
        element.style.width = multiplier * this.dayOrHourWidthPx + "px";
      } else {
        this.setCssPercentageWidth(element, this.blocksInRange, this.dayWidthPercentage, multiplier);
      }
    }
  }
  setWidthPct(resBlockWidthPx, pct, element) {
    if (this.isTimelineOverflowingHorizontally()) {
      element.style.width = this.resBlockMinWidthPx + "px";
    } else {
      if (this.isAlwaysCalculatePixelWidths()) {
        element.style.width = resBlockWidthPx + "px";
      } else {
        if (this.ie) {
          element.style.flex = "1";
        }
        this.setCssPercentageWidthFor(element, this.resBlockWidthPercentage, pct);
      }
    }
  }
  setCssPercentageWidth(element, daysInRange, width, position) {
    let pct = this.createCalcCssValue(daysInRange, position);
    this.setCssPercentageWidthFor(element, position * width, pct);
  }
  getCssPercentageWidth(daysInRange, width, position) {
    let pct = this.createCalcCssValue(daysInRange, position);
    return this.getPercentageWidthString(position * width, pct);
  }
  setCssPercentageWidthFor(element, nValue, pct) {
    if (pct) {
      element.style.width = pct;
    } else {
      element.style.width = nValue + "%";
    }
  }
  getPercentageWidthString(nValue, pct) {
    if (pct) {
      return pct;
    } else {
      return nValue + "%";
    }
  }
  getWidthStyleValue(pct) {
    if (this.isTimelineOverflowingHorizontally()) {
      return this.resBlockMinWidthPx + "px";
    } else {
      if (this.isAlwaysCalculatePixelWidths()) {
        return this.resBlockWidthPx + "px";
      } else {
        return this.getPercentageWidthString(this.resBlockWidthPercentage, pct);
      }
    }
  }
  fillTimelineForHourResolution(startDate, endDate, left) {
    let timeline = this;
    this.firstDay = true;
    let hourCounter;
    let even;
    this.fillTimelineForHour(DateTimeConstants.HOUR_INTERVAL, startDate, endDate, {
      setup() {
        hourCounter = this.getFirstHourOfVisibleRange(startDate);
        even = this.isEven(startDate);
      },
      fillResolutionBlock(index, date, currentYear, lastTimelineBlock) {
        let childCount = timeline.resolutionDiv.childElementCount;
        if (timeline.isValidChildIndex(index, childCount)) {
          let resBlock = timeline.resolutionDiv.childNodes.item(index);
          timeline.fillHourResolutionBlock(resBlock, date, index, hourCounter, lastTimelineBlock, left, even);
          hourCounter = (hourCounter + 1) % 24;
          even = !even;
        } else {
          timeline.logIndexOutOfBounds("hour", index, childCount);
          return;
        }
      },
      isEven(startDate2) {
        let normalDate = timeline.toNormalDate(startDate2);
        if (timeline.normalStartDate.getTime() < normalDate.getTime()) {
          let hours = Math.floor((normalDate.getTime() - timeline.normalStartDate.getTime()) / DateTimeConstants.HOUR_INTERVAL);
          return hours % 2 == 1;
        }
        return false;
      },
      getFirstHourOfVisibleRange(startDate2) {
        let normalDate = timeline.toNormalDate(startDate2);
        if (timeline.normalStartDate.getTime() < normalDate.getTime()) {
          let hours = Math.floor((normalDate.getTime() - timeline.normalStartDate.getTime()) / DateTimeConstants.HOUR_INTERVAL);
          return (timeline.firstHourOfRange + hours) % 24;
        }
        return timeline.firstHourOfRange;
      }
    });
  }
  fillTimelineForDayResolution(startDate, endDate, left) {
    let timeline = this;
    let dayCounter;
    let even;
    let firstWeek = true;
    let weekIndex = 0;
    let weekday;
    this.fillTimelineForDayOrWeek(DateTimeConstants.DAY_INTERVAL, startDate, endDate, {
      setup: function() {
        dayCounter = this.getFirstDayOfVisibleRange(startDate);
        even = this.isEven(startDate, timeline.firstDayOfRange);
      },
      fillResolutionBlock: function(index, date, currentYear, lastTimelineBlock) {
        try {
          weekday = timeline.getWeekday(dayCounter);
          if (timeline.resolution === Resolution.Week) {
            this.fillWeekBlock(left, index, date, lastTimelineBlock);
          } else {
            this.fillDayBlock(left, index, date);
          }
        } finally {
          dayCounter = Math.max((dayCounter + 1) % 8, 1);
        }
      },
      fillDayBlock: function(left2, index, date) {
        let childCount = timeline.resolutionDiv.childElementCount;
        if (timeline.isValidChildIndex(index, childCount)) {
          let resBlock = timeline.resolutionDiv.childNodes.item(index);
          timeline.fillDayResolutionBlock(resBlock, date, index, timeline.isWeekEnd(dayCounter), left2);
        } else {
          timeline.logIndexOutOfBounds("day", index, childCount);
          return;
        }
      },
      fillWeekBlock: function(left2, index, date, lastTimelineBlock) {
        let resBlock = null;
        if (index > 0 && weekday == Weekday.First) {
          weekIndex++;
          firstWeek = false;
          even = !even;
        }
        if (index == 0 || weekday == Weekday.First) {
          let childCount = timeline.resolutionDiv.childElementCount;
          if (timeline.isValidChildIndex(weekIndex, childCount)) {
            resBlock = timeline.resolutionDiv.childNodes.item(weekIndex);
          } else {
            timeline.logIndexOutOfBounds("week", weekIndex, childCount);
            return;
          }
        }
        timeline.fillWeekResolutionBlock(resBlock, date, weekIndex, weekday, firstWeek, lastTimelineBlock, left2, even);
      },
      calcDaysLeftInFirstWeek: function(startDay) {
        let daysLeftInWeek = 0;
        if (startDay != timeline.firstDayOfWeek) {
          for (let i = startDay; ; i++) {
            daysLeftInWeek++;
            if (Math.max(i % 8, 1) === timeline.lastDayOfWeek) {
              break;
            }
          }
        }
        return daysLeftInWeek;
      },
      isEven: function(startDate2, startDay) {
        let visibleRangeNormalStartDate = timeline.toNormalDate(startDate2);
        if (timeline.normalStartDate.getTime() < visibleRangeNormalStartDate.getTime()) {
          let daysHidden = Math.floor((visibleRangeNormalStartDate.getTime() - timeline.normalStartDate.getTime()) / DateTimeConstants.DAY_INTERVAL);
          console.log("Days hidden: " + daysHidden);
          console.log("firstWeekBlockHidden = " + timeline.firstWeekBlockHidden);
          if (daysHidden === 0) {
            return false;
          }
          let daysLeftInFirstWeek = this.calcDaysLeftInFirstWeek(startDay);
          if (daysHidden > daysLeftInFirstWeek) {
            daysHidden -= daysLeftInFirstWeek;
          }
          let weeks = daysHidden / DateTimeConstants.DAYS_IN_WEEK;
          let even2 = weeks % 2 === 1;
          return timeline.firstWeekBlockHidden ? !even2 : even2;
        }
        return false;
      },
      getFirstDayOfVisibleRange: function(startDate2) {
        let visibleRangeNormalStartDate = timeline.toNormalDate(startDate2);
        if (timeline.normalStartDate.getTime() < visibleRangeNormalStartDate.getTime()) {
          let days = Math.floor((visibleRangeNormalStartDate.getTime() - timeline.normalStartDate.getTime()) / DateTimeConstants.DAY_INTERVAL);
          return (timeline.firstDayOfRange - 1 + days) % 7 + 1;
        }
        return timeline.firstDayOfRange;
      }
    });
  }
  logIndexOutOfBounds(indexName, index, childCount) {
    console.log("${indexName} index ${index} out of bounds with childCount ${childCount}. Can't fill content.");
  }
  fillTimelineForHour(interval, startDate, endDate, resBlockFiller) {
    let currentYear = null;
    let pos = startDate;
    let end = endDate;
    let index = 0;
    let lastTimelineBlock = false;
    let date;
    resBlockFiller.setup();
    while (pos <= end) {
      date = pos;
      let nextHour = new Date(pos.getTime() + interval);
      lastTimelineBlock = nextHour.getTime() > end.getTime();
      resBlockFiller.fillResolutionBlock(index, date, currentYear, lastTimelineBlock);
      pos = nextHour;
      index++;
    }
  }
  fillTimelineForDayOrWeek(interval, startDate, endDate, resBlockFiller) {
    let currentYear = null;
    let pos = startDate;
    pos = adjustToMiddleOfDay(pos, this.localeDataProvider.getTimeZone());
    let end = endDate;
    let index = 0;
    let lastTimelineBlock = false;
    let date;
    let isDST = false;
    let previousIsDST = this.localeDataProvider.isDaylightTime(startDate);
    resBlockFiller.setup();
    while (!lastTimelineBlock) {
      let dstAdjusted = this.getDSTAdjustedDate(previousIsDST, pos);
      date = dstAdjusted;
      pos = dstAdjusted;
      isDST = this.localeDataProvider.isDaylightTime(date);
      lastTimelineBlock = this.getDSTAdjustedDate(isDST, new Date(date.getTime() + interval)).getTime() > end.getTime();
      resBlockFiller.fillResolutionBlock(index, date, currentYear, lastTimelineBlock);
      previousIsDST = isDST;
      pos = new Date(pos.getTime() + interval);
      index++;
    }
  }
  isValidChildIndex(index, childCount) {
    return index >= 0 && index < childCount;
  }
  fillDayResolutionBlock(resBlock, date, index, weekend, left) {
    resBlock.innerText = this.localeDataProvider.formatDate(date, "d");
    if (weekend) {
      resBlock.classList.add(TimelineElement_1.STYLE_WEEKEND);
    } else {
      resBlock.classList.remove(TimelineElement_1.STYLE_WEEKEND);
    }
    if (this.setPositionForEachBlock && this.isTimelineOverflowingHorizontally()) {
      resBlock.style.position = "relative";
      resBlock.style.left = left + "px";
    }
  }
  fillWeekResolutionBlock(resBlock, date, index, weekDay, firstWeek, lastBlock, left, even) {
    if (resBlock != null) {
      resBlock.innerText = this.formatWeekCaption(date);
      if (even) {
        resBlock.classList.add(TimelineElement_1.STYLE_EVEN);
      } else {
        resBlock.classList.remove(TimelineElement_1.STYLE_EVEN);
      }
      if (this.setPositionForEachBlock && this.isTimelineOverflowingHorizontally()) {
        resBlock.style.position = "relative";
        resBlock.style.left = left + "px";
      }
      resBlock.classList.remove(TimelineElement_1.STYLE_FIRST, TimelineElement_1.STYLE_LAST);
    }
    if (firstWeek && (weekDay === Weekday.Last || lastBlock)) {
      let firstEl = this.resolutionDiv.firstElementChild;
      if (!firstEl.classList.contains(TimelineElement_1.STYLE_FIRST)) {
        firstEl.classList.add(TimelineElement_1.STYLE_FIRST);
      }
    } else if (lastBlock) {
      let lastEl = this.resolutionDiv.lastChild;
      if (!lastEl.classList.contains(TimelineElement_1.STYLE_LAST)) {
        lastEl.classList.add(TimelineElement_1.STYLE_LAST);
      }
    }
  }
  fillHourResolutionBlock(resBlock, date, index, hourCounter, lastBlock, left, even) {
    if (this.localeDataProvider.isTwelveHourClock()) {
      resBlock.innerText = this.localeDataProvider.formatTime(date, "h");
    } else {
      resBlock.innerText = this.localeDataProvider.formatTime(date, "HH");
    }
    if (even) {
      resBlock.classList.add(TimelineElement_1.STYLE_EVEN);
    } else {
      resBlock.classList.remove(TimelineElement_1.STYLE_EVEN);
    }
    if (this.firstDay && (hourCounter == 24 || lastBlock)) {
      this.firstDay = false;
      this.firstResBlockCount = index + 1;
    } else if (lastBlock) {
      this.lastResBlockCount = (index + 1 - this.firstResBlockCount) % 24;
    }
    if (this.setPositionForEachBlock && this.isTimelineOverflowingHorizontally()) {
      resBlock.style.position = "relative";
      resBlock.style.left = left + "px";
    }
  }
};
TimelineElement.STYLE_ROW = "row";
TimelineElement.STYLE_COL = "col";
TimelineElement.STYLE_MONTH = "month";
TimelineElement.STYLE_YEAR = "year";
TimelineElement.STYLE_DAY = "day";
TimelineElement.STYLE_WEEK = "w";
TimelineElement.STYLE_RESOLUTION = "resolution";
TimelineElement.STYLE_EVEN = "even";
TimelineElement.STYLE_WEEKEND = "weekend";
TimelineElement.STYLE_SPACER = "spacer";
TimelineElement.STYLE_FIRST = "f-col";
TimelineElement.STYLE_CENTER = "c-col";
TimelineElement.STYLE_LAST = "l-col";
TimelineElement.STYLE_MEASURE = "measure";
__decorate5([
  property({
    reflect: true,
    converter: {
      fromAttribute: (value, type) => {
        return Resolution[value];
      },
      toAttribute: (value, type) => {
        return Resolution[value];
      }
    }
  })
], TimelineElement.prototype, "resolution", void 0);
__decorate5([
  property({
    reflect: true,
    converter: {
      fromAttribute: (value, type) => {
        return value ? value.length > 13 ? value.substring(0, 13) : value : value;
      }
    }
  })
], TimelineElement.prototype, "startDateTime", void 0);
__decorate5([
  property({
    reflect: true,
    converter: {
      fromAttribute: (value, type) => {
        return value ? value.length > 13 ? value.substring(0, 13) : value : value;
      }
    }
  })
], TimelineElement.prototype, "endDateTime", void 0);
__decorate5([
  property({ reflect: true })
], TimelineElement.prototype, "timeZone", void 0);
__decorate5([
  property({ reflect: true })
], TimelineElement.prototype, "locale", void 0);
__decorate5([
  property({ reflect: true })
], TimelineElement.prototype, "firstDayOfWeek", void 0);
__decorate5([
  property({ reflect: true, type: Boolean })
], TimelineElement.prototype, "twelveHourClock", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "minWidth", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "normalStartDate", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "normalEndDate", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "lastDayOfWeek", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "firstDayOfRange", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "firstHourOfRange", void 0);
__decorate5([
  property({ reflect: true })
], TimelineElement.prototype, "scrollContainerId", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "monthRowVisible", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "yearRowVisible", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "monthNames", void 0);
__decorate5([
  property()
], TimelineElement.prototype, "weekdayNames", void 0);
__decorate5([
  query("#resolutionDiv")
], TimelineElement.prototype, "resolutionDiv", void 0);
TimelineElement = TimelineElement_1 = __decorate5([
  customElement("timeline-element")
], TimelineElement);

// node_modules/tltv-gantt-element/dist/src/gantt-scroller-mixin.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GanttScrollerMixin = (base) => {
  class GanttScrollerMixin2 extends base {
    /**
     * Register additional scroll event handler to the given element. scrollTop from gantt container will be delegated
     * to the given element and vice versa.
     * @param scrollElement Any scrollable element with scrollTop property or null to clear scroll element.
     */
    registerScrollElement(scrollElement) {
      if (!scrollElement) {
        if (this._scrollElement) {
          this._scrollElement.removeEventListener("scroll", this._handleScrollElementScroll);
          this._container.removeEventListener("scroll", this._handleContainerScroll);
        }
        this._scrollElement = scrollElement;
        return;
      }
      this._scrollElement = scrollElement;
      let self = this;
      this.updateComplete.then(() => {
        let container = self._container;
        self._handleScrollElementScroll = () => self._onHandleScrollElementScroll(self);
        self._handleContainerScroll = () => self._onHandleContainerScroll(self);
        scrollElement.addEventListener("scroll", self._handleScrollElementScroll);
        container.addEventListener("scroll", self._handleContainerScroll);
      });
    }
    _onHandleScrollElementScroll(ganttElement) {
      let self = this;
      clearTimeout(self._pauseContainerScroll);
      if (ganttElement._scrollElement.scrollTop == ganttElement._container.scrollTop) {
        return;
      }
      self._container.removeEventListener("scroll", self._handleContainerScroll);
      requestAnimationFrame(() => {
        ganttElement._container.scrollTop = ganttElement._scrollElement.scrollTop > 0 ? ganttElement._scrollElement.scrollTop : 0;
      });
      self._pauseContainerScroll = setTimeout(() => self._container.addEventListener("scroll", self._handleContainerScroll), 50);
    }
    _onHandleContainerScroll(ganttElement) {
      let self = this;
      clearTimeout(self._pauseScrollElementScroll);
      if (ganttElement._scrollElement.scrollTop == ganttElement._container.scrollTop) {
        return;
      }
      self._scrollElement.removeEventListener("scroll", self._handleScrollElementScroll);
      requestAnimationFrame(() => {
        ganttElement._scrollElement.scrollTop = ganttElement._container.scrollTop > 0 ? ganttElement._container.scrollTop : 0;
      });
      self._pauseScrollElementScroll = setTimeout(() => self._scrollElement.addEventListener("scroll", self._handleScrollElementScroll), 50);
    }
  }
  __decorate6([
    query("#container")
  ], GanttScrollerMixin2.prototype, "_container", void 0);
  return GanttScrollerMixin2;
};

// node_modules/tltv-gantt-element/dist/src/gantt-steps-base.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GanttStepsBase = class extends GanttScrollerMixin(LitElement) {
  constructor() {
    super(...arguments);
    this._steps = [];
  }
  getContentWidth() {
    return getWidth(this.getContent());
  }
  getContentHeight() {
    return getHeight(this.getContent());
  }
  getContent() {
    return this._content;
  }
  /** Returns offset top in pixels relative to content top edge. */
  getOffsetTopContentElement(element) {
    if (element instanceof GanttSubStepsBase && element.substep) {
      return this.getOffsetTop(element.owner);
    }
    return this.getOffsetTop(element);
  }
  getOffsetTop(element) {
    if (element instanceof GanttSubStepsBase && element.substep || element.offsetParent === this._content) {
      return element.offsetTop;
    } else if (element.offsetParent === this) {
      return element.offsetTop - this._container.offsetTop;
    } else {
      throw "element.offsetParent should be either content or gantt element";
    }
  }
  /** Returns offset left in pixels relative to content left edge. */
  getOffsetLeftContentElement(element) {
    if (element instanceof GanttSubStepsBase && element.substep) {
      return this.getOffsetLeft(element.owner);
    }
    return this.getOffsetLeft(element);
  }
  getOffsetLeft(element) {
    if (element instanceof GanttSubStepsBase && element.substep || element.offsetParent === this._content) {
      return element.offsetLeft;
    } else if (element.offsetParent === this) {
      return element.offsetLeft - this._container.offsetLeft;
    } else {
      throw "element.offsetParent should be either content or gantt element";
    }
  }
  handleSlotchange(e) {
    let slot = e.target;
    this._steps = slot.assignedElements({ flatten: true }).map((element) => element);
    this._steps.forEach((step, index) => step.position = index);
    this.initStepsYPosition();
    console.log(`GanttElement.handleSlotchange ended with ${this._steps.length} step(s)`);
  }
  findStepIndexAt(topY) {
    let step;
    for (let index = 0; index < this._steps.length; index++) {
      step = this._steps[index];
      if (this.isBetween(topY, this.getOffsetTop(step), this.getOffsetTop(step) + step.offsetHeight)) {
        return index;
      }
    }
    ;
    return null;
  }
  /**
  * Helper method to find Step element by given starting point and y-position
  * and delta-y. Starting point is there to optimize performance a bit as
  * there's no need to iterate through every single step element.
  *
  * @param startFromStep
  *            Starting point element
  * @param startTopY
  * @param startBottomY
  * @param newY
  *            target y-axis position (relative to scroll container)
  * @param deltay
  *            delta-y relative to starting point element.
  * @return Step element at y-axis position. May be same element as given
  *         startFromBar element.
  */
  findStepElement(startFromStep, startTopY, startBottomY, newY, deltay) {
    let substep = startFromStep.substep;
    if (substep) {
      startFromStep = startFromStep.owner;
    }
    if (this.isBetween(newY, startTopY, startBottomY)) {
      console.log("findStepElement returns same: Y " + newY + " between " + startTopY + "-" + startBottomY);
      return startFromStep;
    }
    let startIndex = this._steps.indexOf(startFromStep);
    let stepCandidate;
    let i = startIndex;
    if (deltay > 0) {
      i++;
      for (; i < this._steps.length; i++) {
        stepCandidate = this._steps[i];
        if (this.isBetween(newY, this.getOffsetTop(stepCandidate), this.getOffsetTop(stepCandidate) + stepCandidate.offsetHeight)) {
          return stepCandidate;
        }
      }
    } else if (deltay < 0) {
      i--;
      for (; i >= 0; i--) {
        stepCandidate = this._steps[i];
        if (this.isBetween(newY, this.getOffsetTop(stepCandidate), this.getOffsetTop(stepCandidate) + stepCandidate.offsetHeight)) {
          return stepCandidate;
        }
      }
    }
    return startFromStep;
  }
  isBetween(v, includeMin, includeMax) {
    return v >= includeMin && v <= includeMax;
  }
  getSteps() {
    return this._steps;
  }
  initStepsYPosition() {
    setTimeout(() => {
      let currentTopPosition = 0;
      this._steps.forEach((step) => {
        if (!step.substep) {
          step.style.top = currentTopPosition + "px";
          currentTopPosition += getElementHeightWithMargin(step);
        }
      });
    }, 0);
  }
};
__decorate7([
  query("#gantt-container")
], GanttStepsBase.prototype, "_ganttContainer", void 0);
__decorate7([
  query("#content")
], GanttStepsBase.prototype, "_content", void 0);

// node_modules/tltv-gantt-element/dist/src/gantt-events-base.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GanttEventsBase = class extends GanttTimelineMixin(GanttStepsBase) {
  constructor() {
    super(...arguments);
    this.movableSteps = true;
    this.resizableSteps = true;
    this.movableStepsBetweenRows = true;
    this.touching = false;
    this.tapTimeWindow = 400;
    this.ignoreTouchTimeWindow = 200;
    this.ignoreMouseEventsMaxTime = 1e3;
    this.ignoreMouseEvents = false;
    this.autoScrollStepSize = 10;
    this.autoScrollAreaSize = 5;
    this.insideTapTimeWindow = true;
  }
  isInsideTouchTimeWindow() {
    return this.ignoreTouchTimeWindow > 0 && Date.now() - this.touchStartTime <= this.ignoreTouchTimeWindow;
  }
  // touchstart is fired before mousedown
  handleTouchStart(event) {
    if (event.touches.length != 1) {
      return;
    }
    if (this.touchStartTime === Date.now()) {
      return;
    }
    clearTimeout(this.ignoreMouseEventsId);
    this.ignoreMouseEvents = true;
    this.touchStartTime = Date.now();
    this.insideTapTimeWindow = true;
    if (event.target instanceof GanttStepElement) {
      this.setEventCapturePoint(event, event.target);
      this.addEventListener("touchend", this._handleTouchEnd);
      let self = this;
      this.touchStartTimeoutId = setTimeout(() => {
        this.touching = true;
        self.addEventListener("touchmove", self._handleTouchMove);
        self.addEventListener("touchcancel", self._handleTouchCancel);
        self.updateMoveElementFor(self._eventTargetStep);
      }, this.ignoreTouchTimeWindow);
      this.touchStartTapTimeoutId = setTimeout(() => {
        self.insideTapTimeWindow = false;
      }, this.tapTimeWindow);
    } else if (event.target === this) {
      this.touching = true;
      this.setEventCapturePoint(event, null);
      this.addEventListener("touchend", this._handleTouchEnd);
      let self = this;
      this.touchStartTapTimeoutId = setTimeout(() => {
        self.insideTapTimeWindow = false;
      }, this.tapTimeWindow);
      this.addEventListener("touchmove", this._handleTouchMove);
      this.addEventListener("touchcancel", this._handleTouchCancel);
    }
  }
  _handleTouchEnd(event) {
    if (!this.touching || this.isInsideTouchTimeWindow()) {
      this._doHandleTouchEnd(() => {
      });
    } else {
      let self = this;
      this._doHandleTouchEnd(() => {
        if (self.insideTapTimeWindow && (!(event.target instanceof GanttStepElement) || self._eventTargetStep === self.findStepByAnotherStepEvent(self._eventTargetStep, event))) {
          self._handleTap(event);
        } else if (!this.isInsideTouchTimeWindow()) {
          if (self.insideTapTimeWindow && event.target instanceof GanttStepElement) {
            self.handleMoveOrResize(event);
          }
          self.handleMouseOrTouchUp(event);
        }
      });
    }
  }
  _doHandleTouchEnd(operation) {
    clearTimeout(this.touchStartTimeoutId);
    clearTimeout(this.touchStartTapTimeoutId);
    this.removeEventListener("touchend", this._handleTouchEnd);
    this.removeEventListener("touchmove", this._handleTouchMove);
    this.removeEventListener("touchcancel", this._handleTouchCancel);
    try {
      operation();
    } finally {
      this.touching = false;
      this.insideTapTimeWindow = true;
      this.deferredResetIgnoreMouseEvents();
      this.clearEventCapturePoint();
      this.hideMoveElement();
    }
  }
  _handleTouchMove(event) {
    if (this.isInsideTouchTimeWindow()) {
      this.touchStartTime = Date.now();
      this._doHandleTouchEnd(() => {
      });
      event.preventDefault();
      return;
    }
    if (this.handleMoveOrResize(event)) {
      event.preventDefault();
    }
  }
  _handleTouchCancel(event) {
    clearTimeout(this.touchStartTimeoutId);
    clearTimeout(this.touchStartTapTimeoutId);
    this.touching = false;
    this.deferredResetIgnoreMouseEvents();
    this.clearEventCapturePoint();
    this.hideMoveElement();
  }
  handleMouseDown(event) {
    if (this.ignoreMouseEvents) {
      return;
    }
    if (event.target instanceof GanttStepElement) {
      this.setEventCapturePoint(event, event.target);
      this.addEventListener("mouseup", this._handleMouseUp);
      this.addEventListener("mousemove", this._handleMouseMove);
      window.addEventListener("mouseup", this._handleMouseUpOutside);
      window.GanttElementEvents = this;
    } else if (event.target === this) {
      this.setEventCapturePoint(event, null);
      this.addEventListener("mouseup", this._handleMouseUp);
      window.addEventListener("mouseup", this._handleMouseUpOutside);
      window.GanttElementEvents = this;
    }
  }
  _handleMouseUp(event) {
    if (this.ignoreMouseEvents) {
      return;
    }
    if (!this.movePoint) {
      this.movePoint = getPointForEvent(event, this._container);
    }
    if (this.capturePoint && this.movePoint && this.capturePoint[0] == this.movePoint[0] && this.capturePoint[1] == this.movePoint[1]) {
      this._handleTap(event);
    } else {
      this.handleMouseOrTouchUp(event);
    }
    this.endMouseEvent();
    event.stopPropagation();
  }
  _handleMouseUpOutside(event) {
    if (!window.GanttElementEvents) {
      console.error("Attempted to end Gantt mouse events without window.GanttElementEvents target gantt element");
      return;
    }
    let target = window.GanttElementEvents;
    target.resetStepPosition(target._eventTargetStep);
    target.hideMoveElement();
    target.endMouseEvent();
  }
  _handleMouseMove(event) {
    if (this.ignoreMouseEvents) {
      return;
    }
    this.handleMoveOrResize(event);
  }
  _handleTap(event) {
    if (event.target instanceof GanttStepElement) {
      this.dispatchEvent(new CustomEvent("ganttStepClick", {
        detail: {
          uid: event.target.uid,
          start: formatInTimeZone(event.target.start, this.getTimeZone(), "yyyy-MM-dd'T'HH:mm:ss"),
          end: formatInTimeZone(event.target.end, this.getTimeZone(), "yyyy-MM-dd'T'HH:mm:ss"),
          step: event.target,
          event
        }
      }));
    } else {
      this.dispatchEvent(new CustomEvent("ganttBackgroundClick", {
        detail: {
          index: this.findStepIndexAt(getPageY(event, this._container) - (this._container.offsetTop + this.offsetTop)),
          date: formatInTimeZone(this._timeline.getDateForLeftPosition(getPageX(event, this._container) - (this._container.offsetLeft + this.offsetLeft)), this.getTimeZone(), "yyyy-MM-dd'T'HH:mm:ss"),
          event
        }
      }));
    }
    this.hideMoveElement();
  }
  handleMoveOrResize(event) {
    this.movePoint = getPointForEvent(event, this._container);
    if (!this._eventTargetStep) {
      return false;
    }
    let deltax = getPageX(event, this._container) - this.capturePoint[0];
    let deltay = getPageY(event, this._container) - this.capturePoint[1];
    if (this._eventTargetStep.resizing) {
      if (this.resizingFromLeft) {
        this.updateStepResizingLeft(this._eventTargetStep, deltax);
      } else {
        this.updateStepResizingRight(this._eventTargetStep, deltax);
      }
      this.updateMoveElementFor(this._eventTargetStep);
    } else if (this._eventTargetStep.moving) {
      if (this.movableSteps) {
        this.moveStepHorizontally(this._eventTargetStep, deltax);
        this.updateMoveElementFor(this._eventTargetStep);
      }
      if (this.movableStepsBetweenRows) {
        this.updateStepYPosition(this._eventTargetStep, deltay);
      }
      this.autoScroll();
    }
    return true;
  }
  handleMouseOrTouchUp(event) {
    if (!this._eventTargetStep) {
      this.hideMoveElement();
      return;
    }
    if (this._eventTargetStep.resizing) {
      console.log("Resizing done");
      this.internalMoveOrResizeCompleted(this._eventTargetStep, null, false, event);
    } else if (this._eventTargetStep.moving) {
      console.log("Moving done");
      this.moveCompleted(this._eventTargetStep, getPageY(event, this._container), event);
    } else {
      this.resetStepPosition(this._eventTargetStep);
    }
    this.hideMoveElement();
  }
  autoScroll() {
    if (this._container.scrollTop > 0 && this._getRelativeMovePointY() <= this._container.scrollTop + this.autoScrollAreaSize) {
      this._container.scrollTop = Math.max(0, this._container.scrollTop - this.autoScrollStepSize);
      return;
    }
    if (this._getRelativeMovePointY() >= this._container.clientHeight + this._container.scrollTop - this.autoScrollAreaSize) {
      this._container.scrollTop = Math.min(this._container.scrollHeight - this._container.clientHeight, this._container.scrollTop + this.autoScrollStepSize);
      return;
    }
    if (this._container.scrollLeft > 0 && this._getRelativeMovePointX() <= this._container.scrollLeft + this.autoScrollAreaSize) {
      this._container.scrollLeft = Math.max(0, this._container.scrollLeft - this.autoScrollStepSize);
      return;
    }
    if (this._getRelativeMovePointX() >= this._container.clientWidth + this._container.scrollLeft - this.autoScrollAreaSize) {
      this._container.scrollLeft = Math.min(this._container.scrollWidth - this._container.clientWidth, this._container.scrollLeft + this.autoScrollStepSize);
      return;
    }
  }
  deferredResetIgnoreMouseEvents() {
    clearTimeout(this.ignoreMouseEventsId);
    let self = this;
    this.ignoreMouseEventsId = setTimeout(() => self.ignoreMouseEvents = false, this.ignoreMouseEventsMaxTime);
  }
  endMouseEvent() {
    this.clearEventCapturePoint();
    this.removeEventListener("mouseup", this._handleMouseUp);
    this.removeEventListener("mousemove", this._handleMouseMove);
    window.removeEventListener("mouseup", this._handleMouseUpOutside);
    window.GanttElementEvents = null;
  }
  resetStepPosition(step) {
    if (!step) {
      return;
    }
    step.style.setProperty("left", this.capturePointLeftPercentage);
    step.style.setProperty("width", this.capturePointWidthPercentage);
    this.resetBarYPosition(step);
  }
  resetBarYPosition(step) {
    if (!step.substep) {
      step.style.top = this.calculateNewStepYPosition(step) + "px";
    } else {
      step.style.top = this.capturePointTopPx + "px";
    }
  }
  calculateNewStepYPosition(step) {
    var rowIndex = this.getSteps().indexOf(step);
    if (rowIndex > 0) {
      return parseInt(this.getSteps()[rowIndex - 1].style.top, 10) + getElementHeightWithMargin(this.getSteps()[rowIndex - 1]);
    } else if (this.getSteps().length > 1) {
      return parseInt(this.getSteps()[rowIndex + 1].style.top, 10) - getElementHeightWithMargin(step);
    } else {
      return 0;
    }
  }
  setEventCapturePoint(event, step) {
    this._eventTargetStep = step;
    this.capturePoint = getPointForEvent(event, this._container);
    this.movePoint = null;
    if (!step) {
      return;
    }
    this.capturePointLeftPercentage = step.style.left;
    this.capturePointWidthPercentage = step.style.width;
    this.capturePointTopPx = this.getOffsetTop(step);
    this.capturePointTopRelativeToContentPx = this.getOffsetTopContentElement(step);
    this.capturePointLeftPx = step.offsetLeft;
    this.capturePointWidthPx = step.clientWidth;
    this.movePoint = [this.capturePoint[0], this.capturePoint[1]];
    if (this.detectResizing(step)) {
      step.resizing = true;
      this.resizingFromLeft = this.isResizingLeft(step);
    } else {
      step.moving = (this.movableSteps || this.movableStepsBetweenRows) && step.movable;
    }
  }
  clearEventCapturePoint() {
    if (this._eventTargetStep) {
      if (this._eventTargetStep.moving)
        this._eventTargetStep.moving = false;
      if (this._eventTargetStep.resizing)
        this._eventTargetStep.resizing = false;
      this._eventTargetStep = null;
    }
  }
  detectResizing(step) {
    return this.resizableSteps && step.resizable && !step.classList.contains("has-sub-steps") && (this.isResizingLeft(step) || this.isResizingRight(step));
  }
  isResizingLeft(step) {
    if (step.substep) {
      return this.movePoint[0] <= this.getStepOffsetLeft(step) + GanttStepElement.RESIZE_WIDTH;
    }
    return this.movePoint[0] <= this.getStepOffsetLeft(step) + GanttStepElement.RESIZE_WIDTH;
  }
  isResizingRight(step) {
    if (step.substep) {
      return this.movePoint[0] >= this.getStepOffsetLeft(step) + step.offsetWidth + -GanttStepElement.RESIZE_WIDTH;
    }
    return this.movePoint[0] >= this.getStepOffsetLeft(step) + step.offsetWidth + -GanttStepElement.RESIZE_WIDTH;
  }
  getStepOffsetLeft(step) {
    if (step.substep) {
      return this.offsetLeft + this.getContent().offsetLeft + step.owner.offsetLeft + step.offsetLeft;
    }
    return this.offsetLeft + this._container.offsetLeft + step.offsetLeft;
  }
  moveStepHorizontally(step, deltax) {
    step.style.left = this.capturePointLeftPx + deltax + "px";
  }
  updateMoveElementFor(step) {
    if (!step) {
      this.hideMoveElement();
      return;
    }
    this.moveElement.style.removeProperty("display");
    let styleLeft = step.style.left;
    let left = this.capturePointLeftPx;
    if (styleLeft && styleLeft.length > 2 && styleLeft.endsWith("px")) {
      left = parseInt(styleLeft, 10);
    }
    if (step.substep) {
      left += step.owner.offsetLeft;
    }
    left -= this._container.scrollLeft;
    this.moveElement.style.left = left + "px";
    this.moveElement.style.width = step.clientWidth + "px";
    this.moveElement.style.height = this._ganttContainer.clientHeight + "px";
  }
  hideMoveElement() {
    this.moveElement.style.display = "none";
  }
  /*
  * This is called when target step element is moved successfully. Element's
  * CSS attributes 'left' and 'width' are updated (unit in pixels).
  */
  moveCompleted(step, y, event) {
    let deltay = this.movableStepsBetweenRows ? y - this.capturePoint[1] : 0;
    let newPosition = this.findStepByAnotherStepEvent(step, event);
    this.internalMoveOrResizeCompleted(step, newPosition, true, event);
  }
  findStepByAnotherStepEvent(step, event) {
    let y = getPageY(event, this._container);
    let deltay = this.movableStepsBetweenRows ? y - this.capturePoint[1] : 0;
    return this.findStepElement(step, this.capturePointTopRelativeToContentPx, this.capturePointTopRelativeToContentPx + getElementHeightWithMargin(step), y - (this._container.offsetTop + this.offsetTop), deltay);
  }
  internalMoveOrResizeCompleted(step, newPosition, move, event) {
    let newStepUid = step.uid;
    if (newPosition && step !== newPosition) {
      newStepUid = newPosition.uid;
    }
    let startDate = step.start;
    let endDate = step.end;
    if (move && this.movableSteps || !move && this.resizableSteps) {
      let left = parseInt(step.style.left, 10);
      if (step.substep) {
        left += step.owner.offsetLeft;
      }
      startDate = this._timeline.getDateForLeftPosition(left);
      left += getWidth(step);
      endDate = this._timeline.getDateForLeftPosition(left);
      step.start = startDate;
      step.end = endDate;
    }
    if (move) {
      if (this.movableStepsBetweenRows) {
        if (step.substep) {
          this.resetBarYPosition(step);
        } else if (step.uid !== newStepUid) {
          this.moveStepPosition(step, newStepUid);
        } else {
          this.resetBarYPosition(step);
        }
      }
      this.dispatchEvent(new CustomEvent("ganttStepMove", {
        detail: {
          uid: step.uid,
          newUid: newStepUid,
          start: formatInTimeZone(startDate, this.getTimeZone(), "yyyy-MM-dd'T'HH:mm:ss"),
          end: formatInTimeZone(endDate, this.getTimeZone(), "yyyy-MM-dd'T'HH:mm:ss"),
          step,
          event
        }
      }));
    } else {
      this.dispatchEvent(new CustomEvent("ganttStepResize", {
        detail: {
          uid: step.uid,
          start: formatInTimeZone(startDate, this.getTimeZone(), "yyyy-MM-dd'T'HH:mm:ss"),
          end: formatInTimeZone(endDate, this.getTimeZone(), "yyyy-MM-dd'T'HH:mm:ss"),
          step,
          event
        }
      }));
    }
  }
  moveStepPosition(step, newStepUid) {
    let steps = [...this._steps];
    let movedOverStep = steps.find((step2) => step2.uid === newStepUid);
    let movingOverSiblingBelow = steps.indexOf(step) + 1 === steps.indexOf(movedOverStep);
    if (movedOverStep) {
      let insertBeforeStep;
      if (steps.indexOf(movedOverStep) + 1 >= steps.length) {
        insertBeforeStep = null;
      } else if (movingOverSiblingBelow) {
        insertBeforeStep = steps[steps.indexOf(movedOverStep) + 1];
      } else {
        insertBeforeStep = movedOverStep;
      }
      steps.splice(steps.indexOf(step), 1);
      this.removeChild(step);
      this.insertBefore(step, insertBeforeStep);
    }
  }
  updateStepYPosition(step, deltay) {
    let stepHeight = getElementHeightWithMargin(step);
    let offsetY = 0;
    if (step.substep) {
      offsetY = parseInt(step.owner.style.top, 10) || 0;
    }
    let stepTop = (parseInt(step.style.top, 10) || 0) + offsetY;
    let maxStepEdgeDeltaUp = stepTop - this._getRelativeCapturePointY();
    let maxStepEdgeDeltaDown = stepHeight + maxStepEdgeDeltaUp;
    if (deltay <= maxStepEdgeDeltaUp) {
      if (stepTop - stepHeight >= 0) {
        step.style.top = stepTop - stepHeight - offsetY + "px";
      }
    } else if (deltay >= maxStepEdgeDeltaDown) {
      step.style.top = Math.min(this.getContent().clientHeight - stepHeight, stepTop + stepHeight - offsetY) + "px";
    }
  }
  updateStepResizingRight(step, deltax) {
    let newWidth = this.capturePointWidthPx + deltax;
    if (newWidth >= GanttStepElement.RESIZE_WIDTH) {
      step.style.left = this.capturePointLeftPx + "px";
      step.style.width = newWidth + "px";
    }
  }
  updateStepResizingLeft(step, deltax) {
    let newLeft = this.capturePointLeftPx + deltax;
    let newWidth = this.capturePointWidthPx - deltax;
    if (newWidth >= GanttStepElement.RESIZE_WIDTH) {
      step.style.left = newLeft + "px";
      step.style.width = newWidth + "px";
    }
  }
  _getRelativeCapturePointY() {
    return this.capturePoint[1] - (this._container.offsetTop + this.offsetTop);
  }
  _getRelativeMovePointY() {
    return this.movePoint[1] - (this._container.offsetTop + this.offsetTop);
  }
  _getRelativeMovePointX() {
    return this.movePoint[0] - (this._container.offsetLeft + this.offsetLeft);
  }
};
__decorate8([
  property({ reflect: true, type: Boolean })
], GanttEventsBase.prototype, "movableSteps", void 0);
__decorate8([
  property({ reflect: true, type: Boolean })
], GanttEventsBase.prototype, "resizableSteps", void 0);
__decorate8([
  property({ reflect: true, type: Boolean })
], GanttEventsBase.prototype, "movableStepsBetweenRows", void 0);
__decorate8([
  property({ reflect: true, type: Boolean })
], GanttEventsBase.prototype, "touching", void 0);
__decorate8([
  query("#mv-el")
], GanttEventsBase.prototype, "moveElement", void 0);

// node_modules/tltv-gantt-element/dist/src/css-background-grid-mixin.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BackgroundGridMixin = (base) => {
  class BackgroundGridMixin2 extends base {
    constructor() {
      super(...arguments);
      this.backgroundGridEnabled = true;
      this.useAlwaysPxSizeInBackground = false;
    }
    initGrid(container, content) {
      this._bgcontainer = container;
    }
    hideGrid() {
      this._bgcontainer.style.backgroundImage = "none";
    }
    showGrid() {
      this._bgcontainer.style.removeProperty("background-image");
    }
    setBackgroundSize(gridBlockWidth, gridBlockWidthPx, gridBlockHeightPx) {
      this._bgcontainer.style.setProperty("background-size", gridBlockWidth + " " + gridBlockHeightPx + "px");
    }
    setBackgroundPosition(offsetX, offsetY, posXPx, posYPx) {
      this._bgcontainer.style.setProperty("background-position", offsetX + " " + offsetY);
    }
  }
  __decorate9([
    property()
  ], BackgroundGridMixin2.prototype, "backgroundGridEnabled", void 0);
  __decorate9([
    property()
  ], BackgroundGridMixin2.prototype, "useAlwaysPxSizeInBackground", void 0);
  return BackgroundGridMixin2;
};

// node_modules/tltv-gantt-element/dist/src/gantt-element.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var GanttElement = class GanttElement2 extends BackgroundGridMixin(GanttEventsBase) {
  static get styles() {
    return css`
      :host {
        display: block;
        position: relative;

        --grid-line-color: #eee;
        --gantt-element-width: 100%;
        --gantt-element-height: auto;

        width: var(--gantt-element-width);
        height: var(--gantt-element-height);
      }

      #gantt-container {
        position: relative;
        width: 100%;
        user-select: none;
        overflow: hidden;
      }

      #container {
        position: relative;
        width: 100%;
        height: 100%;
        user-select: none;
        overflow-x: hidden;
        overflow-y: auto;
        
        background: var(--grid-line-color);
        /* Webkit (Safari/Chrome 10) */
        background: -webkit-gradient(linear, left top, right top, color-stop(1px, var(--grid-line-color)), color-stop(0, transparent)), -webkit-gradient(linear, left top, left bottom, color-stop(1px, var(--grid-line-color)), color-stop(0, transparent));
        /* Webkit (Chrome 11+) */
        background: -webkit-linear-gradient(var(--grid-line-color) 1px, transparent 0px), -webkit-linear-gradient(0deg, var(--grid-line-color) 1px, transparent 0px);
        /* Mozilla Firefox */
        background: -moz-linear-gradient(var(--grid-line-color) 1px, transparent 0px), -moz-linear-gradient(0deg, var(--grid-line-color) 1px, transparent 0px);
        /* IE10 Consumer Preview */
        background: -ms-linear-gradient(0deg, var(--grid-line-color) 1.1px, transparent 0px), -ms-linear-gradient(90deg, var(--grid-line-color) 1.1px, transparent 0px);
        /* Opera */
        background: -o-linear-gradient(var(--grid-line-color) 1px, transparent 0px), -o-linear-gradient(90deg, var(--grid-line-color) 1px, transparent 0px);
        /* W3C Markup, IE10 Release Preview */
        background: linear-gradient(0deg, var(--grid-line-color) 1px, transparent 0px), linear-gradient(90deg, var(--grid-line-color) 1.1px, transparent 0px);
        
        background-attachment: local;
      }

      #content {
        position: relative;
        overflow: hidden;
      }

      #mv-el {
        position: absolute;
				top: 0;
				box-sizing: border-box;
				z-index: 2;
				background: transparent;
				border-left: 1px dashed #999;
        border-right: 1px dashed #999;
        pointer-events: none;
			}
    `;
  }
  render() {
    return html`
    <div id="gantt-container">
      <timeline-element id="timeline" scrollContainerId="container"
          .directlyInsideScrollContainer="${false}"
          .resolution="${this.resolution}" 
          .startDateTime="${this.start}" 
          .endDateTime="${this.end}"
          .timeZone="${this.zone}"
          .locale="${this.locale}"
          .firstDayOfWeek="${this.firstDayOfWeek}"
          .twelveHourClock="${this.twelveHourClock}"
          .monthRowVisible="${this.monthRowVisible}"
          .yearRowVisible="${this.yearRowVisible}"
          .monthNames="${this.monthNames}"
          .weekdayNames="${this.weekdayNames}">
      </timeline-element>
      <div id="container">
        <div id="content">
          <slot @slotchange=${this.handleSlotchange}></slot>
        </div>
      </div>
      <div id="mv-el" style="display: none;"></div>
    </div>
    `;
  }
  constructor() {
    super();
    this.resolution = Resolution.Day;
    this.zone = "Europe/London";
    this.locale = "en-US";
    this.firstDayOfWeek = 1;
    this.twelveHourClock = false;
    this.monthRowVisible = true;
    this.yearRowVisible = true;
    this._resizeObserver = new ResizeObserver(() => {
      this.updateSize();
    });
    this.scrollbarWidth = 18;
  }
  firstUpdated(changedProperties) {
    this.scrollbarWidth = this.calculateScrollbarWidth();
    this.initGrid(this._container, this._content);
    super.firstUpdated(changedProperties);
    this._resizeObserver.observe(this);
    this.addEventListener("touchstart", this._handleGanttTouchStart, { passive: true });
    this.addEventListener("mousedown", this._handleGanttMouseDown);
    this.dispatchEvent(new Event("gantt-element-ready"));
  }
  updated(changedProperties) {
    if (changedProperties.has("resolution") || changedProperties.has("start") || changedProperties.has("end") || changedProperties.has("yearRowVisible") || changedProperties.has("monthRowVisible")) {
      this.timelineUpdated();
    } else if (changedProperties.has("resizableSteps")) {
      this._steps.forEach((step) => step.refresh());
    }
    super.updated(changedProperties);
  }
  handleSlotchange(e) {
    super.handleSlotchange(e);
    setTimeout(() => {
      this.updateContentHeight();
    });
  }
  updateSize() {
    let self = this;
    this.getTimeline().then((timeline) => {
      timeline.updateWidths();
      self.updateGanttContainerStyle();
      self.updateContainerStyle();
      self.updateContentWidth();
    });
  }
  async timelineUpdated() {
    await this._timeline.updateComplete;
    this.updateContentWidth();
    this._steps.forEach((step) => step.refresh());
    this.updateContainerStyle();
  }
  updateContentWidth() {
    if (getHeight(this.getContent()) > getHeight(this._container)) {
      this.getContent().style.width = getWidth(this._timeline) - this.scrollbarWidth + "px";
    } else {
      this.getContent().style.width = getWidth(this._timeline) + "px";
    }
  }
  updateContentHeight() {
    let heightOfSteps = this._steps.map((step) => getElementHeightWithMargin(step)).reduce((a, b) => a + b);
    console.log(`GanttElement.updateContentHeight calculated ${heightOfSteps}px height for content by steps`);
    this.getContent().style.height = heightOfSteps + "px";
  }
  calculateScrollbarWidth() {
    const outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.overflow = "scroll";
    document.body.appendChild(outer);
    const inner = document.createElement("div");
    outer.appendChild(inner);
    const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
    outer.parentNode.removeChild(outer);
    return scrollbarWidth;
  }
  convertGanttHeightToContainerHeight() {
    let ganttHeight = this.ownerDocument.defaultView.getComputedStyle(this).getPropertyValue("--gantt-element-height");
    if (ganttHeight && (ganttHeight.trim().endsWith("%") || ganttHeight.trim().endsWith("vm"))) {
      return "100%";
    }
    return ganttHeight;
  }
  updateGanttContainerStyle() {
    this._ganttContainer.style.height = this.convertGanttHeightToContainerHeight();
  }
  updateContainerStyle() {
    let ganttHeight = this.convertGanttHeightToContainerHeight();
    let timelineHeight = getHeight(this._timeline);
    if (ganttHeight === "auto") {
      this._container.style.height = "auto";
    } else {
      this._container.style.height = "calc(" + ganttHeight + " - " + timelineHeight + "px)";
    }
    if (this.backgroundGridEnabled) {
      this.showGrid();
    } else {
      this.hideGrid();
      return;
    }
    let resDivElementCount = this._timeline.resolutionDiv.childElementCount;
    if (resDivElementCount == 0) {
      return;
    }
    let secondResolutionBlock = null;
    let firstResolutionBlockWidth = this._timeline.getFirstResolutionElementWidth();
    if (firstResolutionBlockWidth == null) {
      return;
    }
    let secondResolutionBlockWidth = null;
    if (resDivElementCount > 2) {
      secondResolutionBlock = this._timeline.resolutionDiv.children[1];
      secondResolutionBlockWidth = getWidth(secondResolutionBlock);
    }
    let contentOverflowingHorizontally = this.isContentOverflowingHorizontally();
    let adjustBgPosition = secondResolutionBlockWidth != null && firstResolutionBlockWidth !== secondResolutionBlockWidth;
    let gridBlockWidthPx = 0;
    if (!adjustBgPosition) {
      gridBlockWidthPx = firstResolutionBlockWidth;
    } else {
      gridBlockWidthPx = secondResolutionBlockWidth;
    }
    this.updateContainerBackgroundSize(contentOverflowingHorizontally, gridBlockWidthPx);
    this.updateContainerBackgroundPosition(firstResolutionBlockWidth, contentOverflowingHorizontally, gridBlockWidthPx, adjustBgPosition);
  }
  updateContainerBackgroundSize(contentOverflowingHorizontally, gridBlockWidthPx) {
    let gridBlockWidth = null;
    if (contentOverflowingHorizontally || this.useAlwaysPxSizeInBackground) {
      gridBlockWidth = gridBlockWidthPx + "px";
    } else {
      let contentWidth = getWidth(this.getContent());
      gridBlockWidth = 100 / contentWidth * gridBlockWidthPx + "%";
    }
    let gridBlockHeightPx = this.getBgGridCellHeight();
    this.setBackgroundSize(gridBlockWidth, gridBlockWidthPx, gridBlockHeightPx);
  }
  updateContainerBackgroundPosition(firstResolutionBlockWidth, contentOverflowingHorizontally, gridBlockWidthPx, adjustBgPosition) {
    if (adjustBgPosition) {
      let realBgPosXPx = firstResolutionBlockWidth - 1;
      if (this.useAlwaysPxSizeInBackground || contentOverflowingHorizontally) {
        this.setBackgroundPosition(realBgPosXPx + "px", "0px", realBgPosXPx, 0);
      } else {
        let timelineWidth = this._timeline.calculateTimelineWidth();
        let relativeBgAreaWidth = timelineWidth - gridBlockWidthPx;
        let bgPosX = 100 / relativeBgAreaWidth * realBgPosXPx;
        this.setBackgroundPosition(bgPosX + "%", "0px", realBgPosXPx, 0);
      }
    } else {
      this.setBackgroundPosition("-1px", "0", -1, 0);
    }
  }
  getBgGridCellHeight() {
    let gridBlockHeightPx = 0;
    let firstStepIndex = 0;
    if (firstStepIndex < this.getSteps().length) {
      let firstStep = this.getSteps()[firstStepIndex];
      gridBlockHeightPx = getElementHeightWithMargin(firstStep);
      if (this.getContentHeight() % gridBlockHeightPx != 0) {
        gridBlockHeightPx = 0;
      }
    }
    return gridBlockHeightPx;
  }
  /**
  * Return true, if content is overflowing horizontally. This means also that
  * horizontal scroll bar is visible.
  */
  isContentOverflowingHorizontally() {
    if (!this._content || !this._container || !this._timeline) {
      return false;
    }
    return this._timeline.isTimelineOverflowingHorizontally();
  }
  /**
  * Return true, if content is overflowing vertically.This means also that
  * vertical scroll bar is visible.
  */
  isContentOverflowingVertically() {
    if (!this._content || !this._container) {
      return false;
    }
    return this._container.scrollHeight > this._container.clientHeight;
  }
  _handleGanttTouchStart(event) {
    this.handleTouchStart(event);
  }
  _handleGanttMouseDown(event) {
    this.handleMouseDown(event);
  }
};
__decorate10([
  property({
    reflect: true,
    converter: {
      fromAttribute: (value, type) => {
        return Resolution[value];
      },
      toAttribute: (value, type) => {
        return Resolution[value];
      }
    }
  })
], GanttElement.prototype, "resolution", void 0);
__decorate10([
  property({
    reflect: true
  })
], GanttElement.prototype, "start", void 0);
__decorate10([
  property({
    reflect: true
  })
], GanttElement.prototype, "end", void 0);
__decorate10([
  property({ reflect: true })
], GanttElement.prototype, "zone", void 0);
__decorate10([
  property({ reflect: true })
], GanttElement.prototype, "locale", void 0);
__decorate10([
  property({ reflect: true })
], GanttElement.prototype, "firstDayOfWeek", void 0);
__decorate10([
  property({ reflect: true, type: Boolean })
], GanttElement.prototype, "twelveHourClock", void 0);
__decorate10([
  property({ type: Boolean })
], GanttElement.prototype, "monthRowVisible", void 0);
__decorate10([
  property({ type: Boolean })
], GanttElement.prototype, "yearRowVisible", void 0);
__decorate10([
  property()
], GanttElement.prototype, "monthNames", void 0);
__decorate10([
  property()
], GanttElement.prototype, "weekdayNames", void 0);
GanttElement = __decorate10([
  customElement("gantt-element")
], GanttElement);
export {
  GanttElement
};
/*! Bundled license information:

lit-element/development/decorators.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=tltv-gantt-element_dist_src_gantt-element__js.js.map
