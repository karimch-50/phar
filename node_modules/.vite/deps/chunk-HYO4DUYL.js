import {
  FocusRestorationController
} from "./chunk-PJNJQYXC.js";
import {
  AriaModalController
} from "./chunk-ZE63AH6T.js";
import {
  FocusTrapController
} from "./chunk-TH3SXEA2.js";
import {
  isIOS
} from "./chunk-DV2EGEEG.js";
import {
  afterNextRender
} from "./chunk-FSP2XZVR.js";
import {
  ControllerMixin
} from "./chunk-QGCYTHXO.js";
import {
  getDeepActiveElement
} from "./chunk-F7YWWDDG.js";
import {
  css
} from "./chunk-CMT2GIH3.js";

// node_modules/@vaadin/overlay/src/vaadin-overlay-styles.js
var overlayStyles = css`
  :host {
    z-index: 200;
    position: fixed;

    /* Despite of what the names say, <vaadin-overlay> is just a container
          for position/sizing/alignment. The actual overlay is the overlay part. */

    /* Default position constraints: the entire viewport. Note: themes can
          override this to introduce gaps between the overlay and the viewport. */
    inset: 0;
    bottom: var(--vaadin-overlay-viewport-bottom);

    /* Use flexbox alignment for the overlay part. */
    display: flex;
    flex-direction: column; /* makes dropdowns sizing easier */
    /* Align to center by default. */
    align-items: center;
    justify-content: center;

    /* Allow centering when max-width/max-height applies. */
    margin: auto;

    /* The host is not clickable, only the overlay part is. */
    pointer-events: none;

    /* Remove tap highlight on touch devices. */
    -webkit-tap-highlight-color: transparent;

    /* CSS API for host */
    --vaadin-overlay-viewport-bottom: 0;
  }

  :host([hidden]),
  :host(:not([opened]):not([closing])),
  :host(:not([opened]):not([closing])) [part='overlay'] {
    display: none !important;
  }

  [part='overlay'] {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
    pointer-events: auto;

    /* Prevent overflowing the host */
    max-width: 100%;
    box-sizing: border-box;

    -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */
  }

  [part='backdrop'] {
    z-index: -1;
    content: '';
    background: rgba(0, 0, 0, 0.5);
    position: fixed;
    inset: 0;
    pointer-events: auto;
  }
`;

// node_modules/@vaadin/overlay/src/vaadin-overlay-focus-mixin.js
var OverlayFocusMixin = (superClass) => class OverlayFocusMixin extends ControllerMixin(superClass) {
  static get properties() {
    return {
      /**
       * When true, opening the overlay moves focus to the first focusable child,
       * or to the overlay part with tabindex if there are no focusable children.
       * @attr {boolean} focus-trap
       */
      focusTrap: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to enable restoring of focus when overlay is closed.
       * @attr {boolean} restore-focus-on-close
       */
      restoreFocusOnClose: {
        type: Boolean,
        value: false
      },
      /**
       * Set to specify the element which should be focused on overlay close,
       * if `restoreFocusOnClose` is set to true.
       * @type {HTMLElement}
       */
      restoreFocusNode: {
        type: HTMLElement
      }
    };
  }
  constructor() {
    super();
    this.__ariaModalController = new AriaModalController(this);
    this.__focusTrapController = new FocusTrapController(this);
    this.__focusRestorationController = new FocusRestorationController();
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this.__ariaModalController);
    this.addController(this.__focusTrapController);
    this.addController(this.__focusRestorationController);
  }
  /**
   * Release focus and restore focus after the overlay is closed.
   *
   * @protected
   */
  _resetFocus() {
    if (this.focusTrap) {
      this.__ariaModalController.close();
      this.__focusTrapController.releaseFocus();
    }
    if (this.restoreFocusOnClose && this._shouldRestoreFocus()) {
      this.__focusRestorationController.restoreFocus();
    }
  }
  /**
   * Save the previously focused node when the overlay starts to open.
   *
   * @protected
   */
  _saveFocus() {
    if (this.restoreFocusOnClose) {
      this.__focusRestorationController.saveFocus(this.restoreFocusNode);
    }
  }
  /**
   * Trap focus within the overlay after opening has completed.
   *
   * @protected
   */
  _trapFocus() {
    if (this.focusTrap) {
      this.__ariaModalController.showModal();
      this.__focusTrapController.trapFocus(this.$.overlay);
    }
  }
  /**
   * Returns true if focus is still inside the overlay or on the body element,
   * otherwise false.
   *
   * Focus shouldn't be restored if it's been moved elsewhere by another
   * component or as a result of a user interaction e.g. the user clicked
   * on a button outside the overlay while the overlay was open.
   *
   * @protected
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    const activeElement = getDeepActiveElement();
    return activeElement === document.body || this._deepContains(activeElement);
  }
  /**
   * Returns true if the overlay contains the given node,
   * including those within shadow DOM trees.
   *
   * @param {Node} node
   * @return {boolean}
   * @protected
   */
  _deepContains(node) {
    if (this.contains(node)) {
      return true;
    }
    let n = node;
    const doc = node.ownerDocument;
    while (n && n !== doc && n !== this) {
      n = n.parentNode || n.host;
    }
    return n === this;
  }
};

// node_modules/@vaadin/overlay/src/vaadin-overlay-stack-mixin.js
var getAttachedInstances = () => Array.from(document.body.children).filter((el) => el instanceof HTMLElement && el._hasOverlayStackMixin && !el.hasAttribute("closing")).sort((a, b) => a.__zIndex - b.__zIndex || 0);
var isLastOverlay = (overlay) => overlay === getAttachedInstances().pop();
var OverlayStackMixin = (superClass) => class OverlayStackMixin extends superClass {
  constructor() {
    super();
    this._hasOverlayStackMixin = true;
  }
  /**
   * Returns true if this is the last one in the opened overlays stack.
   *
   * @return {boolean}
   * @protected
   */
  get _last() {
    return isLastOverlay(this);
  }
  /**
   * Brings the overlay as visually the frontmost one.
   */
  bringToFront() {
    let zIndex = "";
    const frontmost = getAttachedInstances().filter((o) => o !== this).pop();
    if (frontmost) {
      const frontmostZIndex = frontmost.__zIndex;
      zIndex = frontmostZIndex + 1;
    }
    this.style.zIndex = zIndex;
    this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);
  }
  /** @protected */
  _enterModalState() {
    if (document.body.style.pointerEvents !== "none") {
      this._previousDocumentPointerEvents = document.body.style.pointerEvents;
      document.body.style.pointerEvents = "none";
    }
    getAttachedInstances().forEach((el) => {
      if (el !== this) {
        el.$.overlay.style.pointerEvents = "none";
      }
    });
  }
  /** @protected */
  _exitModalState() {
    if (this._previousDocumentPointerEvents !== void 0) {
      document.body.style.pointerEvents = this._previousDocumentPointerEvents;
      delete this._previousDocumentPointerEvents;
    }
    const instances = getAttachedInstances();
    let el;
    while (el = instances.pop()) {
      if (el === this) {
        continue;
      }
      el.$.overlay.style.removeProperty("pointer-events");
      if (!el.modeless) {
        break;
      }
    }
  }
};

// node_modules/@vaadin/overlay/src/vaadin-overlay-mixin.js
var OverlayMixin = (superClass) => class OverlayMixin extends OverlayFocusMixin(OverlayStackMixin(superClass)) {
  static get properties() {
    return {
      /**
       * When true, the overlay is visible and attached to body.
       */
      opened: {
        type: Boolean,
        notify: true,
        observer: "_openedChanged",
        reflectToAttribute: true
      },
      /**
       * Owner element passed with renderer function
       * @type {HTMLElement}
       */
      owner: {
        type: Object
      },
      /**
       * Object with properties that is passed to `renderer` function
       */
      model: {
        type: Object
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `owner` The host element of the renderer function.
       * - `model` The object with the properties related with rendering.
       * @type {OverlayRenderer | null | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * When true the overlay won't disable the main content, showing
       * it doesn't change the functionality of the user interface.
       * @type {boolean}
       */
      modeless: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_modelessChanged"
      },
      /**
       * When set to true, the overlay is hidden. This also closes the overlay
       * immediately in case there is a closing animation in progress.
       * @type {boolean}
       */
      hidden: {
        type: Boolean,
        reflectToAttribute: true,
        observer: "_hiddenChanged"
      },
      /**
       * When true the overlay has backdrop on top of content when opened.
       * @type {boolean}
       */
      withBackdrop: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["_rendererOrDataChanged(renderer, owner, model, opened)"];
  }
  constructor() {
    super();
    this._boundMouseDownListener = this._mouseDownListener.bind(this);
    this._boundMouseUpListener = this._mouseUpListener.bind(this);
    this._boundOutsideClickListener = this._outsideClickListener.bind(this);
    this._boundKeydownListener = this._keydownListener.bind(this);
    if (isIOS) {
      this._boundIosResizeListener = () => this._detectIosNavbar();
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("click", () => {
    });
    this.$.backdrop.addEventListener("click", () => {
    });
    this.addEventListener("mouseup", () => {
      if (document.activeElement === document.body && this.$.overlay.getAttribute("tabindex") === "0") {
        this.$.overlay.focus();
      }
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this._boundIosResizeListener) {
      this._detectIosNavbar();
      window.addEventListener("resize", this._boundIosResizeListener);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._boundIosResizeListener) {
      window.removeEventListener("resize", this._boundIosResizeListener);
    }
  }
  /**
   * Requests an update for the content of the overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.renderer) {
      this.renderer.call(this.owner, this, this.owner, this.model);
    }
  }
  /**
   * @param {Event=} sourceEvent
   */
  close(sourceEvent) {
    const evt = new CustomEvent("vaadin-overlay-close", {
      bubbles: true,
      cancelable: true,
      detail: { sourceEvent }
    });
    this.dispatchEvent(evt);
    if (!evt.defaultPrevented) {
      this.opened = false;
    }
  }
  /** @private */
  _detectIosNavbar() {
    if (!this.opened) {
      return;
    }
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", `${clientHeight - innerHeight}px`);
    } else {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", "0");
    }
  }
  /** @private */
  _addGlobalListeners() {
    document.addEventListener("mousedown", this._boundMouseDownListener);
    document.addEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.addEventListener("click", this._boundOutsideClickListener, true);
  }
  /** @private */
  _removeGlobalListeners() {
    document.removeEventListener("mousedown", this._boundMouseDownListener);
    document.removeEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.removeEventListener("click", this._boundOutsideClickListener, true);
  }
  /** @private */
  _rendererOrDataChanged(renderer, owner, model, opened) {
    const ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;
    this._oldModel = model;
    this._oldOwner = owner;
    const rendererChanged = this._oldRenderer !== renderer;
    const hasOldRenderer = this._oldRenderer !== void 0;
    this._oldRenderer = renderer;
    const openedChanged = this._oldOpened !== opened;
    this._oldOpened = opened;
    if (rendererChanged && hasOldRenderer) {
      this.innerHTML = "";
      delete this._$litPart$;
    }
    if (opened && renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  _modelessChanged(modeless) {
    if (!modeless) {
      if (this.opened) {
        this._addGlobalListeners();
        this._enterModalState();
      }
    } else {
      this._removeGlobalListeners();
      this._exitModalState();
    }
  }
  /** @private */
  _openedChanged(opened, wasOpened) {
    if (opened) {
      this._saveFocus();
      this._animatedOpening();
      afterNextRender(this, () => {
        this._trapFocus();
        const evt = new CustomEvent("vaadin-overlay-open", { bubbles: true });
        this.dispatchEvent(evt);
      });
      document.addEventListener("keydown", this._boundKeydownListener);
      if (!this.modeless) {
        this._addGlobalListeners();
      }
    } else if (wasOpened) {
      this._resetFocus();
      this._animatedClosing();
      document.removeEventListener("keydown", this._boundKeydownListener);
      if (!this.modeless) {
        this._removeGlobalListeners();
      }
    }
  }
  /** @private */
  _hiddenChanged(hidden) {
    if (hidden && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
  }
  /**
   * @return {boolean}
   * @private
   */
  _shouldAnimate() {
    const style = getComputedStyle(this);
    const name = style.getPropertyValue("animation-name");
    const hidden = style.getPropertyValue("display") === "none";
    return !hidden && name && name !== "none";
  }
  /**
   * @param {string} type
   * @param {Function} callback
   * @private
   */
  _enqueueAnimation(type, callback) {
    const handler = `__${type}Handler`;
    const listener = (event) => {
      if (event && event.target !== this) {
        return;
      }
      callback();
      this.removeEventListener("animationend", listener);
      delete this[handler];
    };
    this[handler] = listener;
    this.addEventListener("animationend", listener);
  }
  /**
   * @param {string} type
   * @protected
   */
  _flushAnimation(type) {
    const handler = `__${type}Handler`;
    if (typeof this[handler] === "function") {
      this[handler]();
    }
  }
  /** @private */
  _animatedOpening() {
    if (this.parentNode === document.body && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
    this._attachOverlay();
    if (!this.modeless) {
      this._enterModalState();
    }
    this.setAttribute("opening", "");
    if (this._shouldAnimate()) {
      this._enqueueAnimation("opening", () => {
        this._finishOpening();
      });
    } else {
      this._finishOpening();
    }
  }
  /** @private */
  _attachOverlay() {
    this._placeholder = document.createComment("vaadin-overlay-placeholder");
    this.parentNode.insertBefore(this._placeholder, this);
    document.body.appendChild(this);
    this.bringToFront();
  }
  /** @private */
  _finishOpening() {
    this.removeAttribute("opening");
  }
  /** @private */
  _finishClosing() {
    this._detachOverlay();
    this.$.overlay.style.removeProperty("pointer-events");
    this.removeAttribute("closing");
    this.dispatchEvent(new CustomEvent("vaadin-overlay-closed"));
  }
  /** @private */
  _animatedClosing() {
    if (this.hasAttribute("opening")) {
      this._flushAnimation("opening");
    }
    if (this._placeholder) {
      this._exitModalState();
      this.setAttribute("closing", "");
      this.dispatchEvent(new CustomEvent("vaadin-overlay-closing"));
      if (this._shouldAnimate()) {
        this._enqueueAnimation("closing", () => {
          this._finishClosing();
        });
      } else {
        this._finishClosing();
      }
    }
  }
  /** @private */
  _detachOverlay() {
    this._placeholder.parentNode.insertBefore(this, this._placeholder);
    this._placeholder.parentNode.removeChild(this._placeholder);
  }
  /** @private */
  _mouseDownListener(event) {
    this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /** @private */
  _mouseUpListener(event) {
    this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} _event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(_event) {
    return this._last;
  }
  /**
   * Outside click listener used in capture phase to close the overlay before
   * propagating the event to the listener on the element that triggered it.
   * Otherwise, calling `open()` would result in closing and re-opening.
   *
   * @private
   */
  _outsideClickListener(event) {
    if (event.composedPath().includes(this.$.overlay) || this._mouseDownInside || this._mouseUpInside) {
      this._mouseDownInside = false;
      this._mouseUpInside = false;
      return;
    }
    if (!this._shouldCloseOnOutsideClick(event)) {
      return;
    }
    const evt = new CustomEvent("vaadin-overlay-outside-click", {
      bubbles: true,
      cancelable: true,
      detail: { sourceEvent: event }
    });
    this.dispatchEvent(evt);
    if (this.opened && !evt.defaultPrevented) {
      this.close(event);
    }
  }
  /**
   * Listener used to close whe overlay on Escape press, if it is the last one.
   * @private
   */
  _keydownListener(event) {
    if (!this._last) {
      return;
    }
    if (this.modeless && !event.composedPath().includes(this.$.overlay)) {
      return;
    }
    if (event.key === "Escape") {
      const evt = new CustomEvent("vaadin-overlay-escape-press", {
        bubbles: true,
        cancelable: true,
        detail: { sourceEvent: event }
      });
      this.dispatchEvent(evt);
      if (this.opened && !evt.defaultPrevented) {
        this.close(event);
      }
    }
  }
};

export {
  OverlayFocusMixin,
  OverlayMixin,
  overlayStyles
};
/*! Bundled license information:

@vaadin/overlay/src/vaadin-overlay-styles.js:
  (**
   * @license
   * Copyright (c) 2017 - 2024 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/overlay/src/vaadin-overlay-focus-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2024 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/overlay/src/vaadin-overlay-stack-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2024 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/overlay/src/vaadin-overlay-mixin.js:
  (**
   * @license
   * Copyright (c) 2017 - 2024 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-HYO4DUYL.js.map
