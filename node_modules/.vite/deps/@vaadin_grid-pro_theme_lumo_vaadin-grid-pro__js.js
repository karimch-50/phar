import "./chunk-ZOKNJC4F.js";
import {
  Grid
} from "./chunk-RY5KSWBO.js";
import "./chunk-Z6UBOSHQ.js";
import "./chunk-LHRZSTHO.js";
import "./chunk-P5OJUUFQ.js";
import "./chunk-DJLAMTZC.js";
import {
  get,
  set
} from "./chunk-54ADOYDD.js";
import "./chunk-TBCD74S6.js";
import "./chunk-UTKYTDFY.js";
import "./chunk-3TOJB423.js";
import "./chunk-JWDOWCJS.js";
import "./chunk-PJNJQYXC.js";
import "./chunk-TH3SXEA2.js";
import "./chunk-DV2EGEEG.js";
import "./chunk-2JVJNHM2.js";
import "./chunk-NJXIHJ3Q.js";
import "./chunk-XWHFZQ32.js";
import "./chunk-24BF3Z44.js";
import "./chunk-TVB6PYW6.js";
import "./chunk-MWSAWSJ3.js";
import {
  Debouncer
} from "./chunk-SEGZ6IIL.js";
import "./chunk-TOPBZAEH.js";
import "./chunk-EZVFCO5I.js";
import "./chunk-CEKQDUPK.js";
import "./chunk-CRXJMMF2.js";
import "./chunk-EJTF7QKX.js";
import "./chunk-RPOYDVPH.js";
import "./chunk-O6KCEJHO.js";
import "./chunk-HFKL6MLF.js";
import "./chunk-44TTWRW5.js";
import "./chunk-6C6BQOMD.js";
import "./chunk-ZPXTDJKE.js";
import "./chunk-3BRKSSC5.js";
import "./chunk-EFKWAQ3Y.js";
import "./chunk-GRU2OPCY.js";
import "./chunk-JQFZSNBR.js";
import "./chunk-QGCYTHXO.js";
import "./chunk-F7YWWDDG.js";
import "./chunk-R6DBYMLB.js";
import "./chunk-BORGCLO4.js";
import "./chunk-3WOFLRNV.js";
import "./chunk-J2NV7QBD.js";
import "./chunk-J4OM4IIF.js";
import {
  registerStyles
} from "./chunk-BBNA52CT.js";
import "./chunk-25Y4ITXF.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import "./chunk-QO3ZNG6F.js";
import "./chunk-B6NQGUVK.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import {
  animationFrame
} from "./chunk-ER2S4LLB.js";
import "./chunk-4TYUW4EB.js";
import "./chunk-FXP5WKMI.js";
import "./chunk-2IE6RYOR.js";
import "./chunk-XB4RSW42.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-WGAPYIUP.js";

// node_modules/@vaadin/grid-pro/theme/lumo/vaadin-grid-pro-styles.js
registerStyles(
  "vaadin-grid-pro",
  css`
    :host([navigating]) [part~='cell']:active::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    [part~='editable-cell'],
    [part~='editable-cell'] ::slotted(vaadin-grid-cell-content) {
      cursor: var(--lumo-clickable-cursor);
    }

    [part~='editable-cell']:hover,
    [part~='editable-cell']:focus {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    }

    /* Indicate editable cells */

    :host([theme~='highlight-editable-cells']) [part~='editable-cell'] {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    }

    :host([theme~='highlight-editable-cells']) [part~='editable-cell']:hover,
    :host([theme~='highlight-editable-cells']) [part~='editable-cell']:focus {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-10pct), var(--lumo-contrast-10pct));
    }

    /* Indicate read-only cells */

    /* prettier-ignore */
    :host([theme~='highlight-read-only-cells']) [tabindex]:not([part~='editable-cell']):not([part~='header-cell']):not([part~='footer-cell']) {
      background-image: repeating-linear-gradient(
        135deg,
        transparent,
        transparent 6px,
        var(--lumo-contrast-5pct) 6px,
        var(--lumo-contrast-5pct) 14px
      );
    }
  `,
  { moduleId: "lumo-grid-pro" }
);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-inline-editing-mixin.js
var InlineEditingMixin = (superClass) => class InlineEditingMixin extends superClass {
  static get properties() {
    return {
      /**
       * When true, pressing Enter while in cell edit mode
       * will move focus to the editable cell in the next row
       * (Shift + Enter - same, but for previous row).
       * @attr {boolean} enter-next-row
       */
      enterNextRow: {
        type: Boolean,
        notify: true
        // FIXME(yuriy-fix): needed by Flow counterpart
      },
      /**
       * When true, after moving to next or previous editable cell using
       * Tab / Shift+Tab, it will be focused without edit mode.
       *
       * When `enterNextRow` is true, pressing Enter will also
       * preserve edit mode, otherwise, it will have no effect.
       * @attr {boolean} single-cell-edit
       */
      singleCellEdit: {
        type: Boolean,
        notify: true
        // FIXME(yuriy-fix): needed by Flow counterpart
      },
      /**
       * When true, the grid enters cell edit mode on a single click
       * instead of the default double click.
       * @attr {boolean} edit-on-click
       */
      editOnClick: {
        type: Boolean
      },
      /** @private */
      _editingDisabled: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__boundItemPropertyChanged = this._onItemPropertyChanged.bind(this);
    this.__boundEditorFocusOut = this._onEditorFocusOut.bind(this);
    this.__boundEditorFocusIn = this._onEditorFocusIn.bind(this);
    this.__boundCancelCellSwitch = this._setCancelCellSwitch.bind(this);
    this.__boundGlobalFocusIn = this._onGlobalFocusIn.bind(this);
    this._addEditColumnListener("mousedown", (e) => {
      e.stopImmediatePropagation();
      this.toggleAttribute("navigating", true);
    });
    this._addEditColumnListener("focusout", (e) => {
      e.stopImmediatePropagation();
    });
  }
  /** @protected */
  ready() {
    this.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case 27:
          if (this.__edited) {
            this._stopEdit(true);
          }
          break;
        case 9:
          if (this.__edited) {
            this._switchEditCell(e);
          }
          break;
        case 13:
          if (this.__edited) {
            this._switchEditCell(e);
          } else {
            this._enterEditFromEvent(e);
          }
          break;
        case 32:
          if (!this.__edited) {
            this._enterEditFromEvent(e);
          }
          break;
        default:
          if (e.key && e.key.length === 1) {
            this._enterEditFromEvent(e, "text");
          }
          break;
      }
    });
    super.ready();
    this.$.table.addEventListener("click", (e) => {
      const column = this.getEventContext(e).column;
      if (column && this._isEditColumn(column)) {
        if (e.target.matches(":not([type=checkbox])")) {
          e.preventDefault();
        }
        if (this.editOnClick) {
          this._enterEditFromEvent(e);
        }
      }
    });
    if (this._ios) {
      let firstClickTime;
      let waitingSecondClick = false;
      this.addEventListener("click", (e) => {
        if (!waitingSecondClick) {
          firstClickTime = (/* @__PURE__ */ new Date()).getTime();
          waitingSecondClick = true;
          setTimeout(() => {
            waitingSecondClick = false;
          }, 300);
        } else {
          waitingSecondClick = false;
          const time = (/* @__PURE__ */ new Date()).getTime();
          if (time - firstClickTime < 300) {
            this._enterEditFromEvent(e);
          }
        }
      });
    } else {
      this.addEventListener("dblclick", (e) => {
        if (!this.editOnClick) {
          this._enterEditFromEvent(e);
        }
      });
    }
  }
  /**
   * Override an observer from `DisabledMixin` to stop
   * editing when grid element becomes disabled.
   *
   * @param {boolean} disabled
   * @param {boolean} oldDisabled
   * @protected
   * @override
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (disabled && this.__edited) {
      this._stopEdit(true);
    }
  }
  /** @protected */
  _checkImports() {
    super._checkImports();
    ["vaadin-grid-pro-edit-column"].forEach((elementName) => {
      const element = this.querySelector(elementName);
      if (element && !customElements.get(elementName)) {
        console.warn(`Make sure you have imported the required module for <${elementName}> element.`);
      }
    });
  }
  /** @private */
  _applyEdit({ path, value, index, item }) {
    set(path, value, item);
    this.requestContentUpdate();
  }
  /** @private */
  _addEditColumnListener(type, callback) {
    this.addEventListener(type, (e) => {
      const context = this.getEventContext(e);
      const column = context.column;
      const edited = this.__edited;
      if (context.item && this._isEditColumn(column)) {
        const path = e.composedPath();
        const cell = path[path.indexOf(this.$.table) - 3];
        if (!cell || cell.getAttribute("part").indexOf("details-cell") > -1) {
          return;
        }
        if (edited && edited.cell === cell) {
          return;
        }
        callback(e);
      }
    });
  }
  /** @private */
  _onItemPropertyChanged(e) {
    if (!e.defaultPrevented) {
      this._applyEdit(e.detail);
    }
  }
  /** @private */
  _getRowByIndex(index) {
    return Array.from(this.$.items.children).find((el) => el.index === index);
  }
  /** @private */
  _isEditColumn(column) {
    return column && column.localName.toLowerCase() === "vaadin-grid-pro-edit-column";
  }
  /** @private */
  _getEditColumns() {
    const columnTreeLevel = this._columnTree.length - 1;
    return this._columnTree[columnTreeLevel].filter((column) => this._isEditColumn(column) && !column.hidden).sort((a, b) => a._order - b._order);
  }
  /** @private */
  _cancelStopEdit() {
    if (this._debouncerStopEdit) {
      this._debouncerStopEdit.cancel();
      delete this._debouncerStopEdit;
    }
  }
  /** @private */
  _flushStopEdit() {
    if (this._debouncerStopEdit) {
      this._debouncerStopEdit.flush();
      delete this._debouncerStopEdit;
    }
  }
  /** @private */
  _enterEditFromEvent(e, type) {
    const context = this.getEventContext(e);
    const column = context.column;
    const edited = this.__edited;
    if (context.item && this._isEditColumn(column)) {
      const path = e.composedPath();
      const cell = path[path.indexOf(this.$.table) - 3];
      if (!cell || cell.getAttribute("part").indexOf("details-cell") > -1) {
        return;
      }
      if (type && column.editorType !== type) {
        return;
      }
      if (edited && edited.cell === cell && column._getEditorComponent(cell).contains(e.target)) {
        return;
      }
      this._flushStopEdit();
      this._startEdit(cell, column);
    } else if (edited) {
      this._stopEdit();
    }
  }
  /** @private */
  _onEditorFocusOut() {
    this._debouncerStopEdit = Debouncer.debounce(this._debouncerStopEdit, animationFrame, this._stopEdit.bind(this));
  }
  /** @private */
  _onEditorFocusIn() {
    this._cancelStopEdit();
  }
  /** @private */
  _onGlobalFocusIn(e) {
    const edited = this.__edited;
    if (edited) {
      const overlay = Array.from(e.composedPath()).filter(
        (node) => node.nodeType === Node.ELEMENT_NODE && /^vaadin-(?!dialog).*-overlay$/iu.test(node.localName)
      )[0];
      if (overlay) {
        overlay.addEventListener("vaadin-overlay-outside-click", this.__boundEditorFocusOut);
        this._cancelStopEdit();
      }
    }
  }
  /** @private */
  _startEdit(cell, column) {
    if (this.disabled || this._editingDisabled) {
      return;
    }
    this._cancelStopEdit();
    this._scrollHorizontallyToCell(cell);
    const model = this.__getRowModel(cell.parentElement);
    this.__edited = { cell, column, model };
    column._startCellEdit(cell, model);
    this.dispatchEvent(
      new CustomEvent("cell-edit-started", {
        detail: {
          index: model.index,
          item: model.item,
          path: column.path
        },
        composed: true
      })
    );
    this.addEventListener("item-property-changed", this.__boundItemPropertyChanged);
  }
  /**
   * @param {boolean=} shouldCancel
   * @param {boolean=} shouldRestoreFocus
   * @protected
   */
  _stopEdit(shouldCancel, shouldRestoreFocus) {
    if (!this.__edited) {
      return;
    }
    const { cell, column, model } = this.__edited;
    if (!shouldCancel) {
      const editor = column._getEditorComponent(cell);
      if (editor) {
        const value = column._getEditorValue(editor);
        if (value !== get(column.path, model.item)) {
          editor.blur();
          this.dispatchEvent(
            new CustomEvent("item-property-changed", {
              detail: {
                index: model.index,
                item: model.item,
                path: column.path,
                value
              },
              bubbles: true,
              cancelable: true,
              composed: true
            })
          );
        }
      }
    }
    column._stopCellEdit(cell, model);
    this.__edited = null;
    this.removeEventListener("item-property-changed", this.__boundItemPropertyChanged);
    if (shouldRestoreFocus) {
      cell.focus();
    }
  }
  /** @private */
  _setCancelCellSwitch() {
    this.__cancelCellSwitch = true;
    window.requestAnimationFrame(() => {
      this.__cancelCellSwitch = false;
    });
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  _switchEditCell(e) {
    if (this.__cancelCellSwitch || e.defaultPrevented && e.keyCode === 9) {
      return;
    }
    this._cancelStopEdit();
    const cols = this._getEditColumns();
    const { cell, column, model } = this.__edited;
    const colIndex = cols.indexOf(column);
    const { index } = model;
    let nextCol = null;
    let nextIdx = index;
    if (e.keyCode === 13) {
      nextCol = column;
      if (this.enterNextRow) {
        nextIdx = e.shiftKey ? index - 1 : index + 1;
      }
    }
    if (e.keyCode === 9) {
      if (e.shiftKey) {
        if (cols[colIndex - 1]) {
          nextCol = cols[colIndex - 1];
        } else if (index > 0) {
          nextIdx = index - 1;
          nextCol = cols[cols.length - 1];
        }
      } else if (cols[colIndex + 1]) {
        nextCol = cols[colIndex + 1];
      } else {
        nextIdx = index + 1;
        nextCol = cols[0];
      }
    }
    const nextRow = nextIdx === index ? cell.parentNode : this._getRowByIndex(nextIdx) || null;
    this._stopEdit();
    if (nextRow && nextCol) {
      const nextCell = Array.from(nextRow.children).find((cell2) => cell2._column === nextCol);
      e.preventDefault();
      e.stopImmediatePropagation();
      if (!this.singleCellEdit && nextCell !== cell) {
        this._startEdit(nextCell, nextCol);
      } else {
        this._ensureScrolledToIndex(nextIdx);
        nextCell.focus();
      }
    }
  }
  /**
   * @param {!HTMLElement} row
   * @param {GridItem} item
   * @protected
   */
  _updateItem(row, item) {
    if (this.__edited) {
      const { cell, model } = this.__edited;
      if (cell.parentNode === row && model.item !== item) {
        this._stopEdit();
      }
    }
    super._updateItem(row, item);
  }
  /**
   * Fired before exiting the cell edit mode, if the value has been changed.
   * If the default is prevented, value change would not be applied.
   *
   * @event item-property-changed
   * @param {Object} detail
   * @param {Object} detail.index the row index of the edited cell
   * @param {Object} detail.item the grid item rendered to the row of the edited cell
   * @param {Object} detail.path the column path of the edited cell
   * @param {Object} detail.value the new value of the edited cell
   */
  /**
   * Fired when the user starts editing a grid cell.
   *
   * @event cell-edit-started
   * @param {Object} detail
   * @param {Object} detail.index the row index of the edited cell
   * @param {Object} detail.item the grid item rendered to the row of the edited cell
   * @param {Object} detail.path the column path of the edited cell
   */
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro.js
var GridPro = class extends InlineEditingMixin(Grid) {
  static get is() {
    return "vaadin-grid-pro";
  }
  static get cvdlName() {
    return "vaadin-grid-pro";
  }
};
defineCustomElement(GridPro);
/*! Bundled license information:

@vaadin/grid-pro/src/vaadin-grid-pro-inline-editing-mixin.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)
*/
//# sourceMappingURL=@vaadin_grid-pro_theme_lumo_vaadin-grid-pro__js.js.map
