{
  "version": 3,
  "sources": ["../../@vaadin/component-base/src/slot-observer.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2023 - 2024 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * A helper for observing slot changes.\n */\nexport class SlotObserver {\n  constructor(slot, callback) {\n    /** @type HTMLSlotElement */\n    this.slot = slot;\n\n    /** @type Function */\n    this.callback = callback;\n\n    /** @type {Node[]} */\n    this._storedNodes = [];\n\n    this._connected = false;\n    this._scheduled = false;\n\n    this._boundSchedule = () => {\n      this._schedule();\n    };\n\n    this.connect();\n    this._schedule();\n  }\n\n  /**\n   * Activates an observer. This method is automatically called when\n   * a `SlotObserver` is created. It should only be called to  re-activate\n   * an observer that has been deactivated via the `disconnect` method.\n   */\n  connect() {\n    this.slot.addEventListener('slotchange', this._boundSchedule);\n    this._connected = true;\n  }\n\n  /**\n   * Deactivates the observer. After calling this method the observer callback\n   * will not be called when changes to slotted nodes occur. The `connect` method\n   * may be subsequently called to reactivate the observer.\n   */\n  disconnect() {\n    this.slot.removeEventListener('slotchange', this._boundSchedule);\n    this._connected = false;\n  }\n\n  /** @private */\n  _schedule() {\n    if (!this._scheduled) {\n      this._scheduled = true;\n\n      queueMicrotask(() => {\n        this.flush();\n      });\n    }\n  }\n\n  /**\n   * Run the observer callback synchronously.\n   */\n  flush() {\n    if (!this._connected) {\n      return;\n    }\n\n    this._scheduled = false;\n\n    this._processNodes();\n  }\n\n  /** @private */\n  _processNodes() {\n    const currentNodes = this.slot.assignedNodes({ flatten: true });\n\n    let addedNodes = [];\n    const removedNodes = [];\n    const movedNodes = [];\n\n    if (currentNodes.length) {\n      addedNodes = currentNodes.filter((node) => !this._storedNodes.includes(node));\n    }\n\n    if (this._storedNodes.length) {\n      this._storedNodes.forEach((node, index) => {\n        const idx = currentNodes.indexOf(node);\n        if (idx === -1) {\n          removedNodes.push(node);\n        } else if (idx !== index) {\n          movedNodes.push(node);\n        }\n      });\n    }\n\n    if (addedNodes.length || removedNodes.length || movedNodes.length) {\n      this.callback({ addedNodes, movedNodes, removedNodes });\n    }\n\n    this._storedNodes = currentNodes;\n  }\n}\n"],
  "mappings": ";AASO,IAAM,eAAN,MAAmB;AAAA,EACxB,YAAY,MAAM,UAAU;AAE1B,SAAK,OAAO;AAGZ,SAAK,WAAW;AAGhB,SAAK,eAAe,CAAC;AAErB,SAAK,aAAa;AAClB,SAAK,aAAa;AAElB,SAAK,iBAAiB,MAAM;AAC1B,WAAK,UAAU;AAAA,IACjB;AAEA,SAAK,QAAQ;AACb,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,SAAK,KAAK,iBAAiB,cAAc,KAAK,cAAc;AAC5D,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa;AACX,SAAK,KAAK,oBAAoB,cAAc,KAAK,cAAc;AAC/D,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA,EAGA,YAAY;AACV,QAAI,CAAC,KAAK,YAAY;AACpB,WAAK,aAAa;AAElB,qBAAe,MAAM;AACnB,aAAK,MAAM;AAAA,MACb,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,QAAI,CAAC,KAAK,YAAY;AACpB;AAAA,IACF;AAEA,SAAK,aAAa;AAElB,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA,EAGA,gBAAgB;AACd,UAAM,eAAe,KAAK,KAAK,cAAc,EAAE,SAAS,KAAK,CAAC;AAE9D,QAAI,aAAa,CAAC;AAClB,UAAM,eAAe,CAAC;AACtB,UAAM,aAAa,CAAC;AAEpB,QAAI,aAAa,QAAQ;AACvB,mBAAa,aAAa,OAAO,CAAC,SAAS,CAAC,KAAK,aAAa,SAAS,IAAI,CAAC;AAAA,IAC9E;AAEA,QAAI,KAAK,aAAa,QAAQ;AAC5B,WAAK,aAAa,QAAQ,CAAC,MAAM,UAAU;AACzC,cAAM,MAAM,aAAa,QAAQ,IAAI;AACrC,YAAI,QAAQ,IAAI;AACd,uBAAa,KAAK,IAAI;AAAA,QACxB,WAAW,QAAQ,OAAO;AACxB,qBAAW,KAAK,IAAI;AAAA,QACtB;AAAA,MACF,CAAC;AAAA,IACH;AAEA,QAAI,WAAW,UAAU,aAAa,UAAU,WAAW,QAAQ;AACjE,WAAK,SAAS,EAAE,YAAY,YAAY,aAAa,CAAC;AAAA,IACxD;AAEA,SAAK,eAAe;AAAA,EACtB;AACF;",
  "names": []
}
