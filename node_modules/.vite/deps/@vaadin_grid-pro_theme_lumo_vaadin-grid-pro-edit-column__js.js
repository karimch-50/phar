import {
  GridColumn
} from "./chunk-P5OJUUFQ.js";
import "./chunk-DJLAMTZC.js";
import {
  get,
  set
} from "./chunk-54ADOYDD.js";
import {
  Checkbox
} from "./chunk-ZDVPFWUG.js";
import "./chunk-V2FG5DFM.js";
import "./chunk-UTKYTDFY.js";
import {
  Select
} from "./chunk-FBPFG5ON.js";
import "./chunk-TTWJGM74.js";
import {
  TextField
} from "./chunk-2U5PYWD7.js";
import "./chunk-2QRPMWBW.js";
import "./chunk-QXKYTJLT.js";
import "./chunk-H67WQYV4.js";
import "./chunk-WCEMJP5Y.js";
import "./chunk-MI4WOW4I.js";
import "./chunk-TP3SG6KP.js";
import "./chunk-3TOJB423.js";
import "./chunk-SNCYUXU4.js";
import "./chunk-F6RGR3SN.js";
import "./chunk-JWDOWCJS.js";
import "./chunk-ELPZA6KY.js";
import "./chunk-UY4FDBB3.js";
import "./chunk-A2UCFRVY.js";
import "./chunk-BGWLAHRF.js";
import "./chunk-UFBVVQ65.js";
import "./chunk-HYO4DUYL.js";
import "./chunk-PJNJQYXC.js";
import "./chunk-ZE63AH6T.js";
import "./chunk-TH3SXEA2.js";
import "./chunk-DV2EGEEG.js";
import "./chunk-FSP2XZVR.js";
import "./chunk-ME67HVVO.js";
import "./chunk-NJXIHJ3Q.js";
import "./chunk-XWHFZQ32.js";
import "./chunk-V7EIQ2IZ.js";
import "./chunk-PMRFEKRS.js";
import "./chunk-R5IZNLSA.js";
import "./chunk-M6LOI3BZ.js";
import "./chunk-24BF3Z44.js";
import "./chunk-IDC7WHOS.js";
import "./chunk-TVB6PYW6.js";
import "./chunk-GV4NWW2U.js";
import "./chunk-MWSAWSJ3.js";
import "./chunk-SEGZ6IIL.js";
import "./chunk-TOPBZAEH.js";
import "./chunk-EZVFCO5I.js";
import "./chunk-CEKQDUPK.js";
import "./chunk-CRXJMMF2.js";
import "./chunk-EJTF7QKX.js";
import "./chunk-RPOYDVPH.js";
import "./chunk-O6KCEJHO.js";
import "./chunk-HFKL6MLF.js";
import "./chunk-44TTWRW5.js";
import "./chunk-6C6BQOMD.js";
import "./chunk-ZPXTDJKE.js";
import "./chunk-3BRKSSC5.js";
import "./chunk-EFKWAQ3Y.js";
import {
  addValueToAttribute
} from "./chunk-GRU2OPCY.js";
import "./chunk-JQFZSNBR.js";
import "./chunk-QGCYTHXO.js";
import "./chunk-F7YWWDDG.js";
import "./chunk-R6DBYMLB.js";
import "./chunk-BORGCLO4.js";
import "./chunk-3WOFLRNV.js";
import "./chunk-J2NV7QBD.js";
import "./chunk-J4OM4IIF.js";
import {
  registerStyles
} from "./chunk-BBNA52CT.js";
import "./chunk-25Y4ITXF.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import "./chunk-QO3ZNG6F.js";
import "./chunk-B6NQGUVK.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import "./chunk-ER2S4LLB.js";
import "./chunk-4TYUW4EB.js";
import "./chunk-FXP5WKMI.js";
import "./chunk-2IE6RYOR.js";
import "./chunk-XB4RSW42.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-WGAPYIUP.js";

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-checkbox.js
var GridProEditCheckbox = class extends Checkbox {
  static get is() {
    return "vaadin-grid-pro-edit-checkbox";
  }
};
defineCustomElement(GridProEditCheckbox);

// node_modules/@vaadin/grid-pro/theme/lumo/vaadin-grid-pro-editor-styles.js
var gridProEditor = css`
  :host([theme~='grid-pro-editor']) {
    position: absolute;
    inset: 0;
    padding: 0;
    will-change: transform;
    font-size: inherit;
    --lumo-text-field-size: 27px;
    /* outline similar to what grid uses */
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  :host([theme~='grid-pro-editor']) [part='input-field'] {
    padding: 0;
    border-radius: 0;
    flex-grow: 1;
    font-weight: 400;
    --vaadin-input-field-border-color: transparent;
  }

  /* reset outline inherited from text-field */
  :host([theme~='grid-pro-editor'][focus-ring]) [part='input-field'] {
    box-shadow: none;
  }

  :host([theme~='grid-pro-editor']) ::slotted(input) {
    padding: 0 var(--lumo-space-m);
    font-size: inherit;
  }
`;
registerStyles("", gridProEditor, { moduleId: "lumo-grid-pro-editor" });

// node_modules/@vaadin/grid-pro/theme/lumo/vaadin-grid-pro-edit-select-styles.js
var gridProEditSelect = css`
  :host([theme~='grid-pro-editor']) [part='toggle-button'] {
    margin-right: var(--lumo-space-xs);
  }

  :host([theme~='grid-pro-editor']) [part='input-field'] ::slotted([slot='value']) {
    box-sizing: border-box;
    padding: 0 var(--lumo-space-m);
    font-size: var(--lumo-font-size-m);
    /* prevent selection on editor focus */
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }
`;
registerStyles("vaadin-grid-pro-edit-select", [gridProEditor, gridProEditSelect], {
  moduleId: "lumo-grid-pro-edit-select"
});

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-select-mixin.js
var GridProEditSelectMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      options: {
        type: Array,
        value: () => []
      },
      _grid: {
        type: Object
      },
      _initialized: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["_optionsChanged(options)"];
  }
  ready() {
    super.ready();
    this.setAttribute("theme", "grid-pro-editor");
  }
  _onKeyDown(e) {
    super._onKeyDown(e);
    if (this.options.length === 0 && /^(ArrowDown|Down|ArrowUp|Up|Enter|SpaceBar| )$/u.test(e.key)) {
      console.warn('Missing "editorOptions" for <vaadin-grid-pro-edit-column> select editor!');
    }
    if (e.defaultPrevented) {
      e.stopPropagation();
    }
  }
  /**
   * Override list-box event listener inherited from `Select`:
   * - Enter: set flag for moving to next row on value change,
   * - Tab: switch to next cell when "singleCellEdit" is false.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDownInside(event) {
    if (event.keyCode === 13) {
      this._enterKeydown = event;
    }
    if (event.keyCode === 9) {
      if (!this._grid.singleCellEdit) {
        this._grid._switchEditCell(event);
      }
    }
    super._onKeyDownInside(event);
  }
  _valueChanged(value, oldValue) {
    super._valueChanged(value, oldValue);
    if (value === "" && oldValue === void 0) {
      return;
    }
    if (this._initialized) {
      const enter = this._enterKeydown;
      if (enter && this._grid.enterNextRow) {
        this._grid._switchEditCell(enter);
      } else if (this._grid.singleCellEdit) {
        this._grid._stopEdit(false, true);
      } else {
        this.focus();
      }
    }
  }
  _optionsChanged(options) {
    if (options && options.length) {
      this.items = options.map((option) => ({
        label: option,
        value: option
      }));
      this._overlayElement || (this._overlayElement = this.shadowRoot.querySelector("vaadin-select-overlay"));
      this._overlayElement.addEventListener("vaadin-overlay-outside-click", () => {
        this._grid._stopEdit();
      });
      setTimeout(() => {
        this.opened = true;
        this._initialized = true;
      });
    }
  }
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-select.js
var GridProEditSelect = class extends GridProEditSelectMixin(Select) {
  static get is() {
    return "vaadin-grid-pro-edit-select";
  }
};
defineCustomElement(GridProEditSelect);

// node_modules/@vaadin/grid-pro/theme/lumo/vaadin-grid-pro-edit-text-field-styles.js
registerStyles("vaadin-grid-pro-edit-text-field", gridProEditor, {
  moduleId: "lumo-grid-pro-edit-text-field"
});

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-text-field.js
var GridProEditText = class extends TextField {
  static get is() {
    return "vaadin-grid-pro-edit-text-field";
  }
  ready() {
    super.ready();
    this.setAttribute("theme", "grid-pro-editor");
  }
};
defineCustomElement(GridProEditText);

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-column-mixin.js
var GridProEditColumnMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /**
       * Custom function for rendering the cell content in edit mode.
       * Receives three arguments:
       *
       * - `root` The cell content DOM element. Append your editor component to it.
       * - `column` The `<vaadin-grid-pro-edit-column>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *   - `model.detailsOpened` Details opened state.
       * @type {!GridBodyRenderer | null | undefined}
       */
      editModeRenderer: {
        type: Function,
        sync: true
      },
      /**
       * The list of options which should be passed to cell editor component.
       * Used with the `select` editor type, to provide a list of items.
       * @type {!Array<string>}
       */
      editorOptions: {
        type: Array,
        value: () => []
      },
      /**
       * Type of the cell editor component to be rendered. Allowed values:
       * - `text` (default) - renders a text field
       * - `checkbox` - renders a checkbox
       * - `select` - renders a select with a list of items passed as `editorOptions`
       *
       * Editor type is set to `custom` when `editModeRenderer` is set.
       * @attr {text|checkbox|select|custom} editor-type
       * @type {!GridProEditorType}
       */
      editorType: {
        type: String,
        notify: true,
        // FIXME(web-padawan): needed by Flow counterpart
        value: "text"
      },
      /**
       * Path of the property used for the value of the editor component.
       * @attr {string} editor-value-path
       * @type {string}
       */
      editorValuePath: {
        type: String,
        value: "value"
      },
      /**
       * JS Path of the property in the item used for the editable content.
       */
      path: {
        type: String,
        observer: "_pathChanged",
        sync: true
      },
      /** @private */
      _oldRenderer: Function
    };
  }
  static get observers() {
    return ["_editModeRendererChanged(editModeRenderer, __initialized)", "_cellsChanged(_cells)"];
  }
  constructor() {
    super();
    this._focusButtonMode = navigator.platform.includes("Mac");
    this.__editModeRenderer = function(root, column) {
      const cell = root.assignedSlot.parentNode;
      const tagName = column._getEditorTagName(cell);
      if (!root.firstElementChild || root.firstElementChild.localName.toLowerCase() !== tagName) {
        root.innerHTML = `
          <${tagName}></${tagName}>
        `;
      }
    };
  }
  /** @private */
  _pathChanged(path) {
    if (!path || path.length === 0) {
      throw new Error("You should specify the path for the edit column");
    }
  }
  /** @private */
  _cellsChanged() {
    this._cells.forEach((cell) => {
      const target = cell._focusButton || cell;
      addValueToAttribute(target, "part", "editable-cell");
    });
  }
  /** @private */
  _editModeRendererChanged(renderer) {
    if (renderer) {
      this.editorType = "custom";
    } else if (this._oldRenderer) {
      this.editorType = "text";
    }
    this._oldRenderer = renderer;
  }
  /**
   * @param {!HTMLElement} cell
   * @return {string}
   * @protected
   */
  _getEditorTagName(cell) {
    return this.editorType === "custom" ? this._getEditorComponent(cell).localName : this._getTagNameByType();
  }
  /**
   * @param {!HTMLElement} cell
   * @return {HTMLElement | null}
   * @protected
   */
  _getEditorComponent(cell) {
    return this.editorType === "custom" ? cell._content.firstElementChild : cell._content.querySelector(this._getEditorTagName(cell));
  }
  /** @private */
  _getTagNameByType() {
    let type;
    switch (this.editorType) {
      case "checkbox":
        type = "checkbox";
        break;
      case "select":
        type = "select";
        break;
      case "text":
      default:
        type = "text-field";
        break;
    }
    return this.constructor.is.replace("column", type);
  }
  /** @private */
  _focusEditor(editor) {
    editor.focus();
    if (this.editorType === "checkbox") {
      editor.setAttribute("focus-ring", "");
    } else if (editor instanceof HTMLInputElement) {
      editor.select();
    } else if (editor.focusElement && editor.focusElement instanceof HTMLInputElement) {
      editor.focusElement.select();
    }
  }
  /**
   * @param {!HTMLElement} editor
   * @return {unknown}
   * @protected
   */
  _getEditorValue(editor) {
    const path = this.editorType === "checkbox" ? "checked" : this.editorValuePath;
    return get(path, editor);
  }
  /** @private */
  _renderEditor(cell, model) {
    cell.__savedRenderer = this._renderer || cell._renderer;
    cell._renderer = this.editModeRenderer || this.__editModeRenderer;
    if (cell._focusButton) {
      cell._focusButton.removeAttribute("role");
    }
    this._clearCellContent(cell);
    this._runRenderer(cell._renderer, cell, model);
  }
  /** @private */
  _removeEditor(cell, _model) {
    if (!cell.__savedRenderer) {
      return;
    }
    cell._renderer = cell.__savedRenderer;
    cell.__savedRenderer = void 0;
    this._clearCellContent(cell);
    if (cell._focusButton) {
      cell._focusButton.setAttribute("role", "button");
    }
    this.__renderCellsContent(cell._renderer, [cell]);
  }
  /** @private */
  _setEditorOptions(editor) {
    if (this.editorOptions && this.editorOptions.length) {
      editor.options = this.editorOptions;
    }
  }
  /** @private */
  _setEditorValue(editor, value) {
    const path = this.editorType === "checkbox" ? "checked" : this.editorValuePath;
    value = this.editorType === "checkbox" && typeof value === "string" ? value === "true" : value;
    set(path, value, editor);
    if (editor.notifyPath) {
      editor.notifyPath(path, value);
    }
  }
  /**
   * @param {!HTMLElement} cell
   * @param {!GridItemModel} model
   * @protected
   */
  _startCellEdit(cell, model) {
    this._renderEditor(cell, model);
    const editor = this._getEditorComponent(cell);
    editor.addEventListener("focusout", this._grid.__boundEditorFocusOut);
    editor.addEventListener("focusin", this._grid.__boundEditorFocusIn);
    editor.addEventListener("internal-tab", this._grid.__boundCancelCellSwitch);
    document.body.addEventListener("focusin", this._grid.__boundGlobalFocusIn);
    this._setEditorOptions(editor);
    this._setEditorValue(editor, get(this.path, model.item));
    editor._grid = this._grid;
    this._focusEditor(editor);
    requestAnimationFrame(() => this._focusEditor(editor));
  }
  /**
   * @param {!HTMLElement} cell
   * @param {!GridItemModel} model
   * @protected
   */
  _stopCellEdit(cell, model) {
    document.body.removeEventListener("focusin", this._grid.__boundGlobalFocusIn);
    this._removeEditor(cell, model);
  }
};

// node_modules/@vaadin/grid-pro/src/vaadin-grid-pro-edit-column.js
var GridProEditColumn = class extends GridProEditColumnMixin(GridColumn) {
  static get is() {
    return "vaadin-grid-pro-edit-column";
  }
};
defineCustomElement(GridProEditColumn);
/*! Bundled license information:

@vaadin/grid-pro/src/vaadin-grid-pro-edit-checkbox.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-select-mixin.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-select.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-text-field.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-column-mixin.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid-pro/src/vaadin-grid-pro-edit-column.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)
*/
//# sourceMappingURL=@vaadin_grid-pro_theme_lumo_vaadin-grid-pro-edit-column__js.js.map
