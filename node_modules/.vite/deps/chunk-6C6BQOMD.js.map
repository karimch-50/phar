{
  "version": 3,
  "sources": ["../../@vaadin/component-base/src/slot-controller.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2021 - 2024 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { isEmptyTextNode } from './dom-utils.js';\nimport { SlotObserver } from './slot-observer.js';\nimport { generateUniqueId } from './unique-id-utils.js';\n\n/**\n * A controller for providing content to slot element and observing changes.\n */\nexport class SlotController extends EventTarget {\n  /**\n   * Ensure that every instance has unique ID.\n   *\n   * @param {HTMLElement} host\n   * @param {string} slotName\n   * @return {string}\n   * @protected\n   */\n  static generateId(host, slotName) {\n    const prefix = slotName || 'default';\n    return `${prefix}-${host.localName}-${generateUniqueId()}`;\n  }\n\n  constructor(host, slotName, tagName, config = {}) {\n    super();\n\n    const { initializer, multiple, observe, useUniqueId } = config;\n\n    this.host = host;\n    this.slotName = slotName;\n    this.tagName = tagName;\n    this.observe = typeof observe === 'boolean' ? observe : true;\n    this.multiple = typeof multiple === 'boolean' ? multiple : false;\n    this.slotInitializer = initializer;\n\n    if (multiple) {\n      this.nodes = [];\n    }\n\n    // Only generate the default ID if requested by the controller.\n    if (useUniqueId) {\n      this.defaultId = this.constructor.generateId(host, slotName);\n    }\n  }\n\n  hostConnected() {\n    if (!this.initialized) {\n      if (this.multiple) {\n        this.initMultiple();\n      } else {\n        this.initSingle();\n      }\n\n      if (this.observe) {\n        this.observeSlot();\n      }\n\n      this.initialized = true;\n    }\n  }\n\n  /** @protected */\n  initSingle() {\n    let node = this.getSlotChild();\n\n    if (!node) {\n      node = this.attachDefaultNode();\n      this.initNode(node);\n    } else {\n      this.node = node;\n      this.initAddedNode(node);\n    }\n  }\n\n  /** @protected */\n  initMultiple() {\n    const children = this.getSlotChildren();\n\n    if (children.length === 0) {\n      const defaultNode = this.attachDefaultNode();\n      if (defaultNode) {\n        this.nodes = [defaultNode];\n        this.initNode(defaultNode);\n      }\n    } else {\n      this.nodes = children;\n      children.forEach((node) => {\n        this.initAddedNode(node);\n      });\n    }\n  }\n\n  /**\n   * Create and attach default node using the provided tag name, if any.\n   * @return {Node | undefined}\n   * @protected\n   */\n  attachDefaultNode() {\n    const { host, slotName, tagName } = this;\n\n    // Check if the node was created previously and if so, reuse it.\n    let node = this.defaultNode;\n\n    // Tag name is optional, sometimes we don't init default content.\n    if (!node && tagName) {\n      node = document.createElement(tagName);\n      if (node instanceof Element) {\n        if (slotName !== '') {\n          node.setAttribute('slot', slotName);\n        }\n        this.defaultNode = node;\n      }\n    }\n\n    if (node) {\n      this.node = node;\n      host.appendChild(node);\n    }\n\n    return node;\n  }\n\n  /**\n   * Return the list of nodes matching the slot managed by the controller.\n   * @return {Node}\n   */\n  getSlotChildren() {\n    const { slotName } = this;\n    return Array.from(this.host.childNodes).filter((node) => {\n      // Either an element (any slot) or a text node (only un-named slot).\n      return (\n        (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) ||\n        (node.nodeType === Node.TEXT_NODE && node.textContent.trim() && slotName === '')\n      );\n    });\n  }\n\n  /**\n   * Return a reference to the node managed by the controller.\n   * @return {Node}\n   */\n  getSlotChild() {\n    return this.getSlotChildren()[0];\n  }\n\n  /**\n   * Run `slotInitializer` for the node managed by the controller.\n   *\n   * @param {Node} node\n   * @protected\n   */\n  initNode(node) {\n    const { slotInitializer } = this;\n    // Don't try to bind `this` to initializer (normally it's arrow function).\n    // Instead, pass the host as a first argument to access component's state.\n    if (slotInitializer) {\n      slotInitializer(node, this.host);\n    }\n  }\n\n  /**\n   * Override to initialize the newly added custom node.\n   *\n   * @param {Node} _node\n   * @protected\n   */\n  initCustomNode(_node) {}\n\n  /**\n   * Override to teardown slotted node when it's removed.\n   *\n   * @param {Node} _node\n   * @protected\n   */\n  teardownNode(_node) {}\n\n  /**\n   * Run both `initCustomNode` and `initNode` for a custom slotted node.\n   *\n   * @param {Node} node\n   * @protected\n   */\n  initAddedNode(node) {\n    if (node !== this.defaultNode) {\n      this.initCustomNode(node);\n      this.initNode(node);\n    }\n  }\n\n  /**\n   * Setup the observer to manage slot content changes.\n   * @protected\n   */\n  observeSlot() {\n    const { slotName } = this;\n    const selector = slotName === '' ? 'slot:not([name])' : `slot[name=${slotName}]`;\n    const slot = this.host.shadowRoot.querySelector(selector);\n\n    this.__slotObserver = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {\n      const current = this.multiple ? this.nodes : [this.node];\n\n      // Calling `slot.assignedNodes()` includes whitespace text nodes in case of default slot:\n      // unlike comment nodes, they are not filtered out. So we need to manually ignore them.\n      const newNodes = addedNodes.filter((node) => !isEmptyTextNode(node) && !current.includes(node));\n\n      if (removedNodes.length) {\n        this.nodes = current.filter((node) => !removedNodes.includes(node));\n\n        removedNodes.forEach((node) => {\n          this.teardownNode(node);\n        });\n      }\n\n      if (newNodes && newNodes.length > 0) {\n        if (this.multiple) {\n          // Remove default node if exists\n          if (this.defaultNode) {\n            this.defaultNode.remove();\n          }\n          this.nodes = [...current, ...newNodes].filter((node) => node !== this.defaultNode);\n          newNodes.forEach((node) => {\n            this.initAddedNode(node);\n          });\n        } else {\n          // Remove previous node if exists\n          if (this.node) {\n            this.node.remove();\n          }\n          this.node = newNodes[0];\n          this.initAddedNode(this.node);\n        }\n      }\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
