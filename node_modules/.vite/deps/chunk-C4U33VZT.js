import {
  Point_default,
  deflateCoordinates,
  deflateCoordinatesArray
} from "./chunk-AWJF5NTW.js";
import {
  douglasPeucker,
  inflateCoordinates,
  inflateCoordinatesArray,
  quantizeArray
} from "./chunk-TZQ2SXN3.js";
import {
  GeometryLayout_default,
  SimpleGeometry_default
} from "./chunk-IXYAFR55.js";
import {
  ViewHint_default
} from "./chunk-OV3VFSJD.js";
import {
  DEFAULT_TILE_SIZE
} from "./chunk-JB74NW23.js";
import {
  METERS_PER_UNIT,
  Units_default,
  add,
  createProjection,
  disableCoordinateWarning,
  equals,
  fromUserCoordinate,
  fromUserExtent,
  getUserProjection,
  rotate,
  toUserCoordinate,
  toUserExtent
} from "./chunk-HGML5IPI.js";
import {
  closestSquaredDistanceXY,
  containsExtent,
  createEmpty,
  extendFlatCoordinates,
  forEachCorner,
  getCenter,
  getForViewAndSize,
  getHeight,
  getWidth,
  intersects,
  intersectsSegment,
  isEmpty
} from "./chunk-C7XNUD4N.js";
import {
  GeometryType_default,
  clamp,
  lerp,
  modulo,
  squaredDistance,
  toRadians
} from "./chunk-JFL7O5KA.js";
import {
  easeOut,
  inAndOut
} from "./chunk-FV2F4KM5.js";
import {
  assert
} from "./chunk-FE3DXTD6.js";
import {
  Object_default,
  VOID,
  extend,
  linearFindNearest,
  numberSafeCompareFunction
} from "./chunk-OAOBVDCL.js";
import {
  assign
} from "./chunk-K4RYKKJS.js";

// node_modules/ol/ViewProperty.js
var ViewProperty_default = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [opt_centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, opt_isMoving, opt_centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      var viewWidth = onlyCenter ? 0 : size[0] * resolution;
      var viewHeight = onlyCenter ? 0 : size[1] * resolution;
      var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
      var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
      var minX = extent[0] + viewWidth / 2 + shiftX;
      var maxX = extent[2] - viewWidth / 2 + shiftX;
      var minY = extent[1] + viewHeight / 2 + shiftY;
      var maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      var x = clamp(center[0], minX, maxX);
      var y = clamp(center[1], minY, maxY);
      if (opt_isMoving && smooth && resolution) {
        var ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    }
  );
}
function none(center) {
  return center;
}

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  var xResolution = getWidth(maxExtent) / viewportSize[0];
  var yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  var result = Math.min(resolution, maxResolution);
  var ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, opt_isMoving) {
      if (resolution !== void 0) {
        var maxResolution = resolutions[0];
        var minResolution = resolutions[resolutions.length - 1];
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
        if (opt_isMoving) {
          var smooth = opt_smooth !== void 0 ? opt_smooth : true;
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }
        var capped = Math.min(cappedMaxRes, resolution);
        var z = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      } else {
        return void 0;
      }
    }
  );
}
function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, opt_isMoving) {
      if (resolution !== void 0) {
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
        var minResolution = opt_minResolution !== void 0 ? opt_minResolution : 0;
        if (opt_isMoving) {
          var smooth = opt_smooth !== void 0 ? opt_smooth : true;
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }
        var tolerance = 1e-9;
        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
        var offset2 = -direction * (0.5 - tolerance) + 0.5;
        var capped = Math.min(cappedMaxRes, resolution);
        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset2);
        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        var newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      } else {
        return void 0;
      }
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, opt_isMoving) {
      if (resolution !== void 0) {
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
        var smooth = opt_smooth !== void 0 ? opt_smooth : true;
        if (!smooth || !opt_isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      } else {
        return void 0;
      }
    }
  );
}

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  } else {
    return void 0;
  }
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  } else {
    return void 0;
  }
}
function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, opt_isMoving) {
      if (opt_isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      } else {
        return void 0;
      }
    }
  );
}
function createSnapToZero(opt_tolerance) {
  var tolerance = opt_tolerance || toRadians(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, opt_isMoving) {
      if (opt_isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        if (Math.abs(rotation) <= tolerance) {
          return 0;
        } else {
          return rotation;
        }
      } else {
        return void 0;
      }
    }
  );
}

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset3;
  if (dx === 0 && dy === 0) {
    offset3 = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset3 = offset2;
    } else if (t > 0) {
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }
      closestPoint.length = stride;
      return;
    } else {
      offset3 = offset1;
    }
  }
  for (var i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset3 + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset2, end, stride, max) {
  var x1 = flatCoordinates[offset2];
  var y1 = flatCoordinates[offset2 + 1];
  for (offset2 += stride; offset2 < end; offset2 += stride) {
    var x2 = flatCoordinates[offset2];
    var y2 = flatCoordinates[offset2 + 1];
    var squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset2, end, stride, max);
    offset2 = end;
  }
  return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset2, endss, stride, max) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max);
    offset2 = ends[ends.length - 1];
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset2 == end) {
    return minSquaredDistance;
  }
  var i, squaredDistance2;
  if (maxDelta === 0) {
    squaredDistance2 = squaredDistance(x, y, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);
    if (squaredDistance2 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset2 + i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    } else {
      return minSquaredDistance;
    }
  }
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset2 + stride;
  while (index < end) {
    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max((Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }
  if (isRing) {
    assignClosest(flatCoordinates, end - stride, offset2, stride, x, y, tmpPoint);
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset2 = end;
  }
  return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset2, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset2 = ends[ends.length - 1];
  }
  return minSquaredDistance;
}

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset2, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    var x2 = flatCoordinates[offset2];
    var y2 = flatCoordinates[offset2 + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset2, ends, stride) {
  var area = 0;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += linearRing(flatCoordinates, offset2, end, stride);
    offset2 = end;
  }
  return area;
}
function linearRingss(flatCoordinates, offset2, endss, stride) {
  var area = 0;
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += linearRings(flatCoordinates, offset2, ends, stride);
    offset2 = ends[ends.length - 1];
  }
  return area;
}

// node_modules/ol/geom/LinearRing.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LinearRing = (
  /** @class */
  function(_super) {
    __extends(LinearRing2, _super);
    function LinearRing2(coordinates2, opt_layout) {
      var _this = _super.call(this) || this;
      _this.maxDelta_ = -1;
      _this.maxDeltaRevision_ = -1;
      if (opt_layout !== void 0 && !Array.isArray(coordinates2[0])) {
        _this.setFlatCoordinates(
          opt_layout,
          /** @type {Array<number>} */
          coordinates2
        );
      } else {
        _this.setCoordinates(
          /** @type {Array<import("../coordinate.js").Coordinate>} */
          coordinates2,
          opt_layout
        );
      }
      return _this;
    }
    LinearRing2.prototype.clone = function() {
      return new LinearRing2(this.flatCoordinates.slice(), this.layout);
    };
    LinearRing2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
        this.maxDeltaRevision_ = this.getRevision();
      }
      return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    };
    LinearRing2.prototype.getArea = function() {
      return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    LinearRing2.prototype.getCoordinates = function() {
      return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    LinearRing2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
      var simplifiedFlatCoordinates = [];
      simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
      return new LinearRing2(simplifiedFlatCoordinates, GeometryLayout_default.XY);
    };
    LinearRing2.prototype.getType = function() {
      return GeometryType_default.LINEAR_RING;
    };
    LinearRing2.prototype.intersectsExtent = function(extent) {
      return false;
    };
    LinearRing2.prototype.setCoordinates = function(coordinates2, opt_layout) {
      this.setLayout(opt_layout, coordinates2, 1);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);
      this.changed();
    };
    return LinearRing2;
  }(SimpleGeometry_default)
);
var LinearRing_default = LinearRing;

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset2, end, stride, extent) {
  var outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(flatCoordinates, offset2, end, stride, coordinate[0], coordinate[1]);
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset2, end, stride, x, y) {
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    var x2 = flatCoordinates[offset2];
    var y2 = flatCoordinates[offset2 + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset2, ends[0], stride, x, y)) {
    return false;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}
function linearRingssContainsXY(flatCoordinates, offset2, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  var intersections = [];
  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset2; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(numberSafeCompareFunction);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset2, endss, stride, flatCenters) {
  var interiorPoints = [];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset2 = ends[ends.length - 1];
  }
  return interiorPoints;
}

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset2, end, stride, callback) {
  var ret;
  offset2 += stride;
  for (; offset2 < end; offset2 += stride) {
    ret = callback(flatCoordinates.slice(offset2 - stride, offset2), flatCoordinates.slice(offset2, offset2 + stride));
    if (ret) {
      return ret;
    }
  }
  return false;
}

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset2, end, stride, extent) {
  var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset2, end, stride);
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset2,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLineStringArray(flatCoordinates, offset2, ends, stride, extent) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(flatCoordinates, offset2, ends[i], stride, extent)) {
      return true;
    }
    offset2 = ends[i];
  }
  return false;
}
function intersectsLinearRing(flatCoordinates, offset2, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset2, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent[0], extent[1])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent[0], extent[3])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent[2], extent[1])) {
    return true;
  }
  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent[2], extent[3])) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset2, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        return false;
      }
    }
  }
  return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset2, endss, stride, extent) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset2, end, stride) {
  while (offset2 < end - stride) {
    for (var i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset2 + i];
      flatCoordinates[offset2 + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset2 += stride;
    end -= stride;
  }
}

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset2, end, stride) {
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    var x2 = flatCoordinates[offset2];
    var y2 = flatCoordinates[offset2 + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset2, ends, stride, opt_right) {
  var right = opt_right !== void 0 ? opt_right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset2, end, stride);
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset2 = end;
  }
  return true;
}
function linearRingssAreOriented(flatCoordinates, offset2, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (!linearRingsAreOriented(flatCoordinates, offset2, ends, stride, opt_right)) {
      return false;
    }
    if (ends.length) {
      offset2 = ends[ends.length - 1];
    }
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset2, ends, stride, opt_right) {
  var right = opt_right !== void 0 ? opt_right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset2, end, stride);
    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset2, end, stride);
    }
    offset2 = end;
  }
  return offset2;
}
function orientLinearRingsArray(flatCoordinates, offset2, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    offset2 = orientLinearRings(flatCoordinates, offset2, endss[i], stride, opt_right);
  }
  return offset2;
}

// node_modules/ol/geom/Polygon.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Polygon = (
  /** @class */
  function(_super) {
    __extends2(Polygon2, _super);
    function Polygon2(coordinates2, opt_layout, opt_ends) {
      var _this = _super.call(this) || this;
      _this.ends_ = [];
      _this.flatInteriorPointRevision_ = -1;
      _this.flatInteriorPoint_ = null;
      _this.maxDelta_ = -1;
      _this.maxDeltaRevision_ = -1;
      _this.orientedRevision_ = -1;
      _this.orientedFlatCoordinates_ = null;
      if (opt_layout !== void 0 && opt_ends) {
        _this.setFlatCoordinates(
          opt_layout,
          /** @type {Array<number>} */
          coordinates2
        );
        _this.ends_ = opt_ends;
      } else {
        _this.setCoordinates(
          /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
          coordinates2,
          opt_layout
        );
      }
      return _this;
    }
    Polygon2.prototype.appendLinearRing = function(linearRing2) {
      if (!this.flatCoordinates) {
        this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
      } else {
        extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
      }
      this.ends_.push(this.flatCoordinates.length);
      this.changed();
    };
    Polygon2.prototype.clone = function() {
      var polygon = new Polygon2(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      polygon.applyProperties(this);
      return polygon;
    };
    Polygon2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
        this.maxDeltaRevision_ = this.getRevision();
      }
      return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    };
    Polygon2.prototype.containsXY = function(x, y) {
      return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
    };
    Polygon2.prototype.getArea = function() {
      return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    };
    Polygon2.prototype.getCoordinates = function(opt_right) {
      var flatCoordinates;
      if (opt_right !== void 0) {
        flatCoordinates = this.getOrientedFlatCoordinates().slice();
        orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
      } else {
        flatCoordinates = this.flatCoordinates;
      }
      return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
    };
    Polygon2.prototype.getEnds = function() {
      return this.ends_;
    };
    Polygon2.prototype.getFlatInteriorPoint = function() {
      if (this.flatInteriorPointRevision_ != this.getRevision()) {
        var flatCenter = getCenter(this.getExtent());
        this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
        this.flatInteriorPointRevision_ = this.getRevision();
      }
      return this.flatInteriorPoint_;
    };
    Polygon2.prototype.getInteriorPoint = function() {
      return new Point_default(this.getFlatInteriorPoint(), GeometryLayout_default.XYM);
    };
    Polygon2.prototype.getLinearRingCount = function() {
      return this.ends_.length;
    };
    Polygon2.prototype.getLinearRing = function(index) {
      if (index < 0 || this.ends_.length <= index) {
        return null;
      }
      return new LinearRing_default(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    };
    Polygon2.prototype.getLinearRings = function() {
      var layout = this.layout;
      var flatCoordinates = this.flatCoordinates;
      var ends = this.ends_;
      var linearRings2 = [];
      var offset2 = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var linearRing2 = new LinearRing_default(flatCoordinates.slice(offset2, end), layout);
        linearRings2.push(linearRing2);
        offset2 = end;
      }
      return linearRings2;
    };
    Polygon2.prototype.getOrientedFlatCoordinates = function() {
      if (this.orientedRevision_ != this.getRevision()) {
        var flatCoordinates = this.flatCoordinates;
        if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
          this.orientedFlatCoordinates_ = flatCoordinates;
        } else {
          this.orientedFlatCoordinates_ = flatCoordinates.slice();
          this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
        }
        this.orientedRevision_ = this.getRevision();
      }
      return this.orientedFlatCoordinates_;
    };
    Polygon2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
      var simplifiedFlatCoordinates = [];
      var simplifiedEnds = [];
      simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
      return new Polygon2(simplifiedFlatCoordinates, GeometryLayout_default.XY, simplifiedEnds);
    };
    Polygon2.prototype.getType = function() {
      return GeometryType_default.POLYGON;
    };
    Polygon2.prototype.intersectsExtent = function(extent) {
      return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
    };
    Polygon2.prototype.setCoordinates = function(coordinates2, opt_layout) {
      this.setLayout(opt_layout, coordinates2, 2);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.ends_);
      this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
      this.changed();
    };
    return Polygon2;
  }(SimpleGeometry_default)
);
var Polygon_default = Polygon;
function fromExtent(extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, GeometryLayout_default.XY, [
    flatCoordinates.length
  ]);
}
function fromCircle(circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);
  for (var i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (var j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  var ends = [flatCoordinates.length];
  var polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), opt_angle);
  return polygon;
}
function makeRegular(polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  for (var i = 0; i <= sides; ++i) {
    var offset2 = i * stride;
    var angle = startAngle + modulo(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset2] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset2 + 1] = center[1] + radius * Math.sin(angle);
  }
  polygon.changed();
}

// node_modules/ol/View.js
var __extends3 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DEFAULT_MIN_ZOOM = 0;
var View = (
  /** @class */
  function(_super) {
    __extends3(View2, _super);
    function View2(opt_options) {
      var _this = _super.call(this) || this;
      _this.on;
      _this.once;
      _this.un;
      var options = assign({}, opt_options);
      _this.hints_ = [0, 0];
      _this.animations_ = [];
      _this.updateAnimationKey_;
      _this.projection_ = createProjection(options.projection, "EPSG:3857");
      _this.viewportSize_ = [100, 100];
      _this.targetCenter_ = null;
      _this.targetResolution_;
      _this.targetRotation_;
      _this.nextCenter_ = null;
      _this.nextResolution_;
      _this.nextRotation_;
      _this.cancelAnchor_ = void 0;
      if (options.center) {
        options.center = fromUserCoordinate(options.center, _this.projection_);
      }
      if (options.extent) {
        options.extent = fromUserExtent(options.extent, _this.projection_);
      }
      if (options.projection) {
        disableCoordinateWarning();
      }
      _this.applyOptions_(options);
      return _this;
    }
    View2.prototype.applyOptions_ = function(options) {
      var properties = assign({}, options);
      for (var key in ViewProperty_default) {
        delete properties[key];
      }
      this.setProperties(properties, true);
      var resolutionConstraintInfo = createResolutionConstraint(options);
      this.maxResolution_ = resolutionConstraintInfo.maxResolution;
      this.minResolution_ = resolutionConstraintInfo.minResolution;
      this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
      this.resolutions_ = options.resolutions;
      this.padding_ = options.padding;
      this.minZoom_ = resolutionConstraintInfo.minZoom;
      var centerConstraint = createCenterConstraint(options);
      var resolutionConstraint = resolutionConstraintInfo.constraint;
      var rotationConstraint = createRotationConstraint(options);
      this.constraints_ = {
        center: centerConstraint,
        resolution: resolutionConstraint,
        rotation: rotationConstraint
      };
      this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
      this.setCenterInternal(options.center !== void 0 ? options.center : null);
      if (options.resolution !== void 0) {
        this.setResolution(options.resolution);
      } else if (options.zoom !== void 0) {
        this.setZoom(options.zoom);
      }
    };
    Object.defineProperty(View2.prototype, "padding", {
      /**
       * Padding (in css pixels).
       * If the map viewport is partially covered with other content (overlays) along
       * its edges, this setting allows to shift the center of the viewport away from that
       * content. The order of the values in the array is top, right, bottom, left.
       * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
       * @type {Array<number>|undefined}
       * @api
       */
      get: function() {
        return this.padding_;
      },
      set: function(padding) {
        var oldPadding = this.padding_;
        this.padding_ = padding;
        var center = this.getCenter();
        if (center) {
          var newPadding = padding || [0, 0, 0, 0];
          oldPadding = oldPadding || [0, 0, 0, 0];
          var resolution = this.getResolution();
          var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
          var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
          this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
        }
      },
      enumerable: false,
      configurable: true
    });
    View2.prototype.getUpdatedOptions_ = function(newOptions) {
      var options = this.getProperties();
      if (options.resolution !== void 0) {
        options.resolution = this.getResolution();
      } else {
        options.zoom = this.getZoom();
      }
      options.center = this.getCenterInternal();
      options.rotation = this.getRotation();
      return assign({}, options, newOptions);
    };
    View2.prototype.animate = function(var_args) {
      if (this.isDef() && !this.getAnimating()) {
        this.resolveConstraints(0);
      }
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; ++i) {
        var options = arguments[i];
        if (options.center) {
          options = assign({}, options);
          options.center = fromUserCoordinate(options.center, this.getProjection());
        }
        if (options.anchor) {
          options = assign({}, options);
          options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
        }
        args[i] = options;
      }
      this.animateInternal.apply(this, args);
    };
    View2.prototype.animateInternal = function(var_args) {
      var animationCount = arguments.length;
      var callback;
      if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
        callback = arguments[animationCount - 1];
        --animationCount;
      }
      var i = 0;
      for (; i < animationCount && !this.isDef(); ++i) {
        var state = arguments[i];
        if (state.center) {
          this.setCenterInternal(state.center);
        }
        if (state.zoom !== void 0) {
          this.setZoom(state.zoom);
        } else if (state.resolution) {
          this.setResolution(state.resolution);
        }
        if (state.rotation !== void 0) {
          this.setRotation(state.rotation);
        }
      }
      if (i === animationCount) {
        if (callback) {
          animationCallback(callback, true);
        }
        return;
      }
      var start = Date.now();
      var center = this.targetCenter_.slice();
      var resolution = this.targetResolution_;
      var rotation = this.targetRotation_;
      var series = [];
      for (; i < animationCount; ++i) {
        var options = (
          /** @type {AnimationOptions} */
          arguments[i]
        );
        var animation = {
          start,
          complete: false,
          anchor: options.anchor,
          duration: options.duration !== void 0 ? options.duration : 1e3,
          easing: options.easing || inAndOut,
          callback
        };
        if (options.center) {
          animation.sourceCenter = center;
          animation.targetCenter = options.center.slice();
          center = animation.targetCenter;
        }
        if (options.zoom !== void 0) {
          animation.sourceResolution = resolution;
          animation.targetResolution = this.getResolutionForZoom(options.zoom);
          resolution = animation.targetResolution;
        } else if (options.resolution) {
          animation.sourceResolution = resolution;
          animation.targetResolution = options.resolution;
          resolution = animation.targetResolution;
        }
        if (options.rotation !== void 0) {
          animation.sourceRotation = rotation;
          var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
          animation.targetRotation = rotation + delta;
          rotation = animation.targetRotation;
        }
        if (isNoopAnimation(animation)) {
          animation.complete = true;
        } else {
          start += animation.duration;
        }
        series.push(animation);
      }
      this.animations_.push(series);
      this.setHint(ViewHint_default.ANIMATING, 1);
      this.updateAnimations_();
    };
    View2.prototype.getAnimating = function() {
      return this.hints_[ViewHint_default.ANIMATING] > 0;
    };
    View2.prototype.getInteracting = function() {
      return this.hints_[ViewHint_default.INTERACTING] > 0;
    };
    View2.prototype.cancelAnimations = function() {
      this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
      var anchor;
      for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
        var series = this.animations_[i];
        if (series[0].callback) {
          animationCallback(series[0].callback, false);
        }
        if (!anchor) {
          for (var j = 0, jj = series.length; j < jj; ++j) {
            var animation = series[j];
            if (!animation.complete) {
              anchor = animation.anchor;
              break;
            }
          }
        }
      }
      this.animations_.length = 0;
      this.cancelAnchor_ = anchor;
      this.nextCenter_ = null;
      this.nextResolution_ = NaN;
      this.nextRotation_ = NaN;
    };
    View2.prototype.updateAnimations_ = function() {
      if (this.updateAnimationKey_ !== void 0) {
        cancelAnimationFrame(this.updateAnimationKey_);
        this.updateAnimationKey_ = void 0;
      }
      if (!this.getAnimating()) {
        return;
      }
      var now = Date.now();
      var more = false;
      for (var i = this.animations_.length - 1; i >= 0; --i) {
        var series = this.animations_[i];
        var seriesComplete = true;
        for (var j = 0, jj = series.length; j < jj; ++j) {
          var animation = series[j];
          if (animation.complete) {
            continue;
          }
          var elapsed = now - animation.start;
          var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
          if (fraction >= 1) {
            animation.complete = true;
            fraction = 1;
          } else {
            seriesComplete = false;
          }
          var progress = animation.easing(fraction);
          if (animation.sourceCenter) {
            var x0 = animation.sourceCenter[0];
            var y0 = animation.sourceCenter[1];
            var x1 = animation.targetCenter[0];
            var y1 = animation.targetCenter[1];
            this.nextCenter_ = animation.targetCenter;
            var x = x0 + progress * (x1 - x0);
            var y = y0 + progress * (y1 - y0);
            this.targetCenter_ = [x, y];
          }
          if (animation.sourceResolution && animation.targetResolution) {
            var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
            if (animation.anchor) {
              var size = this.getViewportSize_(this.getRotation());
              var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
              this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
            }
            this.nextResolution_ = animation.targetResolution;
            this.targetResolution_ = resolution;
            this.applyTargetState_(true);
          }
          if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
            var rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
            if (animation.anchor) {
              var constrainedRotation = this.constraints_.rotation(rotation, true);
              this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
            }
            this.nextRotation_ = animation.targetRotation;
            this.targetRotation_ = rotation;
          }
          this.applyTargetState_(true);
          more = true;
          if (!animation.complete) {
            break;
          }
        }
        if (seriesComplete) {
          this.animations_[i] = null;
          this.setHint(ViewHint_default.ANIMATING, -1);
          this.nextCenter_ = null;
          this.nextResolution_ = NaN;
          this.nextRotation_ = NaN;
          var callback = series[0].callback;
          if (callback) {
            animationCallback(callback, true);
          }
        }
      }
      this.animations_ = this.animations_.filter(Boolean);
      if (more && this.updateAnimationKey_ === void 0) {
        this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
      }
    };
    View2.prototype.calculateCenterRotate = function(rotation, anchor) {
      var center;
      var currentCenter = this.getCenterInternal();
      if (currentCenter !== void 0) {
        center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
        rotate(center, rotation - this.getRotation());
        add(center, anchor);
      }
      return center;
    };
    View2.prototype.calculateCenterZoom = function(resolution, anchor) {
      var center;
      var currentCenter = this.getCenterInternal();
      var currentResolution = this.getResolution();
      if (currentCenter !== void 0 && currentResolution !== void 0) {
        var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
        var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
        center = [x, y];
      }
      return center;
    };
    View2.prototype.getViewportSize_ = function(opt_rotation) {
      var size = this.viewportSize_;
      if (opt_rotation) {
        var w = size[0];
        var h = size[1];
        return [
          Math.abs(w * Math.cos(opt_rotation)) + Math.abs(h * Math.sin(opt_rotation)),
          Math.abs(w * Math.sin(opt_rotation)) + Math.abs(h * Math.cos(opt_rotation))
        ];
      } else {
        return size;
      }
    };
    View2.prototype.setViewportSize = function(opt_size) {
      this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [100, 100];
      if (!this.getAnimating()) {
        this.resolveConstraints(0);
      }
    };
    View2.prototype.getCenter = function() {
      var center = this.getCenterInternal();
      if (!center) {
        return center;
      }
      return toUserCoordinate(center, this.getProjection());
    };
    View2.prototype.getCenterInternal = function() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(ViewProperty_default.CENTER)
      );
    };
    View2.prototype.getConstraints = function() {
      return this.constraints_;
    };
    View2.prototype.getConstrainResolution = function() {
      return this.get("constrainResolution");
    };
    View2.prototype.getHints = function(opt_hints) {
      if (opt_hints !== void 0) {
        opt_hints[0] = this.hints_[0];
        opt_hints[1] = this.hints_[1];
        return opt_hints;
      } else {
        return this.hints_.slice();
      }
    };
    View2.prototype.calculateExtent = function(opt_size) {
      var extent = this.calculateExtentInternal(opt_size);
      return toUserExtent(extent, this.getProjection());
    };
    View2.prototype.calculateExtentInternal = function(opt_size) {
      var size = opt_size || this.getViewportSizeMinusPadding_();
      var center = (
        /** @type {!import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      assert(center, 1);
      var resolution = (
        /** @type {!number} */
        this.getResolution()
      );
      assert(resolution !== void 0, 2);
      var rotation = (
        /** @type {!number} */
        this.getRotation()
      );
      assert(rotation !== void 0, 3);
      return getForViewAndSize(center, resolution, rotation, size);
    };
    View2.prototype.getMaxResolution = function() {
      return this.maxResolution_;
    };
    View2.prototype.getMinResolution = function() {
      return this.minResolution_;
    };
    View2.prototype.getMaxZoom = function() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.minResolution_)
      );
    };
    View2.prototype.setMaxZoom = function(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
    };
    View2.prototype.getMinZoom = function() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.maxResolution_)
      );
    };
    View2.prototype.setMinZoom = function(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
    };
    View2.prototype.setConstrainResolution = function(enabled) {
      this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
    };
    View2.prototype.getProjection = function() {
      return this.projection_;
    };
    View2.prototype.getResolution = function() {
      return (
        /** @type {number|undefined} */
        this.get(ViewProperty_default.RESOLUTION)
      );
    };
    View2.prototype.getResolutions = function() {
      return this.resolutions_;
    };
    View2.prototype.getResolutionForExtent = function(extent, opt_size) {
      return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), opt_size);
    };
    View2.prototype.getResolutionForExtentInternal = function(extent, opt_size) {
      var size = opt_size || this.getViewportSizeMinusPadding_();
      var xResolution = getWidth(extent) / size[0];
      var yResolution = getHeight(extent) / size[1];
      return Math.max(xResolution, yResolution);
    };
    View2.prototype.getResolutionForValueFunction = function(opt_power) {
      var power = opt_power || 2;
      var maxResolution = this.getConstrainedResolution(this.maxResolution_);
      var minResolution = this.minResolution_;
      var max = Math.log(maxResolution / minResolution) / Math.log(power);
      return (
        /**
         * @param {number} value Value.
         * @return {number} Resolution.
         */
        function(value) {
          var resolution = maxResolution / Math.pow(power, value * max);
          return resolution;
        }
      );
    };
    View2.prototype.getRotation = function() {
      return (
        /** @type {number} */
        this.get(ViewProperty_default.ROTATION)
      );
    };
    View2.prototype.getValueForResolutionFunction = function(opt_power) {
      var logPower = Math.log(opt_power || 2);
      var maxResolution = this.getConstrainedResolution(this.maxResolution_);
      var minResolution = this.minResolution_;
      var max = Math.log(maxResolution / minResolution) / logPower;
      return (
        /**
         * @param {number} resolution Resolution.
         * @return {number} Value.
         */
        function(resolution) {
          var value = Math.log(maxResolution / resolution) / logPower / max;
          return value;
        }
      );
    };
    View2.prototype.getViewportSizeMinusPadding_ = function(opt_rotation) {
      var size = this.getViewportSize_(opt_rotation);
      var padding = this.padding_;
      if (padding) {
        size = [
          size[0] - padding[1] - padding[3],
          size[1] - padding[0] - padding[2]
        ];
      }
      return size;
    };
    View2.prototype.getState = function() {
      var projection = this.getProjection();
      var resolution = this.getResolution();
      var rotation = this.getRotation();
      var center = (
        /** @type {import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      var padding = this.padding_;
      if (padding) {
        var reducedSize = this.getViewportSizeMinusPadding_();
        center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
      }
      return {
        center: center.slice(0),
        projection: projection !== void 0 ? projection : null,
        resolution,
        nextCenter: this.nextCenter_,
        nextResolution: this.nextResolution_,
        nextRotation: this.nextRotation_,
        rotation,
        zoom: this.getZoom()
      };
    };
    View2.prototype.getZoom = function() {
      var zoom;
      var resolution = this.getResolution();
      if (resolution !== void 0) {
        zoom = this.getZoomForResolution(resolution);
      }
      return zoom;
    };
    View2.prototype.getZoomForResolution = function(resolution) {
      var offset2 = this.minZoom_ || 0;
      var max, zoomFactor;
      if (this.resolutions_) {
        var nearest = linearFindNearest(this.resolutions_, resolution, 1);
        offset2 = nearest;
        max = this.resolutions_[nearest];
        if (nearest == this.resolutions_.length - 1) {
          zoomFactor = 2;
        } else {
          zoomFactor = max / this.resolutions_[nearest + 1];
        }
      } else {
        max = this.maxResolution_;
        zoomFactor = this.zoomFactor_;
      }
      return offset2 + Math.log(max / resolution) / Math.log(zoomFactor);
    };
    View2.prototype.getResolutionForZoom = function(zoom) {
      if (this.resolutions_) {
        if (this.resolutions_.length <= 1) {
          return 0;
        }
        var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
        var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
        return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
      } else {
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
      }
    };
    View2.prototype.fit = function(geometryOrExtent, opt_options) {
      var geometry;
      assert(Array.isArray(geometryOrExtent) || typeof /** @type {?} */
      geometryOrExtent.getSimplifiedGeometry === "function", 24);
      if (Array.isArray(geometryOrExtent)) {
        assert(!isEmpty(geometryOrExtent), 25);
        var extent = fromUserExtent(geometryOrExtent, this.getProjection());
        geometry = fromExtent(extent);
      } else if (geometryOrExtent.getType() === GeometryType_default.CIRCLE) {
        var extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
        geometry = fromExtent(extent);
        geometry.rotate(this.getRotation(), getCenter(extent));
      } else {
        var userProjection = getUserProjection();
        if (userProjection) {
          geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
          geometryOrExtent.clone().transform(userProjection, this.getProjection());
        } else {
          geometry = geometryOrExtent;
        }
      }
      this.fitInternal(geometry, opt_options);
    };
    View2.prototype.rotatedExtentForGeometry = function(geometry) {
      var rotation = this.getRotation();
      var cosAngle = Math.cos(rotation);
      var sinAngle = Math.sin(-rotation);
      var coords = geometry.getFlatCoordinates();
      var stride = geometry.getStride();
      var minRotX = Infinity;
      var minRotY = Infinity;
      var maxRotX = -Infinity;
      var maxRotY = -Infinity;
      for (var i = 0, ii = coords.length; i < ii; i += stride) {
        var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
        var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
        minRotX = Math.min(minRotX, rotX);
        minRotY = Math.min(minRotY, rotY);
        maxRotX = Math.max(maxRotX, rotX);
        maxRotY = Math.max(maxRotY, rotY);
      }
      return [minRotX, minRotY, maxRotX, maxRotY];
    };
    View2.prototype.fitInternal = function(geometry, opt_options) {
      var options = opt_options || {};
      var size = options.size;
      if (!size) {
        size = this.getViewportSizeMinusPadding_();
      }
      var padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
      var nearest = options.nearest !== void 0 ? options.nearest : false;
      var minResolution;
      if (options.minResolution !== void 0) {
        minResolution = options.minResolution;
      } else if (options.maxZoom !== void 0) {
        minResolution = this.getResolutionForZoom(options.maxZoom);
      } else {
        minResolution = 0;
      }
      var rotatedExtent = this.rotatedExtentForGeometry(geometry);
      var resolution = this.getResolutionForExtentInternal(rotatedExtent, [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2]
      ]);
      resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
      resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
      var rotation = this.getRotation();
      var sinAngle = Math.sin(rotation);
      var cosAngle = Math.cos(rotation);
      var centerRot = getCenter(rotatedExtent);
      centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
      centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
      var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
      var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
      var center = this.getConstrainedCenter([centerX, centerY], resolution);
      var callback = options.callback ? options.callback : VOID;
      if (options.duration !== void 0) {
        this.animateInternal({
          resolution,
          center,
          duration: options.duration,
          easing: options.easing
        }, callback);
      } else {
        this.targetResolution_ = resolution;
        this.targetCenter_ = center;
        this.applyTargetState_(false, true);
        animationCallback(callback, true);
      }
    };
    View2.prototype.centerOn = function(coordinate, size, position) {
      this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
    };
    View2.prototype.centerOnInternal = function(coordinate, size, position) {
      this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    };
    View2.prototype.calculateCenterShift = function(center, resolution, rotation, size) {
      var centerShift;
      var padding = this.padding_;
      if (padding && center) {
        var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
        var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
        centerShift = [
          center[0] - shiftedCenter[0],
          center[1] - shiftedCenter[1]
        ];
      }
      return centerShift;
    };
    View2.prototype.isDef = function() {
      return !!this.getCenterInternal() && this.getResolution() !== void 0;
    };
    View2.prototype.adjustCenter = function(deltaCoordinates) {
      var center = toUserCoordinate(this.targetCenter_, this.getProjection());
      this.setCenter([
        center[0] + deltaCoordinates[0],
        center[1] + deltaCoordinates[1]
      ]);
    };
    View2.prototype.adjustCenterInternal = function(deltaCoordinates) {
      var center = this.targetCenter_;
      this.setCenterInternal([
        center[0] + deltaCoordinates[0],
        center[1] + deltaCoordinates[1]
      ]);
    };
    View2.prototype.adjustResolution = function(ratio, opt_anchor) {
      var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
      this.adjustResolutionInternal(ratio, anchor);
    };
    View2.prototype.adjustResolutionInternal = function(ratio, opt_anchor) {
      var isMoving = this.getAnimating() || this.getInteracting();
      var size = this.getViewportSize_(this.getRotation());
      var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
      if (opt_anchor) {
        this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
      }
      this.targetResolution_ *= ratio;
      this.applyTargetState_();
    };
    View2.prototype.adjustZoom = function(delta, opt_anchor) {
      this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
    };
    View2.prototype.adjustRotation = function(delta, opt_anchor) {
      if (opt_anchor) {
        opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());
      }
      this.adjustRotationInternal(delta, opt_anchor);
    };
    View2.prototype.adjustRotationInternal = function(delta, opt_anchor) {
      var isMoving = this.getAnimating() || this.getInteracting();
      var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
      if (opt_anchor) {
        this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
      }
      this.targetRotation_ += delta;
      this.applyTargetState_();
    };
    View2.prototype.setCenter = function(center) {
      this.setCenterInternal(center ? fromUserCoordinate(center, this.getProjection()) : center);
    };
    View2.prototype.setCenterInternal = function(center) {
      this.targetCenter_ = center;
      this.applyTargetState_();
    };
    View2.prototype.setHint = function(hint, delta) {
      this.hints_[hint] += delta;
      this.changed();
      return this.hints_[hint];
    };
    View2.prototype.setResolution = function(resolution) {
      this.targetResolution_ = resolution;
      this.applyTargetState_();
    };
    View2.prototype.setRotation = function(rotation) {
      this.targetRotation_ = rotation;
      this.applyTargetState_();
    };
    View2.prototype.setZoom = function(zoom) {
      this.setResolution(this.getResolutionForZoom(zoom));
    };
    View2.prototype.applyTargetState_ = function(opt_doNotCancelAnims, opt_forceMoving) {
      var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
      var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
      var size = this.getViewportSize_(newRotation);
      var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
      var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
      if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
        this.set(ViewProperty_default.ROTATION, newRotation);
      }
      if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
        this.set(ViewProperty_default.RESOLUTION, newResolution);
        this.set("zoom", this.getZoom(), true);
      }
      if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals(this.get(ViewProperty_default.CENTER), newCenter)) {
        this.set(ViewProperty_default.CENTER, newCenter);
      }
      if (this.getAnimating() && !opt_doNotCancelAnims) {
        this.cancelAnimations();
      }
      this.cancelAnchor_ = void 0;
    };
    View2.prototype.resolveConstraints = function(opt_duration, opt_resolutionDirection, opt_anchor) {
      var duration = opt_duration !== void 0 ? opt_duration : 200;
      var direction = opt_resolutionDirection || 0;
      var newRotation = this.constraints_.rotation(this.targetRotation_);
      var size = this.getViewportSize_(newRotation);
      var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
      var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
      if (duration === 0 && !this.cancelAnchor_) {
        this.targetResolution_ = newResolution;
        this.targetRotation_ = newRotation;
        this.targetCenter_ = newCenter;
        this.applyTargetState_();
        return;
      }
      var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
      this.cancelAnchor_ = void 0;
      if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals(this.getCenterInternal(), newCenter)) {
        if (this.getAnimating()) {
          this.cancelAnimations();
        }
        this.animateInternal({
          rotation: newRotation,
          center: newCenter,
          resolution: newResolution,
          duration,
          easing: easeOut,
          anchor
        });
      }
    };
    View2.prototype.beginInteraction = function() {
      this.resolveConstraints(0);
      this.setHint(ViewHint_default.INTERACTING, 1);
    };
    View2.prototype.endInteraction = function(opt_duration, opt_resolutionDirection, opt_anchor) {
      var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
      this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
    };
    View2.prototype.endInteractionInternal = function(opt_duration, opt_resolutionDirection, opt_anchor) {
      this.setHint(ViewHint_default.INTERACTING, -1);
      this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
    };
    View2.prototype.getConstrainedCenter = function(targetCenter, opt_targetResolution) {
      var size = this.getViewportSize_(this.getRotation());
      return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
    };
    View2.prototype.getConstrainedZoom = function(targetZoom, opt_direction) {
      var targetRes = this.getResolutionForZoom(targetZoom);
      return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
    };
    View2.prototype.getConstrainedResolution = function(targetResolution, opt_direction) {
      var direction = opt_direction || 0;
      var size = this.getViewportSize_(this.getRotation());
      return this.constraints_.resolution(targetResolution, direction, size);
    };
    return View2;
  }(Object_default)
);
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    var smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  var projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    var extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  var multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  var smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  var showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  var projection = createProjection(options.projection, "EPSG:3857");
  var projExtent = projection.getExtent();
  var constrainOnlyCenter = options.constrainOnlyCenter;
  var extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  } else {
    var size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT[Units_default.DEGREES] / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    } else if (constrainRotation === false) {
      return none2;
    } else if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    } else {
      return none2;
    }
  } else {
    return disable;
  }
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var View_default = View;

export {
  ViewProperty_default,
  disable,
  maxSquaredDelta,
  arrayMaxSquaredDelta,
  multiArrayMaxSquaredDelta,
  assignClosestPoint,
  assignClosestArrayPoint,
  assignClosestMultiArrayPoint,
  linearRingss,
  linearRingssContainsXY,
  getInteriorPointsOfMultiArray,
  forEach,
  intersectsLineString,
  intersectsLineStringArray,
  intersectsLinearRingMultiArray,
  linearRingssAreOriented,
  orientLinearRingsArray,
  Polygon_default,
  fromExtent,
  fromCircle,
  createCenterConstraint,
  createResolutionConstraint,
  createRotationConstraint,
  isNoopAnimation,
  View_default
};
//# sourceMappingURL=chunk-C4U33VZT.js.map
