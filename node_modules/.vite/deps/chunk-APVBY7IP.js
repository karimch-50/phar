import {
  TemplateResultType,
  isTemplateResult
} from "./chunk-43WG3WIY.js";
import {
  Directive,
  PartType,
  directive
} from "./chunk-RMSEGTBR.js";
import {
  ElementMixin
} from "./chunk-MWSAWSJ3.js";
import {
  noChange,
  nothing,
  render,
  svg
} from "./chunk-QO3ZNG6F.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import {
  PolymerElement
} from "./chunk-4TYUW4EB.js";

// node_modules/lit-html/development/directives/unsafe-html.js
var HTML_RESULT = 1;
var UnsafeHTMLDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._value = nothing;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  render(value) {
    if (value === nothing || value == null) {
      this._templateResult = void 0;
      return this._value = value;
    }
    if (value === noChange) {
      return value;
    }
    if (typeof value != "string") {
      throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
    }
    if (value === this._value) {
      return this._templateResult;
    }
    this._value = value;
    const strings = [value];
    strings.raw = strings;
    return this._templateResult = {
      // Cast to a known set of integers that satisfy ResultType so that we
      // don't have to export ResultType and possibly encourage this pattern.
      // This property needs to remain unminified.
      ["_$litType$"]: this.constructor.resultType,
      strings,
      values: []
    };
  }
};
UnsafeHTMLDirective.directiveName = "unsafeHTML";
UnsafeHTMLDirective.resultType = HTML_RESULT;
var unsafeHTML = directive(UnsafeHTMLDirective);

// node_modules/lit-html/development/directives/unsafe-svg.js
var SVG_RESULT = 2;
var UnsafeSVGDirective = class extends UnsafeHTMLDirective {
};
UnsafeSVGDirective.directiveName = "unsafeSVG";
UnsafeSVGDirective.resultType = SVG_RESULT;
var unsafeSVG = directive(UnsafeSVGDirective);

// node_modules/@vaadin/icon/src/vaadin-icon-svg.js
function cloneSvgNode(source) {
  let result = nothing;
  if (source) {
    const content = source.cloneNode(true);
    content.removeAttribute("id");
    result = svg`${unsafeSVG(content.outerHTML)}`;
  }
  return result;
}
function isValidSvg(source) {
  return isTemplateResult(source, TemplateResultType.SVG) || source === nothing;
}
function ensureSvgLiteral(source) {
  let result = source == null || source === "" ? nothing : source;
  if (!isValidSvg(result)) {
    console.error("[vaadin-icon] Invalid svg passed, please use Lit svg literal.");
    result = nothing;
  }
  return result;
}
function renderSvg(source, container) {
  const result = ensureSvgLiteral(source);
  render(result, container);
}
function unsafeSvgLiteral(source) {
  return svg`${unsafeSVG(source)}`;
}

// node_modules/@vaadin/icon/src/vaadin-iconset.js
var iconsetRegistry = {};
var attachedIcons = /* @__PURE__ */ new Set();
function getIconId(id, name) {
  return (id || "").replace(`${name}:`, "");
}
function getIconsetName(icon) {
  if (!icon) {
    return;
  }
  const parts = icon.split(":");
  return parts[0] || "vaadin";
}
function initIconsMap(iconset, name) {
  iconset._icons = [...iconset.querySelectorAll("[id]")].reduce((map, svg2) => {
    const key = getIconId(svg2.id, name);
    map[key] = svg2;
    return map;
  }, {});
}
var Iconset = class extends ElementMixin(PolymerElement) {
  static get template() {
    return null;
  }
  static get is() {
    return "vaadin-iconset";
  }
  static get properties() {
    return {
      /**
       * The name of the iconset. Every iconset is required to have its own unique name.
       * All the SVG icons in the iconset must have IDs conforming to its name.
       *
       * See also [`name`](#/elements/vaadin-icon#property-name) property of `vaadin-icon`.
       */
      name: {
        type: String,
        observer: "__nameChanged"
      },
      /**
       * The size of an individual icon. Note that icons must be square.
       *
       * When using `vaadin-icon`, the size of the iconset will take precedence
       * over the size defined by the user to ensure correct appearance.
       */
      size: {
        type: Number,
        value: 24
      }
    };
  }
  /**
   * Set of the `vaadin-icon` instances in the DOM.
   *
   * @return {Set<Icon>}
   */
  static get attachedIcons() {
    return attachedIcons;
  }
  /**
   * Returns an instance of the iconset by its name.
   *
   * @param {string} name
   * @return {Iconset}
   */
  static getIconset(name) {
    return iconsetRegistry[name];
  }
  /**
   * Returns SVGTemplateResult for the `icon` ID matching `name` of the
   * iconset, or `nothing` literal if there is no matching icon found.
   *
   * @param {string} icon
   * @param {?string} name
   */
  static getIconSvg(icon, name) {
    const iconsetName = name || getIconsetName(icon);
    const iconset = this.getIconset(iconsetName);
    if (!icon || !iconset) {
      return { svg: cloneSvgNode(null) };
    }
    const iconId = getIconId(icon, iconsetName);
    const iconSvg = iconset._icons[iconId];
    return {
      preserveAspectRatio: iconSvg ? iconSvg.getAttribute("preserveAspectRatio") : null,
      svg: cloneSvgNode(iconSvg),
      size: iconset.size,
      viewBox: iconSvg ? iconSvg.getAttribute("viewBox") : null
    };
  }
  /**
   * Register an iconset without adding to the DOM.
   *
   * @param {string} name
   * @param {number} size
   * @param {?HTMLTemplateElement} template
   */
  static register(name, size, template) {
    if (!iconsetRegistry[name]) {
      const iconset = document.createElement("vaadin-iconset");
      iconset.appendChild(template.content.cloneNode(true));
      iconsetRegistry[name] = iconset;
      initIconsMap(iconset, name);
      iconset.size = size;
      iconset.name = name;
      iconset.__nameChanged(name);
    }
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.style.display = "none";
    const { name } = this;
    iconsetRegistry[name] = this;
    initIconsMap(this, name);
    this.__updateIcons(name);
  }
  /**
   * Update all the icons instances in the DOM.
   *
   * @param {string} name
   * @private
   */
  __updateIcons(name) {
    attachedIcons.forEach((element) => {
      if (name === getIconsetName(element.icon)) {
        element._applyIcon();
      }
    });
  }
  /** @private */
  __nameChanged(name, oldName) {
    if (oldName) {
      iconsetRegistry[name] = iconsetRegistry[oldName];
      delete iconsetRegistry[oldName];
    }
    if (name) {
      this.__updateIcons(name);
    }
  }
};
defineCustomElement(Iconset);

export {
  ensureSvgLiteral,
  renderSvg,
  unsafeSvgLiteral,
  Iconset
};
/*! Bundled license information:

lit-html/development/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/unsafe-svg.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@vaadin/icon/src/vaadin-icon-svg.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/icon/src/vaadin-iconset.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-APVBY7IP.js.map
