import {
  ContextMenu,
  MenuOverlayMixin,
  contextMenuItem,
  contextMenuListBox,
  contextMenuOverlay,
  styles
} from "./chunk-UAVKWSFN.js";
import "./chunk-QXKYTJLT.js";
import "./chunk-3TOJB423.js";
import {
  listBox
} from "./chunk-F6RGR3SN.js";
import {
  ItemMixin
} from "./chunk-FSPP5RVA.js";
import {
  ListMixin
} from "./chunk-JWDOWCJS.js";
import {
  menuOverlay
} from "./chunk-UY4FDBB3.js";
import {
  item
} from "./chunk-ELPZA6KY.js";
import "./chunk-A2UCFRVY.js";
import "./chunk-BGWLAHRF.js";
import "./chunk-UFBVVQ65.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-HYO4DUYL.js";
import "./chunk-PJNJQYXC.js";
import "./chunk-ZE63AH6T.js";
import "./chunk-TH3SXEA2.js";
import "./chunk-DV2EGEEG.js";
import {
  ResizeMixin
} from "./chunk-2JVJNHM2.js";
import "./chunk-FSP2XZVR.js";
import {
  button
} from "./chunk-7DHOJVCV.js";
import {
  Button
} from "./chunk-MOF77BCW.js";
import "./chunk-IHIS7TAV.js";
import {
  KeyboardDirectionMixin
} from "./chunk-24BF3Z44.js";
import {
  ElementMixin
} from "./chunk-MWSAWSJ3.js";
import "./chunk-SEGZ6IIL.js";
import "./chunk-EZVFCO5I.js";
import "./chunk-TOPBZAEH.js";
import "./chunk-LERX5ED5.js";
import "./chunk-RPOYDVPH.js";
import {
  DisabledMixin
} from "./chunk-CRXJMMF2.js";
import "./chunk-EJTF7QKX.js";
import {
  TooltipController
} from "./chunk-44TTWRW5.js";
import {
  SlotController
} from "./chunk-6C6BQOMD.js";
import "./chunk-ZPXTDJKE.js";
import "./chunk-O6KCEJHO.js";
import "./chunk-EFKWAQ3Y.js";
import {
  FocusMixin
} from "./chunk-3BRKSSC5.js";
import "./chunk-GRU2OPCY.js";
import "./chunk-HFKL6MLF.js";
import {
  ControllerMixin
} from "./chunk-QGCYTHXO.js";
import "./chunk-JQFZSNBR.js";
import {
  isElementFocused,
  isKeyboardActive
} from "./chunk-F7YWWDDG.js";
import "./chunk-R6DBYMLB.js";
import "./chunk-BORGCLO4.js";
import "./chunk-J4OM4IIF.js";
import "./chunk-3WOFLRNV.js";
import "./chunk-J2NV7QBD.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-BBNA52CT.js";
import "./chunk-IBHXN4JT.js";
import "./chunk-QO3ZNG6F.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import {
  DirMixin
} from "./chunk-B6NQGUVK.js";
import "./chunk-ER2S4LLB.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import {
  PolymerElement
} from "./chunk-4TYUW4EB.js";
import "./chunk-FXP5WKMI.js";
import "./chunk-2IE6RYOR.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import {
  html
} from "./chunk-XB4RSW42.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-WGAPYIUP.js";

// node_modules/@vaadin/menu-bar/theme/lumo/vaadin-menu-bar-button-styles.js
var menuBarButton = css`
  :host {
    margin: calc(var(--lumo-space-xs) / 2);
    margin-left: 0;
    border-radius: 0;
  }

  [part='label'] {
    width: 100%;
  }

  /* NOTE(web-padawan): avoid using shorthand padding property for IE11 */
  [part='label'] ::slotted(vaadin-menu-bar-item) {
    justify-content: center;
    background-color: transparent;
    height: var(--lumo-button-size);
    margin: 0 calc((var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2) * -1);
    padding-left: calc(var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2);
    padding-right: calc(var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2);
  }

  :host([theme~='small']) [part='label'] ::slotted(vaadin-menu-bar-item) {
    min-height: var(--lumo-size-s);
    margin: 0 calc((var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2) * -1);
    padding-left: calc(var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2);
    padding-right: calc(var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2);
  }

  :host([theme~='tertiary']) [part='label'] ::slotted(vaadin-menu-bar-item) {
    margin: 0 calc((var(--lumo-button-size) / 6) * -1);
    padding-left: calc(var(--lumo-button-size) / 6);
    padding-right: calc(var(--lumo-button-size) / 6);
  }

  :host([theme~='tertiary-inline']) {
    margin-top: calc(var(--lumo-space-xs) / 2);
    margin-bottom: calc(var(--lumo-space-xs) / 2);
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([theme~='tertiary-inline']) [part='label'] ::slotted(vaadin-menu-bar-item) {
    margin: 0;
    padding: 0;
  }

  :host(:first-of-type) {
    border-radius: var(--lumo-border-radius-m) 0 0 var(--lumo-border-radius-m);

    /* Needed to retain the focus-ring with border-radius */
    margin-left: calc(var(--lumo-space-xs) / 2);
  }

  :host(:nth-last-of-type(2)),
  :host([slot='overflow']) {
    border-radius: 0 var(--lumo-border-radius-m) var(--lumo-border-radius-m) 0;
  }

  :host([theme~='tertiary']),
  :host([theme~='tertiary-inline']) {
    border-radius: var(--lumo-border-radius-m);
  }

  :host([slot='overflow']) {
    min-width: var(--lumo-button-size);
    padding-left: calc(var(--lumo-button-size) / 4);
    padding-right: calc(var(--lumo-button-size) / 4);
  }

  :host([slot='overflow']) ::slotted(*) {
    font-size: var(--lumo-font-size-xl);
  }

  :host([slot='overflow']) [part='prefix'],
  :host([slot='overflow']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }

  /* RTL styles */
  :host([dir='rtl']) {
    margin-left: calc(var(--lumo-space-xs) / 2);
    margin-right: 0;
    border-radius: 0;
  }

  :host([dir='rtl']:first-of-type) {
    border-radius: 0 var(--lumo-border-radius-m) var(--lumo-border-radius-m) 0;
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([dir='rtl']:nth-last-of-type(2)),
  :host([dir='rtl'][slot='overflow']) {
    border-radius: var(--lumo-border-radius-m) 0 0 var(--lumo-border-radius-m);
  }
`;
registerStyles("vaadin-menu-bar-button", [button, menuBarButton], {
  moduleId: "lumo-menu-bar-button"
});

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-button.js
registerStyles(
  "vaadin-menu-bar-button",
  css`
    :host {
      flex-shrink: 0;
    }

    :host([slot='overflow']) {
      margin-inline-end: 0;
    }

    [part='label'] ::slotted(vaadin-menu-bar-item) {
      position: relative;
      z-index: 1;
    }
  `,
  { moduleId: "vaadin-menu-bar-button-styles" }
);
var MenuBarButton = class extends Button {
  static get is() {
    return "vaadin-menu-bar-button";
  }
  /**
   * Override method inherited from `ButtonMixin`. Sets a flag based on whether the key is an active key. Unlike a mouse click, Enter and Space should also focus the first item. This flag is used in menu bar to identify the action that triggered the click.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    this.__triggeredWithActiveKeys = this._activeKeys.includes(event.key);
    super._onKeyDown(event);
    this.__triggeredWithActiveKeys = null;
  }
};
defineCustomElement(MenuBarButton);

// node_modules/@vaadin/menu-bar/theme/lumo/vaadin-menu-bar-item-styles.js
var menuBarItem = css`
  [part='content'] {
    display: flex;
    /* tweak to inherit centering from menu bar button */
    align-items: inherit;
    justify-content: inherit;
  }

  [part='content'] ::slotted(vaadin-icon) {
    display: inline-block;
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }

  [part='content'] ::slotted(vaadin-icon[icon^='vaadin:']) {
    padding: var(--lumo-space-xs);
    box-sizing: border-box !important;
  }
`;
registerStyles("vaadin-menu-bar-item", [item, contextMenuItem, menuBarItem], { moduleId: "lumo-menu-bar-item" });

// node_modules/@vaadin/menu-bar/theme/lumo/vaadin-menu-bar-list-box-styles.js
registerStyles("vaadin-menu-bar-list-box", [listBox, contextMenuListBox], { moduleId: "lumo-menu-bar-list-box" });

// node_modules/@vaadin/menu-bar/theme/lumo/vaadin-menu-bar-overlay-styles.js
var menuBarOverlay = css`
  :host(:first-of-type) {
    padding-top: var(--lumo-space-xs);
  }
`;
registerStyles("vaadin-menu-bar-overlay", [menuOverlay, contextMenuOverlay, menuBarOverlay], {
  moduleId: "lumo-menu-bar-overlay"
});

// node_modules/@vaadin/menu-bar/theme/lumo/vaadin-menu-bar-styles.js
registerStyles(
  "vaadin-menu-bar",
  css`
    :host([has-single-button]) ::slotted(vaadin-menu-bar-button) {
      border-radius: var(--lumo-border-radius-m);
    }

    :host([theme~='end-aligned']) ::slotted(vaadin-menu-bar-button:first-of-type),
    :host([theme~='end-aligned'][has-single-button]) ::slotted(vaadin-menu-bar-button) {
      margin-inline-start: auto;
    }
  `,
  { moduleId: "lumo-menu-bar" }
);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-item.js
var MenuBarItem = class extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-menu-bar-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menuitem");
  }
};
defineCustomElement(MenuBarItem);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-list-box.js
var MenuBarListBox = class extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-menu-bar-list-box";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
};
defineCustomElement(MenuBarListBox);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-overlay.js
registerStyles("vaadin-menu-bar-overlay", [overlayStyles, styles], {
  moduleId: "vaadin-menu-bar-overlay-styles"
});
var MenuBarOverlay = class extends MenuOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-menu-bar-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
defineCustomElement(MenuBarOverlay);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-submenu.js
var MenuBarSubmenu = class extends ContextMenu {
  static get is() {
    return "vaadin-menu-bar-submenu";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>

      <slot id="slot"></slot>
    `;
  }
  constructor() {
    super();
    this.openOn = "opensubmenu";
  }
  /**
   * Tag name prefix used by overlay, list-box and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-menu-bar";
  }
  /**
   * Overriding the observer to not add global "contextmenu" listener.
   */
  _openedChanged(opened) {
    this._overlayElement.opened = opened;
  }
  /**
   * Overriding the public method to reset expanded button state.
   */
  close() {
    super.close();
    if (this.hasAttribute("is-root")) {
      this.getRootNode().host._close();
    }
  }
};
defineCustomElement(MenuBarSubmenu);

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar-mixin.js
var MenuBarMixin = (superClass) => class MenuBarMixinClass extends KeyboardDirectionMixin(
  ResizeMixin(FocusMixin(DisabledMixin(ControllerMixin(superClass))))
) {
  static get properties() {
    return {
      /**
       * @typedef MenuBarItem
       * @type {object}
       * @property {string} text - Text to be set as the menu button component's textContent.
       * @property {string} tooltip - Text to be set as the menu button's tooltip.
       * Requires a `<vaadin-tooltip slot="tooltip">` element to be added inside the `<vaadin-menu-bar>`.
       * @property {union: string | object} component - The component to represent the button content.
       * Either a tagName or an element instance. Defaults to "vaadin-menu-bar-item".
       * @property {boolean} disabled - If true, the button is disabled and cannot be activated.
       * @property {union: string | string[]} theme - Theme(s) to be set as the theme attribute of the button, overriding any theme set on the menu bar.
       * @property {SubMenuItem[]} children - Array of submenu items.
       */
      /**
       * @typedef SubMenuItem
       * @type {object}
       * @property {string} text - Text to be set as the menu item component's textContent.
       * @property {union: string | object} component - The component to represent the item.
       * Either a tagName or an element instance. Defaults to "vaadin-menu-bar-item".
       * @property {boolean} disabled - If true, the item is disabled and cannot be selected.
       * @property {boolean} checked - If true, the item shows a checkmark next to it.
       * @property {SubMenuItem[]} children - Array of child submenu items.
       */
      /**
       * Defines a hierarchical structure, where root level items represent menu bar buttons,
       * and `children` property configures a submenu with items to be opened below
       * the button on click, Enter, Space, Up and Down arrow keys.
       *
       * #### Example
       *
       * ```js
       * menubar.items = [
       *   {
       *     text: 'File',
       *     className: 'file',
       *     children: [
       *       {text: 'Open', className: 'file open'}
       *       {text: 'Auto Save', checked: true},
       *     ]
       *   },
       *   {component: 'hr'},
       *   {
       *     text: 'Edit',
       *     children: [
       *       {text: 'Undo', disabled: true},
       *       {text: 'Redo'}
       *     ]
       *   },
       *   {text: 'Help'}
       * ];
       * ```
       *
       * @type {!Array<!MenuBarItem>}
       */
      items: {
        type: Array,
        value: () => []
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * To update individual properties, extend the existing i18n object like so:
       * ```
       * menuBar.i18n = {
       *   ...menuBar.i18n,
       *   moreOptions: 'More options'
       * }
       * ```
       *
       * The object has the following JSON structure and default values:
       * ```
       * {
       *   moreOptions: 'More options'
       * }
       * ```
       *
       * @type {!MenuBarI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            moreOptions: "More options"
          };
        }
      },
      /**
       * A space-delimited list of CSS class names
       * to set on each sub-menu overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * If true, the submenu will open on hover (mouseover) instead of click.
       * @attr {boolean} open-on-hover
       */
      openOnHover: {
        type: Boolean
      },
      /**
       * @type {boolean}
       * @protected
       */
      _hasOverflow: {
        type: Boolean,
        value: false
      },
      /** @protected */
      _overflow: {
        type: Object
      },
      /** @protected */
      _container: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "_themeChanged(_theme, _overflow, _container)",
      "__hasOverflowChanged(_hasOverflow, _overflow)",
      "__i18nChanged(i18n, _overflow)",
      "_menuItemsChanged(items, _overflow, _container)"
    ];
  }
  constructor() {
    super();
    this.__boundOnContextMenuKeydown = this.__onContextMenuKeydown.bind(this);
  }
  /**
   * Override getter from `KeyboardDirectionMixin`
   * to use expanded button for arrow navigation
   * when the sub-menu is opened and has focus.
   *
   * @return {Element | null}
   * @protected
   * @override
   */
  get focused() {
    return (this._getItems() || []).find(isElementFocused) || this._expandedButton;
  }
  /**
   * Override getter from `KeyboardDirectionMixin`.
   *
   * @return {boolean}
   * @protected
   * @override
   */
  get _vertical() {
    return false;
  }
  /**
   * Override getter from `ResizeMixin` to observe parent.
   *
   * @protected
   * @override
   */
  get _observeParent() {
    return true;
  }
  /**
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _buttons() {
    return Array.from(this.querySelectorAll("vaadin-menu-bar-button"));
  }
  /** @private */
  get _subMenu() {
    return this.shadowRoot.querySelector("vaadin-menu-bar-submenu");
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menubar");
    this._overflowController = new SlotController(this, "overflow", "vaadin-menu-bar-button", {
      initializer: (btn) => {
        btn.setAttribute("hidden", "");
        const dots = document.createElement("div");
        dots.setAttribute("aria-hidden", "true");
        dots.innerHTML = "&centerdot;".repeat(3);
        btn.appendChild(dots);
        this._overflow = btn;
        this._initButtonAttrs(btn);
      }
    });
    this.addController(this._overflowController);
    this.addEventListener("mousedown", () => this._hideTooltip());
    this.addEventListener("mouseleave", () => this._hideTooltip());
    this._subMenu.addEventListener("item-selected", this.__onItemSelected.bind(this));
    this._subMenu.addEventListener("close-all-menus", this.__onEscapeClose.bind(this));
    const overlay = this._subMenu._overlayElement;
    overlay.addEventListener("keydown", this.__boundOnContextMenuKeydown);
    const container = this.shadowRoot.querySelector('[part="container"]');
    container.addEventListener("click", this.__onButtonClick.bind(this));
    container.addEventListener("mouseover", (e) => this._onMouseOver(e));
    this._container = container;
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the list of menu-bar buttons as items.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this._buttons;
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._hideTooltip(true);
  }
  /**
   * Implement callback from `ResizeMixin` to update buttons
   * and detect whether to show or hide the overflow button.
   *
   * @protected
   * @override
   */
  _onResize() {
    this.__detectOverflow();
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to update the `disabled` property for the buttons
   * whenever the property changes on the menu bar.
   *
   * @param {boolean} newValue the new disabled value
   * @param {boolean} oldValue the previous disabled value
   * @override
   * @protected
   */
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (oldValue !== newValue) {
      this.__updateButtonsDisabled(newValue);
    }
  }
  /**
   * A callback for the `_theme` property observer.
   * It propagates the host theme to the buttons and the sub menu.
   *
   * @param {string | null} theme
   * @private
   */
  _themeChanged(theme, overflow, container) {
    if (overflow && container) {
      this._buttons.forEach((btn) => this._setButtonTheme(btn, theme));
      this.__detectOverflow();
    }
    if (theme) {
      this._subMenu.setAttribute("theme", theme);
    } else {
      this._subMenu.removeAttribute("theme");
    }
  }
  /** @private */
  __hasOverflowChanged(hasOverflow, overflow) {
    if (overflow) {
      overflow.toggleAttribute("hidden", !hasOverflow);
    }
  }
  /** @private */
  _menuItemsChanged(items, overflow, container) {
    if (!overflow || !container) {
      return;
    }
    if (items !== this._oldItems) {
      this._oldItems = items;
      this.__renderButtons(items);
    }
    const subMenu = this._subMenu;
    if (subMenu && subMenu.opened) {
      subMenu.close();
    }
  }
  /** @private */
  __i18nChanged(i18n, overflow) {
    if (overflow && i18n && i18n.moreOptions !== void 0) {
      if (i18n.moreOptions) {
        overflow.setAttribute("aria-label", i18n.moreOptions);
      } else {
        overflow.removeAttribute("aria-label");
      }
    }
  }
  /** @private */
  __getOverflowCount(overflow) {
    return overflow.item && overflow.item.children && overflow.item.children.length || 0;
  }
  /** @private */
  __restoreButtons(buttons) {
    buttons.forEach((button2) => {
      button2.disabled = button2.item && button2.item.disabled || this.disabled;
      button2.style.visibility = "";
      button2.style.position = "";
      const item2 = button2.item && button2.item.component;
      if (item2 instanceof HTMLElement && item2.getAttribute("role") === "menuitem") {
        this.__restoreItem(button2, item2);
      }
    });
    this.__updateOverflow([]);
  }
  /** @private */
  __restoreItem(button2, item2) {
    button2.appendChild(item2);
    item2.removeAttribute("role");
    item2.removeAttribute("aria-expanded");
    item2.removeAttribute("aria-haspopup");
    item2.removeAttribute("tabindex");
  }
  /** @private */
  __updateButtonsDisabled(disabled) {
    this._buttons.forEach((btn) => {
      btn.disabled = disabled || btn.item && btn.item.disabled;
    });
  }
  /** @private */
  __updateOverflow(items) {
    this._overflow.item = { children: items };
    this._hasOverflow = items.length > 0;
  }
  /** @private */
  __setOverflowItems(buttons, overflow) {
    const container = this._container;
    if (container.offsetWidth < container.scrollWidth) {
      this._hasOverflow = true;
      const isRTL = this.__isRTL;
      const containerLeft = container.getBoundingClientRect().left;
      let i;
      for (i = buttons.length; i > 0; i--) {
        const btn = buttons[i - 1];
        const btnStyle = getComputedStyle(btn);
        const btnLeft = btn.getBoundingClientRect().left - containerLeft;
        if (!isRTL && btnLeft + btn.offsetWidth < container.offsetWidth - overflow.offsetWidth || isRTL && btnLeft >= overflow.offsetWidth) {
          break;
        }
        btn.disabled = true;
        btn.style.visibility = "hidden";
        btn.style.position = "absolute";
        btn.style.width = btnStyle.width;
      }
      const items = buttons.filter((_, idx) => idx >= i).map((b) => b.item);
      this.__updateOverflow(items);
      const remaining = buttons.slice(0, i);
      if (i > 0 && !remaining.some((btn) => btn.getAttribute("tabindex") === "0")) {
        this._setTabindex(remaining[i - 1], true);
      }
    }
  }
  /** @private */
  __detectOverflow() {
    const overflow = this._overflow;
    const buttons = this._buttons.filter((btn) => btn !== overflow);
    const oldOverflowCount = this.__getOverflowCount(overflow);
    this.__restoreButtons(buttons);
    this.__setOverflowItems(buttons, overflow);
    const newOverflowCount = this.__getOverflowCount(overflow);
    if (oldOverflowCount !== newOverflowCount && this._subMenu.opened) {
      this._subMenu.close();
    }
    const isSingleButton = newOverflowCount === buttons.length || newOverflowCount === 0 && buttons.length === 1;
    this.toggleAttribute("has-single-button", isSingleButton);
  }
  /** @protected */
  _removeButtons() {
    this._buttons.forEach((button2) => {
      if (button2 !== this._overflow) {
        this.removeChild(button2);
      }
    });
  }
  /** @protected */
  _initButton(item2) {
    const button2 = document.createElement("vaadin-menu-bar-button");
    const itemCopy = { ...item2 };
    button2.item = itemCopy;
    if (item2.component) {
      const component = this.__getComponent(itemCopy);
      itemCopy.component = component;
      component.item = itemCopy;
      button2.appendChild(component);
    } else if (item2.text) {
      button2.textContent = item2.text;
    }
    if (item2.className) {
      button2.className = item2.className;
    }
    return button2;
  }
  /** @protected */
  _initButtonAttrs(button2) {
    button2.setAttribute("role", "menuitem");
    if (button2 === this._overflow || button2.item && button2.item.children) {
      button2.setAttribute("aria-haspopup", "true");
      button2.setAttribute("aria-expanded", "false");
    }
  }
  /** @protected */
  _setButtonDisabled(button2, disabled) {
    button2.disabled = disabled;
    button2.setAttribute("tabindex", disabled ? "-1" : "0");
  }
  /** @protected */
  _setButtonTheme(btn, hostTheme) {
    let theme = hostTheme;
    const itemTheme = btn.item && btn.item.theme;
    if (itemTheme != null) {
      theme = Array.isArray(itemTheme) ? itemTheme.join(" ") : itemTheme;
    }
    if (theme) {
      btn.setAttribute("theme", theme);
    } else {
      btn.removeAttribute("theme");
    }
  }
  /** @private */
  __getComponent(item2) {
    const itemComponent = item2.component;
    let component;
    const isElement = itemComponent instanceof HTMLElement;
    if (isElement && itemComponent.localName === "vaadin-menu-bar-item") {
      component = itemComponent;
    } else {
      component = document.createElement("vaadin-menu-bar-item");
      component.appendChild(isElement ? itemComponent : document.createElement(itemComponent));
    }
    if (item2.text) {
      const node = component.firstChild || component;
      node.textContent = item2.text;
    }
    return component;
  }
  /** @private */
  __renderButtons(items = []) {
    this._removeButtons();
    if (items.length === 0) {
      return;
    }
    items.forEach((item2) => {
      const button2 = this._initButton(item2);
      this.insertBefore(button2, this._overflow);
      this._setButtonDisabled(button2, item2.disabled);
      this._initButtonAttrs(button2);
      this._setButtonTheme(button2, this._theme);
    });
    this.__detectOverflow();
  }
  /**
   * @param {HTMLElement} button
   * @protected
   */
  _showTooltip(button2, isHover) {
    const tooltip = this._tooltipController.node;
    if (tooltip && tooltip.isConnected) {
      if (tooltip.generator === void 0) {
        tooltip.generator = ({ item: item2 }) => item2 && item2.tooltip;
      }
      if (!this._subMenu.opened) {
        this._tooltipController.setTarget(button2);
        this._tooltipController.setContext({ item: button2.item });
        tooltip._stateController.open({
          hover: isHover,
          focus: !isHover
        });
      }
    }
  }
  /** @protected */
  _hideTooltip(immediate) {
    const tooltip = this._tooltipController && this._tooltipController.node;
    if (tooltip) {
      tooltip._stateController.close(immediate);
    }
  }
  /** @protected */
  _setExpanded(button2, expanded) {
    button2.toggleAttribute("expanded", expanded);
    button2.toggleAttribute("active", expanded);
    button2.setAttribute("aria-expanded", expanded ? "true" : "false");
  }
  /** @protected */
  _setTabindex(button2, focused) {
    button2.setAttribute("tabindex", focused ? "0" : "-1");
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to close the submenu for the previously focused button
   * and open another one for the newly focused button.
   *
   * @param {Element} item
   * @param {boolean} navigating
   * @protected
   * @override
   */
  _focusItem(item2, navigating) {
    const wasExpanded = navigating && this.focused === this._expandedButton;
    if (wasExpanded) {
      this._close();
    }
    super._focusItem(item2, navigating);
    this._buttons.forEach((btn) => {
      this._setTabindex(btn, btn === item2);
    });
    if (wasExpanded && item2.item && item2.item.children) {
      this.__openSubMenu(item2, true, { keepFocus: true });
    } else if (item2 === this._overflow) {
      this._hideTooltip();
    } else {
      this._showTooltip(item2);
    }
  }
  /** @private */
  _getButtonFromEvent(e) {
    return Array.from(e.composedPath()).find((el) => el.localName === "vaadin-menu-bar-button");
  }
  /**
   * Override method inherited from `FocusMixin`
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    if (focused) {
      const target = this.querySelector('[tabindex="0"]');
      if (target) {
        this._buttons.forEach((btn) => {
          this._setTabindex(btn, btn === target);
          if (btn === target && btn !== this._overflow && isKeyboardActive()) {
            this._showTooltip(btn);
          }
        });
      }
    } else {
      this._hideTooltip();
    }
  }
  /**
   * @param {!KeyboardEvent} event
   * @private
   */
  _onArrowDown(event) {
    event.preventDefault();
    const button2 = this._getButtonFromEvent(event);
    if (button2 === this._expandedButton) {
      this._focusFirstItem();
    } else {
      this.__openSubMenu(button2, true);
    }
  }
  /**
   * @param {!KeyboardEvent} event
   * @private
   */
  _onArrowUp(event) {
    event.preventDefault();
    const button2 = this._getButtonFromEvent(event);
    if (button2 === this._expandedButton) {
      this._focusLastItem();
    } else {
      this.__openSubMenu(button2, true, { focusLast: true });
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`:
   * - to close the sub-menu for expanded button,
   * - to close a tooltip for collapsed button.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (event.composedPath().includes(this._expandedButton)) {
      this._close(true);
    }
    this._hideTooltip(true);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
        this._onArrowDown(event);
        break;
      case "ArrowUp":
        this._onArrowUp(event);
        break;
      default:
        super._onKeyDown(event);
        break;
    }
  }
  /**
   * @param {!MouseEvent} e
   * @protected
   */
  _onMouseOver(e) {
    const button2 = this._getButtonFromEvent(e);
    if (!button2) {
      this._hideTooltip();
    } else if (button2 !== this._expandedButton) {
      const isOpened = this._subMenu.opened;
      if (button2.item.children && (this.openOnHover || isOpened)) {
        this.__openSubMenu(button2, false);
      } else if (isOpened) {
        this._close();
      }
      if (button2 === this._overflow || this.openOnHover && button2.item.children) {
        this._hideTooltip();
      } else {
        this._showTooltip(button2, true);
      }
    }
  }
  /** @private */
  __onContextMenuKeydown(e) {
    const item2 = Array.from(e.composedPath()).find((el) => el._item);
    if (item2) {
      const list = item2.parentNode;
      if (e.keyCode === 38 && item2 === list.items[0]) {
        this._close(true);
      }
      if (e.keyCode === 37 || e.keyCode === 39 && !item2._item.children) {
        e.stopImmediatePropagation();
        this._onKeyDown(e);
      }
    }
  }
  /** @private */
  __fireItemSelected(value) {
    this.dispatchEvent(new CustomEvent("item-selected", { detail: { value } }));
  }
  /** @private */
  __onButtonClick(e) {
    e.stopPropagation();
    const button2 = this._getButtonFromEvent(e);
    if (button2) {
      this.__openSubMenu(button2, button2.__triggeredWithActiveKeys);
    }
  }
  /** @private */
  __openSubMenu(button2, keydown, options = {}) {
    const subMenu = this._subMenu;
    const item2 = button2.item;
    if (subMenu.opened) {
      this._close();
      if (subMenu.listenOn === button2) {
        return;
      }
    }
    const items = item2 && item2.children;
    if (!items || items.length === 0) {
      this.__fireItemSelected(item2);
      return;
    }
    subMenu.items = items;
    subMenu.listenOn = button2;
    const overlay = subMenu._overlayElement;
    overlay.positionTarget = button2;
    overlay.noVerticalOverlap = true;
    this._expandedButton = button2;
    requestAnimationFrame(() => {
      button2.dispatchEvent(
        new CustomEvent("opensubmenu", {
          detail: {
            children: items
          }
        })
      );
      this._hideTooltip(true);
      this._setExpanded(button2, true);
    });
    this.style.pointerEvents = "auto";
    overlay.addEventListener(
      "vaadin-overlay-open",
      () => {
        if (options.focusLast) {
          this._focusLastItem();
        }
        if (options.keepFocus) {
          this._focusItem(this._expandedButton, false);
        }
        if (!keydown) {
          overlay.$.overlay.focus();
        }
        overlay._updatePosition();
      },
      { once: true }
    );
  }
  /** @private */
  _focusFirstItem() {
    const list = this._subMenu._overlayElement.firstElementChild;
    list.focus();
  }
  /** @private */
  _focusLastItem() {
    const list = this._subMenu._overlayElement.firstElementChild;
    const item2 = list.items[list.items.length - 1];
    if (item2) {
      item2.focus();
    }
  }
  /** @private */
  __onItemSelected(e) {
    e.stopPropagation();
    this.__fireItemSelected(e.detail.value);
  }
  /** @private */
  __onEscapeClose() {
    this.__deactivateButton(true);
  }
  /** @private */
  __deactivateButton(restoreFocus) {
    const button2 = this._expandedButton;
    if (button2 && button2.hasAttribute("expanded")) {
      this._setExpanded(button2, false);
      if (restoreFocus) {
        this._focusItem(button2, false);
      }
      this._expandedButton = null;
    }
  }
  /**
   * @param {boolean} restoreFocus
   * @protected
   */
  _close(restoreFocus) {
    this.style.pointerEvents = "";
    this.__deactivateButton(restoreFocus);
    if (this._subMenu.opened) {
      this._subMenu.close();
    }
  }
};

// node_modules/@vaadin/menu-bar/src/vaadin-menu-bar.js
var MenuBar = class extends MenuBarMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='container'] {
          position: relative;
          display: flex;
          width: 100%;
          flex-wrap: nowrap;
          overflow: hidden;
        }
      </style>

      <div part="container">
        <slot></slot>
        <slot name="overflow"></slot>
      </div>
      <vaadin-menu-bar-submenu is-root overlay-class="[[overlayClass]]"></vaadin-menu-bar-submenu>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-menu-bar";
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setManual(true);
    this.addController(this._tooltipController);
  }
  /**
   * Fired when either a submenu item or menu bar button without nested children is clicked.
   *
   * @event item-selected
   * @param {Object} detail
   * @param {Object} detail.value the selected menu bar item
   */
};
defineCustomElement(MenuBar);
/*! Bundled license information:

@vaadin/menu-bar/src/vaadin-menu-bar-button.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/menu-bar/src/vaadin-menu-bar-item.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/menu-bar/src/vaadin-menu-bar-list-box.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/menu-bar/src/vaadin-menu-bar-overlay.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/menu-bar/src/vaadin-menu-bar-submenu.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/menu-bar/src/vaadin-menu-bar-mixin.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/menu-bar/src/vaadin-menu-bar.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=@vaadin_menu-bar_theme_lumo_vaadin-menu-bar__js.js.map
