import {
  MediaQueryController
} from "./chunk-QXKYTJLT.js";
import {
  processTemplates
} from "./chunk-3TOJB423.js";
import {
  ItemMixin
} from "./chunk-SNCYUXU4.js";
import {
  listBox
} from "./chunk-F6RGR3SN.js";
import {
  ListMixin
} from "./chunk-JWDOWCJS.js";
import {
  item
} from "./chunk-ELPZA6KY.js";
import {
  menuOverlay
} from "./chunk-UY4FDBB3.js";
import {
  PositionMixin
} from "./chunk-A2UCFRVY.js";
import {
  OverlayClassMixin
} from "./chunk-BGWLAHRF.js";
import {
  OverlayFocusMixin,
  OverlayMixin,
  overlayStyles
} from "./chunk-HYO4DUYL.js";
import {
  isIOS,
  isTouch
} from "./chunk-DV2EGEEG.js";
import {
  ElementMixin
} from "./chunk-MWSAWSJ3.js";
import {
  addListener,
  gestures,
  prevent,
  register,
  removeListener
} from "./chunk-RPOYDVPH.js";
import {
  getClosestElement
} from "./chunk-GRU2OPCY.js";
import {
  ControllerMixin
} from "./chunk-QGCYTHXO.js";
import {
  ThemableMixin,
  ThemePropertyMixin,
  registerStyles
} from "./chunk-BBNA52CT.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import {
  DirMixin
} from "./chunk-B6NQGUVK.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import {
  PolymerElement
} from "./chunk-4TYUW4EB.js";
import {
  html
} from "./chunk-XB4RSW42.js";

// node_modules/@vaadin/context-menu/theme/lumo/vaadin-context-menu-item-styles.js
var contextMenuItem = css`
  /* :hover needed to workaround https://github.com/vaadin/web-components/issues/3133 */
  :host(:hover) {
    user-select: none;
    -ms-user-select: none;
    -webkit-user-select: none;
  }

  :host([role='menuitem'][menu-item-checked]) [part='checkmark']::before {
    opacity: 1;
  }

  :host([aria-haspopup='true'])::after {
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-xs);
    content: var(--lumo-icons-angle-right);
    color: var(--lumo-tertiary-text-color);
  }

  :host(:not([dir='rtl'])[aria-haspopup='true'])::after {
    margin-right: calc(var(--lumo-space-m) * -1);
    padding-left: var(--lumo-space-m);
  }

  :host([expanded]) {
    background-color: var(--lumo-primary-color-10pct);
  }

  /* RTL styles */
  :host([dir='rtl'][aria-haspopup='true'])::after {
    content: var(--lumo-icons-angle-left);
    margin-left: calc(var(--lumo-space-m) * -1);
    padding-right: var(--lumo-space-m);
  }
`;
registerStyles("vaadin-context-menu-item", [item, contextMenuItem], { moduleId: "lumo-context-menu-item" });

// node_modules/@vaadin/context-menu/theme/lumo/vaadin-context-menu-list-box-styles.js
var contextMenuListBox = css`
  :host {
    --_lumo-list-box-item-selected-icon-display: block;
  }

  /* Normal item */
  [part='items'] ::slotted([role='menuitem']) {
    -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
    cursor: default;
    outline: none;
    border-radius: var(--lumo-border-radius-m);
    padding-left: calc(var(--lumo-border-radius-m) / 4);
    padding-right: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
  }

  /* Hovered item */
  /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
  [part='items'] ::slotted([role='menuitem']:hover:not([disabled])),
  [part='items'] ::slotted([role='menuitem'][expanded]:not([disabled])) {
    background-color: var(--lumo-primary-color-10pct);
  }

  /* RTL styles */
  :host([dir='rtl']) [part='items'] ::slotted([role='menuitem']) {
    padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    padding-right: calc(var(--lumo-border-radius-m) / 4);
  }

  /* Focused item */
  @media (pointer: coarse) {
    [part='items'] ::slotted([role='menuitem']:hover:not([expanded]):not([disabled])) {
      background-color: transparent;
    }
  }
`;
registerStyles("vaadin-context-menu-list-box", [listBox, contextMenuListBox], {
  moduleId: "lumo-context-menu-list-box"
});

// node_modules/@vaadin/context-menu/theme/lumo/vaadin-context-menu-overlay-styles.js
var contextMenuOverlay = css`
  :host([phone]) {
    /* stylelint-disable declaration-block-no-redundant-longhand-properties */
    top: 0 !important;
    right: 0 !important;
    bottom: var(--vaadin-overlay-viewport-bottom) !important;
    left: 0 !important;
    /* stylelint-enable declaration-block-no-redundant-longhand-properties */
    align-items: stretch;
    justify-content: flex-end;
  }

  /* TODO These style overrides should not be needed.
   We should instead offer a way to have non-selectable items inside the context menu. */

  :host {
    --_lumo-list-box-item-selected-icon-display: none;
    --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);
  }

  [part='overlay'] {
    outline: none;
  }
`;
registerStyles("vaadin-context-menu-overlay", [menuOverlay, contextMenuOverlay], {
  moduleId: "lumo-context-menu-overlay"
});

// node_modules/@vaadin/context-menu/src/vaadin-contextmenu-event.js
register({
  name: "vaadin-contextmenu",
  deps: ["touchstart", "touchmove", "touchend", "contextmenu"],
  flow: {
    start: ["touchstart", "contextmenu"],
    end: ["contextmenu"]
  },
  emits: ["vaadin-contextmenu"],
  info: {
    sourceEvent: null
  },
  reset() {
    this.info.sourceEvent = null;
    this._cancelTimer();
    this.info.touchJob = null;
    this.info.touchStartCoords = null;
  },
  _cancelTimer() {
    if (this._timerId) {
      clearTimeout(this._timerId);
      delete this._fired;
    }
  },
  _setSourceEvent(e) {
    this.info.sourceEvent = e;
    const path = e.composedPath();
    this.info.sourceEvent.__composedPath = path;
  },
  touchstart(e) {
    this._setSourceEvent(e);
    this.info.touchStartCoords = {
      x: e.changedTouches[0].clientX,
      y: e.changedTouches[0].clientY
    };
    const t = e.composedPath()[0] || e.target;
    this._timerId = setTimeout(() => {
      const ct = e.changedTouches[0];
      if (!e.shiftKey) {
        if (isIOS) {
          this._fired = true;
          this.fire(t, ct.clientX, ct.clientY);
        }
        prevent("tap");
      }
    }, 500);
  },
  touchmove(e) {
    const moveThreshold = 15;
    const touchStartCoords = this.info.touchStartCoords;
    if (Math.abs(touchStartCoords.x - e.changedTouches[0].clientX) > moveThreshold || Math.abs(touchStartCoords.y - e.changedTouches[0].clientY) > moveThreshold) {
      this._cancelTimer();
    }
  },
  touchend(e) {
    if (this._fired) {
      e.preventDefault();
    }
    this._cancelTimer();
  },
  contextmenu(e) {
    if (!e.shiftKey) {
      this._setSourceEvent(e);
      this.fire(e.target, e.clientX, e.clientY);
      prevent("tap");
    }
  },
  fire(target, x, y) {
    const sourceEvent = this.info.sourceEvent;
    const ev = new Event("vaadin-contextmenu", { bubbles: true, cancelable: true, composed: true });
    ev.detail = { x, y, sourceEvent };
    target.dispatchEvent(ev);
    if (ev.defaultPrevented && sourceEvent && sourceEvent.preventDefault) {
      sourceEvent.preventDefault();
    }
  }
});

// node_modules/@vaadin/context-menu/src/vaadin-context-menu-item.js
var ContextMenuItem = class extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-context-menu-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menuitem");
  }
};
defineCustomElement(ContextMenuItem);

// node_modules/@vaadin/context-menu/src/vaadin-context-menu-list-box.js
var ContextMenuListBox = class extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-context-menu-list-box";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
};
defineCustomElement(ContextMenuListBox);

// node_modules/@vaadin/context-menu/src/vaadin-menu-overlay-mixin.js
var MenuOverlayMixin = (superClass) => class MenuOverlayMixin extends OverlayFocusMixin(PositionMixin(superClass)) {
  static get properties() {
    return {
      /**
       * @protected
       */
      parentOverlay: {
        type: Object,
        readOnly: true
      },
      /**
       * @protected
       */
      _theme: {
        type: String,
        readOnly: true,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_themeChanged(_theme)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.restoreFocusOnClose = true;
    this.addEventListener("keydown", (e) => {
      if (!e.defaultPrevented && e.composedPath()[0] === this.$.overlay && [38, 40].indexOf(e.keyCode) > -1) {
        const child = this.getFirstChild();
        if (child && Array.isArray(child.items) && child.items.length) {
          e.preventDefault();
          if (e.keyCode === 38) {
            child.items[child.items.length - 1].focus();
          } else {
            child.focus();
          }
        }
      }
    });
  }
  /**
   * Returns the first element in the overlay content.
   *
   * @returns {HTMLElement}
   */
  getFirstChild() {
    return this.querySelector(":not(style):not(slot)");
  }
  /** @private */
  _themeChanged() {
    this.close();
  }
  /**
   * Returns the adjusted boundaries of the overlay.
   *
   * @returns {object}
   */
  getBoundaries() {
    const overlayRect = this.getBoundingClientRect();
    const contentRect = this.$.overlay.getBoundingClientRect();
    let yMax = overlayRect.bottom - contentRect.height;
    const parent = this.parentOverlay;
    if (parent && parent.hasAttribute("bottom-aligned")) {
      const parentStyle = getComputedStyle(parent);
      yMax = yMax - parseFloat(parentStyle.bottom) - parseFloat(parentStyle.height);
    }
    return {
      xMax: overlayRect.right - contentRect.width,
      xMin: overlayRect.left + contentRect.width,
      yMax
    };
  }
  /**
   * @protected
   * @override
   */
  _updatePosition() {
    super._updatePosition();
    if (this.positionTarget && this.parentOverlay) {
      const content = this.$.content;
      const style = getComputedStyle(content);
      const isLeftAligned = !!this.style.left;
      if (isLeftAligned) {
        this.style.left = `${parseFloat(this.style.left) + parseFloat(style.paddingLeft)}px`;
      } else {
        this.style.right = `${parseFloat(this.style.right) + parseFloat(style.paddingRight)}px`;
      }
      const isBottomAligned = !!this.style.bottom;
      if (isBottomAligned) {
        this.style.bottom = `${parseFloat(this.style.bottom) - parseFloat(style.paddingBottom)}px`;
      } else {
        this.style.top = `${parseFloat(this.style.top) - parseFloat(style.paddingTop)}px`;
      }
    }
  }
  /**
   * Override method inherited from `OverlayFocusMixin` to disable
   * focus restoration on sub-menu overlay close. Focus should
   * be only restored when the root menu closes.
   *
   * @protected
   * @override
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    if (this.parentOverlay) {
      return false;
    }
    return super._shouldRestoreFocus();
  }
  /**
   * Override method inherited from `OverlayFocusMixin` to return
   * true if the overlay contains the given node, including
   * those within descendant menu overlays.
   *
   * @protected
   * @override
   * @param {Node} node
   * @return {boolean}
   */
  _deepContains(node) {
    let overlay = getClosestElement(this.localName, node);
    while (overlay) {
      if (overlay === this) {
        return true;
      }
      overlay = overlay.parentOverlay;
    }
    return false;
  }
};

// node_modules/@vaadin/context-menu/src/vaadin-menu-overlay-styles.js
var styles = css`
  :host {
    align-items: flex-start;
    justify-content: flex-start;
  }

  :host([right-aligned]),
  :host([end-aligned]) {
    align-items: flex-end;
  }

  :host([bottom-aligned]) {
    justify-content: flex-end;
  }

  [part='overlay'] {
    background-color: #fff;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid !important;
    }
  }
`;

// node_modules/@vaadin/context-menu/src/vaadin-context-menu-overlay.js
registerStyles("vaadin-context-menu-overlay", [overlayStyles, styles], {
  moduleId: "vaadin-context-menu-overlay-styles"
});
var ContextMenuOverlay = class extends MenuOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-context-menu-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
defineCustomElement(ContextMenuOverlay);

// node_modules/@vaadin/context-menu/src/vaadin-contextmenu-items-mixin.js
var ItemsMixin = (superClass) => class ItemsMixin extends superClass {
  static get properties() {
    return {
      /**
       * @typedef ContextMenuItem
       * @type {object}
       * @property {string} text - Text to be set as the menu item component's textContent
       * @property {union: string | object} component - The component to represent the item.
       * Either a tagName or an element instance. Defaults to "vaadin-context-menu-item".
       * @property {boolean} disabled - If true, the item is disabled and cannot be selected
       * @property {boolean} checked - If true, the item shows a checkmark next to it
       * @property {boolean} keepOpen - If true, the menu will not be closed on item selection
       * @property {string} className - A space-delimited list of CSS class names to be set on the menu item component.
       * @property {union: string | string[]} theme - If set, sets the given theme(s) as an attribute to the menu item component, overriding any theme set on the context menu.
       * @property {MenuItem[]} children - Array of child menu items
       */
      /**
       * Defines a (hierarchical) menu structure for the component.
       * If a menu item has a non-empty `children` set, a sub-menu with the child items is opened
       * next to the parent menu on mouseover, tap or a right arrow keypress.
       *
       * The items API can't be used together with a renderer!
       *
       * #### Example
       *
       * ```javascript
       * contextMenu.items = [
       *   { text: 'Menu Item 1', theme: 'primary', className: 'first', children:
       *     [
       *       { text: 'Menu Item 1-1', checked: true, keepOpen: true },
       *       { text: 'Menu Item 1-2' }
       *     ]
       *   },
       *   { component: 'hr' },
       *   { text: 'Menu Item 2', children:
       *     [
       *       { text: 'Menu Item 2-1' },
       *       { text: 'Menu Item 2-2', disabled: true }
       *     ]
       *   },
       *   { text: 'Menu Item 3', disabled: true, className: 'last' }
       * ];
       * ```
       *
       * @type {!Array<!ContextMenuItem> | undefined}
       *
       *
       * ### Styling
       *
       * The `<vaadin-context-menu-item>` sub-menu elements have the following additional state attributes on top of
       * the built-in `<vaadin-item>` state attributes (see `<vaadin-item>` documentation for full listing).
       *
       * Part name | Attribute | Description
       * ----------------|----------------|----------------
       * `:host` | expanded | Expanded parent item
       */
      items: {
        type: Array,
        sync: true
      }
    };
  }
  constructor() {
    super();
    this.__itemsOutsideClickListener = (e) => {
      if (!e.composedPath().some((el) => el.localName === `${this._tagNamePrefix}-overlay`)) {
        this.dispatchEvent(new CustomEvent("items-outside-click"));
      }
    };
    this.addEventListener("items-outside-click", () => {
      this.items && this.close();
    });
  }
  /**
   * Tag name prefix used by overlay, list-box and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-context-menu";
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.documentElement.addEventListener("click", this.__itemsOutsideClickListener);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.documentElement.removeEventListener("click", this.__itemsOutsideClickListener);
  }
  /** @protected */
  __forwardFocus() {
    const overlay = this._overlayElement;
    const child = overlay.getFirstChild();
    if (overlay.parentOverlay) {
      const parent = overlay.parentOverlay.querySelector("[expanded]");
      if (parent && parent.hasAttribute("focused") && child) {
        child.focus();
      } else {
        overlay.$.overlay.focus();
      }
    } else if (child) {
      child.focus();
    }
  }
  /** @private */
  __openSubMenu(subMenu, itemElement, overlayClass) {
    subMenu.items = itemElement._item.children;
    subMenu.listenOn = itemElement;
    subMenu.overlayClass = overlayClass;
    const parent = this._overlayElement;
    const subMenuOverlay = subMenu._overlayElement;
    subMenuOverlay.positionTarget = itemElement;
    subMenuOverlay.noHorizontalOverlap = true;
    subMenuOverlay._setParentOverlay(parent);
    if (parent.hasAttribute("theme")) {
      subMenu.setAttribute("theme", parent.getAttribute("theme"));
    } else {
      subMenu.removeAttribute("theme");
    }
    const content = subMenuOverlay.$.content;
    content.style.minWidth = "";
    itemElement.dispatchEvent(
      new CustomEvent("opensubmenu", {
        detail: {
          children: itemElement._item.children
        }
      })
    );
  }
  /**
   * @param {!ContextMenuItem} item
   * @return {HTMLElement}
   * @private
   */
  __createComponent(item2) {
    let component;
    if (item2.component instanceof HTMLElement) {
      component = item2.component;
    } else {
      component = document.createElement(item2.component || `${this._tagNamePrefix}-item`);
    }
    if (component._hasVaadinItemMixin) {
      component.setAttribute("role", "menuitem");
      component.tabIndex = -1;
    }
    if (component.localName === "hr") {
      component.setAttribute("role", "separator");
    } else {
      component.setAttribute("aria-haspopup", "false");
    }
    this._setMenuItemTheme(component, item2, this._theme);
    component._item = item2;
    if (item2.text) {
      component.textContent = item2.text;
    }
    if (item2.className) {
      component.setAttribute("class", item2.className);
    }
    this.__toggleMenuComponentAttribute(component, "menu-item-checked", item2.checked);
    this.__toggleMenuComponentAttribute(component, "disabled", item2.disabled);
    if (item2.children && item2.children.length) {
      this.__updateExpanded(component, false);
      component.setAttribute("aria-haspopup", "true");
    }
    return component;
  }
  /** @private */
  __initListBox() {
    const listBox2 = document.createElement(`${this._tagNamePrefix}-list-box`);
    if (this._theme) {
      listBox2.setAttribute("theme", this._theme);
    }
    listBox2.addEventListener("selected-changed", (event) => {
      const { value } = event.detail;
      if (typeof value === "number") {
        const item2 = listBox2.items[value]._item;
        listBox2.selected = null;
        if (!item2.children) {
          this.dispatchEvent(new CustomEvent("item-selected", { detail: { value: item2 } }));
        }
      }
    });
    return listBox2;
  }
  /** @private */
  __initOverlay() {
    const overlay = this._overlayElement;
    overlay.$.backdrop.addEventListener("click", () => {
      this.close();
    });
    overlay.addEventListener(isTouch ? "click" : "mouseover", (event) => {
      this.__showSubMenu(event);
    });
    overlay.addEventListener("keydown", (event) => {
      const { key } = event;
      const isRTL = this.__isRTL;
      const isArrowRight = key === "ArrowRight";
      const isArrowLeft = key === "ArrowLeft";
      if (!isRTL && isArrowRight || isRTL && isArrowLeft || key === "Enter" || key === " ") {
        this.__showSubMenu(event);
      } else if (!isRTL && isArrowLeft || isRTL && isArrowRight || key === "Escape") {
        if (key === "Escape") {
          event.stopPropagation();
        }
        this.close();
        this.listenOn.focus();
      } else if (key === "Tab") {
        this.dispatchEvent(new CustomEvent("close-all-menus"));
      }
    });
  }
  /** @private */
  __initSubMenu() {
    const subMenu = document.createElement(this.constructor.is);
    subMenu._modeless = true;
    subMenu.openOn = "opensubmenu";
    subMenu.setAttribute("hidden", "");
    this.addEventListener("opened-changed", (event) => {
      if (!event.detail.value) {
        this._subMenu.close();
      }
    });
    subMenu.addEventListener("close-all-menus", () => {
      this.dispatchEvent(new CustomEvent("close-all-menus"));
    });
    subMenu.addEventListener("item-selected", (event) => {
      const { detail } = event;
      this.dispatchEvent(new CustomEvent("item-selected", { detail }));
    });
    this.addEventListener("close-all-menus", () => {
      this._overlayElement.close();
    });
    this.addEventListener("item-selected", (e) => {
      const menu = e.target;
      const selectedItem = e.detail.value;
      const index = menu.items.indexOf(selectedItem);
      if (!!selectedItem.keepOpen && index > -1) {
        menu._overlayElement.requestContentUpdate();
        menu._listBox._observer.flush();
        const newItem = menu._listBox.children[index];
        newItem.focus();
      } else if (!selectedItem.keepOpen) {
        this.close();
      }
    });
    subMenu.addEventListener("opened-changed", (event) => {
      if (!event.detail.value) {
        const expandedItem = this._listBox.querySelector("[expanded]");
        if (expandedItem) {
          this.__updateExpanded(expandedItem, false);
        }
      }
    });
    return subMenu;
  }
  /** @private */
  __showSubMenu(event, item2 = event.composedPath().find((node) => node.localName === `${this._tagNamePrefix}-item`)) {
    if (!this.__openListenerActive) {
      return;
    }
    if (this._overlayElement.hasAttribute("opening")) {
      requestAnimationFrame(() => {
        this.__showSubMenu(event, item2);
      });
      return;
    }
    const subMenu = this._subMenu;
    if (item2) {
      const { children } = item2._item;
      if (subMenu.items !== children) {
        subMenu.close();
      }
      if (!this.opened) {
        return;
      }
      if (children && children.length) {
        this.__updateExpanded(item2, true);
        const { overlayClass } = this;
        this.__openSubMenu(subMenu, item2, overlayClass);
      } else {
        subMenu.listenOn.focus();
      }
    }
  }
  /**
   * @param {!HTMLElement} root
   * @param {!ContextMenu} menu
   * @param {!ContextMenuRendererContext} context
   * @protected
   */
  __itemsRenderer(root, menu, { detail }) {
    this.__initMenu(root, menu);
    const subMenu = root.querySelector(this.constructor.is);
    subMenu.closeOn = menu.closeOn;
    const listBox2 = root.querySelector(`${this._tagNamePrefix}-list-box`);
    listBox2.innerHTML = "";
    [...detail.children || menu.items].forEach((item2) => {
      const component = this.__createComponent(item2);
      listBox2.appendChild(component);
    });
  }
  /** @protected */
  _setMenuItemTheme(component, item2, hostTheme) {
    let theme = component.getAttribute("theme") || hostTheme;
    if (item2.theme != null) {
      theme = Array.isArray(item2.theme) ? item2.theme.join(" ") : item2.theme;
    }
    this.__updateTheme(component, theme);
  }
  /** @private */
  __toggleMenuComponentAttribute(component, attribute, on) {
    if (on) {
      component.setAttribute(attribute, "");
      component[`__has-${attribute}`] = true;
    } else if (component[`__has-${attribute}`]) {
      component.removeAttribute(attribute);
      component[`__has-${attribute}`] = false;
    }
  }
  /** @private */
  __initMenu(root, menu) {
    if (!root.firstElementChild) {
      this.__initOverlay();
      const listBox2 = this.__initListBox();
      this._listBox = listBox2;
      root.appendChild(listBox2);
      const subMenu = this.__initSubMenu();
      this._subMenu = subMenu;
      root.appendChild(subMenu);
      requestAnimationFrame(() => {
        this.__openListenerActive = true;
      });
    } else {
      this.__updateTheme(this._listBox, this._theme);
    }
  }
  /** @private */
  __updateExpanded(component, expanded) {
    component.setAttribute("aria-expanded", expanded.toString());
    component.toggleAttribute("expanded", expanded);
  }
  /** @private */
  __updateTheme(component, theme) {
    if (theme) {
      component.setAttribute("theme", theme);
    } else {
      component.removeAttribute("theme");
    }
  }
};

// node_modules/@vaadin/context-menu/src/vaadin-context-menu-mixin.js
var ContextMenuMixin = (superClass) => class ContextMenuMixinClass extends ItemsMixin(superClass) {
  static get properties() {
    return {
      /**
       * CSS selector that can be used to target any child element
       * of the context menu to listen for `openOn` events.
       */
      selector: {
        type: String
      },
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },
      /**
       * Event name to listen for opening the context menu.
       * @attr {string} open-on
       * @type {string}
       */
      openOn: {
        type: String,
        value: "vaadin-contextmenu",
        sync: true
      },
      /**
       * The target element that's listened to for context menu opening events.
       * By default the vaadin-context-menu listens to the target's `vaadin-contextmenu`
       * events.
       * @type {!HTMLElement}
       * @default self
       */
      listenOn: {
        type: Object,
        sync: true,
        value() {
          return this;
        }
      },
      /**
       * Event name to listen for closing the context menu.
       * @attr {string} close-on
       * @type {string}
       */
      closeOn: {
        type: String,
        value: "click",
        observer: "_closeOnChanged",
        sync: true
      },
      /**
       * Custom function for rendering the content of the menu overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `contextMenu` The reference to the `<vaadin-context-menu>` element.
       * - `context` The object with the menu context, contains:
       *   - `context.target`  the target of the menu opening event,
       *   - `context.detail` the menu opening event detail.
       * @type {ContextMenuRenderer | undefined}
       */
      renderer: {
        type: Function,
        sync: true
      },
      /**
       * When true, the menu overlay is modeless.
       * @protected
       */
      _modeless: {
        type: Boolean,
        sync: true
      },
      /** @private */
      _context: {
        type: Object,
        sync: true
      },
      /** @private */
      _phone: {
        type: Boolean
      },
      /** @private */
      _touch: {
        type: Boolean,
        value: isTouch
      },
      /** @private */
      _wide: {
        type: Boolean
      },
      /** @private */
      _wideMediaQuery: {
        type: String,
        value: "(min-device-width: 750px)"
      }
    };
  }
  static get observers() {
    return [
      "_openedChanged(opened)",
      "_targetOrOpenOnChanged(listenOn, openOn)",
      "_rendererChanged(renderer, items)",
      "_touchOrWideChanged(_touch, _wide)",
      "_overlayContextChanged(_overlayElement, _context)",
      "_overlayModelessChanged(_overlayElement, _modeless)",
      "_overlayPhoneChanged(_overlayElement, _phone)",
      "_overlayThemeChanged(_overlayElement, _theme)"
    ];
  }
  constructor() {
    super();
    this._createOverlay();
    this._boundOpen = this.open.bind(this);
    this._boundClose = this.close.bind(this);
    this._boundPreventDefault = this._preventDefault.bind(this);
    this._boundOnGlobalContextMenu = this._onGlobalContextMenu.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__boundOnScroll = this.__onScroll.bind(this);
    window.addEventListener("scroll", this.__boundOnScroll, true);
    if (this.__restoreOpened) {
      this._setOpened(true);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("scroll", this.__boundOnScroll, true);
    this.__restoreOpened = this.opened;
    this.close();
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new MediaQueryController(this._wideMediaQuery, (matches) => {
        this._wide = matches;
      })
    );
  }
  /** @private */
  _createOverlay() {
    const overlay = document.createElement(`${this._tagNamePrefix}-overlay`);
    overlay.owner = this;
    overlay.addEventListener("opened-changed", (e) => {
      this._onOverlayOpened(e);
    });
    overlay.addEventListener("vaadin-overlay-open", (e) => {
      this._onVaadinOverlayOpen(e);
    });
    this._overlayElement = overlay;
  }
  /**
   * Runs before overlay is fully rendered
   * @private
   */
  _onOverlayOpened(e) {
    this._setOpened(e.detail.value);
    this.__alignOverlayPosition();
  }
  /**
   * Runs after overlay is fully rendered
   * @private
   */
  _onVaadinOverlayOpen() {
    this.__alignOverlayPosition();
    this._overlayElement.style.opacity = "";
    this.__forwardFocus();
  }
  /** @private */
  _overlayContextChanged(overlay, context) {
    if (overlay) {
      overlay.model = context;
    }
  }
  /** @private */
  _overlayModelessChanged(overlay, modeless) {
    if (overlay) {
      overlay.modeless = modeless;
    }
  }
  /** @private */
  _overlayPhoneChanged(overlay, phone) {
    if (overlay) {
      overlay.toggleAttribute("phone", phone);
      overlay.withBackdrop = phone;
    }
  }
  /** @private */
  _overlayThemeChanged(overlay, theme) {
    if (overlay) {
      if (theme) {
        overlay.setAttribute("theme", theme);
      } else {
        overlay.removeAttribute("theme");
      }
    }
  }
  /** @private */
  _targetOrOpenOnChanged(listenOn, openOn) {
    if (this._oldListenOn && this._oldOpenOn) {
      this._unlisten(this._oldListenOn, this._oldOpenOn, this._boundOpen);
      this._oldListenOn.style.webkitTouchCallout = "";
      this._oldListenOn.style.webkitUserSelect = "";
      this._oldListenOn.style.userSelect = "";
      this._oldListenOn = null;
      this._oldOpenOn = null;
    }
    if (listenOn && openOn) {
      this._listen(listenOn, openOn, this._boundOpen);
      this._oldListenOn = listenOn;
      this._oldOpenOn = openOn;
    }
  }
  /** @private */
  _touchOrWideChanged(touch, wide) {
    this._phone = !wide && touch;
  }
  /** @private */
  _setListenOnUserSelect(value) {
    this.listenOn.style.webkitTouchCallout = value;
    this.listenOn.style.webkitUserSelect = value;
    this.listenOn.style.userSelect = value;
    document.getSelection().removeAllRanges();
  }
  /** @private */
  _closeOnChanged(closeOn, oldCloseOn) {
    const evtOverlay = "vaadin-overlay-outside-click";
    const overlay = this._overlayElement;
    if (oldCloseOn) {
      this._unlisten(overlay, oldCloseOn, this._boundClose);
    }
    if (closeOn) {
      this._listen(overlay, closeOn, this._boundClose);
      overlay.removeEventListener(evtOverlay, this._boundPreventDefault);
    } else {
      overlay.addEventListener(evtOverlay, this._boundPreventDefault);
    }
  }
  /** @private */
  _preventDefault(e) {
    e.preventDefault();
  }
  /** @private */
  _openedChanged(opened) {
    if (opened) {
      document.documentElement.addEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
      this._setListenOnUserSelect("none");
    } else {
      document.documentElement.removeEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
      this._setListenOnUserSelect("");
    }
    this._overlayElement.opened = opened;
  }
  /**
   * Requests an update for the content of the menu overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._overlayElement || !this.renderer) {
      return;
    }
    this._overlayElement.requestContentUpdate();
  }
  /** @private */
  _rendererChanged(renderer, items) {
    if (items) {
      if (renderer) {
        throw new Error("The items API cannot be used together with a renderer");
      }
      if (this.closeOn === "click") {
        this.closeOn = "";
      }
      renderer = this.__itemsRenderer;
    }
    this._overlayElement.renderer = renderer;
  }
  /**
   * Closes the overlay.
   */
  close() {
    this._setOpened(false);
  }
  /** @private */
  _contextTarget(e) {
    if (this.selector) {
      const targets = this.listenOn.querySelectorAll(this.selector);
      return Array.prototype.filter.call(targets, (el) => {
        return e.composedPath().indexOf(el) > -1;
      })[0];
    }
    return e.target;
  }
  /**
   * Opens the overlay.
   * @param {!Event | undefined} e used as the context for the menu. Overlay coordinates are taken from this event.
   */
  open(e) {
    if (e && !this.opened) {
      this._context = {
        detail: e.detail,
        target: this._contextTarget(e)
      };
      if (this._context.target) {
        e.preventDefault();
        e.stopPropagation();
        this.__x = this._getEventCoordinate(e, "x");
        this.__pageXOffset = window.pageXOffset;
        this.__y = this._getEventCoordinate(e, "y");
        this.__pageYOffset = window.pageYOffset;
        this._overlayElement.style.opacity = "0";
        this._setOpened(true);
      }
    }
  }
  /** @private */
  __onScroll() {
    if (!this.opened) {
      return;
    }
    const yDiff = window.pageYOffset - this.__pageYOffset;
    const xDiff = window.pageXOffset - this.__pageXOffset;
    this.__adjustPosition("left", -xDiff);
    this.__adjustPosition("right", xDiff);
    this.__adjustPosition("top", -yDiff);
    this.__adjustPosition("bottom", yDiff);
    this.__pageYOffset += yDiff;
    this.__pageXOffset += xDiff;
  }
  /** @private */
  __adjustPosition(coord, diff) {
    const overlay = this._overlayElement;
    const style = overlay.style;
    style[coord] = `${(parseInt(style[coord]) || 0) + diff}px`;
  }
  /** @private */
  __alignOverlayPosition() {
    const overlay = this._overlayElement;
    if (overlay.positionTarget) {
      return;
    }
    const style = overlay.style;
    ["top", "right", "bottom", "left"].forEach((prop) => style.removeProperty(prop));
    ["right-aligned", "end-aligned", "bottom-aligned"].forEach((attr) => overlay.removeAttribute(attr));
    const { xMax, xMin, yMax } = overlay.getBoundaries();
    const x = this.__x;
    const y = this.__y;
    const wdthVport = document.documentElement.clientWidth;
    const hghtVport = document.documentElement.clientHeight;
    if (!this.__isRTL) {
      if (x < wdthVport / 2 || x < xMax) {
        style.left = `${x}px`;
      } else {
        style.right = `${Math.max(0, wdthVport - x)}px`;
        this._setEndAligned(overlay);
      }
    } else if (x > wdthVport / 2 || x > xMin) {
      style.right = `${Math.max(0, wdthVport - x)}px`;
    } else {
      style.left = `${x}px`;
      this._setEndAligned(overlay);
    }
    if (y < hghtVport / 2 || y < yMax) {
      style.top = `${y}px`;
    } else {
      style.bottom = `${Math.max(0, hghtVport - y)}px`;
      overlay.setAttribute("bottom-aligned", "");
    }
  }
  /** @private */
  _setEndAligned(element) {
    element.setAttribute("end-aligned", "");
    if (!this.__isRTL) {
      element.setAttribute("right-aligned", "");
    }
  }
  /** @private */
  _getEventCoordinate(event, coord) {
    if (event.detail instanceof Object) {
      if (event.detail[coord]) {
        return event.detail[coord];
      } else if (event.detail.sourceEvent) {
        return this._getEventCoordinate(event.detail.sourceEvent, coord);
      }
    } else {
      const prop = `client${coord.toUpperCase()}`;
      const position = event.changedTouches ? event.changedTouches[0][prop] : event[prop];
      if (position === 0) {
        const rect = event.target.getBoundingClientRect();
        return coord === "x" ? rect.left : rect.top + rect.height;
      }
      return position;
    }
  }
  /** @private */
  _listen(node, evType, handler) {
    if (gestures[evType]) {
      addListener(node, evType, handler);
    } else {
      node.addEventListener(evType, handler);
    }
  }
  /** @private */
  _unlisten(node, evType, handler) {
    if (gestures[evType]) {
      removeListener(node, evType, handler);
    } else {
      node.removeEventListener(evType, handler);
    }
  }
  /** @private */
  _onGlobalContextMenu(e) {
    if (!e.shiftKey) {
      e.preventDefault();
      this.close();
    }
  }
};

// node_modules/@vaadin/context-menu/src/vaadin-context-menu.js
var ContextMenu = class extends ContextMenuMixin(
  OverlayClassMixin(ControllerMixin(ElementMixin(ThemePropertyMixin(PolymerElement))))
) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>

      <slot id="slot"></slot>
    `;
  }
  static get is() {
    return "vaadin-context-menu";
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /**
   * @param {DocumentFragment} dom
   * @return {null}
   * @protected
   * @override
   */
  _attachDom(dom) {
    const root = this.attachShadow({ mode: "open" });
    root.appendChild(dom);
    root.appendChild(this._overlayElement);
    return root;
  }
  /**
   * Fired when an item is selected when the context menu is populated using the `items` API.
   *
   * @event item-selected
   * @param {Object} detail
   * @param {Object} detail.value the selected menu item
   */
};
defineCustomElement(ContextMenu);

export {
  contextMenuItem,
  contextMenuListBox,
  contextMenuOverlay,
  MenuOverlayMixin,
  styles,
  ContextMenu
};
/*! Bundled license information:

@vaadin/context-menu/src/vaadin-contextmenu-event.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/context-menu/src/vaadin-context-menu-item.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/context-menu/src/vaadin-context-menu-list-box.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/context-menu/src/vaadin-menu-overlay-mixin.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/context-menu/src/vaadin-menu-overlay-styles.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/context-menu/src/vaadin-context-menu-overlay.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/context-menu/src/vaadin-contextmenu-items-mixin.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/context-menu/src/vaadin-context-menu-mixin.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/context-menu/src/vaadin-context-menu.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=chunk-5DAXN5QZ.js.map
