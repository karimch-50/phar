{
  "version": 3,
  "sources": ["../../@vaadin/date-picker/src/vaadin-date-picker-helper.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2016 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Get ISO 8601 week number for the given date.\n *\n * @param {!Date} Date object\n * @return {number} Week number\n */\nexport function getISOWeekNumber(date) {\n  // Ported from Vaadin Framework method com.vaadin.client.DateTimeService.getISOWeekNumber(date)\n  let dayOfWeek = date.getDay(); // 0 == sunday\n\n  // ISO 8601 use weeks that start on monday so we use\n  // mon=1,tue=2,...sun=7;\n  if (dayOfWeek === 0) {\n    dayOfWeek = 7;\n  }\n  // Find nearest thursday (defines the week in ISO 8601). The week number\n  // for the nearest thursday is the same as for the target date.\n  const nearestThursdayDiff = 4 - dayOfWeek; // 4 is thursday\n  const nearestThursday = new Date(date.getTime() + nearestThursdayDiff * 24 * 3600 * 1000);\n\n  const firstOfJanuary = new Date(0, 0);\n  firstOfJanuary.setFullYear(nearestThursday.getFullYear());\n\n  const timeDiff = nearestThursday.getTime() - firstOfJanuary.getTime();\n\n  // Rounding the result, as the division doesn't result in an integer\n  // when the given date is inside daylight saving time period.\n  const daysSinceFirstOfJanuary = Math.round(timeDiff / (24 * 3600 * 1000));\n\n  return Math.floor(daysSinceFirstOfJanuary / 7 + 1);\n}\n\n/**\n * Check if two dates are equal.\n *\n * @param {Date} date1\n * @param {Date} date2\n * @return {boolean} True if the given date objects refer to the same date\n */\nexport function dateEquals(date1, date2) {\n  return (\n    date1 instanceof Date &&\n    date2 instanceof Date &&\n    date1.getFullYear() === date2.getFullYear() &&\n    date1.getMonth() === date2.getMonth() &&\n    date1.getDate() === date2.getDate()\n  );\n}\n\n/**\n * Check if the given date is in the range of allowed dates.\n *\n * @param {!Date} date The date to check\n * @param {Date} min Range start\n * @param {Date} max Range end\n * @return {boolean} True if the date is in the range\n */\nexport function dateAllowed(date, min, max) {\n  return (!min || date >= min) && (!max || date <= max);\n}\n\n/**\n * Get closest date from array of dates.\n *\n * @param {!Date} date The date to compare dates with\n * @param {!Array<!Date>} dates Array of date objects\n * @return {!Date} Closest date\n */\nexport function getClosestDate(date, dates) {\n  return dates\n    .filter((date) => date !== undefined)\n    .reduce((closestDate, candidate) => {\n      if (!candidate) {\n        return closestDate;\n      }\n\n      if (!closestDate) {\n        return candidate;\n      }\n\n      const candidateDiff = Math.abs(date.getTime() - candidate.getTime());\n      const closestDateDiff = Math.abs(closestDate.getTime() - date.getTime());\n      return candidateDiff < closestDateDiff ? candidate : closestDate;\n    });\n}\n\n/**\n * Extracts the basic component parts of a date (day, month and year)\n * to the expected format.\n * @param {!Date} date\n * @return {{day: number, month: number, year: number}}\n */\nexport function extractDateParts(date) {\n  return {\n    day: date.getDate(),\n    month: date.getMonth(),\n    year: date.getFullYear(),\n  };\n}\n\n/**\n * Get difference in months between today and given months value.\n *\n * @param {number} months\n * @return {number}\n */\nexport function dateAfterXMonths(months) {\n  const today = new Date();\n  const result = new Date(today);\n  result.setDate(1);\n  result.setMonth(parseInt(months) + today.getMonth());\n  return result;\n}\n\n/**\n * Calculate the year of the date based on the provided reference date.\n * Gets a two-digit year and returns a full year.\n * @param {!Date} referenceDate The date to act as basis in the calculation\n * @param {!number} year Should be in the range of [0, 99]\n * @param {number} month\n * @param {number} day\n * @return {!number} Adjusted year value\n */\nexport function getAdjustedYear(referenceDate, year, month = 0, day = 1) {\n  if (year > 99) {\n    throw new Error('The provided year cannot have more than 2 digits.');\n  }\n  if (year < 0) {\n    throw new Error('The provided year cannot be negative.');\n  }\n  // Year values up to 2 digits are parsed based on the reference date.\n  let adjustedYear = year + Math.floor(referenceDate.getFullYear() / 100) * 100;\n  if (referenceDate < new Date(adjustedYear - 50, month, day)) {\n    adjustedYear -= 100;\n  } else if (referenceDate > new Date(adjustedYear + 50, month, day)) {\n    adjustedYear += 100;\n  }\n  return adjustedYear;\n}\n\n/**\n * Parse date string of one of the following date formats:\n * - ISO 8601 `\"YYYY-MM-DD\"`\n * - 6-digit extended ISO 8601 `\"+YYYYYY-MM-DD\"`, `\"-YYYYYY-MM-DD\"`\n * @param {!string} str Date string to parse\n * @return {Date} Parsed date\n */\nexport function parseDate(str) {\n  // Parsing with RegExp to ensure correct format\n  const parts = /^([-+]\\d{1}|\\d{2,4}|[-+]\\d{6})-(\\d{1,2})-(\\d{1,2})$/u.exec(str);\n  if (!parts) {\n    return undefined;\n  }\n\n  const date = new Date(0, 0); // Wrong date (1900-01-01), but with midnight in local time\n  date.setFullYear(parseInt(parts[1], 10));\n  date.setMonth(parseInt(parts[2], 10) - 1);\n  date.setDate(parseInt(parts[3], 10));\n  return date;\n}\n"],
  "mappings": ";AAYO,SAAS,iBAAiB,MAAM;AAErC,MAAI,YAAY,KAAK,OAAO;AAI5B,MAAI,cAAc,GAAG;AACnB,gBAAY;AAAA,EACd;AAGA,QAAM,sBAAsB,IAAI;AAChC,QAAM,kBAAkB,IAAI,KAAK,KAAK,QAAQ,IAAI,sBAAsB,KAAK,OAAO,GAAI;AAExF,QAAM,iBAAiB,IAAI,KAAK,GAAG,CAAC;AACpC,iBAAe,YAAY,gBAAgB,YAAY,CAAC;AAExD,QAAM,WAAW,gBAAgB,QAAQ,IAAI,eAAe,QAAQ;AAIpE,QAAM,0BAA0B,KAAK,MAAM,YAAY,KAAK,OAAO,IAAK;AAExE,SAAO,KAAK,MAAM,0BAA0B,IAAI,CAAC;AACnD;AASO,SAAS,WAAW,OAAO,OAAO;AACvC,SACE,iBAAiB,QACjB,iBAAiB,QACjB,MAAM,YAAY,MAAM,MAAM,YAAY,KAC1C,MAAM,SAAS,MAAM,MAAM,SAAS,KACpC,MAAM,QAAQ,MAAM,MAAM,QAAQ;AAEtC;AAUO,SAAS,YAAY,MAAM,KAAK,KAAK;AAC1C,UAAQ,CAAC,OAAO,QAAQ,SAAS,CAAC,OAAO,QAAQ;AACnD;AASO,SAAS,eAAe,MAAM,OAAO;AAC1C,SAAO,MACJ,OAAO,CAACA,UAASA,UAAS,MAAS,EACnC,OAAO,CAAC,aAAa,cAAc;AAClC,QAAI,CAAC,WAAW;AACd,aAAO;AAAA,IACT;AAEA,QAAI,CAAC,aAAa;AAChB,aAAO;AAAA,IACT;AAEA,UAAM,gBAAgB,KAAK,IAAI,KAAK,QAAQ,IAAI,UAAU,QAAQ,CAAC;AACnE,UAAM,kBAAkB,KAAK,IAAI,YAAY,QAAQ,IAAI,KAAK,QAAQ,CAAC;AACvE,WAAO,gBAAgB,kBAAkB,YAAY;AAAA,EACvD,CAAC;AACL;AAQO,SAAS,iBAAiB,MAAM;AACrC,SAAO;AAAA,IACL,KAAK,KAAK,QAAQ;AAAA,IAClB,OAAO,KAAK,SAAS;AAAA,IACrB,MAAM,KAAK,YAAY;AAAA,EACzB;AACF;AAQO,SAAS,iBAAiB,QAAQ;AACvC,QAAM,QAAQ,oBAAI,KAAK;AACvB,QAAM,SAAS,IAAI,KAAK,KAAK;AAC7B,SAAO,QAAQ,CAAC;AAChB,SAAO,SAAS,SAAS,MAAM,IAAI,MAAM,SAAS,CAAC;AACnD,SAAO;AACT;AAWO,SAAS,gBAAgB,eAAe,MAAM,QAAQ,GAAG,MAAM,GAAG;AACvE,MAAI,OAAO,IAAI;AACb,UAAM,IAAI,MAAM,mDAAmD;AAAA,EACrE;AACA,MAAI,OAAO,GAAG;AACZ,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,MAAI,eAAe,OAAO,KAAK,MAAM,cAAc,YAAY,IAAI,GAAG,IAAI;AAC1E,MAAI,gBAAgB,IAAI,KAAK,eAAe,IAAI,OAAO,GAAG,GAAG;AAC3D,oBAAgB;AAAA,EAClB,WAAW,gBAAgB,IAAI,KAAK,eAAe,IAAI,OAAO,GAAG,GAAG;AAClE,oBAAgB;AAAA,EAClB;AACA,SAAO;AACT;AASO,SAAS,UAAU,KAAK;AAE7B,QAAM,QAAQ,uDAAuD,KAAK,GAAG;AAC7E,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AAEA,QAAM,OAAO,IAAI,KAAK,GAAG,CAAC;AAC1B,OAAK,YAAY,SAAS,MAAM,CAAC,GAAG,EAAE,CAAC;AACvC,OAAK,SAAS,SAAS,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC;AACxC,OAAK,QAAQ,SAAS,MAAM,CAAC,GAAG,EAAE,CAAC;AACnC,SAAO;AACT;",
  "names": ["date"]
}
