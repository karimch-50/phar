import {
  Stroke_default
} from "./chunk-DETCTFAH.js";
import {
  Fill_default
} from "./chunk-TAVH433R.js";
import {
  getFontParameters
} from "./chunk-FEVAEU4Y.js";
import {
  asArray,
  toString
} from "./chunk-EBEDITAK.js";
import {
  toSize
} from "./chunk-V7IIVM7C.js";
import {
  ImageState_default,
  createCanvasContext2D
} from "./chunk-PN2SGMHC.js";
import {
  GeometryType_default
} from "./chunk-JFL7O5KA.js";
import {
  WORKER_OFFSCREEN_CANVAS
} from "./chunk-IRMQKYQT.js";
import {
  assert
} from "./chunk-FE3DXTD6.js";
import {
  Object_default,
  Target_default
} from "./chunk-OAOBVDCL.js";
import {
  abstract,
  clear
} from "./chunk-K4RYKKJS.js";

// node_modules/ol/style/Image.js
var ImageStyle = (
  /** @class */
  function() {
    function ImageStyle2(options) {
      this.opacity_ = options.opacity;
      this.rotateWithView_ = options.rotateWithView;
      this.rotation_ = options.rotation;
      this.scale_ = options.scale;
      this.scaleArray_ = toSize(options.scale);
      this.displacement_ = options.displacement;
    }
    ImageStyle2.prototype.clone = function() {
      var scale = this.getScale();
      return new ImageStyle2({
        opacity: this.getOpacity(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice()
      });
    };
    ImageStyle2.prototype.getOpacity = function() {
      return this.opacity_;
    };
    ImageStyle2.prototype.getRotateWithView = function() {
      return this.rotateWithView_;
    };
    ImageStyle2.prototype.getRotation = function() {
      return this.rotation_;
    };
    ImageStyle2.prototype.getScale = function() {
      return this.scale_;
    };
    ImageStyle2.prototype.getScaleArray = function() {
      return this.scaleArray_;
    };
    ImageStyle2.prototype.getDisplacement = function() {
      return this.displacement_;
    };
    ImageStyle2.prototype.getAnchor = function() {
      return abstract();
    };
    ImageStyle2.prototype.getImage = function(pixelRatio) {
      return abstract();
    };
    ImageStyle2.prototype.getHitDetectionImage = function() {
      return abstract();
    };
    ImageStyle2.prototype.getPixelRatio = function(pixelRatio) {
      return 1;
    };
    ImageStyle2.prototype.getImageState = function() {
      return abstract();
    };
    ImageStyle2.prototype.getImageSize = function() {
      return abstract();
    };
    ImageStyle2.prototype.getOrigin = function() {
      return abstract();
    };
    ImageStyle2.prototype.getSize = function() {
      return abstract();
    };
    ImageStyle2.prototype.setDisplacement = function(displacement) {
      this.displacement_ = displacement;
    };
    ImageStyle2.prototype.setOpacity = function(opacity) {
      this.opacity_ = opacity;
    };
    ImageStyle2.prototype.setRotateWithView = function(rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    };
    ImageStyle2.prototype.setRotation = function(rotation) {
      this.rotation_ = rotation;
    };
    ImageStyle2.prototype.setScale = function(scale) {
      this.scale_ = scale;
      this.scaleArray_ = toSize(scale);
    };
    ImageStyle2.prototype.listenImageChange = function(listener) {
      abstract();
    };
    ImageStyle2.prototype.load = function() {
      abstract();
    };
    ImageStyle2.prototype.unlistenImageChange = function(listener) {
      abstract();
    };
    return ImageStyle2;
  }()
);
var Image_default = ImageStyle;

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (Array.isArray(color)) {
    return toString(color);
  } else {
    return color;
  }
}

// node_modules/ol/render/canvas.js
var defaultFont = "10px sans-serif";
var defaultFillStyle = "#000";
var defaultLineCap = "round";
var defaultLineDash = [];
var defaultLineDashOffset = 0;
var defaultLineJoin = "round";
var defaultMiterLimit = 10;
var defaultStrokeStyle = "#000";
var defaultTextAlign = "center";
var defaultTextBaseline = "middle";
var defaultPadding = [0, 0, 0, 0];
var defaultLineWidth = 1;
var checkedFonts = new Object_default();
var labelCache = new Target_default();
labelCache.setSize = function() {
  console.warn("labelCache is deprecated.");
};
var measureContext = null;
var measureFont;
var textHeights = {};
var registerFont = function() {
  var retries = 100;
  var size = "32px ";
  var referenceFonts = ["monospace", "serif"];
  var len = referenceFonts.length;
  var text = "wmytzilWMYTZIL@#/&?$%10";
  var interval, referenceWidth;
  function isAvailable(fontStyle, fontWeight, fontFamily) {
    var available = true;
    for (var i = 0; i < len; ++i) {
      var referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(fontStyle + " " + fontWeight + " " + size + referenceFont, text);
      if (fontFamily != referenceFont) {
        var width = measureTextWidth(fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont, text);
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }
  function check() {
    var done = true;
    var fonts = checkedFonts.getKeys();
    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];
      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split("\n"))) {
          clear(textHeights);
          measureContext = null;
          measureFont = void 0;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = void 0;
    }
  }
  return function(fontSpec) {
    var font = getFontParameters(fontSpec);
    if (!font) {
      return;
    }
    var families = font.families;
    for (var i = 0, ii = families.length; i < ii; ++i) {
      var family = families[i];
      var key = font.style + "\n" + font.weight + "\n" + family;
      if (checkedFonts.get(key) === void 0) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === void 0) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
var measureTextHeight = /* @__PURE__ */ function() {
  var measureElement;
  return function(fontSpec) {
    var height = textHeights[fontSpec];
    if (height == void 0) {
      if (WORKER_OFFSCREEN_CANVAS) {
        var font = getFontParameters(fontSpec);
        var metrics = measureText(fontSpec, "Žg");
        var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement("div");
          measureElement.innerHTML = "M";
          measureElement.style.minHeight = "0";
          measureElement.style.maxHeight = "none";
          measureElement.style.height = "auto";
          measureElement.style.padding = "0";
          measureElement.style.border = "none";
          measureElement.style.position = "absolute";
          measureElement.style.display = "block";
          measureElement.style.left = "-99999px";
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
}();
function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache) {
  if (text in cache) {
    return cache[text];
  }
  var width = measureTextWidth(font, text);
  cache[text] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  var widths = [];
  var heights = [];
  var lineWidths = [];
  var width = 0;
  var lineWidth = 0;
  var height = 0;
  var lineHeight = 0;
  for (var i = 0, ii = chunks.length; i <= ii; i += 2) {
    var text = chunks[i];
    if (text === "\n" || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      continue;
    }
    var font = chunks[i + 1] || baseStyle.font;
    var currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    var currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
  context.save();
  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }
  if (transform) {
    context.setTransform.apply(context, transform);
  }
  if (
    /** @type {*} */
    labelOrImage.contextInstructions
  ) {
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    executeLabelInstructions(
      /** @type {Label} */
      labelOrImage,
      context
    );
  } else if (scale[0] < 0 || scale[1] < 0) {
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      0,
      0,
      w,
      h
    );
  } else {
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      x,
      y,
      w * scale[0],
      h * scale[1]
    );
  }
  context.restore();
}
function executeLabelInstructions(label, context) {
  var contextInstructions = label.contextInstructions;
  for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}

// node_modules/ol/style/RegularShape.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RegularShape = (
  /** @class */
  function(_super) {
    __extends(RegularShape2, _super);
    function RegularShape2(options) {
      var _this = this;
      var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
      _this = _super.call(this, {
        opacity: 1,
        rotateWithView,
        rotation: options.rotation !== void 0 ? options.rotation : 0,
        scale: options.scale !== void 0 ? options.scale : 1,
        displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
      }) || this;
      _this.canvas_ = void 0;
      _this.hitDetectionCanvas_ = null;
      _this.fill_ = options.fill !== void 0 ? options.fill : null;
      _this.origin_ = [0, 0];
      _this.points_ = options.points;
      _this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
      _this.radius2_ = options.radius2;
      _this.angle_ = options.angle !== void 0 ? options.angle : 0;
      _this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
      _this.size_ = null;
      _this.renderOptions_ = null;
      _this.render();
      return _this;
    }
    RegularShape2.prototype.clone = function() {
      var scale = this.getScale();
      var style = new RegularShape2({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        points: this.getPoints(),
        radius: this.getRadius(),
        radius2: this.getRadius2(),
        angle: this.getAngle(),
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        displacement: this.getDisplacement().slice()
      });
      style.setOpacity(this.getOpacity());
      return style;
    };
    RegularShape2.prototype.getAnchor = function() {
      var size = this.size_;
      if (!size) {
        return null;
      }
      var displacement = this.getDisplacement();
      return [size[0] / 2 - displacement[0], size[1] / 2 + displacement[1]];
    };
    RegularShape2.prototype.getAngle = function() {
      return this.angle_;
    };
    RegularShape2.prototype.getFill = function() {
      return this.fill_;
    };
    RegularShape2.prototype.getHitDetectionImage = function() {
      if (!this.hitDetectionCanvas_) {
        this.createHitDetectionCanvas_(this.renderOptions_);
      }
      return this.hitDetectionCanvas_;
    };
    RegularShape2.prototype.getImage = function(pixelRatio) {
      var image = this.canvas_[pixelRatio];
      if (!image) {
        var renderOptions = this.renderOptions_;
        var context = createCanvasContext2D(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
        this.draw_(renderOptions, context, pixelRatio);
        image = context.canvas;
        this.canvas_[pixelRatio] = image;
      }
      return image;
    };
    RegularShape2.prototype.getPixelRatio = function(pixelRatio) {
      return pixelRatio;
    };
    RegularShape2.prototype.getImageSize = function() {
      return this.size_;
    };
    RegularShape2.prototype.getImageState = function() {
      return ImageState_default.LOADED;
    };
    RegularShape2.prototype.getOrigin = function() {
      return this.origin_;
    };
    RegularShape2.prototype.getPoints = function() {
      return this.points_;
    };
    RegularShape2.prototype.getRadius = function() {
      return this.radius_;
    };
    RegularShape2.prototype.getRadius2 = function() {
      return this.radius2_;
    };
    RegularShape2.prototype.getSize = function() {
      return this.size_;
    };
    RegularShape2.prototype.getStroke = function() {
      return this.stroke_;
    };
    RegularShape2.prototype.listenImageChange = function(listener) {
    };
    RegularShape2.prototype.load = function() {
    };
    RegularShape2.prototype.unlistenImageChange = function(listener) {
    };
    RegularShape2.prototype.calculateLineJoinSize_ = function(lineJoin, strokeWidth, miterLimit) {
      if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
        return strokeWidth;
      }
      var r1 = this.radius_;
      var r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
      if (r1 < r2) {
        var tmp = r1;
        r1 = r2;
        r2 = tmp;
      }
      var points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
      var alpha = 2 * Math.PI / points;
      var a = r2 * Math.sin(alpha);
      var b = Math.sqrt(r2 * r2 - a * a);
      var d = r1 - b;
      var e = Math.sqrt(a * a + d * d);
      var miterRatio = e / a;
      if (lineJoin === "miter" && miterRatio <= miterLimit) {
        return miterRatio * strokeWidth;
      }
      var k = strokeWidth / 2 / miterRatio;
      var l = strokeWidth / 2 * (d / e);
      var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
      var bevelAdd = maxr - r1;
      if (this.radius2_ === void 0 || lineJoin === "bevel") {
        return bevelAdd * 2;
      }
      var aa = r1 * Math.sin(alpha);
      var bb = Math.sqrt(r1 * r1 - aa * aa);
      var dd = r2 - bb;
      var ee = Math.sqrt(aa * aa + dd * dd);
      var innerMiterRatio = ee / aa;
      if (innerMiterRatio <= miterLimit) {
        var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
        return 2 * Math.max(bevelAdd, innerLength);
      }
      return bevelAdd * 2;
    };
    RegularShape2.prototype.createRenderOptions = function() {
      var lineJoin = defaultLineJoin;
      var miterLimit = 0;
      var lineDash = null;
      var lineDashOffset = 0;
      var strokeStyle;
      var strokeWidth = 0;
      if (this.stroke_) {
        strokeStyle = this.stroke_.getColor();
        if (strokeStyle === null) {
          strokeStyle = defaultStrokeStyle;
        }
        strokeStyle = asColorLike(strokeStyle);
        strokeWidth = this.stroke_.getWidth();
        if (strokeWidth === void 0) {
          strokeWidth = defaultLineWidth;
        }
        lineDash = this.stroke_.getLineDash();
        lineDashOffset = this.stroke_.getLineDashOffset();
        lineJoin = this.stroke_.getLineJoin();
        if (lineJoin === void 0) {
          lineJoin = defaultLineJoin;
        }
        miterLimit = this.stroke_.getMiterLimit();
        if (miterLimit === void 0) {
          miterLimit = defaultMiterLimit;
        }
      }
      var add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
      var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
      var size = Math.ceil(2 * maxRadius + add);
      return {
        strokeStyle,
        strokeWidth,
        size,
        lineDash,
        lineDashOffset,
        lineJoin,
        miterLimit
      };
    };
    RegularShape2.prototype.render = function() {
      this.renderOptions_ = this.createRenderOptions();
      var size = this.renderOptions_.size;
      this.canvas_ = {};
      this.size_ = [size, size];
    };
    RegularShape2.prototype.draw_ = function(renderOptions, context, pixelRatio) {
      context.scale(pixelRatio, pixelRatio);
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      if (this.fill_) {
        var color = this.fill_.getColor();
        if (color === null) {
          color = defaultFillStyle;
        }
        context.fillStyle = asColorLike(color);
        context.fill();
      }
      if (this.stroke_) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;
        if (context.setLineDash && renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }
        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    };
    RegularShape2.prototype.createHitDetectionCanvas_ = function(renderOptions) {
      if (this.fill_) {
        var color = this.fill_.getColor();
        var opacity = 0;
        if (typeof color === "string") {
          color = asArray(color);
        }
        if (color === null) {
          opacity = 1;
        } else if (Array.isArray(color)) {
          opacity = color.length === 4 ? color[3] : 1;
        }
        if (opacity === 0) {
          var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
          this.hitDetectionCanvas_ = context.canvas;
          this.drawHitDetectionCanvas_(renderOptions, context);
        }
      }
      if (!this.hitDetectionCanvas_) {
        this.hitDetectionCanvas_ = this.getImage(1);
      }
    };
    RegularShape2.prototype.createPath_ = function(context) {
      var points = this.points_;
      var radius = this.radius_;
      if (points === Infinity) {
        context.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        var radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
        if (this.radius2_ !== void 0) {
          points *= 2;
        }
        var startAngle = this.angle_ - Math.PI / 2;
        var step = 2 * Math.PI / points;
        for (var i = 0; i < points; i++) {
          var angle0 = startAngle + i * step;
          var radiusC = i % 2 === 0 ? radius : radius2;
          context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
        }
        context.closePath();
      }
    };
    RegularShape2.prototype.drawHitDetectionCanvas_ = function(renderOptions, context) {
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      context.fillStyle = defaultFillStyle;
      context.fill();
      if (this.stroke_) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;
        if (renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }
        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    };
    return RegularShape2;
  }(Image_default)
);
var RegularShape_default = RegularShape;

// node_modules/ol/style/Circle.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CircleStyle = (
  /** @class */
  function(_super) {
    __extends2(CircleStyle2, _super);
    function CircleStyle2(opt_options) {
      var options = opt_options ? opt_options : {};
      return _super.call(this, {
        points: Infinity,
        fill: options.fill,
        radius: options.radius,
        stroke: options.stroke,
        scale: options.scale !== void 0 ? options.scale : 1,
        rotation: options.rotation !== void 0 ? options.rotation : 0,
        rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
        displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
      }) || this;
    }
    CircleStyle2.prototype.clone = function() {
      var scale = this.getScale();
      var style = new CircleStyle2({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        radius: this.getRadius(),
        scale: Array.isArray(scale) ? scale.slice() : scale,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice()
      });
      style.setOpacity(this.getOpacity());
      return style;
    };
    CircleStyle2.prototype.setRadius = function(radius) {
      this.radius_ = radius;
      this.render();
    };
    return CircleStyle2;
  }(RegularShape_default)
);
var Circle_default = CircleStyle;

// node_modules/ol/style/Style.js
var Style = (
  /** @class */
  function() {
    function Style2(opt_options) {
      var options = opt_options || {};
      this.geometry_ = null;
      this.geometryFunction_ = defaultGeometryFunction;
      if (options.geometry !== void 0) {
        this.setGeometry(options.geometry);
      }
      this.fill_ = options.fill !== void 0 ? options.fill : null;
      this.image_ = options.image !== void 0 ? options.image : null;
      this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
      this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
      this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
      this.text_ = options.text !== void 0 ? options.text : null;
      this.zIndex_ = options.zIndex;
    }
    Style2.prototype.clone = function() {
      var geometry = this.getGeometry();
      if (geometry && typeof geometry === "object") {
        geometry = /** @type {import("../geom/Geometry.js").default} */
        geometry.clone();
      }
      return new Style2({
        geometry,
        fill: this.getFill() ? this.getFill().clone() : void 0,
        image: this.getImage() ? this.getImage().clone() : void 0,
        renderer: this.getRenderer(),
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        text: this.getText() ? this.getText().clone() : void 0,
        zIndex: this.getZIndex()
      });
    };
    Style2.prototype.getRenderer = function() {
      return this.renderer_;
    };
    Style2.prototype.setRenderer = function(renderer) {
      this.renderer_ = renderer;
    };
    Style2.prototype.setHitDetectionRenderer = function(renderer) {
      this.hitDetectionRenderer_ = renderer;
    };
    Style2.prototype.getHitDetectionRenderer = function() {
      return this.hitDetectionRenderer_;
    };
    Style2.prototype.getGeometry = function() {
      return this.geometry_;
    };
    Style2.prototype.getGeometryFunction = function() {
      return this.geometryFunction_;
    };
    Style2.prototype.getFill = function() {
      return this.fill_;
    };
    Style2.prototype.setFill = function(fill) {
      this.fill_ = fill;
    };
    Style2.prototype.getImage = function() {
      return this.image_;
    };
    Style2.prototype.setImage = function(image) {
      this.image_ = image;
    };
    Style2.prototype.getStroke = function() {
      return this.stroke_;
    };
    Style2.prototype.setStroke = function(stroke) {
      this.stroke_ = stroke;
    };
    Style2.prototype.getText = function() {
      return this.text_;
    };
    Style2.prototype.setText = function(text) {
      this.text_ = text;
    };
    Style2.prototype.getZIndex = function() {
      return this.zIndex_;
    };
    Style2.prototype.setGeometry = function(geometry) {
      if (typeof geometry === "function") {
        this.geometryFunction_ = geometry;
      } else if (typeof geometry === "string") {
        this.geometryFunction_ = function(feature) {
          return (
            /** @type {import("../geom/Geometry.js").default} */
            feature.get(geometry)
          );
        };
      } else if (!geometry) {
        this.geometryFunction_ = defaultGeometryFunction;
      } else if (geometry !== void 0) {
        this.geometryFunction_ = function() {
          return (
            /** @type {import("../geom/Geometry.js").default} */
            geometry
          );
        };
      }
      this.geometry_ = geometry;
    };
    Style2.prototype.setZIndex = function(zIndex) {
      this.zIndex_ = zIndex;
    };
    return Style2;
  }()
);
function toFunction(obj) {
  var styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    var styles_1;
    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      assert(typeof /** @type {?} */
      obj.getZIndex === "function", 41);
      var style = (
        /** @type {Style} */
        obj
      );
      styles_1 = [style];
    }
    styleFunction = function() {
      return styles_1;
    };
  }
  return styleFunction;
}
var defaultStyles = null;
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    var fill = new Fill_default({
      color: "rgba(255,255,255,0.4)"
    });
    var stroke = new Stroke_default({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new Circle_default({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function createEditingStyle() {
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[GeometryType_default.POLYGON] = [
    new Style({
      fill: new Fill_default({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles[GeometryType_default.MULTI_POLYGON] = styles[GeometryType_default.POLYGON];
  styles[GeometryType_default.LINE_STRING] = [
    new Style({
      stroke: new Stroke_default({
        color: white,
        width: width + 2
      })
    }),
    new Style({
      stroke: new Stroke_default({
        color: blue,
        width
      })
    })
  ];
  styles[GeometryType_default.MULTI_LINE_STRING] = styles[GeometryType_default.LINE_STRING];
  styles[GeometryType_default.CIRCLE] = styles[GeometryType_default.POLYGON].concat(styles[GeometryType_default.LINE_STRING]);
  styles[GeometryType_default.POINT] = [
    new Style({
      image: new Circle_default({
        radius: width * 2,
        fill: new Fill_default({
          color: blue
        }),
        stroke: new Stroke_default({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles[GeometryType_default.MULTI_POINT] = styles[GeometryType_default.POINT];
  styles[GeometryType_default.GEOMETRY_COLLECTION] = styles[GeometryType_default.POLYGON].concat(styles[GeometryType_default.LINE_STRING], styles[GeometryType_default.POINT]);
  return styles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style_default = Style;

export {
  defaultFont,
  defaultFillStyle,
  defaultLineCap,
  defaultLineDash,
  defaultLineDashOffset,
  defaultLineJoin,
  defaultMiterLimit,
  defaultStrokeStyle,
  defaultTextAlign,
  defaultTextBaseline,
  defaultPadding,
  defaultLineWidth,
  checkedFonts,
  registerFont,
  measureAndCacheTextWidth,
  getTextDimensions,
  drawImageOrLabel,
  Image_default,
  asColorLike,
  RegularShape_default,
  Circle_default,
  toFunction,
  createDefaultStyle,
  createEditingStyle,
  Style_default
};
//# sourceMappingURL=chunk-RTP5WR2F.js.map
