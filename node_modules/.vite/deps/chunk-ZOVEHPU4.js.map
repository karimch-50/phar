{
  "version": 3,
  "sources": ["../../ol/src/Tile.js", "../../ol/src/ImageTile.js", "../../ol/src/reproj/Tile.js", "../../ol/src/TileRange.js"],
  "sourcesContent": ["/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   var xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     var data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [opt_options] Tile options.\n   */\n  constructor(tileCoord, state, opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile}\n     */\n    this.interimTile = null;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {}\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  getInterimTile() {\n    if (!this.interimTile) {\n      //empty chain\n      return this;\n    }\n    let tile = this.interimTile;\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        // Show tile immediately instead of fading it in after loading, because\n        // the interim tile is in place already\n        this.transition_ = 0;\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  }\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  refreshInterimChain() {\n    if (!this.interimTile) {\n      return;\n    }\n\n    let tile = this.interimTile;\n\n    /**\n     * @type {Tile}\n     */\n    let prev = this;\n\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      } else if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n}\n\nexport default Tile;\n", "/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [opt_options] Tile options.\n   */\n  constructor(\n    tileCoord,\n    state,\n    src,\n    crossOrigin,\n    tileLoadFunction,\n    opt_options\n  ) {\n    super(tileCoord, state, opt_options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @api\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n", "/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [opt_renderEdges] Render reprojection edges.\n   * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    opt_errorThreshold,\n    opt_renderEdges,\n    opt_interpolate\n  ) {\n    super(tileCoord, TileState.IDLE, {interpolate: !!opt_interpolate});\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach(\n      function (tile, i, arr) {\n        if (tile && tile.getState() == TileState.LOADED) {\n          sources.push({\n            extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n            image: tile.getImage(),\n          });\n        }\n      }.bind(this)\n    );\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(\n        function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE || state == TileState.LOADING) {\n            leftToLoad++;\n\n            const sourceListenKey = listen(\n              tile,\n              EventType.CHANGE,\n              function (e) {\n                const state = tile.getState();\n                if (\n                  state == TileState.LOADED ||\n                  state == TileState.ERROR ||\n                  state == TileState.EMPTY\n                ) {\n                  unlistenByKey(sourceListenKey);\n                  leftToLoad--;\n                  if (leftToLoad === 0) {\n                    this.unlistenSources_();\n                    this.reproject_();\n                  }\n                }\n              },\n              this\n            );\n            this.sourcesListenerKeys_.push(sourceListenKey);\n          }\n        }.bind(this)\n      );\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojTile;\n", "/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  } else {\n    return new TileRange(minX, maxX, minY, maxY);\n  }\n}\n\nexport default TileRange;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4EA,IAAA;;EAAA,SAAA,QAAA;AAAmB,cAAAA,OAAA,MAAA;AAMjB,aAAAA,MAAY,WAAW,OAAO,aAAW;AAAzC,UAAA,QACE,OAAA,KAAA,IAAA,KAAO;AAEP,UAAM,UAAU,cAAc,cAAc,CAAA;AAK5C,YAAK,YAAY;AAMjB,YAAK,QAAQ;AAQb,YAAK,cAAc;AAQnB,YAAK,MAAM;AAMX,YAAK,cACH,QAAQ,eAAe,SAAY,MAAM,QAAQ;AAOnD,YAAK,oBAAoB,CAAA;AAKzB,YAAK,cAAc,CAAC,CAAC,QAAQ;;IAC/B;AAKA,IAAAA,MAAA,UAAA,UAAA,WAAA;AACE,WAAK,cAAc,kBAAU,MAAM;IACrC;AAKA,IAAAA,MAAA,UAAA,UAAA,WAAA;IAAW;AAKX,IAAAA,MAAA,UAAA,SAAA,WAAA;AACE,aAAO,KAAK,MAAM,MAAM,KAAK;IAC/B;AAQA,IAAAA,MAAA,UAAA,iBAAA,WAAA;AACE,UAAI,CAAC,KAAK,aAAa;AAErB,eAAO;;AAET,UAAI,OAAO,KAAK;AAMhB,SAAG;AACD,YAAI,KAAK,SAAQ,KAAM,kBAAU,QAAQ;AAGvC,eAAK,cAAc;AACnB,iBAAO;;AAET,eAAO,KAAK;eACL;AAGT,aAAO;IACT;AAMA,IAAAA,MAAA,UAAA,sBAAA,WAAA;AACE,UAAI,CAAC,KAAK,aAAa;AACrB;;AAGF,UAAI,OAAO,KAAK;AAKhB,UAAI,OAAO;AAEX,SAAG;AACD,YAAI,KAAK,SAAQ,KAAM,kBAAU,QAAQ;AAIvC,eAAK,cAAc;AACnB;mBACS,KAAK,SAAQ,KAAM,kBAAU,SAAS;AAG/C,iBAAO;mBACE,KAAK,SAAQ,KAAM,kBAAU,MAAM;AAG5C,eAAK,cAAc,KAAK;eACnB;AACL,iBAAO;;AAET,eAAO,KAAK;eACL;IACX;AAOA,IAAAA,MAAA,UAAA,eAAA,WAAA;AACE,aAAO,KAAK;IACd;AAKA,IAAAA,MAAA,UAAA,WAAA,WAAA;AACE,aAAO,KAAK;IACd;AAUA,IAAAA,MAAA,UAAA,WAAA,SAAS,OAAK;AACZ,UAAI,KAAK,UAAU,kBAAU,SAAS,KAAK,QAAQ,OAAO;AACxD,cAAM,IAAI,MAAM,8BAA8B;;AAEhD,WAAK,QAAQ;AACb,WAAK,QAAO;IACd;AASA,IAAAA,MAAA,UAAA,OAAA,WAAA;AACE,eAAQ;IACV;AAQA,IAAAA,MAAA,UAAA,WAAA,SAAS,IAAI,MAAI;AACf,UAAI,CAAC,KAAK,aAAa;AACrB,eAAO;;AAGT,UAAI,QAAQ,KAAK,kBAAkB,EAAE;AACrC,UAAI,CAAC,OAAO;AACV,gBAAQ;AACR,aAAK,kBAAkB,EAAE,IAAI;iBACpB,UAAU,IAAI;AACvB,eAAO;;AAGT,UAAM,QAAQ,OAAO,QAAQ,MAAO;AACpC,UAAI,SAAS,KAAK,aAAa;AAC7B,eAAO;;AAET,aAAO,OAAO,QAAQ,KAAK,WAAW;IACxC;AASA,IAAAA,MAAA,UAAA,eAAA,SAAa,IAAE;AACb,UAAI,CAAC,KAAK,aAAa;AACrB,eAAO;;AAET,aAAO,KAAK,kBAAkB,EAAE,MAAM;IACxC;AAMA,IAAAA,MAAA,UAAA,gBAAA,SAAc,IAAE;AACd,UAAI,KAAK,aAAa;AACpB,aAAK,kBAAkB,EAAE,IAAI;;IAEjC;AACF,WAAAA;EAAA,EA9OmB,cAAW;;AAgP9B,IAAA,eAAe;;;;;;;;;;;;;;;;;;;;;;;;ACpTf,IAAA;;EAAA,SAAA,QAAA;AAAwB,IAAAC,WAAAC,YAAA,MAAA;AAStB,aAAAA,WACE,WACA,OACA,KACA,aACA,kBACA,aAAW;AANb,UAAA,QAQE,OAAA,KAAA,MAAM,WAAW,OAAO,WAAW,KAAC;AAMpC,YAAK,eAAe;AAQpB,YAAK,OAAO;AAEZ,YAAK,MAAM;AAMX,YAAK,SAAS,IAAI,MAAK;AACvB,UAAI,gBAAgB,MAAM;AACxB,cAAK,OAAO,cAAc;;AAO5B,YAAK,YAAY;AAMjB,YAAK,oBAAoB;;IAC3B;AAOA,IAAAA,WAAA,UAAA,WAAA,WAAA;AACE,aAAO,KAAK;IACd;AAMA,IAAAA,WAAA,UAAA,WAAA,SAAS,SAAO;AACd,WAAK,SAAS;AACd,WAAK,QAAQ,kBAAU;AACvB,WAAK,eAAc;AACnB,WAAK,QAAO;IACd;AAOA,IAAAA,WAAA,UAAA,oBAAA,WAAA;AACE,WAAK,QAAQ,kBAAU;AACvB,WAAK,eAAc;AACnB,WAAK,SAAS,cAAa;AAC3B,WAAK,QAAO;IACd;AAOA,IAAAA,WAAA,UAAA,mBAAA,WAAA;AACE,UAAM;;QAAyC,KAAK;;AACpD,UAAI,MAAM,gBAAgB,MAAM,eAAe;AAC7C,aAAK,QAAQ,kBAAU;aAClB;AACL,aAAK,QAAQ,kBAAU;;AAEzB,WAAK,eAAc;AACnB,WAAK,QAAO;IACd;AAMA,IAAAA,WAAA,UAAA,OAAA,WAAA;AACE,UAAI,KAAK,SAAS,kBAAU,OAAO;AACjC,aAAK,QAAQ,kBAAU;AACvB,aAAK,SAAS,IAAI,MAAK;AACvB,YAAI,KAAK,iBAAiB,MAAM;AAC9B,eAAK,OAAO,cAAc,KAAK;;;AAGnC,UAAI,KAAK,SAAS,kBAAU,MAAM;AAChC,aAAK,QAAQ,kBAAU;AACvB,aAAK,QAAO;AACZ,aAAK,kBAAkB,MAAM,KAAK,IAAI;AACtC,aAAK,YAAY,YACf,KAAK,QACL,KAAK,iBAAiB,KAAK,IAAI,GAC/B,KAAK,kBAAkB,KAAK,IAAI,CAAC;;IAGvC;AAOA,IAAAA,WAAA,UAAA,iBAAA,WAAA;AACE,UAAI,KAAK,WAAW;AAClB,aAAK,UAAS;AACd,aAAK,YAAY;;IAErB;AACF,WAAAA;EAAA,EA5IwB,YAAI;;AAkJ5B,SAAS,gBAAa;AACpB,MAAM,MAAM,sBAAsB,GAAG,CAAC;AACtC,MAAI,YAAY;AAChB,MAAI,SAAS,GAAG,GAAG,GAAG,CAAC;AACvB,SAAO,IAAI;AACb;AAEA,IAAA,oBAAe;;;;;;;;;;;;;;;;;;;;;;;;ACtIf,IAAA;;EAAA,SAAA,QAAA;AAAyB,IAAAC,WAAAC,aAAA,MAAA;AAgBvB,aAAAA,YACE,YACA,gBACA,YACA,gBACA,WACA,kBACA,YACA,QACA,iBACA,oBACA,iBACA,iBAAe;AAZjB,UAAA,QAcE,OAAA,KAAA,MAAM,WAAW,kBAAU,MAAM,EAAC,aAAa,CAAC,CAAC,gBAAe,CAAC,KAAC;AAMlE,YAAK,eAAe,oBAAoB,SAAY,kBAAkB;AAMtE,YAAK,cAAc;AAMnB,YAAK,UAAU;AAMf,YAAK,UAAU;AAMf,YAAK,kBAAkB;AAMvB,YAAK,kBAAkB;AAMvB,YAAK,oBAAoB,mBAAmB,mBAAmB;AAM/D,YAAK,eAAe,CAAA;AAMpB,YAAK,uBAAuB;AAM5B,YAAK,WAAW;AAEhB,UAAM,eAAe,eAAe,mBAClC,MAAK,iBAAiB;AAExB,UAAM,kBAAkB,MAAK,gBAAgB,UAAS;AACtD,UAAI,kBAAkB,MAAK,gBAAgB,UAAS;AAEpD,UAAM,sBAAsB,kBACxB,gBAAgB,cAAc,eAAe,IAC7C;AAEJ,UAAI,QAAQ,mBAAmB,MAAM,GAAG;AAGtC,cAAK,QAAQ,kBAAU;;;AAIzB,UAAM,mBAAmB,WAAW,UAAS;AAC7C,UAAI,kBAAkB;AACpB,YAAI,CAAC,iBAAiB;AACpB,4BAAkB;eACb;AACL,4BAAkB,gBAAgB,iBAAiB,gBAAgB;;;AAIvE,UAAM,mBAAmB,eAAe,cACtC,MAAK,kBAAkB,CAAC,CAAC;AAG3B,UAAM,mBAAmB,gCACvB,YACA,YACA,qBACA,gBAAgB;AAGlB,UAAI,CAAC,SAAS,gBAAgB,KAAK,oBAAoB,GAAG;AAGxD,cAAK,QAAQ,kBAAU;;;AAIzB,UAAM,yBACJ,uBAAuB,SAAY,qBAAqB;AAM1D,YAAK,iBAAiB,IAAI,sBACxB,YACA,YACA,qBACA,iBACA,mBAAmB,wBACnB,gBAAgB;AAGlB,UAAI,MAAK,eAAe,aAAY,EAAG,WAAW,GAAG;AAEnD,cAAK,QAAQ,kBAAU;;;AAIzB,YAAK,WAAW,eAAe,kBAAkB,gBAAgB;AACjE,UAAI,eAAe,MAAK,eAAe,sBAAqB;AAE5D,UAAI,iBAAiB;AACnB,YAAI,WAAW,SAAQ,GAAI;AACzB,uBAAa,CAAC,IAAI,MAChB,aAAa,CAAC,GACd,gBAAgB,CAAC,GACjB,gBAAgB,CAAC,CAAC;AAEpB,uBAAa,CAAC,IAAI,MAChB,aAAa,CAAC,GACd,gBAAgB,CAAC,GACjB,gBAAgB,CAAC,CAAC;eAEf;AACL,yBAAe,gBAAgB,cAAc,eAAe;;;AAIhE,UAAI,CAAC,QAAQ,YAAY,GAAG;AAC1B,cAAK,QAAQ,kBAAU;aAClB;AACL,YAAM,cAAc,eAAe,0BACjC,cACA,MAAK,QAAQ;AAGf,iBAAS,OAAO,YAAY,MAAM,QAAQ,YAAY,MAAM,QAAQ;AAClE,mBAAS,OAAO,YAAY,MAAM,QAAQ,YAAY,MAAM,QAAQ;AAClE,gBAAM,OAAO,gBAAgB,MAAK,UAAU,MAAM,MAAM,UAAU;AAClE,gBAAI,MAAM;AACR,oBAAK,aAAa,KAAK,IAAI;;;;AAKjC,YAAI,MAAK,aAAa,WAAW,GAAG;AAClC,gBAAK,QAAQ,kBAAU;;;;IAG7B;AAMA,IAAAA,YAAA,UAAA,WAAA,WAAA;AACE,aAAO,KAAK;IACd;AAKA,IAAAA,YAAA,UAAA,aAAA,WAAA;AACE,UAAM,UAAU,CAAA;AAChB,WAAK,aAAa,SAChB,SAAU,MAAM,GAAG,KAAG;AACpB,YAAI,QAAQ,KAAK,SAAQ,KAAM,kBAAU,QAAQ;AAC/C,kBAAQ,KAAK;YACX,QAAQ,KAAK,gBAAgB,mBAAmB,KAAK,SAAS;YAC9D,OAAO,KAAK,SAAQ;WACrB;;MAEL,GAAE,KAAK,IAAI,CAAC;AAEd,WAAK,aAAa,SAAS;AAE3B,UAAI,QAAQ,WAAW,GAAG;AACxB,aAAK,QAAQ,kBAAU;aAClB;AACL,YAAM,IAAI,KAAK,kBAAkB,CAAC;AAClC,YAAM,OAAO,KAAK,gBAAgB,YAAY,CAAC;AAC/C,YAAM,QAAQ,OAAO,SAAS,WAAW,OAAO,KAAK,CAAC;AACtD,YAAM,SAAS,OAAO,SAAS,WAAW,OAAO,KAAK,CAAC;AACvD,YAAM,mBAAmB,KAAK,gBAAgB,cAAc,CAAC;AAC7D,YAAM,mBAAmB,KAAK,gBAAgB,cAC5C,KAAK,QAAQ;AAGf,YAAM,eAAe,KAAK,gBAAgB,mBACxC,KAAK,iBAAiB;AAGxB,aAAK,UAAU,OACb,OACA,QACA,KAAK,aACL,kBACA,KAAK,gBAAgB,UAAS,GAC9B,kBACA,cACA,KAAK,gBACL,SACA,KAAK,SACL,KAAK,cACL,KAAK,WAAW;AAGlB,aAAK,QAAQ,kBAAU;;AAEzB,WAAK,QAAO;IACd;AAKA,IAAAA,YAAA,UAAA,OAAA,WAAA;AACE,UAAI,KAAK,SAAS,kBAAU,MAAM;AAChC,aAAK,QAAQ,kBAAU;AACvB,aAAK,QAAO;AAEZ,YAAI,eAAa;AAEjB,aAAK,uBAAuB,CAAA;AAC5B,aAAK,aAAa,SAChB,SAAU,MAAM,GAAG,KAAG;AACpB,cAAM,QAAQ,KAAK,SAAQ;AAC3B,cAAI,SAAS,kBAAU,QAAQ,SAAS,kBAAU,SAAS;AACzD;AAEA,gBAAM,oBAAkB,OACtB,MACA,kBAAU,QACV,SAAU,GAAC;AACT,kBAAMC,SAAQ,KAAK,SAAQ;AAC3B,kBACEA,UAAS,kBAAU,UACnBA,UAAS,kBAAU,SACnBA,UAAS,kBAAU,OACnB;AACA,8BAAc,iBAAe;AAC7B;AACA,oBAAI,iBAAe,GAAG;AACpB,uBAAK,iBAAgB;AACrB,uBAAK,WAAU;;;YAGrB,GACA,IAAI;AAEN,iBAAK,qBAAqB,KAAK,iBAAe;;QAElD,GAAE,KAAK,IAAI,CAAC;AAGd,YAAI,iBAAe,GAAG;AACpB,qBAAW,KAAK,WAAW,KAAK,IAAI,GAAG,CAAC;eACnC;AACL,eAAK,aAAa,QAAQ,SAAU,MAAM,GAAG,KAAG;AAC9C,gBAAM,QAAQ,KAAK,SAAQ;AAC3B,gBAAI,SAAS,kBAAU,MAAM;AAC3B,mBAAK,KAAI;;UAEb,CAAC;;;IAGP;AAKA,IAAAD,YAAA,UAAA,mBAAA,WAAA;AACE,WAAK,qBAAqB,QAAQ,aAAa;AAC/C,WAAK,uBAAuB;IAC9B;AACF,WAAAA;EAAA,EApUyB,YAAI;;AAsU7B,IAAAE,gBAAe;;;ACzVf,IAAA;;EAAA,WAAA;AAOE,aAAAC,WAAY,MAAM,MAAM,MAAM,MAAI;AAIhC,WAAK,OAAO;AAKZ,WAAK,OAAO;AAKZ,WAAK,OAAO;AAKZ,WAAK,OAAO;IACd;AAMA,IAAAA,WAAA,UAAA,WAAA,SAAS,WAAS;AAChB,aAAO,KAAK,WAAW,UAAU,CAAC,GAAG,UAAU,CAAC,CAAC;IACnD;AAMA,IAAAA,WAAA,UAAA,oBAAA,SAAkB,WAAS;AACzB,aACE,KAAK,QAAQ,UAAU,QACvB,UAAU,QAAQ,KAAK,QACvB,KAAK,QAAQ,UAAU,QACvB,UAAU,QAAQ,KAAK;IAE3B;AAOA,IAAAA,WAAA,UAAA,aAAA,SAAW,GAAG,GAAC;AACb,aAAO,KAAK,QAAQ,KAAK,KAAK,KAAK,QAAQ,KAAK,QAAQ,KAAK,KAAK,KAAK;IACzE;AAMA,IAAAA,WAAA,UAAA,SAAA,SAAO,WAAS;AACd,aACE,KAAK,QAAQ,UAAU,QACvB,KAAK,QAAQ,UAAU,QACvB,KAAK,QAAQ,UAAU,QACvB,KAAK,QAAQ,UAAU;IAE3B;AAKA,IAAAA,WAAA,UAAA,SAAA,SAAO,WAAS;AACd,UAAI,UAAU,OAAO,KAAK,MAAM;AAC9B,aAAK,OAAO,UAAU;;AAExB,UAAI,UAAU,OAAO,KAAK,MAAM;AAC9B,aAAK,OAAO,UAAU;;AAExB,UAAI,UAAU,OAAO,KAAK,MAAM;AAC9B,aAAK,OAAO,UAAU;;AAExB,UAAI,UAAU,OAAO,KAAK,MAAM;AAC9B,aAAK,OAAO,UAAU;;IAE1B;AAKA,IAAAA,WAAA,UAAA,YAAA,WAAA;AACE,aAAO,KAAK,OAAO,KAAK,OAAO;IACjC;AAKA,IAAAA,WAAA,UAAA,UAAA,WAAA;AACE,aAAO,CAAC,KAAK,SAAQ,GAAI,KAAK,UAAS,CAAE;IAC3C;AAKA,IAAAA,WAAA,UAAA,WAAA,WAAA;AACE,aAAO,KAAK,OAAO,KAAK,OAAO;IACjC;AAMA,IAAAA,WAAA,UAAA,aAAA,SAAW,WAAS;AAClB,aACE,KAAK,QAAQ,UAAU,QACvB,KAAK,QAAQ,UAAU,QACvB,KAAK,QAAQ,UAAU,QACvB,KAAK,QAAQ,UAAU;IAE3B;AACF,WAAAA;EAAA,EA3HA;;AAqIM,SAAU,eAAe,MAAM,MAAM,MAAM,MAAM,WAAS;AAC9D,MAAI,cAAc,QAAW;AAC3B,cAAU,OAAO;AACjB,cAAU,OAAO;AACjB,cAAU,OAAO;AACjB,cAAU,OAAO;AACjB,WAAO;SACF;AACL,WAAO,IAAI,UAAU,MAAM,MAAM,MAAM,IAAI;;AAE/C;AAEA,IAAA,oBAAe;",
  "names": ["Tile", "__extends", "ImageTile", "__extends", "ReprojTile", "state", "Tile_default", "TileRange"]
}
