import {
  BaseException,
  CMapCompressionType,
  MissingPDFException,
  UnexpectedResponseException,
  Util,
  assert,
  init_util,
  isString,
  removeNullCharacters,
  stringToBytes,
  unreachable,
  warn
} from "./chunk-U4PJHKRL.js";
import {
  __esm
} from "./chunk-WGAPYIUP.js";

// node_modules/@vaadin-component-factory/vcf-pdf-viewer/pdfjs/dist/display_utils.js
async function fetchData(url, asTypedArray = false) {
  if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL") || isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(response.statusText);
    }
    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : stringToBytes(await response.text());
  }
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open(
      "GET",
      url,
      /* asTypedArray = */
      true
    );
    if (asTypedArray) {
      request.responseType = "arraybuffer";
    }
    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }
      if (request.status === 200 || request.status === 0) {
        let data;
        if (asTypedArray && request.response) {
          data = new Uint8Array(request.response);
        } else if (!asTypedArray && request.responseText) {
          data = stringToBytes(request.responseText);
        }
        if (data) {
          resolve(data);
          return;
        }
      }
      reject(new Error(request.statusText));
    };
    request.send(null);
  });
}
function addLinkAttributes(link, {
  url,
  target,
  rel,
  enabled = true
} = {}) {
  assert(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
  const urlNullRemoved = removeNullCharacters(url);
  if (enabled) {
    link.href = link.title = urlNullRemoved;
  } else {
    link.href = "";
    link.title = `Disabled: ${urlNullRemoved}`;
    link.onclick = () => {
      return false;
    };
  }
  let targetStr = "";
  switch (target) {
    case LinkTarget.NONE:
      break;
    case LinkTarget.SELF:
      targetStr = "_self";
      break;
    case LinkTarget.BLANK:
      targetStr = "_blank";
      break;
    case LinkTarget.PARENT:
      targetStr = "_parent";
      break;
    case LinkTarget.TOP:
      targetStr = "_top";
      break;
  }
  link.target = targetStr;
  link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
}
function isDataScheme(url) {
  const ii = url.length;
  let i = 0;
  while (i < ii && url[i].trim() === "") {
    i++;
  }
  return url.substring(i, i + 5).toLowerCase() === "data:";
}
function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}
function getFilenameFromUrl(url) {
  const anchor = url.indexOf("#");
  const query = url.indexOf("?");
  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
  return url.substring(url.lastIndexOf("/", end) + 1, end);
}
function isValidFetchUrl(url, baseUrl) {
  try {
    const {
      protocol
    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
    return protocol === "http:" || protocol === "https:";
  } catch (ex) {
    return false;
  }
}
function loadScript(src, removeScriptElement = false) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;
    script.onload = function(evt) {
      if (removeScriptElement) {
        script.remove();
      }
      resolve(evt);
    };
    script.onerror = function() {
      reject(new Error(`Cannot load script at: ${script.src}`));
    };
    (document.head || document.documentElement).appendChild(script);
  });
}
function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}
var BaseCanvasFactory, BaseCMapReaderFactory, BaseStandardFontDataFactory, BaseSVGFactory, DEFAULT_LINK_REL, SVG_NS, DOMCanvasFactory, DOMCMapReaderFactory, DOMStandardFontDataFactory, DOMSVGFactory, PageViewport, RenderingCancelledException, LinkTarget, StatTimer, pdfDateStringRegex, PDFDateString;
var init_display_utils = __esm({
  "node_modules/@vaadin-component-factory/vcf-pdf-viewer/pdfjs/dist/display_utils.js"() {
    init_util();
    BaseCanvasFactory = class _BaseCanvasFactory {
      constructor() {
        if (this.constructor === _BaseCanvasFactory) {
          unreachable("Cannot initialize BaseCanvasFactory.");
        }
      }
      create(width, height) {
        if (width <= 0 || height <= 0) {
          throw new Error("Invalid canvas size");
        }
        const canvas = this._createCanvas(width, height);
        return {
          canvas,
          context: canvas.getContext("2d")
        };
      }
      reset(canvasAndContext, width, height) {
        if (!canvasAndContext.canvas) {
          throw new Error("Canvas is not specified");
        }
        if (width <= 0 || height <= 0) {
          throw new Error("Invalid canvas size");
        }
        canvasAndContext.canvas.width = width;
        canvasAndContext.canvas.height = height;
      }
      destroy(canvasAndContext) {
        if (!canvasAndContext.canvas) {
          throw new Error("Canvas is not specified");
        }
        canvasAndContext.canvas.width = 0;
        canvasAndContext.canvas.height = 0;
        canvasAndContext.canvas = null;
        canvasAndContext.context = null;
      }
      /**
       * @private
       */
      _createCanvas(width, height) {
        unreachable("Abstract method `_createCanvas` called.");
      }
    };
    BaseCMapReaderFactory = class _BaseCMapReaderFactory {
      constructor({
        baseUrl = null,
        isCompressed = false
      }) {
        if (this.constructor === _BaseCMapReaderFactory) {
          unreachable("Cannot initialize BaseCMapReaderFactory.");
        }
        this.baseUrl = baseUrl;
        this.isCompressed = isCompressed;
      }
      async fetch({
        name
      }) {
        if (!this.baseUrl) {
          throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
        }
        if (!name) {
          throw new Error("CMap name must be specified.");
        }
        const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
        const compressionType = this.isCompressed ? CMapCompressionType.BINARY : CMapCompressionType.NONE;
        return this._fetchData(url, compressionType).catch((reason) => {
          throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
        });
      }
      /**
       * @private
       */
      _fetchData(url, compressionType) {
        unreachable("Abstract method `_fetchData` called.");
      }
    };
    BaseStandardFontDataFactory = class _BaseStandardFontDataFactory {
      constructor({
        baseUrl = null
      }) {
        if (this.constructor === _BaseStandardFontDataFactory) {
          unreachable("Cannot initialize BaseStandardFontDataFactory.");
        }
        this.baseUrl = baseUrl;
      }
      async fetch({
        filename
      }) {
        if (!this.baseUrl) {
          throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
        }
        if (!filename) {
          throw new Error("Font filename must be specified.");
        }
        const url = `${this.baseUrl}${filename}`;
        return this._fetchData(url).catch((reason) => {
          throw new Error(`Unable to load font data at: ${url}`);
        });
      }
      /**
       * @private
       */
      _fetchData(url) {
        unreachable("Abstract method `_fetchData` called.");
      }
    };
    BaseSVGFactory = class _BaseSVGFactory {
      constructor() {
        if (this.constructor === _BaseSVGFactory) {
          unreachable("Cannot initialize BaseSVGFactory.");
        }
      }
      create(width, height) {
        if (width <= 0 || height <= 0) {
          throw new Error("Invalid SVG dimensions");
        }
        const svg = this._createSVG("svg:svg");
        svg.setAttribute("version", "1.1");
        svg.setAttribute("width", `${width}px`);
        svg.setAttribute("height", `${height}px`);
        svg.setAttribute("preserveAspectRatio", "none");
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        return svg;
      }
      createElement(type) {
        if (typeof type !== "string") {
          throw new Error("Invalid SVG element type");
        }
        return this._createSVG(type);
      }
      /**
       * @private
       */
      _createSVG(type) {
        unreachable("Abstract method `_createSVG` called.");
      }
    };
    DEFAULT_LINK_REL = "noopener noreferrer nofollow";
    SVG_NS = "http://www.w3.org/2000/svg";
    DOMCanvasFactory = class extends BaseCanvasFactory {
      constructor({
        ownerDocument = globalThis.document
      } = {}) {
        super();
        this._document = ownerDocument;
      }
      _createCanvas(width, height) {
        const canvas = this._document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
      }
    };
    DOMCMapReaderFactory = class extends BaseCMapReaderFactory {
      _fetchData(url, compressionType) {
        return fetchData(
          url,
          /* asTypedArray = */
          this.isCompressed
        ).then((data) => {
          return {
            cMapData: data,
            compressionType
          };
        });
      }
    };
    DOMStandardFontDataFactory = class extends BaseStandardFontDataFactory {
      _fetchData(url) {
        return fetchData(
          url,
          /* asTypedArray = */
          true
        );
      }
    };
    DOMSVGFactory = class extends BaseSVGFactory {
      _createSVG(type) {
        return document.createElementNS(SVG_NS, type);
      }
    };
    PageViewport = class _PageViewport {
      /**
       * @param {PageViewportParameters}
       */
      constructor({
        viewBox,
        scale,
        rotation,
        offsetX = 0,
        offsetY = 0,
        dontFlip = false
      }) {
        this.viewBox = viewBox;
        this.scale = scale;
        this.rotation = rotation;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        const centerX = (viewBox[2] + viewBox[0]) / 2;
        const centerY = (viewBox[3] + viewBox[1]) / 2;
        let rotateA, rotateB, rotateC, rotateD;
        rotation %= 360;
        if (rotation < 0) {
          rotation += 360;
        }
        switch (rotation) {
          case 180:
            rotateA = -1;
            rotateB = 0;
            rotateC = 0;
            rotateD = 1;
            break;
          case 90:
            rotateA = 0;
            rotateB = 1;
            rotateC = 1;
            rotateD = 0;
            break;
          case 270:
            rotateA = 0;
            rotateB = -1;
            rotateC = -1;
            rotateD = 0;
            break;
          case 0:
            rotateA = 1;
            rotateB = 0;
            rotateC = 0;
            rotateD = -1;
            break;
          default:
            throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
        }
        if (dontFlip) {
          rotateC = -rotateC;
          rotateD = -rotateD;
        }
        let offsetCanvasX, offsetCanvasY;
        let width, height;
        if (rotateA === 0) {
          offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
          offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
          width = Math.abs(viewBox[3] - viewBox[1]) * scale;
          height = Math.abs(viewBox[2] - viewBox[0]) * scale;
        } else {
          offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
          offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
          width = Math.abs(viewBox[2] - viewBox[0]) * scale;
          height = Math.abs(viewBox[3] - viewBox[1]) * scale;
        }
        this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
        this.width = width;
        this.height = height;
      }
      /**
       * Clones viewport, with optional additional properties.
       * @param {PageViewportCloneParameters} [params]
       * @returns {PageViewport} Cloned viewport.
       */
      clone({
        scale = this.scale,
        rotation = this.rotation,
        offsetX = this.offsetX,
        offsetY = this.offsetY,
        dontFlip = false
      } = {}) {
        return new _PageViewport({
          viewBox: this.viewBox.slice(),
          scale,
          rotation,
          offsetX,
          offsetY,
          dontFlip
        });
      }
      /**
       * Converts PDF point to the viewport coordinates. For examples, useful for
       * converting PDF location into canvas pixel coordinates.
       * @param {number} x - The x-coordinate.
       * @param {number} y - The y-coordinate.
       * @returns {Object} Object containing `x` and `y` properties of the
       *   point in the viewport coordinate space.
       * @see {@link convertToPdfPoint}
       * @see {@link convertToViewportRectangle}
       */
      convertToViewportPoint(x, y) {
        return Util.applyTransform([x, y], this.transform);
      }
      /**
       * Converts PDF rectangle to the viewport coordinates.
       * @param {Array} rect - The xMin, yMin, xMax and yMax coordinates.
       * @returns {Array} Array containing corresponding coordinates of the
       *   rectangle in the viewport coordinate space.
       * @see {@link convertToViewportPoint}
       */
      convertToViewportRectangle(rect) {
        const topLeft = Util.applyTransform([rect[0], rect[1]], this.transform);
        const bottomRight = Util.applyTransform([rect[2], rect[3]], this.transform);
        return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
      }
      /**
       * Converts viewport coordinates to the PDF location. For examples, useful
       * for converting canvas pixel location into PDF one.
       * @param {number} x - The x-coordinate.
       * @param {number} y - The y-coordinate.
       * @returns {Object} Object containing `x` and `y` properties of the
       *   point in the PDF coordinate space.
       * @see {@link convertToViewportPoint}
       */
      convertToPdfPoint(x, y) {
        return Util.applyInverseTransform([x, y], this.transform);
      }
    };
    RenderingCancelledException = class extends BaseException {
      constructor(msg, type) {
        super(msg);
        this.type = type;
      }
    };
    LinkTarget = {
      NONE: 0,
      // Default value.
      SELF: 1,
      BLANK: 2,
      PARENT: 3,
      TOP: 4
    };
    StatTimer = class {
      constructor() {
        this.started = /* @__PURE__ */ Object.create(null);
        this.times = [];
      }
      time(name) {
        if (name in this.started) {
          warn(`Timer is already running for ${name}`);
        }
        this.started[name] = Date.now();
      }
      timeEnd(name) {
        if (!(name in this.started)) {
          warn(`Timer has not been started for ${name}`);
        }
        this.times.push({
          name,
          start: this.started[name],
          end: Date.now()
        });
        delete this.started[name];
      }
      toString() {
        const outBuf = [];
        let longest = 0;
        for (const time of this.times) {
          const name = time.name;
          if (name.length > longest) {
            longest = name.length;
          }
        }
        for (const time of this.times) {
          const duration = time.end - time.start;
          outBuf.push(`${time.name.padEnd(longest)} ${duration}ms
`);
        }
        return outBuf.join("");
      }
    };
    PDFDateString = class {
      /**
       * Convert a PDF date string to a JavaScript `Date` object.
       *
       * The PDF date string format is described in section 7.9.4 of the official
       * PDF 32000-1:2008 specification. However, in the PDF 1.7 reference (sixth
       * edition) Adobe describes the same format including a trailing apostrophe.
       * This syntax in incorrect, but Adobe Acrobat creates PDF files that contain
       * them. We ignore all apostrophes as they are not necessary for date parsing.
       *
       * Moreover, Adobe Acrobat doesn't handle changing the date to universal time
       * and doesn't use the user's time zone (effectively ignoring the HH' and mm'
       * parts of the date string).
       *
       * @param {string} input
       * @returns {Date|null}
       */
      static toDateObject(input) {
        if (!input || !isString(input)) {
          return null;
        }
        if (!pdfDateStringRegex) {
          pdfDateStringRegex = new RegExp(
            "^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"
            // Trailing apostrophe (optional)
          );
        }
        const matches = pdfDateStringRegex.exec(input);
        if (!matches) {
          return null;
        }
        const year = parseInt(matches[1], 10);
        let month = parseInt(matches[2], 10);
        month = month >= 1 && month <= 12 ? month - 1 : 0;
        let day = parseInt(matches[3], 10);
        day = day >= 1 && day <= 31 ? day : 1;
        let hour = parseInt(matches[4], 10);
        hour = hour >= 0 && hour <= 23 ? hour : 0;
        let minute = parseInt(matches[5], 10);
        minute = minute >= 0 && minute <= 59 ? minute : 0;
        let second = parseInt(matches[6], 10);
        second = second >= 0 && second <= 59 ? second : 0;
        const universalTimeRelation = matches[7] || "Z";
        let offsetHour = parseInt(matches[8], 10);
        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
        let offsetMinute = parseInt(matches[9], 10) || 0;
        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
        if (universalTimeRelation === "-") {
          hour += offsetHour;
          minute += offsetMinute;
        } else if (universalTimeRelation === "+") {
          hour -= offsetHour;
          minute -= offsetMinute;
        }
        return new Date(Date.UTC(year, month, day, hour, minute, second));
      }
    };
  }
});

// node_modules/@vaadin-component-factory/vcf-pdf-viewer/pdfjs/dist/network_utils.js
function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  tmp = rfc2231getparam(contentDisposition);
  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }
  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
  }
  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch (e) {
        if (/^utf-?8$/i.test(encoding)) {
          try {
            value = decodeURIComponent(escape(value));
            needsEncodingFixup = false;
          } catch (err) {
          }
        }
      }
    }
    return value;
  }
  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);
      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }
    return value;
  }
  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);
      if (n in matches) {
        if (n === 0) {
          break;
        }
        continue;
      }
      matches[n] = [quot, part];
    }
    const parts = [];
    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }
      let [quot, part] = matches[n];
      part = rfc2616unquote(part);
      if (quot) {
        part = unescape(part);
        if (n === 0) {
          part = rfc5987decode(part);
        }
      }
      parts.push(part);
    }
    return parts.join("");
  }
  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');
      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');
        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }
        parts[i] = parts[i].replace(/\\(.)/g, "$1");
      }
      value = parts.join('"');
    }
    return value;
  }
  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");
    if (encodingend === -1) {
      return extvalue;
    }
    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }
  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }
    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replace(/_/g, " ");
        text = text.replace(/=([0-9a-fA-F]{2})/g, function(match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }
      try {
        text = atob(text);
      } catch (e) {
      }
      return textdecode(charset, text);
    });
  }
  return "";
}
function validateRangeRequestCapabilities({
  getResponseHeader,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  assert(rangeChunkSize > 0, "Range chunk size must be larger than zero");
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: void 0
  };
  const length = parseInt(getResponseHeader("Content-Length"), 10);
  if (!Number.isInteger(length)) {
    return returnValues;
  }
  returnValues.suggestedLength = length;
  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }
  if (disableRange || !isHttp) {
    return returnValues;
  }
  if (getResponseHeader("Accept-Ranges") !== "bytes") {
    return returnValues;
  }
  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
  if (contentEncoding !== "identity") {
    return returnValues;
  }
  returnValues.allowRangeRequests = true;
  return returnValues;
}
function extractFilenameFromHeader(getResponseHeader) {
  const contentDisposition = getResponseHeader("Content-Disposition");
  if (contentDisposition) {
    let filename = getFilenameFromContentDispositionHeader(contentDisposition);
    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch (ex) {
      }
    }
    if (isPdfFile(filename)) {
      return filename;
    }
  }
  return null;
}
function createResponseStatusError(status, url) {
  if (status === 404 || status === 0 && url.startsWith("file:")) {
    return new MissingPDFException('Missing PDF "' + url + '".');
  }
  return new UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
}
function validateResponseStatus(status) {
  return status === 200 || status === 206;
}
var init_network_utils = __esm({
  "node_modules/@vaadin-component-factory/vcf-pdf-viewer/pdfjs/dist/network_utils.js"() {
    init_util();
    init_display_utils();
  }
});

export {
  BaseCanvasFactory,
  BaseCMapReaderFactory,
  BaseStandardFontDataFactory,
  DOMCanvasFactory,
  DOMCMapReaderFactory,
  DOMStandardFontDataFactory,
  DOMSVGFactory,
  PageViewport,
  RenderingCancelledException,
  LinkTarget,
  addLinkAttributes,
  isDataScheme,
  isPdfFile,
  getFilenameFromUrl,
  StatTimer,
  isValidFetchUrl,
  loadScript,
  deprecated,
  PDFDateString,
  init_display_utils,
  validateRangeRequestCapabilities,
  extractFilenameFromHeader,
  createResponseStatusError,
  validateResponseStatus,
  init_network_utils
};
//# sourceMappingURL=chunk-6YVIDVPS.js.map
