import "./chunk-NQMUQH4C.js";
import {
  announce
} from "./chunk-TBCD74S6.js";
import {
  fieldButton
} from "./chunk-MI4WOW4I.js";
import {
  isTouch
} from "./chunk-DV2EGEEG.js";
import "./chunk-5AS73FDI.js";
import "./chunk-7DHOJVCV.js";
import "./chunk-MOF77BCW.js";
import "./chunk-IHIS7TAV.js";
import {
  ElementMixin
} from "./chunk-MWSAWSJ3.js";
import "./chunk-SEGZ6IIL.js";
import "./chunk-EZVFCO5I.js";
import "./chunk-TOPBZAEH.js";
import "./chunk-LERX5ED5.js";
import "./chunk-RPOYDVPH.js";
import "./chunk-CRXJMMF2.js";
import "./chunk-EJTF7QKX.js";
import "./chunk-44TTWRW5.js";
import {
  SlotController
} from "./chunk-6C6BQOMD.js";
import "./chunk-ZPXTDJKE.js";
import "./chunk-O6KCEJHO.js";
import "./chunk-EFKWAQ3Y.js";
import {
  FocusMixin
} from "./chunk-3BRKSSC5.js";
import "./chunk-GRU2OPCY.js";
import "./chunk-HFKL6MLF.js";
import {
  ControllerMixin
} from "./chunk-QGCYTHXO.js";
import "./chunk-JQFZSNBR.js";
import "./chunk-F7YWWDDG.js";
import "./chunk-R6DBYMLB.js";
import "./chunk-BORGCLO4.js";
import "./chunk-J4OM4IIF.js";
import "./chunk-3WOFLRNV.js";
import "./chunk-J2NV7QBD.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-BBNA52CT.js";
import "./chunk-IBHXN4JT.js";
import {
  html as html2,
  render
} from "./chunk-QO3ZNG6F.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import "./chunk-B6NQGUVK.js";
import "./chunk-ER2S4LLB.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import {
  PolymerElement
} from "./chunk-4TYUW4EB.js";
import "./chunk-FXP5WKMI.js";
import "./chunk-2IE6RYOR.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import {
  html
} from "./chunk-XB4RSW42.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-WGAPYIUP.js";

// node_modules/@vaadin/upload/theme/lumo/vaadin-upload-styles.js
registerStyles(
  "vaadin-upload",
  css`
    :host {
      line-height: var(--lumo-line-height-m);
    }

    :host(:not([nodrop])) {
      overflow: hidden;
      border: 1px dashed var(--lumo-contrast-20pct);
      border-radius: var(--lumo-border-radius-l);
      padding: var(--lumo-space-m);
      transition: background-color 0.6s, border-color 0.6s;
    }

    [part='drop-label'] {
      display: inline-block;
      white-space: normal;
      padding: 0 var(--lumo-space-s);
      color: var(--lumo-secondary-text-color);
      font-family: var(--lumo-font-family);
    }

    :host([dragover-valid]) {
      border-color: var(--lumo-primary-color-50pct);
      background: var(--lumo-primary-color-10pct);
      transition: background-color 0.1s, border-color 0.1s;
    }

    :host([dragover-valid]) [part='drop-label'] {
      color: var(--lumo-primary-text-color);
    }

    :host([max-files-reached]) [part='drop-label'] {
      color: var(--lumo-disabled-text-color);
    }
  `,
  { moduleId: "lumo-upload" }
);
registerStyles(
  "vaadin-upload-icon",
  css`
    :host::before {
      content: var(--lumo-icons-upload);
      font-family: lumo-icons;
      font-size: var(--lumo-icon-size-m);
      line-height: 1;
      vertical-align: -0.25em;
    }
  `,
  { moduleId: "lumo-upload-icon" }
);
registerStyles(
  "vaadin-upload-file-list",
  css`
    ::slotted(li:not(:first-of-type)) {
      border-top: 1px solid var(--lumo-contrast-10pct);
    }
  `,
  { moduleId: "lumo-upload-file-list" }
);
var uploadFile = css`
  :host {
    padding: var(--lumo-space-s) 0;
    outline: none;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focus-ring]) [part='row'] {
    border-radius: var(--lumo-border-radius-s);
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part='row'] {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
  }

  [part='status'],
  [part='error'] {
    color: var(--lumo-secondary-text-color);
    font-size: var(--lumo-font-size-s);
  }

  [part='info'] {
    display: flex;
    align-items: baseline;
    flex: auto;
  }

  [part='meta'] {
    width: 0.001px;
    flex: 1 1 auto;
  }

  [part='name'] {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  [part='commands'] {
    display: flex;
    align-items: baseline;
    flex: none;
  }

  [part$='icon'] {
    margin-right: var(--lumo-space-xs);
    font-size: var(--lumo-icon-size-m);
    font-family: 'lumo-icons';
    line-height: 1;
  }

  /* When both icons are hidden, let us keep space for one */
  [part='done-icon'][hidden] + [part='warning-icon'][hidden] {
    display: block !important;
    visibility: hidden;
  }

  [part$='button'] {
    flex: none;
    margin-left: var(--lumo-space-xs);
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:focus {
    outline: none;
    border-radius: var(--lumo-border-radius-s);
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part$='icon']::before,
  [part$='button']::before {
    vertical-align: -0.25em;
  }

  [part='done-icon']::before {
    content: var(--lumo-icons-checkmark);
    color: var(--lumo-primary-text-color);
  }

  [part='warning-icon']::before {
    content: var(--lumo-icons-error);
    color: var(--lumo-error-text-color);
  }

  [part='start-button']::before {
    content: var(--lumo-icons-play);
  }

  [part='retry-button']::before {
    content: var(--lumo-icons-reload);
  }

  [part='remove-button']::before {
    content: var(--lumo-icons-cross);
  }

  [part='error'] {
    color: var(--lumo-error-text-color);
  }

  ::slotted([slot='progress']) {
    width: auto;
    margin-left: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
    margin-right: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
  }
`;
registerStyles("vaadin-upload-file", [fieldButton, uploadFile], { moduleId: "lumo-upload-file" });

// node_modules/@vaadin/upload/src/vaadin-upload-icon.js
var UploadIcon = class extends ThemableMixin(PolymerElement) {
  static get is() {
    return "vaadin-upload-icon";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
    `;
  }
};
defineCustomElement(UploadIcon);

// node_modules/@vaadin/upload/src/vaadin-upload-icons.js
var template = document.createElement("template");
template.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-upload-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,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) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(template.content);

// node_modules/@vaadin/upload/src/vaadin-upload-file-mixin.js
var UploadFileMixin = (superClass) => class UploadFileMixin extends FocusMixin(superClass) {
  static get properties() {
    return {
      /**
       * True if uploading is completed, false otherwise.
       */
      complete: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Error message returned by the server, if any.
       */
      errorMessage: {
        type: String,
        value: "",
        observer: "_errorMessageChanged"
      },
      /**
       * The object representing a file.
       */
      file: {
        type: Object
      },
      /**
       * Name of the uploading file.
       */
      fileName: {
        type: String
      },
      /**
       * True if uploading is not started, false otherwise.
       */
      held: {
        type: Boolean,
        value: false
      },
      /**
       * True if remaining time is unknown, false otherwise.
       */
      indeterminate: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The object used to localize this component.
       */
      i18n: {
        type: Object
      },
      /**
       * Number representing the uploading progress.
       */
      progress: {
        type: Number
      },
      /**
       * Uploading status.
       */
      status: {
        type: String
      },
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0,
        reflectToAttribute: true
      },
      /**
       * True if uploading is in progress, false otherwise.
       */
      uploading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** @private */
      _progress: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateProgress(_progress, progress, indeterminate)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new SlotController(this, "progress", "vaadin-progress-bar", {
        initializer: (progress) => {
          this._progress = progress;
        }
      })
    );
    this.shadowRoot.addEventListener("focusin", (e) => {
      const target = e.composedPath()[0];
      if (target.getAttribute("part").endsWith("button")) {
        this._setFocused(false);
      }
    });
    this.shadowRoot.addEventListener("focusout", (e) => {
      if (e.relatedTarget === this) {
        this._setFocused(true);
      }
    });
  }
  /**
   * Override method inherited from `FocusMixin` to mark the file as focused
   * only when the host is focused.
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldSetFocus(event) {
    return event.composedPath()[0] === this;
  }
  /** @private */
  _errorMessageChanged(errorMessage) {
    this.toggleAttribute("error", Boolean(errorMessage));
  }
  /** @private */
  __updateProgress(progress, value, indeterminate) {
    if (progress) {
      progress.value = isNaN(value) ? 0 : value / 100;
      progress.indeterminate = indeterminate;
    }
  }
  /** @private */
  _fireFileEvent(e) {
    e.preventDefault();
    return this.dispatchEvent(
      new CustomEvent(e.target.getAttribute("file-event"), {
        detail: { file: this.file },
        bubbles: true,
        composed: true
      })
    );
  }
};

// node_modules/@vaadin/upload/src/vaadin-upload-file-styles.js
var uploadFileStyles = css`
  :host {
    display: block;
  }

  [hidden] {
    display: none;
  }

  [part='row'] {
    list-style-type: none;
  }

  button {
    background: transparent;
    padding: 0;
    border: none;
    box-shadow: none;
  }

  :host([complete]) ::slotted([slot='progress']),
  :host([error]) ::slotted([slot='progress']) {
    display: none !important;
  }
`;

// node_modules/@vaadin/upload/src/vaadin-upload-file.js
registerStyles("vaadin-upload-file", uploadFileStyles, { moduleId: "vaadin-upload-file-styles" });
var UploadFile = class extends UploadFileMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
  static get template() {
    return html`
      <div part="row">
        <div part="info">
          <div part="done-icon" hidden$="[[!complete]]" aria-hidden="true"></div>
          <div part="warning-icon" hidden$="[[!errorMessage]]" aria-hidden="true"></div>

          <div part="meta">
            <div part="name" id="name">[[fileName]]</div>
            <div part="status" hidden$="[[!status]]" id="status">[[status]]</div>
            <div part="error" id="error" hidden$="[[!errorMessage]]">[[errorMessage]]</div>
          </div>
        </div>
        <div part="commands">
          <button
            type="button"
            part="start-button"
            file-event="file-start"
            on-click="_fireFileEvent"
            hidden$="[[!held]]"
            aria-label$="[[i18n.file.start]]"
            aria-describedby="name"
          ></button>
          <button
            type="button"
            part="retry-button"
            file-event="file-retry"
            on-click="_fireFileEvent"
            hidden$="[[!errorMessage]]"
            aria-label$="[[i18n.file.retry]]"
            aria-describedby="name"
          ></button>
          <button
            type="button"
            part="remove-button"
            file-event="file-abort"
            on-click="_fireFileEvent"
            aria-label$="[[i18n.file.remove]]"
            aria-describedby="name"
          ></button>
        </div>
      </div>

      <slot name="progress"></slot>
    `;
  }
  static get is() {
    return "vaadin-upload-file";
  }
  /**
   * Fired when the retry button is pressed. It is listened by `vaadin-upload`
   * which will start a new upload process of this file.
   *
   * @event file-retry
   * @param {Object} detail
   * @param {Object} detail.file file to retry upload of
   */
  /**
   * Fired when the start button is pressed. It is listened by `vaadin-upload`
   * which will start a new upload process of this file.
   *
   * @event file-start
   * @param {Object} detail
   * @param {Object} detail.file file to start upload of
   */
  /**
   * Fired when abort button is pressed. It is listened by `vaadin-upload` which
   * will abort the upload in progress, and then remove the file from the list.
   *
   * @event file-abort
   * @param {Object} detail
   * @param {Object} detail.file file to abort upload of
   */
};
defineCustomElement(UploadFile);

// node_modules/@vaadin/upload/src/vaadin-upload-file-list-mixin.js
var UploadFileListMixin = (superClass) => class UploadFileListMixin extends superClass {
  static get properties() {
    return {
      /**
       * The array of files being processed, or already uploaded.
       */
      items: {
        type: Array
      },
      /**
       * The object used to localize upload files.
       */
      i18n: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateItems(items, i18n)"];
  }
  /** @private */
  __updateItems(items, i18n) {
    if (items && i18n) {
      this.requestContentUpdate();
    }
  }
  /**
   * Requests an update for the `vaadin-upload-file` elements.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    const { items, i18n } = this;
    render(
      html2`
          ${items.map(
        (file) => html2`
              <li>
                <vaadin-upload-file
                  .file="${file}"
                  .complete="${file.complete}"
                  .errorMessage="${file.error}"
                  .fileName="${file.name}"
                  .held="${file.held}"
                  .indeterminate="${file.indeterminate}"
                  .progress="${file.progress}"
                  .status="${file.status}"
                  .uploading="${file.uploading}"
                  .i18n="${i18n}"
                ></vaadin-upload-file>
              </li>
            `
      )}
        `,
      this
    );
  }
};

// node_modules/@vaadin/upload/src/vaadin-upload-file-list.js
var UploadFileList = class extends UploadFileListMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-upload-file-list";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='list'] {
          padding: 0;
          margin: 0;
          list-style-type: none;
        }
      </style>
      <ul part="list">
        <slot></slot>
      </ul>
    `;
  }
};
defineCustomElement(UploadFileList);

// node_modules/@vaadin/upload/src/vaadin-upload-mixin.js
var AddButtonController = class extends SlotController {
  constructor(host) {
    super(host, "add-button", "vaadin-button");
  }
  /**
   * Override method inherited from `SlotController`
   * to add listeners to default and custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    if (node._isDefault) {
      this.defaultNode = node;
    }
    node.addEventListener("touchend", (e) => {
      this.host._onAddFilesTouchEnd(e);
    });
    node.addEventListener("click", (e) => {
      this.host._onAddFilesClick(e);
    });
    this.host._addButton = node;
  }
};
var DropLabelController = class extends SlotController {
  constructor(host) {
    super(host, "drop-label", "span");
  }
  /**
   * Override method inherited from `SlotController`
   * to add listeners to default and custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    if (node._isDefault) {
      this.defaultNode = node;
    }
    this.host._dropLabel = node;
  }
};
var UploadMixin = (superClass) => class UploadMixin extends superClass {
  static get properties() {
    return {
      /**
       * Define whether the element supports dropping files on it for uploading.
       * By default it's enabled in desktop and disabled in touch devices
       * because mobile devices do not support drag events in general. Setting
       * it false means that drop is enabled even in touch-devices, and true
       * disables drop in all devices.
       *
       * @type {boolean}
       * @default true in touch-devices, false otherwise.
       */
      nodrop: {
        type: Boolean,
        reflectToAttribute: true,
        value: isTouch
      },
      /**
       * The server URL. The default value is an empty string, which means that
       * _window.location_ will be used.
       * @type {string}
       */
      target: {
        type: String,
        value: ""
      },
      /**
       * HTTP Method used to send the files. Only POST and PUT are allowed.
       * @type {!UploadMethod}
       */
      method: {
        type: String,
        value: "POST"
      },
      /**
       * Key-Value map to send to the server. If you set this property as an
       * attribute, use a valid JSON string, for example:
       * ```
       * <vaadin-upload headers='{"X-Foo": "Bar"}'></vaadin-upload>
       * ```
       * @type {object | string}
       */
      headers: {
        type: Object,
        value: {}
      },
      /**
       * Max time in milliseconds for the entire upload process, if exceeded the
       * request will be aborted. Zero means that there is no timeout.
       * @type {number}
       */
      timeout: {
        type: Number,
        value: 0
      },
      /** @private */
      _dragover: {
        type: Boolean,
        value: false,
        observer: "_dragoverChanged"
      },
      /**
       * The array of files being processed, or already uploaded.
       *
       * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
       * object with a number of extra properties  to track the upload process:
       * - `uploadTarget`: The target URL used to upload this file.
       * - `elapsed`: Elapsed time since the upload started.
       * - `elapsedStr`: Human-readable elapsed time.
       * - `remaining`: Number of seconds remaining for the upload to finish.
       * - `remainingStr`: Human-readable remaining time for the upload to finish.
       * - `progress`: Percentage of the file already uploaded.
       * - `speed`: Upload speed in kB/s.
       * - `size`: File size in bytes.
       * - `totalStr`: Human-readable total size of the file.
       * - `loaded`: Bytes transferred so far.
       * - `loadedStr`: Human-readable uploaded size at the moment.
       * - `status`: Status of the upload process.
       * - `error`: Error message in case the upload failed.
       * - `abort`: True if the file was canceled by the user.
       * - `complete`: True when the file was transferred to the server.
       * - `uploading`: True while transferring data to the server.
       * @type {!Array<!UploadFile>}
       */
      files: {
        type: Array,
        notify: true,
        value: () => [],
        sync: true
      },
      /**
       * Limit of files to upload, by default it is unlimited. If the value is
       * set to one, native file browser will prevent selecting multiple files.
       * @attr {number} max-files
       * @type {number}
       */
      maxFiles: {
        type: Number,
        value: Infinity,
        sync: true
      },
      /**
       * Specifies if the maximum number of files have been uploaded
       * @attr {boolean} max-files-reached
       * @type {boolean}
       */
      maxFilesReached: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },
      /**
       * Specifies the types of files that the server accepts.
       * Syntax: a comma-separated list of MIME type patterns (wildcards are
       * allowed) or file extensions.
       * Notice that MIME types are widely supported, while file extensions
       * are only implemented in certain browsers, so avoid using it.
       * Example: accept="video/*,image/tiff" or accept=".pdf,audio/mp3"
       * @type {string}
       */
      accept: {
        type: String,
        value: ""
      },
      /**
       * Specifies the maximum file size in bytes allowed to upload.
       * Notice that it is a client-side constraint, which will be checked before
       * sending the request. Obviously you need to do the same validation in
       * the server-side and be sure that they are aligned.
       * @attr {number} max-file-size
       * @type {number}
       */
      maxFileSize: {
        type: Number,
        value: Infinity
      },
      /**
       * Specifies if the dragover is validated with maxFiles and
       * accept properties.
       * @private
       */
      _dragoverValid: {
        type: Boolean,
        value: false,
        observer: "_dragoverValidChanged"
      },
      /**
       * Specifies the 'name' property at Content-Disposition
       * @attr {string} form-data-name
       * @type {string}
       */
      formDataName: {
        type: String,
        value: "file"
      },
      /**
       * Prevents upload(s) from immediately uploading upon adding file(s).
       * When set, you must manually trigger uploads using the `uploadFiles` method
       * @attr {boolean} no-auto
       * @type {boolean}
       */
      noAuto: {
        type: Boolean,
        value: false
      },
      /**
       * Set the withCredentials flag on the request.
       * @attr {boolean} with-credentials
       * @type {boolean}
       */
      withCredentials: {
        type: Boolean,
        value: false
      },
      /**
       * Pass-through to input's capture attribute. Allows user to trigger device inputs
       * such as camera or microphone immediately.
       */
      capture: String,
      /**
       * The object used to localize this component.
       * For changing the default localization, change the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   dropFiles: {
       *     one: 'Drop file here',
       *     many: 'Drop files here'
       *   },
       *   addFiles: {
       *     one: 'Select File...',
       *     many: 'Upload Files...'
       *   },
       *   error: {
       *     tooManyFiles: 'Too Many Files.',
       *     fileIsTooBig: 'File is Too Big.',
       *     incorrectFileType: 'Incorrect File Type.'
       *   },
       *   uploading: {
       *     status: {
       *       connecting: 'Connecting...',
       *       stalled: 'Stalled',
       *       processing: 'Processing File...',
       *       held: 'Queued'
       *     },
       *     remainingTime: {
       *       prefix: 'remaining time: ',
       *       unknown: 'unknown remaining time'
       *     },
       *     error: {
       *       serverUnavailable: 'Server Unavailable',
       *       unexpectedServerError: 'Unexpected Server Error',
       *       forbidden: 'Forbidden'
       *     }
       *   },
       *   file: {
       *     retry: 'Retry',
       *     start: 'Start',
       *     remove: 'Remove'
       *   },
       *   units: {
       *     size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
       *     sizeBase: 1000
       *   },
       *   formatSize: function(bytes) {
       *     // returns the size followed by the best suitable unit
       *   },
       *   formatTime: function(seconds, [secs, mins, hours]) {
       *     // returns a 'HH:MM:SS' string
       *   }
       * }
       * ```
       *
       * @type {!UploadI18n}
       * @default {English}
       */
      i18n: {
        type: Object,
        value() {
          return {
            dropFiles: {
              one: "Drop file here",
              many: "Drop files here"
            },
            addFiles: {
              one: "Upload File...",
              many: "Upload Files..."
            },
            error: {
              tooManyFiles: "Too Many Files.",
              fileIsTooBig: "File is Too Big.",
              incorrectFileType: "Incorrect File Type."
            },
            uploading: {
              status: {
                connecting: "Connecting...",
                stalled: "Stalled",
                processing: "Processing File...",
                held: "Queued"
              },
              remainingTime: {
                prefix: "remaining time: ",
                unknown: "unknown remaining time"
              },
              error: {
                serverUnavailable: "Upload failed, please try again later",
                unexpectedServerError: "Upload failed due to server error",
                forbidden: "Upload forbidden"
              }
            },
            file: {
              retry: "Retry",
              start: "Start",
              remove: "Remove"
            },
            units: {
              size: ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
            }
          };
        }
      },
      /** @private */
      _addButton: {
        type: Object
      },
      /** @private */
      _dropLabel: {
        type: Object
      },
      /** @private */
      _fileList: {
        type: Object
      },
      /** @private */
      _files: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "__updateAddButton(_addButton, maxFiles, i18n, maxFilesReached)",
      "__updateDropLabel(_dropLabel, maxFiles, i18n)",
      "__updateFileList(_fileList, files, i18n)",
      "__updateMaxFilesReached(maxFiles, files)"
    ];
  }
  /** @private */
  get __acceptRegexp() {
    if (!this.accept) {
      return null;
    }
    const processedTokens = this.accept.split(",").map((token) => {
      let processedToken = token.trim();
      processedToken = processedToken.replace(/[+.]/gu, "\\$&");
      if (processedToken.startsWith("\\.")) {
        processedToken = `.*${processedToken}$`;
      }
      return processedToken.replace(/\/\*/gu, "/.*");
    });
    return new RegExp(`^(${processedTokens.join("|")})$`, "iu");
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("dragover", this._onDragover.bind(this));
    this.addEventListener("dragleave", this._onDragleave.bind(this));
    this.addEventListener("drop", this._onDrop.bind(this));
    this.addEventListener("file-retry", this._onFileRetry.bind(this));
    this.addEventListener("file-abort", this._onFileAbort.bind(this));
    this.addEventListener("file-start", this._onFileStart.bind(this));
    this.addEventListener("file-reject", this._onFileReject.bind(this));
    this.addEventListener("upload-start", this._onUploadStart.bind(this));
    this.addEventListener("upload-success", this._onUploadSuccess.bind(this));
    this.addEventListener("upload-error", this._onUploadError.bind(this));
    this._addButtonController = new AddButtonController(this);
    this.addController(this._addButtonController);
    this._dropLabelController = new DropLabelController(this);
    this.addController(this._dropLabelController);
    this.addController(
      new SlotController(this, "file-list", "vaadin-upload-file-list", {
        initializer: (list) => {
          this._fileList = list;
        }
      })
    );
    this.addController(new SlotController(this, "drop-label-icon", "vaadin-upload-icon"));
  }
  /** @private */
  _formatSize(bytes) {
    if (typeof this.i18n.formatSize === "function") {
      return this.i18n.formatSize(bytes);
    }
    const base = this.i18n.units.sizeBase || 1e3;
    const unit = ~~(Math.log(bytes) / Math.log(base));
    const dec = Math.max(0, Math.min(3, unit - 1));
    const size = parseFloat((bytes / base ** unit).toFixed(dec));
    return `${size} ${this.i18n.units.size[unit]}`;
  }
  /** @private */
  _splitTimeByUnits(time) {
    const unitSizes = [60, 60, 24, Infinity];
    const timeValues = [0];
    for (let i = 0; i < unitSizes.length && time > 0; i++) {
      timeValues[i] = time % unitSizes[i];
      time = Math.floor(time / unitSizes[i]);
    }
    return timeValues;
  }
  /** @private */
  _formatTime(seconds, split) {
    if (typeof this.i18n.formatTime === "function") {
      return this.i18n.formatTime(seconds, split);
    }
    while (split.length < 3) {
      split.push(0);
    }
    return split.reverse().map((number) => {
      return (number < 10 ? "0" : "") + number;
    }).join(":");
  }
  /** @private */
  _formatFileProgress(file) {
    const remainingTime = file.loaded > 0 ? this.i18n.uploading.remainingTime.prefix + file.remainingStr : this.i18n.uploading.remainingTime.unknown;
    return `${file.totalStr}: ${file.progress}% (${remainingTime})`;
  }
  /** @private */
  __updateMaxFilesReached(maxFiles, files) {
    this._setMaxFilesReached(maxFiles >= 0 && files.length >= maxFiles);
  }
  /** @private */
  __updateAddButton(addButton, maxFiles, i18n, maxFilesReached) {
    if (addButton) {
      addButton.disabled = maxFilesReached;
      if (addButton === this._addButtonController.defaultNode) {
        addButton.textContent = this._i18nPlural(maxFiles, i18n.addFiles);
      }
    }
  }
  /** @private */
  __updateDropLabel(dropLabel, maxFiles, i18n) {
    if (dropLabel && dropLabel === this._dropLabelController.defaultNode) {
      dropLabel.textContent = this._i18nPlural(maxFiles, i18n.dropFiles);
    }
  }
  /** @private */
  __updateFileList(list, files, i18n) {
    if (list) {
      list.items = [...files];
      list.i18n = i18n;
    }
  }
  /** @private */
  _onDragover(event) {
    event.preventDefault();
    if (!this.nodrop && !this._dragover) {
      this._dragoverValid = !this.maxFilesReached;
      this._dragover = true;
    }
    event.dataTransfer.dropEffect = !this._dragoverValid || this.nodrop ? "none" : "copy";
  }
  /** @private */
  _onDragleave(event) {
    event.preventDefault();
    if (this._dragover && !this.nodrop) {
      this._dragover = this._dragoverValid = false;
    }
  }
  /** @private */
  _onDrop(event) {
    if (!this.nodrop) {
      event.preventDefault();
      this._dragover = this._dragoverValid = false;
      this._addFiles(event.dataTransfer.files);
    }
  }
  /** @private */
  _createXhr() {
    return new XMLHttpRequest();
  }
  /** @private */
  _configureXhr(xhr) {
    if (typeof this.headers === "string") {
      try {
        this.headers = JSON.parse(this.headers);
      } catch (e) {
        this.headers = void 0;
      }
    }
    Object.entries(this.headers).forEach(([key, value]) => {
      xhr.setRequestHeader(key, value);
    });
    if (this.timeout) {
      xhr.timeout = this.timeout;
    }
    xhr.withCredentials = this.withCredentials;
  }
  /** @private */
  _setStatus(file, total, loaded, elapsed) {
    file.elapsed = elapsed;
    file.elapsedStr = this._formatTime(file.elapsed, this._splitTimeByUnits(file.elapsed));
    file.remaining = Math.ceil(elapsed * (total / loaded - 1));
    file.remainingStr = this._formatTime(file.remaining, this._splitTimeByUnits(file.remaining));
    file.speed = ~~(total / elapsed / 1024);
    file.totalStr = this._formatSize(total);
    file.loadedStr = this._formatSize(loaded);
    file.status = this._formatFileProgress(file);
  }
  /**
   * Triggers the upload of any files that are not completed
   *
   * @param {!UploadFile | !Array<!UploadFile>=} files - Files being uploaded. Defaults to all outstanding files
   */
  uploadFiles(files = this.files) {
    if (files && !Array.isArray(files)) {
      files = [files];
    }
    files = files.filter((file) => !file.complete);
    Array.prototype.forEach.call(files, this._uploadFile.bind(this));
  }
  /** @private */
  _uploadFile(file) {
    if (file.uploading) {
      return;
    }
    const ini = Date.now();
    const xhr = file.xhr = this._createXhr();
    let stalledId, last;
    xhr.upload.onprogress = (e) => {
      clearTimeout(stalledId);
      last = Date.now();
      const elapsed = (last - ini) / 1e3;
      const loaded = e.loaded, total = e.total, progress = ~~(loaded / total * 100);
      file.loaded = loaded;
      file.progress = progress;
      file.indeterminate = loaded <= 0 || loaded >= total;
      if (file.error) {
        file.indeterminate = file.status = void 0;
      } else if (!file.abort) {
        if (progress < 100) {
          this._setStatus(file, total, loaded, elapsed);
          stalledId = setTimeout(() => {
            file.status = this.i18n.uploading.status.stalled;
            this._renderFileList();
          }, 2e3);
        } else {
          file.loadedStr = file.totalStr;
          file.status = this.i18n.uploading.status.processing;
        }
      }
      this._renderFileList();
      this.dispatchEvent(new CustomEvent("upload-progress", { detail: { file, xhr } }));
    };
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        clearTimeout(stalledId);
        file.indeterminate = file.uploading = false;
        if (file.abort) {
          return;
        }
        file.status = "";
        const evt2 = this.dispatchEvent(
          new CustomEvent("upload-response", {
            detail: { file, xhr },
            cancelable: true
          })
        );
        if (!evt2) {
          return;
        }
        if (xhr.status === 0) {
          file.error = this.i18n.uploading.error.serverUnavailable;
        } else if (xhr.status >= 500) {
          file.error = this.i18n.uploading.error.unexpectedServerError;
        } else if (xhr.status >= 400) {
          file.error = this.i18n.uploading.error.forbidden;
        }
        file.complete = !file.error;
        this.dispatchEvent(
          new CustomEvent(`upload-${file.error ? "error" : "success"}`, {
            detail: { file, xhr }
          })
        );
        this._renderFileList();
      }
    };
    const formData = new FormData();
    file.uploadTarget = file.uploadTarget || this.target || "";
    file.formDataName = this.formDataName;
    const evt = this.dispatchEvent(
      new CustomEvent("upload-before", {
        detail: { file, xhr },
        cancelable: true
      })
    );
    if (!evt) {
      return;
    }
    formData.append(file.formDataName, file, file.name);
    xhr.open(this.method, file.uploadTarget, true);
    this._configureXhr(xhr);
    file.status = this.i18n.uploading.status.connecting;
    file.uploading = file.indeterminate = true;
    file.complete = file.abort = file.error = file.held = false;
    xhr.upload.onloadstart = () => {
      this.dispatchEvent(
        new CustomEvent("upload-start", {
          detail: { file, xhr }
        })
      );
      this._renderFileList();
    };
    const uploadEvt = this.dispatchEvent(
      new CustomEvent("upload-request", {
        detail: { file, xhr, formData },
        cancelable: true
      })
    );
    if (uploadEvt) {
      xhr.send(formData);
    }
  }
  /** @private */
  _retryFileUpload(file) {
    const evt = this.dispatchEvent(
      new CustomEvent("upload-retry", {
        detail: { file, xhr: file.xhr },
        cancelable: true
      })
    );
    if (evt) {
      this._uploadFile(file);
    }
  }
  /** @private */
  _abortFileUpload(file) {
    const evt = this.dispatchEvent(
      new CustomEvent("upload-abort", {
        detail: { file, xhr: file.xhr },
        cancelable: true
      })
    );
    if (evt) {
      file.abort = true;
      if (file.xhr) {
        file.xhr.abort();
      }
      this._removeFile(file);
    }
  }
  /** @private */
  _renderFileList() {
    if (this._fileList) {
      this._fileList.requestContentUpdate();
    }
  }
  /** @private */
  _addFiles(files) {
    Array.prototype.forEach.call(files, this._addFile.bind(this));
  }
  /**
   * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.
   *
   * @param {!UploadFile} file File being added
   * @protected
   */
  _addFile(file) {
    if (this.maxFilesReached) {
      this.dispatchEvent(
        new CustomEvent("file-reject", {
          detail: { file, error: this.i18n.error.tooManyFiles }
        })
      );
      return;
    }
    if (this.maxFileSize >= 0 && file.size > this.maxFileSize) {
      this.dispatchEvent(
        new CustomEvent("file-reject", {
          detail: { file, error: this.i18n.error.fileIsTooBig }
        })
      );
      return;
    }
    const re = this.__acceptRegexp;
    if (re && !(re.test(file.type) || re.test(file.name))) {
      this.dispatchEvent(
        new CustomEvent("file-reject", {
          detail: { file, error: this.i18n.error.incorrectFileType }
        })
      );
      return;
    }
    file.loaded = 0;
    file.held = true;
    file.status = this.i18n.uploading.status.held;
    this.files = [file, ...this.files];
    if (!this.noAuto) {
      this._uploadFile(file);
    }
  }
  /**
   * Remove file from upload list. Called internally if file upload was canceled.
   * @param {!UploadFile} file File to remove
   * @protected
   */
  _removeFile(file) {
    if (this.files.indexOf(file) > -1) {
      this.files = this.files.filter((i) => i !== file);
      this.dispatchEvent(
        new CustomEvent("file-remove", {
          detail: { file },
          bubbles: true,
          composed: true
        })
      );
    }
  }
  /** @private */
  _onAddFilesTouchEnd(e) {
    e.preventDefault();
    this._onAddFilesClick(e);
  }
  /** @private */
  _onAddFilesClick(e) {
    if (this.maxFilesReached) {
      return;
    }
    e.stopPropagation();
    this.$.fileInput.value = "";
    this.$.fileInput.click();
  }
  /** @private */
  _onFileInputChange(event) {
    this._addFiles(event.target.files);
  }
  /** @private */
  _onFileStart(event) {
    this._uploadFile(event.detail.file);
  }
  /** @private */
  _onFileRetry(event) {
    this._retryFileUpload(event.detail.file);
  }
  /** @private */
  _onFileAbort(event) {
    this._abortFileUpload(event.detail.file);
  }
  /** @private */
  _onFileReject(event) {
    announce(`${event.detail.file.name}: ${event.detail.error}`, { mode: "alert" });
  }
  /** @private */
  _onUploadStart(event) {
    announce(`${event.detail.file.name}: 0%`, { mode: "alert" });
  }
  /** @private */
  _onUploadSuccess(event) {
    announce(`${event.detail.file.name}: 100%`, { mode: "alert" });
  }
  /** @private */
  _onUploadError(event) {
    announce(`${event.detail.file.name}: ${event.detail.file.error}`, { mode: "alert" });
  }
  /** @private */
  _dragoverChanged(dragover) {
    if (dragover) {
      this.setAttribute("dragover", dragover);
    } else {
      this.removeAttribute("dragover");
    }
  }
  /** @private */
  _dragoverValidChanged(dragoverValid) {
    if (dragoverValid) {
      this.setAttribute("dragover-valid", dragoverValid);
    } else {
      this.removeAttribute("dragover-valid");
    }
  }
  /** @private */
  _i18nPlural(value, plural) {
    return value === 1 ? plural.one : plural.many;
  }
  /** @protected */
  _isMultiple(maxFiles) {
    return maxFiles !== 1;
  }
};

// node_modules/@vaadin/upload/src/vaadin-upload.js
var Upload = class extends UploadMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          position: relative;
          box-sizing: border-box;
        }

        :host([hidden]) {
          display: none !important;
        }

        [hidden] {
          display: none !important;
        }
      </style>

      <div part="primary-buttons">
        <slot name="add-button"></slot>
        <div part="drop-label" hidden$="[[nodrop]]" id="dropLabelContainer" aria-hidden="true">
          <slot name="drop-label-icon"></slot>
          <slot name="drop-label"></slot>
        </div>
      </div>
      <slot name="file-list"></slot>
      <slot></slot>
      <input
        type="file"
        id="fileInput"
        hidden
        on-change="_onFileInputChange"
        accept$="{{accept}}"
        multiple$="[[_isMultiple(maxFiles)]]"
        capture$="[[capture]]"
      />
    `;
  }
  static get is() {
    return "vaadin-upload";
  }
  /**
   * Fired when a file cannot be added to the queue due to a constrain:
   *  file-size, file-type or maxFiles
   *
   * @event file-reject
   * @param {Object} detail
   * @param {Object} detail.file the file added
   * @param {string} detail.error the cause
   */
  /**
   * Fired before the XHR is opened. Could be used for changing the request
   * URL. If the default is prevented, then XHR would not be opened.
   *
   * @event upload-before
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   * @param {Object} detail.file.uploadTarget the upload request URL, initialized with the value of vaadin-upload `target` property
   */
  /**
   * Fired when the XHR has been opened but not sent yet. Useful for appending
   * data keys to the FormData object, for changing some parameters like
   * headers, etc. If the event is defaultPrevented, `vaadin-upload` will not
   * send the request allowing the user to do something on his own.
   *
   * @event upload-request
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   * @param {Object} detail.formData the FormData object
   */
  /**
   * Fired when the XHR is sent.
   *
   * @event upload-start
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired as many times as the progress is updated.
   *
   * @event upload-progress
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded with loaded info
   */
  /**
   * Fired when we have the actual server response, and before the component
   * analyses it. It's useful for developers to make the upload fail depending
   * on the server response. If the event is defaultPrevented the vaadin-upload
   * will return allowing the user to do something on his own like retry the
   * upload, etc. since he has full access to the `xhr` and `file` objects.
   * Otherwise, if the event is not prevented default `vaadin-upload` continues
   * with the normal workflow checking the `xhr.status` and `file.error`
   * which also might be modified by the user to force a customized response.
   *
   * @event upload-response
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired in case the upload process succeed.
   *
   * @event upload-success
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded with loaded info
   */
  /**
   * Fired in case the upload process failed.
   *
   * @event upload-error
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired when retry upload is requested. If the default is prevented, then
   * retry would not be performed.
   *
   * @event upload-retry
   * @param {Object} detail
   * @param {Object} detail.xhr the previous upload xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired when retry abort is requested. If the default is prevented, then the
   * file upload would not be aborted.
   *
   * @event upload-abort
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
};
defineCustomElement(Upload);
/*! Bundled license information:

@vaadin/upload/src/vaadin-upload-icon.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/upload/src/vaadin-upload-icons.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/upload/src/vaadin-upload-file-mixin.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/upload/src/vaadin-upload-file-styles.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/upload/src/vaadin-upload-file.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/upload/src/vaadin-upload-file-list-mixin.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/upload/src/vaadin-upload-file-list.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/upload/src/vaadin-upload-mixin.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/upload/src/vaadin-upload.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=@vaadin_upload_theme_lumo_vaadin-upload__js.js.map
