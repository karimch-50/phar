import "./chunk-WCUVPZ2J.js";
import {
  FieldMixin
} from "./chunk-ME67HVVO.js";
import "./chunk-NJXIHJ3Q.js";
import "./chunk-XWHFZQ32.js";
import "./chunk-R5IZNLSA.js";
import "./chunk-GV4NWW2U.js";
import {
  ElementMixin
} from "./chunk-MWSAWSJ3.js";
import "./chunk-SEGZ6IIL.js";
import {
  KeyboardMixin
} from "./chunk-EJTF7QKX.js";
import "./chunk-O6KCEJHO.js";
import "./chunk-HFKL6MLF.js";
import {
  TooltipController
} from "./chunk-44TTWRW5.js";
import "./chunk-6C6BQOMD.js";
import "./chunk-ZPXTDJKE.js";
import {
  FocusMixin
} from "./chunk-3BRKSSC5.js";
import "./chunk-EFKWAQ3Y.js";
import {
  getFlattenedElements
} from "./chunk-GRU2OPCY.js";
import "./chunk-JQFZSNBR.js";
import "./chunk-QGCYTHXO.js";
import "./chunk-F7YWWDDG.js";
import "./chunk-R6DBYMLB.js";
import "./chunk-BORGCLO4.js";
import "./chunk-3WOFLRNV.js";
import "./chunk-J2NV7QBD.js";
import "./chunk-J4OM4IIF.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-BBNA52CT.js";
import "./chunk-25Y4ITXF.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import "./chunk-QO3ZNG6F.js";
import "./chunk-B6NQGUVK.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import "./chunk-ER2S4LLB.js";
import {
  PolymerElement
} from "./chunk-4TYUW4EB.js";
import "./chunk-FXP5WKMI.js";
import "./chunk-2IE6RYOR.js";
import {
  html
} from "./chunk-XB4RSW42.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-WGAPYIUP.js";

// node_modules/@vaadin/custom-field/src/vaadin-custom-field-mixin.js
var defaultParseValue = (value) => {
  return value.split("	");
};
var defaultFormatValue = (inputValues) => {
  return inputValues.join("	");
};
var CustomFieldMixin = (superClass) => class CustomFieldMixin extends FieldMixin(FocusMixin(KeyboardMixin(superClass))) {
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: String,
      /**
       * The value of the field. When wrapping several inputs, it will contain `\t`
       * (Tab character) as a delimiter indicating parts intended to be used as the
       * corresponding inputs values.
       * Use the [`formatValue`](#/elements/vaadin-custom-field#property-formatValue)
       * and [`parseValue`](#/elements/vaadin-custom-field#property-parseValue)
       * properties to customize this behavior.
       */
      value: {
        type: String,
        observer: "__valueChanged",
        notify: true
      },
      /**
       * Array of available input nodes
       * @type {!Array<!HTMLElement> | undefined}
       */
      inputs: {
        type: Array,
        readOnly: true
      },
      /**
       * A function to format the values of the individual fields contained by
       * the custom field into a single component value. The function receives
       * an array of all values of the individual fields in the order of their
       * presence in the DOM, and must return a single component value.
       * This function is called each time a value of an internal field is
       * changed.
       *
       * Example:
       * ```js
       * customField.formatValue = (fieldValues) => {
       *   return fieldValues.join("-");
       * }
       * ```
       * @type {!CustomFieldFormatValueFn | undefined}
       */
      formatValue: {
        type: Function
      },
      /**
       * A function to parse the component value into values for the individual
       * fields contained by the custom field. The function receives the
       * component value, and must return an array of values for the individual
       * fields in the order of their presence in the DOM.
       * The function is called each time the value of the component changes.
       *
       * Example:
       * ```js
       * customField.parseValue = (componentValue) => {
       *   return componentValue.split("-");
       * }
       * ```
       * @type {!CustomFieldParseValueFn | undefined}
       */
      parseValue: {
        type: Function
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "group");
    this.ariaTarget = this;
    this.__childrenObserver = new MutationObserver(() => {
      this.__setInputsFromSlot();
    });
    this.__setInputsFromSlot();
    this.$.slot.addEventListener("slotchange", () => {
      this.__setInputsFromSlot();
      getFlattenedElements(this.$.slot).filter((el) => !this.__isInput(el)).forEach((el) => {
        this.__childrenObserver.observe(el, { childList: true });
      });
    });
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setShouldShow((target) => {
      const inputs = target.inputs || [];
      return !inputs.some((el) => el.opened);
    });
  }
  /** @protected */
  focus() {
    if (this.inputs && this.inputs[0]) {
      this.inputs[0].focus();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves to another input in the custom field.
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    const { relatedTarget } = event;
    return !this.inputs.some((el) => relatedTarget === (el.focusElement || el));
  }
  /**
   * Returns true if the current inputs values satisfy all constraints (if any).
   *
   * @return {boolean}
   */
  checkValidity() {
    const invalidFields = this.inputs.filter((input) => !(input.validate || input.checkValidity).call(input));
    if (invalidFields.length || this.required && !this.value.trim()) {
      return false;
    }
    return true;
  }
  /**
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e) {
    if (e.key === "Tab") {
      if (this.inputs.indexOf(e.target) < this.inputs.length - 1 && !e.shiftKey || this.inputs.indexOf(e.target) > 0 && e.shiftKey) {
        this.dispatchEvent(new CustomEvent("internal-tab"));
      } else {
        this.__setValue();
      }
    }
  }
  /** @protected */
  _onInputChange(event) {
    event.stopPropagation();
    this.__setValue();
    this.validate();
    this.dispatchEvent(
      new CustomEvent("change", {
        bubbles: true,
        cancelable: false,
        detail: {
          value: this.value
        }
      })
    );
  }
  /** @private */
  __setValue() {
    this.__settingValue = true;
    const formatFn = this.formatValue || defaultFormatValue;
    this.value = formatFn.apply(this, [this.inputs.map((input) => input.value)]);
    this.__settingValue = false;
  }
  /** @private */
  __isInput(node) {
    const isSlottedInput = node.getAttribute("slot") === "input" || node.getAttribute("slot") === "textarea";
    return !isSlottedInput && (node.validate || node.checkValidity);
  }
  /** @private */
  __getInputsFromSlot() {
    return getFlattenedElements(this.$.slot).filter((node) => this.__isInput(node));
  }
  /** @private */
  __setInputsFromSlot() {
    this._setInputs(this.__getInputsFromSlot());
    this.__setValue();
  }
  /** @private */
  __toggleHasValue(value) {
    this.toggleAttribute("has-value", value !== null && value.trim() !== "");
  }
  /** @private */
  __valueChanged(value, oldValue) {
    if (this.__settingValue || !this.inputs) {
      return;
    }
    this.__toggleHasValue(value);
    const parseFn = this.parseValue || defaultParseValue;
    const valuesArray = parseFn.apply(this, [value]);
    if (!valuesArray || valuesArray.length === 0) {
      console.warn("Value parser has not provided values array");
      return;
    }
    this.inputs.forEach((input, id) => {
      input.value = valuesArray[id];
    });
    if (oldValue !== void 0) {
      this.validate();
    }
  }
};

// node_modules/@vaadin/custom-field/src/vaadin-custom-field-styles.js
var customFieldStyles = css`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
           to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-custom-field-container {
    width: 100%;
    display: flex;
    flex-direction: column;
  }

  .inputs-wrapper {
    flex: none;
  }
`;

// node_modules/@vaadin/custom-field/src/vaadin-custom-field.js
registerStyles("vaadin-custom-field", customFieldStyles, { moduleId: "vaadin-custom-field-styles" });
var CustomField = class extends CustomFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-custom-field";
  }
  static get template() {
    return html`
      <div class="vaadin-custom-field-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="inputs-wrapper" part="input-fields" on-change="_onInputChange">
          <slot id="slot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  /**
   * Fired when the user commits a value change for any of the internal inputs.
   *
   * @event change
   */
};
defineCustomElement(CustomField);
/*! Bundled license information:

@vaadin/custom-field/src/vaadin-custom-field-mixin.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/custom-field/src/vaadin-custom-field-styles.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/custom-field/src/vaadin-custom-field.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/custom-field/theme/lumo/vaadin-custom-field.js:
  (**
   * @license
   * Copyright (c) 2019 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=@vaadin_custom-field_theme_lumo_vaadin-custom-field__js.js.map
