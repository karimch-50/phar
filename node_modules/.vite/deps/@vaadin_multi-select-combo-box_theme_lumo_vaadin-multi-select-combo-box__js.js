import {
  Overlay
} from "./chunk-F6I6TNT2.js";
import {
  ComboBoxDataProviderMixin
} from "./chunk-NND2WSOD.js";
import {
  ComboBoxItemMixin,
  ComboBoxMixin,
  ComboBoxOverlayMixin,
  ComboBoxScrollerMixin,
  comboBoxItem,
  comboBoxLoader,
  comboBoxOverlay
} from "./chunk-DDM4F425.js";
import {
  loader
} from "./chunk-24TDNNNQ.js";
import "./chunk-LHRZSTHO.js";
import "./chunk-BVOJNHKU.js";
import {
  ComboBoxPlaceholder
} from "./chunk-Y6UIPY5B.js";
import "./chunk-54ADOYDD.js";
import {
  announce
} from "./chunk-TBCD74S6.js";
import {
  InputControlMixin,
  inputFieldShared as inputFieldShared2
} from "./chunk-H67WQYV4.js";
import {
  InputContainer,
  inputFieldShared
} from "./chunk-WCEMJP5Y.js";
import {
  fieldButton
} from "./chunk-MI4WOW4I.js";
import "./chunk-TP3SG6KP.js";
import {
  processTemplates
} from "./chunk-3TOJB423.js";
import {
  item
} from "./chunk-ELPZA6KY.js";
import {
  menuOverlayCore
} from "./chunk-UY4FDBB3.js";
import "./chunk-A2UCFRVY.js";
import "./chunk-BGWLAHRF.js";
import {
  overlay
} from "./chunk-UFBVVQ65.js";
import "./chunk-HYO4DUYL.js";
import "./chunk-PJNJQYXC.js";
import "./chunk-ZE63AH6T.js";
import "./chunk-TH3SXEA2.js";
import "./chunk-DV2EGEEG.js";
import "./chunk-FSP2XZVR.js";
import {
  ResizeMixin
} from "./chunk-2JVJNHM2.js";
import "./chunk-ME67HVVO.js";
import "./chunk-NJXIHJ3Q.js";
import "./chunk-XWHFZQ32.js";
import {
  InputController
} from "./chunk-V7EIQ2IZ.js";
import {
  LabelledInputController
} from "./chunk-PMRFEKRS.js";
import "./chunk-R5IZNLSA.js";
import "./chunk-IDC7WHOS.js";
import "./chunk-TVB6PYW6.js";
import "./chunk-GV4NWW2U.js";
import {
  ElementMixin
} from "./chunk-MWSAWSJ3.js";
import "./chunk-SEGZ6IIL.js";
import "./chunk-TOPBZAEH.js";
import "./chunk-EZVFCO5I.js";
import "./chunk-CRXJMMF2.js";
import "./chunk-EJTF7QKX.js";
import "./chunk-O6KCEJHO.js";
import "./chunk-HFKL6MLF.js";
import {
  TooltipController
} from "./chunk-44TTWRW5.js";
import {
  SlotController
} from "./chunk-6C6BQOMD.js";
import "./chunk-ZPXTDJKE.js";
import "./chunk-3BRKSSC5.js";
import "./chunk-EFKWAQ3Y.js";
import "./chunk-GRU2OPCY.js";
import "./chunk-JQFZSNBR.js";
import "./chunk-QGCYTHXO.js";
import "./chunk-F7YWWDDG.js";
import "./chunk-R6DBYMLB.js";
import "./chunk-BORGCLO4.js";
import "./chunk-3WOFLRNV.js";
import "./chunk-J2NV7QBD.js";
import "./chunk-J4OM4IIF.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-BBNA52CT.js";
import "./chunk-25Y4ITXF.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import "./chunk-QO3ZNG6F.js";
import {
  DirMixin
} from "./chunk-B6NQGUVK.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import "./chunk-ER2S4LLB.js";
import {
  PolymerElement
} from "./chunk-4TYUW4EB.js";
import "./chunk-FXP5WKMI.js";
import "./chunk-2IE6RYOR.js";
import {
  html
} from "./chunk-XB4RSW42.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-WGAPYIUP.js";

// node_modules/@vaadin/multi-select-combo-box/theme/lumo/vaadin-multi-select-combo-box-chip-styles.js
var chip = css`
  :host {
    font-size: var(--lumo-font-size-xxs);
    line-height: 1;
    color: var(--lumo-body-text-color);
    border-radius: var(--lumo-border-radius-s);
    background-color: var(--lumo-contrast-20pct);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  :host([focused]) [part='remove-button'] {
    color: inherit;
  }

  :host([slot='overflow']) {
    position: relative;
    min-width: var(--lumo-size-xxs);
    margin-inline-start: var(--lumo-space-s);
  }

  :host([slot='overflow'])::before,
  :host([slot='overflow'])::after {
    position: absolute;
    content: '';
    width: 100%;
    height: 100%;
    border-left: calc(var(--lumo-space-s) / 4) solid;
    border-radius: var(--lumo-border-radius-s);
    border-color: var(--lumo-contrast-30pct);
  }

  :host([slot='overflow'])::before {
    left: calc(-1 * var(--lumo-space-s) / 2);
  }

  :host([slot='overflow'])::after {
    left: calc(-1 * var(--lumo-space-s));
  }

  :host([count='2']) {
    margin-inline-start: calc(var(--lumo-space-s) / 2);
  }

  :host([count='2'])::after {
    display: none;
  }

  :host([count='1']) {
    margin-inline-start: 0;
  }

  :host([count='1'])::before,
  :host([count='1'])::after {
    display: none;
  }

  [part='label'] {
    font-weight: 500;
    line-height: 1.25;
  }

  [part='remove-button'] {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: -0.3125em;
    margin-bottom: -0.3125em;
    margin-inline-start: auto;
    width: 1.25em;
    height: 1.25em;
    font-size: 1.5em;
    transition: none;
  }

  [part='remove-button']::before {
    content: var(--lumo-icons-cross);
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
    pointer-events: none;
  }
`;
registerStyles("vaadin-multi-select-combo-box-chip", [fieldButton, chip], {
  moduleId: "lumo-multi-select-combo-box-chip"
});

// node_modules/@vaadin/multi-select-combo-box/theme/lumo/vaadin-multi-select-combo-box-styles.js
var multiSelectComboBoxItem = css`
  @media (any-hover: hover) {
    :host(:hover[readonly]) {
      background-color: transparent;
      cursor: default;
    }
  }
`;
registerStyles("vaadin-multi-select-combo-box-item", [item, comboBoxItem, multiSelectComboBoxItem], {
  moduleId: "lumo-multi-select-combo-box-item"
});
registerStyles(
  "vaadin-multi-select-combo-box-overlay",
  [
    overlay,
    menuOverlayCore,
    comboBoxOverlay,
    loader,
    comboBoxLoader,
    css`
      :host {
        --_vaadin-multi-select-combo-box-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-multi-select-combo-box-items-container-border-style: solid;
      }
    `
  ],
  { moduleId: "lumo-multi-select-combo-box-overlay" }
);
registerStyles(
  "vaadin-multi-select-combo-box-container",
  css`
    :host([auto-expand-vertically]) {
      padding-block: var(--lumo-space-xs);
    }
  `,
  { moduleId: "lumo-multi-select-combo-box-container" }
);
var multiSelectComboBox = css`
  :host([has-value]) {
    padding-inline-start: 0;
  }

  :host([has-value]) ::slotted(input:placeholder-shown) {
    caret-color: var(--lumo-body-text-color) !important;
  }

  [part='label'] {
    flex-shrink: 0;
  }

  /* Override input-container styles */
  ::slotted([slot='chip']),
  ::slotted([slot='overflow']) {
    min-height: auto;
    padding: 0.3125em calc(0.5em + var(--lumo-border-radius-s) / 4);
    color: var(--lumo-body-text-color);
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([auto-expand-vertically]) ::slotted([slot='chip']) {
    margin-block: calc(var(--lumo-space-xs) / 2);
  }

  ::slotted([slot='chip']:not([readonly]):not([disabled])) {
    padding-inline-end: 0;
  }

  :host([auto-expand-vertically]) ::slotted([slot='input']) {
    min-height: calc(var(--lumo-text-field-size, var(--lumo-size-m)) - 2 * var(--lumo-space-xs));
  }

  ::slotted([slot='chip']:not(:last-of-type)),
  ::slotted([slot='overflow']:not(:last-of-type)) {
    margin-inline-end: var(--lumo-space-xs);
  }

  ::slotted([slot='chip'][focused]) {
    background-color: var(--vaadin-selection-color, var(--lumo-primary-color));
    color: var(--lumo-primary-contrast-color);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }

  :host([readonly][has-value]) [part='toggle-button'] {
    color: var(--lumo-contrast-60pct);
    cursor: var(--lumo-clickable-cursor);
  }
`;
registerStyles("vaadin-multi-select-combo-box", [inputFieldShared, multiSelectComboBox], {
  moduleId: "lumo-multi-select-combo-box"
});

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-chip.js
var MultiSelectComboBoxChip = class extends ThemableMixin(PolymerElement) {
  static get is() {
    return "vaadin-multi-select-combo-box-chip";
  }
  static get properties() {
    return {
      disabled: {
        type: Boolean,
        reflectToAttribute: true
      },
      readonly: {
        type: Boolean,
        reflectToAttribute: true
      },
      label: {
        type: String
      },
      item: {
        type: Object
      }
    };
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
          align-items: center;
          align-self: center;
          white-space: nowrap;
          box-sizing: border-box;
        }

        [part='label'] {
          overflow: hidden;
          text-overflow: ellipsis;
        }

        :host([hidden]),
        :host(:is([readonly], [disabled], [slot='overflow'])) [part='remove-button'] {
          display: none !important;
        }

        @media (forced-colors: active) {
          :host {
            outline: 1px solid;
            outline-offset: -1px;
          }
        }
      </style>
      <div part="label">[[label]]</div>
      <div part="remove-button" on-click="_onRemoveClick"></div>
    `;
  }
  /** @private */
  _onRemoveClick(event) {
    event.stopPropagation();
    this.dispatchEvent(
      new CustomEvent("item-removed", {
        detail: {
          item: this.item
        },
        bubbles: true,
        composed: true
      })
    );
  }
};
defineCustomElement(MultiSelectComboBoxChip);

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-container.js
registerStyles(
  "vaadin-multi-select-combo-box-container",
  css`
    #wrapper {
      display: flex;
      width: 100%;
      min-width: 0;
    }

    :host([auto-expand-vertically]) #wrapper {
      flex-wrap: wrap;
    }
  `,
  {
    moduleId: "vaadin-multi-select-combo-box-container-styles"
  }
);
var memoizedTemplate;
var MultiSelectComboBoxContainer = class extends InputContainer {
  static get is() {
    return "vaadin-multi-select-combo-box-container";
  }
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      const content = memoizedTemplate.content;
      const slots = content.querySelectorAll("slot");
      const wrapper = document.createElement("div");
      wrapper.setAttribute("id", "wrapper");
      content.insertBefore(wrapper, slots[2]);
      wrapper.appendChild(slots[0]);
      wrapper.appendChild(slots[1]);
    }
    return memoizedTemplate;
  }
  static get properties() {
    return {
      /**
       * Set to true to not collapse selected items chips into the overflow
       * chip and instead always expand vertically, causing input field to
       * wrap into multiple lines when width is limited.
       * @attr {boolean} auto-expand-vertically
       */
      autoExpandVertically: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
};
defineCustomElement(MultiSelectComboBoxContainer);

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-item.js
var MultiSelectComboBoxItem = class extends ComboBoxItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-multi-select-combo-box-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
};
defineCustomElement(MultiSelectComboBoxItem);

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-overlay.js
registerStyles(
  "vaadin-multi-select-combo-box-overlay",
  css`
    #overlay {
      width: var(
        --vaadin-multi-select-combo-box-overlay-width,
        var(--_vaadin-multi-select-combo-box-overlay-default-width, auto)
      );
    }

    [part='content'] {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
  `,
  { moduleId: "vaadin-multi-select-combo-box-overlay-styles" }
);
var memoizedTemplate2;
var MultiSelectComboBoxOverlay = class extends ComboBoxOverlayMixin(Overlay) {
  static get is() {
    return "vaadin-multi-select-combo-box-overlay";
  }
  static get template() {
    if (!memoizedTemplate2) {
      memoizedTemplate2 = super.template.cloneNode(true);
      const overlay2 = memoizedTemplate2.content.querySelector('[part~="overlay"]');
      overlay2.removeAttribute("tabindex");
      const loader2 = document.createElement("div");
      loader2.setAttribute("part", "loader");
      overlay2.insertBefore(loader2, overlay2.firstElementChild);
    }
    return memoizedTemplate2;
  }
};
defineCustomElement(MultiSelectComboBoxOverlay);

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-scroller.js
var MultiSelectComboBoxScroller = class extends ComboBoxScrollerMixin(PolymerElement) {
  static get is() {
    return "vaadin-multi-select-combo-box-scroller";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-multi-select-combo-box-items-container-border-width);
          border-style: var(--_vaadin-multi-select-combo-box-items-container-border-style);
          border-color: var(--_vaadin-multi-select-combo-box-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("aria-multiselectable", "true");
  }
  /**
   * @protected
   * @override
   */
  _isItemSelected(item2, _selectedItem, itemIdPath) {
    if (item2 instanceof ComboBoxPlaceholder) {
      return false;
    }
    if (this.owner.readonly) {
      return false;
    }
    return this.owner._findIndex(item2, this.owner.selectedItems, itemIdPath) > -1;
  }
  /**
   * @param {HTMLElement} el
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(el, index) {
    super._updateElement(el, index);
    el.toggleAttribute("readonly", this.owner.readonly);
  }
};
defineCustomElement(MultiSelectComboBoxScroller);

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-internal.js
var MultiSelectComboBoxInternal = class extends ComboBoxDataProviderMixin(ComboBoxMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-multi-select-combo-box-internal";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-multi-select-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_target]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-multi-select-combo-box-overlay>
    `;
  }
  static get properties() {
    return {
      /**
       * A subset of items, filtered based on the user input.
       */
      filteredItems: {
        type: Array,
        notify: true
      },
      /**
       * When set to `true`, "loading" attribute is set
       * on the host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        notify: true
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        notify: true
      },
      /**
       * Selected items to render in the dropdown
       * when the component is read-only.
       */
      selectedItems: {
        type: Array,
        value: () => []
      },
      /**
       * Set to true to group selected items at the top of the overlay.
       * @attr {boolean} selected-items-on-top
       */
      selectedItemsOnTop: {
        type: Boolean,
        value: false
      },
      /**
       * Last input value entered by the user before value is updated.
       * Used to store `filter` property value before clearing it.
       */
      lastFilter: {
        type: String,
        notify: true
      },
      /**
       * A subset of items to be shown at the top of the overlay.
       */
      topGroup: {
        type: Array,
        observer: "_topGroupChanged"
      },
      _target: {
        type: Object
      }
    };
  }
  /**
   * Reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.querySelector('[part="clear-button"]');
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-multi-select-combo-box";
  }
  /**
   * Override method inherited from the combo-box
   * to allow opening dropdown when readonly.
   * @override
   */
  open() {
    if (!this.disabled && !(this.readonly && this.selectedItems.length === 0)) {
      this.opened = true;
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this._target = this;
    this._toggleElement = this.querySelector(".toggle-button");
  }
  /**
   * Override combo-box method to group selected
   * items at the top of the overlay.
   *
   * @protected
   * @override
   */
  _setDropdownItems(items) {
    if (this.readonly) {
      this._dropdownItems = this.selectedItems;
      return;
    }
    if (this.filter || !this.selectedItemsOnTop) {
      this._dropdownItems = items;
      return;
    }
    if (items && items.length && this.topGroup && this.topGroup.length) {
      const filteredItems = items.filter(
        (item2) => this._comboBox._findIndex(item2, this.topGroup, this.itemIdPath) === -1
      );
      this._dropdownItems = this.topGroup.concat(filteredItems);
      return;
    }
    this._dropdownItems = items;
  }
  /** @private */
  _topGroupChanged(topGroup) {
    if (topGroup) {
      this._setDropdownItems(this.filteredItems);
    }
  }
  /**
   * Override combo-box method to set correct owner for using by item renderers.
   * This needs to be done before the scroller gets added to the DOM to ensure
   * Lit directive works in case when combo-box is opened using attribute.
   *
   * @protected
   * @override
   */
  _initScroller() {
    const comboBox = this.getRootNode().host;
    this._comboBox = comboBox;
    super._initScroller(comboBox);
  }
  /**
   * Override Enter handler to keep overlay open
   * when item is selected or unselected.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEnter(event) {
    if (this.opened) {
      event.preventDefault();
      event.stopPropagation();
      if (this.readonly) {
        this.close();
      } else if (this._hasValidInputValue()) {
        const focusedItem = this._dropdownItems[this._focusedIndex];
        this._commitValue();
        this._focusedIndex = this._dropdownItems.indexOf(focusedItem);
      }
      return;
    }
    super._onEnter(event);
  }
  /**
   * Override Escape handler to not clear
   * selected items when readonly.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.readonly) {
      event.stopPropagation();
      if (this.opened) {
        this.close();
      }
      return;
    }
    super._onEscape(event);
  }
  /**
   * @protected
   * @override
   */
  _commitValue() {
    this.lastFilter = this.filter;
    super._commitValue();
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowDown() {
    if (!this.readonly) {
      super._onArrowDown();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowUp() {
    if (!this.readonly) {
      super._onArrowUp();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to close dropdown on blur when readonly.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    if (!focused) {
      this._ignoreCommitValue = true;
    }
    super._setFocused(focused);
    if (!focused && this.readonly && !this._closeOnBlurIsPrevented) {
      this.close();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not commit an already selected item again
   * on blur, which would result in un-selecting.
   * @protected
   * @override
   */
  _detectAndDispatchChange() {
    if (this._ignoreCommitValue) {
      this._ignoreCommitValue = false;
      this.selectedItem = null;
      this._inputElementValue = "";
      return;
    }
    super._detectAndDispatchChange();
  }
  /**
   * @param {CustomEvent} event
   * @protected
   * @override
   */
  _overlaySelectedItemChanged(event) {
    event.stopPropagation();
    if (this.readonly) {
      return;
    }
    if (event.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this.dispatchEvent(
        new CustomEvent("combo-box-item-selected", {
          detail: {
            item: event.detail.item
          }
        })
      );
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not request data provider when read-only.
   *
   * @param {number}
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldLoadPage(page) {
    if (this.readonly) {
      return false;
    }
    return super._shouldLoadPage(page);
  }
  /**
   * Override method inherited from the combo-box
   * to not clear the data provider cache when read-only.
   *
   * @protected
   * @override
   */
  clearCache() {
    if (this.readonly) {
      return;
    }
    super.clearCache();
  }
};
defineCustomElement(MultiSelectComboBoxInternal);

// node_modules/@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box.js
var multiSelectComboBox2 = css`
  :host {
    --input-min-width: var(--vaadin-multi-select-combo-box-input-min-width, 4em);
    --_chip-min-width: var(--vaadin-multi-select-combo-box-chip-min-width, 50px);
  }

  #chips {
    display: flex;
    align-items: center;
  }

  ::slotted(input) {
    box-sizing: border-box;
    flex: 1 0 var(--input-min-width);
  }

  ::slotted([slot='chip']),
  ::slotted([slot='overflow']) {
    flex: 0 1 auto;
  }

  ::slotted([slot='chip']) {
    overflow: hidden;
  }

  :host(:is([readonly], [disabled])) ::slotted(input) {
    flex-grow: 0;
    flex-basis: 0;
    padding: 0;
  }

  :host([auto-expand-vertically]) #chips {
    display: contents;
  }

  :host([auto-expand-horizontally]) [class$='container'] {
    width: auto;
  }
`;
registerStyles("vaadin-multi-select-combo-box", [inputFieldShared2, multiSelectComboBox2], {
  moduleId: "vaadin-multi-select-combo-box-styles"
});
var MultiSelectComboBox = class extends ResizeMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-multi-select-combo-box";
  }
  static get template() {
    return html`
      <div class="vaadin-multi-select-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-multi-select-combo-box-internal
          id="comboBox"
          items="[[__effectiveItems]]"
          item-id-path="[[itemIdPath]]"
          item-label-path="[[itemLabelPath]]"
          item-value-path="[[itemValuePath]]"
          disabled="[[disabled]]"
          readonly="[[readonly]]"
          auto-open-disabled="[[autoOpenDisabled]]"
          allow-custom-value="[[allowCustomValue]]"
          overlay-class="[[overlayClass]]"
          data-provider="[[dataProvider]]"
          filter="{{filter}}"
          last-filter="{{_lastFilter}}"
          loading="{{loading}}"
          size="{{size}}"
          filtered-items="[[__effectiveFilteredItems]]"
          selected-items="[[selectedItems]]"
          selected-items-on-top="[[selectedItemsOnTop]]"
          top-group="[[_topGroup]]"
          opened="{{opened}}"
          renderer="[[renderer]]"
          theme$="[[_theme]]"
          on-combo-box-item-selected="_onComboBoxItemSelected"
          on-change="_onComboBoxChange"
          on-custom-value-set="_onCustomValueSet"
          on-filtered-items-changed="_onFilteredItemsChanged"
        >
          <vaadin-multi-select-combo-box-container
            part="input-field"
            auto-expand-vertically="[[autoExpandVertically]]"
            readonly="[[readonly]]"
            disabled="[[disabled]]"
            invalid="[[invalid]]"
            theme$="[[_theme]]"
          >
            <slot name="overflow" slot="prefix"></slot>
            <div id="chips" part="chips" slot="prefix">
              <slot name="chip"></slot>
            </div>
            <slot name="input"></slot>
            <div
              id="clearButton"
              part="clear-button"
              slot="suffix"
              on-touchend="_onClearButtonTouchend"
              aria-hidden="true"
            ></div>
            <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix" aria-hidden="true"></div>
          </vaadin-multi-select-combo-box-container>
        </vaadin-multi-select-combo-box-internal>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get properties() {
    return {
      /**
       * Set to true to auto expand horizontally, causing input field to
       * grow until max width is reached.
       * @attr {boolean} auto-expand-horizontally
       */
      autoExpandHorizontally: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_autoExpandHorizontallyChanged"
      },
      /**
       * Set to true to not collapse selected items chips into the overflow
       * chip and instead always expand vertically, causing input field to
       * wrap into multiple lines when width is limited.
       * @attr {boolean} auto-expand-vertically
       */
      autoExpandVertically: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_autoExpandVerticallyChanged"
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: Boolean,
      /**
       * Set to true to display the clear icon which clears the input.
       * @attr {boolean} clear-button-visible
       */
      clearButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        observer: "_clearButtonVisibleChanged",
        value: false
      },
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       */
      items: {
        type: Array
      },
      /**
       * The item property used for a visual representation of the item.
       * @attr {string} item-label-path
       */
      itemLabelPath: {
        type: String,
        value: "label"
      },
      /**
       * Path for the value of the item. If `items` is an array of objects,
       * this property is used as a string value for the selected item.
       * @attr {string} item-value-path
       */
      itemValuePath: {
        type: String,
        value: "value"
      },
      /**
       * Path for the id of the item, used to detect whether the item is selected.
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       * ```
       * {
       *   // Screen reader announcement on clear button click.
       *   cleared: 'Selection cleared',
       *   // Screen reader announcement when a chip is focused.
       *   focused: ' focused. Press Backspace to remove',
       *   // Screen reader announcement when item is selected.
       *   selected: 'added to selection',
       *   // Screen reader announcement when item is deselected.
       *   deselected: 'removed from selection',
       *   // Screen reader announcement of the selected items count.
       *   // {count} is replaced with the actual count of items.
       *   total: '{count} items selected',
       * }
       * ```
       * @type {!MultiSelectComboBoxI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            cleared: "Selection cleared",
            focused: "focused. Press Backspace to remove",
            selected: "added to selection",
            deselected: "removed from selection",
            total: "{count} items selected"
          };
        }
      },
      /**
       * True when loading items from the data provider, false otherwise.
       */
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * When present, it specifies that the field is read-only.
       */
      readonly: {
        type: Boolean,
        value: false,
        observer: "_readonlyChanged",
        reflectToAttribute: true
      },
      /**
       * The list of selected items.
       * Note: modifying the selected items creates a new array each time.
       */
      selectedItems: {
        type: Array,
        value: () => [],
        notify: true
      },
      /**
       * True if the dropdown is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Total number of items.
       */
      size: {
        type: Number
      },
      /**
       * Number of items fetched at a time from the data provider.
       * @attr {number} page-size
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged"
      },
      /**
       * Function that provides items lazily. Receives two arguments:
       *
       * - `params` - Object with the following properties:
       *   - `params.page` Requested page index
       *   - `params.pageSize` Current page size
       *   - `params.filter` Currently applied filter
       *
       * - `callback(items, size)` - Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items.
       */
      dataProvider: {
        type: Object
      },
      /**
       * When true, the user can input a value that is not present in the items list.
       * @attr {boolean} allow-custom-value
       */
      allowCustomValue: {
        type: Boolean,
        value: false
      },
      /**
       * A hint to the user of what can be entered in the control.
       * The placeholder will be only displayed in the case when
       * there is no item selected.
       */
      placeholder: {
        type: String,
        value: "",
        observer: "_placeholderChanged"
      },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-multi-select-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-multi-select-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       */
      renderer: Function,
      /**
       * Filtering string the user has typed into the input field.
       */
      filter: {
        type: String,
        value: "",
        notify: true
      },
      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       */
      filteredItems: Array,
      /**
       * Set to true to group selected items at the top of the overlay.
       * @attr {boolean} selected-items-on-top
       */
      selectedItemsOnTop: {
        type: Boolean,
        value: false
      },
      /** @private */
      value: {
        type: String
      },
      /** @private */
      __effectiveItems: {
        type: Array,
        computed: "__computeEffectiveItems(items, selectedItems, readonly)"
      },
      /** @private */
      __effectiveFilteredItems: {
        type: Array,
        computed: "__computeEffectiveFilteredItems(items, filteredItems, selectedItems, readonly)"
      },
      /** @private */
      _overflowItems: {
        type: Array,
        value: () => []
      },
      /** @private */
      _focusedChipIndex: {
        type: Number,
        value: -1,
        observer: "_focusedChipIndexChanged"
      },
      /** @private */
      _lastFilter: {
        type: String
      },
      /** @private */
      _topGroup: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemsChanged(selectedItems, selectedItems.*)",
      "__updateOverflowChip(_overflow, _overflowItems, disabled, readonly)",
      "__updateTopGroup(selectedItemsOnTop, selectedItems, opened)"
    ];
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      ...super.slotStyles,
      `
        ${tag}[has-value] input::placeholder {
          color: transparent !important;
          forced-color-adjust: none;
        }
      `
    ];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  get _chips() {
    return [...this.querySelectorAll('[slot="chip"]')];
  }
  /**
   * Override a getter from `InputMixin` to compute
   * the presence of value based on `selectedItems`.
   *
   * @protected
   * @override
   */
  get _hasValue() {
    return this.selectedItems && this.selectedItems.length > 0;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this._tooltipController.setShouldShow((target) => !target.opened);
    this._inputField = this.shadowRoot.querySelector('[part="input-field"]');
    this._overflowController = new SlotController(this, "overflow", "vaadin-multi-select-combo-box-chip", {
      initializer: (chip2) => {
        chip2.addEventListener("mousedown", (e) => this._preventBlur(e));
        this._overflow = chip2;
      }
    });
    this.addController(this._overflowController);
    this.__updateChips();
    processTemplates(this);
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any).
   * @return {boolean}
   */
  checkValidity() {
    return this.required && !this.readonly ? this._hasValue : true;
  }
  /**
   * Clears the selected items.
   */
  clear() {
    this.__updateSelection([]);
    announce(this.i18n.cleared);
  }
  /**
   * Clears the cached pages and reloads data from data provider when needed.
   */
  clearCache() {
    if (this.$ && this.$.comboBox) {
      this.$.comboBox.clearCache();
    }
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.$ && this.$.comboBox) {
      this.$.comboBox.requestContentUpdate();
    }
  }
  /**
   * Override method inherited from `DisabledMixin` to forward disabled to chips.
   * @protected
   * @override
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (disabled || oldDisabled) {
      this.__updateChips();
    }
  }
  /**
   * Override method inherited from `InputMixin` to forward the input to combo-box.
   * @protected
   * @override
   */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      this.$.comboBox._setInputElement(input);
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._focusedChipIndex = -1;
      this.validate();
    }
  }
  /**
   * Implement callback from `ResizeMixin` to update chips.
   * @protected
   * @override
   */
  _onResize() {
    this.__updateChips();
  }
  /**
   * Override method from `DelegateStateMixin` to set required state
   * using `aria-required` attribute instead of `required`, in order
   * to prevent screen readers from announcing "invalid entry".
   * @protected
   * @override
   */
  _delegateAttribute(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "required") {
      this._delegateAttribute("aria-required", value ? "true" : false);
      return;
    }
    super._delegateAttribute(name, value);
  }
  /** @private */
  _autoExpandHorizontallyChanged(autoExpand, oldAutoExpand) {
    if (autoExpand || oldAutoExpand) {
      this.__updateChips();
    }
  }
  /** @private */
  _autoExpandVerticallyChanged(autoExpand, oldAutoExpand) {
    if (autoExpand || oldAutoExpand) {
      this.__updateChips();
    }
  }
  /**
   * Setting clear button visible reduces total space available
   * for rendering chips, and making it hidden increases it.
   * @private
   */
  _clearButtonVisibleChanged(visible, oldVisible) {
    if (visible || oldVisible) {
      this.__updateChips();
    }
  }
  /**
   * Implement two-way binding for the `filteredItems` property
   * that can be set on the internal combo-box element.
   *
   * @param {CustomEvent} event
   * @private
   */
  _onFilteredItemsChanged(event) {
    const { value } = event.detail;
    if (Array.isArray(value) || value == null) {
      this.filteredItems = value;
    }
  }
  /** @private */
  _readonlyChanged(readonly, oldReadonly) {
    if (readonly || oldReadonly) {
      this.__updateChips();
    }
    if (this.dataProvider) {
      this.clearCache();
    }
  }
  /** @private */
  _pageSizeChanged(pageSize, oldPageSize) {
    if (Math.floor(pageSize) !== pageSize || pageSize <= 0) {
      this.pageSize = oldPageSize;
      console.error('"pageSize" value must be an integer > 0');
    }
    this.$.comboBox.pageSize = this.pageSize;
  }
  /** @private */
  _placeholderChanged(placeholder) {
    const tmpPlaceholder = this.__tmpA11yPlaceholder;
    if (tmpPlaceholder !== placeholder) {
      this.__savedPlaceholder = placeholder;
      if (tmpPlaceholder) {
        this.placeholder = tmpPlaceholder;
      }
    }
  }
  /** @private */
  _selectedItemsChanged(selectedItems) {
    this._toggleHasValue(this._hasValue);
    if (this._hasValue) {
      const tmpPlaceholder = this._mergeItemLabels(selectedItems);
      this.__tmpA11yPlaceholder = tmpPlaceholder;
      this.placeholder = tmpPlaceholder;
    } else {
      delete this.__tmpA11yPlaceholder;
      this.placeholder = this.__savedPlaceholder;
    }
    this.__updateChips();
    this.requestContentUpdate();
    if (this.opened) {
      this.$.comboBox.$.overlay._updateOverlayWidth();
    }
  }
  /** @private */
  _getItemLabel(item2) {
    return this.$.comboBox._getItemLabel(item2);
  }
  /** @private */
  _mergeItemLabels(items) {
    return items.map((item2) => this._getItemLabel(item2)).join(", ");
  }
  /** @private */
  _findIndex(item2, selectedItems, itemIdPath) {
    if (itemIdPath && item2) {
      for (let index = 0; index < selectedItems.length; index++) {
        if (selectedItems[index] && selectedItems[index][itemIdPath] === item2[itemIdPath]) {
          return index;
        }
      }
      return -1;
    }
    return selectedItems.indexOf(item2);
  }
  /** @private */
  __clearFilter() {
    this.filter = "";
    this.$.comboBox.clear();
  }
  /** @private */
  __announceItem(itemLabel, isSelected, itemCount) {
    const state = isSelected ? "selected" : "deselected";
    const total = this.i18n.total.replace("{count}", itemCount || 0);
    announce(`${itemLabel} ${this.i18n[state]} ${total}`);
  }
  /** @private */
  __removeItem(item2) {
    const itemsCopy = [...this.selectedItems];
    itemsCopy.splice(itemsCopy.indexOf(item2), 1);
    this.__updateSelection(itemsCopy);
    const itemLabel = this._getItemLabel(item2);
    this.__announceItem(itemLabel, false, itemsCopy.length);
  }
  /** @private */
  __selectItem(item2) {
    const itemsCopy = [...this.selectedItems];
    const index = this._findIndex(item2, itemsCopy, this.itemIdPath);
    const itemLabel = this._getItemLabel(item2);
    let isSelected = false;
    if (index !== -1) {
      const lastFilter = this._lastFilter;
      if (lastFilter && lastFilter.toLowerCase() === itemLabel.toLowerCase()) {
        this.__clearFilter();
        return;
      }
      itemsCopy.splice(index, 1);
    } else {
      itemsCopy.push(item2);
      isSelected = true;
    }
    this.__updateSelection(itemsCopy);
    this.__clearFilter();
    this.__announceItem(itemLabel, isSelected, itemsCopy.length);
  }
  /** @private */
  __updateSelection(selectedItems) {
    this.selectedItems = selectedItems;
    this.validate();
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  /** @private */
  __updateTopGroup(selectedItemsOnTop, selectedItems, opened) {
    if (!selectedItemsOnTop) {
      this._topGroup = [];
    } else if (!opened) {
      this._topGroup = [...selectedItems];
    }
  }
  /** @private */
  __createChip(item2) {
    const chip2 = document.createElement("vaadin-multi-select-combo-box-chip");
    chip2.setAttribute("slot", "chip");
    chip2.item = item2;
    chip2.disabled = this.disabled;
    chip2.readonly = this.readonly;
    const label = this._getItemLabel(item2);
    chip2.label = label;
    chip2.setAttribute("title", label);
    chip2.addEventListener("item-removed", (e) => this._onItemRemoved(e));
    chip2.addEventListener("mousedown", (e) => this._preventBlur(e));
    return chip2;
  }
  /** @private */
  __getOverflowWidth() {
    const chip2 = this._overflow;
    chip2.style.visibility = "hidden";
    chip2.removeAttribute("hidden");
    const count = chip2.getAttribute("count");
    chip2.setAttribute("count", "99");
    const overflowStyle = getComputedStyle(chip2);
    const overflowWidth = chip2.clientWidth + parseInt(overflowStyle.marginInlineStart);
    chip2.setAttribute("count", count);
    chip2.setAttribute("hidden", "");
    chip2.style.visibility = "";
    return overflowWidth;
  }
  /** @private */
  __updateChips() {
    if (!this._inputField || !this.inputElement) {
      return;
    }
    this._chips.forEach((chip2) => {
      chip2.remove();
    });
    const items = [...this.selectedItems];
    const totalWidth = this._inputField.$.wrapper.clientWidth;
    const inputWidth = parseInt(getComputedStyle(this.inputElement).flexBasis);
    let remainingWidth = totalWidth - inputWidth;
    if (items.length > 1) {
      remainingWidth -= this.__getOverflowWidth();
    }
    const chipMinWidth = parseInt(getComputedStyle(this).getPropertyValue("--_chip-min-width"));
    if (this.autoExpandHorizontally) {
      const chips = [];
      for (let i = items.length - 1, refNode = null; i >= 0; i--) {
        const chip2 = this.__createChip(items[i]);
        this.insertBefore(chip2, refNode);
        refNode = chip2;
        chips.unshift(chip2);
      }
      const overflowItems = [];
      const availableWidth = this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth;
      if (!this.autoExpandVertically && availableWidth < inputWidth) {
        while (chips.length > 1) {
          const lastChip = chips.pop();
          lastChip.remove();
          overflowItems.unshift(items.pop());
          const neededWidth = overflowItems.length > 0 ? inputWidth + this.__getOverflowWidth() : inputWidth;
          if (this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth >= neededWidth) {
            break;
          }
        }
        if (chips.length === 1) {
          chips[0].style.maxWidth = `${Math.max(chipMinWidth, remainingWidth)}px`;
        }
      }
      this._overflowItems = overflowItems;
      return;
    }
    for (let i = items.length - 1, refNode = null; i >= 0; i--) {
      const chip2 = this.__createChip(items[i]);
      this.insertBefore(chip2, refNode);
      if (!this.autoExpandVertically && this.$.chips.clientWidth > remainingWidth) {
        if (refNode === null) {
          chip2.style.maxWidth = `${Math.max(chipMinWidth, remainingWidth)}px`;
        } else {
          chip2.remove();
          break;
        }
      }
      items.pop();
      refNode = chip2;
    }
    this._overflowItems = items;
  }
  /** @private */
  __updateOverflowChip(overflow, items, disabled, readonly) {
    if (overflow) {
      const count = items.length;
      overflow.label = `${count}`;
      overflow.setAttribute("count", `${count}`);
      overflow.setAttribute("title", this._mergeItemLabels(items));
      overflow.toggleAttribute("hidden", count === 0);
      overflow.disabled = disabled;
      overflow.readonly = readonly;
    }
  }
  /** @private */
  _onClearButtonTouchend(event) {
    event.preventDefault();
    event.stopPropagation();
    this.clear();
  }
  /**
   * Override method inherited from `InputControlMixin` and clear items.
   * @protected
   * @override
   */
  _onClearButtonClick(event) {
    event.stopPropagation();
    this.clear();
  }
  /**
   * Override an event listener from `InputControlMixin` to
   * stop the change event re-targeted from the input.
   *
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.clearButtonVisible && this.selectedItems && this.selectedItems.length) {
      event.stopPropagation();
      this.selectedItems = [];
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    const chips = this._chips;
    if (!this.readonly && chips.length > 0) {
      switch (event.key) {
        case "Backspace":
          this._onBackSpace(chips);
          break;
        case "ArrowLeft":
          this._onArrowLeft(chips, event);
          break;
        case "ArrowRight":
          this._onArrowRight(chips, event);
          break;
        default:
          this._focusedChipIndex = -1;
          break;
      }
    }
  }
  /** @private */
  _onArrowLeft(chips, event) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx !== -1) {
      event.preventDefault();
    }
    let newIdx;
    if (!this.__isRTL) {
      if (idx === -1) {
        newIdx = chips.length - 1;
      } else if (idx > 0) {
        newIdx = idx - 1;
      }
    } else if (idx === chips.length - 1) {
      newIdx = -1;
    } else if (idx > -1) {
      newIdx = idx + 1;
    }
    if (newIdx !== void 0) {
      this._focusedChipIndex = newIdx;
    }
  }
  /** @private */
  _onArrowRight(chips, event) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx !== -1) {
      event.preventDefault();
    }
    let newIdx;
    if (this.__isRTL) {
      if (idx === -1) {
        newIdx = chips.length - 1;
      } else if (idx > 0) {
        newIdx = idx - 1;
      }
    } else if (idx === chips.length - 1) {
      newIdx = -1;
    } else if (idx > -1) {
      newIdx = idx + 1;
    }
    if (newIdx !== void 0) {
      this._focusedChipIndex = newIdx;
    }
  }
  /** @private */
  _onBackSpace(chips) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx === -1) {
      this._focusedChipIndex = chips.length - 1;
    } else {
      this.__removeItem(chips[idx].item);
      this._focusedChipIndex = -1;
    }
  }
  /** @private */
  _focusedChipIndexChanged(focusedIndex, oldFocusedIndex) {
    if (focusedIndex > -1 || oldFocusedIndex > -1) {
      const chips = this._chips;
      chips.forEach((chip2, index) => {
        chip2.toggleAttribute("focused", index === focusedIndex);
      });
      if (focusedIndex > -1) {
        const item2 = chips[focusedIndex].item;
        const itemLabel = this._getItemLabel(item2);
        announce(`${itemLabel} ${this.i18n.focused}`);
      }
    }
  }
  /** @private */
  _onComboBoxChange() {
    const item2 = this.$.comboBox.selectedItem;
    if (item2) {
      this.__selectItem(item2);
    }
  }
  /** @private */
  _onComboBoxItemSelected(event) {
    this.__selectItem(event.detail.item);
  }
  /** @private */
  _onCustomValueSet(event) {
    event.preventDefault();
    event.stopPropagation();
    this.__clearFilter();
    this.dispatchEvent(
      new CustomEvent("custom-value-set", {
        detail: event.detail,
        composed: true,
        bubbles: true
      })
    );
  }
  /** @private */
  _onItemRemoved(event) {
    this.__removeItem(event.detail.item);
  }
  /** @private */
  _preventBlur(event) {
    event.preventDefault();
  }
  /** @private */
  __computeEffectiveItems(items, selectedItems, readonly) {
    return items && readonly ? selectedItems : items;
  }
  /** @private */
  __computeEffectiveFilteredItems(items, filteredItems, selectedItems, readonly) {
    return !items && readonly ? selectedItems : filteredItems;
  }
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {string} detail the custom value
   */
};
defineCustomElement(MultiSelectComboBox);
/*! Bundled license information:

@vaadin/multi-select-combo-box/theme/lumo/vaadin-multi-select-combo-box-chip-styles.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/multi-select-combo-box/theme/lumo/vaadin-multi-select-combo-box-styles.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-chip.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-container.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-item.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-overlay.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-scroller.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box-internal.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/multi-select-combo-box/src/vaadin-multi-select-combo-box.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/multi-select-combo-box/theme/lumo/vaadin-multi-select-combo-box.js:
  (**
   * @license
   * Copyright (c) 2021 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)
*/
//# sourceMappingURL=@vaadin_multi-select-combo-box_theme_lumo_vaadin-multi-select-combo-box__js.js.map
