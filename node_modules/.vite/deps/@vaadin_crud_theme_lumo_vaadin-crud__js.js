import "./chunk-IXKMP7WV.js";
import "./chunk-NKBMA4ET.js";
import "./chunk-ZOKNJC4F.js";
import {
  Grid
} from "./chunk-BPFJRAAQ.js";
import "./chunk-2LTC4HBG.js";
import {
  FormLayout
} from "./chunk-X3DNGHIV.js";
import "./chunk-Z6UBOSHQ.js";
import "./chunk-YQV52A53.js";
import "./chunk-P5OJUUFQ.js";
import "./chunk-DJLAMTZC.js";
import "./chunk-UTKYTDFY.js";
import "./chunk-LHRZSTHO.js";
import "./chunk-54ADOYDD.js";
import "./chunk-NKS7BVZU.js";
import {
  DialogBaseMixin,
  dialogOverlay,
  dialogOverlay2,
  resizableOverlay
} from "./chunk-XLXC57MX.js";
import "./chunk-F6I6TNT2.js";
import "./chunk-TBCD74S6.js";
import "./chunk-KLWGRNBK.js";
import "./chunk-IZU3SL7W.js";
import "./chunk-22HBDZ2I.js";
import "./chunk-WCEMJP5Y.js";
import "./chunk-MI4WOW4I.js";
import "./chunk-TP3SG6KP.js";
import "./chunk-ME67HVVO.js";
import "./chunk-NJXIHJ3Q.js";
import "./chunk-V7EIQ2IZ.js";
import "./chunk-PMRFEKRS.js";
import "./chunk-R5IZNLSA.js";
import {
  MediaQueryController
} from "./chunk-QXKYTJLT.js";
import "./chunk-XWHFZQ32.js";
import "./chunk-3TOJB423.js";
import "./chunk-JWDOWCJS.js";
import {
  OverlayClassMixin
} from "./chunk-BGWLAHRF.js";
import {
  overlay
} from "./chunk-UFBVVQ65.js";
import {
  OverlayMixin,
  overlayStyles
} from "./chunk-HYO4DUYL.js";
import {
  FocusRestorationController
} from "./chunk-PJNJQYXC.js";
import "./chunk-ZE63AH6T.js";
import "./chunk-TH3SXEA2.js";
import "./chunk-DV2EGEEG.js";
import "./chunk-2JVJNHM2.js";
import {
  afterNextRender
} from "./chunk-FSP2XZVR.js";
import "./chunk-5AS73FDI.js";
import "./chunk-7DHOJVCV.js";
import "./chunk-MOF77BCW.js";
import "./chunk-IHIS7TAV.js";
import "./chunk-24BF3Z44.js";
import {
  ElementMixin
} from "./chunk-MWSAWSJ3.js";
import {
  Debouncer
} from "./chunk-SEGZ6IIL.js";
import "./chunk-IDC7WHOS.js";
import "./chunk-TVB6PYW6.js";
import "./chunk-GV4NWW2U.js";
import "./chunk-EZVFCO5I.js";
import "./chunk-TOPBZAEH.js";
import "./chunk-LERX5ED5.js";
import "./chunk-RPOYDVPH.js";
import "./chunk-CRXJMMF2.js";
import "./chunk-EJTF7QKX.js";
import "./chunk-44TTWRW5.js";
import {
  SlotController
} from "./chunk-6C6BQOMD.js";
import "./chunk-ZPXTDJKE.js";
import "./chunk-O6KCEJHO.js";
import "./chunk-EFKWAQ3Y.js";
import "./chunk-3BRKSSC5.js";
import "./chunk-GRU2OPCY.js";
import "./chunk-HFKL6MLF.js";
import {
  ControllerMixin
} from "./chunk-QGCYTHXO.js";
import "./chunk-JQFZSNBR.js";
import "./chunk-F7YWWDDG.js";
import "./chunk-R6DBYMLB.js";
import "./chunk-BORGCLO4.js";
import "./chunk-J4OM4IIF.js";
import "./chunk-3WOFLRNV.js";
import "./chunk-J2NV7QBD.js";
import {
  ThemableMixin,
  ThemePropertyMixin,
  registerStyles
} from "./chunk-BBNA52CT.js";
import "./chunk-IBHXN4JT.js";
import "./chunk-QO3ZNG6F.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import {
  DirMixin
} from "./chunk-B6NQGUVK.js";
import {
  timeOut
} from "./chunk-ER2S4LLB.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import {
  PolymerElement,
  get,
  set
} from "./chunk-4TYUW4EB.js";
import "./chunk-FXP5WKMI.js";
import "./chunk-2IE6RYOR.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import {
  html
} from "./chunk-XB4RSW42.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-WGAPYIUP.js";

// node_modules/@vaadin/crud/theme/lumo/vaadin-crud-styles.js
registerStyles(
  "vaadin-crud-edit",
  css`
    :host {
      min-width: auto;
      margin: 0;
      font-family: 'lumo-icons', var(--lumo-font-family);
      font-size: var(--lumo-icon-size-m);
      line-height: 1;
      position: relative;
      width: var(--lumo-size-s);
      height: var(--lumo-size-s);
      outline: none;
    }

    [part='icon']::before {
      content: var(--lumo-icons-edit);
      width: var(--lumo-size-m);
      height: var(--lumo-size-m);
      line-height: var(--lumo-size-m);
      text-align: center;
      position: absolute;
      top: calc((var(--lumo-size-m) - var(--lumo-size-s)) / -2);
      left: calc((var(--lumo-size-m) - var(--lumo-size-s)) / -2);
    }
  `,
  { moduleId: "lumo-crud-grid-edit" }
);
var editorStyles = css`
  [part='header'] ::slotted(h3) {
    margin-top: 0 !important;
  }

  :host(:not([dir='rtl'])) ::slotted([slot='delete-button']) {
    margin-right: auto;
  }

  :host([dir='rtl']) ::slotted([slot='delete-button']) {
    margin-left: auto;
  }
`;
registerStyles(
  "vaadin-crud",
  [
    editorStyles,
    css`
      :host {
        font-family: var(--lumo-font-family);
        --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
        --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      }

      [part='scroller'] {
        padding: var(--lumo-space-l);
      }

      [part='toolbar'] {
        padding: var(--lumo-space-s) var(--lumo-space-m);
        background-color: var(--lumo-contrast-5pct);
        border: 1px solid var(--lumo-contrast-10pct);
        border-top: none;
      }

      :host(:not([dir='rtl'])) [part='toolbar'] ::slotted(*:not(:first-child)) {
        margin-left: var(--lumo-space-s);
      }

      :host([dir='rtl']) [part='toolbar'] ::slotted(*:not(:first-child)) {
        margin-right: var(--lumo-space-s);
      }

      :host([theme~='no-border']) [part='toolbar'] {
        border: 0;
      }

      [part='footer'] {
        background-color: var(--lumo-contrast-5pct);
        padding: var(--lumo-space-s);
      }

      [part='footer'] ::slotted(*) {
        margin-left: var(--lumo-space-s);
        margin-right: var(--lumo-space-s);
      }

      [part='editor'] {
        background: var(--lumo-base-color);
        box-sizing: border-box;
        position: relative;
      }

      [part='editor']:focus::before {
        position: absolute;
        inset: 0;
        content: '';
        box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
      }

      :host(:not([editor-position=''])) [part='editor']:not([hidden]) {
        box-shadow: var(--lumo-box-shadow-m);
      }

      :host(:not([theme~='no-border']):not([editor-position=''])) [part='editor']:not([hidden]) {
        border: 1px solid var(--lumo-contrast-20pct);
      }

      :host(:not([theme~='no-border'])[editor-position='bottom']) [part='editor']:not([hidden]) {
        border-top: 0;
      }

      :host(:not([dir='rtl'])[editor-position='aside']) [part='editor']:not([hidden]) {
        border-left: 0;
      }

      :host([dir='rtl']:not([theme~='no-border'])[editor-position='aside']) [part='editor']:not([hidden]) {
        border-right: 0;
      }
    `
  ],
  { moduleId: "lumo-crud" }
);
registerStyles(
  "vaadin-crud-dialog-overlay",
  [
    overlay,
    dialogOverlay,
    editorStyles,
    css`
      [part='header'] ::slotted(h3) {
        margin-top: 0 !important;
        margin-bottom: 0 !important;
        margin-inline-start: var(--lumo-space-s);
      }
    `
  ],
  {
    moduleId: "lumo-crud-dialog-overlay"
  }
);

// node_modules/@vaadin/crud/src/vaadin-crud-dialog.js
var crudDialogOverlay = css`
  [part='overlay'] {
    max-width: 54em;
    min-width: 20em;
  }

  [part='footer'] {
    justify-content: flex-start;
    flex-direction: row-reverse;
  }

  /* Make buttons clickable */
  [part='footer'] ::slotted(:not([disabled])) {
    pointer-events: all;
  }

  :host([fullscreen]) {
    inset: 0;
    padding: 0;
  }

  :host([fullscreen]) [part='overlay'] {
    height: 100vh;
    width: 100vw;
    border-radius: 0 !important;
  }

  :host([fullscreen]) [part='content'] {
    flex: 1;
  }
`;
registerStyles("vaadin-crud-dialog-overlay", [overlayStyles, dialogOverlay2, resizableOverlay, crudDialogOverlay], {
  moduleId: "vaadin-crud-dialog-overlay-styles"
});
var CrudDialogOverlay = class extends OverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-crud-dialog-overlay";
  }
  static get template() {
    return html`
      <div part="backdrop" id="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <section id="resizerContainer" class="resizer-container">
          <header part="header"><slot name="header"></slot></header>
          <div part="content" id="content">
            <slot name="form"></slot>
          </div>
          <footer part="footer" role="toolbar">
            <slot name="save-button"></slot>
            <slot name="cancel-button"></slot>
            <slot name="delete-button"></slot>
          </footer>
        </section>
      </div>
    `;
  }
  /**
   * @protected
   * @override
   */
  ready() {
    super.ready();
    this.setAttribute("has-header", "");
    this.setAttribute("has-footer", "");
  }
};
defineCustomElement(CrudDialogOverlay);
var CrudDialog = class extends DialogBaseMixin(OverlayClassMixin(ThemePropertyMixin(PolymerElement))) {
  static get is() {
    return "vaadin-crud-dialog";
  }
  static get properties() {
    return {
      ariaLabel: {
        type: String
      },
      fullscreen: {
        type: Boolean
      }
    };
  }
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>

      <vaadin-crud-dialog-overlay
        id="overlay"
        opened="[[opened]]"
        aria-label$="[[ariaLabel]]"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[_theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        fullscreen$="[[fullscreen]]"
        focus-trap
      ></vaadin-crud-dialog-overlay>
    `;
  }
};
defineCustomElement(CrudDialog);

// node_modules/@vaadin/grid/src/vaadin-grid-filter-element-mixin.js
registerStyles(
  "vaadin-grid-filter",
  css`
    :host {
      display: inline-flex;
      max-width: 100%;
    }

    ::slotted(*) {
      width: 100%;
      box-sizing: border-box;
    }
  `,
  { moduleId: "vaadin-grid-filter-styles" }
);
var GridFilterElementMixin = (superClass) => class extends ControllerMixin(superClass) {
  static get properties() {
    return {
      /**
       * JS Path of the property in the item used for filtering the data.
       */
      path: {
        type: String,
        sync: true
      },
      /**
       * Current filter value.
       */
      value: {
        type: String,
        notify: true,
        sync: true
      },
      /** @private */
      _textField: {
        type: Object,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_filterChanged(path, value, _textField)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this._filterController = new SlotController(this, "", "vaadin-text-field", {
      initializer: (field) => {
        field.addEventListener("value-changed", (e) => {
          if (field.__previousValue === void 0 && e.detail.value === "") {
            field.__previousValue = e.detail.value;
            return;
          }
          this.value = e.detail.value;
        });
        this._textField = field;
      }
    });
    this.addController(this._filterController);
  }
  /** @private */
  _filterChanged(path, value, textField) {
    if (path === void 0 || value === void 0 || !textField) {
      return;
    }
    if (this._previousValue === void 0 && value === "") {
      return;
    }
    textField.value = value;
    this._previousValue = value;
    this._debouncerFilterChanged = Debouncer.debounce(this._debouncerFilterChanged, timeOut.after(200), () => {
      this.dispatchEvent(new CustomEvent("filter-changed", { bubbles: true }));
    });
  }
  focus() {
    if (this._textField) {
      this._textField.focus();
    }
  }
};

// node_modules/@vaadin/grid/src/vaadin-grid-filter.js
var GridFilter = class extends GridFilterElementMixin(ThemableMixin(PolymerElement)) {
  static get template() {
    return html`<slot></slot>`;
  }
  static get is() {
    return "vaadin-grid-filter";
  }
};
defineCustomElement(GridFilter);

// node_modules/@vaadin/crud/src/vaadin-crud-helpers.js
function capitalize(path) {
  return path.toLowerCase().replace(/([^\w]+)/gu, " ").trim().replace(/^./u, (c) => c.toUpperCase());
}
function getProperty(path, obj) {
  return get(obj, path);
}
function setProperty(path, value, obj) {
  if (obj && path) {
    path.split(".").slice(0, -1).reduce((o, p) => {
      if (!o[p]) {
        o[p] = {};
      }
      return o[p];
    }, obj);
    set(obj, path, value);
  }
}

// node_modules/@vaadin/crud/src/vaadin-crud-include-mixin.js
var IncludedMixin = (superClass) => class IncludedMixin extends superClass {
  static get properties() {
    return {
      /**
       * A list of item fields that should not be mapped to form fields.
       *
       * When [`include`](#/elements/vaadin-crud-form#property-include) is defined, this property is ignored.
       *
       * Default is to exclude any private property.
       *
       * @type {string | RegExp}
       */
      exclude: {
        value: "^_",
        observer: "__onExcludeChange"
      },
      /**
       * A list of item properties that should be mapped to form fields.
       *
       * When it is defined [`exclude`](#/elements/vaadin-crud-form#property-exclude) is ignored.
       *
       * @type {string | !Array<string> | undefined}
       */
      include: {
        observer: "__onIncludeChange"
      }
    };
  }
  /** @private */
  __onExcludeChange(exclude) {
    if (typeof exclude === "string") {
      this.exclude = exclude ? RegExp(exclude.replace(/, */gu, "|"), "iu") : void 0;
    }
  }
  /** @private */
  __onIncludeChange(include) {
    if (typeof include === "string") {
      this.include = include ? include.split(/, */u) : void 0;
    } else if (!this._fields && Array.isArray(include)) {
      const item = {};
      this.include.forEach((path) => {
        setProperty(path, null, item);
      });
      this._configure(item);
    }
  }
};

// node_modules/@vaadin/crud/src/vaadin-crud-grid.js
var CrudGrid = class extends IncludedMixin(Grid) {
  static get is() {
    return "vaadin-crud-grid";
  }
  static get properties() {
    return {
      /**
       * Disable filtering in the generated columns.
       * @attr {boolean} no-filter
       */
      noFilter: Boolean,
      /**
       * Disable sorting in the generated columns.
       * @attr {boolean} no-sort
       */
      noSort: Boolean,
      /**
       * Do not add headers to columns.
       * @attr {boolean} no-head
       */
      noHead: Boolean,
      /** @private */
      __hideEditColumn: Boolean
    };
  }
  static get observers() {
    return ["__onItemsChange(items)", "__onHideEditColumnChange(hideEditColumn)"];
  }
  /** @private */
  __onItemsChange(items) {
    if ((!this.dataProvider || this.dataProvider === this._arrayDataProvider) && !this.include && items && items[0]) {
      this._configure(items[0]);
    }
  }
  /** @private */
  __onHideEditColumnChange() {
    if (this.firstChild) {
      this.__toggleEditColumn();
    }
  }
  /** @private */
  __toggleEditColumn() {
    let editColumn = this.querySelector("vaadin-crud-edit-column");
    if (this.hideEditColumn) {
      if (editColumn) {
        this.removeChild(editColumn);
      }
    } else if (!editColumn) {
      editColumn = document.createElement("vaadin-crud-edit-column");
      editColumn.frozenToEnd = true;
      this.appendChild(editColumn);
    }
  }
  /** @private */
  __dataProviderWrapper(params, callback) {
    this.__dataProvider(params, (items, size) => {
      if (this.innerHTML === "" && !this.include && items[0]) {
        this._configure(items[0]);
      }
      callback(items, size);
    });
  }
  /**
   * @override
   * @private
   */
  _dataProviderChanged(dataProvider, oldDataProvider) {
    if (this._arrayDataProvider === dataProvider) {
      super._dataProviderChanged(dataProvider, oldDataProvider);
    } else if (this.__dataProviderWrapper !== dataProvider) {
      this.innerHTML = "";
      this.__dataProvider = dataProvider;
      this.dataProvider = this.__dataProviderWrapper;
      super._dataProviderChanged(this.__dataProviderWrapper, oldDataProvider);
    }
  }
  /**
   * Auto-generate grid columns based on the JSON structure of the object provided.
   *
   * Method will be executed when items or dataProvider is assigned.
   * @private
   */
  _configure(item) {
    this.innerHTML = "";
    this.__createColumns(this, item, void 0, this.__getPropertyDepth(item));
    this.__toggleEditColumn();
  }
  /**
   * Return the deepest property depth of the object
   * @private
   */
  __getPropertyDepth(object) {
    if (!object || typeof object !== "object") {
      return 0;
    }
    return Object.keys(object).reduce((deepest, prop) => {
      if (this.exclude && this.exclude.test(prop)) {
        return deepest;
      }
      return Math.max(deepest, 1 + this.__getPropertyDepth(object[prop]));
    }, 0);
  }
  /**
   * Parse the camelCase column names into sentence case headers.
   * @param {string} path
   * @return {string}
   * @protected
   */
  _generateHeader(path) {
    return path.substr(path.lastIndexOf(".") + 1).replace(/([A-Z])/gu, "-$1").toLowerCase().replace(/-/gu, " ").replace(/^./u, (match) => match.toUpperCase());
  }
  /** @private */
  __createColumn(parent, path) {
    let col;
    if (!this.noFilter && !this.noSort && !parent.__sortColumnGroup) {
      col = this.__createGroup(parent);
      col.__sortColumnGroup = true;
      this.__createColumn(col, path);
    } else {
      col = document.createElement("vaadin-grid-column");
      parent.appendChild(col);
      col.renderer = (root, _column, model) => {
        root.textContent = path ? getProperty(path, model.item) : model.item;
      };
    }
    if (!this.noHead && path) {
      col.headerRenderer = (root) => {
        if (root.firstElementChild) {
          return;
        }
        const label = this._generateHeader(path);
        if (col.__sortColumnGroup || this.noFilter && !this.noSort) {
          const sorter = document.createElement("vaadin-grid-sorter");
          sorter.setAttribute("path", path);
          sorter.setAttribute("aria-label", `Sort by ${label}`);
          sorter.textContent = label;
          root.appendChild(sorter);
        } else if (!this.noFilter) {
          const filter = document.createElement("vaadin-grid-filter");
          filter.setAttribute("path", path);
          filter.setAttribute("aria-label", `Filter by ${label}`);
          filter.style.display = "flex";
          const textField = window.document.createElement("vaadin-text-field");
          textField.setAttribute("theme", "small");
          textField.setAttribute("focus-target", true);
          textField.style.width = "100%";
          if (this.noSort) {
            textField.placeholder = label;
          }
          textField.addEventListener("value-changed", (event) => {
            filter.value = event.detail.value;
          });
          filter.appendChild(textField);
          root.appendChild(filter);
        } else if (this.noSort && this.noFilter) {
          root.textContent = label;
        }
      };
    }
  }
  /**
   * Creates the column structure for the (sub)object.
   *
   * @param {HTMLElement} parent May be the crud-grid or a column group.
   * @param {Object} object The object to create the sub-columns for.
   * @param {string} path The property path from the root item to the object.
   * @param {number} depth The depth of the object in the object hierarchy.
   * @private
   */
  __createColumns(parent, object, path, depth) {
    if (object && typeof object === "object") {
      Object.keys(object).forEach((prop) => {
        if (!this.include && this.exclude && this.exclude.test(prop)) {
          return;
        }
        const subObject = object[prop];
        const subObjectPath = path ? `${path}.${prop}` : prop;
        let subObjectColumn = parent;
        if (!this.noHead && depth > 1) {
          const isSubObject = subObject && typeof subObject === "object";
          subObjectColumn = this.__createGroup(parent, isSubObject ? prop : void 0);
        }
        this.__createColumns(subObjectColumn, subObject, subObjectPath, depth - 1);
      });
    } else if (depth > 1) {
      this.__createColumns(this.__createGroup(parent), void 0, path, depth - 1);
    } else {
      this.__createColumn(parent, path);
    }
  }
  /** @private */
  __createGroup(parent, header) {
    const grp = document.createElement("vaadin-grid-column-group");
    if (header) {
      grp.header = capitalize(header);
    }
    parent.appendChild(grp);
    return grp;
  }
};
defineCustomElement(CrudGrid);

// node_modules/@vaadin/crud/src/vaadin-crud-form.js
var CrudForm = class extends IncludedMixin(FormLayout) {
  static get is() {
    return "vaadin-crud-form";
  }
  static get properties() {
    return {
      /**
       * The item being edited.
       * @type {unknown}
       */
      item: Object
    };
  }
  static get observers() {
    return ["__onItemChange(item)"];
  }
  /**
   * Auto-generate form fields based on the JSON structure of the object provided.
   *
   * If not called, the method will be executed the first time an item is assigned.
   * @param {unknown} object
   * @protected
   */
  _configure(object) {
    this.innerHTML = "";
    this._fields = [];
    this.__createFields(this, object);
    this._updateLayout();
  }
  /** @private */
  __onItemChange(item) {
    if (!this._fields) {
      this._configure(item);
    }
  }
  /** @private */
  __createField(parent, path) {
    const field = document.createElement("vaadin-text-field");
    field.label = capitalize(path);
    field.path = path;
    field.required = true;
    parent.appendChild(field);
    this._fields.push(field);
    return field;
  }
  /** @private */
  __createFields(parent, object, path) {
    Object.keys(object).forEach((prop) => {
      if (!this.include && this.exclude && this.exclude.test(prop)) {
        return;
      }
      const newPath = (path ? `${path}.` : "") + prop;
      if (object[prop] && typeof object[prop] === "object") {
        this.__createFields(parent, object[prop], newPath);
      } else {
        this.__createField(parent, newPath);
      }
    });
    if (!this._fields.length) {
      this._fields = void 0;
    }
  }
};
defineCustomElement(CrudForm);

// node_modules/@vaadin/crud/src/vaadin-crud-controllers.js
var ButtonSlotController = class extends SlotController {
  constructor(host, type, theme, noDefaultNode) {
    super(host, `${type}-button`, noDefaultNode ? null : "vaadin-button");
    this.type = type;
    this.theme = theme;
  }
  /**
   * Override method inherited from `SlotController`
   * to mark custom slotted button as the default.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    if (!node) {
      return;
    }
    if (node._isDefault) {
      this.defaultNode = node;
    }
    if (node === this.defaultNode && !node.hasAttribute("theme")) {
      node.setAttribute("theme", this.theme);
    }
    const { host, type } = this;
    const property = `_${type}Button`;
    const listener = `__${type}`;
    if (host[property] && host[property] !== node) {
      host[property].remove();
    }
    node.addEventListener("click", host[listener]);
    host[property] = node;
  }
};
var FormSlotController = class extends SlotController {
  constructor(host) {
    super(host, "form", "vaadin-crud-form");
  }
  /**
   * Override method inherited from `SlotController`
   * to move slotted form to the overlay if needed.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    this.host._form = node;
    if (this.host.editorOpened) {
      this.host.__ensureChildren();
    }
  }
};
var GridSlotController = class extends SlotController {
  constructor(host) {
    super(host, "grid", "vaadin-crud-grid");
  }
  /**
   * Override method inherited from `SlotController`
   * to initialize `active-item-changed` listener.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    const { host } = this;
    queueMicrotask(() => {
      host.__editOnClickChanged(false, host._grid);
      host._grid = node;
      host.__editOnClickChanged(host.editOnClick, host._grid);
    });
  }
};

// node_modules/@vaadin/crud/src/vaadin-crud.js
var Crud = class _Crud extends ControllerMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          width: 100%;
          height: 400px;
          --vaadin-crud-editor-max-height: 40%;
          --vaadin-crud-editor-max-width: 40%;
        }

        :host,
        #main {
          display: flex;
          flex-direction: column;
          align-self: stretch;
          position: relative;
          overflow: hidden;
        }

        #main {
          flex: 1 1 100%;
          height: 100%;
        }

        :host([hidden]),
        [hidden] {
          display: none !important;
        }

        [part='toolbar'] {
          display: flex;
          flex-shrink: 0;
          align-items: baseline;
          justify-content: flex-end;
        }

        :host([no-toolbar]) [part='toolbar'] {
          display: none;
        }

        #container {
          display: flex;
          height: 100%;
        }

        :host([editor-position='bottom']) #container {
          flex-direction: column;
        }

        [part='editor'] {
          z-index: 1;
          display: flex;
          flex-direction: column;
          height: 100%;
          outline: none;
        }

        :host(:not([editor-position=''])[editor-opened]:not([fullscreen])) [part='editor'] {
          flex: 1 0 100%;
        }

        :host([editor-position='bottom'][editor-opened]:not([fullscreen])) [part='editor'] {
          max-height: var(--vaadin-crud-editor-max-height);
        }

        :host([editor-position='aside'][editor-opened]:not([fullscreen])) [part='editor'] {
          min-width: 300px;
          max-width: var(--vaadin-crud-editor-max-width);
        }

        [part='scroller'] {
          display: flex;
          flex-direction: column;
          overflow: auto;
          flex: auto;
        }

        [part='footer'] {
          display: flex;
          flex: none;
          flex-direction: row-reverse;
        }
      </style>

      <div id="container">
        <div id="main">
          <slot name="grid"></slot>

          <div id="toolbar" part="toolbar">
            <slot name="toolbar"></slot>
            <slot name="new-button"></slot>
          </div>
        </div>

        <div
          part="editor"
          id="editor"
          role="group"
          aria-labelledby="header"
          hidden$="[[__computeEditorHidden(editorOpened, _fullscreen, editorPosition)]]"
        >
          <div part="scroller" id="scroller">
            <div part="header" id="header">
              <slot name="header"></slot>
            </div>
            <slot name="form"></slot>
          </div>

          <div part="footer" role="toolbar">
            <slot name="save-button"></slot>
            <slot name="cancel-button"></slot>
            <slot name="delete-button"></slot>
          </div>
        </div>
      </div>

      <vaadin-crud-dialog
        id="dialog"
        opened="[[__computeDialogOpened(editorOpened, _fullscreen, editorPosition)]]"
        fullscreen="[[_fullscreen]]"
        aria-label="[[__dialogAriaLabel]]"
        no-close-on-outside-click="[[__isDirty]]"
        no-close-on-esc="[[__isDirty]]"
        theme$="[[_theme]]"
        on-opened-changed="__onDialogOpened"
      ></vaadin-crud-dialog>

      <vaadin-confirm-dialog
        theme$="[[_theme]]"
        id="confirmCancel"
        on-confirm="__confirmCancel"
        cancel-button-visible
        confirm-text="[[i18n.confirm.cancel.button.confirm]]"
        cancel-text="[[i18n.confirm.cancel.button.dismiss]]"
        header="[[i18n.confirm.cancel.title]]"
        message="[[i18n.confirm.cancel.content]]"
        confirm-theme="primary"
      ></vaadin-confirm-dialog>

      <vaadin-confirm-dialog
        theme$="[[_theme]]"
        id="confirmDelete"
        on-confirm="__confirmDelete"
        cancel-button-visible
        confirm-text="[[i18n.confirm.delete.button.confirm]]"
        cancel-text="[[i18n.confirm.delete.button.dismiss]]"
        header="[[i18n.confirm.delete.title]]"
        message="[[i18n.confirm.delete.content]]"
        confirm-theme="primary error"
      ></vaadin-confirm-dialog>
    `;
  }
  static get is() {
    return "vaadin-crud";
  }
  static get cvdlName() {
    return "vaadin-crud";
  }
  static get properties() {
    return {
      /**
       * A reference to the grid used for displaying the item list
       * @private
       */
      _grid: {
        type: Object,
        observer: "__gridChanged"
      },
      /**
       * A reference to the editor component which will be teleported to the dialog
       * @private
       */
      _form: {
        type: Object,
        observer: "__formChanged"
      },
      /**
       * A reference to the save button which will be teleported to the dialog
       * @private
       */
      _saveButton: {
        type: Object
      },
      /**
       * A reference to the delete button which will be teleported to the dialog
       * @private
       */
      _deleteButton: {
        type: Object
      },
      /**
       * A reference to the cancel button which will be teleported to the dialog
       * @private
       */
      _cancelButton: {
        type: Object
      },
      /**
       * A reference to the default editor header element created by the CRUD
       * @private
       */
      _defaultHeader: {
        type: Object
      },
      /**
       * A reference to the "New item" button
       * @private
       */
      _newButton: {
        type: Object
      },
      /**
       * An array containing the items which will be stamped to the column template instances.
       * @type {Array<unknown> | undefined}
       */
      items: {
        type: Array,
        notify: true,
        observer: "__itemsChanged"
      },
      /**
       * The item being edited in the dialog.
       * @type {unknown}
       */
      editedItem: {
        type: Object,
        observer: "__editedItemChanged",
        notify: true
      },
      /**
       * Sets how editor will be presented on desktop screen.
       *
       * Accepted values are:
       *   - `` (default) - form will open as overlay
       *   - `bottom` - form will open below the grid
       *   - `aside` - form will open on the grid side (_right_, if lft and _left_ if rtl)
       * @attr {bottom|aside} editor-position
       * @type {!CrudEditorPosition}
       */
      editorPosition: {
        type: String,
        value: "",
        reflectToAttribute: true,
        observer: "__editorPositionChanged"
      },
      /**
       * Enables user to click on row to edit it.
       * Note: When enabled, auto-generated grid won't show the edit column.
       * @attr {boolean} edit-on-click
       * @type {boolean}
       */
      editOnClick: {
        type: Boolean,
        value: false
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       * `params.pageSize` Current page size
       * `params.filters` Currently applied filters
       * `params.sortOrders` Currently applied sorting orders
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items
       * @type {CrudDataProvider | undefined}
       */
      dataProvider: {
        type: Function,
        observer: "__dataProviderChanged"
      },
      /**
       * Disable filtering when grid is autoconfigured.
       * @attr {boolean} no-filter
       */
      noFilter: Boolean,
      /**
       * Disable sorting when grid is autoconfigured.
       * @attr {boolean} no-sort
       */
      noSort: Boolean,
      /**
       * Remove grid headers when it is autoconfigured.
       * @attr {boolean} no-head
       */
      noHead: Boolean,
      /**
       * A comma-separated list of fields to include in the generated grid and the generated editor.
       *
       * It can be used to explicitly define the field order.
       *
       * When it is defined [`exclude`](#/elements/vaadin-crud#property-exclude) is ignored.
       *
       * Default is undefined meaning that all properties in the object should be mapped to fields.
       */
      include: String,
      /**
       * A comma-separated list of fields to be excluded from the generated grid and the generated editor.
       *
       * When [`include`](#/elements/vaadin-crud#property-include) is defined, this parameter is ignored.
       *
       * Default is to exclude all private fields (those properties starting with underscore)
       */
      exclude: String,
      /**
       * Reflects the opened status of the editor.
       */
      editorOpened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
        observer: "__editorOpenedChanged"
      },
      /**
       * Number of items in the data set which is reported by the grid.
       * Typically it reflects the number of filtered items displayed in the grid.
       */
      size: {
        type: Number,
        readOnly: true,
        notify: true
      },
      /**
       * Controls visibility state of toolbar.
       * When set to false toolbar is hidden and shown when set to true.
       * @attr {boolean} no-toolbar
       */
      noToolbar: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The object used to localize this component.
       * For changing the default localization, change the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   newItem: 'New item',
       *   editItem: 'Edit item',
       *   saveItem: 'Save',
       *   cancel: 'Cancel',
       *   deleteItem: 'Delete...',
       *   editLabel: 'Edit',
       *   confirm: {
       *     delete: {
       *       title: 'Confirm delete',
       *       content: 'Are you sure you want to delete the selected item? This action cannot be undone.',
       *       button: {
       *         confirm: 'Delete',
       *         dismiss: 'Cancel'
       *       }
       *     },
       *     cancel: {
       *       title: 'Unsaved changes',
       *       content: 'There are unsaved modifications to the item.',
       *       button: {
       *         confirm: 'Discard',
       *         dismiss: 'Continue editing'
       *       }
       *     }
       *   }
       * }
       * ```
       *
       * @type {!CrudI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value() {
          return {
            newItem: "New item",
            editItem: "Edit item",
            saveItem: "Save",
            cancel: "Cancel",
            deleteItem: "Delete...",
            editLabel: "Edit",
            confirm: {
              delete: {
                title: "Delete item",
                content: "Are you sure you want to delete this item? This action cannot be undone.",
                button: {
                  confirm: "Delete",
                  dismiss: "Cancel"
                }
              },
              cancel: {
                title: "Discard changes",
                content: "There are unsaved changes to this item.",
                button: {
                  confirm: "Discard",
                  dismiss: "Cancel"
                }
              }
            }
          };
        }
      },
      /** @private */
      __dialogAriaLabel: String,
      /** @private */
      __isDirty: Boolean,
      /** @private */
      __isNew: Boolean,
      /**
       * @type {boolean}
       * @protected
       */
      _fullscreen: {
        type: Boolean,
        observer: "__fullscreenChanged"
      },
      /**
       * @type {string}
       * @protected
       */
      _fullscreenMediaQuery: {
        value: "(max-width: 600px), (max-height: 600px)"
      }
    };
  }
  static get observers() {
    return [
      "__headerPropsChanged(_defaultHeader, __isNew, i18n.newItem, i18n.editItem)",
      "__formPropsChanged(_form, _theme, include, exclude)",
      "__gridPropsChanged(_grid, _theme, include, exclude, noFilter, noHead, noSort, items)",
      "__i18nChanged(i18n, _grid)",
      "__editOnClickChanged(editOnClick, _grid)",
      "__saveButtonPropsChanged(_saveButton, i18n.saveItem, __isDirty)",
      "__cancelButtonPropsChanged(_cancelButton, i18n.cancel)",
      "__deleteButtonPropsChanged(_deleteButton, i18n.deleteItem, __isNew)",
      "__newButtonPropsChanged(_newButton, i18n.newItem)"
    ];
  }
  /** @private */
  static _isValidEditorPosition(editorPosition) {
    return ["bottom", "aside"].includes(editorPosition);
  }
  constructor() {
    super();
    this.__cancel = this.__cancel.bind(this);
    this.__delete = this.__delete.bind(this);
    this.__save = this.__save.bind(this);
    this.__new = this.__new.bind(this);
    this.__onFormChange = this.__onFormChange.bind(this);
    this.__onGridEdit = this.__onGridEdit.bind(this);
    this.__onGridSizeChanged = this.__onGridSizeChanged.bind(this);
    this.__onGridActiveItemChanged = this.__onGridActiveItemChanged.bind(this);
    this.__focusRestorationController = new FocusRestorationController();
  }
  /** @protected */
  get _headerNode() {
    return this._headerController && this._headerController.node;
  }
  /**
   * A reference to all fields inside the [`_form`](#/elements/vaadin-crud#property-_form) element
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _fields() {
    if (!this.__fields || !this.__fields.length) {
      this.__fields = Array.from(this._form.querySelectorAll("*")).filter((e) => e.validate || e.checkValidity);
    }
    return this.__fields;
  }
  /** @protected */
  ready() {
    super.ready();
    this.$.dialog.$.overlay.addEventListener("vaadin-overlay-outside-click", this.__cancel);
    this.$.dialog.$.overlay.addEventListener("vaadin-overlay-escape-press", this.__cancel);
    this._headerController = new SlotController(this, "header", "h3", {
      initializer: (node) => {
        this._defaultHeader = node;
      }
    });
    this.addController(this._headerController);
    this._gridController = new GridSlotController(this);
    this.addController(this._gridController);
    this.addController(new FormSlotController(this));
    this._newButtonController = new ButtonSlotController(this, "new", "primary", this._noDefaultButtons);
    this._saveButtonController = new ButtonSlotController(this, "save", "primary", this._noDefaultButtons);
    this._cancelButtonController = new ButtonSlotController(this, "cancel", "tertiary", this._noDefaultButtons);
    this._deleteButtonController = new ButtonSlotController(this, "delete", "tertiary error", this._noDefaultButtons);
    this.addController(this._newButtonController);
    this.addController(this._saveButtonController);
    this.addController(this._cancelButtonController);
    this.addController(this._deleteButtonController);
    this.addController(
      new MediaQueryController(this._fullscreenMediaQuery, (matches) => {
        this._fullscreen = matches;
      })
    );
    this.addController(this.__focusRestorationController);
  }
  /**
   * @param {boolean} isDirty
   * @private
   */
  __isSaveBtnDisabled(isDirty) {
    return !isDirty;
  }
  /**
   * @param {HTMLElement | undefined} headerNode
   * @param {boolean} isNew
   * @param {string} i18nNewItem
   * @param {string} i18nEditItem
   * @private
   */
  __headerPropsChanged(headerNode, isNew, i18nNewItem, i18nEditItem) {
    if (headerNode) {
      headerNode.textContent = isNew ? i18nNewItem : i18nEditItem;
    }
  }
  /**
   * @param {CrudI18n} i18n
   * @param {CrudGrid | Grid} grid
   * @private
   */
  __i18nChanged(i18n, grid) {
    if (!grid) {
      return;
    }
    afterNextRender(grid, () => {
      Array.from(grid.querySelectorAll("vaadin-crud-edit-column")).forEach((column) => {
        column.ariaLabel = i18n.editLabel;
      });
    });
  }
  /** @private */
  __editorPositionChanged(editorPosition) {
    if (_Crud._isValidEditorPosition(editorPosition)) {
      return;
    }
    this.editorPosition = "";
  }
  /** @private */
  __editorOpenedChanged(opened, oldOpened) {
    if (!opened && oldOpened) {
      this.__closeEditor();
    } else {
      this.__formChanged(this._form);
    }
    if (opened) {
      this.__ensureChildren();
      if (this._form.parentElement === this) {
        this.$.editor.setAttribute("tabindex", "0");
        this.$.editor.focus();
      } else {
        this.$.editor.removeAttribute("tabindex");
      }
    }
    this.__toggleToolbar();
    this.$.scroller.scrollTop = 0;
  }
  /** @private */
  __fullscreenChanged(fullscreen, oldFullscreen) {
    if (fullscreen || oldFullscreen) {
      this.__toggleToolbar();
      this.__ensureChildren();
      this.toggleAttribute("fullscreen", fullscreen);
    }
  }
  /** @private */
  __toggleToolbar() {
    if (this.editorPosition === "bottom" && !this._fullscreen) {
      this.$.toolbar.style.display = this.editorOpened ? "none" : "";
    }
  }
  /** @private */
  __moveChildNodes(target) {
    const nodes = [this._headerNode, this._form, this._saveButton, this._cancelButton, this._deleteButton];
    if (!nodes.every((node) => node instanceof HTMLElement)) {
      return;
    }
    nodes.forEach((node) => {
      target.appendChild(node);
    });
    setTimeout(() => {
      this.__dialogAriaLabel = this._headerNode.textContent.trim();
    });
  }
  /** @private */
  __shouldOpenDialog(fullscreen, editorPosition) {
    return editorPosition === "" || fullscreen;
  }
  /** @private */
  __ensureChildren() {
    if (this.__shouldOpenDialog(this._fullscreen, this.editorPosition)) {
      this.__moveChildNodes(this.$.dialog.$.overlay);
    } else {
      this.__moveChildNodes(this);
    }
  }
  /** @private */
  __computeDialogOpened(opened, fullscreen, editorPosition) {
    return this.__shouldOpenDialog(fullscreen, editorPosition) ? opened : false;
  }
  /** @private */
  __computeEditorHidden(opened, fullscreen, editorPosition) {
    if (["aside", "bottom"].includes(editorPosition) && !fullscreen) {
      return !opened;
    }
    return true;
  }
  /** @private */
  __onDialogOpened(event) {
    this.editorOpened = event.detail.value;
  }
  /** @private */
  __onGridEdit(event) {
    event.stopPropagation();
    this.__confirmBeforeChangingEditedItem(event.detail.item);
  }
  /** @private */
  __onFormChange() {
    this.__isDirty = true;
  }
  /** @private */
  __onGridSizeChanged() {
    this._setSize(this._grid.size);
  }
  /**
   * @param {CrudGrid | Grid} grid
   * @param {CrudGrid | Grid | undefined} oldGrid
   * @private
   */
  __gridChanged(grid, oldGrid) {
    if (oldGrid) {
      oldGrid.removeEventListener("edit", this.__onGridEdit);
      oldGrid.removeEventListener("size-changed", this.__onGridSizeChanged);
    }
    if (this.dataProvider) {
      this.__dataProviderChanged(this.dataProvider);
    }
    if (this.editedItem) {
      this.__editedItemChanged(this.editedItem);
    }
    grid.addEventListener("edit", this.__onGridEdit);
    grid.addEventListener("size-changed", this.__onGridSizeChanged);
    this.__onGridSizeChanged();
  }
  /**
   * @param {HTMLElement | undefined | null} form
   * @param {HTMLElement | undefined | null} oldForm
   * @private
   */
  __formChanged(form, oldForm) {
    if (oldForm && oldForm.parentElement) {
      oldForm.parentElement.removeChild(oldForm);
      oldForm.removeEventListener("change", this.__onFormChange);
      oldForm.removeEventListener("input", this.__onFormChange);
    }
    if (!form) {
      return;
    }
    if (this.items) {
      this.__itemsChanged(this.items);
    }
    if (this.editedItem) {
      this.__editedItemChanged(this.editedItem);
    }
    form.addEventListener("change", this.__onFormChange);
    form.addEventListener("input", this.__onFormChange);
  }
  /**
   * @param {HTMLElement | undefined} form
   * @param {string} theme
   * @param {string | string[] | undefined} include
   * @param {string | RegExp} exclude
   * @private
   */
  __formPropsChanged(form, theme, include, exclude) {
    if (form) {
      form.include = include;
      form.exclude = exclude;
      if (theme) {
        form.setAttribute("theme", theme);
      } else {
        form.removeAttribute("theme");
      }
    }
  }
  /**
   * @param {HTMLElement | undefined} grid
   * @param {string} theme
   * @param {string | string[] | undefined} include
   * @param {string | RegExp} exclude
   * @param {boolean} noFilter
   * @param {boolean} noHead
   * @param {boolean} noSort
   * @param {Array<unknown> | undefined} items
   * @private
   */
  // eslint-disable-next-line max-params
  __gridPropsChanged(grid, theme, include, exclude, noFilter, noHead, noSort, items) {
    if (!grid) {
      return;
    }
    if (grid === this._gridController.defaultNode) {
      grid.noFilter = noFilter;
      grid.noHead = noHead;
      grid.noSort = noSort;
      grid.include = include;
      grid.exclude = exclude;
      if (theme) {
        grid.setAttribute("theme", theme);
      } else {
        grid.removeAttribute("theme");
      }
    }
    grid.items = items;
  }
  /**
   * @param {HTMLElement | undefined} saveButton
   * @param {string} i18nLabel
   * @param {boolean} isDirty
   * @private
   */
  __saveButtonPropsChanged(saveButton, i18nLabel, isDirty) {
    if (saveButton) {
      saveButton.toggleAttribute("disabled", this.__isSaveBtnDisabled(isDirty));
      if (saveButton === this._saveButtonController.defaultNode) {
        saveButton.textContent = i18nLabel;
      }
    }
  }
  /**
   * @param {HTMLElement | undefined} deleteButton
   * @param {string} i18nLabel
   * @param {boolean} isNew
   * @private
   */
  __deleteButtonPropsChanged(deleteButton, i18nLabel, isNew) {
    if (deleteButton) {
      deleteButton.toggleAttribute("hidden", isNew);
      if (deleteButton === this._deleteButtonController.defaultNode) {
        deleteButton.textContent = i18nLabel;
      }
    }
  }
  /**
   * @param {HTMLElement | undefined} cancelButton
   * @param {string} i18nLabel
   * @private
   */
  __cancelButtonPropsChanged(cancelButton, i18nLabel) {
    if (cancelButton && cancelButton === this._cancelButtonController.defaultNode) {
      cancelButton.textContent = i18nLabel;
    }
  }
  /**
   * @param {HTMLElement | undefined} newButton
   * @param {string} i18nNewItem
   * @private
   */
  __newButtonPropsChanged(newButton, i18nNewItem) {
    if (newButton && newButton === this._newButtonController.defaultNode) {
      newButton.textContent = i18nNewItem;
    }
  }
  /** @private */
  __dataProviderChanged(dataProvider) {
    if (this._grid) {
      this._grid.dataProvider = this.__createDataProviderProxy(dataProvider);
    }
  }
  /** @private */
  __editOnClickChanged(editOnClick, grid) {
    if (!grid) {
      return;
    }
    grid.hideEditColumn = editOnClick;
    if (editOnClick) {
      grid.addEventListener("active-item-changed", this.__onGridActiveItemChanged);
    } else {
      grid.removeEventListener("active-item-changed", this.__onGridActiveItemChanged);
    }
  }
  /** @private */
  __onGridActiveItemChanged(event) {
    const item = event.detail.value;
    if (this.editorOpened && this.__isDirty) {
      this.__confirmBeforeChangingEditedItem(item);
      return;
    }
    if (item) {
      this.__edit(item);
    } else if (!this.__keepOpened) {
      this.__closeEditor();
    }
  }
  /** @private */
  __confirmBeforeChangingEditedItem(item, keepOpened) {
    if (this.editorOpened && // Editor opened
    this.__isDirty && // Form change has been made
    this.editedItem !== item) {
      this.$.confirmCancel.opened = true;
      this.addEventListener(
        "cancel",
        (event) => {
          event.preventDefault();
          if (item || keepOpened) {
            this.__edit(item);
            this.__clearItemAndKeepEditorOpened(item, keepOpened);
          } else {
            this.__closeEditor();
          }
        },
        { once: true }
      );
    } else {
      this.__edit(item);
      this.__clearItemAndKeepEditorOpened(item, keepOpened);
    }
  }
  /** @private */
  __clearItemAndKeepEditorOpened(item, keepOpened) {
    if (!item) {
      setTimeout(() => {
        this.__keepOpened = keepOpened;
        this.editedItem = this._grid.activeItem = void 0;
      });
    }
  }
  /** @private */
  __createDataProviderProxy(dataProvider) {
    return (params, callback) => {
      const callbackProxy = (chunk, size) => {
        if (chunk && chunk[0]) {
          this.__model = chunk[0];
        }
        callback(chunk, size);
      };
      dataProvider(params, callbackProxy);
    };
  }
  /** @private */
  __itemsChanged(items) {
    if (this.items && this.items[0]) {
      this.__model = items[0];
    }
  }
  /** @private */
  __editedItemChanged(item) {
    if (!this._form) {
      return;
    }
    if (item) {
      if (!this._fields.length && this._form._configure) {
        if (this.__model) {
          this._form._configure(this.__model);
        } else {
          console.warn(
            "<vaadin-crud> Unable to autoconfigure form because the data structure is unknown. Either specify `include` or ensure at least one item is available beforehand."
          );
        }
      }
      this._form.item = item;
      this._fields.forEach((e) => {
        const path = e.path || e.getAttribute("path");
        if (path) {
          e.value = getProperty(path, item);
        }
      });
      this.__isNew = !!(this.__isNew || this.items && this.items.indexOf(item) < 0);
      this.editorOpened = true;
    }
  }
  /** @private */
  __validate() {
    return this._fields.every((e) => (e.validate || e.checkValidity).call(e));
  }
  /** @private */
  __setHighlightedItem(item) {
    if (this._grid === this._gridController.defaultNode) {
      this._grid.selectedItems = item ? [item] : [];
    }
  }
  /** @private */
  __closeEditor() {
    this.editorOpened = false;
    this.__isDirty = false;
    this.__setHighlightedItem(null);
    setTimeout(() => this.__clearItemAndKeepEditorOpened(null, false));
  }
  /** @private */
  __new() {
    this.__confirmBeforeChangingEditedItem(null, true);
  }
  /** @private */
  __edit(item) {
    if (this.editedItem === item) {
      return;
    }
    this.__setHighlightedItem(item);
    this.__openEditor("edit", item);
  }
  /** @private */
  __fireEvent(type, item) {
    const event = new CustomEvent(type, { detail: { item }, cancelable: true });
    this.dispatchEvent(event);
    return event.defaultPrevented === false;
  }
  /** @private */
  __openEditor(type, item) {
    this.__focusRestorationController.saveFocus();
    this.__isDirty = false;
    this.__isNew = !item;
    const result = this.__fireEvent(this.__isNew ? "new" : "edit", item);
    if (result) {
      this.editedItem = item || {};
    } else {
      this.editorOpened = true;
    }
  }
  /** @private */
  __restoreFocusOnDelete() {
    if (this._grid._flatSize === 1) {
      this._newButton.focus();
    } else {
      this._grid._focusFirstVisibleRow();
    }
  }
  /** @private */
  __restoreFocusOnSaveOrCancel() {
    const focusNode = this.__focusRestorationController.focusNode;
    const row = this._grid._getRowContainingNode(focusNode);
    if (!row) {
      this.__focusRestorationController.restoreFocus();
      return;
    }
    if (this._grid._isItemAssignedToRow(this.editedItem, row) && this._grid._isInViewport(row)) {
      this.__focusRestorationController.restoreFocus();
    } else {
      this._grid._focusFirstVisibleRow();
    }
  }
  /** @private */
  __save() {
    if (!this.__validate()) {
      return;
    }
    const item = { ...this.editedItem };
    this._fields.forEach((e) => {
      const path = e.path || e.getAttribute("path");
      if (path) {
        setProperty(path, e.value, item);
      }
    });
    const result = this.__fireEvent("save", item);
    if (result) {
      if (this.__isNew && !this.dataProvider) {
        if (!this.items) {
          this.items = [item];
        } else {
          this.items.push(item);
        }
      } else {
        if (!this.editedItem) {
          this.editedItem = {};
        }
        Object.assign(this.editedItem, item);
      }
      this.__restoreFocusOnSaveOrCancel();
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  /** @private */
  __cancel() {
    if (this.__isDirty) {
      this.$.confirmCancel.opened = true;
    } else {
      this.__confirmCancel();
    }
  }
  /** @private */
  __confirmCancel() {
    const result = this.__fireEvent("cancel", this.editedItem);
    if (result) {
      this.__restoreFocusOnSaveOrCancel();
      this.__closeEditor();
    }
  }
  /** @private */
  __delete() {
    this.$.confirmDelete.opened = true;
  }
  /** @private */
  __confirmDelete() {
    const result = this.__fireEvent("delete", this.editedItem);
    if (result) {
      if (this.items && this.items.indexOf(this.editedItem) >= 0) {
        this.items.splice(this.items.indexOf(this.editedItem), 1);
      }
      this.__restoreFocusOnDelete();
      this._grid.clearCache();
      this.__closeEditor();
    }
  }
  /**
   * Fired when user wants to edit an existing item. If the default is prevented, then
   * a new item is not assigned to the form, giving that responsibility to the app, though
   * dialog is always opened.
   *
   * @event edit
   * @param {Object} detail.item the item to edit
   */
  /**
   * Fired when user wants to create a new item.
   *
   * @event new
   */
  /**
   * Fired when user wants to delete item. If the default is prevented, then
   * no action is performed, items array is not modified nor dialog closed
   *
   * @event delete
   * @param {Object} detail.item the item to delete
   */
  /**
   * Fired when user discards edition. If the default is prevented, then
   * no action is performed, user is responsible to close dialog and reset
   * item and grid.
   *
   * @event cancel
   * @param {Object} detail.item the item to delete
   */
  /**
   * Fired when user wants to save a new or an existing item. If the default is prevented, then
   * no action is performed, items array is not modified nor dialog closed
   *
   * @event save
   * @param {Object} detail.item the item to save
   * @param {Object} detail.new whether the item is a new one
   */
};
defineCustomElement(Crud);
/*! Bundled license information:

@vaadin/crud/src/vaadin-crud-dialog.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/grid/src/vaadin-grid-filter-element-mixin.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/grid/src/vaadin-grid-filter.js:
  (**
   * @license
   * Copyright (c) 2016 - 2023 Vaadin Ltd.
   * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
   *)

@vaadin/crud/src/vaadin-crud-helpers.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/crud/src/vaadin-crud-include-mixin.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/crud/src/vaadin-crud-grid.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/crud/src/vaadin-crud-form.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/crud/src/vaadin-crud-controllers.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/crud/src/vaadin-crud.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)
*/
//# sourceMappingURL=@vaadin_crud_theme_lumo_vaadin-crud__js.js.map
