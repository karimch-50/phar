{
  "version": 3,
  "sources": ["../../@vaadin/a11y-base/src/aria-id-reference.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright (c) 2023 - 2024 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport {\n  addValueToAttribute,\n  deserializeAttributeValue,\n  removeValueFromAttribute,\n  serializeAttributeValue,\n} from '@vaadin/component-base/src/dom-utils.js';\n\nconst attributeToTargets = new Map();\n\n/**\n * Gets or creates a Set with the stored values for each element controlled by this helper\n *\n * @param {string} attr the attribute name used as key in the map\n *\n * @returns {WeakMap<HTMLElement, Set<string>} a weak map with the stored values for the elements being controlled by the helper\n */\nfunction getAttrMap(attr) {\n  if (!attributeToTargets.has(attr)) {\n    attributeToTargets.set(attr, new WeakMap());\n  }\n  return attributeToTargets.get(attr);\n}\n\n/**\n * Cleans the values set on the attribute to the given element.\n * It also stores the current values in the map, if `storeValue` is `true`.\n *\n * @param {HTMLElement} target\n * @param {string} attr the attribute to be cleared\n * @param {boolean} storeValue whether or not the current value of the attribute should be stored on the map\n * @returns\n */\nfunction cleanAriaIDReference(target, attr) {\n  if (!target) {\n    return;\n  }\n\n  target.removeAttribute(attr);\n}\n\n/**\n * Storing values of the accessible attributes in a Set inside of the WeakMap.\n *\n * @param {HTMLElement} target\n * @param {string} attr the attribute to be stored\n */\nfunction storeAriaIDReference(target, attr) {\n  if (!target || !attr) {\n    return;\n  }\n  const attributeMap = getAttrMap(attr);\n  if (attributeMap.has(target)) {\n    return;\n  }\n  const values = deserializeAttributeValue(target.getAttribute(attr));\n  attributeMap.set(target, new Set(values));\n}\n\n/**\n * Restores the generated values of the attribute to the given element.\n *\n * @param {HTMLElement} target\n * @param {string} attr\n */\nexport function restoreGeneratedAriaIDReference(target, attr) {\n  if (!target || !attr) {\n    return;\n  }\n  const attributeMap = getAttrMap(attr);\n  const values = attributeMap.get(target);\n  if (!values || values.size === 0) {\n    target.removeAttribute(attr);\n  } else {\n    addValueToAttribute(target, attr, serializeAttributeValue(values));\n  }\n  attributeMap.delete(target);\n}\n\n/**\n * Sets a new ID reference for a target element and an ARIA attribute.\n *\n * @typedef {Object} AriaIdReferenceConfig\n * @property {string | null | undefined} newId\n * @property {string | null | undefined} oldId\n * @property {boolean | null | undefined} fromUser\n * @param {HTMLElement} target\n * @param {string} attr\n * @param {AriaIdReferenceConfig | null | undefined} config\n * @param config.newId The new ARIA ID reference to set. If `null`, the attribute is removed,\n * and `config.fromUser` is true, any stored values are restored. If there are stored values\n * and `config.fromUser` is `false`, then `config.newId` is added to the stored values set.\n * @param config.oldId The ARIA ID reference to be removed from the attribute. If there are\n * stored values and `config.fromUser` is `false`, then `config.oldId` is removed from the\n * stored values set.\n * @param config.fromUser Indicates whether the function is called by the user or internally.\n * When `config.fromUser` is called with `true` for the first time, the function will clear\n * and store the attribute value for the given element.\n */\nexport function setAriaIDReference(target, attr, config = { newId: null, oldId: null, fromUser: false }) {\n  if (!target || !attr) {\n    return;\n  }\n\n  const { newId, oldId, fromUser } = config;\n\n  const attributeMap = getAttrMap(attr);\n  const storedValues = attributeMap.get(target);\n\n  if (!fromUser && !!storedValues) {\n    // If there's any stored values, it means the attribute is being handled by the user\n    // Replace the \"oldId\" with \"newId\" on the stored values set and leave\n    oldId && storedValues.delete(oldId);\n    newId && storedValues.add(newId);\n    return;\n  }\n\n  if (fromUser) {\n    if (!storedValues) {\n      // If it's called from user and there's no stored values for the attribute,\n      // then store the current value\n      storeAriaIDReference(target, attr);\n    } else if (!newId) {\n      // If called from user with newId == null, it means the attribute will no longer\n      // be in control of the user and the stored values should be restored\n      // Removing the entry on the map for this target\n      attributeMap.delete(target);\n    }\n\n    // If it's from user, then clear the attribute value before setting newId\n    cleanAriaIDReference(target, attr);\n  }\n\n  removeValueFromAttribute(target, attr, oldId);\n\n  const attributeValue = !newId ? serializeAttributeValue(storedValues) : newId;\n  if (attributeValue) {\n    addValueToAttribute(target, attr, attributeValue);\n  }\n}\n\n/**\n * Removes the {@link attr | attribute} value of the given {@link target} element.\n * It also stores the current value, if no stored values are present.\n *\n * @param {HTMLElement} target\n * @param {string} attr\n */\nexport function removeAriaIDReference(target, attr) {\n  storeAriaIDReference(target, attr);\n  cleanAriaIDReference(target, attr);\n}\n"],
  "mappings": ";;;;;;;;AAYA,IAAM,qBAAqB,oBAAI,IAAI;AASnC,SAAS,WAAW,MAAM;AACxB,MAAI,CAAC,mBAAmB,IAAI,IAAI,GAAG;AACjC,uBAAmB,IAAI,MAAM,oBAAI,QAAQ,CAAC;AAAA,EAC5C;AACA,SAAO,mBAAmB,IAAI,IAAI;AACpC;AAWA,SAAS,qBAAqB,QAAQ,MAAM;AAC1C,MAAI,CAAC,QAAQ;AACX;AAAA,EACF;AAEA,SAAO,gBAAgB,IAAI;AAC7B;AAQA,SAAS,qBAAqB,QAAQ,MAAM;AAC1C,MAAI,CAAC,UAAU,CAAC,MAAM;AACpB;AAAA,EACF;AACA,QAAM,eAAe,WAAW,IAAI;AACpC,MAAI,aAAa,IAAI,MAAM,GAAG;AAC5B;AAAA,EACF;AACA,QAAM,SAAS,0BAA0B,OAAO,aAAa,IAAI,CAAC;AAClE,eAAa,IAAI,QAAQ,IAAI,IAAI,MAAM,CAAC;AAC1C;AAQO,SAAS,gCAAgC,QAAQ,MAAM;AAC5D,MAAI,CAAC,UAAU,CAAC,MAAM;AACpB;AAAA,EACF;AACA,QAAM,eAAe,WAAW,IAAI;AACpC,QAAM,SAAS,aAAa,IAAI,MAAM;AACtC,MAAI,CAAC,UAAU,OAAO,SAAS,GAAG;AAChC,WAAO,gBAAgB,IAAI;AAAA,EAC7B,OAAO;AACL,wBAAoB,QAAQ,MAAM,wBAAwB,MAAM,CAAC;AAAA,EACnE;AACA,eAAa,OAAO,MAAM;AAC5B;AAsBO,SAAS,mBAAmB,QAAQ,MAAM,SAAS,EAAE,OAAO,MAAM,OAAO,MAAM,UAAU,MAAM,GAAG;AACvG,MAAI,CAAC,UAAU,CAAC,MAAM;AACpB;AAAA,EACF;AAEA,QAAM,EAAE,OAAO,OAAO,SAAS,IAAI;AAEnC,QAAM,eAAe,WAAW,IAAI;AACpC,QAAM,eAAe,aAAa,IAAI,MAAM;AAE5C,MAAI,CAAC,YAAY,CAAC,CAAC,cAAc;AAG/B,aAAS,aAAa,OAAO,KAAK;AAClC,aAAS,aAAa,IAAI,KAAK;AAC/B;AAAA,EACF;AAEA,MAAI,UAAU;AACZ,QAAI,CAAC,cAAc;AAGjB,2BAAqB,QAAQ,IAAI;AAAA,IACnC,WAAW,CAAC,OAAO;AAIjB,mBAAa,OAAO,MAAM;AAAA,IAC5B;AAGA,yBAAqB,QAAQ,IAAI;AAAA,EACnC;AAEA,2BAAyB,QAAQ,MAAM,KAAK;AAE5C,QAAM,iBAAiB,CAAC,QAAQ,wBAAwB,YAAY,IAAI;AACxE,MAAI,gBAAgB;AAClB,wBAAoB,QAAQ,MAAM,cAAc;AAAA,EAClD;AACF;AASO,SAAS,sBAAsB,QAAQ,MAAM;AAClD,uBAAqB,QAAQ,IAAI;AACjC,uBAAqB,QAAQ,IAAI;AACnC;",
  "names": []
}
