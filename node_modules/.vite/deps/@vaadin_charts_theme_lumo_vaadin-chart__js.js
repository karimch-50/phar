import {
  FlattenedNodesObserver
} from "./chunk-JLX4O4JZ.js";
import "./chunk-GTUSTTGL.js";
import {
  beforeNextRender
} from "./chunk-FSP2XZVR.js";
import {
  ResizeMixin
} from "./chunk-2JVJNHM2.js";
import {
  ElementMixin
} from "./chunk-MWSAWSJ3.js";
import "./chunk-SEGZ6IIL.js";
import "./chunk-R6DBYMLB.js";
import "./chunk-BORGCLO4.js";
import "./chunk-3WOFLRNV.js";
import "./chunk-J2NV7QBD.js";
import "./chunk-J4OM4IIF.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-BBNA52CT.js";
import "./chunk-25Y4ITXF.js";
import {
  css
} from "./chunk-CMT2GIH3.js";
import "./chunk-QO3ZNG6F.js";
import "./chunk-B6NQGUVK.js";
import {
  defineCustomElement
} from "./chunk-JDVQIXGE.js";
import "./chunk-ER2S4LLB.js";
import {
  PolymerElement
} from "./chunk-4TYUW4EB.js";
import "./chunk-FXP5WKMI.js";
import "./chunk-2IE6RYOR.js";
import {
  html
} from "./chunk-XB4RSW42.js";
import "./chunk-IIZJCMP5.js";
import "./chunk-GFCZVMCV.js";
import "./chunk-6WL6DBHT.js";
import "./chunk-WGAPYIUP.js";

// node_modules/@vaadin/charts/theme/vaadin-chart-base-theme.js
var chartBaseTheme = css`
  :host {
    font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Segoe UI', Helvetica, Arial, sans-serif,
      'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
    font-size: 12px;
    line-height: normal;
  }

  .highcharts-container {
    position: relative;
    overflow: hidden;
    width: 100%;
    height: 100%;
    text-align: left;
    z-index: 0;
    /* #1072 */
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  }

  :where([styled-mode]) .highcharts-root {
    display: block;
  }

  :where([styled-mode]) .highcharts-root text {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-strong {
    font-weight: 600;
  }

  :where([styled-mode]) .highcharts-emphasized {
    font-style: italic;
  }

  :where([styled-mode]) .highcharts-anchor {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-background {
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-plot-border,
  :where([styled-mode]) .highcharts-plot-background {
    fill: none;
  }

  :where([styled-mode]) .highcharts-label-box {
    fill: none;
  }

  :where([styled-mode]) .highcharts-button-box {
    fill: inherit;
  }

  :where([styled-mode]) .highcharts-tracker-line {
    stroke-linejoin: round;
    stroke: rgba(192, 192, 192, 0.0001);
    stroke-width: 22;
    fill: none;
  }

  :where([styled-mode]) .highcharts-tracker-area {
    fill: rgba(192, 192, 192, 0.0001);
    stroke-width: 0;
  }

  /* Titles */
  :where([styled-mode]) .highcharts-title {
    fill: var(--vaadin-charts-title-label, hsl(214, 35%, 15%));
    font-size: 1.5em;
    font-weight: 600;
  }

  :where([styled-mode]) .highcharts-subtitle {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  /* Axes */
  :where([styled-mode]) .highcharts-axis-line {
    fill: none;
    stroke: var(--vaadin-charts-axis-line, hsla(214, 61%, 25%, 0.05));
  }

  :where([styled-mode]) .highcharts-yaxis .highcharts-axis-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-axis-title {
    fill: var(--vaadin-charts-axis-title, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-axis-labels {
    fill: var(--vaadin-charts-axis-label, hsla(214, 42%, 18%, 0.72));
    cursor: default;
    font-size: 0.9em;
  }

  :where([styled-mode]) .highcharts-grid-line {
    fill: none;
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-xaxis-grid .highcharts-grid-line {
    stroke-width: var(--vaadin-charts-xaxis-line-width, 0px);
  }

  :where([styled-mode]) .highcharts-tick {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-yaxis .highcharts-tick {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-minor-grid-line {
    stroke: var(--vaadin-charts-contrast-5pct, hsla(214, 61%, 25%, 0.05));
  }

  :where([styled-mode]) .highcharts-crosshair-thin {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-crosshair-category {
    stroke: var(--vaadin-charts-color-0, #5ac2f7);
    stroke-opacity: 0.25;
  }

  /* Credits */
  :where([styled-mode]) .highcharts-credits {
    cursor: pointer;
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26));
    font-size: 0.7em;
    transition: fill 250ms, font-size 250ms;
  }

  :where([styled-mode]) .highcharts-credits:hover {
    fill: black;
    font-size: 1em;
  }

  /* Tooltip */
  :where([styled-mode]) .highcharts-tooltip {
    cursor: default;
    pointer-events: none;
    white-space: nowrap;
    transition: stroke 150ms;
  }

  :where([styled-mode]) .highcharts-tooltip {
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.05)) !important;
  }

  :where([styled-mode]) .highcharts-tooltip text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) .highcharts-tooltip .highcharts-header {
    font-size: 0.85em;
    color: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-tooltip-box {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-tooltip-border, inherit);
    fill: var(--vaadin-charts-tooltip-background, #fff);
    fill-opacity: var(--vaadin-charts-tooltip-background-opacity, 1);
  }

  :where([styled-mode]) .highcharts-tooltip-box .highcharts-label-box {
    fill: var(--vaadin-charts-tooltip-background, #fff);
    fill-opacity: var(--vaadin-charts-tooltip-background-opacity, 1);
  }

  :where([styled-mode]) .highcharts-tooltip-header {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) div.highcharts-tooltip {
    filter: none;
  }

  :where([styled-mode]) .highcharts-selection-marker {
    fill: var(--vaadin-charts-color-0, #5ac2f7);
    fill-opacity: 0.25;
  }

  :where([styled-mode]) .highcharts-graph {
    fill: none;
    stroke-width: 2px;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  :where([styled-mode]) .highcharts-state-hover .highcharts-graph {
    stroke-width: 3;
  }

  :where([styled-mode]) .highcharts-point-inactive {
    opacity: 0.2;
    transition: opacity 50ms;
    /* quick in */
  }

  :where([styled-mode]) .highcharts-series-inactive {
    opacity: 0.2;
    transition: opacity 50ms;
    /* quick in */
  }

  :where([styled-mode]) .highcharts-state-hover path {
    transition: stroke-width 50ms;
    /* quick in */
  }

  :where([styled-mode]) .highcharts-state-normal path {
    transition: stroke-width 250ms;
    /* slow out */
  }

  /* Legend hover affects points and series */
  :where([styled-mode]) g.highcharts-series,
  :where([styled-mode]) .highcharts-point,
  :where([styled-mode]) .highcharts-markers,
  :where([styled-mode]) .highcharts-data-labels {
    transition: opacity 250ms;
  }

  :where([styled-mode]) .highcharts-legend-series-active g.highcharts-series:not(.highcharts-series-hover),
  :where([styled-mode]) .highcharts-legend-point-active .highcharts-point:not(.highcharts-point-hover),
  :where([styled-mode]) .highcharts-legend-series-active .highcharts-markers:not(.highcharts-series-hover),
  :where([styled-mode]) .highcharts-legend-series-active .highcharts-data-labels:not(.highcharts-series-hover) {
    opacity: 0.2;
  }

  /* Series options */
  /* Default colors */
  /* vaadin-charts custom properties */
  /* Use of :where() function to avoid setting classes with high specificity */
  :where([styled-mode]) .highcharts-color-0 {
    fill: var(--vaadin-charts-color-0, #5ac2f7);
    stroke: var(--vaadin-charts-color-0, #5ac2f7);
  }

  :where([styled-mode]) .highcharts-color-1 {
    fill: var(--vaadin-charts-color-1, #1676f3);
    stroke: var(--vaadin-charts-color-1, #1676f3);
  }

  :where([styled-mode]) .highcharts-color-2 {
    fill: var(--vaadin-charts-color-2, #ff7d94);
    stroke: var(--vaadin-charts-color-2, #ff7d94);
  }

  :where([styled-mode]) .highcharts-color-3 {
    fill: var(--vaadin-charts-color-3, #c5164e);
    stroke: var(--vaadin-charts-color-3, #c5164e);
  }

  :where([styled-mode]) .highcharts-color-4 {
    fill: var(--vaadin-charts-color-4, #15c15d);
    stroke: var(--vaadin-charts-color-4, #15c15d);
  }

  :where([styled-mode]) .highcharts-color-5 {
    fill: var(--vaadin-charts-color-5, #0e8151);
    stroke: var(--vaadin-charts-color-5, #0e8151);
  }

  :where([styled-mode]) .highcharts-color-6 {
    fill: var(--vaadin-charts-color-6, #c18ed2);
    stroke: var(--vaadin-charts-color-6, #c18ed2);
  }

  :where([styled-mode]) .highcharts-color-7 {
    fill: var(--vaadin-charts-color-7, #9233b3);
    stroke: var(--vaadin-charts-color-7, #9233b3);
  }

  :where([styled-mode]) .highcharts-color-8 {
    fill: var(--vaadin-charts-color-8, #fda253);
    stroke: var(--vaadin-charts-color-8, #fda253);
  }

  :where([styled-mode]) .highcharts-color-9 {
    fill: var(--vaadin-charts-color-9, #e24932);
    stroke: var(--vaadin-charts-color-9, #e24932);
  }

  /* end of vaadin-charts custom properties */

  :where([styled-mode]) .highcharts-area {
    fill-opacity: 0.5;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-markers {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode])
    .highcharts-a11y-markers-hidden
    .highcharts-point:not(.highcharts-point-hover):not(.highcharts-a11y-marker-visible),
  :where([styled-mode]) .highcharts-a11y-marker-hidden {
    opacity: 0;
  }

  :where([styled-mode]) .highcharts-point {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-dense-data .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-data-label {
    font-size: 0.9em;
    font-weight: normal;
  }

  :where([styled-mode]) .highcharts-data-label-box {
    fill: none;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-data-label text,
  :where([styled-mode]) text.highcharts-data-label {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) .highcharts-data-label-connector {
    fill: none;
  }

  :where([styled-mode]) .highcharts-data-label-hidden {
    pointer-events: none;
  }

  :where([styled-mode]) .highcharts-halo {
    fill-opacity: 0.25;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-series:not(.highcharts-pie-series) .highcharts-point-select,
  :where([styled-mode]) .highcharts-markers .highcharts-point-select {
    fill: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-column-series rect.highcharts-point {
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-column-series .highcharts-point {
    transition: fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-column-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-pie-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-pie-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--vaadin-charts-background, #fff);
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-funnel-series .highcharts-point-select {
    fill: inherit;
    stroke: inherit;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point {
    stroke-linejoin: round;
    stroke: var(--vaadin-charts-background, #fff);
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point-hover {
    fill-opacity: 0.75;
    transition: fill-opacity 50ms;
  }

  :where([styled-mode]) .highcharts-pyramid-series .highcharts-point-select {
    fill: inherit;
    stroke: inherit;
  }

  :where([styled-mode]) .highcharts-solidgauge-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-point {
    stroke-width: 2px;
    stroke: var(--vaadin-charts-background, #fff);
    transition: stroke 250ms, fill 250ms, fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-point-hover {
    stroke-width: 0px;
    stroke: var(--vaadin-charts-background, #fff);
    fill-opacity: 0.75;
    transition: stroke 25ms, fill 25ms, fill-opacity 25ms;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-above-level {
    display: none;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node {
    fill: none;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node-interactive {
    fill-opacity: 0.15;
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-treemap-series .highcharts-internal-node-interactive:hover {
    fill-opacity: 0.75;
  }

  :where([styled-mode]) .highcharts-vector-series .highcharts-point {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-windbarb-series .highcharts-point {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-lollipop-stem {
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-focus-border {
    fill: none;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-legend-item-hidden .highcharts-focus-border {
    fill: none !important;
  }

  /* Legend */
  :where([styled-mode]) .highcharts-legend-box {
    fill: none;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-legend-item > text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
    font-weight: normal;
    font-size: 1em;
    cursor: pointer;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-legend-item > .highcharts-point {
    stroke-width: 0px;
  }

  :where([styled-mode]) .highcharts-legend-item:hover text {
    fill: var(--vaadin-charts-title-label, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-legend-item-hidden * {
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26)) !important;
    stroke: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26)) !important;
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-legend-nav-active {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-legend-nav-inactive {
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26));
  }

  :where([styled-mode]) circle.highcharts-legend-nav-active,
  :where([styled-mode]) circle.highcharts-legend-nav-inactive {
    /* tracker */
    fill: rgba(192, 192, 192, 0.0001);
  }

  :where([styled-mode]) .highcharts-legend-title-box {
    fill: none;
    stroke-width: 0;
  }

  /* Bubble legend */
  :where([styled-mode]) .highcharts-bubble-legend-symbol {
    stroke-width: 2;
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-bubble-legend-connectors {
    stroke-width: 1;
  }

  :where([styled-mode]) .highcharts-bubble-legend-labels {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  /* Loading */
  :where([styled-mode]) .highcharts-loading {
    position: absolute;
    background-color: var(--vaadin-charts-background, #fff);
    opacity: 0.5;
    text-align: center;
    z-index: 10;
    transition: opacity 250ms;
  }

  :where([styled-mode]) .highcharts-loading-hidden {
    height: 0 !important;
    opacity: 0;
    overflow: hidden;
    transition: opacity 250ms, height 250ms step-end;
  }

  :where([styled-mode]) .highcharts-loading-inner {
    font-weight: normal;
    position: relative;
    top: 45%;
  }

  /* Plot bands and polar pane backgrounds */
  :where([styled-mode]) .highcharts-plot-band,
  :where([styled-mode]) .highcharts-pane {
    fill: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    fill-opacity: 0.05;
  }

  :where([styled-mode]) .highcharts-plot-line {
    fill: none;
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-plot-line-label {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  /* Highcharts More and modules */
  :where([styled-mode]) .highcharts-boxplot-box {
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-boxplot-median {
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-bubble-series .highcharts-point {
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-errorbar-series .highcharts-point {
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
  }

  :where([styled-mode]) .highcharts-gauge-series .highcharts-data-label-box {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-gauge-series .highcharts-dial {
    fill: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-polygon-series .highcharts-graph {
    fill: inherit;
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-waterfall-series .highcharts-graph {
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    stroke-dasharray: 1, 3;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-link {
    transition: fill 250ms, fill-opacity 250ms;
    fill-opacity: 0.5;
  }

  :where([styled-mode]) .highcharts-sankey-series .highcharts-point-hover.highcharts-link {
    transition: fill 50ms, fill-opacity 50ms;
    fill-opacity: 1;
  }

  :where([styled-mode]) .highcharts-venn-series .highcharts-point {
    fill-opacity: 0.75;
    stroke: var(--vaadin-charts-background, #fff);
    transition: stroke 250ms, fill-opacity 250ms;
  }

  :where([styled-mode]) .highcharts-venn-series .highcharts-point-hover {
    fill-opacity: 1;
    stroke: var(--vaadin-charts-background, #fff);
  }

  /* Highstock */
  :where([styled-mode]) .highcharts-navigator-mask-outside {
    fill-opacity: 0;
  }

  :where([styled-mode]) .highcharts-navigator-mask-inside {
    fill: var(--vaadin-charts-color-0, #5ac2f7);
    /* navigator.maskFill option */
    fill-opacity: 0.2;
    cursor: ew-resize;
  }

  :where([styled-mode]) .highcharts-navigator-outline {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    fill: none;
  }

  :where([styled-mode]) .highcharts-navigator-handle {
    stroke: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
    fill: var(--vaadin-charts-background, #fff);
    cursor: ew-resize;
  }

  :where([styled-mode]) .highcharts-navigator-series {
    fill: var(--vaadin-charts-color-1, #1676f3);
    stroke: var(--vaadin-charts-color-1, #1676f3);
  }

  :where([styled-mode]) .highcharts-navigator-series .highcharts-graph {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-navigator-series .highcharts-area {
    fill-opacity: 0.05;
  }

  :where([styled-mode]) .highcharts-navigator-xaxis .highcharts-axis-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-navigator-xaxis .highcharts-grid-line {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-navigator-xaxis.highcharts-axis-labels {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-navigator-yaxis .highcharts-grid-line {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-scrollbar-thumb {
    fill: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-scrollbar-button {
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-scrollbar-arrow {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) .highcharts-scrollbar-rifles {
    stroke: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-scrollbar-track {
    fill: var(--vaadin-charts-contrast-5pct, hsla(214, 61%, 25%, 0.05));
  }

  :where([styled-mode]) .highcharts-button {
    fill: var(--vaadin-charts-button-background, hsla(214, 61%, 25%, 0.05));
    cursor: default;
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-button text {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    font-weight: 600;
  }

  :where([styled-mode]) .highcharts-button-hover {
    transition: fill 0ms;
    fill: var(--vaadin-charts-button-hover-background, hsla(214, 90%, 52%, 0.1));
    stroke-width: 0px;
  }

  :where([styled-mode]) .highcharts-button-hover text {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
  }

  :where([styled-mode]) .highcharts-button-pressed {
    fill: var(--vaadin-charts-button-active-background, hsl(214, 90%, 52%));
  }

  :where([styled-mode]) .highcharts-button-pressed text {
    fill: var(--vaadin-charts-button-active-label, #fff);
  }

  :where([styled-mode]) .highcharts-button-disabled text {
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
  }

  :where([styled-mode]) .highcharts-range-selector-buttons > text {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-range-selector-buttons .highcharts-button {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-range-label rect {
    fill: none;
  }

  :where([styled-mode]) .highcharts-range-label text {
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  :where([styled-mode]) .highcharts-range-input rect {
    fill: var(--vaadin-charts-contrast-10pct, hsla(214, 57%, 24%, 0.1));
    rx: 2;
    ry: 2;
  }

  :where([styled-mode]) .highcharts-range-input:hover rect {
    fill: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-range-input text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
  }

  :where([styled-mode]) input.highcharts-range-selector {
    position: absolute;
    border: 0;
    width: 1px;
    /* Chrome needs a pixel to see it */
    height: 1px;
    padding: 0;
    text-align: center;
    left: -9em;
    /* #4798 */
  }

  :where([styled-mode]) .highcharts-crosshair-label text {
    fill: var(--vaadin-charts-background, #fff);
    font-size: 1.1em;
  }

  :where([styled-mode]) .highcharts-crosshair-label .highcharts-label-box {
    fill: inherit;
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point {
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point-up {
    fill: var(--vaadin-charts-color-positive, #15c15d);
  }

  :where([styled-mode]) .highcharts-candlestick-series .highcharts-point-down {
    fill: var(--vaadin-charts-color-negative, #e24932);
  }

  :where([styled-mode]) .highcharts-ohlc-series .highcharts-point-hover {
    stroke-width: 3px;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point .highcharts-label-box {
    stroke: var(--vaadin-charts-grid-line, hsla(214, 53%, 23%, 0.16));
    fill: var(--vaadin-charts-background, #fff);
    transition: fill 250ms;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point-hover .highcharts-label-box {
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
    fill: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point text {
    fill: var(--vaadin-charts-data-label, hsla(214, 40%, 16%, 0.94));
    font-size: 0.9em;
    font-weight: normal;
  }

  :where([styled-mode]) .highcharts-flags-series .highcharts-point-hover text {
    fill: var(--vaadin-charts-title-label, hsl(214, 35%, 15%));
  }

  /* Highmaps */
  :where([styled-mode]) .highcharts-map-series .highcharts-point {
    transition: fill 500ms, fill-opacity 500ms, stroke-width 250ms;
    stroke: var(--vaadin-charts-contrast-20pct, hsla(214, 53%, 23%, 0.16));
  }

  :where([styled-mode]) .highcharts-map-series .highcharts-point-hover {
    transition: fill 0ms, fill-opacity 0ms;
    fill-opacity: 0.5;
    stroke-width: 2px;
  }

  :where([styled-mode]) .highcharts-mapline-series .highcharts-point {
    fill: none;
  }

  :where([styled-mode]) .highcharts-heatmap-series .highcharts-point {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-map-navigation {
    font-size: 1.3em;
    font-weight: normal;
    text-align: center;
  }

  :where([styled-mode]) .highcharts-coloraxis {
    stroke-width: 0;
  }

  :where([styled-mode]) .highcharts-coloraxis-grid .highcharts-grid-line {
    stroke: var(--vaadin-charts-background, #fff);
  }

  :where([styled-mode]) .highcharts-coloraxis-marker {
    fill: var(--vaadin-charts-axis-label, hsla(214, 42%, 18%, 0.72));
    stroke-width: 0px;
  }

  :where([styled-mode]) .highcharts-null-point {
    fill: var(--vaadin-charts-contrast-5pct, hsla(214, 61%, 25%, 0.05));
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
  }

  /* 3d charts */
  :where([styled-mode]) .highcharts-3d-frame {
    fill: transparent;
  }

  /* Exporting module */
  :where([styled-mode]) .highcharts-contextbutton {
    fill: #fff;
    /* needed to capture hover */
    stroke: none;
    stroke-linecap: round;
  }

  :where([styled-mode]) .highcharts-contextbutton:hover {
    fill: #e6e6e6;
    stroke: #e6e6e6;
  }

  :where([styled-mode]) .highcharts-button-symbol {
    stroke: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
    stroke-width: 3px;
  }

  :where([styled-mode]) .highcharts-menu {
    border: 1px solid #999;
    background: #fff;
    padding: 5px 0;
    box-shadow: 3px 3px 10px #888;
  }

  :where([styled-mode]) .highcharts-menu-item {
    padding: 0.5em 1em;
    background: none;
    color: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    cursor: pointer;
    transition: background 250ms, color 250ms;
  }

  :where([styled-mode]) .highcharts-menu-item:hover {
    background: #335cad;
    color: #fff;
  }

  /* Drilldown module */
  :where([styled-mode]) .highcharts-drilldown-point {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-drilldown-data-label text,
  :where([styled-mode]) text.highcharts-drilldown-data-label,
  :where([styled-mode]) .highcharts-drilldown-axis-label {
    cursor: pointer;
    fill: var(--vaadin-charts-button-label, hsl(214, 90%, 52%));
    font-weight: normal;
    text-decoration: underline;
  }

  /* No-data module */
  :where([styled-mode]) .highcharts-no-data text {
    font-weight: normal;
    font-size: 1rem;
    fill: var(--vaadin-charts-secondary-label, hsla(214, 42%, 18%, 0.72));
  }

  /* Drag-panes module */
  :where([styled-mode]) .highcharts-axis-resizer {
    cursor: ns-resize;
    stroke: black;
    stroke-width: 2px;
  }

  /* Bullet type series */
  :where([styled-mode]) .highcharts-bullet-target {
    stroke-width: 0;
  }

  /* Lineargauge type series */
  :where([styled-mode]) .highcharts-lineargauge-target {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
  }

  :where([styled-mode]) .highcharts-lineargauge-target-line {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast-60pct, hsla(214, 43%, 19%, 0.61));
  }

  /* Annotations module */
  :where([styled-mode]) .highcharts-annotation-label-box {
    stroke-width: 1px;
    stroke: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    fill: var(--vaadin-charts-contrast, hsl(214, 35%, 15%));
    fill-opacity: 0.75;
  }

  :where([styled-mode]) .highcharts-annotation-label text {
    fill: var(--vaadin-charts-disabled-label, hsla(214, 50%, 22%, 0.26));
  }

  /* Gantt */
  :where([styled-mode]) .highcharts-treegrid-node-collapsed,
  :where([styled-mode]) .highcharts-treegrid-node-expanded {
    cursor: pointer;
  }

  :where([styled-mode]) .highcharts-point-connecting-path {
    fill: none;
  }

  :where([styled-mode]) .highcharts-grid-axis .highcharts-tick {
    stroke-width: 1px;
  }

  :where([styled-mode]) .highcharts-grid-axis .highcharts-axis-line {
    stroke-width: 1px;
  }

  /* RTL styles */
  :host([dir='rtl']) :where([styled-mode]) .highcharts-container {
    text-align: right;
  }

  :host([dir='rtl']) :where([styled-mode]) input.highcharts-range-selector {
    left: auto;
    right: -9em;
  }

  :host([dir='rtl']) :where([styled-mode]) .highcharts-menu {
    box-shadow: -3px 3px 10px #888;
  }

  /* https://github.com/highcharts/highcharts/issues/16282 */
  /* without this the resize callback always calls __reflow */
  ul[aria-hidden='false'] {
    margin: 0px;
  }
`;
registerStyles("vaadin-chart", chartBaseTheme, { moduleId: "vaadin-chart-base-theme" });

// node_modules/@vaadin/charts/theme/lumo/vaadin-chart-styles.js
var chartColors = css`
  :host {
    --vaadin-charts-color-0: #5ac2f7;
    --vaadin-charts-color-1: #1676f3;
    --vaadin-charts-color-2: #ff7d94;
    --vaadin-charts-color-3: #c5164e;
    --vaadin-charts-color-4: #15c15d;
    --vaadin-charts-color-5: #0e8151;
    --vaadin-charts-color-6: #c18ed2;
    --vaadin-charts-color-7: #9233b3;
    --vaadin-charts-color-8: #fda253;
    --vaadin-charts-color-9: #e24932;
    --vaadin-charts-color-positive: var(--vaadin-charts-color-4, #15c15d);
    --vaadin-charts-color-negative: var(--vaadin-charts-color-9, #e24932);
  }

  :host([theme~='gradient']) {
    --vaadin-charts-color-0: #1676f3;
    --vaadin-charts-color-1: #13bbf0;
    --vaadin-charts-color-2: #1ee;
    --vaadin-charts-color-3: #0cd9bf;
    --vaadin-charts-color-4: #06be81;
    --vaadin-charts-color-5: #00a344;
    --vaadin-charts-color-6: #41c639;
    --vaadin-charts-color-7: #8aed2c;
    --vaadin-charts-color-8: #c0e632;
    --vaadin-charts-color-9: #f6db3a;
    --vaadin-charts-color-positive: var(--vaadin-charts-color-6);
    --vaadin-charts-color-negative: var(--vaadin-charts-color-1);
  }

  :host([theme~='monotone']) {
    --vaadin-charts-color-0: #1676f3;
    --vaadin-charts-color-1: #4795f5;
    --vaadin-charts-color-2: #71b0f7;
    --vaadin-charts-color-3: #a0cef9;
    --vaadin-charts-color-4: #bce0fa;
    --vaadin-charts-color-5: #a8d8ed;
    --vaadin-charts-color-6: #7fc3dd;
    --vaadin-charts-color-7: #54adcc;
    --vaadin-charts-color-8: #2b99bc;
    --vaadin-charts-color-9: #0284ac;
    --vaadin-charts-color-positive: var(--vaadin-charts-color-3);
    --vaadin-charts-color-negative: var(--vaadin-charts-color-9);
  }

  :host([theme~='classic']) {
    --vaadin-charts-color-0: #7cb5ec;
    --vaadin-charts-color-1: #434348;
    --vaadin-charts-color-2: #90ed7d;
    --vaadin-charts-color-3: #f7a35c;
    --vaadin-charts-color-4: #8085e9;
    --vaadin-charts-color-5: #f15c80;
    --vaadin-charts-color-6: #e4d354;
    --vaadin-charts-color-7: #2b908f;
    --vaadin-charts-color-8: #f45b5b;
    --vaadin-charts-color-9: #91e8e1;
  }
`;
var chartTheme = css`
  :host {
    --vaadin-charts-background: var(--lumo-base-color);
    --vaadin-charts-title-label: var(--lumo-header-text-color);
    --vaadin-charts-axis-title: var(--lumo-secondary-text-color);
    --vaadin-charts-axis-label: var(--lumo-secondary-text-color);
    --vaadin-charts-data-label: var(--lumo-body-text-color);
    --vaadin-charts-secondary-label: var(--lumo-secondary-text-color);
    --vaadin-charts-axis-line: var(--lumo-contrast-5pct);
    --vaadin-charts-grid-line: var(--lumo-contrast-20pct);
    --vaadin-charts-disabled-label: var(--lumo-disabled-text-color);
    --vaadin-charts-contrast: var(--lumo-contrast);
    --vaadin-charts-contrast-5pct: var(--lumo-contrast-5pct);
    --vaadin-charts-contrast-10pct: var(--lumo-contrast-10pct);
    --vaadin-charts-contrast-20pct: var(--lumo-contrast-20pct);
    --vaadin-charts-contrast-60pct: var(--lumo-contrast-60pct);
    --vaadin-charts-tooltip-background: var(--lumo-base-color);
    --vaadin-charts-tooltip-border-color: inherit;
    --vaadin-charts-button-label: var(--lumo-primary-text-color);
    --vaadin-charts-button-background: var(--lumo-contrast-5pct);
    --vaadin-charts-button-hover-background: var(--lumo-primary-color-10pct);
    --vaadin-charts-button-active-label: var(--lumo-primary-contrast-color);
    --vaadin-charts-button-active-background: var(--lumo-primary-color);
    --vaadin-charts-xaxis-line-width: 0;
    --vaadin-charts-tooltip-background-opacity: 1;
    font-family: var(--lumo-font-family);
  }
`;
registerStyles("vaadin-chart", [chartColors, chartTheme], { moduleId: "lumo-chart" });

// node_modules/highcharts/es-modules/Core/Globals.js
var w = typeof win !== "undefined" ? win : typeof window !== "undefined" ? window : {};
var Globals;
(function(Globals2) {
  Globals2.SVG_NS = "http://www.w3.org/2000/svg", Globals2.product = "Highcharts", Globals2.version = "9.2.2", Globals2.win = w, Globals2.doc = Globals2.win.document, Globals2.svg = Globals2.doc && Globals2.doc.createElementNS && !!Globals2.doc.createElementNS(Globals2.SVG_NS, "svg").createSVGRect, Globals2.userAgent = Globals2.win.navigator && Globals2.win.navigator.userAgent || "", Globals2.isChrome = Globals2.userAgent.indexOf("Chrome") !== -1, Globals2.isFirefox = Globals2.userAgent.indexOf("Firefox") !== -1, Globals2.isMS = /(edge|msie|trident)/i.test(Globals2.userAgent) && !Globals2.win.opera, Globals2.isSafari = !Globals2.isChrome && Globals2.userAgent.indexOf("Safari") !== -1, Globals2.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals2.userAgent), Globals2.isWebKit = Globals2.userAgent.indexOf("AppleWebKit") !== -1, Globals2.deg2rad = Math.PI * 2 / 360, Globals2.hasBidiBug = Globals2.isFirefox && parseInt(Globals2.userAgent.split("Firefox/")[1], 10) < 4, Globals2.hasTouch = !!Globals2.win.TouchEvent, Globals2.marginNames = [
    "plotTop",
    "marginRight",
    "marginBottom",
    "plotLeft"
  ], Globals2.noop = function() {
  }, Globals2.supportsPassiveEvents = function() {
    var supportsPassive = false;
    if (!Globals2.isMS) {
      var opts = Object.defineProperty({}, "passive", {
        get: function() {
          supportsPassive = true;
        }
      });
      if (Globals2.win.addEventListener && Globals2.win.removeEventListener) {
        Globals2.win.addEventListener("testPassive", Globals2.noop, opts);
        Globals2.win.removeEventListener("testPassive", Globals2.noop, opts);
      }
    }
    return supportsPassive;
  }();
  Globals2.charts = [];
  Globals2.dateFormats = {};
  Globals2.seriesTypes = {};
  Globals2.symbolSizes = {};
  Globals2.chartCount = 0;
})(Globals || (Globals = {}));
var Globals_default = Globals;

// node_modules/highcharts/es-modules/Core/Utilities.js
var charts = Globals_default.charts;
var doc = Globals_default.doc;
var win2 = Globals_default.win;
function error(code, stop4, chart, params) {
  var severity = stop4 ? "Highcharts error" : "Highcharts warning";
  if (code === 32) {
    code = severity + ": Deprecated member";
  }
  var isCode = isNumber(code);
  var message = isCode ? severity + " #" + code + ": www.highcharts.com/errors/" + code + "/" : code.toString();
  var defaultHandler = function() {
    if (stop4) {
      throw new Error(message);
    }
    if (win2.console && error.messages.indexOf(message) === -1) {
      console.warn(message);
    }
  };
  if (typeof params !== "undefined") {
    var additionalMessages_1 = "";
    if (isCode) {
      message += "?";
    }
    objectEach(params, function(value, key) {
      additionalMessages_1 += "\n - " + key + ": " + value;
      if (isCode) {
        message += encodeURI(key) + "=" + encodeURI(value);
      }
    });
    message += additionalMessages_1;
  }
  fireEvent(Globals_default, "displayError", { chart, code, message, params }, defaultHandler);
  error.messages.push(message);
}
(function(error12) {
  error12.messages = [];
})(error || (error = {}));
function merge() {
  var i, args = arguments, ret = {};
  var doCopy = function(copy, original) {
    if (typeof copy !== "object") {
      copy = {};
    }
    objectEach(original, function(value, key) {
      if (key === "__proto__" || key === "constructor") {
        return;
      }
      if (isObject(value, true) && !isClass(value) && !isDOMElement(value)) {
        copy[key] = doCopy(copy[key] || {}, value);
      } else {
        copy[key] = original[key];
      }
    });
    return copy;
  };
  if (args[0] === true) {
    ret = args[1];
    args = Array.prototype.slice.call(args, 2);
  }
  var len = args.length;
  for (i = 0; i < len; i++) {
    ret = doCopy(ret, args[i]);
  }
  return ret;
}
function clamp(value, min, max) {
  return value > min ? value < max ? value : max : min;
}
function cleanRecursively(newer, older) {
  var result2 = {};
  objectEach(newer, function(_val, key) {
    var ob;
    if (isObject(newer[key], true) && !newer.nodeType && // #10044
    older[key]) {
      ob = cleanRecursively(newer[key], older[key]);
      if (Object.keys(ob).length) {
        result2[key] = ob;
      }
    } else if (isObject(newer[key]) || newer[key] !== older[key]) {
      result2[key] = newer[key];
    }
  });
  return result2;
}
function pInt(s, mag) {
  return parseInt(s, mag || 10);
}
function isString(s) {
  return typeof s === "string";
}
function isArray(obj) {
  var str = Object.prototype.toString.call(obj);
  return str === "[object Array]" || str === "[object Array Iterator]";
}
function isObject(obj, strict) {
  return !!obj && typeof obj === "object" && (!strict || !isArray(obj));
}
function isDOMElement(obj) {
  return isObject(obj) && typeof obj.nodeType === "number";
}
function isClass(obj) {
  var c = obj && obj.constructor;
  return !!(isObject(obj, true) && !isDOMElement(obj) && (c && c.name && c.name !== "Object"));
}
function isNumber(n) {
  return typeof n === "number" && !isNaN(n) && n < Infinity && n > -Infinity;
}
function erase(arr, item) {
  var i = arr.length;
  while (i--) {
    if (arr[i] === item) {
      arr.splice(i, 1);
      break;
    }
  }
}
function defined(obj) {
  return typeof obj !== "undefined" && obj !== null;
}
function attr2(elem, prop, value) {
  var ret;
  if (isString(prop)) {
    if (defined(value)) {
      elem.setAttribute(prop, value);
    } else if (elem && elem.getAttribute) {
      ret = elem.getAttribute(prop);
      if (!ret && prop === "class") {
        ret = elem.getAttribute(prop + "Name");
      }
    }
  } else {
    objectEach(prop, function(val, key) {
      elem.setAttribute(key, val);
    });
  }
  return ret;
}
function splat(obj) {
  return isArray(obj) ? obj : [obj];
}
function syncTimeout(fn, delay, context) {
  if (delay > 0) {
    return setTimeout(fn, delay, context);
  }
  fn.call(0, context);
  return -1;
}
function internalClearTimeout(id) {
  if (defined(id)) {
    clearTimeout(id);
  }
}
function extend(a, b) {
  var n;
  if (!a) {
    a = {};
  }
  for (n in b) {
    a[n] = b[n];
  }
  return a;
}
function pick() {
  var args = arguments;
  var length = args.length;
  for (var i = 0; i < length; i++) {
    var arg = args[i];
    if (typeof arg !== "undefined" && arg !== null) {
      return arg;
    }
  }
}
function css2(el, styles) {
  if (Globals_default.isMS && !Globals_default.svg) {
    if (styles && typeof styles.opacity !== "undefined") {
      styles.filter = "alpha(opacity=" + styles.opacity * 100 + ")";
    }
  }
  extend(el.style, styles);
}
function createElement(tag, attribs, styles, parent, nopad) {
  var el = doc.createElement(tag);
  if (attribs) {
    extend(el, attribs);
  }
  if (nopad) {
    css2(el, { padding: "0", border: "none", margin: "0" });
  }
  if (styles) {
    css2(el, styles);
  }
  if (parent) {
    parent.appendChild(el);
  }
  return el;
}
function extendClass(parent, members) {
  var obj = function() {
  };
  obj.prototype = new parent();
  extend(obj.prototype, members);
  return obj;
}
function pad(number, length, padder) {
  return new Array((length || 2) + 1 - String(number).replace("-", "").length).join(padder || "0") + number;
}
function relativeLength(value, base, offset3) {
  return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset3 || 0) : parseFloat(value);
}
function wrap(obj, method, func) {
  var proceed = obj[method];
  obj[method] = function() {
    var args = Array.prototype.slice.call(arguments), outerArgs = arguments, ctx = this;
    ctx.proceed = function() {
      proceed.apply(ctx, arguments.length ? arguments : outerArgs);
    };
    args.unshift(proceed);
    var ret = func.apply(this, args);
    ctx.proceed = null;
    return ret;
  };
}
function getMagnitude(num) {
  return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
}
function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, hasTickAmount) {
  var i, retInterval = interval;
  magnitude = pick(magnitude, 1);
  var normalized = interval / magnitude;
  if (!multiples) {
    multiples = hasTickAmount ? (
      // Finer grained ticks when the tick amount is hard set, including
      // when alignTicks is true on multiple axes (#4580).
      [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]
    ) : (
      // Else, let ticks fall on rounder numbers
      [1, 2, 2.5, 5, 10]
    );
    if (allowDecimals === false) {
      if (magnitude === 1) {
        multiples = multiples.filter(function(num) {
          return num % 1 === 0;
        });
      } else if (magnitude <= 0.1) {
        multiples = [1 / magnitude];
      }
    }
  }
  for (i = 0; i < multiples.length; i++) {
    retInterval = multiples[i];
    if (hasTickAmount && retInterval * magnitude >= interval || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
      break;
    }
  }
  retInterval = correctFloat(retInterval * magnitude, -Math.round(Math.log(1e-3) / Math.LN10));
  return retInterval;
}
function stableSort(arr, sortFunction) {
  var length = arr.length;
  var sortValue, i;
  for (i = 0; i < length; i++) {
    arr[i].safeI = i;
  }
  arr.sort(function(a, b) {
    sortValue = sortFunction(a, b);
    return sortValue === 0 ? a.safeI - b.safeI : sortValue;
  });
  for (i = 0; i < length; i++) {
    delete arr[i].safeI;
  }
}
function arrayMin(data) {
  var i = data.length, min = data[0];
  while (i--) {
    if (data[i] < min) {
      min = data[i];
    }
  }
  return min;
}
function arrayMax(data) {
  var i = data.length, max = data[0];
  while (i--) {
    if (data[i] > max) {
      max = data[i];
    }
  }
  return max;
}
function destroyObjectProperties(obj, except) {
  objectEach(obj, function(val, n) {
    if (val && val !== except && val.destroy) {
      val.destroy();
    }
    delete obj[n];
  });
}
function discardElement(element) {
  if (!garbageBin) {
    garbageBin = createElement("div");
  }
  if (element) {
    garbageBin.appendChild(element);
  }
  garbageBin.innerHTML = "";
}
var garbageBin;
function correctFloat(num, prec) {
  return parseFloat(num.toPrecision(prec || 14));
}
var timeUnits = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 24 * 36e5,
  week: 7 * 24 * 36e5,
  month: 28 * 24 * 36e5,
  year: 364 * 24 * 36e5
};
Math.easeInOutSine = function(pos) {
  return -0.5 * (Math.cos(Math.PI * pos) - 1);
};
function getNestedProperty(path, parent) {
  var pathElements = path.split(".");
  while (pathElements.length && defined(parent)) {
    var pathElement = pathElements.shift();
    if (typeof pathElement === "undefined" || pathElement === "__proto__") {
      return;
    }
    var child = parent[pathElement];
    if (!defined(child) || typeof child === "function" || typeof child.nodeType === "number" || child === win2) {
      return;
    }
    parent = child;
  }
  return parent;
}
function getStyle(el, prop, toInt) {
  var customGetStyle = Globals_default.getStyle || // oldie getStyle
  getStyle;
  var style;
  if (prop === "width") {
    var offsetWidth = Math.min(el.offsetWidth, el.scrollWidth);
    var boundingClientRectWidth = el.getBoundingClientRect && el.getBoundingClientRect().width;
    if (boundingClientRectWidth < offsetWidth && boundingClientRectWidth >= offsetWidth - 1) {
      offsetWidth = Math.floor(boundingClientRectWidth);
    }
    return Math.max(
      0,
      // #8377
      offsetWidth - (customGetStyle(el, "padding-left", true) || 0) - (customGetStyle(el, "padding-right", true) || 0)
    );
  }
  if (prop === "height") {
    return Math.max(
      0,
      // #8377
      Math.min(el.offsetHeight, el.scrollHeight) - (customGetStyle(el, "padding-top", true) || 0) - (customGetStyle(el, "padding-bottom", true) || 0)
    );
  }
  if (!win2.getComputedStyle) {
    error(27, true);
  }
  var css16 = win2.getComputedStyle(el, void 0);
  if (css16) {
    style = css16.getPropertyValue(prop);
    if (pick(toInt, prop !== "opacity")) {
      style = pInt(style);
    }
  }
  return style;
}
function inArray(item, arr, fromIndex) {
  error(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" });
  return arr.indexOf(item, fromIndex);
}
var find = Array.prototype.find ? function(arr, callback) {
  return arr.find(callback);
} : (
  // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
  function(arr, callback) {
    var i;
    var length = arr.length;
    for (i = 0; i < length; i++) {
      if (callback(arr[i], i)) {
        return arr[i];
      }
    }
  }
);
function keys(obj) {
  error(32, false, void 0, { "Highcharts.keys": "use Object.keys" });
  return Object.keys(obj);
}
function offset(el) {
  var docElem = doc.documentElement, box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
  return {
    top: box.top + (win2.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
    left: box.left + (win2.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
    width: box.width,
    height: box.height
  };
}
function objectEach(obj, fn, ctx) {
  for (var key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      fn.call(ctx || obj[key], obj[key], key, obj);
    }
  }
}
objectEach({
  map: "map",
  each: "forEach",
  grep: "filter",
  reduce: "reduce",
  some: "some"
}, function(val, key) {
  Globals_default[key] = function(arr) {
    var _a15;
    error(32, false, void 0, (_a15 = {}, _a15["Highcharts." + key] = "use Array." + val, _a15));
    return Array.prototype[val].apply(arr, [].slice.call(arguments, 1));
  };
});
function addEvent(el, type, fn, options) {
  if (options === void 0) {
    options = {};
  }
  var owner = typeof el === "function" && el.prototype || el;
  if (!Object.hasOwnProperty.call(owner, "hcEvents")) {
    owner.hcEvents = {};
  }
  var events = owner.hcEvents;
  if (Globals_default.Point && // without H a dependency loop occurs
  el instanceof Globals_default.Point && el.series && el.series.chart) {
    el.series.chart.runTrackerClick = true;
  }
  var addEventListener = el.addEventListener || Globals_default.addEventListenerPolyfill;
  if (addEventListener) {
    addEventListener.call(el, type, fn, Globals_default.supportsPassiveEvents ? {
      passive: options.passive === void 0 ? type.indexOf("touch") !== -1 : options.passive,
      capture: false
    } : false);
  }
  if (!events[type]) {
    events[type] = [];
  }
  var eventObject = {
    fn,
    order: typeof options.order === "number" ? options.order : Infinity
  };
  events[type].push(eventObject);
  events[type].sort(function(a, b) {
    return a.order - b.order;
  });
  return function() {
    removeEvent(el, type, fn);
  };
}
function removeEvent(el, type, fn) {
  function removeOneEvent(type2, fn2) {
    var removeEventListener = el.removeEventListener || Globals_default.removeEventListenerPolyfill;
    if (removeEventListener) {
      removeEventListener.call(el, type2, fn2, false);
    }
  }
  function removeAllEvents(eventCollection) {
    var types, len;
    if (!el.nodeName) {
      return;
    }
    if (type) {
      types = {};
      types[type] = true;
    } else {
      types = eventCollection;
    }
    objectEach(types, function(_val, n) {
      if (eventCollection[n]) {
        len = eventCollection[n].length;
        while (len--) {
          removeOneEvent(n, eventCollection[n][len].fn);
        }
      }
    });
  }
  var owner = typeof el === "function" && el.prototype || el;
  if (Object.hasOwnProperty.call(owner, "hcEvents")) {
    var events = owner.hcEvents;
    if (type) {
      var typeEvents = events[type] || [];
      if (fn) {
        events[type] = typeEvents.filter(function(obj) {
          return fn !== obj.fn;
        });
        removeOneEvent(type, fn);
      } else {
        removeAllEvents(events);
        events[type] = [];
      }
    } else {
      removeAllEvents(events);
      delete owner.hcEvents;
    }
  }
}
function fireEvent(el, type, eventArguments, defaultFunction) {
  var e2, i;
  eventArguments = eventArguments || {};
  if (doc.createEvent && (el.dispatchEvent || el.fireEvent && // Enable firing events on Highcharts instance.
  el !== Globals_default)) {
    e2 = doc.createEvent("Events");
    e2.initEvent(type, true, true);
    eventArguments = extend(e2, eventArguments);
    if (el.dispatchEvent) {
      el.dispatchEvent(eventArguments);
    } else {
      el.fireEvent(type, eventArguments);
    }
  } else if (el.hcEvents) {
    if (!eventArguments.target) {
      extend(eventArguments, {
        // Attach a simple preventDefault function to skip
        // default handler if called. The built-in
        // defaultPrevented property is not overwritable (#5112)
        preventDefault: function() {
          eventArguments.defaultPrevented = true;
        },
        // Setting target to native events fails with clicking
        // the zoom-out button in Chrome.
        target: el,
        // If the type is not set, we're running a custom event
        // (#2297). If it is set, we're running a browser event,
        // and setting it will cause en error in IE8 (#2465).
        type
      });
    }
    var events = [];
    var object = el;
    var multilevel = false;
    while (object.hcEvents) {
      if (Object.hasOwnProperty.call(object, "hcEvents") && object.hcEvents[type]) {
        if (events.length) {
          multilevel = true;
        }
        events.unshift.apply(events, object.hcEvents[type]);
      }
      object = Object.getPrototypeOf(object);
    }
    if (multilevel) {
      events.sort(function(a, b) {
        return a.order - b.order;
      });
    }
    events.forEach(function(obj) {
      if (obj.fn.call(el, eventArguments) === false) {
        eventArguments.preventDefault();
      }
    });
  }
  if (defaultFunction && !eventArguments.defaultPrevented) {
    defaultFunction.call(el, eventArguments);
  }
}
var serialMode;
var uniqueKey = function() {
  var hash = Math.random().toString(36).substring(2, 9) + "-";
  var id = 0;
  return function() {
    return "highcharts-" + (serialMode ? "" : hash) + id++;
  };
}();
function useSerialIds(mode) {
  return serialMode = pick(mode, serialMode);
}
function isFunction(obj) {
  return typeof obj === "function";
}
if (win2.jQuery) {
  win2.jQuery.fn.highcharts = function() {
    var args = [].slice.call(arguments);
    if (this[0]) {
      if (args[0]) {
        new Globals_default[
          // eslint-disable-line computed-property-spacing, no-new
          // Constructor defaults to Chart
          isString(args[0]) ? args.shift() : "Chart"
        ](this[0], args[0], args[1]);
        return this;
      }
      return charts[attr2(this[0], "data-highcharts-chart")];
    }
  };
}
var Utilities = {
  addEvent,
  arrayMax,
  arrayMin,
  attr: attr2,
  clamp,
  cleanRecursively,
  clearTimeout: internalClearTimeout,
  correctFloat,
  createElement,
  css: css2,
  defined,
  destroyObjectProperties,
  discardElement,
  erase,
  error,
  extend,
  extendClass,
  find,
  fireEvent,
  getMagnitude,
  getNestedProperty,
  getStyle,
  inArray,
  isArray,
  isClass,
  isDOMElement,
  isFunction,
  isNumber,
  isObject,
  isString,
  keys,
  merge,
  normalizeTickInterval,
  objectEach,
  offset,
  pad,
  pick,
  pInt,
  relativeLength,
  removeEvent,
  splat,
  stableSort,
  syncTimeout,
  timeUnits,
  uniqueKey,
  useSerialIds,
  wrap
};
var Utilities_default = Utilities;

// node_modules/highcharts/es-modules/Core/Color/Palette.js
var palette = {
  /**
   * Colors for data series and points.
   */
  colors: [
    "#7cb5ec",
    "#434348",
    "#90ed7d",
    "#f7a35c",
    "#8085e9",
    "#f15c80",
    "#e4d354",
    "#2b908f",
    "#f45b5b",
    "#91e8e1"
  ],
  /**
   * Chart background, point stroke for markers and columns etc
   */
  backgroundColor: "#ffffff",
  /**
   * Strong text.
   */
  neutralColor100: "#000000",
  /**
   * Main text and some strokes.
   */
  neutralColor80: "#333333",
  /**
   * Axis labels, axis title, connector fallback.
   */
  neutralColor60: "#666666",
  /**
   * Credits text, export menu stroke.
   */
  neutralColor40: "#999999",
  /**
   * Disabled texts, button strokes, crosshair etc.
   */
  neutralColor20: "#cccccc",
  /**
   * Grid lines etc.
   */
  neutralColor10: "#e6e6e6",
  /**
   * Minor grid lines etc.
   */
  neutralColor5: "#f2f2f2",
  /**
   * Tooltip backgroud, button fills, map null points.
   */
  neutralColor3: "#f7f7f7",
  /**
   * Drilldown clickable labels, color axis max color.
   */
  highlightColor100: "#003399",
  /**
   * Selection marker, menu hover, button hover, chart border, navigator series.
   */
  highlightColor80: "#335cad",
  /**
   * Navigator mask fill.
   */
  highlightColor60: "#6685c2",
  /**
   * Ticks and axis line.
   */
  highlightColor20: "#ccd6eb",
  /**
   * Pressed button, color axis min color.
   */
  highlightColor10: "#e6ebf5",
  /**
   * Positive indicator color
   */
  positiveColor: "#06b535",
  /**
   * Negative indicator color
   */
  negativeColor: "#f21313"
};
var Palette_default = palette;

// node_modules/highcharts/es-modules/Core/Chart/ChartDefaults.js
var ChartDefaults = {
  /**
   * Default `mapData` for all series. If set to a string, it functions
   * as an index into the `Highcharts.maps` array. Otherwise it is
   * interpreted as map data.
   *
   * @see [mapData](#series.map.mapData)
   *
   * @sample    maps/demo/geojson
   *            Loading geoJSON data
   * @sample    maps/chart/topojson
   *            Loading topoJSON converted to geoJSON
   *
   * @type      {string|Array<*>|Highcharts.GeoJSON}
   * @since     5.0.0
   * @product   highmaps
   * @apioption chart.map
   */
  /**
   * Set lat/lon transformation definitions for the chart. If not defined,
   * these are extracted from the map data.
   *
   * @type      {*}
   * @since     5.0.0
   * @product   highmaps
   * @apioption chart.mapTransforms
   */
  /**
   * When using multiple axis, the ticks of two or more opposite axes
   * will automatically be aligned by adding ticks to the axis or axes
   * with the least ticks, as if `tickAmount` were specified.
   *
   * This can be prevented by setting `alignTicks` to false. If the grid
   * lines look messy, it's a good idea to hide them for the secondary
   * axis by setting `gridLineWidth` to 0.
   *
   * If `startOnTick` or `endOnTick` in an Axis options are set to false,
   * then the `alignTicks ` will be disabled for the Axis.
   *
   * Disabled for logarithmic axes.
   *
   * @sample {highcharts} highcharts/chart/alignticks-true/
   *         True by default
   * @sample {highcharts} highcharts/chart/alignticks-false/
   *         False
   * @sample {highstock} stock/chart/alignticks-true/
   *         True by default
   * @sample {highstock} stock/chart/alignticks-false/
   *         False
   *
   * @type      {boolean}
   * @default   true
   * @product   highcharts highstock gantt
   * @apioption chart.alignTicks
   */
  /**
   * Set the overall animation for all chart updating. Animation can be
   * disabled throughout the chart by setting it to false here. It can
   * be overridden for each individual API method as a function parameter.
   * The only animation not affected by this option is the initial series
   * animation, see [plotOptions.series.animation](
   * #plotOptions.series.animation).
   *
   * The animation can either be set as a boolean or a configuration
   * object. If `true`, it will use the 'swing' jQuery easing and a
   * duration of 500 ms. If used as a configuration object, the following
   * properties are supported:
   *
   * - `defer`: The animation delay time in milliseconds.
   *
   * - `duration`: The duration of the animation in milliseconds.
   *
   * - `easing`: A string reference to an easing function set on the
   *   `Math` object. See
   *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
   *
   * When zooming on a series with less than 100 points, the chart redraw
   * will be done with animation, but in case of more data points, it is
   * necessary to set this option to ensure animation on zoom.
   *
   * @sample {highcharts} highcharts/chart/animation-none/
   *         Updating with no animation
   * @sample {highcharts} highcharts/chart/animation-duration/
   *         With a longer duration
   * @sample {highcharts} highcharts/chart/animation-easing/
   *         With a jQuery UI easing
   * @sample {highmaps} maps/chart/animation-none/
   *         Updating with no animation
   * @sample {highmaps} maps/chart/animation-duration/
   *         With a longer duration
   *
   * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
   * @default   undefined
   * @apioption chart.animation
   */
  /**
   * A CSS class name to apply to the charts container `div`, allowing
   * unique CSS styling for each chart.
   *
   * @type      {string}
   * @apioption chart.className
   */
  /**
   * Event listeners for the chart.
   *
   * @apioption chart.events
   */
  /**
   * Fires when a series is added to the chart after load time, using the
   * `addSeries` method. One parameter, `event`, is passed to the
   * function, containing common event information. Through
   * `event.options` you can access the series options that were passed to
   * the `addSeries` method. Returning false prevents the series from
   * being added.
   *
   * @sample {highcharts} highcharts/chart/events-addseries/
   *         Alert on add series
   * @sample {highstock} stock/chart/events-addseries/
   *         Alert on add series
   *
   * @type      {Highcharts.ChartAddSeriesCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Chart
   * @apioption chart.events.addSeries
   */
  /**
   * Fires when clicking on the plot background. One parameter, `event`,
   * is passed to the function, containing common event information.
   *
   * Information on the clicked spot can be found through `event.xAxis`
   * and `event.yAxis`, which are arrays containing the axes of each
   * dimension and each axis' value at the clicked spot. The primary axes
   * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
   * datetime axis is milliseconds since 1970-01-01 00:00:00.
   *
   * ```js
   * click: function(e) {
   *     console.log(
   *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
   *         e.yAxis[0].value
   *     )
   * }
   * ```
   *
   * @sample {highcharts} highcharts/chart/events-click/
   *         Alert coordinates on click
   * @sample {highcharts} highcharts/chart/events-container/
   *         Alternatively, attach event to container
   * @sample {highstock} stock/chart/events-click/
   *         Alert coordinates on click
   * @sample {highstock} highcharts/chart/events-container/
   *         Alternatively, attach event to container
   * @sample {highmaps} maps/chart/events-click/
   *         Record coordinates on click
   * @sample {highmaps} highcharts/chart/events-container/
   *         Alternatively, attach event to container
   *
   * @type      {Highcharts.ChartClickCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Chart
   * @apioption chart.events.click
   */
  /**
   * Fires when the chart is finished loading. Since v4.2.2, it also waits
   * for images to be loaded, for example from point markers. One
   * parameter, `event`, is passed to the function, containing common
   * event information.
   *
   * There is also a second parameter to the chart constructor where a
   * callback function can be passed to be executed on chart.load.
   *
   * @sample {highcharts} highcharts/chart/events-load/
   *         Alert on chart load
   * @sample {highstock} stock/chart/events-load/
   *         Alert on chart load
   * @sample {highmaps} maps/chart/events-load/
   *         Add series on chart load
   *
   * @type      {Highcharts.ChartLoadCallbackFunction}
   * @context   Highcharts.Chart
   * @apioption chart.events.load
   */
  /**
   * Fires when the chart is redrawn, either after a call to
   * `chart.redraw()` or after an axis, series or point is modified with
   * the `redraw` option set to `true`. One parameter, `event`, is passed
   * to the function, containing common event information.
   *
   * @sample {highcharts} highcharts/chart/events-redraw/
   *         Alert on chart redraw
   * @sample {highstock} stock/chart/events-redraw/
   *         Alert on chart redraw when adding a series or moving the
   *         zoomed range
   * @sample {highmaps} maps/chart/events-redraw/
   *         Set subtitle on chart redraw
   *
   * @type      {Highcharts.ChartRedrawCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Chart
   * @apioption chart.events.redraw
   */
  /**
   * Fires after initial load of the chart (directly after the `load`
   * event), and after each redraw (directly after the `redraw` event).
   *
   * @type      {Highcharts.ChartRenderCallbackFunction}
   * @since     5.0.7
   * @context   Highcharts.Chart
   * @apioption chart.events.render
   */
  /**
   * Fires when an area of the chart has been selected. Selection is
   * enabled by setting the chart's zoomType. One parameter, `event`, is
   * passed to the function, containing common event information. The
   * default action for the selection event is to zoom the chart to the
   * selected area. It can be prevented by calling
   * `event.preventDefault()` or return false.
   *
   * Information on the selected area can be found through `event.xAxis`
   * and `event.yAxis`, which are arrays containing the axes of each
   * dimension and each axis' min and max values. The primary axes are
   * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
   * datetime axis is milliseconds since 1970-01-01 00:00:00.
   *
   * ```js
   * selection: function(event) {
   *     // log the min and max of the primary, datetime x-axis
   *     console.log(
   *         Highcharts.dateFormat(
   *             '%Y-%m-%d %H:%M:%S',
   *             event.xAxis[0].min
   *         ),
   *         Highcharts.dateFormat(
   *             '%Y-%m-%d %H:%M:%S',
   *             event.xAxis[0].max
   *         )
   *     );
   *     // log the min and max of the y axis
   *     console.log(event.yAxis[0].min, event.yAxis[0].max);
   * }
   * ```
   *
   * @sample {highcharts} highcharts/chart/events-selection/
   *         Report on selection and reset
   * @sample {highcharts} highcharts/chart/events-selection-points/
   *         Select a range of points through a drag selection
   * @sample {highstock} stock/chart/events-selection/
   *         Report on selection and reset
   * @sample {highstock} highcharts/chart/events-selection-points/
   *         Select a range of points through a drag selection
   *         (Highcharts)
   *
   * @type      {Highcharts.ChartSelectionCallbackFunction}
   * @apioption chart.events.selection
   */
  /**
   * The margin between the outer edge of the chart and the plot area.
   * The numbers in the array designate top, right, bottom and left
   * respectively. Use the options `marginTop`, `marginRight`,
   * `marginBottom` and `marginLeft` for shorthand setting of one option.
   *
   * By default there is no margin. The actual space is dynamically
   * calculated from the offset of axis labels, axis title, title,
   * subtitle and legend in addition to the `spacingTop`, `spacingRight`,
   * `spacingBottom` and `spacingLeft` options.
   *
   * @sample {highcharts} highcharts/chart/margins-zero/
   *         Zero margins
   * @sample {highstock} stock/chart/margin-zero/
   *         Zero margins
   *
   * @type      {number|Array<number>}
   * @apioption chart.margin
   */
  /**
   * The margin between the bottom outer edge of the chart and the plot
   * area. Use this to set a fixed pixel value for the margin as opposed
   * to the default dynamic margin. See also `spacingBottom`.
   *
   * @sample {highcharts} highcharts/chart/marginbottom/
   *         100px bottom margin
   * @sample {highstock} stock/chart/marginbottom/
   *         100px bottom margin
   * @sample {highmaps} maps/chart/margin/
   *         100px margins
   *
   * @type      {number}
   * @since     2.0
   * @apioption chart.marginBottom
   */
  /**
   * The margin between the left outer edge of the chart and the plot
   * area. Use this to set a fixed pixel value for the margin as opposed
   * to the default dynamic margin. See also `spacingLeft`.
   *
   * @sample {highcharts} highcharts/chart/marginleft/
   *         150px left margin
   * @sample {highstock} stock/chart/marginleft/
   *         150px left margin
   * @sample {highmaps} maps/chart/margin/
   *         100px margins
   *
   * @type      {number}
   * @since     2.0
   * @apioption chart.marginLeft
   */
  /**
   * The margin between the right outer edge of the chart and the plot
   * area. Use this to set a fixed pixel value for the margin as opposed
   * to the default dynamic margin. See also `spacingRight`.
   *
   * @sample {highcharts} highcharts/chart/marginright/
   *         100px right margin
   * @sample {highstock} stock/chart/marginright/
   *         100px right margin
   * @sample {highmaps} maps/chart/margin/
   *         100px margins
   *
   * @type      {number}
   * @since     2.0
   * @apioption chart.marginRight
   */
  /**
   * The margin between the top outer edge of the chart and the plot area.
   * Use this to set a fixed pixel value for the margin as opposed to
   * the default dynamic margin. See also `spacingTop`.
   *
   * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
   * @sample {highstock} stock/chart/margintop/
   *         100px top margin
   * @sample {highmaps} maps/chart/margin/
   *         100px margins
   *
   * @type      {number}
   * @since     2.0
   * @apioption chart.marginTop
   */
  /**
   * Callback function to override the default function that formats all
   * the numbers in the chart. Returns a string with the formatted number.
   *
   * @sample highcharts/members/highcharts-numberformat
   *      Arabic digits in Highcharts
   * @type {Highcharts.NumberFormatterCallbackFunction}
   * @since 8.0.0
   * @apioption chart.numberFormatter
   */
  /**
   * Allows setting a key to switch between zooming and panning. Can be
   * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
   * key on Windows) or `shift`. The keys are mapped directly to the key
   * properties of the click event argument (`event.altKey`,
   * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).
   *
   * @type       {string}
   * @since      4.0.3
   * @product    highcharts gantt
   * @validvalue ["alt", "ctrl", "meta", "shift"]
   * @apioption  chart.panKey
   */
  /**
   * Allow panning in a chart. Best used with [panKey](#chart.panKey)
   * to combine zooming and panning.
   *
   * On touch devices, when the [tooltip.followTouchMove](
   * #tooltip.followTouchMove) option is `true` (default), panning
   * requires two fingers. To allow panning with one finger, set
   * `followTouchMove` to `false`.
   *
   * @sample  {highcharts} highcharts/chart/pankey/ Zooming and panning
   * @sample  {highstock} stock/chart/panning/ Zooming and xy panning
   */
  panning: {
    /**
     * Enable or disable chart panning.
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock|highmaps} true
     */
    enabled: false,
    /**
     * Decides in what dimensions the user can pan the chart. Can be
     * one of `x`, `y`, or `xy`.
     *
     * @sample {highcharts} highcharts/chart/panning-type
     *         Zooming and xy panning
     *
     * @type       {string}
     * @validvalue ["x", "y", "xy"]
     * @default    {highcharts|highstock} x
     * @default    {highmaps} xy
     */
    type: "x"
  },
  /**
   * Equivalent to [zoomType](#chart.zoomType), but for multitouch
   * gestures only. By default, the `pinchType` is the same as the
   * `zoomType` setting. However, pinching can be enabled separately in
   * some cases, for example in stock charts where a mouse drag pans the
   * chart, while pinching is enabled. When [tooltip.followTouchMove](
   * #tooltip.followTouchMove) is true, pinchType only applies to
   * two-finger touches.
   *
   * @type       {string}
   * @default    {highcharts} undefined
   * @default    {highstock} x
   * @since      3.0
   * @product    highcharts highstock gantt
   * @validvalue ["x", "y", "xy"]
   * @apioption  chart.pinchType
   */
  /**
   * Whether to apply styled mode. When in styled mode, no presentational
   * attributes or CSS are applied to the chart SVG. Instead, CSS rules
   * are required to style the chart. The default style sheet is
   * available from `https://code.highcharts.com/css/highcharts.css`.
   *
   * @type       {boolean}
   * @default    false
   * @since      7.0
   * @apioption  chart.styledMode
   */
  styledMode: false,
  /**
   * The corner radius of the outer chart border.
   *
   * @sample {highcharts} highcharts/chart/borderradius/
   *         20px radius
   * @sample {highstock} stock/chart/border/
   *         10px radius
   * @sample {highmaps} maps/chart/border/
   *         Border options
   *
   */
  borderRadius: 0,
  /**
   * In styled mode, this sets how many colors the class names
   * should rotate between. With ten colors, series (or points) are
   * given class names like `highcharts-color-0`, `highcharts-color-0`
   * [...] `highcharts-color-9`. The equivalent in non-styled mode
   * is to set colors using the [colors](#colors) setting.
   *
   * @since      5.0.0
   */
  colorCount: 10,
  /**
   * Alias of `type`.
   *
   * @sample {highcharts} highcharts/chart/defaultseriestype/
   *         Bar
   *
   * @deprecated
   *
   * @product highcharts
   */
  defaultSeriesType: "line",
  /**
   * If true, the axes will scale to the remaining visible series once
   * one series is hidden. If false, hiding and showing a series will
   * not affect the axes or the other series. For stacks, once one series
   * within the stack is hidden, the rest of the stack will close in
   * around it even if the axis is not affected.
   *
   * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
   *         True by default
   * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
   *         False
   * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
   *         True with stack
   * @sample {highstock} stock/chart/ignorehiddenseries-true/
   *         True by default
   * @sample {highstock} stock/chart/ignorehiddenseries-false/
   *         False
   *
   * @since   1.2.0
   * @product highcharts highstock gantt
   */
  ignoreHiddenSeries: true,
  /**
   * Whether to invert the axes so that the x axis is vertical and y axis
   * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
   * by default.
   *
   * @productdesc {highcharts}
   * If a bar series is present in the chart, it will be inverted
   * automatically. Inverting the chart doesn't have an effect if there
   * are no cartesian series in the chart, or if the chart is
   * [polar](#chart.polar).
   *
   * @sample {highcharts} highcharts/chart/inverted/
   *         Inverted line
   * @sample {highstock} stock/navigator/inverted/
   *         Inverted stock chart
   *
   * @type      {boolean}
   * @default   false
   * @product   highcharts highstock gantt
   * @apioption chart.inverted
   */
  /**
   * The distance between the outer edge of the chart and the content,
   * like title or legend, or axis title and labels if present. The
   * numbers in the array designate top, right, bottom and left
   * respectively. Use the options spacingTop, spacingRight, spacingBottom
   * and spacingLeft options for shorthand setting of one option.
   *
   * @type    {Array<number>}
   * @see     [chart.margin](#chart.margin)
   * @default [10, 10, 15, 10]
   * @since   3.0.6
   */
  spacing: [10, 10, 15, 10],
  /**
   * The button that appears after a selection zoom, allowing the user
   * to reset zoom.
   */
  resetZoomButton: {
    /**
     * What frame the button placement should be related to. Can be
     * either `plotBox` or `spacingBox`.
     *
     * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
     *         Relative to the chart
     * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
     *         Relative to the chart
     *
     * @type       {Highcharts.ButtonRelativeToValue}
     * @default    plot
     * @since      2.2
     * @apioption  chart.resetZoomButton.relativeTo
     */
    /**
     * A collection of attributes for the button. The object takes SVG
     * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
     * border radius. The theme also supports `style`, a collection of
     * CSS properties for the text. Equivalent attributes for the hover
     * state are given in `theme.states.hover`.
     *
     * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
     *         Theming the button
     * @sample {highstock} highcharts/chart/resetzoombutton-theme/
     *         Theming the button
     *
     * @type {Highcharts.SVGAttributes}
     * @since 2.2
     */
    theme: {
      /** @internal */
      zIndex: 6
    },
    /**
     * The position of the button.
     *
     * @sample {highcharts} highcharts/chart/resetzoombutton-position/
     *         Above the plot area
     * @sample {highstock} highcharts/chart/resetzoombutton-position/
     *         Above the plot area
     * @sample {highmaps} highcharts/chart/resetzoombutton-position/
     *         Above the plot area
     *
     * @type  {Highcharts.AlignObject}
     * @since 2.2
     */
    position: {
      /**
       * The horizontal alignment of the button.
       */
      align: "right",
      /**
       * The horizontal offset of the button.
       */
      x: -10,
      /**
       * The vertical alignment of the button.
       *
       * @type       {Highcharts.VerticalAlignValue}
       * @default    top
       * @apioption  chart.resetZoomButton.position.verticalAlign
       */
      /**
       * The vertical offset of the button.
       */
      y: 10
    }
  },
  /**
   * The pixel width of the plot area border.
   *
   * @sample {highcharts} highcharts/chart/plotborderwidth/
   *         1px border
   * @sample {highstock} stock/chart/plotborder/
   *         2px border
   * @sample {highmaps} maps/chart/plotborder/
   *         Plot border options
   *
   * @type      {number}
   * @default   0
   * @apioption chart.plotBorderWidth
   */
  /**
   * Whether to apply a drop shadow to the plot area. Requires that
   * plotBackgroundColor be set. The shadow can be an object configuration
   * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
   *
   * @sample {highcharts} highcharts/chart/plotshadow/
   *         Plot shadow
   * @sample {highstock} stock/chart/plotshadow/
   *         Plot shadow
   * @sample {highmaps} maps/chart/plotborder/
   *         Plot border options
   *
   * @type      {boolean|Highcharts.CSSObject}
   * @default   false
   * @apioption chart.plotShadow
   */
  /**
   * When true, cartesian charts like line, spline, area and column are
   * transformed into the polar coordinate system. This produces _polar
   * charts_, also known as _radar charts_.
   *
   * @sample {highcharts} highcharts/demo/polar/
   *         Polar chart
   * @sample {highcharts} highcharts/demo/polar-wind-rose/
   *         Wind rose, stacked polar column chart
   * @sample {highcharts} highcharts/demo/polar-spider/
   *         Spider web chart
   * @sample {highcharts} highcharts/parallel-coordinates/polar/
   *         Star plot, multivariate data in a polar chart
   *
   * @type      {boolean}
   * @default   false
   * @since     2.3.0
   * @product   highcharts
   * @requires  highcharts-more
   * @apioption chart.polar
   */
  /**
   * Whether to reflow the chart to fit the width of the container div
   * on resizing the window.
   *
   * @sample {highcharts} highcharts/chart/reflow-true/
   *         True by default
   * @sample {highcharts} highcharts/chart/reflow-false/
   *         False
   * @sample {highstock} stock/chart/reflow-true/
   *         True by default
   * @sample {highstock} stock/chart/reflow-false/
   *         False
   * @sample {highmaps} maps/chart/reflow-true/
   *         True by default
   * @sample {highmaps} maps/chart/reflow-false/
   *         False
   *
   * @type      {boolean}
   * @default   true
   * @since     2.1
   * @apioption chart.reflow
   */
  /**
   * The HTML element where the chart will be rendered. If it is a string,
   * the element by that id is used. The HTML element can also be passed
   * by direct reference, or as the first argument of the chart
   * constructor, in which case the option is not needed.
   *
   * @sample {highcharts} highcharts/chart/reflow-true/
   *         String
   * @sample {highcharts} highcharts/chart/renderto-object/
   *         Object reference
   * @sample {highstock} stock/chart/renderto-string/
   *         String
   * @sample {highstock} stock/chart/renderto-object/
   *         Object reference
   *
   * @type      {string|Highcharts.HTMLDOMElement}
   * @apioption chart.renderTo
   */
  /**
   * The background color of the marker square when selecting (zooming
   * in on) an area of the chart.
   *
   * @see In styled mode, the selection marker fill is set with the
   *      `.highcharts-selection-marker` class.
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default   rgba(51,92,173,0.25)
   * @since     2.1.7
   * @apioption chart.selectionMarkerFill
   */
  /**
   * Whether to apply a drop shadow to the outer chart area. Requires
   * that backgroundColor be set. The shadow can be an object
   * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
   * `width`.
   *
   * @sample {highcharts} highcharts/chart/shadow/
   *         Shadow
   * @sample {highstock} stock/chart/shadow/
   *         Shadow
   * @sample {highmaps} maps/chart/border/
   *         Chart border and shadow
   *
   * @type      {boolean|Highcharts.CSSObject}
   * @default   false
   * @apioption chart.shadow
   */
  /**
   * Whether to show the axes initially. This only applies to empty charts
   * where series are added dynamically, as axes are automatically added
   * to cartesian series.
   *
   * @sample {highcharts} highcharts/chart/showaxes-false/
   *         False by default
   * @sample {highcharts} highcharts/chart/showaxes-true/
   *         True
   *
   * @type      {boolean}
   * @since     1.2.5
   * @product   highcharts gantt
   * @apioption chart.showAxes
   */
  /**
   * The space between the bottom edge of the chart and the content (plot
   * area, axis title and labels, title, subtitle or legend in top
   * position).
   *
   * @sample {highcharts} highcharts/chart/spacingbottom/
   *         Spacing bottom set to 100
   * @sample {highstock} stock/chart/spacingbottom/
   *         Spacing bottom set to 100
   * @sample {highmaps} maps/chart/spacing/
   *         Spacing 100 all around
   *
   * @type      {number}
   * @default   15
   * @since     2.1
   * @apioption chart.spacingBottom
   */
  /**
   * The space between the left edge of the chart and the content (plot
   * area, axis title and labels, title, subtitle or legend in top
   * position).
   *
   * @sample {highcharts} highcharts/chart/spacingleft/
   *         Spacing left set to 100
   * @sample {highstock} stock/chart/spacingleft/
   *         Spacing left set to 100
   * @sample {highmaps} maps/chart/spacing/
   *         Spacing 100 all around
   *
   * @type      {number}
   * @default   10
   * @since     2.1
   * @apioption chart.spacingLeft
   */
  /**
   * The space between the right edge of the chart and the content (plot
   * area, axis title and labels, title, subtitle or legend in top
   * position).
   *
   * @sample {highcharts} highcharts/chart/spacingright-100/
   *         Spacing set to 100
   * @sample {highcharts} highcharts/chart/spacingright-legend/
   *         Legend in right position with default spacing
   * @sample {highstock} stock/chart/spacingright/
   *         Spacing set to 100
   * @sample {highmaps} maps/chart/spacing/
   *         Spacing 100 all around
   *
   * @type      {number}
   * @default   10
   * @since     2.1
   * @apioption chart.spacingRight
   */
  /**
   * The space between the top edge of the chart and the content (plot
   * area, axis title and labels, title, subtitle or legend in top
   * position).
   *
   * @sample {highcharts} highcharts/chart/spacingtop-100/
   *         A top spacing of 100
   * @sample {highcharts} highcharts/chart/spacingtop-10/
   *         Floating chart title makes the plot area align to the default
   *         spacingTop of 10.
   * @sample {highstock} stock/chart/spacingtop/
   *         A top spacing of 100
   * @sample {highmaps} maps/chart/spacing/
   *         Spacing 100 all around
   *
   * @type      {number}
   * @default   10
   * @since     2.1
   * @apioption chart.spacingTop
   */
  /**
   * Additional CSS styles to apply inline to the container `div`. Note
   * that since the default font styles are applied in the renderer, it
   * is ignorant of the individual chart options and must be set globally.
   *
   * @see    In styled mode, general chart styles can be set with the
   *         `.highcharts-root` class.
   * @sample {highcharts} highcharts/chart/style-serif-font/
   *         Using a serif type font
   * @sample {highcharts} highcharts/css/em/
   *         Styled mode with relative font sizes
   * @sample {highstock} stock/chart/style/
   *         Using a serif type font
   * @sample {highmaps} maps/chart/style-serif-font/
   *         Using a serif type font
   *
   * @type      {Highcharts.CSSObject}
   * @default   {"fontFamily": "\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif","fontSize":"12px"}
   * @apioption chart.style
   */
  /**
   * The default series type for the chart. Can be any of the chart types
   * listed under [plotOptions](#plotOptions) and [series](#series) or can
   * be a series provided by an additional module.
   *
   * In TypeScript this option has no effect in sense of typing and
   * instead the `type` option must always be set in the series.
   *
   * @sample {highcharts} highcharts/chart/type-bar/
   *         Bar
   * @sample {highstock} stock/chart/type/
   *         Areaspline
   * @sample {highmaps} maps/chart/type-mapline/
   *         Mapline
   *
   * @type       {string}
   * @default    {highcharts} line
   * @default    {highstock} line
   * @default    {highmaps} map
   * @since      2.1.0
   * @apioption  chart.type
   */
  /**
   * Decides in what dimensions the user can zoom by dragging the mouse.
   * Can be one of `x`, `y` or `xy`.
   *
   * @see [panKey](#chart.panKey)
   *
   * @sample {highcharts} highcharts/chart/zoomtype-none/
   *         None by default
   * @sample {highcharts} highcharts/chart/zoomtype-x/
   *         X
   * @sample {highcharts} highcharts/chart/zoomtype-y/
   *         Y
   * @sample {highcharts} highcharts/chart/zoomtype-xy/
   *         Xy
   * @sample {highstock} stock/demo/basic-line/
   *         None by default
   * @sample {highstock} stock/chart/zoomtype-x/
   *         X
   * @sample {highstock} stock/chart/zoomtype-y/
   *         Y
   * @sample {highstock} stock/chart/zoomtype-xy/
   *         Xy
   *
   * @type       {string}
   * @product    highcharts highstock gantt
   * @validvalue ["x", "y", "xy"]
   * @apioption  chart.zoomType
   */
  /**
   * Enables zooming by a single touch, in combination with
   * [chart.zoomType](#chart.zoomType). When enabled, two-finger pinch
   * will still work as set up by [chart.pinchType](#chart.pinchType).
   * However, `zoomBySingleTouch` will interfere with touch-dragging the
   * chart to read the tooltip. And especially when vertical zooming is
   * enabled, it will make it hard to scroll vertically on the page.
   * @since 9.0.0
   * @sample     highcharts/chart/zoombysingletouch
   *             Zoom by single touch enabled, with buttons to toggle
   * @product    highcharts highstock gantt
   */
  zoomBySingleTouch: false,
  /**
   * An explicit width for the chart. By default (when `null`) the width
   * is calculated from the offset width of the containing element.
   *
   * @sample {highcharts} highcharts/chart/width/
   *         800px wide
   * @sample {highstock} stock/chart/width/
   *         800px wide
   * @sample {highmaps} maps/chart/size/
   *         Chart with explicit size
   *
   * @type {null|number|string}
   */
  width: null,
  /**
   * An explicit height for the chart. If a _number_, the height is
   * given in pixels. If given a _percentage string_ (for example
   * `'56%'`), the height is given as the percentage of the actual chart
   * width. This allows for preserving the aspect ratio across responsive
   * sizes.
   *
   * By default (when `null`) the height is calculated from the offset
   * height of the containing element, or 400 pixels if the containing
   * element's height is 0.
   *
   * @sample {highcharts} highcharts/chart/height/
   *         500px height
   * @sample {highstock} stock/chart/height/
   *         300px height
   * @sample {highmaps} maps/chart/size/
   *         Chart with explicit size
   * @sample highcharts/chart/height-percent/
   *         Highcharts with percentage height
   *
   * @type {null|number|string}
   */
  height: null,
  /**
   * The color of the outer chart border.
   *
   * @see In styled mode, the stroke is set with the
   *      `.highcharts-background` class.
   *
   * @sample {highcharts} highcharts/chart/bordercolor/
   *         Brown border
   * @sample {highstock} stock/chart/border/
   *         Brown border
   * @sample {highmaps} maps/chart/border/
   *         Border options
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  borderColor: Palette_default.highlightColor80,
  /**
   * The pixel width of the outer chart border.
   *
   * @see In styled mode, the stroke is set with the
   *      `.highcharts-background` class.
   *
   * @sample {highcharts} highcharts/chart/borderwidth/
   *         5px border
   * @sample {highstock} stock/chart/border/
   *         2px border
   * @sample {highmaps} maps/chart/border/
   *         Border options
   *
   * @type      {number}
   * @default   0
   * @apioption chart.borderWidth
   */
  /**
   * The background color or gradient for the outer chart area.
   *
   * @see In styled mode, the background is set with the
   *      `.highcharts-background` class.
   *
   * @sample {highcharts} highcharts/chart/backgroundcolor-color/
   *         Color
   * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/
   *         Gradient
   * @sample {highstock} stock/chart/backgroundcolor-color/
   *         Color
   * @sample {highstock} stock/chart/backgroundcolor-gradient/
   *         Gradient
   * @sample {highmaps} maps/chart/backgroundcolor-color/
   *         Color
   * @sample {highmaps} maps/chart/backgroundcolor-gradient/
   *         Gradient
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  backgroundColor: Palette_default.backgroundColor,
  /**
   * The background color or gradient for the plot area.
   *
   * @see In styled mode, the plot background is set with the
   *      `.highcharts-plot-background` class.
   *
   * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
   *         Color
   * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
   *         Gradient
   * @sample {highstock} stock/chart/plotbackgroundcolor-color/
   *         Color
   * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
   *         Gradient
   * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
   *         Color
   * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
   *         Gradient
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @apioption chart.plotBackgroundColor
   */
  /**
   * The URL for an image to use as the plot background. To set an image
   * as the background for the entire chart, set a CSS background image
   * to the container element. Note that for the image to be applied to
   * exported charts, its URL needs to be accessible by the export server.
   *
   * @see In styled mode, a plot background image can be set with the
   *      `.highcharts-plot-background` class and a [custom pattern](
   *      https://www.highcharts.com/docs/chart-design-and-style/
   *      gradients-shadows-and-patterns).
   *
   * @sample {highcharts} highcharts/chart/plotbackgroundimage/
   *         Skies
   * @sample {highstock} stock/chart/plotbackgroundimage/
   *         Skies
   *
   * @type      {string}
   * @apioption chart.plotBackgroundImage
   */
  /**
   * The color of the inner chart or plot area border.
   *
   * @see In styled mode, a plot border stroke can be set with the
   *      `.highcharts-plot-border` class.
   *
   * @sample {highcharts} highcharts/chart/plotbordercolor/
   *         Blue border
   * @sample {highstock} stock/chart/plotborder/
   *         Blue border
   * @sample {highmaps} maps/chart/plotborder/
   *         Plot border options
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  plotBorderColor: Palette_default.neutralColor20
};
var ChartDefaults_default = ChartDefaults;

// node_modules/highcharts/es-modules/Core/Color/Color.js
var isNumber2 = Utilities_default.isNumber;
var merge2 = Utilities_default.merge;
var pInt2 = Utilities_default.pInt;
var Color = (
  /** @class */
  function() {
    function Color2(input) {
      this.rgba = [NaN, NaN, NaN, NaN];
      this.input = input;
      var GlobalColor = Globals_default.Color;
      if (GlobalColor && GlobalColor !== Color2) {
        return new GlobalColor(input);
      }
      if (!(this instanceof Color2)) {
        return new Color2(input);
      }
      this.init(input);
    }
    Color2.parse = function(input) {
      return input ? new Color2(input) : Color2.None;
    };
    Color2.prototype.init = function(input) {
      var result2, rgba, i, parser;
      if (typeof input === "object" && typeof input.stops !== "undefined") {
        this.stops = input.stops.map(function(stop4) {
          return new Color2(stop4[1]);
        });
      } else if (typeof input === "string") {
        this.input = input = Color2.names[input.toLowerCase()] || input;
        if (input.charAt(0) === "#") {
          var len = input.length, col = parseInt(input.substr(1), 16);
          if (len === 7) {
            rgba = [
              (col & 16711680) >> 16,
              (col & 65280) >> 8,
              col & 255,
              1
            ];
          } else if (len === 4) {
            rgba = [
              (col & 3840) >> 4 | (col & 3840) >> 8,
              (col & 240) >> 4 | col & 240,
              (col & 15) << 4 | col & 15,
              1
            ];
          }
        }
        if (!rgba) {
          i = Color2.parsers.length;
          while (i-- && !rgba) {
            parser = Color2.parsers[i];
            result2 = parser.regex.exec(input);
            if (result2) {
              rgba = parser.parse(result2);
            }
          }
        }
      }
      if (rgba) {
        this.rgba = rgba;
      }
    };
    Color2.prototype.get = function(format15) {
      var input = this.input, rgba = this.rgba;
      if (typeof input === "object" && typeof this.stops !== "undefined") {
        var ret_1 = merge2(input);
        ret_1.stops = [].slice.call(ret_1.stops);
        this.stops.forEach(function(stop4, i) {
          ret_1.stops[i] = [
            ret_1.stops[i][0],
            stop4.get(format15)
          ];
        });
        return ret_1;
      }
      if (rgba && isNumber2(rgba[0])) {
        if (format15 === "rgb" || !format15 && rgba[3] === 1) {
          return "rgb(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + ")";
        }
        if (format15 === "a") {
          return "" + rgba[3];
        }
        return "rgba(" + rgba.join(",") + ")";
      }
      return input;
    };
    Color2.prototype.brighten = function(alpha) {
      var rgba = this.rgba;
      if (this.stops) {
        this.stops.forEach(function(stop4) {
          stop4.brighten(alpha);
        });
      } else if (isNumber2(alpha) && alpha !== 0) {
        for (var i = 0; i < 3; i++) {
          rgba[i] += pInt2(alpha * 255);
          if (rgba[i] < 0) {
            rgba[i] = 0;
          }
          if (rgba[i] > 255) {
            rgba[i] = 255;
          }
        }
      }
      return this;
    };
    Color2.prototype.setOpacity = function(alpha) {
      this.rgba[3] = alpha;
      return this;
    };
    Color2.prototype.tweenTo = function(to, pos) {
      var fromRgba = this.rgba, toRgba = to.rgba;
      if (!isNumber2(fromRgba[0]) || !isNumber2(toRgba[0])) {
        return to.input || "none";
      }
      var hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1;
      return (hasAlpha ? "rgba(" : "rgb(") + Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) + "," + Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) + "," + Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) + (hasAlpha ? "," + (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos)) : "") + ")";
    };
    Color2.names = {
      white: "#ffffff",
      black: "#000000"
    };
    Color2.parsers = [{
      // RGBA color
      // eslint-disable-next-line max-len
      regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
      parse: function(result2) {
        return [
          pInt2(result2[1]),
          pInt2(result2[2]),
          pInt2(result2[3]),
          parseFloat(result2[4], 10)
        ];
      }
    }, {
      // RGB color
      regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
      parse: function(result2) {
        return [pInt2(result2[1]), pInt2(result2[2]), pInt2(result2[3]), 1];
      }
    }];
    Color2.None = new Color2("");
    return Color2;
  }()
);
var Color_default = Color;

// node_modules/highcharts/es-modules/Core/Time.js
var win3 = Globals_default.win;
var defined2 = Utilities_default.defined;
var error2 = Utilities_default.error;
var extend2 = Utilities_default.extend;
var isObject2 = Utilities_default.isObject;
var merge3 = Utilities_default.merge;
var objectEach2 = Utilities_default.objectEach;
var pad2 = Utilities_default.pad;
var pick2 = Utilities_default.pick;
var splat2 = Utilities_default.splat;
var timeUnits2 = Utilities_default.timeUnits;
var hasNewSafariBug = Globals_default.isSafari && win3.Intl && win3.Intl.DateTimeFormat.prototype.formatRange;
var hasOldSafariBug = Globals_default.isSafari && win3.Intl && !win3.Intl.DateTimeFormat.prototype.formatRange;
var Time = (
  /** @class */
  function() {
    function Time2(options) {
      this.options = {};
      this.useUTC = false;
      this.variableTimezone = false;
      this.Date = win3.Date;
      this.getTimezoneOffset = this.timezoneOffsetFunction();
      this.update(options);
    }
    Time2.prototype.get = function(unit, date) {
      if (this.variableTimezone || this.timezoneOffset) {
        var realMs = date.getTime();
        var ms = realMs - this.getTimezoneOffset(date);
        date.setTime(ms);
        var ret = date["getUTC" + unit]();
        date.setTime(realMs);
        return ret;
      }
      if (this.useUTC) {
        return date["getUTC" + unit]();
      }
      return date["get" + unit]();
    };
    Time2.prototype.set = function(unit, date, value) {
      if (this.variableTimezone || this.timezoneOffset) {
        if (unit === "Milliseconds" || unit === "Seconds" || unit === "Minutes" && this.getTimezoneOffset(date) % 36e5 === 0) {
          return date["setUTC" + unit](value);
        }
        var offset3 = this.getTimezoneOffset(date);
        var ms = date.getTime() - offset3;
        date.setTime(ms);
        date["setUTC" + unit](value);
        var newOffset = this.getTimezoneOffset(date);
        ms = date.getTime() + newOffset;
        return date.setTime(ms);
      }
      if (this.useUTC || hasNewSafariBug && unit === "FullYear") {
        return date["setUTC" + unit](value);
      }
      return date["set" + unit](value);
    };
    Time2.prototype.update = function(options) {
      var useUTC = pick2(options && options.useUTC, true), time = this;
      this.options = options = merge3(true, this.options || {}, options);
      this.Date = options.Date || win3.Date || Date;
      this.useUTC = useUTC;
      this.timezoneOffset = useUTC && options.timezoneOffset;
      this.getTimezoneOffset = this.timezoneOffsetFunction();
      this.variableTimezone = useUTC && !!(options.getTimezoneOffset || options.timezone);
    };
    Time2.prototype.makeTime = function(year, month, date, hours, minutes, seconds) {
      var d, offset3, newOffset;
      if (this.useUTC) {
        d = this.Date.UTC.apply(0, arguments);
        offset3 = this.getTimezoneOffset(d);
        d += offset3;
        newOffset = this.getTimezoneOffset(d);
        if (offset3 !== newOffset) {
          d += newOffset - offset3;
        } else if (offset3 - 36e5 === this.getTimezoneOffset(d - 36e5) && !hasOldSafariBug) {
          d -= 36e5;
        }
      } else {
        d = new this.Date(year, month, pick2(date, 1), pick2(hours, 0), pick2(minutes, 0), pick2(seconds, 0)).getTime();
      }
      return d;
    };
    Time2.prototype.timezoneOffsetFunction = function() {
      var time = this, options = this.options, moment = options.moment || win3.moment;
      if (!this.useUTC) {
        return function(timestamp) {
          return new Date(timestamp.toString()).getTimezoneOffset() * 6e4;
        };
      }
      if (options.timezone) {
        if (!moment) {
          error2(25);
        } else {
          return function(timestamp) {
            return -moment.tz(timestamp, options.timezone).utcOffset() * 6e4;
          };
        }
      }
      if (this.useUTC && options.getTimezoneOffset) {
        return function(timestamp) {
          return options.getTimezoneOffset(timestamp.valueOf()) * 6e4;
        };
      }
      return function() {
        return (time.timezoneOffset || 0) * 6e4;
      };
    };
    Time2.prototype.dateFormat = function(format15, timestamp, capitalize) {
      if (!defined2(timestamp) || isNaN(timestamp)) {
        return Globals_default.defaultOptions.lang && Globals_default.defaultOptions.lang.invalidDate || "";
      }
      format15 = pick2(format15, "%Y-%m-%d %H:%M:%S");
      var time = this, date = new this.Date(timestamp), hours = this.get("Hours", date), day = this.get("Day", date), dayOfMonth = this.get("Date", date), month = this.get("Month", date), fullYear = this.get("FullYear", date), lang2 = Globals_default.defaultOptions.lang, langWeekdays = lang2 && lang2.weekdays, shortWeekdays = lang2 && lang2.shortWeekdays, replacements = extend2({
        // Day
        // Short weekday, like 'Mon'
        a: shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3),
        // Long weekday, like 'Monday'
        A: langWeekdays[day],
        // Two digit day of the month, 01 to 31
        d: pad2(dayOfMonth),
        // Day of the month, 1 through 31
        e: pad2(dayOfMonth, 2, " "),
        // Day of the week, 0 through 6
        w: day,
        // Week (none implemented)
        // 'W': weekNumber(),
        // Month
        // Short month, like 'Jan'
        b: lang2.shortMonths[month],
        // Long month, like 'January'
        B: lang2.months[month],
        // Two digit month number, 01 through 12
        m: pad2(month + 1),
        // Month number, 1 through 12 (#8150)
        o: month + 1,
        // Year
        // Two digits year, like 09 for 2009
        y: fullYear.toString().substr(2, 2),
        // Four digits year, like 2009
        Y: fullYear,
        // Time
        // Two digits hours in 24h format, 00 through 23
        H: pad2(hours),
        // Hours in 24h format, 0 through 23
        k: hours,
        // Two digits hours in 12h format, 00 through 11
        I: pad2(hours % 12 || 12),
        // Hours in 12h format, 1 through 12
        l: hours % 12 || 12,
        // Two digits minutes, 00 through 59
        M: pad2(this.get("Minutes", date)),
        // Upper case AM or PM
        p: hours < 12 ? "AM" : "PM",
        // Lower case AM or PM
        P: hours < 12 ? "am" : "pm",
        // Two digits seconds, 00 through  59
        S: pad2(date.getSeconds()),
        // Milliseconds (naming from Ruby)
        L: pad2(Math.floor(timestamp % 1e3), 3)
      }, Globals_default.dateFormats);
      objectEach2(replacements, function(val, key) {
        while (format15.indexOf("%" + key) !== -1) {
          format15 = format15.replace("%" + key, typeof val === "function" ? val.call(time, timestamp) : val);
        }
      });
      return capitalize ? format15.substr(0, 1).toUpperCase() + format15.substr(1) : format15;
    };
    Time2.prototype.resolveDTLFormat = function(f) {
      if (!isObject2(f, true)) {
        f = splat2(f);
        return {
          main: f[0],
          from: f[1],
          to: f[2]
        };
      }
      return f;
    };
    Time2.prototype.getTimeTicks = function(normalizedInterval, min, max, startOfWeek) {
      var time = this, Date2 = time.Date, tickPositions = [], higherRanks = {}, minDate = new Date2(min), interval = normalizedInterval.unitRange, count = normalizedInterval.count || 1;
      var i, minYear, variableDayLength, minDay;
      startOfWeek = pick2(startOfWeek, 1);
      if (defined2(min)) {
        time.set("Milliseconds", minDate, interval >= timeUnits2.second ? 0 : (
          // #3935
          count * Math.floor(time.get("Milliseconds", minDate) / count)
        ));
        if (interval >= timeUnits2.second) {
          time.set("Seconds", minDate, interval >= timeUnits2.minute ? 0 : (
            // #3935
            count * Math.floor(time.get("Seconds", minDate) / count)
          ));
        }
        if (interval >= timeUnits2.minute) {
          time.set("Minutes", minDate, interval >= timeUnits2.hour ? 0 : count * Math.floor(time.get("Minutes", minDate) / count));
        }
        if (interval >= timeUnits2.hour) {
          time.set("Hours", minDate, interval >= timeUnits2.day ? 0 : count * Math.floor(time.get("Hours", minDate) / count));
        }
        if (interval >= timeUnits2.day) {
          time.set("Date", minDate, interval >= timeUnits2.month ? 1 : Math.max(1, count * Math.floor(time.get("Date", minDate) / count)));
        }
        if (interval >= timeUnits2.month) {
          time.set("Month", minDate, interval >= timeUnits2.year ? 0 : count * Math.floor(time.get("Month", minDate) / count));
          minYear = time.get("FullYear", minDate);
        }
        if (interval >= timeUnits2.year) {
          minYear -= minYear % count;
          time.set("FullYear", minDate, minYear);
        }
        if (interval === timeUnits2.week) {
          minDay = time.get("Day", minDate);
          time.set("Date", minDate, time.get("Date", minDate) - minDay + startOfWeek + // We don't want to skip days that are before
          // startOfWeek (#7051)
          (minDay < startOfWeek ? -7 : 0));
        }
        minYear = time.get("FullYear", minDate);
        var minMonth = time.get("Month", minDate), minDateDate = time.get("Date", minDate), minHours = time.get("Hours", minDate);
        min = minDate.getTime();
        if ((time.variableTimezone || !time.useUTC) && defined2(max)) {
          variableDayLength = // Long range, assume we're crossing over.
          max - min > 4 * timeUnits2.month || // Short range, check if min and max are in different time
          // zones.
          time.getTimezoneOffset(min) !== time.getTimezoneOffset(max);
        }
        var t = minDate.getTime();
        i = 1;
        while (t < max) {
          tickPositions.push(t);
          if (interval === timeUnits2.year) {
            t = time.makeTime(minYear + i * count, 0);
          } else if (interval === timeUnits2.month) {
            t = time.makeTime(minYear, minMonth + i * count);
          } else if (variableDayLength && (interval === timeUnits2.day || interval === timeUnits2.week)) {
            t = time.makeTime(minYear, minMonth, minDateDate + i * count * (interval === timeUnits2.day ? 1 : 7));
          } else if (variableDayLength && interval === timeUnits2.hour && count > 1) {
            t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count);
          } else {
            t += interval * count;
          }
          i++;
        }
        tickPositions.push(t);
        if (interval <= timeUnits2.hour && tickPositions.length < 1e4) {
          tickPositions.forEach(function(t2) {
            if (
              // Speed optimization, no need to run dateFormat unless
              // we're on a full or half hour
              t2 % 18e5 === 0 && // Check for local or global midnight
              time.dateFormat("%H%M%S%L", t2) === "000000000"
            ) {
              higherRanks[t2] = "day";
            }
          });
        }
      }
      tickPositions.info = extend2(normalizedInterval, {
        higherRanks,
        totalRange: interval * count
      });
      return tickPositions;
    };
    Time2.prototype.getDateFormat = function(range, timestamp, startOfWeek, dateTimeLabelFormats) {
      var dateStr = this.dateFormat("%m-%d %H:%M:%S.%L", timestamp), blank = "01-01 00:00:00.000", strpos = {
        millisecond: 15,
        second: 12,
        minute: 9,
        hour: 6,
        day: 3
      };
      var format15, n, lastN = "millisecond";
      for (n in timeUnits2) {
        if (range === timeUnits2.week && +this.dateFormat("%w", timestamp) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {
          n = "week";
          break;
        }
        if (timeUnits2[n] > range) {
          n = lastN;
          break;
        }
        if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
          break;
        }
        if (n !== "week") {
          lastN = n;
        }
      }
      if (n) {
        format15 = this.resolveDTLFormat(dateTimeLabelFormats[n]).main;
      }
      return format15;
    };
    return Time2;
  }()
);
var Time_default = Time;

// node_modules/highcharts/es-modules/Core/DefaultOptions.js
var color = Color_default.parse;
var isTouchDevice = Globals_default.isTouchDevice;
var svg = Globals_default.svg;
var merge4 = Utilities_default.merge;
var defaultOptions = {
  /**
   * An array containing the default colors for the chart's series. When
   * all colors are used, new colors are pulled from the start again.
   *
   * Default colors can also be set on a series or series.type basis,
   * see [column.colors](#plotOptions.column.colors),
   * [pie.colors](#plotOptions.pie.colors).
   *
   * In styled mode, the colors option doesn't exist. Instead, colors
   * are defined in CSS and applied either through series or point class
   * names, or through the [chart.colorCount](#chart.colorCount) option.
   *
   *
   * ### Legacy
   *
   * In Highcharts 3.x, the default colors were:
   * ```js
   * colors: ['#2f7ed8', '#0d233a', '#8bbc21', '#910000', '#1aadce',
   *         '#492970', '#f28f43', '#77a1e5', '#c42525', '#a6c96a']
   * ```
   *
   * In Highcharts 2.x, the default colors were:
   * ```js
   * colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
   *         '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92']
   * ```
   *
   * @sample {highcharts} highcharts/chart/colors/
   *         Assign a global color theme
   *
   * @type    {Array<Highcharts.ColorString>}
   * @default ["#7cb5ec", "#434348", "#90ed7d", "#f7a35c", "#8085e9",
   *          "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1"]
   */
  colors: Palette_default.colors,
  /**
   * Styled mode only. Configuration object for adding SVG definitions for
   * reusable elements. See [gradients, shadows and
   * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)
   * for more information and code examples.
   *
   * @type      {*}
   * @since     5.0.0
   * @apioption defs
   */
  /**
   * @ignore-option
   */
  symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
  /**
   * The language object is global and it can't be set on each chart
   * initialization. Instead, use `Highcharts.setOptions` to set it before any
   * chart is initialized.
   *
   * ```js
   * Highcharts.setOptions({
   *     lang: {
   *         months: [
   *             'Janvier', 'Fvrier', 'Mars', 'Avril',
   *             'Mai', 'Juin', 'Juillet', 'Aot',
   *             'Septembre', 'Octobre', 'Novembre', 'Dcembre'
   *         ],
   *         weekdays: [
   *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
   *             'Jeudi', 'Vendredi', 'Samedi'
   *         ]
   *     }
   * });
   * ```
   */
  lang: {
    /**
     * The loading text that appears when the chart is set into the loading
     * state following a call to `chart.showLoading`.
     */
    loading: "Loading...",
    /**
     * An array containing the months names. Corresponds to the `%B` format
     * in `Highcharts.dateFormat()`.
     *
     * @type    {Array<string>}
     * @default ["January", "February", "March", "April", "May", "June",
     *          "July", "August", "September", "October", "November",
     *          "December"]
     */
    months: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    /**
     * An array containing the months names in abbreviated form. Corresponds
     * to the `%b` format in `Highcharts.dateFormat()`.
     *
     * @type    {Array<string>}
     * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
     *          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
     */
    shortMonths: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    /**
     * An array containing the weekday names.
     *
     * @type    {Array<string>}
     * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
     *          "Friday", "Saturday"]
     */
    weekdays: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ],
    /**
     * Short week days, starting Sunday. If not specified, Highcharts uses
     * the first three letters of the `lang.weekdays` option.
     *
     * @sample highcharts/lang/shortweekdays/
     *         Finnish two-letter abbreviations
     *
     * @type      {Array<string>}
     * @since     4.2.4
     * @apioption lang.shortWeekdays
     */
    /**
     * What to show in a date field for invalid dates. Defaults to an empty
     * string.
     *
     * @type      {string}
     * @since     4.1.8
     * @product   highcharts highstock
     * @apioption lang.invalidDate
     */
    /**
     * The title appearing on hovering the zoom in button. The text itself
     * defaults to "+" and can be changed in the button options.
     *
     * @type      {string}
     * @default   Zoom in
     * @product   highmaps
     * @apioption lang.zoomIn
     */
    /**
     * The title appearing on hovering the zoom out button. The text itself
     * defaults to "-" and can be changed in the button options.
     *
     * @type      {string}
     * @default   Zoom out
     * @product   highmaps
     * @apioption lang.zoomOut
     */
    /**
     * The default decimal point used in the `Highcharts.numberFormat`
     * method unless otherwise specified in the function arguments.
     *
     * @since 1.2.2
     */
    decimalPoint: ".",
    /**
     * [Metric prefixes](https://en.wikipedia.org/wiki/Metric_prefix) used
     * to shorten high numbers in axis labels. Replacing any of the
     * positions with `null` causes the full number to be written. Setting
     * `numericSymbols` to `null` disables shortening altogether.
     *
     * @sample {highcharts} highcharts/lang/numericsymbols/
     *         Replacing the symbols with text
     * @sample {highstock} highcharts/lang/numericsymbols/
     *         Replacing the symbols with text
     *
     * @type    {Array<string>}
     * @default ["k", "M", "G", "T", "P", "E"]
     * @since   2.3.0
     */
    numericSymbols: ["k", "M", "G", "T", "P", "E"],
    /**
     * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
     * Use 10000 for Japanese, Korean and various Chinese locales, which
     * use symbols for 10^4, 10^8 and 10^12.
     *
     * @sample highcharts/lang/numericsymbolmagnitude/
     *         10000 magnitude for Japanese
     *
     * @type      {number}
     * @default   1000
     * @since     5.0.3
     * @apioption lang.numericSymbolMagnitude
     */
    /**
     * The text for the label appearing when a chart is zoomed.
     *
     * @since 1.2.4
     */
    resetZoom: "Reset zoom",
    /**
     * The tooltip title for the label appearing when a chart is zoomed.
     *
     * @since 1.2.4
     */
    resetZoomTitle: "Reset zoom level 1:1",
    /**
     * The default thousands separator used in the `Highcharts.numberFormat`
     * method unless otherwise specified in the function arguments. Defaults
     * to a single space character, which is recommended in
     * [ISO 31-0](https://en.wikipedia.org/wiki/ISO_31-0#Numbers) and works
     * across Anglo-American and continental European languages.
     *
     * @default \u0020
     * @since   1.2.2
     */
    thousandsSep: " "
  },
  /**
   * Global options that don't apply to each chart. These options, like
   * the `lang` options, must be set using the `Highcharts.setOptions`
   * method.
   *
   * ```js
   * Highcharts.setOptions({
   *     global: {
   *         useUTC: false
   *     }
   * });
   * ```
   */
  /**
   * _Canvg rendering for Android 2.x is removed as of Highcharts 5.0\.
   * Use the [libURL](#exporting.libURL) option to configure exporting._
   *
   * The URL to the additional file to lazy load for Android 2.x devices.
   * These devices don't support SVG, so we download a helper file that
   * contains [canvg](https://github.com/canvg/canvg), its dependency
   * rbcolor, and our own CanVG Renderer class. To avoid hotlinking to
   * our site, you can install canvas-tools.js on your own server and
   * change this option accordingly.
   *
   * @deprecated
   *
   * @type      {string}
   * @default   https://code.highcharts.com/{version}/modules/canvas-tools.js
   * @product   highcharts highmaps
   * @apioption global.canvasToolsURL
   */
  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.useUTC](#time.useUTC) that supports individual time settings
   * per chart.
   *
   * @deprecated
   *
   * @type      {boolean}
   * @apioption global.useUTC
   */
  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.Date](#time.Date) that supports individual time settings
   * per chart.
   *
   * @deprecated
   *
   * @type      {Function}
   * @product   highcharts highstock
   * @apioption global.Date
   */
  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.getTimezoneOffset](#time.getTimezoneOffset) that supports
   * individual time settings per chart.
   *
   * @deprecated
   *
   * @type      {Function}
   * @product   highcharts highstock
   * @apioption global.getTimezoneOffset
   */
  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.timezone](#time.timezone) that supports individual time
   * settings per chart.
   *
   * @deprecated
   *
   * @type      {string}
   * @product   highcharts highstock
   * @apioption global.timezone
   */
  /**
   * This option is deprecated since v6.0.5. Instead, use
   * [time.timezoneOffset](#time.timezoneOffset) that supports individual
   * time settings per chart.
   *
   * @deprecated
   *
   * @type      {number}
   * @product   highcharts highstock
   * @apioption global.timezoneOffset
   */
  global: {},
  /**
   * Time options that can apply globally or to individual charts. These
   * settings affect how `datetime` axes are laid out, how tooltips are
   * formatted, how series
   * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
   * the Highcharts Stock range selector handles time.
   *
   * The common use case is that all charts in the same Highcharts object
   * share the same time settings, in which case the global settings are set
   * using `setOptions`.
   *
   * ```js
   * // Apply time settings globally
   * Highcharts.setOptions({
   *     time: {
   *         timezone: 'Europe/London'
   *     }
   * });
   * // Apply time settings by instance
   * let chart = Highcharts.chart('container', {
   *     time: {
   *         timezone: 'America/New_York'
   *     },
   *     series: [{
   *         data: [1, 4, 3, 5]
   *     }]
   * });
   *
   * // Use the Time object
   * console.log(
   *        'Current time in New York',
   *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
   * );
   * ```
   *
   * Since v6.0.5, the time options were moved from the `global` obect to the
   * `time` object, and time options can be set on each individual chart.
   *
   * @sample {highcharts|highstock}
   *         highcharts/time/timezone/
   *         Set the timezone globally
   * @sample {highcharts}
   *         highcharts/time/individual/
   *         Set the timezone per chart instance
   * @sample {highstock}
   *         stock/time/individual/
   *         Set the timezone per chart instance
   *
   * @since     6.0.5
   * @optionparent time
   */
  time: {
    /**
     * A custom `Date` class for advanced date handling. For example,
     * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to
     * handle Jalali dates.
     *
     * @type      {*}
     * @since     4.0.4
     * @product   highcharts highstock gantt
     */
    Date: void 0,
    /**
     * A callback to return the time zone offset for a given datetime. It
     * takes the timestamp in terms of milliseconds since January 1 1970,
     * and returns the timezone offset in minutes. This provides a hook
     * for drawing time based charts in specific time zones using their
     * local DST crossover dates, with the help of external libraries.
     *
     * @see [global.timezoneOffset](#global.timezoneOffset)
     *
     * @sample {highcharts|highstock} highcharts/time/gettimezoneoffset/
     *         Use moment.js to draw Oslo time regardless of browser locale
     *
     * @type      {Highcharts.TimezoneOffsetCallbackFunction}
     * @since     4.1.0
     * @product   highcharts highstock gantt
     */
    getTimezoneOffset: void 0,
    /**
     * Requires [moment.js](https://momentjs.com/). If the timezone option
     * is specified, it creates a default
     * [getTimezoneOffset](#time.getTimezoneOffset) function that looks
     * up the specified timezone in moment.js. If moment.js is not included,
     * this throws a Highcharts error in the console, but does not crash the
     * chart.
     *
     * @see [getTimezoneOffset](#time.getTimezoneOffset)
     *
     * @sample {highcharts|highstock} highcharts/time/timezone/
     *         Europe/Oslo
     *
     * @type      {string}
     * @since     5.0.7
     * @product   highcharts highstock gantt
     */
    timezone: void 0,
    /**
     * The timezone offset in minutes. Positive values are west, negative
     * values are east of UTC, as in the ECMAScript
     * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
     * method. Use this to display UTC based data in a predefined time zone.
     *
     * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
     *
     * @sample {highcharts|highstock} highcharts/time/timezoneoffset/
     *         Timezone offset
     *
     * @since     3.0.8
     * @product   highcharts highstock gantt
     */
    timezoneOffset: 0,
    /**
     * Whether to use UTC time for axis scaling, tickmark placement and
     * time display in `Highcharts.dateFormat`. Advantages of using UTC
     * is that the time displays equally regardless of the user agent's
     * time zone settings. Local time can be used when the data is loaded
     * in real time or when correct Daylight Saving Time transitions are
     * required.
     *
     * @sample {highcharts} highcharts/time/useutc-true/
     *         True by default
     * @sample {highcharts} highcharts/time/useutc-false/
     *         False
     */
    useUTC: true
  },
  chart: ChartDefaults_default,
  /**
   * The chart's main title.
   *
   * @sample {highmaps} maps/title/title/
   *         Title options demonstrated
   */
  title: {
    /**
     * When the title is floating, the plot area will not move to make space
     * for it.
     *
     * @sample {highcharts} highcharts/chart/zoomtype-none/
     *         False by default
     * @sample {highcharts} highcharts/title/floating/
     *         True - title on top of the plot area
     * @sample {highstock} stock/chart/title-floating/
     *         True - title on top of the plot area
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @apioption title.floating
     */
    /**
     * CSS styles for the title. Use this for font styling, but use `align`,
     * `x` and `y` for text alignment.
     *
     * In styled mode, the title style is given in the `.highcharts-title`
     * class.
     *
     * @sample {highcharts} highcharts/title/style/
     *         Custom color and weight
     * @sample {highstock} stock/chart/title-style/
     *         Custom color and weight
     * @sample highcharts/css/titles/
     *         Styled mode
     *
     * @type      {Highcharts.CSSObject}
     * @default   {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
     * @default   {highstock} { "color": "#333333", "fontSize": "16px" }
     * @apioption title.style
     */
    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the text.
     *
     * @type      {boolean}
     * @default   false
     * @apioption title.useHTML
     */
    /**
     * The vertical alignment of the title. Can be one of `"top"`,
     * `"middle"` and `"bottom"`. When a value is given, the title behaves
     * as if [floating](#title.floating) were `true`.
     *
     * @sample {highcharts} highcharts/title/verticalalign/
     *         Chart title in bottom right corner
     * @sample {highstock} stock/chart/title-verticalalign/
     *         Chart title in bottom right corner
     *
     * @type      {Highcharts.VerticalAlignValue}
     * @since     2.1
     * @apioption title.verticalAlign
     */
    /**
     * The x position of the title relative to the alignment within
     * `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @sample {highcharts} highcharts/title/align/
     *         Aligned to the plot area (x = 70px = margin left - spacing
     *         left)
     * @sample {highstock} stock/chart/title-align/
     *         Aligned to the plot area (x = 50px = margin left - spacing
     *         left)
     *
     * @type      {number}
     * @default   0
     * @since     2.0
     * @apioption title.x
     */
    /**
     * The y position of the title relative to the alignment within
     * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](
     * #chart.spacingBottom). By default it depends on the font size.
     *
     * @sample {highcharts} highcharts/title/y/
     *         Title inside the plot area
     * @sample {highstock} stock/chart/title-verticalalign/
     *         Chart title in bottom right corner
     *
     * @type      {number}
     * @since     2.0
     * @apioption title.y
     */
    /**
     * The title of the chart. To disable the title, set the `text` to
     * `undefined`.
     *
     * @sample {highcharts} highcharts/title/text/
     *         Custom title
     * @sample {highstock} stock/chart/title-text/
     *         Custom title
     *
     * @default {highcharts|highmaps} Chart title
     * @default {highstock} undefined
     */
    text: "Chart title",
    /**
     * The horizontal alignment of the title. Can be one of "left", "center"
     * and "right".
     *
     * @sample {highcharts} highcharts/title/align/
     *         Aligned to the plot area (x = 70px = margin left - spacing
     *         left)
     * @sample {highstock} stock/chart/title-align/
     *         Aligned to the plot area (x = 50px = margin left - spacing
     *         left)
     *
     * @type  {Highcharts.AlignValue}
     * @since 2.0
     */
    align: "center",
    /**
     * The margin between the title and the plot area, or if a subtitle
     * is present, the margin between the subtitle and the plot area.
     *
     * @sample {highcharts} highcharts/title/margin-50/
     *         A chart title margin of 50
     * @sample {highcharts} highcharts/title/margin-subtitle/
     *         The same margin applied with a subtitle
     * @sample {highstock} stock/chart/title-margin/
     *         A chart title margin of 50
     *
     * @since 2.1
     */
    margin: 15,
    /**
     * Adjustment made to the title width, normally to reserve space for
     * the exporting burger menu.
     *
     * @sample highcharts/title/widthadjust/
     *         Wider menu, greater padding
     *
     * @since 4.2.5
     */
    widthAdjust: -44
  },
  /**
   * The chart's subtitle. This can be used both to display a subtitle below
   * the main title, and to display random text anywhere in the chart. The
   * subtitle can be updated after chart initialization through the
   * `Chart.setTitle` method.
   *
   * @sample {highmaps} maps/title/subtitle/
   *         Subtitle options demonstrated
   */
  subtitle: {
    /**
     * When the subtitle is floating, the plot area will not move to make
     * space for it.
     *
     * @sample {highcharts} highcharts/subtitle/floating/
     *         Floating title and subtitle
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote floating at bottom right of plot area
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @apioption subtitle.floating
     */
    /**
     * CSS styles for the title.
     *
     * In styled mode, the subtitle style is given in the
     * `.highcharts-subtitle` class.
     *
     * @sample {highcharts} highcharts/subtitle/style/
     *         Custom color and weight
     * @sample {highcharts} highcharts/css/titles/
     *         Styled mode
     * @sample {highstock} stock/chart/subtitle-style
     *         Custom color and weight
     * @sample {highstock} highcharts/css/titles/
     *         Styled mode
     * @sample {highmaps} highcharts/css/titles/
     *         Styled mode
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"color": "#666666"}
     * @apioption subtitle.style
     */
    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the text.
     *
     * @type      {boolean}
     * @default   false
     * @apioption subtitle.useHTML
     */
    /**
     * The vertical alignment of the title. Can be one of `"top"`,
     * `"middle"` and `"bottom"`. When middle, the subtitle behaves as
     * floating.
     *
     * @sample {highcharts} highcharts/subtitle/verticalalign/
     *         Footnote at the bottom right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at the bottom right of plot area
     *
     * @type      {Highcharts.VerticalAlignValue}
     * @since     2.1
     * @apioption subtitle.verticalAlign
     */
    /**
     * The x position of the subtitle relative to the alignment within
     * `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @sample {highcharts} highcharts/subtitle/align/
     *         Footnote at right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at the bottom right of plot area
     *
     * @type      {number}
     * @default   0
     * @since     2.0
     * @apioption subtitle.x
     */
    /**
     * The y position of the subtitle relative to the alignment within
     * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle
     * is laid out below the title unless the title is floating.
     *
     * @sample {highcharts} highcharts/subtitle/verticalalign/
     *         Footnote at the bottom right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at the bottom right of plot area
     *
     * @type      {number}
     * @since     2.0
     * @apioption subtitle.y
     */
    /**
     * The subtitle of the chart.
     *
     * @sample {highcharts|highstock} highcharts/subtitle/text/
     *         Custom subtitle
     * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/
     *         Formatted and linked text.
     */
    text: "",
    /**
     * The horizontal alignment of the subtitle. Can be one of "left",
     *  "center" and "right".
     *
     * @sample {highcharts} highcharts/subtitle/align/
     *         Footnote at right of plot area
     * @sample {highstock} stock/chart/subtitle-footnote
     *         Footnote at bottom right of plot area
     *
     * @type  {Highcharts.AlignValue}
     * @since 2.0
     */
    align: "center",
    /**
     * Adjustment made to the subtitle width, normally to reserve space
     * for the exporting burger menu.
     *
     * @see [title.widthAdjust](#title.widthAdjust)
     *
     * @sample highcharts/title/widthadjust/
     *         Wider menu, greater padding
     *
     * @since 4.2.5
     */
    widthAdjust: -44
  },
  /**
   * The chart's caption, which will render below the chart and will be part
   * of exported charts. The caption can be updated after chart initialization
   * through the `Chart.update` or `Chart.caption.update` methods.
   *
   * @sample highcharts/caption/text/
   *         A chart with a caption
   * @since  7.2.0
   */
  caption: {
    /**
     * When the caption is floating, the plot area will not move to make
     * space for it.
     *
     * @type      {boolean}
     * @default   false
     * @apioption caption.floating
     */
    /**
     * The margin between the caption and the plot area.
     */
    margin: 15,
    /**
     * CSS styles for the caption.
     *
     * In styled mode, the caption style is given in the
     * `.highcharts-caption` class.
     *
     * @sample {highcharts} highcharts/css/titles/
     *         Styled mode
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"color": "#666666"}
     * @apioption caption.style
     */
    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the text.
     *
     * @type      {boolean}
     * @default   false
     * @apioption caption.useHTML
     */
    /**
     * The x position of the caption relative to the alignment within
     * `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @type      {number}
     * @default   0
     * @apioption caption.x
     */
    /**
     * The y position of the caption relative to the alignment within
     * `chart.spacingTop` and `chart.spacingBottom`.
     *
     * @type      {number}
     * @apioption caption.y
     */
    /**
     * The caption text of the chart.
     *
     * @sample {highcharts} highcharts/caption/text/
     *         Custom caption
     */
    text: "",
    /**
     * The horizontal alignment of the caption. Can be one of "left",
     *  "center" and "right".
     *
     * @type  {Highcharts.AlignValue}
     */
    align: "left",
    /**
     * The vertical alignment of the caption. Can be one of `"top"`,
     * `"middle"` and `"bottom"`. When middle, the caption behaves as
     * floating.
     *
     * @type      {Highcharts.VerticalAlignValue}
     */
    verticalAlign: "bottom"
  },
  /**
   * The plotOptions is a wrapper object for config objects for each series
   * type. The config objects for each series can also be overridden for
   * each series item as given in the series array.
   *
   * Configuration options for the series are given in three levels. Options
   * for all series in a chart are given in the [plotOptions.series](
   * #plotOptions.series) object. Then options for all series of a specific
   * type are given in the plotOptions of that type, for example
   * `plotOptions.line`. Next, options for one single series are given in
   * [the series array](#series).
   */
  plotOptions: {},
  /**
   * HTML labels that can be positioned anywhere in the chart area.
   *
   * This option is deprecated since v7.1.2. Instead, use
   * [annotations](#annotations) that support labels.
   *
   * @deprecated
   * @product   highcharts highstock
   */
  labels: {
    /**
     * An HTML label that can be positioned anywhere in the chart area.
     *
     * @deprecated
     * @type      {Array<*>}
     * @apioption labels.items
     */
    /**
     * Inner HTML or text for the label.
     *
     * @deprecated
     * @type      {string}
     * @apioption labels.items.html
     */
    /**
     * CSS styles for each label. To position the label, use left and top
     * like this:
     * ```js
     * style: {
     *     left: '100px',
     *     top: '100px'
     * }
     * ```
     *
     * @deprecated
     * @type      {Highcharts.CSSObject}
     * @apioption labels.items.style
     */
    /**
     * Shared CSS styles for all labels.
     *
     * @deprecated
     * @type    {Highcharts.CSSObject}
     * @default {"color": "#333333", "position": "absolute"}
     */
    style: {
      /**
       * @ignore-option
       */
      position: "absolute",
      /**
       * @ignore-option
       */
      color: Palette_default.neutralColor80
    }
  },
  /**
   * The legend is a box containing a symbol and name for each series
   * item or point item in the chart. Each series (or points in case
   * of pie charts) is represented by a symbol and its name in the legend.
   *
   * It is possible to override the symbol creator function and create
   * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).
   *
   * @productdesc {highmaps}
   * A Highmaps legend by default contains one legend item per series, but if
   * a `colorAxis` is defined, the axis will be displayed in the legend.
   * Either as a gradient, or as multiple legend items for `dataClasses`.
   */
  legend: {
    /**
     * The background color of the legend.
     *
     * @see In styled mode, the legend background fill can be applied with
     *      the `.highcharts-legend-box` class.
     *
     * @sample {highcharts} highcharts/legend/backgroundcolor/
     *         Yellowish background
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption legend.backgroundColor
     */
    /**
     * The width of the drawn border around the legend.
     *
     * @see In styled mode, the legend border stroke width can be applied
     *      with the `.highcharts-legend-box` class.
     *
     * @sample {highcharts} highcharts/legend/borderwidth/
     *         2px border width
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type      {number}
     * @default   0
     * @apioption legend.borderWidth
     */
    /**
     * Enable or disable the legend. There is also a series-specific option,
     * [showInLegend](#plotOptions.series.showInLegend), that can hide the
     * series from the legend. In some series types this is `false` by
     * default, so it must set to `true` in order to show the legend for the
     * series.
     *
     * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
     * @sample {highstock} stock/legend/align/ Various legend options
     * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
     *
     * @default {highstock} false
     * @default {highmaps} true
     * @default {gantt} false
     */
    enabled: true,
    /**
     * The horizontal alignment of the legend box within the chart area.
     * Valid values are `left`, `center` and `right`.
     *
     * In the case that the legend is aligned in a corner position, the
     * `layout` option will determine whether to place it above/below
     * or on the side of the plot area.
     *
     * @sample {highcharts} highcharts/legend/align/
     *         Legend at the right of the chart
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/alignment/
     *         Legend alignment
     *
     * @type  {Highcharts.AlignValue}
     * @since 2.0
     */
    align: "center",
    /**
     * If the [layout](legend.layout) is `horizontal` and the legend items
     * span over two lines or more, whether to align the items into vertical
     * columns. Setting this to `false` makes room for more items, but will
     * look more messy.
     *
     * @since 6.1.0
     */
    alignColumns: true,
    /**
     * A CSS class name to apply to the legend group.
     */
    className: "highcharts-no-tooltip",
    /**
     * When the legend is floating, the plot area ignores it and is allowed
     * to be placed below it.
     *
     * @sample {highcharts} highcharts/legend/floating-false/
     *         False by default
     * @sample {highcharts} highcharts/legend/floating-true/
     *         True
     * @sample {highmaps} maps/legend/alignment/
     *         Floating legend
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @apioption legend.floating
     */
    /**
     * The layout of the legend items. Can be one of `horizontal` or
     * `vertical` or `proximate`. When `proximate`, the legend items will be
     * placed as close as possible to the graphs they're representing,
     * except in inverted charts or when the legend position doesn't allow
     * it.
     *
     * @sample {highcharts} highcharts/legend/layout-horizontal/
     *         Horizontal by default
     * @sample {highcharts} highcharts/legend/layout-vertical/
     *         Vertical
     * @sample highcharts/legend/layout-proximate
     *         Labels proximate to the data
     * @sample {highstock} stock/legend/layout-horizontal/
     *         Horizontal by default
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Vertical with data classes
     * @sample {highmaps} maps/legend/layout-vertical/
     *         Vertical with color axis gradient
     *
     * @validvalue ["horizontal", "vertical", "proximate"]
     */
    layout: "horizontal",
    /**
     * In a legend with horizontal layout, the itemDistance defines the
     * pixel distance between each item.
     *
     * @sample {highcharts} highcharts/legend/layout-horizontal/
     *         50px item distance
     * @sample {highstock} highcharts/legend/layout-horizontal/
     *         50px item distance
     *
     * @type      {number}
     * @default   {highcharts} 20
     * @default   {highstock} 20
     * @default   {highmaps} 8
     * @since     3.0.3
     * @apioption legend.itemDistance
     */
    /**
     * The pixel bottom margin for each legend item.
     *
     * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     *
     * @type      {number}
     * @default   0
     * @since     2.2.0
     * @apioption legend.itemMarginBottom
     */
    /**
     * The pixel top margin for each legend item.
     *
     * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     *
     * @type      {number}
     * @default   0
     * @since     2.2.0
     * @apioption legend.itemMarginTop
     */
    /**
     * The width for each legend item. By default the items are laid out
     * successively. In a [horizontal layout](legend.layout), if the items
     * are laid out across two rows or more, they will be vertically aligned
     * depending on the [legend.alignColumns](legend.alignColumns) option.
     *
     * @sample {highcharts} highcharts/legend/itemwidth-default/
     *         Undefined by default
     * @sample {highcharts} highcharts/legend/itemwidth-80/
     *         80 for aligned legend items
     *
     * @type      {number}
     * @since     2.0
     * @apioption legend.itemWidth
     */
    /**
     * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * for each legend label. Available variables relates to properties on
     * the series, or the point in case of pies.
     *
     * @type      {string}
     * @default   {name}
     * @since     1.3
     * @apioption legend.labelFormat
     */
    /* eslint-disable valid-jsdoc */
    /**
     * Callback function to format each of the series' labels. The `this`
     * keyword refers to the series object, or the point object in case of
     * pie charts. By default the series or point name is printed.
     *
     * @productdesc {highmaps}
     * In Highmaps the context can also be a data class in case of a
     * `colorAxis`.
     *
     * @sample {highcharts} highcharts/legend/labelformatter/
     *         Add text
     * @sample {highmaps} maps/legend/labelformatter/
     *         Data classes with label formatter
     *
     * @type {Highcharts.FormatterCallbackFunction<Point|Series>}
     */
    labelFormatter: function() {
      return this.name;
    },
    /**
     * Line height for the legend items. Deprecated as of 2.1\. Instead,
     * the line height for each item can be set using
     * `itemStyle.lineHeight`, and the padding between items using
     * `itemMarginTop` and `itemMarginBottom`.
     *
     * @sample {highcharts} highcharts/legend/lineheight/
     *         Setting padding
     *
     * @deprecated
     *
     * @type      {number}
     * @default   16
     * @since     2.0
     * @product   highcharts gantt
     * @apioption legend.lineHeight
     */
    /**
     * If the plot area sized is calculated automatically and the legend is
     * not floating, the legend margin is the space between the legend and
     * the axis labels or plot area.
     *
     * @sample {highcharts} highcharts/legend/margin-default/
     *         12 pixels by default
     * @sample {highcharts} highcharts/legend/margin-30/
     *         30 pixels
     *
     * @type      {number}
     * @default   12
     * @since     2.1
     * @apioption legend.margin
     */
    /**
     * Maximum pixel height for the legend. When the maximum height is
     * extended, navigation will show.
     *
     * @type      {number}
     * @since     2.3.0
     * @apioption legend.maxHeight
     */
    /**
     * The color of the drawn border around the legend.
     *
     * @see In styled mode, the legend border stroke can be applied with the
     *      `.highcharts-legend-box` class.
     *
     * @sample {highcharts} highcharts/legend/bordercolor/
     *         Brown border
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    borderColor: Palette_default.neutralColor40,
    /**
     * The border corner radius of the legend.
     *
     * @sample {highcharts} highcharts/legend/borderradius-default/
     *         Square by default
     * @sample {highcharts} highcharts/legend/borderradius-round/
     *         5px rounded
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     */
    borderRadius: 0,
    /**
     * Options for the paging or navigation appearing when the legend is
     * overflown. Navigation works well on screen, but not in static
     * exported images. One way of working around that is to
     * [increase the chart height in
     * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).
     */
    navigation: {
      /**
       * How to animate the pages when navigating up or down. A value of
       * `true` applies the default navigation given in the
       * `chart.animation` option. Additional options can be given as an
       * object containing values for easing and duration.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @default   true
       * @since     2.2.4
       * @apioption legend.navigation.animation
       */
      /**
       * The pixel size of the up and down arrows in the legend paging
       * navigation.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type      {number}
       * @default   12
       * @since     2.2.4
       * @apioption legend.navigation.arrowSize
       */
      /**
       * Whether to enable the legend navigation. In most cases, disabling
       * the navigation results in an unwanted overflow.
       *
       * See also the [adapt chart to legend](
       * https://www.highcharts.com/products/plugin-registry/single/8/Adapt-Chart-To-Legend)
       * plugin for a solution to extend the chart height to make room for
       * the legend, optionally in exported charts only.
       *
       * @type      {boolean}
       * @default   true
       * @since     4.2.4
       * @apioption legend.navigation.enabled
       */
      /**
       * Text styles for the legend page navigation.
       *
       * @see In styled mode, the navigation items are styled with the
       *      `.highcharts-legend-navigation` class.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type      {Highcharts.CSSObject}
       * @since     2.2.4
       * @apioption legend.navigation.style
       */
      /**
       * The color for the active up or down arrow in the legend page
       * navigation.
       *
       * @see In styled mode, the active arrow be styled with the
       *      `.highcharts-legend-nav-active` class.
       *
       * @sample  {highcharts} highcharts/legend/navigation/
       *          Legend page navigation demonstrated
       * @sample  {highstock} highcharts/legend/navigation/
       *          Legend page navigation demonstrated
       *
       * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since 2.2.4
       */
      activeColor: Palette_default.highlightColor100,
      /**
       * The color of the inactive up or down arrow in the legend page
       * navigation. .
       *
       * @see In styled mode, the inactive arrow be styled with the
       *      `.highcharts-legend-nav-inactive` class.
       *
       * @sample {highcharts} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       * @sample {highstock} highcharts/legend/navigation/
       *         Legend page navigation demonstrated
       *
       * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since 2.2.4
       */
      inactiveColor: Palette_default.neutralColor20
    },
    /**
     * The inner padding of the legend box.
     *
     * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     *
     * @type      {number}
     * @default   8
     * @since     2.2.0
     * @apioption legend.padding
     */
    /**
     * Whether to reverse the order of the legend items compared to the
     * order of the series or points as defined in the configuration object.
     *
     * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
     *      [series.legendIndex](#series.legendIndex)
     *
     * @sample {highcharts} highcharts/legend/reversed/
     *         Stacked bar with reversed legend
     *
     * @type      {boolean}
     * @default   false
     * @since     1.2.5
     * @apioption legend.reversed
     */
    /**
     * Whether to show the symbol on the right side of the text rather than
     * the left side. This is common in Arabic and Hebrew.
     *
     * @sample {highcharts} highcharts/legend/rtl/
     *         Symbol to the right
     *
     * @type      {boolean}
     * @default   false
     * @since     2.2
     * @apioption legend.rtl
     */
    /**
     * CSS styles for the legend area. In the 1.x versions the position
     * of the legend area was determined by CSS. In 2.x, the position is
     * determined by properties like `align`, `verticalAlign`, `x` and `y`,
     * but the styles are still parsed for backwards compatibility.
     *
     * @deprecated
     *
     * @type      {Highcharts.CSSObject}
     * @product   highcharts highstock
     * @apioption legend.style
     */
    /**
     * CSS styles for each legend item. Only a subset of CSS is supported,
     * notably those options related to text. The default `textOverflow`
     * property makes long texts truncate. Set it to `undefined` to wrap
     * text instead. A `width` property can be added to control the text
     * width.
     *
     * @see In styled mode, the legend items can be styled with the
     *      `.highcharts-legend-item` class.
     *
     * @sample {highcharts} highcharts/legend/itemstyle/
     *         Bold black text
     * @sample {highmaps} maps/legend/itemstyle/
     *         Item text styles
     *
     * @type    {Highcharts.CSSObject}
     * @default {"color": "#333333", "cursor": "pointer", "fontSize": "12px", "fontWeight": "bold", "textOverflow": "ellipsis"}
     */
    itemStyle: {
      /**
       * @ignore
       */
      color: Palette_default.neutralColor80,
      /**
       * @ignore
       */
      cursor: "pointer",
      /**
       * @ignore
       */
      fontSize: "12px",
      /**
       * @ignore
       */
      fontWeight: "bold",
      /**
       * @ignore
       */
      textOverflow: "ellipsis"
    },
    /**
     * CSS styles for each legend item in hover mode. Only a subset of
     * CSS is supported, notably those options related to text. Properties
     * are inherited from `style` unless overridden here.
     *
     * @see In styled mode, the hovered legend items can be styled with
     *      the `.highcharts-legend-item:hover` pesudo-class.
     *
     * @sample {highcharts} highcharts/legend/itemhoverstyle/
     *         Red on hover
     * @sample {highmaps} maps/legend/itemstyle/
     *         Item text styles
     *
     * @type    {Highcharts.CSSObject}
     * @default {"color": "#000000"}
     */
    itemHoverStyle: {
      /**
       * @ignore
       */
      color: Palette_default.neutralColor100
    },
    /**
     * CSS styles for each legend item when the corresponding series or
     * point is hidden. Only a subset of CSS is supported, notably those
     * options related to text. Properties are inherited from `style`
     * unless overridden here.
     *
     * @see In styled mode, the hidden legend items can be styled with
     *      the `.highcharts-legend-item-hidden` class.
     *
     * @sample {highcharts} highcharts/legend/itemhiddenstyle/
     *         Darker gray color
     *
     * @type    {Highcharts.CSSObject}
     * @default {"color": "#cccccc"}
     */
    itemHiddenStyle: {
      /**
       * @ignore
       */
      color: Palette_default.neutralColor20
    },
    /**
     * Whether to apply a drop shadow to the legend. A `backgroundColor`
     * also needs to be applied for this to take effect. The shadow can be
     * an object configuration containing `color`, `offsetX`, `offsetY`,
     * `opacity` and `width`.
     *
     * @sample {highcharts} highcharts/legend/shadow/
     *         White background and drop shadow
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/border-background/
     *         Border and background options
     *
     * @type {boolean|Highcharts.CSSObject}
     */
    shadow: false,
    /**
     * Default styling for the checkbox next to a legend item when
     * `showCheckbox` is true.
     *
     * @type {Highcharts.CSSObject}
     * @default {"width": "13px", "height": "13px", "position":"absolute"}
     */
    itemCheckboxStyle: {
      /**
       * @ignore
       */
      position: "absolute",
      /**
       * @ignore
       */
      width: "13px",
      /**
       * @ignore
       */
      height: "13px"
    },
    // itemWidth: undefined,
    /**
     * When this is true, the legend symbol width will be the same as
     * the symbol height, which in turn defaults to the font size of the
     * legend items.
     *
     * @since 5.0.0
     */
    squareSymbol: true,
    /**
     * The pixel height of the symbol for series types that use a rectangle
     * in the legend. Defaults to the font size of legend items.
     *
     * @productdesc {highmaps}
     * In Highmaps, when the symbol is the gradient of a vertical color
     * axis, the height defaults to 200.
     *
     * @sample {highmaps} maps/legend/layout-vertical-sized/
     *         Sized vertical gradient
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         No distance between data classes
     *
     * @type      {number}
     * @since     3.0.8
     * @apioption legend.symbolHeight
     */
    /**
     * The border radius of the symbol for series types that use a rectangle
     * in the legend. Defaults to half the `symbolHeight`.
     *
     * @sample {highcharts} highcharts/legend/symbolradius/
     *         Round symbols
     * @sample {highstock} highcharts/legend/symbolradius/
     *         Round symbols
     * @sample {highmaps} highcharts/legend/symbolradius/
     *         Round symbols
     *
     * @type      {number}
     * @since     3.0.8
     * @apioption legend.symbolRadius
     */
    /**
     * The pixel width of the legend item symbol. When the `squareSymbol`
     * option is set, this defaults to the `symbolHeight`, otherwise 16.
     *
     * @productdesc {highmaps}
     * In Highmaps, when the symbol is the gradient of a horizontal color
     * axis, the width defaults to 200.
     *
     * @sample {highcharts} highcharts/legend/symbolwidth/
     *         Greater symbol width and padding
     * @sample {highmaps} maps/legend/padding-itemmargin/
     *         Padding and item margins demonstrated
     * @sample {highmaps} maps/legend/layout-vertical-sized/
     *         Sized vertical gradient
     *
     * @type      {number}
     * @apioption legend.symbolWidth
     */
    /**
     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the legend item texts.
     *
     * Prior to 4.1.7, when using HTML, [legend.navigation](
     * #legend.navigation) was disabled.
     *
     * @type      {boolean}
     * @default   false
     * @apioption legend.useHTML
     */
    /**
     * The width of the legend box. If a number is set, it translates to
     * pixels. Since v7.0.2 it allows setting a percent string of the full
     * chart width, for example `40%`.
     *
     * Defaults to the full chart width for legends below or above the
     * chart, half the chart width for legends to the left and right.
     *
     * @sample {highcharts} highcharts/legend/width/
     *         Aligned to the plot area
     * @sample {highcharts} highcharts/legend/width-percent/
     *         A percent of the chart width
     *
     * @type      {number|string}
     * @since     2.0
     * @apioption legend.width
     */
    /**
     * The pixel padding between the legend item symbol and the legend
     * item text.
     *
     * @sample {highcharts} highcharts/legend/symbolpadding/
     *         Greater symbol width and padding
     */
    symbolPadding: 5,
    /**
     * The vertical alignment of the legend box. Can be one of `top`,
     * `middle` or `bottom`. Vertical position can be further determined
     * by the `y` option.
     *
     * In the case that the legend is aligned in a corner position, the
     * `layout` option will determine whether to place it above/below
     * or on the side of the plot area.
     *
     * When the [layout](#legend.layout) option is `proximate`, the
     * `verticalAlign` option doesn't apply.
     *
     * @sample {highcharts} highcharts/legend/verticalalign/
     *         Legend 100px from the top of the chart
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/alignment/
     *         Legend alignment
     *
     * @type  {Highcharts.VerticalAlignValue}
     * @since 2.0
     */
    verticalAlign: "bottom",
    // width: undefined,
    /**
     * The x offset of the legend relative to its horizontal alignment
     * `align` within chart.spacingLeft and chart.spacingRight. Negative
     * x moves it to the left, positive x moves it to the right.
     *
     * @sample {highcharts} highcharts/legend/width/
     *         Aligned to the plot area
     *
     * @since 2.0
     */
    x: 0,
    /**
     * The vertical offset of the legend relative to it's vertical alignment
     * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
     *  Negative y moves it up, positive y moves it down.
     *
     * @sample {highcharts} highcharts/legend/verticalalign/
     *         Legend 100px from the top of the chart
     * @sample {highstock} stock/legend/align/
     *         Various legend options
     * @sample {highmaps} maps/legend/alignment/
     *         Legend alignment
     *
     * @since 2.0
     */
    y: 0,
    /**
     * A title to be added on top of the legend.
     *
     * @sample {highcharts} highcharts/legend/title/
     *         Legend title
     * @sample {highmaps} maps/legend/alignment/
     *         Legend with title
     *
     * @since 3.0
     */
    title: {
      /**
       * A text or HTML string for the title.
       *
       * @type      {string}
       * @since     3.0
       * @apioption legend.title.text
       */
      /**
       * Generic CSS styles for the legend title.
       *
       * @see In styled mode, the legend title is styled with the
       *      `.highcharts-legend-title` class.
       *
       * @type    {Highcharts.CSSObject}
       * @default {"fontWeight": "bold"}
       * @since   3.0
       */
      style: {
        /**
         * @ignore
         */
        fontWeight: "bold"
      }
    }
  },
  /**
   * The loading options control the appearance of the loading screen
   * that covers the plot area on chart operations. This screen only
   * appears after an explicit call to `chart.showLoading()`. It is a
   * utility for developers to communicate to the end user that something
   * is going on, for example while retrieving new data via an XHR connection.
   * The "Loading..." text itself is not part of this configuration
   * object, but part of the `lang` object.
   */
  loading: {
    /**
     * The duration in milliseconds of the fade out effect.
     *
     * @sample highcharts/loading/hideduration/
     *         Fade in and out over a second
     *
     * @type      {number}
     * @default   100
     * @since     1.2.0
     * @apioption loading.hideDuration
     */
    /**
     * The duration in milliseconds of the fade in effect.
     *
     * @sample highcharts/loading/hideduration/
     *         Fade in and out over a second
     *
     * @type      {number}
     * @default   100
     * @since     1.2.0
     * @apioption loading.showDuration
     */
    /**
     * CSS styles for the loading label `span`.
     *
     * @see In styled mode, the loading label is styled with the
     *      `.highcharts-loading-inner` class.
     *
     * @sample {highcharts|highmaps} highcharts/loading/labelstyle/
     *         Vertically centered
     * @sample {highstock} stock/loading/general/
     *         Label styles
     *
     * @type    {Highcharts.CSSObject}
     * @default {"fontWeight": "bold", "position": "relative", "top": "45%"}
     * @since   1.2.0
     */
    labelStyle: {
      /**
       * @ignore
       */
      fontWeight: "bold",
      /**
       * @ignore
       */
      position: "relative",
      /**
       * @ignore
       */
      top: "45%"
    },
    /**
     * CSS styles for the loading screen that covers the plot area.
     *
     * In styled mode, the loading label is styled with the
     * `.highcharts-loading` class.
     *
     * @sample  {highcharts|highmaps} highcharts/loading/style/
     *          Gray plot area, white text
     * @sample  {highstock} stock/loading/general/
     *          Gray plot area, white text
     *
     * @type    {Highcharts.CSSObject}
     * @default {"position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center"}
     * @since   1.2.0
     */
    style: {
      /**
       * @ignore
       */
      position: "absolute",
      /**
       * @ignore
       */
      backgroundColor: Palette_default.backgroundColor,
      /**
       * @ignore
       */
      opacity: 0.5,
      /**
       * @ignore
       */
      textAlign: "center"
    }
  },
  /**
   * Options for the tooltip that appears when the user hovers over a
   * series or point.
   *
   * @declare Highcharts.TooltipOptions
   */
  tooltip: {
    /**
     * The color of the tooltip border. When `undefined`, the border takes
     * the color of the corresponding series or point.
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         Follow series by default
     * @sample {highcharts} highcharts/tooltip/bordercolor-black/
     *         Black border
     * @sample {highstock} stock/tooltip/general/
     *         Styled tooltip
     * @sample {highmaps} maps/tooltip/background-border/
     *         Background and border demo
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption tooltip.borderColor
     */
    /**
     * A CSS class name to apply to the tooltip's container div,
     * allowing unique CSS styling for each chart.
     *
     * @type      {string}
     * @apioption tooltip.className
     */
    /**
     * Since 4.1, the crosshair definitions are moved to the Axis object
     * in order for a better separation from the tooltip. See
     * [xAxis.crosshair](#xAxis.crosshair).
     *
     * @sample {highcharts} highcharts/tooltip/crosshairs-x/
     *         Enable a crosshair for the x value
     *
     * @deprecated
     *
     * @type      {*}
     * @default   true
     * @apioption tooltip.crosshairs
     */
    /**
     * Distance from point to tooltip in pixels.
     *
     * @type      {number}
     * @default   16
     * @apioption tooltip.distance
     */
    /**
     * Whether the tooltip should follow the mouse as it moves across
     * columns, pie slices and other point types with an extent.
     * By default it behaves this way for pie, polygon, map, sankey
     * and wordcloud series by override in the `plotOptions`
     * for those series types.
     *
     * Does not apply if [split](#tooltip.split) is `true`.
     *
     * For touch moves to behave the same way, [followTouchMove](
     * #tooltip.followTouchMove) must be `true` also.
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} false
     * @default   {highmaps} true
     * @since     3.0
     * @apioption tooltip.followPointer
     */
    /**
     * Whether the tooltip should update as the finger moves on a touch
     * device. If this is `true` and [chart.panning](#chart.panning) is
     * set,`followTouchMove` will take over one-finger touches, so the user
     * needs to use two fingers for zooming and panning.
     *
     * Note the difference to [followPointer](#tooltip.followPointer) that
     * only defines the _position_ of the tooltip. If `followPointer` is
     * false in for example a column series, the tooltip will show above or
     * below the column, but as `followTouchMove` is true, the tooltip will
     * jump from column to column as the user swipes across the plot area.
     *
     * @type      {boolean}
     * @default   {highcharts} true
     * @default   {highstock} true
     * @default   {highmaps} false
     * @since     3.0.1
     * @apioption tooltip.followTouchMove
     */
    /**
     * Callback function to format the text of the tooltip from scratch. In
     * case of single or [shared](#tooltip.shared) tooltips, a string should
     * be returned. In case of [split](#tooltip.split) tooltips, it should
     * return an array where the first item is the header, and subsequent
     * items are mapped to the points. Return `false` to disable tooltip for
     * a specific point on series.
     *
     * A subset of HTML is supported. Unless `useHTML` is true, the HTML of
     * the tooltip is parsed and converted to SVG, therefore this isn't a
     * complete HTML renderer. The following HTML tags are supported: `b`,
     * `br`, `em`, `i`, `span`, `strong`. Spans can be styled with a `style`
     * attribute, but only text-related CSS, that is shared with SVG, is
     * handled.
     *
     * The available data in the formatter differ a bit depending on whether
     * the tooltip is shared or split, or belongs to a single point. In a
     * shared/split tooltip, all properties except `x`, which is common for
     * all points, are kept in an array, `this.points`.
     *
     * Available data are:
     *
     * - **this.percentage (not shared) /**
     *   **this.points[i].percentage (shared)**:
     *   Stacked series and pies only. The point's percentage of the total.
     *
     * - **this.point (not shared) / this.points[i].point (shared)**:
     *   The point object. The point name, if defined, is available through
     *   `this.point.name`.
     *
     * - **this.points**:
     *   In a shared tooltip, this is an array containing all other
     *   properties for each point.
     *
     * - **this.series (not shared) / this.points[i].series (shared)**:
     *   The series object. The series name is available through
     *   `this.series.name`.
     *
     * - **this.total (not shared) / this.points[i].total (shared)**:
     *   Stacked series only. The total value at this point's x value.
     *
     * - **this.x**:
     *   The x value. This property is the same regardless of the tooltip
     *   being shared or not.
     *
     * - **this.y (not shared) / this.points[i].y (shared)**:
     *   The y value.
     *
     * @sample {highcharts} highcharts/tooltip/formatter-simple/
     *         Simple string formatting
     * @sample {highcharts} highcharts/tooltip/formatter-shared/
     *         Formatting with shared tooltip
     * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
     *         Formatting with split tooltip
     * @sample highcharts/tooltip/formatter-conditional-default/
     *         Extending default formatter
     * @sample {highstock} stock/tooltip/formatter/
     *         Formatting with shared tooltip
     * @sample {highmaps} maps/tooltip/formatter/
     *         String formatting
     *
     * @type      {Highcharts.TooltipFormatterCallbackFunction}
     * @apioption tooltip.formatter
     */
    /**
     * Callback function to format the text of the tooltip for
     * visible null points.
     * Works analogously to [formatter](#tooltip.formatter).
     *
     * @sample highcharts/plotoptions/series-nullformat
     *         Format data label and tooltip for null point.
     *
     * @type      {Highcharts.TooltipFormatterCallbackFunction}
     * @apioption tooltip.nullFormatter
     */
    /**
     * Whether to allow the tooltip to render outside the chart's SVG
     * element box. By default (`false`), the tooltip is rendered within the
     * chart's SVG element, which results in the tooltip being aligned
     * inside the chart area. For small charts, this may result in clipping
     * or overlapping. When `true`, a separate SVG element is created and
     * overlaid on the page, allowing the tooltip to be aligned inside the
     * page itself.
     *
     * Defaults to `true` if `chart.scrollablePlotArea` is activated,
     * otherwise `false`.
     *
     * @sample highcharts/tooltip/outside
     *         Small charts with tooltips outside
     *
     * @type      {boolean|undefined}
     * @default   undefined
     * @since     6.1.1
     * @apioption tooltip.outside
     */
    /**
     * A callback function for formatting the HTML output for a single point
     * in the tooltip. Like the `pointFormat` string, but with more
     * flexibility.
     *
     * @type      {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
     * @since     4.1.0
     * @context   Highcharts.Point
     * @apioption tooltip.pointFormatter
     */
    /**
     * A callback function to place the tooltip in a default position. The
     * callback receives three parameters: `labelWidth`, `labelHeight` and
     * `point`, where point contains values for `plotX` and `plotY` telling
     * where the reference point is in the plot area. Add `chart.plotLeft`
     * and `chart.plotTop` to get the full coordinates.
     *
     * Since v7, when [tooltip.split](#tooltip.split) option is enabled,
     * positioner is called for each of the boxes separately, including
     * xAxis header. xAxis header is not a point, instead `point` argument
     * contains info:
     * `{ plotX: Number, plotY: Number, isHeader: Boolean }`
     *
     *
     * The return should be an object containing x and y values, for example
     * `{ x: 100, y: 100 }`.
     *
     * @sample {highcharts} highcharts/tooltip/positioner/
     *         A fixed tooltip position
     * @sample {highstock} stock/tooltip/positioner/
     *         A fixed tooltip position on top of the chart
     * @sample {highmaps} maps/tooltip/positioner/
     *         A fixed tooltip position
     * @sample {highstock} stock/tooltip/split-positioner/
     *         Split tooltip with fixed positions
     * @sample {highstock} stock/tooltip/positioner-scrollable-plotarea/
     *         Scrollable plot area combined with tooltip positioner
     *
     * @type      {Highcharts.TooltipPositionerCallbackFunction}
     * @since     2.2.4
     * @apioption tooltip.positioner
     */
    /**
     * Split the tooltip into one label per series, with the header close
     * to the axis. This is recommended over [shared](#tooltip.shared)
     * tooltips for charts with multiple line series, generally making them
     * easier to read. This option takes precedence over `tooltip.shared`.
     *
     * @productdesc {highstock} In Highcharts Stock, tooltips are split
     * by default since v6.0.0. Stock charts typically contain
     * multi-dimension points and multiple panes, making split tooltips
     * the preferred layout over
     * the previous `shared` tooltip.
     *
     * @sample highcharts/tooltip/split/
     *         Split tooltip
     * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
     *         Split tooltip and custom formatter callback
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} true
     * @since     5.0.0
     * @product   highcharts highstock
     * @apioption tooltip.split
     */
    /**
     * Prevents the tooltip from switching or closing, when touched or
     * pointed.
     *
     * @sample highcharts/tooltip/stickoncontact/
     *         Tooltip sticks on pointer contact
     *
     * @type      {boolean}
     * @since     8.0.1
     * @apioption tooltip.stickOnContact
     */
    /**
     * Use HTML to render the contents of the tooltip instead of SVG. Using
     * HTML allows advanced formatting like tables and images in the
     * tooltip. It is also recommended for rtl languages as it works around
     * rtl bugs in early Firefox.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
     *         A table for value alignment
     * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
     *         Full HTML tooltip
     * @sample {highmaps} maps/tooltip/usehtml/
     *         Pure HTML tooltip
     *
     * @type      {boolean}
     * @default   false
     * @since     2.2
     * @apioption tooltip.useHTML
     */
    /**
     * How many decimals to show in each series' y value. This is
     * overridable in each series' tooltip options object. The default is to
     * preserve all decimals.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     * @sample {highmaps} maps/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     *
     * @type      {number|undefined}
     * @since     2.2
     * @apioption tooltip.valueDecimals
     */
    /**
     * A string to prepend to each series' y value. Overridable in each
     * series' tooltip options object.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     * @sample {highmaps} maps/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     *
     * @type      {string}
     * @since     2.2
     * @apioption tooltip.valuePrefix
     */
    /**
     * A string to append to each series' y value. Overridable in each
     * series' tooltip options object.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     * @sample {highmaps} maps/tooltip/valuedecimals/
     *         Set decimals, prefix and suffix for the value
     *
     * @type      {string}
     * @since     2.2
     * @apioption tooltip.valueSuffix
     */
    /**
     * The format for the date in the tooltip header if the X axis is a
     * datetime axis. The default is a best guess based on the smallest
     * distance between points in the chart.
     *
     * @sample {highcharts} highcharts/tooltip/xdateformat/
     *         A different format
     *
     * @type      {string}
     * @product   highcharts highstock gantt
     * @apioption tooltip.xDateFormat
     */
    /**
     * How many decimals to show for the `point.change` value when the
     * `series.compare` option is set. This is overridable in each series'
     * tooltip options object. The default is to preserve all decimals.
     *
     * @type      {number}
     * @since     1.0.1
     * @product   highstock
     * @apioption tooltip.changeDecimals
     */
    /**
     * Enable or disable the tooltip.
     *
     * @sample {highcharts} highcharts/tooltip/enabled/
     *         Disabled
     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
     *         Disable tooltip and show values on chart instead
     */
    enabled: true,
    /**
     * Enable or disable animation of the tooltip.
     *
     * @type       {boolean}
     * @default    true
     * @since      2.3.0
     */
    animation: svg,
    /**
     * The radius of the rounded border corners.
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         5px by default
     * @sample {highcharts} highcharts/tooltip/borderradius-0/
     *         Square borders
     * @sample {highmaps} maps/tooltip/background-border/
     *         Background and border demo
     */
    borderRadius: 3,
    /**
     * For series on datetime axes, the date format in the tooltip's
     * header will by default be guessed based on the closest data points.
     * This member gives the default string representations used for
     * each unit. For an overview of the replacement codes, see
     * [dateFormat](/class-reference/Highcharts#.dateFormat).
     *
     * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
     *
     * @type    {Highcharts.Dictionary<string>}
     * @product highcharts highstock gantt
     */
    dateTimeLabelFormats: {
      /** @internal */
      millisecond: "%A, %b %e, %H:%M:%S.%L",
      /** @internal */
      second: "%A, %b %e, %H:%M:%S",
      /** @internal */
      minute: "%A, %b %e, %H:%M",
      /** @internal */
      hour: "%A, %b %e, %H:%M",
      /** @internal */
      day: "%A, %b %e, %Y",
      /** @internal */
      week: "Week from %A, %b %e, %Y",
      /** @internal */
      month: "%B %Y",
      /** @internal */
      year: "%Y"
    },
    /**
     * A string to append to the tooltip format.
     *
     * @sample {highcharts} highcharts/tooltip/footerformat/
     *         A table for value alignment
     * @sample {highmaps} maps/tooltip/format/
     *         Format demo
     *
     * @since 2.2
     */
    footerFormat: "",
    /**
     * The name of a symbol to use for the border around the tooltip
     * header. Applies only when [tooltip.split](#tooltip.split) is
     * enabled.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
     * [series.marker.symbol](plotOptions.line.marker.symbol).
     *
     * @see [tooltip.shape](#tooltip.shape)
     *
     * @sample {highstock} stock/tooltip/split-positioner/
     *         Different shapes for header and split boxes
     *
     * @type       {Highcharts.TooltipShapeValue}
     * @validvalue ["callout", "square"]
     * @since      7.0
     */
    headerShape: "callout",
    /**
     * The number of milliseconds to wait until the tooltip is hidden when
     * mouse out from a point or chart.
     *
     * @since     3.0
     */
    hideDelay: 500,
    /**
     * Padding inside the tooltip, in pixels.
     *
     * @since      5.0.0
     */
    padding: 8,
    /**
     * The name of a symbol to use for the border around the tooltip. Can
     * be one of: `"callout"`, `"circle"` or `"rect"`. When
     * [tooltip.split](#tooltip.split)
     * option is enabled, shape is applied to all boxes except header, which
     * is controlled by
     * [tooltip.headerShape](#tooltip.headerShape).
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
     * [series.marker.symbol](plotOptions.line.marker.symbol).
     *
     * @type      {Highcharts.TooltipShapeValue}
     * @since     4.0
     */
    shape: "callout",
    /**
     * When the tooltip is shared, the entire plot area will capture mouse
     * movement or touch events. Tooltip texts for series types with ordered
     * data (not pie, scatter, flags etc) will be shown in a single bubble.
     * This is recommended for single series charts and for tablet/mobile
     * optimized charts.
     *
     * See also [tooltip.split](#tooltip.split), that is better suited for
     * charts with many series, especially line-type series. The
     * `tooltip.split` option takes precedence over `tooltip.shared`.
     *
     * @sample {highcharts} highcharts/tooltip/shared-false/
     *         False by default
     * @sample {highcharts} highcharts/tooltip/shared-true/
     *         True
     * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/
     *         True with x axis crosshair
     * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/
     *         True with mixed series types
     *
     * @since     2.1
     * @product   highcharts highstock
     */
    shared: false,
    /**
     * Proximity snap for graphs or single points. It defaults to 10 for
     * mouse-powered devices and 25 for touch devices.
     *
     * Note that in most cases the whole plot area captures the mouse
     * movement, and in these cases `tooltip.snap` doesn't make sense. This
     * applies when [stickyTracking](#plotOptions.series.stickyTracking)
     * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
     * or [split](#tooltip.split).
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         10 px by default
     * @sample {highcharts} highcharts/tooltip/snap-50/
     *         50 px on graph
     *
     * @type    {number}
     * @default 10/25
     * @since   1.2.0
     * @product highcharts highstock
     */
    snap: isTouchDevice ? 25 : 10,
    /**
     * The HTML of the tooltip header line. Variables are enclosed by
     * curly brackets. Available variables are `point.key`, `series.name`,
     * `series.color` and other members from the `point` and `series`
     * objects. The `point.key` variable contains the category name, x
     * value or datetime string depending on the type of axis. For datetime
     * axes, the `point.key` date format can be set using
     * `tooltip.xDateFormat`.
     *
     * @sample {highcharts} highcharts/tooltip/footerformat/
     *         An HTML table in the tooltip
     * @sample {highstock} highcharts/tooltip/footerformat/
     *         An HTML table in the tooltip
     * @sample {highmaps} maps/tooltip/format/
     *         Format demo
     *
     * @type       {string}
     * @apioption  tooltip.headerFormat
     */
    headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
    /**
     * The HTML of the null point's line in the tooltip. Works analogously
     * to [pointFormat](#tooltip.pointFormat).
     *
     * @sample {highcharts} highcharts/plotoptions/series-nullformat
     *         Format data label and tooltip for null point.
     *
     * @type      {string}
     * @apioption tooltip.nullFormat
     */
    /**
     * The HTML of the point's line in the tooltip. Variables are enclosed
     * by curly brackets. Available variables are `point.x`, `point.y`,
     * `series.name` and `series.color` and other properties on the same
     * form. Furthermore, `point.y` can be extended by the
     * `tooltip.valuePrefix` and `tooltip.valueSuffix` variables. This can
     * also be overridden for each series, which makes it a good hook for
     * displaying units.
     *
     * In styled mode, the dot is colored by a class name rather
     * than the point color.
     *
     * @sample {highcharts} highcharts/tooltip/pointformat/
     *         A different point format with value suffix
     * @sample {highmaps} maps/tooltip/format/
     *         Format demo
     *
     * @type       {string}
     * @since      2.2
     * @apioption  tooltip.pointFormat
     */
    pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.y}</b><br/>',
    /**
     * The background color or gradient for the tooltip.
     *
     * In styled mode, the stroke width is set in the
     * `.highcharts-tooltip-box` class.
     *
     * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/
     *         Yellowish background
     * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/
     *         Gradient
     * @sample {highcharts} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     * @sample {highstock} stock/tooltip/general/
     *         Custom tooltip
     * @sample {highstock} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     * @sample {highmaps} maps/tooltip/background-border/
     *         Background and border demo
     * @sample {highmaps} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    backgroundColor: color(Palette_default.neutralColor3).setOpacity(0.85).get(),
    /**
     * The pixel width of the tooltip border.
     *
     * In styled mode, the stroke width is set in the
     * `.highcharts-tooltip-box` class.
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         2px by default
     * @sample {highcharts} highcharts/tooltip/borderwidth/
     *         No border (shadow only)
     * @sample {highcharts} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     * @sample {highstock} stock/tooltip/general/
     *         Custom tooltip
     * @sample {highstock} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     * @sample {highmaps} maps/tooltip/background-border/
     *         Background and border demo
     * @sample {highmaps} highcharts/css/tooltip-border-background/
     *         Tooltip in styled mode
     */
    borderWidth: 1,
    /**
     * Whether to apply a drop shadow to the tooltip.
     *
     * @sample {highcharts} highcharts/tooltip/bordercolor-default/
     *         True by default
     * @sample {highcharts} highcharts/tooltip/shadow/
     *         False
     * @sample {highmaps} maps/tooltip/positioner/
     *         Fixed tooltip position, border and shadow disabled
     *
     * @type {boolean|Highcharts.ShadowOptionsObject}
     */
    shadow: true,
    /**
     * Prevents the tooltip from switching or closing when touched or
     * pointed.
     *
     * @sample highcharts/tooltip/stickoncontact/
     *         Tooltip sticks on pointer contact
     *
     * @since     8.0.1
     */
    stickOnContact: false,
    /**
     * CSS styles for the tooltip. The tooltip can also be styled through
     * the CSS class `.highcharts-tooltip`.
     *
     * Note that the default `pointerEvents` style makes the tooltip ignore
     * mouse events, so in order to use clickable tooltips, this value must
     * be set to `auto`.
     *
     * @sample {highcharts} highcharts/tooltip/style/
     *         Greater padding, bold text
     *
     * @type {Highcharts.CSSObject}
     */
    style: {
      /** @internal */
      color: Palette_default.neutralColor80,
      /** @internal */
      cursor: "default",
      /** @internal */
      fontSize: "12px",
      /** @internal */
      whiteSpace: "nowrap"
    },
    /**
     * Use HTML to render the contents of the tooltip instead of SVG. Using
     * HTML allows advanced formatting like tables and images in the
     * tooltip. It is also recommended for rtl languages as it works around
     * rtl bugs in early Firefox.
     *
     * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
     *         A table for value alignment
     * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
     *         Full HTML tooltip
     * @sample {highmaps} maps/tooltip/usehtml/
     *         Pure HTML tooltip
     *
     * @since     2.2
     */
    useHTML: false
  },
  /**
   * Highchart by default puts a credits label in the lower right corner
   * of the chart. This can be changed using these options.
   */
  credits: {
    /**
     * Credits for map source to be concatenated with conventional credit
     * text. By default this is a format string that collects copyright
     * information from the map if available.
     *
     * @see [mapTextFull](#credits.mapTextFull)
     * @see [text](#credits.text)
     *
     * @type      {string}
     * @default   \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>
     * @since     4.2.2
     * @product   highmaps
     * @apioption credits.mapText
     */
    /**
     * Detailed credits for map source to be displayed on hover of credits
     * text. By default this is a format string that collects copyright
     * information from the map if available.
     *
     * @see [mapText](#credits.mapText)
     * @see [text](#credits.text)
     *
     * @type      {string}
     * @default   {geojson.copyright}
     * @since     4.2.2
     * @product   highmaps
     * @apioption credits.mapTextFull
     */
    /**
     * Whether to show the credits text.
     *
     * @sample {highcharts} highcharts/credits/enabled-false/
     *         Credits disabled
     * @sample {highstock} stock/credits/enabled/
     *         Credits disabled
     * @sample {highmaps} maps/credits/enabled-false/
     *         Credits disabled
     */
    enabled: true,
    /**
     * The URL for the credits label.
     *
     * @sample {highcharts} highcharts/credits/href/
     *         Custom URL and text
     * @sample {highmaps} maps/credits/customized/
     *         Custom URL and text
     */
    href: "https://www.highcharts.com?credits",
    /**
     * Position configuration for the credits label.
     *
     * @sample {highcharts} highcharts/credits/position-left/
     *         Left aligned
     * @sample {highcharts} highcharts/credits/position-left/
     *         Left aligned
     * @sample {highmaps} maps/credits/customized/
     *         Left aligned
     * @sample {highmaps} maps/credits/customized/
     *         Left aligned
     *
     * @type    {Highcharts.AlignObject}
     * @since   2.1
     */
    position: {
      /** @internal */
      align: "right",
      /** @internal */
      x: -10,
      /** @internal */
      verticalAlign: "bottom",
      /** @internal */
      y: -5
    },
    /**
     * CSS styles for the credits label.
     *
     * @see In styled mode, credits styles can be set with the
     *      `.highcharts-credits` class.
     *
     * @type {Highcharts.CSSObject}
     */
    style: {
      /** @internal */
      cursor: "pointer",
      /** @internal */
      color: Palette_default.neutralColor40,
      /** @internal */
      fontSize: "9px"
    },
    /**
     * The text for the credits label.
     *
     * @productdesc {highmaps}
     * If a map is loaded as GeoJSON, the text defaults to
     * `Highcharts @ {map-credits}`. Otherwise, it defaults to
     * `Highcharts.com`.
     *
     * @sample {highcharts} highcharts/credits/href/
     *         Custom URL and text
     * @sample {highmaps} maps/credits/customized/
     *         Custom URL and text
     */
    text: "Highcharts.com"
  }
};
defaultOptions.chart.styledMode = false;
var defaultTime = new Time_default(merge4(defaultOptions.global, defaultOptions.time));
function getOptions() {
  return defaultOptions;
}
function setOptions(options) {
  merge4(true, defaultOptions, options);
  if (options.time || options.global) {
    if (Globals_default.time) {
      Globals_default.time.update(merge4(defaultOptions.global, defaultOptions.time, options.global, options.time));
    } else {
      Globals_default.time = defaultTime;
    }
  }
  return defaultOptions;
}
var DefaultOptions = {
  defaultOptions,
  defaultTime,
  getOptions,
  setOptions
};
var DefaultOptions_default = DefaultOptions;

// node_modules/highcharts/es-modules/Core/Animation/Fx.js
var color2 = Color_default.parse;
var win4 = Globals_default.win;
var isNumber3 = Utilities_default.isNumber;
var objectEach3 = Utilities_default.objectEach;
var Fx = (
  /** @class */
  function() {
    function Fx2(elem, options, prop) {
      this.pos = NaN;
      this.options = options;
      this.elem = elem;
      this.prop = prop;
    }
    Fx2.prototype.dSetter = function() {
      var paths = this.paths, start = paths && paths[0], end = paths && paths[1], now = this.now || 0;
      var path = [];
      if (now === 1 || !start || !end) {
        path = this.toD || [];
      } else if (start.length === end.length && now < 1) {
        for (var i = 0; i < end.length; i++) {
          var startSeg = start[i];
          var endSeg = end[i];
          var tweenSeg = [];
          for (var j = 0; j < endSeg.length; j++) {
            var startItem = startSeg[j];
            var endItem = endSeg[j];
            if (isNumber3(startItem) && isNumber3(endItem) && // Arc boolean flags
            !(endSeg[0] === "A" && (j === 4 || j === 5))) {
              tweenSeg[j] = startItem + now * (endItem - startItem);
            } else {
              tweenSeg[j] = endItem;
            }
          }
          path.push(tweenSeg);
        }
      } else {
        path = end;
      }
      this.elem.attr("d", path, void 0, true);
    };
    Fx2.prototype.update = function() {
      var elem = this.elem, prop = this.prop, now = this.now, step = this.options.step;
      if (this[prop + "Setter"]) {
        this[prop + "Setter"]();
      } else if (elem.attr) {
        if (elem.element) {
          elem.attr(prop, now, null, true);
        }
      } else {
        elem.style[prop] = now + this.unit;
      }
      if (step) {
        step.call(elem, now, this);
      }
    };
    Fx2.prototype.run = function(from, to, unit) {
      var self = this, options = self.options, timer = function(gotoEnd) {
        return timer.stopped ? false : self.step(gotoEnd);
      }, requestAnimationFrame = win4.requestAnimationFrame || function(step2) {
        setTimeout(step2, 13);
      }, step = function() {
        for (var i = 0; i < Fx2.timers.length; i++) {
          if (!Fx2.timers[i]()) {
            Fx2.timers.splice(i--, 1);
          }
        }
        if (Fx2.timers.length) {
          requestAnimationFrame(step);
        }
      };
      if (from === to && !this.elem["forceAnimate:" + this.prop]) {
        delete options.curAnim[this.prop];
        if (options.complete && Object.keys(options.curAnim).length === 0) {
          options.complete.call(this.elem);
        }
      } else {
        this.startTime = +/* @__PURE__ */ new Date();
        this.start = from;
        this.end = to;
        this.unit = unit;
        this.now = this.start;
        this.pos = 0;
        timer.elem = this.elem;
        timer.prop = this.prop;
        if (timer() && Fx2.timers.push(timer) === 1) {
          requestAnimationFrame(step);
        }
      }
    };
    Fx2.prototype.step = function(gotoEnd) {
      var t = +/* @__PURE__ */ new Date(), options = this.options, elem = this.elem, complete = options.complete, duration = options.duration, curAnim = options.curAnim;
      var ret, done;
      if (elem.attr && !elem.element) {
        ret = false;
      } else if (gotoEnd || t >= duration + this.startTime) {
        this.now = this.end;
        this.pos = 1;
        this.update();
        curAnim[this.prop] = true;
        done = true;
        objectEach3(curAnim, function(val) {
          if (val !== true) {
            done = false;
          }
        });
        if (done && complete) {
          complete.call(elem);
        }
        ret = false;
      } else {
        this.pos = options.easing((t - this.startTime) / duration);
        this.now = this.start + (this.end - this.start) * this.pos;
        this.update();
        ret = true;
      }
      return ret;
    };
    Fx2.prototype.initPath = function(elem, fromD, toD) {
      var startX = elem.startX, endX = elem.endX, end = toD.slice(), isArea = elem.isArea, positionFactor = isArea ? 2 : 1;
      var shift, fullLength, i, reverse, start = fromD && fromD.slice();
      if (!start) {
        return [end, end];
      }
      function prepend(arr, other) {
        while (arr.length < fullLength) {
          var moveSegment = arr[0], otherSegment = other[fullLength - arr.length];
          if (otherSegment && moveSegment[0] === "M") {
            if (otherSegment[0] === "C") {
              arr[0] = [
                "C",
                moveSegment[1],
                moveSegment[2],
                moveSegment[1],
                moveSegment[2],
                moveSegment[1],
                moveSegment[2]
              ];
            } else {
              arr[0] = ["L", moveSegment[1], moveSegment[2]];
            }
          }
          arr.unshift(moveSegment);
          if (isArea) {
            var z = arr.pop();
            arr.push(arr[arr.length - 1], z);
          }
        }
      }
      function append(arr, other) {
        while (arr.length < fullLength) {
          var segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
          if (segmentToAdd[0] === "C") {
            segmentToAdd[1] = segmentToAdd[5];
            segmentToAdd[2] = segmentToAdd[6];
          }
          if (!isArea) {
            arr.push(segmentToAdd);
          } else {
            var lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
            arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);
          }
        }
      }
      if (startX && endX && endX.length) {
        for (i = 0; i < startX.length; i++) {
          if (startX[i] === endX[0]) {
            shift = i;
            break;
          } else if (startX[0] === endX[endX.length - startX.length + i]) {
            shift = i;
            reverse = true;
            break;
          } else if (startX[startX.length - 1] === endX[endX.length - startX.length + i]) {
            shift = startX.length - i;
            break;
          }
        }
        if (typeof shift === "undefined") {
          start = [];
        }
      }
      if (start.length && isNumber3(shift)) {
        fullLength = end.length + shift * positionFactor;
        if (!reverse) {
          prepend(end, start);
          append(start, end);
        } else {
          prepend(start, end);
          append(end, start);
        }
      }
      return [start, end];
    };
    Fx2.prototype.fillSetter = function() {
      Fx2.prototype.strokeSetter.apply(this, arguments);
    };
    Fx2.prototype.strokeSetter = function() {
      this.elem.attr(this.prop, color2(this.start).tweenTo(color2(this.end), this.pos), null, true);
    };
    Fx2.timers = [];
    return Fx2;
  }()
);
var Fx_default = Fx;

// node_modules/highcharts/es-modules/Core/Animation/AnimationUtilities.js
var defined3 = Utilities_default.defined;
var getStyle2 = Utilities_default.getStyle;
var isArray2 = Utilities_default.isArray;
var isNumber4 = Utilities_default.isNumber;
var isObject3 = Utilities_default.isObject;
var merge5 = Utilities_default.merge;
var objectEach4 = Utilities_default.objectEach;
var pick3 = Utilities_default.pick;
function setAnimation(animation, chart) {
  chart.renderer.globalAnimation = pick3(animation, chart.options.chart.animation, true);
}
function animObject(animation) {
  return isObject3(animation) ? merge5({ duration: 500, defer: 0 }, animation) : { duration: animation ? 500 : 0, defer: 0 };
}
function getDeferredAnimation(chart, animation, series) {
  var labelAnimation = animObject(animation), s = series ? [series] : chart.series;
  var defer = 0, duration = 0;
  s.forEach(function(series2) {
    var seriesAnim = animObject(series2.options.animation);
    defer = animation && defined3(animation.defer) ? labelAnimation.defer : Math.max(defer, seriesAnim.duration + seriesAnim.defer);
    duration = Math.min(labelAnimation.duration, seriesAnim.duration);
  });
  if (chart.renderer.forExport) {
    defer = 0;
  }
  var anim = {
    defer: Math.max(0, defer - duration),
    duration: Math.min(defer, duration)
  };
  return anim;
}
function animate(el, params, opt) {
  var start, unit = "", end, fx, args;
  if (!isObject3(opt)) {
    args = arguments;
    opt = {
      duration: args[2],
      easing: args[3],
      complete: args[4]
    };
  }
  if (!isNumber4(opt.duration)) {
    opt.duration = 400;
  }
  opt.easing = typeof opt.easing === "function" ? opt.easing : Math[opt.easing] || Math.easeInOutSine;
  opt.curAnim = merge5(params);
  objectEach4(params, function(val, prop) {
    stop(el, prop);
    fx = new Fx_default(el, opt, prop);
    end = void 0;
    if (prop === "d" && isArray2(params.d)) {
      fx.paths = fx.initPath(el, el.pathArray, params.d);
      fx.toD = params.d;
      start = 0;
      end = 1;
    } else if (el.attr) {
      start = el.attr(prop);
    } else {
      start = parseFloat(getStyle2(el, prop)) || 0;
      if (prop !== "opacity") {
        unit = "px";
      }
    }
    if (!end) {
      end = val;
    }
    if (typeof end === "string" && end.match("px")) {
      end = end.replace(/px/g, "");
    }
    fx.run(start, end, unit);
  });
}
function stop(el, prop) {
  var i = Fx_default.timers.length;
  while (i--) {
    if (Fx_default.timers[i].elem === el && (!prop || prop === Fx_default.timers[i].prop)) {
      Fx_default.timers[i].stopped = true;
    }
  }
}
var animationExports = {
  animate,
  animObject,
  getDeferredAnimation,
  setAnimation,
  stop
};
var AnimationUtilities_default = animationExports;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/AST.js
var SVG_NS = Globals_default.SVG_NS;
var attr3 = Utilities_default.attr;
var createElement2 = Utilities_default.createElement;
var discardElement2 = Utilities_default.discardElement;
var error3 = Utilities_default.error;
var isString2 = Utilities_default.isString;
var objectEach5 = Utilities_default.objectEach;
var splat3 = Utilities_default.splat;
var hasValidDOMParser = function() {
  try {
    return Boolean(new DOMParser().parseFromString("", "text/html"));
  } catch (e2) {
    return false;
  }
}();
var AST = (
  /** @class */
  function() {
    function AST2(source) {
      this.nodes = typeof source === "string" ? this.parseMarkup(source) : source;
    }
    AST2.filterUserAttributes = function(attributes) {
      objectEach5(attributes, function(val, key) {
        var valid = true;
        if (AST2.allowedAttributes.indexOf(key) === -1) {
          valid = false;
        }
        if (["background", "dynsrc", "href", "lowsrc", "src"].indexOf(key) !== -1) {
          valid = isString2(val) && AST2.allowedReferences.some(function(ref) {
            return val.indexOf(ref) === 0;
          });
        }
        if (!valid) {
          error3("Highcharts warning: Invalid attribute '" + key + "' in config");
          delete attributes[key];
        }
      });
      return attributes;
    };
    AST2.setElementHTML = function(el, html2) {
      el.innerHTML = "";
      if (html2) {
        var ast = new AST2(html2);
        ast.addToDOM(el);
      }
    };
    AST2.prototype.addToDOM = function(parent) {
      function recurse(subtree, subParent) {
        var ret;
        splat3(subtree).forEach(function(item) {
          var tagName = item.tagName;
          var textNode = item.textContent ? Globals_default.doc.createTextNode(item.textContent) : void 0;
          var node;
          if (tagName) {
            if (tagName === "#text") {
              node = textNode;
            } else if (AST2.allowedTags.indexOf(tagName) !== -1) {
              var NS = tagName === "svg" ? SVG_NS : subParent.namespaceURI || SVG_NS;
              var element = Globals_default.doc.createElementNS(NS, tagName);
              var attributes_1 = item.attributes || {};
              objectEach5(item, function(val, key) {
                if (key !== "tagName" && key !== "attributes" && key !== "children" && key !== "textContent") {
                  attributes_1[key] = val;
                }
              });
              attr3(element, AST2.filterUserAttributes(attributes_1));
              if (textNode) {
                element.appendChild(textNode);
              }
              recurse(item.children || [], element);
              node = element;
            } else {
              error3("Highcharts warning: Invalid tagName '" + tagName + "' in config");
            }
          }
          if (node) {
            subParent.appendChild(node);
          }
          ret = node;
        });
        return ret;
      }
      return recurse(this.nodes, parent);
    };
    AST2.prototype.parseMarkup = function(markup) {
      var nodes = [];
      markup = markup.trim();
      var doc25;
      var body;
      if (hasValidDOMParser) {
        doc25 = new DOMParser().parseFromString(markup, "text/html");
      } else {
        body = createElement2("div");
        body.innerHTML = markup;
        doc25 = { body };
      }
      var appendChildNodes = function(node, addTo) {
        var tagName = node.nodeName.toLowerCase();
        var astNode = {
          tagName
        };
        if (tagName === "#text") {
          astNode.textContent = node.textContent || "";
        }
        var parsedAttributes = node.attributes;
        if (parsedAttributes) {
          var attributes_2 = {};
          [].forEach.call(parsedAttributes, function(attrib) {
            attributes_2[attrib.name] = attrib.value;
          });
          astNode.attributes = attributes_2;
        }
        if (node.childNodes.length) {
          var children_1 = [];
          [].forEach.call(node.childNodes, function(childNode) {
            appendChildNodes(childNode, children_1);
          });
          if (children_1.length) {
            astNode.children = children_1;
          }
        }
        addTo.push(astNode);
      };
      [].forEach.call(doc25.body.childNodes, function(childNode) {
        return appendChildNodes(childNode, nodes);
      });
      if (body) {
        discardElement2(body);
      }
      return nodes;
    };
    AST2.allowedAttributes = [
      "aria-controls",
      "aria-describedby",
      "aria-expanded",
      "aria-haspopup",
      "aria-hidden",
      "aria-label",
      "aria-labelledby",
      "aria-live",
      "aria-pressed",
      "aria-readonly",
      "aria-roledescription",
      "aria-selected",
      "class",
      "clip-path",
      "color",
      "colspan",
      "cx",
      "cy",
      "d",
      "dx",
      "dy",
      "disabled",
      "fill",
      "height",
      "href",
      "id",
      "in",
      "markerHeight",
      "markerWidth",
      "offset",
      "opacity",
      "orient",
      "padding",
      "paddingLeft",
      "paddingRight",
      "patternUnits",
      "r",
      "refX",
      "refY",
      "role",
      "scope",
      "slope",
      "src",
      "startOffset",
      "stdDeviation",
      "stroke",
      "stroke-linecap",
      "stroke-width",
      "style",
      "tableValues",
      "result",
      "rowspan",
      "summary",
      "target",
      "tabindex",
      "text-align",
      "textAnchor",
      "textLength",
      "type",
      "valign",
      "width",
      "x",
      "x1",
      "x2",
      "y",
      "y1",
      "y2",
      "zIndex"
    ];
    AST2.allowedReferences = [
      "https://",
      "http://",
      "mailto:",
      "/",
      "../",
      "./",
      "#"
    ];
    AST2.allowedTags = [
      "a",
      "b",
      "br",
      "button",
      "caption",
      "circle",
      "clipPath",
      "code",
      "dd",
      "defs",
      "div",
      "dl",
      "dt",
      "em",
      "feComponentTransfer",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feOffset",
      "feMerge",
      "feMergeNode",
      "filter",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hr",
      "i",
      "img",
      "li",
      "linearGradient",
      "marker",
      "ol",
      "p",
      "path",
      "pattern",
      "pre",
      "rect",
      "small",
      "span",
      "stop",
      "strong",
      "style",
      "sub",
      "sup",
      "svg",
      "table",
      "text",
      "thead",
      "tbody",
      "tspan",
      "td",
      "th",
      "tr",
      "u",
      "ul",
      "#text"
    ];
    return AST2;
  }()
);
var AST_default = AST;

// node_modules/highcharts/es-modules/Core/FormatUtilities.js
var defaultOptions2 = DefaultOptions_default.defaultOptions;
var defaultTime2 = DefaultOptions_default.defaultTime;
var getNestedProperty2 = Utilities_default.getNestedProperty;
var isNumber5 = Utilities_default.isNumber;
var pick4 = Utilities_default.pick;
var pInt3 = Utilities_default.pInt;
function dateFormat(format15, timestamp, capitalize) {
  return defaultTime2.dateFormat(format15, timestamp, capitalize);
}
function format(str, ctx, chart) {
  var splitter = "{", isInside = false, segment, valueAndFormat, val, index;
  var floatRegex = /f$/;
  var decRegex = /\.([0-9])/;
  var lang2 = defaultOptions2.lang;
  var time = chart && chart.time || defaultTime2;
  var numberFormatter = chart && chart.numberFormatter || numberFormat;
  var ret = [];
  while (str) {
    index = str.indexOf(splitter);
    if (index === -1) {
      break;
    }
    segment = str.slice(0, index);
    if (isInside) {
      valueAndFormat = segment.split(":");
      val = getNestedProperty2(valueAndFormat.shift() || "", ctx);
      if (valueAndFormat.length && typeof val === "number") {
        segment = valueAndFormat.join(":");
        if (floatRegex.test(segment)) {
          var decimals = parseInt((segment.match(decRegex) || ["", "-1"])[1], 10);
          if (val !== null) {
            val = numberFormatter(val, decimals, lang2.decimalPoint, segment.indexOf(",") > -1 ? lang2.thousandsSep : "");
          }
        } else {
          val = time.dateFormat(segment, val);
        }
      }
      ret.push(val);
    } else {
      ret.push(segment);
    }
    str = str.slice(index + 1);
    isInside = !isInside;
    splitter = isInside ? "}" : "{";
  }
  ret.push(str);
  return ret.join("");
}
function numberFormat(number, decimals, decimalPoint, thousandsSep) {
  number = +number || 0;
  decimals = +decimals;
  var ret, fractionDigits;
  var lang2 = defaultOptions2.lang, origDec = (number.toString().split(".")[1] || "").split("e")[0].length, exponent = number.toString().split("e"), firstDecimals = decimals;
  if (decimals === -1) {
    decimals = Math.min(origDec, 20);
  } else if (!isNumber5(decimals)) {
    decimals = 2;
  } else if (decimals && exponent[1] && exponent[1] < 0) {
    fractionDigits = decimals + +exponent[1];
    if (fractionDigits >= 0) {
      exponent[0] = (+exponent[0]).toExponential(fractionDigits).split("e")[0];
      decimals = fractionDigits;
    } else {
      exponent[0] = exponent[0].split(".")[0] || 0;
      if (decimals < 20) {
        number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals);
      } else {
        number = 0;
      }
      exponent[1] = 0;
    }
  }
  var roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals);
  var strinteger = String(pInt3(roundedNumber));
  var thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
  decimalPoint = pick4(decimalPoint, lang2.decimalPoint);
  thousandsSep = pick4(thousandsSep, lang2.thousandsSep);
  ret = number < 0 ? "-" : "";
  ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : "";
  if (+exponent[1] < 0 && !firstDecimals) {
    ret = "0";
  } else {
    ret += strinteger.substr(thousands).replace(/(\d{3})(?=\d)/g, "$1" + thousandsSep);
  }
  if (decimals) {
    ret += decimalPoint + roundedNumber.slice(-decimals);
  }
  if (exponent[1] && +ret !== 0) {
    ret += "e" + exponent[1];
  }
  return ret;
}
var FormatUtilities = {
  dateFormat,
  format,
  numberFormat
};
var FormatUtilities_default = FormatUtilities;

// node_modules/highcharts/es-modules/Core/Renderer/RendererUtilities.js
var clamp2 = Utilities_default.clamp;
var pick5 = Utilities_default.pick;
var stableSort2 = Utilities_default.stableSort;
var RendererUtilities;
(function(RendererUtilities2) {
  function distribute5(boxes, len, maxDistance) {
    var origBoxes = boxes, reducedLen = origBoxes.reducedLen || len, sortByRank = function(a, b) {
      return (b.rank || 0) - (a.rank || 0);
    }, sortByTarget = function(a, b) {
      return a.target - b.target;
    };
    var i, overlapping = true, restBoxes = [], box, target, total = 0;
    i = boxes.length;
    while (i--) {
      total += boxes[i].size;
    }
    if (total > reducedLen) {
      stableSort2(boxes, sortByRank);
      i = 0;
      total = 0;
      while (total <= reducedLen) {
        total += boxes[i].size;
        i++;
      }
      restBoxes = boxes.splice(i - 1, boxes.length);
    }
    stableSort2(boxes, sortByTarget);
    boxes = boxes.map(function(box2) {
      return {
        size: box2.size,
        targets: [box2.target],
        align: pick5(box2.align, 0.5)
      };
    });
    while (overlapping) {
      i = boxes.length;
      while (i--) {
        box = boxes[i];
        target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
        box.pos = clamp2(target - box.size * box.align, 0, len - box.size);
      }
      i = boxes.length;
      overlapping = false;
      while (i--) {
        if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
          boxes[i - 1].size += boxes[i].size;
          boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
          boxes[i - 1].align = 0.5;
          if (boxes[i - 1].pos + boxes[i - 1].size > len) {
            boxes[i - 1].pos = len - boxes[i - 1].size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
    origBoxes.push.apply(origBoxes, restBoxes);
    i = 0;
    boxes.some(function(box2) {
      var posInCompositeBox = 0;
      return (box2.targets || []).some(function() {
        origBoxes[i].pos = box2.pos + posInCompositeBox;
        if (typeof maxDistance !== "undefined" && Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {
          origBoxes.slice(0, i + 1).forEach(function(box3) {
            return delete box3.pos;
          });
          origBoxes.reducedLen = (origBoxes.reducedLen || len) - len * 0.1;
          if (origBoxes.reducedLen > len * 0.1) {
            distribute5(origBoxes, len, maxDistance);
          }
          return true;
        }
        posInCompositeBox += origBoxes[i].size;
        i++;
        return false;
      });
    });
    stableSort2(origBoxes, sortByTarget);
    return origBoxes;
  }
  RendererUtilities2.distribute = distribute5;
})(RendererUtilities || (RendererUtilities = {}));
var RendererUtilities_default = RendererUtilities;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGElement.js
var animate2 = AnimationUtilities_default.animate;
var animObject2 = AnimationUtilities_default.animObject;
var stop2 = AnimationUtilities_default.stop;
var deg2rad = Globals_default.deg2rad;
var doc2 = Globals_default.doc;
var noop = Globals_default.noop;
var svg2 = Globals_default.svg;
var SVG_NS2 = Globals_default.SVG_NS;
var win5 = Globals_default.win;
var addEvent2 = Utilities_default.addEvent;
var attr4 = Utilities_default.attr;
var createElement3 = Utilities_default.createElement;
var css3 = Utilities_default.css;
var defined4 = Utilities_default.defined;
var erase2 = Utilities_default.erase;
var extend3 = Utilities_default.extend;
var fireEvent2 = Utilities_default.fireEvent;
var isArray3 = Utilities_default.isArray;
var isFunction2 = Utilities_default.isFunction;
var isNumber6 = Utilities_default.isNumber;
var isString3 = Utilities_default.isString;
var merge6 = Utilities_default.merge;
var objectEach6 = Utilities_default.objectEach;
var pick6 = Utilities_default.pick;
var pInt4 = Utilities_default.pInt;
var syncTimeout2 = Utilities_default.syncTimeout;
var uniqueKey2 = Utilities_default.uniqueKey;
var SVGElement = (
  /** @class */
  function() {
    function SVGElement2() {
      this.element = void 0;
      this.onEvents = {};
      this.opacity = 1;
      this.renderer = void 0;
      this.SVG_NS = SVG_NS2;
      this.symbolCustomAttribs = [
        "x",
        "y",
        "width",
        "height",
        "r",
        "start",
        "end",
        "innerR",
        "anchorX",
        "anchorY",
        "rounded"
      ];
    }
    SVGElement2.prototype._defaultGetter = function(key) {
      var ret = pick6(
        this[key + "Value"],
        // align getter
        this[key],
        this.element ? this.element.getAttribute(key) : null,
        0
      );
      if (/^[\-0-9\.]+$/.test(ret)) {
        ret = parseFloat(ret);
      }
      return ret;
    };
    SVGElement2.prototype._defaultSetter = function(value, key, element) {
      element.setAttribute(key, value);
    };
    SVGElement2.prototype.add = function(parent) {
      var renderer = this.renderer, element = this.element;
      var inserted;
      if (parent) {
        this.parentGroup = parent;
      }
      this.parentInverted = parent && parent.inverted;
      if (typeof this.textStr !== "undefined" && this.element.nodeName === "text") {
        renderer.buildText(this);
      }
      this.added = true;
      if (!parent || parent.handleZ || this.zIndex) {
        inserted = this.zIndexSetter();
      }
      if (!inserted) {
        (parent ? parent.element : renderer.box).appendChild(element);
      }
      if (this.onAdd) {
        this.onAdd();
      }
      return this;
    };
    SVGElement2.prototype.addClass = function(className, replace) {
      var currentClassName = replace ? "" : this.attr("class") || "";
      className = (className || "").split(/ /g).reduce(function(newClassName, name) {
        if (currentClassName.indexOf(name) === -1) {
          newClassName.push(name);
        }
        return newClassName;
      }, currentClassName ? [currentClassName] : []).join(" ");
      if (className !== currentClassName) {
        this.attr("class", className);
      }
      return this;
    };
    SVGElement2.prototype.afterSetters = function() {
      if (this.doTransform) {
        this.updateTransform();
        this.doTransform = false;
      }
    };
    SVGElement2.prototype.align = function(alignOptions, alignByTranslate, box) {
      var attribs = {}, renderer = this.renderer, alignedObjects = renderer.alignedObjects;
      var x, y, alignTo, alignFactor, vAlignFactor;
      if (alignOptions) {
        this.alignOptions = alignOptions;
        this.alignByTranslate = alignByTranslate;
        if (!box || isString3(box)) {
          this.alignTo = alignTo = box || "renderer";
          erase2(alignedObjects, this);
          alignedObjects.push(this);
          box = void 0;
        }
      } else {
        alignOptions = this.alignOptions;
        alignByTranslate = this.alignByTranslate;
        alignTo = this.alignTo;
      }
      box = pick6(box, renderer[alignTo], alignTo === "scrollablePlotBox" ? renderer.plotBox : void 0, renderer);
      var align = alignOptions.align, vAlign = alignOptions.verticalAlign;
      x = (box.x || 0) + (alignOptions.x || 0);
      y = (box.y || 0) + (alignOptions.y || 0);
      if (align === "right") {
        alignFactor = 1;
      } else if (align === "center") {
        alignFactor = 2;
      }
      if (alignFactor) {
        x += (box.width - (alignOptions.width || 0)) / alignFactor;
      }
      attribs[alignByTranslate ? "translateX" : "x"] = Math.round(x);
      if (vAlign === "bottom") {
        vAlignFactor = 1;
      } else if (vAlign === "middle") {
        vAlignFactor = 2;
      }
      if (vAlignFactor) {
        y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
      }
      attribs[alignByTranslate ? "translateY" : "y"] = Math.round(y);
      this[this.placed ? "animate" : "attr"](attribs);
      this.placed = true;
      this.alignAttr = attribs;
      return this;
    };
    SVGElement2.prototype.alignSetter = function(value) {
      var convert = {
        left: "start",
        center: "middle",
        right: "end"
      };
      if (convert[value]) {
        this.alignValue = value;
        this.element.setAttribute("text-anchor", convert[value]);
      }
    };
    SVGElement2.prototype.animate = function(params, options, complete) {
      var _this = this;
      var animOptions = animObject2(pick6(options, this.renderer.globalAnimation, true)), deferTime = animOptions.defer;
      if (pick6(doc2.hidden, doc2.msHidden, doc2.webkitHidden, false)) {
        animOptions.duration = 0;
      }
      if (animOptions.duration !== 0) {
        if (complete) {
          animOptions.complete = complete;
        }
        syncTimeout2(function() {
          if (_this.element) {
            animate2(_this, params, animOptions);
          }
        }, deferTime);
      } else {
        this.attr(params, void 0, complete);
        objectEach6(params, function(val, prop) {
          if (animOptions.step) {
            animOptions.step.call(this, val, { prop, pos: 1, elem: this });
          }
        }, this);
      }
      return this;
    };
    SVGElement2.prototype.applyTextOutline = function(textOutline) {
      var elem = this.element, hasContrast = textOutline.indexOf("contrast") !== -1, styles = {};
      if (hasContrast) {
        styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
      }
      var parts = textOutline.split(" ");
      var color18 = parts[parts.length - 1];
      var strokeWidth = parts[0];
      if (strokeWidth && strokeWidth !== "none" && Globals_default.svg) {
        this.fakeTS = true;
        this.ySetter = this.xSetter;
        strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function(match, digit, unit) {
          return 2 * Number(digit) + unit;
        });
        this.removeTextOutline();
        var outline_1 = doc2.createElementNS(SVG_NS2, "tspan");
        attr4(outline_1, {
          "class": "highcharts-text-outline",
          fill: color18,
          stroke: color18,
          "stroke-width": strokeWidth,
          "stroke-linejoin": "round"
        });
        [].forEach.call(elem.childNodes, function(childNode) {
          var clone = childNode.cloneNode(true);
          if (clone.removeAttribute) {
            ["fill", "stroke", "stroke-width", "stroke"].forEach(function(prop) {
              return clone.removeAttribute(prop);
            });
          }
          outline_1.appendChild(clone);
        });
        var br_1 = doc2.createElementNS(SVG_NS2, "tspan");
        br_1.textContent = "";
        ["x", "y"].forEach(function(key) {
          var value = elem.getAttribute(key);
          if (value) {
            br_1.setAttribute(key, value);
          }
        });
        outline_1.appendChild(br_1);
        elem.insertBefore(outline_1, elem.firstChild);
      }
    };
    SVGElement2.prototype.attr = function(hash, val, complete, continueAnimation) {
      var element = this.element, symbolCustomAttribs = this.symbolCustomAttribs;
      var key, hasSetSymbolSize, ret = this, skipAttr, setter;
      if (typeof hash === "string" && typeof val !== "undefined") {
        key = hash;
        hash = {};
        hash[key] = val;
      }
      if (typeof hash === "string") {
        ret = (this[hash + "Getter"] || this._defaultGetter).call(this, hash, element);
      } else {
        objectEach6(hash, function eachAttribute(val2, key2) {
          skipAttr = false;
          if (!continueAnimation) {
            stop2(this, key2);
          }
          if (this.symbolName && symbolCustomAttribs.indexOf(key2) !== -1) {
            if (!hasSetSymbolSize) {
              this.symbolAttr(hash);
              hasSetSymbolSize = true;
            }
            skipAttr = true;
          }
          if (this.rotation && (key2 === "x" || key2 === "y")) {
            this.doTransform = true;
          }
          if (!skipAttr) {
            setter = this[key2 + "Setter"] || this._defaultSetter;
            setter.call(this, val2, key2, element);
            if (!this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key2)) {
              this.updateShadows(key2, val2, setter);
            }
          }
        }, this);
        this.afterSetters();
      }
      if (complete) {
        complete.call(this);
      }
      return ret;
    };
    SVGElement2.prototype.clip = function(clipRect) {
      return this.attr("clip-path", clipRect ? "url(" + this.renderer.url + "#" + clipRect.id + ")" : "none");
    };
    SVGElement2.prototype.crisp = function(rect2, strokeWidth) {
      var wrapper = this;
      strokeWidth = strokeWidth || rect2.strokeWidth || 0;
      var normalizer = Math.round(strokeWidth) % 2 / 2;
      rect2.x = Math.floor(rect2.x || wrapper.x || 0) + normalizer;
      rect2.y = Math.floor(rect2.y || wrapper.y || 0) + normalizer;
      rect2.width = Math.floor((rect2.width || wrapper.width || 0) - 2 * normalizer);
      rect2.height = Math.floor((rect2.height || wrapper.height || 0) - 2 * normalizer);
      if (defined4(rect2.strokeWidth)) {
        rect2.strokeWidth = strokeWidth;
      }
      return rect2;
    };
    SVGElement2.prototype.complexColor = function(colorOptions, prop, elem) {
      var renderer = this.renderer;
      var colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id, key = [], value;
      fireEvent2(this.renderer, "complexColor", {
        args: arguments
      }, function() {
        if (colorOptions.radialGradient) {
          gradName = "radialGradient";
        } else if (colorOptions.linearGradient) {
          gradName = "linearGradient";
        }
        if (gradName) {
          gradAttr = colorOptions[gradName];
          gradients = renderer.gradients;
          stops = colorOptions.stops;
          radialReference = elem.radialReference;
          if (isArray3(gradAttr)) {
            colorOptions[gradName] = gradAttr = {
              x1: gradAttr[0],
              y1: gradAttr[1],
              x2: gradAttr[2],
              y2: gradAttr[3],
              gradientUnits: "userSpaceOnUse"
            };
          }
          if (gradName === "radialGradient" && radialReference && !defined4(gradAttr.gradientUnits)) {
            radAttr = gradAttr;
            gradAttr = merge6(gradAttr, renderer.getRadialAttr(radialReference, radAttr), { gradientUnits: "userSpaceOnUse" });
          }
          objectEach6(gradAttr, function(value2, n) {
            if (n !== "id") {
              key.push(n, value2);
            }
          });
          objectEach6(stops, function(val) {
            key.push(val);
          });
          key = key.join(",");
          if (gradients[key]) {
            id = gradients[key].attr("id");
          } else {
            gradAttr.id = id = uniqueKey2();
            var gradientObject_1 = gradients[key] = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
            gradientObject_1.radAttr = radAttr;
            gradientObject_1.stops = [];
            stops.forEach(function(stop4) {
              if (stop4[1].indexOf("rgba") === 0) {
                colorObject = Color_default.parse(stop4[1]);
                stopColor = colorObject.get("rgb");
                stopOpacity = colorObject.get("a");
              } else {
                stopColor = stop4[1];
                stopOpacity = 1;
              }
              var stopObject = renderer.createElement("stop").attr({
                offset: stop4[0],
                "stop-color": stopColor,
                "stop-opacity": stopOpacity
              }).add(gradientObject_1);
              gradientObject_1.stops.push(stopObject);
            });
          }
          value = "url(" + renderer.url + "#" + id + ")";
          elem.setAttribute(prop, value);
          elem.gradient = key;
          colorOptions.toString = function() {
            return value;
          };
        }
      });
    };
    SVGElement2.prototype.css = function(styles) {
      var oldStyles = this.styles, newStyles = {}, elem = this.element, svgPseudoProps = ["textOutline", "textOverflow", "width"];
      var textWidth, serializedCss = "", hyphenate, hasNew = !oldStyles;
      if (styles && styles.color) {
        styles.fill = styles.color;
      }
      if (oldStyles) {
        objectEach6(styles, function(style, n) {
          if (oldStyles && oldStyles[n] !== style) {
            newStyles[n] = style;
            hasNew = true;
          }
        });
      }
      if (hasNew) {
        if (oldStyles) {
          styles = extend3(oldStyles, newStyles);
        }
        if (styles) {
          if (styles.width === null || styles.width === "auto") {
            delete this.textWidth;
          } else if (elem.nodeName.toLowerCase() === "text" && styles.width) {
            textWidth = this.textWidth = pInt4(styles.width);
          }
        }
        this.styles = styles;
        if (textWidth && (!svg2 && this.renderer.forExport)) {
          delete styles.width;
        }
        if (elem.namespaceURI === this.SVG_NS) {
          hyphenate = function(a, b) {
            return "-" + b.toLowerCase();
          };
          objectEach6(styles, function(style, n) {
            if (svgPseudoProps.indexOf(n) === -1) {
              serializedCss += n.replace(/([A-Z])/g, hyphenate) + ":" + style + ";";
            }
          });
          if (serializedCss) {
            attr4(elem, "style", serializedCss);
          }
        } else {
          css3(elem, styles);
        }
        if (this.added) {
          if (this.element.nodeName === "text") {
            this.renderer.buildText(this);
          }
          if (styles && styles.textOutline) {
            this.applyTextOutline(styles.textOutline);
          }
        }
      }
      return this;
    };
    SVGElement2.prototype.dashstyleSetter = function(value) {
      var i, strokeWidth = this["stroke-width"];
      if (strokeWidth === "inherit") {
        strokeWidth = 1;
      }
      value = value && value.toLowerCase();
      if (value) {
        var v = value.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
        i = v.length;
        while (i--) {
          v[i] = "" + pInt4(v[i]) * pick6(strokeWidth, NaN);
        }
        value = v.join(",").replace(/NaN/g, "none");
        this.element.setAttribute("stroke-dasharray", value);
      }
    };
    SVGElement2.prototype.destroy = function() {
      var wrapper = this, element = wrapper.element || {}, renderer = wrapper.renderer, ownerSVGElement = element.ownerSVGElement;
      var parentToClean = renderer.isSVG && element.nodeName === "SPAN" && wrapper.parentGroup || void 0, grandParent, i;
      element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
      stop2(wrapper);
      if (wrapper.clipPath && ownerSVGElement) {
        var clipPath_1 = wrapper.clipPath;
        [].forEach.call(ownerSVGElement.querySelectorAll("[clip-path],[CLIP-PATH]"), function(el) {
          if (el.getAttribute("clip-path").indexOf(clipPath_1.element.id) > -1) {
            el.removeAttribute("clip-path");
          }
        });
        wrapper.clipPath = clipPath_1.destroy();
      }
      if (wrapper.stops) {
        for (i = 0; i < wrapper.stops.length; i++) {
          wrapper.stops[i].destroy();
        }
        wrapper.stops.length = 0;
        wrapper.stops = void 0;
      }
      wrapper.safeRemoveChild(element);
      if (!renderer.styledMode) {
        wrapper.destroyShadows();
      }
      while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
        grandParent = parentToClean.parentGroup;
        wrapper.safeRemoveChild(parentToClean.div);
        delete parentToClean.div;
        parentToClean = grandParent;
      }
      if (wrapper.alignTo) {
        erase2(renderer.alignedObjects, wrapper);
      }
      objectEach6(wrapper, function(val, key) {
        if (wrapper[key] && wrapper[key].parentGroup === wrapper && wrapper[key].destroy) {
          wrapper[key].destroy();
        }
        delete wrapper[key];
      });
      return;
    };
    SVGElement2.prototype.destroyShadows = function() {
      (this.shadows || []).forEach(function(shadow) {
        this.safeRemoveChild(shadow);
      }, this);
      this.shadows = void 0;
    };
    SVGElement2.prototype.destroyTextPath = function(elem, path) {
      var textElement = elem.getElementsByTagName("text")[0];
      var childNodes;
      if (textElement) {
        textElement.removeAttribute("dx");
        textElement.removeAttribute("dy");
        path.element.setAttribute("id", "");
        if (this.textPathWrapper && textElement.getElementsByTagName("textPath").length) {
          childNodes = this.textPathWrapper.element.childNodes;
          while (childNodes.length) {
            textElement.appendChild(childNodes[0]);
          }
          textElement.removeChild(this.textPathWrapper.element);
        }
      } else if (elem.getAttribute("dx") || elem.getAttribute("dy")) {
        elem.removeAttribute("dx");
        elem.removeAttribute("dy");
      }
      if (this.textPathWrapper) {
        this.textPathWrapper = this.textPathWrapper.destroy();
      }
    };
    SVGElement2.prototype.dSetter = function(value, key, element) {
      if (isArray3(value)) {
        if (typeof value[0] === "string") {
          value = this.renderer.pathToSegments(value);
        }
        this.pathArray = value;
        value = value.reduce(function(acc, seg, i) {
          if (!seg || !seg.join) {
            return (seg || "").toString();
          }
          return (i ? acc + " " : "") + seg.join(" ");
        }, "");
      }
      if (/(NaN| {2}|^$)/.test(value)) {
        value = "M 0 0";
      }
      if (this[key] !== value) {
        element.setAttribute(key, value);
        this[key] = value;
      }
    };
    SVGElement2.prototype.fadeOut = function(duration) {
      var elemWrapper = this;
      elemWrapper.animate({
        opacity: 0
      }, {
        duration: pick6(duration, 150),
        complete: function() {
          elemWrapper.attr({ y: -9999 }).hide();
        }
      });
    };
    SVGElement2.prototype.fillSetter = function(value, key, element) {
      if (typeof value === "string") {
        element.setAttribute(key, value);
      } else if (value) {
        this.complexColor(value, key, element);
      }
    };
    SVGElement2.prototype.getBBox = function(reload, rot) {
      var wrapper = this, renderer = wrapper.renderer, element = wrapper.element, styles = wrapper.styles, textStr = wrapper.textStr, cache = renderer.cache, cacheKeys = renderer.cacheKeys, isSVG = element.namespaceURI === wrapper.SVG_NS, rotation = pick6(rot, wrapper.rotation, 0), fontSize = renderer.styledMode ? element && SVGElement2.prototype.getStyle.call(element, "font-size") : styles && styles.fontSize;
      var bBox, width, height, toggleTextShadowShim, cacheKey;
      if (defined4(textStr)) {
        cacheKey = textStr.toString();
        if (cacheKey.indexOf("<") === -1) {
          cacheKey = cacheKey.replace(/[0-9]/g, "0");
        }
        cacheKey += [
          "",
          rotation,
          fontSize,
          wrapper.textWidth,
          styles && styles.textOverflow,
          styles && styles.fontWeight
          // #12163
        ].join(",");
      }
      if (cacheKey && !reload) {
        bBox = cache[cacheKey];
      }
      if (!bBox) {
        if (isSVG || renderer.forExport) {
          try {
            toggleTextShadowShim = this.fakeTS && function(display) {
              var outline = element.querySelector(".highcharts-text-outline");
              if (outline) {
                css3(outline, { display });
              }
            };
            if (isFunction2(toggleTextShadowShim)) {
              toggleTextShadowShim("none");
            }
            bBox = element.getBBox ? (
              // SVG: use extend because IE9 is not allowed to change
              // width and height in case of rotation (below)
              extend3({}, element.getBBox())
            ) : {
              // Legacy IE in export mode
              width: element.offsetWidth,
              height: element.offsetHeight
            };
            if (isFunction2(toggleTextShadowShim)) {
              toggleTextShadowShim("");
            }
          } catch (e2) {
            "";
          }
          if (!bBox || bBox.width < 0) {
            bBox = { width: 0, height: 0 };
          }
        } else {
          bBox = wrapper.htmlGetBBox();
        }
        if (renderer.isSVG) {
          width = bBox.width;
          height = bBox.height;
          if (isSVG) {
            bBox.height = height = {
              "11px,17": 14,
              "13px,20": 16
            }[styles && styles.fontSize + "," + Math.round(height)] || height;
          }
          if (rotation) {
            var rad = rotation * deg2rad;
            bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));
            bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));
          }
        }
        if (cacheKey && (textStr === "" || bBox.height > 0)) {
          while (cacheKeys.length > 250) {
            delete cache[cacheKeys.shift()];
          }
          if (!cache[cacheKey]) {
            cacheKeys.push(cacheKey);
          }
          cache[cacheKey] = bBox;
        }
      }
      return bBox;
    };
    SVGElement2.prototype.getStyle = function(prop) {
      return win5.getComputedStyle(this.element || this, "").getPropertyValue(prop);
    };
    SVGElement2.prototype.hasClass = function(className) {
      return ("" + this.attr("class")).split(" ").indexOf(className) !== -1;
    };
    SVGElement2.prototype.hide = function(hideByTranslation) {
      if (hideByTranslation) {
        this.attr({ y: -9999 });
      } else {
        this.attr({ visibility: "hidden" });
      }
      return this;
    };
    SVGElement2.prototype.htmlGetBBox = function() {
      return { height: 0, width: 0, x: 0, y: 0 };
    };
    SVGElement2.prototype.init = function(renderer, nodeName) {
      this.element = nodeName === "span" ? createElement3(nodeName) : doc2.createElementNS(this.SVG_NS, nodeName);
      this.renderer = renderer;
      fireEvent2(this, "afterInit");
    };
    SVGElement2.prototype.invert = function(inverted) {
      this.inverted = inverted;
      this.updateTransform();
      return this;
    };
    SVGElement2.prototype.on = function(eventType, handler) {
      var onEvents = this.onEvents;
      if (onEvents[eventType]) {
        onEvents[eventType]();
      }
      onEvents[eventType] = addEvent2(this.element, eventType, handler);
      return this;
    };
    SVGElement2.prototype.opacitySetter = function(value, key, element) {
      var opacity = Number(Number(value).toFixed(3));
      this.opacity = opacity;
      element.setAttribute(key, opacity);
    };
    SVGElement2.prototype.removeClass = function(className) {
      return this.attr("class", ("" + this.attr("class")).replace(isString3(className) ? new RegExp("(^| )" + className + "( |$)") : (
        // #12064, #13590
        className
      ), " ").replace(/ +/g, " ").trim());
    };
    SVGElement2.prototype.removeTextOutline = function() {
      var outline = this.element.querySelector("tspan.highcharts-text-outline");
      if (outline) {
        this.safeRemoveChild(outline);
      }
    };
    SVGElement2.prototype.safeRemoveChild = function(element) {
      var parentNode = element.parentNode;
      if (parentNode) {
        parentNode.removeChild(element);
      }
    };
    SVGElement2.prototype.setRadialReference = function(coordinates) {
      var existingGradient = this.element.gradient && this.renderer.gradients[this.element.gradient];
      this.element.radialReference = coordinates;
      if (existingGradient && existingGradient.radAttr) {
        existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
      }
      return this;
    };
    SVGElement2.prototype.setTextPath = function(path, textPathOptions) {
      var elem = this.element, textNode = this.text ? this.text.element : elem, attribsMap = {
        textAnchor: "text-anchor"
      };
      var adder = false, textPathElement, textPathId, textPathWrapper = this.textPathWrapper, firstTime = !textPathWrapper;
      textPathOptions = merge6(true, {
        enabled: true,
        attributes: {
          dy: -5,
          startOffset: "50%",
          textAnchor: "middle"
        }
      }, textPathOptions);
      var attrs = AST_default.filterUserAttributes(textPathOptions.attributes);
      if (path && textPathOptions && textPathOptions.enabled) {
        if (textPathWrapper && textPathWrapper.element.parentNode === null) {
          firstTime = true;
          textPathWrapper = textPathWrapper.destroy();
        } else if (textPathWrapper) {
          this.removeTextOutline.call(textPathWrapper.parentGroup);
        }
        if (this.options && this.options.padding) {
          attrs.dx = -this.options.padding;
        }
        if (!textPathWrapper) {
          this.textPathWrapper = textPathWrapper = this.renderer.createElement("textPath");
          adder = true;
        }
        textPathElement = textPathWrapper.element;
        textPathId = path.element.getAttribute("id");
        if (!textPathId) {
          path.element.setAttribute("id", textPathId = uniqueKey2());
        }
        if (firstTime) {
          textNode.setAttribute("y", 0);
          if (isNumber6(attrs.dx)) {
            textNode.setAttribute("x", -attrs.dx);
          }
          var childNodes = [].slice.call(textNode.childNodes);
          for (var i = 0; i < childNodes.length; i++) {
            var childNode = childNodes[i];
            if (childNode.nodeType === Node.TEXT_NODE || childNode.nodeName === "tspan") {
              textPathElement.appendChild(childNode);
            }
          }
        }
        if (adder && textPathWrapper) {
          textPathWrapper.add({ element: textNode });
        }
        textPathElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + textPathId);
        if (defined4(attrs.dy)) {
          textPathElement.parentNode.setAttribute("dy", attrs.dy);
          delete attrs.dy;
        }
        if (defined4(attrs.dx)) {
          textPathElement.parentNode.setAttribute("dx", attrs.dx);
          delete attrs.dx;
        }
        objectEach6(attrs, function(val, key) {
          textPathElement.setAttribute(attribsMap[key] || key, val);
        });
        elem.removeAttribute("transform");
        this.removeTextOutline.call(textPathWrapper);
        if (this.text && !this.renderer.styledMode) {
          this.attr({
            fill: "none",
            "stroke-width": 0
          });
        }
        this.updateTransform = noop;
        this.applyTextOutline = noop;
      } else if (textPathWrapper) {
        delete this.updateTransform;
        delete this.applyTextOutline;
        this.destroyTextPath(elem, path);
        this.updateTransform();
        if (this.options && this.options.rotation) {
          this.applyTextOutline(this.options.style.textOutline);
        }
      }
      return this;
    };
    SVGElement2.prototype.shadow = function(shadowOptions, group, cutOff) {
      var shadows = [], element = this.element, oldShadowOptions = this.oldShadowOptions, defaultShadowOptions = {
        color: Palette_default.neutralColor100,
        offsetX: this.parentInverted ? -1 : 1,
        offsetY: this.parentInverted ? -1 : 1,
        opacity: 0.15,
        width: 3
      };
      var i, shadow, strokeWidth, shadowElementOpacity, update = false, transform, options;
      if (shadowOptions === true) {
        options = defaultShadowOptions;
      } else if (typeof shadowOptions === "object") {
        options = extend3(defaultShadowOptions, shadowOptions);
      }
      if (options) {
        if (options && oldShadowOptions) {
          objectEach6(options, function(value, key) {
            if (value !== oldShadowOptions[key]) {
              update = true;
            }
          });
        }
        if (update) {
          this.destroyShadows();
        }
        this.oldShadowOptions = options;
      }
      if (!options) {
        this.destroyShadows();
      } else if (!this.shadows) {
        shadowElementOpacity = options.opacity / options.width;
        transform = this.parentInverted ? "translate(" + options.offsetY + ", " + options.offsetX + ")" : "translate(" + options.offsetX + ", " + options.offsetY + ")";
        for (i = 1; i <= options.width; i++) {
          shadow = element.cloneNode(false);
          strokeWidth = options.width * 2 + 1 - 2 * i;
          attr4(shadow, {
            stroke: shadowOptions.color || Palette_default.neutralColor100,
            "stroke-opacity": shadowElementOpacity * i,
            "stroke-width": strokeWidth,
            transform,
            fill: "none"
          });
          shadow.setAttribute("class", (shadow.getAttribute("class") || "") + " highcharts-shadow");
          if (cutOff) {
            attr4(shadow, "height", Math.max(attr4(shadow, "height") - strokeWidth, 0));
            shadow.cutHeight = strokeWidth;
          }
          if (group) {
            group.element.appendChild(shadow);
          } else if (element.parentNode) {
            element.parentNode.insertBefore(shadow, element);
          }
          shadows.push(shadow);
        }
        this.shadows = shadows;
      }
      return this;
    };
    SVGElement2.prototype.show = function(inherit) {
      return this.attr({ visibility: inherit ? "inherit" : "visible" });
    };
    SVGElement2.prototype.strokeSetter = function(value, key, element) {
      this[key] = value;
      if (this.stroke && this["stroke-width"]) {
        SVGElement2.prototype.fillSetter.call(this, this.stroke, "stroke", element);
        element.setAttribute("stroke-width", this["stroke-width"]);
        this.hasStroke = true;
      } else if (key === "stroke-width" && value === 0 && this.hasStroke) {
        element.removeAttribute("stroke");
        this.hasStroke = false;
      } else if (this.renderer.styledMode && this["stroke-width"]) {
        element.setAttribute("stroke-width", this["stroke-width"]);
        this.hasStroke = true;
      }
    };
    SVGElement2.prototype.strokeWidth = function() {
      if (!this.renderer.styledMode) {
        return this["stroke-width"] || 0;
      }
      var val = this.getStyle("stroke-width");
      var ret = 0, dummy;
      if (val.indexOf("px") === val.length - 2) {
        ret = pInt4(val);
      } else if (val !== "") {
        dummy = doc2.createElementNS(SVG_NS2, "rect");
        attr4(dummy, {
          width: val,
          "stroke-width": 0
        });
        this.element.parentNode.appendChild(dummy);
        ret = dummy.getBBox().width;
        dummy.parentNode.removeChild(dummy);
      }
      return ret;
    };
    SVGElement2.prototype.symbolAttr = function(hash) {
      var wrapper = this;
      [
        "x",
        "y",
        "r",
        "start",
        "end",
        "width",
        "height",
        "innerR",
        "anchorX",
        "anchorY",
        "clockwise"
      ].forEach(function(key) {
        wrapper[key] = pick6(hash[key], wrapper[key]);
      });
      wrapper.attr({
        d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
      });
    };
    SVGElement2.prototype.textSetter = function(value) {
      if (value !== this.textStr) {
        delete this.textPxLength;
        this.textStr = value;
        if (this.added) {
          this.renderer.buildText(this);
        }
      }
    };
    SVGElement2.prototype.titleSetter = function(value) {
      var el = this.element;
      var titleNode = el.getElementsByTagName("title")[0] || doc2.createElementNS(this.SVG_NS, "title");
      if (el.insertBefore) {
        el.insertBefore(titleNode, el.firstChild);
      } else {
        el.appendChild(titleNode);
      }
      titleNode.textContent = // #3276, #3895
      String(pick6(value, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
    };
    SVGElement2.prototype.toFront = function() {
      var element = this.element;
      element.parentNode.appendChild(element);
      return this;
    };
    SVGElement2.prototype.translate = function(x, y) {
      return this.attr({
        translateX: x,
        translateY: y
      });
    };
    SVGElement2.prototype.updateShadows = function(key, value, setter) {
      var shadows = this.shadows;
      if (shadows) {
        var i = shadows.length;
        while (i--) {
          setter.call(shadows[i], key === "height" ? Math.max(value - (shadows[i].cutHeight || 0), 0) : key === "d" ? this.d : value, key, shadows[i]);
        }
      }
    };
    SVGElement2.prototype.updateTransform = function() {
      var wrapper = this, scaleX = wrapper.scaleX, scaleY = wrapper.scaleY, inverted = wrapper.inverted, rotation = wrapper.rotation, matrix = wrapper.matrix, element = wrapper.element;
      var translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0;
      if (inverted) {
        translateX += wrapper.width;
        translateY += wrapper.height;
      }
      var transform = ["translate(" + translateX + "," + translateY + ")"];
      if (defined4(matrix)) {
        transform.push("matrix(" + matrix.join(",") + ")");
      }
      if (inverted) {
        transform.push("rotate(90) scale(-1,1)");
      } else if (rotation) {
        transform.push("rotate(" + rotation + " " + pick6(this.rotationOriginX, element.getAttribute("x"), 0) + " " + pick6(this.rotationOriginY, element.getAttribute("y") || 0) + ")");
      }
      if (defined4(scaleX) || defined4(scaleY)) {
        transform.push("scale(" + pick6(scaleX, 1) + " " + pick6(scaleY, 1) + ")");
      }
      if (transform.length) {
        element.setAttribute("transform", transform.join(" "));
      }
    };
    SVGElement2.prototype.visibilitySetter = function(value, key, element) {
      if (value === "inherit") {
        element.removeAttribute(key);
      } else if (this[key] !== value) {
        element.setAttribute(key, value);
      }
      this[key] = value;
    };
    SVGElement2.prototype.xGetter = function(key) {
      if (this.element.nodeName === "circle") {
        if (key === "x") {
          key = "cx";
        } else if (key === "y") {
          key = "cy";
        }
      }
      return this._defaultGetter(key);
    };
    SVGElement2.prototype.zIndexSetter = function(value, key) {
      var renderer = this.renderer, parentGroup = this.parentGroup, parentWrapper = parentGroup || renderer, parentNode = parentWrapper.element || renderer.box, element = this.element, svgParent = parentNode === renderer.box;
      var childNodes, otherElement, otherZIndex, inserted = false, undefinedOtherZIndex, run = this.added, i;
      if (defined4(value)) {
        element.setAttribute("data-z-index", value);
        value = +value;
        if (this[key] === value) {
          run = false;
        }
      } else if (defined4(this[key])) {
        element.removeAttribute("data-z-index");
      }
      this[key] = value;
      if (run) {
        value = this.zIndex;
        if (value && parentGroup) {
          parentGroup.handleZ = true;
        }
        childNodes = parentNode.childNodes;
        for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
          otherElement = childNodes[i];
          otherZIndex = otherElement.getAttribute("data-z-index");
          undefinedOtherZIndex = !defined4(otherZIndex);
          if (otherElement !== element) {
            if (
              // Negative zIndex versus no zIndex:
              // On all levels except the highest. If the parent is
              // <svg>, then we don't want to put items before <desc>
              // or <defs>
              value < 0 && undefinedOtherZIndex && !svgParent && !i
            ) {
              parentNode.insertBefore(element, childNodes[i]);
              inserted = true;
            } else if (
              // Insert after the first element with a lower zIndex
              pInt4(otherZIndex) <= value || // If negative zIndex, add this before first undefined
              // zIndex element
              undefinedOtherZIndex && (!defined4(value) || value >= 0)
            ) {
              parentNode.insertBefore(
                element,
                childNodes[i + 1] || null
                // null for oldIE export
              );
              inserted = true;
            }
          }
        }
        if (!inserted) {
          parentNode.insertBefore(
            element,
            childNodes[svgParent ? 3 : 0] || null
            // null for oldIE
          );
          inserted = true;
        }
      }
      return inserted;
    };
    return SVGElement2;
  }()
);
SVGElement.prototype["stroke-widthSetter"] = SVGElement.prototype.strokeSetter;
SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
SVGElement.prototype.matrixSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.verticalAlignSetter = function(value, key) {
  this[key] = value;
  this.doTransform = true;
};
var SVGElement_default = SVGElement;

// node_modules/highcharts/es-modules/Core/Renderer/RendererRegistry.js
var RendererRegistry;
(function(RendererRegistry2) {
  RendererRegistry2.rendererTypes = {};
  var defaultRenderer;
  function getRendererType(rendererType) {
    if (rendererType === void 0) {
      rendererType = defaultRenderer;
    }
    return RendererRegistry2.rendererTypes[rendererType] || RendererRegistry2.rendererTypes[defaultRenderer];
  }
  RendererRegistry2.getRendererType = getRendererType;
  function registerRendererType(rendererType, rendererClass, setAsDefault) {
    RendererRegistry2.rendererTypes[rendererType] = rendererClass;
    if (!defaultRenderer || setAsDefault) {
      defaultRenderer = rendererType;
      Globals_default.Renderer = rendererClass;
    }
  }
  RendererRegistry2.registerRendererType = registerRendererType;
})(RendererRegistry || (RendererRegistry = {}));
var RendererRegistry_default = RendererRegistry;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGLabel.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var defined5 = Utilities_default.defined;
var extend4 = Utilities_default.extend;
var isNumber7 = Utilities_default.isNumber;
var merge7 = Utilities_default.merge;
var pick7 = Utilities_default.pick;
var removeEvent2 = Utilities_default.removeEvent;
var SVGLabel = (
  /** @class */
  function(_super) {
    __extends(SVGLabel2, _super);
    function SVGLabel2(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
      var _this = _super.call(this) || this;
      _this.paddingLeftSetter = _this.paddingSetter;
      _this.paddingRightSetter = _this.paddingSetter;
      _this.init(renderer, "g");
      _this.textStr = str;
      _this.x = x;
      _this.y = y;
      _this.anchorX = anchorX;
      _this.anchorY = anchorY;
      _this.baseline = baseline;
      _this.className = className;
      _this.addClass(className === "button" ? "highcharts-no-tooltip" : "highcharts-label");
      if (className) {
        _this.addClass("highcharts-" + className);
      }
      _this.text = renderer.text(void 0, 0, 0, useHTML).attr({ zIndex: 1 });
      var hasBGImage;
      if (typeof shape === "string") {
        hasBGImage = /^url\((.*?)\)$/.test(shape);
        if (hasBGImage || _this.renderer.symbols[shape]) {
          _this.symbolKey = shape;
        }
      }
      _this.bBox = SVGLabel2.emptyBBox;
      _this.padding = 3;
      _this.baselineOffset = 0;
      _this.needsBox = renderer.styledMode || hasBGImage;
      _this.deferredAttr = {};
      _this.alignFactor = 0;
      return _this;
    }
    SVGLabel2.prototype.alignSetter = function(value) {
      var alignFactor = {
        left: 0,
        center: 0.5,
        right: 1
      }[value];
      if (alignFactor !== this.alignFactor) {
        this.alignFactor = alignFactor;
        if (this.bBox && isNumber7(this.xSetting)) {
          this.attr({ x: this.xSetting });
        }
      }
    };
    SVGLabel2.prototype.anchorXSetter = function(value, key) {
      this.anchorX = value;
      this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);
    };
    SVGLabel2.prototype.anchorYSetter = function(value, key) {
      this.anchorY = value;
      this.boxAttr(key, value - this.ySetting);
    };
    SVGLabel2.prototype.boxAttr = function(key, value) {
      if (this.box) {
        this.box.attr(key, value);
      } else {
        this.deferredAttr[key] = value;
      }
    };
    SVGLabel2.prototype.css = function(styles) {
      if (styles) {
        var textStyles_1 = {};
        styles = merge7(styles);
        SVGLabel2.textProps.forEach(function(prop) {
          if (typeof styles[prop] !== "undefined") {
            textStyles_1[prop] = styles[prop];
            delete styles[prop];
          }
        });
        this.text.css(textStyles_1);
        var isWidth = "width" in textStyles_1, isFontStyle = "fontSize" in textStyles_1 || "fontWeight" in textStyles_1;
        if (isFontStyle) {
          this.updateTextPadding();
        } else if (isWidth) {
          this.updateBoxSize();
        }
      }
      return SVGElement_default.prototype.css.call(this, styles);
    };
    SVGLabel2.prototype.destroy = function() {
      removeEvent2(this.element, "mouseenter");
      removeEvent2(this.element, "mouseleave");
      if (this.text) {
        this.text.destroy();
      }
      if (this.box) {
        this.box = this.box.destroy();
      }
      SVGElement_default.prototype.destroy.call(this);
      return void 0;
    };
    SVGLabel2.prototype.fillSetter = function(value, key) {
      if (value) {
        this.needsBox = true;
      }
      this.fill = value;
      this.boxAttr(key, value);
    };
    SVGLabel2.prototype.getBBox = function() {
      if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {
        this.updateBoxSize();
      }
      var padding = this.padding;
      var paddingLeft = pick7(this.paddingLeft, padding);
      return {
        width: this.width,
        height: this.height,
        x: this.bBox.x - paddingLeft,
        y: this.bBox.y - padding
      };
    };
    SVGLabel2.prototype.getCrispAdjust = function() {
      return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
    };
    SVGLabel2.prototype.heightSetter = function(value) {
      this.heightSetting = value;
    };
    SVGLabel2.prototype.onAdd = function() {
      var str = this.textStr;
      this.text.add(this);
      this.attr({
        // Alignment is available now  (#3295, 0 not rendered if given
        // as a value)
        text: defined5(str) ? str : "",
        x: this.x,
        y: this.y
      });
      if (this.box && defined5(this.anchorX)) {
        this.attr({
          anchorX: this.anchorX,
          anchorY: this.anchorY
        });
      }
    };
    SVGLabel2.prototype.paddingSetter = function(value, key) {
      if (!isNumber7(value)) {
        this[key] = void 0;
      } else if (value !== this[key]) {
        this[key] = value;
        this.updateTextPadding();
      }
    };
    SVGLabel2.prototype.rSetter = function(value, key) {
      this.boxAttr(key, value);
    };
    SVGLabel2.prototype.shadow = function(b) {
      if (b && !this.renderer.styledMode) {
        this.updateBoxSize();
        if (this.box) {
          this.box.shadow(b);
        }
      }
      return this;
    };
    SVGLabel2.prototype.strokeSetter = function(value, key) {
      this.stroke = value;
      this.boxAttr(key, value);
    };
    SVGLabel2.prototype["stroke-widthSetter"] = function(value, key) {
      if (value) {
        this.needsBox = true;
      }
      this["stroke-width"] = value;
      this.boxAttr(key, value);
    };
    SVGLabel2.prototype["text-alignSetter"] = function(value) {
      this.textAlign = value;
    };
    SVGLabel2.prototype.textSetter = function(text) {
      if (typeof text !== "undefined") {
        this.text.attr({ text });
      }
      this.updateTextPadding();
    };
    SVGLabel2.prototype.updateBoxSize = function() {
      var style = this.text.element.style, attribs = {}, padding = this.padding, bBox = this.bBox = (!isNumber7(this.widthSetting) || !isNumber7(this.heightSetting) || this.textAlign) && defined5(this.text.textStr) ? this.text.getBBox() : SVGLabel2.emptyBBox;
      var crispAdjust;
      this.width = this.getPaddedWidth();
      this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;
      var metrics = this.renderer.fontMetrics(style && style.fontSize, this.text);
      this.baselineOffset = padding + Math.min(
        // When applicable, use the font size of the first line (#15707)
        (this.text.firstLineMetrics || metrics).b,
        // When the height is 0, there is no bBox, so go with the font
        // metrics. Highmaps CSS demos.
        bBox.height || Infinity
      );
      if (this.heightSetting) {
        this.baselineOffset += (this.heightSetting - metrics.h) / 2;
      }
      if (this.needsBox) {
        if (!this.box) {
          var box = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
          box.addClass(
            // Don't use label className for buttons
            (this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")
          );
          box.add(this);
        }
        crispAdjust = this.getCrispAdjust();
        attribs.x = crispAdjust;
        attribs.y = (this.baseline ? -this.baselineOffset : 0) + crispAdjust;
        attribs.width = Math.round(this.width);
        attribs.height = Math.round(this.height);
        this.box.attr(extend4(attribs, this.deferredAttr));
        this.deferredAttr = {};
      }
    };
    SVGLabel2.prototype.updateTextPadding = function() {
      var text = this.text;
      this.updateBoxSize();
      var textY = this.baseline ? 0 : this.baselineOffset;
      var textX = pick7(this.paddingLeft, this.padding);
      if (defined5(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right")) {
        textX += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width);
      }
      if (textX !== text.x || textY !== text.y) {
        text.attr("x", textX);
        if (text.hasBoxWidthChanged) {
          this.bBox = text.getBBox(true);
        }
        if (typeof textY !== "undefined") {
          text.attr("y", textY);
        }
      }
      text.x = textX;
      text.y = textY;
    };
    SVGLabel2.prototype.widthSetter = function(value) {
      this.widthSetting = isNumber7(value) ? value : void 0;
    };
    SVGLabel2.prototype.getPaddedWidth = function() {
      var padding = this.padding;
      var paddingLeft = pick7(this.paddingLeft, padding);
      var paddingRight = pick7(this.paddingRight, padding);
      return (this.widthSetting || this.bBox.width || 0) + paddingLeft + paddingRight;
    };
    SVGLabel2.prototype.xSetter = function(value) {
      this.x = value;
      if (this.alignFactor) {
        value -= this.alignFactor * this.getPaddedWidth();
        this["forceAnimate:x"] = true;
      }
      this.xSetting = Math.round(value);
      this.attr("translateX", this.xSetting);
    };
    SVGLabel2.prototype.ySetter = function(value) {
      this.ySetting = this.y = Math.round(value);
      this.attr("translateY", this.ySetting);
    };
    SVGLabel2.emptyBBox = { width: 0, height: 0, x: 0, y: 0 };
    SVGLabel2.textProps = [
      "color",
      "direction",
      "fontFamily",
      "fontSize",
      "fontStyle",
      "fontWeight",
      "lineHeight",
      "textAlign",
      "textDecoration",
      "textOutline",
      "textOverflow",
      "width"
    ];
    return SVGLabel2;
  }(SVGElement_default)
);
var SVGLabel_default = SVGLabel;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/Symbols.js
var defined6 = Utilities_default.defined;
var isNumber8 = Utilities_default.isNumber;
var pick8 = Utilities_default.pick;
function arc(x, y, w2, h, options) {
  var arc3 = [];
  if (options) {
    var start = options.start || 0, rx = pick8(options.r, w2), ry = pick8(options.r, h || w2), proximity = 1e-3, fullCircle = Math.abs((options.end || 0) - start - 2 * Math.PI) < proximity, end = (options.end || 0) - proximity, innerRadius = options.innerR, open_1 = pick8(options.open, fullCircle), cosStart = Math.cos(start), sinStart = Math.sin(start), cosEnd = Math.cos(end), sinEnd = Math.sin(end), longArc = pick8(options.longArc, end - start - Math.PI < proximity ? 0 : 1);
    arc3.push([
      "M",
      x + rx * cosStart,
      y + ry * sinStart
    ], [
      "A",
      rx,
      ry,
      0,
      longArc,
      pick8(options.clockwise, 1),
      x + rx * cosEnd,
      y + ry * sinEnd
    ]);
    if (defined6(innerRadius)) {
      arc3.push(open_1 ? [
        "M",
        x + innerRadius * cosEnd,
        y + innerRadius * sinEnd
      ] : [
        "L",
        x + innerRadius * cosEnd,
        y + innerRadius * sinEnd
      ], [
        "A",
        innerRadius,
        innerRadius,
        0,
        longArc,
        // Clockwise - opposite to the outer arc clockwise
        defined6(options.clockwise) ? 1 - options.clockwise : 0,
        x + innerRadius * cosStart,
        y + innerRadius * sinStart
      ]);
    }
    if (!open_1) {
      arc3.push(["Z"]);
    }
  }
  return arc3;
}
function callout(x, y, w2, h, options) {
  var arrowLength = 6, halfDistance = 6, r = Math.min(options && options.r || 0, w2, h), safeDistance = r + halfDistance, anchorX = options && options.anchorX, anchorY = options && options.anchorY || 0;
  var path = roundedRect(x, y, w2, h, { r });
  if (!isNumber8(anchorX)) {
    return path;
  }
  if (x + anchorX >= w2) {
    if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
      path.splice(3, 1, ["L", x + w2, anchorY - halfDistance], ["L", x + w2 + arrowLength, anchorY], ["L", x + w2, anchorY + halfDistance], ["L", x + w2, y + h - r]);
    } else {
      path.splice(3, 1, ["L", x + w2, h / 2], ["L", anchorX, anchorY], ["L", x + w2, h / 2], ["L", x + w2, y + h - r]);
    }
  } else if (x + anchorX <= 0) {
    if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
      path.splice(7, 1, ["L", x, anchorY + halfDistance], ["L", x - arrowLength, anchorY], ["L", x, anchorY - halfDistance], ["L", x, y + r]);
    } else {
      path.splice(7, 1, ["L", x, h / 2], ["L", anchorX, anchorY], ["L", x, h / 2], ["L", x, y + r]);
    }
  } else if (
    // replace bottom
    anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w2 - safeDistance
  ) {
    path.splice(5, 1, ["L", anchorX + halfDistance, y + h], ["L", anchorX, y + h + arrowLength], ["L", anchorX - halfDistance, y + h], ["L", x + r, y + h]);
  } else if (
    // replace top
    anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w2 - safeDistance
  ) {
    path.splice(1, 1, ["L", anchorX - halfDistance, y], ["L", anchorX, y - arrowLength], ["L", anchorX + halfDistance, y], ["L", w2 - r, y]);
  }
  return path;
}
function circle(x, y, w2, h) {
  return arc(x + w2 / 2, y + h / 2, w2 / 2, h / 2, {
    start: Math.PI * 0.5,
    end: Math.PI * 2.5,
    open: false
  });
}
function diamond(x, y, w2, h) {
  return [
    ["M", x + w2 / 2, y],
    ["L", x + w2, y + h / 2],
    ["L", x + w2 / 2, y + h],
    ["L", x, y + h / 2],
    ["Z"]
  ];
}
function rect(x, y, w2, h, options) {
  if (options && options.r) {
    return roundedRect(x, y, w2, h, options);
  }
  return [
    ["M", x, y],
    ["L", x + w2, y],
    ["L", x + w2, y + h],
    ["L", x, y + h],
    ["Z"]
  ];
}
function roundedRect(x, y, w2, h, options) {
  var r = options && options.r || 0;
  return [
    ["M", x + r, y],
    ["L", x + w2 - r, y],
    ["C", x + w2, y, x + w2, y, x + w2, y + r],
    ["L", x + w2, y + h - r],
    ["C", x + w2, y + h, x + w2, y + h, x + w2 - r, y + h],
    ["L", x + r, y + h],
    ["C", x, y + h, x, y + h, x, y + h - r],
    ["L", x, y + r],
    ["C", x, y, x, y, x + r, y]
    // top-left corner
  ];
}
function triangle(x, y, w2, h) {
  return [
    ["M", x + w2 / 2, y],
    ["L", x + w2, y + h],
    ["L", x, y + h],
    ["Z"]
  ];
}
function triangleDown(x, y, w2, h) {
  return [
    ["M", x, y],
    ["L", x + w2, y],
    ["L", x + w2 / 2, y + h],
    ["Z"]
  ];
}
var Symbols = {
  arc,
  callout,
  circle,
  diamond,
  rect,
  roundedRect,
  square: rect,
  triangle,
  "triangle-down": triangleDown
};
var Symbols_default = Symbols;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/TextBuilder.js
var doc3 = Globals_default.doc;
var SVG_NS3 = Globals_default.SVG_NS;
var attr5 = Utilities_default.attr;
var isString4 = Utilities_default.isString;
var objectEach7 = Utilities_default.objectEach;
var pick9 = Utilities_default.pick;
var TextBuilder = (
  /** @class */
  function() {
    function TextBuilder2(svgElement) {
      var textStyles = svgElement.styles;
      this.renderer = svgElement.renderer;
      this.svgElement = svgElement;
      this.width = svgElement.textWidth;
      this.textLineHeight = textStyles && textStyles.lineHeight;
      this.textOutline = textStyles && textStyles.textOutline;
      this.ellipsis = Boolean(textStyles && textStyles.textOverflow === "ellipsis");
      this.noWrap = Boolean(textStyles && textStyles.whiteSpace === "nowrap");
      this.fontSize = textStyles && textStyles.fontSize;
    }
    TextBuilder2.prototype.buildSVG = function() {
      var wrapper = this.svgElement, textNode = wrapper.element, renderer = wrapper.renderer, textStr = pick9(wrapper.textStr, "").toString(), hasMarkup = textStr.indexOf("<") !== -1, childNodes = textNode.childNodes, tempParent = this.width && !wrapper.added && renderer.box, regexMatchBreaks = /<br.*?>/g, textCache = [
        textStr,
        this.ellipsis,
        this.noWrap,
        this.textLineHeight,
        this.textOutline,
        this.fontSize,
        this.width
      ].join(",");
      if (textCache === wrapper.textCache) {
        return;
      }
      wrapper.textCache = textCache;
      delete wrapper.actualWidth;
      for (var i = childNodes.length; i--; ) {
        textNode.removeChild(childNodes[i]);
      }
      if (!hasMarkup && !this.ellipsis && !this.width && (textStr.indexOf(" ") === -1 || this.noWrap && !regexMatchBreaks.test(textStr))) {
        textNode.appendChild(doc3.createTextNode(this.unescapeEntities(textStr)));
      } else if (textStr !== "") {
        if (tempParent) {
          tempParent.appendChild(textNode);
        }
        var ast = new AST_default(textStr);
        this.modifyTree(ast.nodes);
        ast.addToDOM(wrapper.element);
        this.modifyDOM();
        if (this.ellipsis && (textNode.textContent || "").indexOf("") !== -1) {
          wrapper.attr(
            "title",
            this.unescapeEntities(wrapper.textStr || "", ["&lt;", "&gt;"])
            // #7179
          );
        }
        if (tempParent) {
          tempParent.removeChild(textNode);
        }
      }
      if (isString4(this.textOutline) && wrapper.applyTextOutline) {
        wrapper.applyTextOutline(this.textOutline);
      }
    };
    TextBuilder2.prototype.modifyDOM = function() {
      var _this = this;
      var wrapper = this.svgElement;
      var x = attr5(wrapper.element, "x");
      wrapper.firstLineMetrics = void 0;
      var firstChild;
      while (firstChild = wrapper.element.firstChild) {
        if (/^[\s\u200B]*$/.test(firstChild.textContent || " ")) {
          wrapper.element.removeChild(firstChild);
        } else {
          break;
        }
      }
      [].forEach.call(wrapper.element.querySelectorAll("tspan.highcharts-br"), function(br, i) {
        if (br.nextSibling && br.previousSibling) {
          if (i === 0 && br.previousSibling.nodeType === 1) {
            wrapper.firstLineMetrics = wrapper.renderer.fontMetrics(void 0, br.previousSibling);
          }
          attr5(br, {
            // Since the break is inserted in front of the next
            // line, we need to use the next sibling for the line
            // height
            dy: _this.getLineHeight(br.nextSibling),
            x
          });
        }
      });
      var width = this.width || 0;
      if (!width) {
        return;
      }
      var modifyTextNode = function(textNode, parentElement) {
        var text = textNode.textContent || "";
        var words = text.replace(/([^\^])-/g, "$1- ").split(" ");
        var hasWhiteSpace = !_this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);
        var dy = _this.getLineHeight(parentElement);
        var lineNo = 0;
        var startAt = wrapper.actualWidth;
        if (_this.ellipsis) {
          if (text) {
            _this.truncate(
              textNode,
              text,
              void 0,
              0,
              // Target width
              Math.max(
                0,
                // Substract the font face to make room for the
                // ellipsis itself
                width - parseInt(_this.fontSize || 12, 10)
              ),
              // Build the text to test for
              function(text2, currentIndex) {
                return text2.substring(0, currentIndex) + "";
              }
            );
          }
        } else if (hasWhiteSpace) {
          var lines = [];
          var precedingSiblings = [];
          while (parentElement.firstChild && parentElement.firstChild !== textNode) {
            precedingSiblings.push(parentElement.firstChild);
            parentElement.removeChild(parentElement.firstChild);
          }
          while (words.length) {
            if (words.length && !_this.noWrap && lineNo > 0) {
              lines.push(textNode.textContent || "");
              textNode.textContent = words.join(" ").replace(/- /g, "-");
            }
            _this.truncate(
              textNode,
              void 0,
              words,
              lineNo === 0 ? startAt || 0 : 0,
              width,
              // Build the text to test for
              function(t, currentIndex) {
                return words.slice(0, currentIndex).join(" ").replace(/- /g, "-");
              }
            );
            startAt = wrapper.actualWidth;
            lineNo++;
          }
          precedingSiblings.forEach(function(childNode) {
            parentElement.insertBefore(childNode, textNode);
          });
          lines.forEach(function(line) {
            parentElement.insertBefore(doc3.createTextNode(line), textNode);
            var br = doc3.createElementNS(SVG_NS3, "tspan");
            br.textContent = "";
            attr5(br, { dy, x });
            parentElement.insertBefore(br, textNode);
          });
        }
      };
      var modifyChildren = function(node) {
        var childNodes = [].slice.call(node.childNodes);
        childNodes.forEach(function(childNode) {
          if (childNode.nodeType === Node.TEXT_NODE) {
            modifyTextNode(childNode, node);
          } else {
            if (childNode.className.baseVal.indexOf("highcharts-br") !== -1) {
              wrapper.actualWidth = 0;
            }
            modifyChildren(childNode);
          }
        });
      };
      modifyChildren(wrapper.element);
    };
    TextBuilder2.prototype.getLineHeight = function(node) {
      var fontSizeStyle;
      var element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (!this.renderer.styledMode) {
        fontSizeStyle = element && /(px|em)$/.test(element.style.fontSize) ? element.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12;
      }
      return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(fontSizeStyle, element || this.svgElement.element).h;
    };
    TextBuilder2.prototype.modifyTree = function(nodes) {
      var _this = this;
      var modifyChild = function(node, i) {
        var tagName = node.tagName;
        var styledMode = _this.renderer.styledMode;
        var attributes = node.attributes || {};
        if (tagName === "b" || tagName === "strong") {
          if (styledMode) {
            attributes["class"] = "highcharts-strong";
          } else {
            attributes.style = "font-weight:bold;" + (attributes.style || "");
          }
        } else if (tagName === "i" || tagName === "em") {
          if (styledMode) {
            attributes["class"] = "highcharts-emphasized";
          } else {
            attributes.style = "font-style:italic;" + (attributes.style || "");
          }
        }
        if (isString4(attributes.style)) {
          attributes.style = attributes.style.replace(/(;| |^)color([ :])/, "$1fill$2");
        }
        if (tagName === "br") {
          attributes["class"] = "highcharts-br";
          node.textContent = "";
          var nextNode = nodes[i + 1];
          if (nextNode && nextNode.textContent) {
            nextNode.textContent = nextNode.textContent.replace(/^ +/gm, "");
          }
        }
        if (tagName !== "#text" && tagName !== "a") {
          node.tagName = "tspan";
        }
        node.attributes = attributes;
        if (node.children) {
          node.children.filter(function(c) {
            return c.tagName !== "#text";
          }).forEach(modifyChild);
        }
      };
      nodes.forEach(modifyChild);
    };
    TextBuilder2.prototype.truncate = function(textNode, text, words, startAt, width, getString) {
      var svgElement = this.svgElement;
      var renderer = svgElement.renderer, rotation = svgElement.rotation;
      var lengths = [];
      var minIndex = words ? 1 : 0;
      var maxIndex = (text || words || "").length;
      var currentIndex = maxIndex;
      var str;
      var actualWidth;
      var getSubStringLength = function(charEnd, concatenatedEnd) {
        var end = concatenatedEnd || charEnd;
        var parentNode = textNode.parentNode;
        if (parentNode && typeof lengths[end] === "undefined") {
          if (parentNode.getSubStringLength) {
            try {
              lengths[end] = startAt + parentNode.getSubStringLength(0, words ? end + 1 : end);
            } catch (e2) {
              "";
            }
          } else if (renderer.getSpanWidth) {
            textNode.textContent = getString(text || words, charEnd);
            lengths[end] = startAt + renderer.getSpanWidth(svgElement, textNode);
          }
        }
        return lengths[end];
      };
      svgElement.rotation = 0;
      actualWidth = getSubStringLength(textNode.textContent.length);
      if (startAt + actualWidth > width) {
        while (minIndex <= maxIndex) {
          currentIndex = Math.ceil((minIndex + maxIndex) / 2);
          if (words) {
            str = getString(words, currentIndex);
          }
          actualWidth = getSubStringLength(currentIndex, str && str.length - 1);
          if (minIndex === maxIndex) {
            minIndex = maxIndex + 1;
          } else if (actualWidth > width) {
            maxIndex = currentIndex - 1;
          } else {
            minIndex = currentIndex;
          }
        }
        if (maxIndex === 0) {
          textNode.textContent = "";
        } else if (!(text && maxIndex === text.length - 1)) {
          textNode.textContent = str || getString(text || words, currentIndex);
        }
      }
      if (words) {
        words.splice(0, currentIndex);
      }
      svgElement.actualWidth = actualWidth;
      svgElement.rotation = rotation;
    };
    TextBuilder2.prototype.unescapeEntities = function(inputStr, except) {
      objectEach7(this.renderer.escapes, function(value, key) {
        if (!except || except.indexOf(value) === -1) {
          inputStr = inputStr.toString().replace(new RegExp(value, "g"), key);
        }
      });
      return inputStr;
    };
    return TextBuilder2;
  }()
);
var TextBuilder_default = TextBuilder;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGRenderer.js
var charts2 = Globals_default.charts;
var deg2rad2 = Globals_default.deg2rad;
var doc4 = Globals_default.doc;
var isFirefox = Globals_default.isFirefox;
var isMS = Globals_default.isMS;
var isWebKit = Globals_default.isWebKit;
var noop2 = Globals_default.noop;
var SVG_NS4 = Globals_default.SVG_NS;
var symbolSizes = Globals_default.symbolSizes;
var win6 = Globals_default.win;
var addEvent3 = Utilities_default.addEvent;
var attr6 = Utilities_default.attr;
var createElement4 = Utilities_default.createElement;
var css4 = Utilities_default.css;
var defined7 = Utilities_default.defined;
var destroyObjectProperties2 = Utilities_default.destroyObjectProperties;
var extend5 = Utilities_default.extend;
var isArray4 = Utilities_default.isArray;
var isNumber9 = Utilities_default.isNumber;
var isObject4 = Utilities_default.isObject;
var isString5 = Utilities_default.isString;
var merge8 = Utilities_default.merge;
var pick10 = Utilities_default.pick;
var pInt5 = Utilities_default.pInt;
var uniqueKey3 = Utilities_default.uniqueKey;
var hasInternalReferenceBug;
var SVGRenderer = (
  /** @class */
  function() {
    function SVGRenderer2(container, width, height, style, forExport, allowHTML, styledMode) {
      this.alignedObjects = void 0;
      this.box = void 0;
      this.boxWrapper = void 0;
      this.cache = void 0;
      this.cacheKeys = void 0;
      this.chartIndex = void 0;
      this.defs = void 0;
      this.globalAnimation = void 0;
      this.gradients = void 0;
      this.height = void 0;
      this.imgCount = void 0;
      this.isSVG = void 0;
      this.style = void 0;
      this.url = void 0;
      this.width = void 0;
      this.init(container, width, height, style, forExport, allowHTML, styledMode);
    }
    SVGRenderer2.prototype.init = function(container, width, height, style, forExport, allowHTML, styledMode) {
      var renderer = this, boxWrapper = renderer.createElement("svg").attr({
        version: "1.1",
        "class": "highcharts-root"
      }), element = boxWrapper.element;
      if (!styledMode) {
        boxWrapper.css(this.getStyle(style));
      }
      container.appendChild(element);
      attr6(container, "dir", "ltr");
      if (container.innerHTML.indexOf("xmlns") === -1) {
        attr6(element, "xmlns", this.SVG_NS);
      }
      renderer.isSVG = true;
      this.box = element;
      this.boxWrapper = boxWrapper;
      renderer.alignedObjects = [];
      this.url = this.getReferenceURL();
      var desc = this.createElement("desc").add();
      desc.element.appendChild(doc4.createTextNode("Created with Highcharts 9.2.2"));
      renderer.defs = this.createElement("defs").add();
      renderer.allowHTML = allowHTML;
      renderer.forExport = forExport;
      renderer.styledMode = styledMode;
      renderer.gradients = {};
      renderer.cache = {};
      renderer.cacheKeys = [];
      renderer.imgCount = 0;
      renderer.setSize(width, height, false);
      var subPixelFix, rect2;
      if (isFirefox && container.getBoundingClientRect) {
        subPixelFix = function() {
          css4(container, { left: 0, top: 0 });
          rect2 = container.getBoundingClientRect();
          css4(container, {
            left: Math.ceil(rect2.left) - rect2.left + "px",
            top: Math.ceil(rect2.top) - rect2.top + "px"
          });
        };
        subPixelFix();
        renderer.unSubPixelFix = addEvent3(win6, "resize", subPixelFix);
      }
    };
    SVGRenderer2.prototype.definition = function(def) {
      var ast = new AST_default([def]);
      return ast.addToDOM(this.defs.element);
    };
    SVGRenderer2.prototype.getReferenceURL = function() {
      if ((isFirefox || isWebKit) && doc4.getElementsByTagName("base").length) {
        if (!defined7(hasInternalReferenceBug)) {
          var id = uniqueKey3();
          var ast = new AST_default([{
            tagName: "svg",
            attributes: {
              width: 8,
              height: 8
            },
            children: [{
              tagName: "defs",
              children: [{
                tagName: "clipPath",
                attributes: {
                  id
                },
                children: [{
                  tagName: "rect",
                  attributes: {
                    width: 4,
                    height: 4
                  }
                }]
              }]
            }, {
              tagName: "rect",
              attributes: {
                id: "hitme",
                width: 8,
                height: 8,
                "clip-path": "url(#" + id + ")",
                fill: "rgba(0,0,0,0.001)"
              }
            }]
          }]);
          var svg7 = ast.addToDOM(doc4.body);
          css4(svg7, {
            position: "fixed",
            top: 0,
            left: 0,
            zIndex: 9e5
          });
          var hitElement = doc4.elementFromPoint(6, 6);
          hasInternalReferenceBug = (hitElement && hitElement.id) === "hitme";
          doc4.body.removeChild(svg7);
        }
        if (hasInternalReferenceBug) {
          return win6.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
        }
      }
      return "";
    };
    SVGRenderer2.prototype.getStyle = function(style) {
      this.style = extend5({
        fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
        fontSize: "12px"
      }, style);
      return this.style;
    };
    SVGRenderer2.prototype.setStyle = function(style) {
      this.boxWrapper.css(this.getStyle(style));
    };
    SVGRenderer2.prototype.isHidden = function() {
      return !this.boxWrapper.getBBox().width;
    };
    SVGRenderer2.prototype.destroy = function() {
      var renderer = this, rendererDefs = renderer.defs;
      renderer.box = null;
      renderer.boxWrapper = renderer.boxWrapper.destroy();
      destroyObjectProperties2(renderer.gradients || {});
      renderer.gradients = null;
      if (rendererDefs) {
        renderer.defs = rendererDefs.destroy();
      }
      if (renderer.unSubPixelFix) {
        renderer.unSubPixelFix();
      }
      renderer.alignedObjects = null;
      return null;
    };
    SVGRenderer2.prototype.createElement = function(nodeName) {
      var wrapper = new this.Element();
      wrapper.init(this, nodeName);
      return wrapper;
    };
    SVGRenderer2.prototype.getRadialAttr = function(radialReference, gradAttr) {
      return {
        cx: radialReference[0] - radialReference[2] / 2 + (gradAttr.cx || 0) * radialReference[2],
        cy: radialReference[1] - radialReference[2] / 2 + (gradAttr.cy || 0) * radialReference[2],
        r: (gradAttr.r || 0) * radialReference[2]
      };
    };
    SVGRenderer2.prototype.buildText = function(wrapper) {
      new TextBuilder_default(wrapper).buildSVG();
    };
    SVGRenderer2.prototype.getContrast = function(rgba) {
      rgba = Color_default.parse(rgba).rgba;
      rgba[0] *= 1;
      rgba[1] *= 1.2;
      rgba[2] *= 0.5;
      return rgba[0] + rgba[1] + rgba[2] > 1.8 * 255 ? "#000000" : "#FFFFFF";
    };
    SVGRenderer2.prototype.button = function(text, x, y, callback, theme2, hoverState, pressedState, disabledState, shape, useHTML) {
      var label = this.label(text, x, y, shape, void 0, void 0, useHTML, void 0, "button"), styledMode = this.styledMode;
      var curState = 0, normalState = theme2 ? merge8(theme2) : {};
      var userNormalStyle = normalState && normalState.style || {};
      normalState = AST_default.filterUserAttributes(normalState);
      label.attr(merge8({ padding: 8, r: 2 }, normalState));
      var normalStyle, hoverStyle, pressedStyle, disabledStyle;
      if (!styledMode) {
        normalState = merge8({
          fill: Palette_default.neutralColor3,
          stroke: Palette_default.neutralColor20,
          "stroke-width": 1,
          style: {
            color: Palette_default.neutralColor80,
            cursor: "pointer",
            fontWeight: "normal"
          }
        }, {
          style: userNormalStyle
        }, normalState);
        normalStyle = normalState.style;
        delete normalState.style;
        hoverState = merge8(normalState, {
          fill: Palette_default.neutralColor10
        }, AST_default.filterUserAttributes(hoverState || {}));
        hoverStyle = hoverState.style;
        delete hoverState.style;
        pressedState = merge8(normalState, {
          fill: Palette_default.highlightColor10,
          style: {
            color: Palette_default.neutralColor100,
            fontWeight: "bold"
          }
        }, AST_default.filterUserAttributes(pressedState || {}));
        pressedStyle = pressedState.style;
        delete pressedState.style;
        disabledState = merge8(normalState, {
          style: {
            color: Palette_default.neutralColor20
          }
        }, AST_default.filterUserAttributes(disabledState || {}));
        disabledStyle = disabledState.style;
        delete disabledState.style;
      }
      addEvent3(label.element, isMS ? "mouseover" : "mouseenter", function() {
        if (curState !== 3) {
          label.setState(1);
        }
      });
      addEvent3(label.element, isMS ? "mouseout" : "mouseleave", function() {
        if (curState !== 3) {
          label.setState(curState);
        }
      });
      label.setState = function(state) {
        if (state !== 1) {
          label.state = curState = state;
        }
        label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][state || 0]);
        if (!styledMode) {
          label.attr([
            normalState,
            hoverState,
            pressedState,
            disabledState
          ][state || 0]).css([
            normalStyle,
            hoverStyle,
            pressedStyle,
            disabledStyle
          ][state || 0]);
        }
      };
      if (!styledMode) {
        label.attr(normalState).css(extend5({ cursor: "default" }, normalStyle));
      }
      return label.on("touchstart", function(e2) {
        return e2.stopPropagation();
      }).on("click", function(e2) {
        if (curState !== 3) {
          callback.call(label, e2);
        }
      });
    };
    SVGRenderer2.prototype.crispLine = function(points, width, roundingFunction) {
      if (roundingFunction === void 0) {
        roundingFunction = "round";
      }
      var start = points[0];
      var end = points[1];
      if (defined7(start[1]) && start[1] === end[1]) {
        start[1] = end[1] = Math[roundingFunction](start[1]) - width % 2 / 2;
      }
      if (defined7(start[2]) && start[2] === end[2]) {
        start[2] = end[2] = Math[roundingFunction](start[2]) + width % 2 / 2;
      }
      return points;
    };
    SVGRenderer2.prototype.path = function(path) {
      var attribs = this.styledMode ? {} : {
        fill: "none"
      };
      if (isArray4(path)) {
        attribs.d = path;
      } else if (isObject4(path)) {
        extend5(attribs, path);
      }
      return this.createElement("path").attr(attribs);
    };
    SVGRenderer2.prototype.circle = function(x, y, r) {
      var attribs = isObject4(x) ? x : typeof x === "undefined" ? {} : { x, y, r }, wrapper = this.createElement("circle");
      wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
        element.setAttribute("c" + key, value);
      };
      return wrapper.attr(attribs);
    };
    SVGRenderer2.prototype.arc = function(x, y, r, innerR, start, end) {
      var options;
      if (isObject4(x)) {
        options = x;
        y = options.y;
        r = options.r;
        innerR = options.innerR;
        start = options.start;
        end = options.end;
        x = options.x;
      } else {
        options = { innerR, start, end };
      }
      var arc3 = this.symbol("arc", x, y, r, r, options);
      arc3.r = r;
      return arc3;
    };
    SVGRenderer2.prototype.rect = function(x, y, width, height, r, strokeWidth) {
      r = isObject4(x) ? x.r : r;
      var wrapper = this.createElement("rect");
      var attribs = isObject4(x) ? x : typeof x === "undefined" ? {} : {
        x,
        y,
        width: Math.max(width, 0),
        height: Math.max(height, 0)
      };
      if (!this.styledMode) {
        if (typeof strokeWidth !== "undefined") {
          attribs["stroke-width"] = strokeWidth;
          attribs = wrapper.crisp(attribs);
        }
        attribs.fill = "none";
      }
      if (r) {
        attribs.r = r;
      }
      wrapper.rSetter = function(value, _key, element) {
        wrapper.r = value;
        attr6(element, {
          rx: value,
          ry: value
        });
      };
      wrapper.rGetter = function() {
        return wrapper.r || 0;
      };
      return wrapper.attr(attribs);
    };
    SVGRenderer2.prototype.setSize = function(width, height, animate4) {
      var renderer = this;
      renderer.width = width;
      renderer.height = height;
      renderer.boxWrapper.animate({
        width,
        height
      }, {
        step: function() {
          this.attr({
            viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
          });
        },
        duration: pick10(animate4, true) ? void 0 : 0
      });
      renderer.alignElements();
    };
    SVGRenderer2.prototype.g = function(name) {
      var elem = this.createElement("g");
      return name ? elem.attr({ "class": "highcharts-" + name }) : elem;
    };
    SVGRenderer2.prototype.image = function(src, x, y, width, height, onload) {
      var attribs = { preserveAspectRatio: "none" }, setSVGImageSource = function(el, src2) {
        if (el.setAttributeNS) {
          el.setAttributeNS("http://www.w3.org/1999/xlink", "href", src2);
        } else {
          el.setAttribute("hc-svg-href", src2);
        }
      };
      if (arguments.length > 1) {
        extend5(attribs, {
          x,
          y,
          width,
          height
        });
      }
      var elemWrapper = this.createElement("image").attr(attribs), onDummyLoad = function(e2) {
        setSVGImageSource(elemWrapper.element, src);
        onload.call(elemWrapper, e2);
      };
      if (onload) {
        setSVGImageSource(
          elemWrapper.element,
          "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
          /* eslint-disable-line */
        );
        var dummy = new win6.Image();
        addEvent3(dummy, "load", onDummyLoad);
        dummy.src = src;
        if (dummy.complete) {
          onDummyLoad({});
        }
      } else {
        setSVGImageSource(elemWrapper.element, src);
      }
      return elemWrapper;
    };
    SVGRenderer2.prototype.symbol = function(symbol, x, y, width, height, options) {
      var ren = this, imageRegex = /^url\((.*?)\)$/, isImage = imageRegex.test(symbol), sym = !isImage && (this.symbols[symbol] ? symbol : "circle"), symbolFn = sym && this.symbols[sym];
      var obj, path, imageSrc, centerImage;
      if (symbolFn) {
        if (typeof x === "number") {
          path = symbolFn.call(this.symbols, Math.round(x || 0), Math.round(y || 0), width || 0, height || 0, options);
        }
        obj = this.path(path);
        if (!ren.styledMode) {
          obj.attr("fill", "none");
        }
        extend5(obj, {
          symbolName: sym || void 0,
          x,
          y,
          width,
          height
        });
        if (options) {
          extend5(obj, options);
        }
      } else if (isImage) {
        imageSrc = symbol.match(imageRegex)[1];
        var img_1 = obj = this.image(imageSrc);
        img_1.imgwidth = pick10(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);
        img_1.imgheight = pick10(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);
        centerImage = function(obj2) {
          return obj2.attr({
            width: obj2.width,
            height: obj2.height
          });
        };
        ["width", "height"].forEach(function(key) {
          img_1[key + "Setter"] = function(value, key2) {
            var imgSize = this["img" + key2];
            this[key2] = value;
            if (defined7(imgSize)) {
              if (options && options.backgroundSize === "within" && this.width && this.height) {
                imgSize = Math.round(imgSize * Math.min(this.width / this.imgwidth, this.height / this.imgheight));
              }
              if (this.element) {
                this.element.setAttribute(key2, imgSize);
              }
              if (!this.alignByTranslate) {
                var translate = ((this[key2] || 0) - imgSize) / 2;
                var attribs = key2 === "width" ? { translateX: translate } : { translateY: translate };
                this.attr(attribs);
              }
            }
          };
        });
        if (defined7(x)) {
          img_1.attr({
            x,
            y
          });
        }
        img_1.isImg = true;
        if (defined7(img_1.imgwidth) && defined7(img_1.imgheight)) {
          centerImage(img_1);
        } else {
          img_1.attr({ width: 0, height: 0 });
          createElement4("img", {
            onload: function() {
              var chart = charts2[ren.chartIndex];
              if (this.width === 0) {
                css4(this, {
                  position: "absolute",
                  top: "-999em"
                });
                doc4.body.appendChild(this);
              }
              symbolSizes[imageSrc] = {
                width: this.width,
                height: this.height
              };
              img_1.imgwidth = this.width;
              img_1.imgheight = this.height;
              if (img_1.element) {
                centerImage(img_1);
              }
              if (this.parentNode) {
                this.parentNode.removeChild(this);
              }
              ren.imgCount--;
              if (!ren.imgCount && chart && !chart.hasLoaded) {
                chart.onload();
              }
            },
            src: imageSrc
          });
          this.imgCount++;
        }
      }
      return obj;
    };
    SVGRenderer2.prototype.clipRect = function(x, y, width, height) {
      var id = uniqueKey3() + "-", clipPath = this.createElement("clipPath").attr({
        id
      }).add(this.defs), wrapper = this.rect(x, y, width, height, 0).add(clipPath);
      wrapper.id = id;
      wrapper.clipPath = clipPath;
      wrapper.count = 0;
      return wrapper;
    };
    SVGRenderer2.prototype.text = function(str, x, y, useHTML) {
      var renderer = this, attribs = {};
      if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
        return renderer.html(str, x, y);
      }
      attribs.x = Math.round(x || 0);
      if (y) {
        attribs.y = Math.round(y);
      }
      if (defined7(str)) {
        attribs.text = str;
      }
      var wrapper = renderer.createElement("text").attr(attribs);
      if (!useHTML || renderer.forExport && !renderer.allowHTML) {
        wrapper.xSetter = function(value, key, element) {
          var tspans = element.getElementsByTagName("tspan"), parentVal = element.getAttribute(key);
          for (var i = 0, tspan = void 0; i < tspans.length; i++) {
            tspan = tspans[i];
            if (tspan.getAttribute(key) === parentVal) {
              tspan.setAttribute(key, value);
            }
          }
          element.setAttribute(key, value);
        };
      }
      return wrapper;
    };
    SVGRenderer2.prototype.fontMetrics = function(fontSize, elem) {
      if ((this.styledMode || !/px/.test(fontSize)) && win6.getComputedStyle) {
        fontSize = elem && SVGElement_default.prototype.getStyle.call(elem, "font-size");
      } else {
        fontSize = fontSize || // When the elem is a DOM element (#5932)
        elem && elem.style && elem.style.fontSize || // Fall back on the renderer style default
        this.style && this.style.fontSize;
      }
      if (/px/.test(fontSize)) {
        fontSize = pInt5(fontSize);
      } else {
        fontSize = 12;
      }
      var lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2), baseline = Math.round(lineHeight * 0.8);
      return {
        h: lineHeight,
        b: baseline,
        f: fontSize
      };
    };
    SVGRenderer2.prototype.rotCorr = function(baseline, rotation, alterY) {
      var y = baseline;
      if (rotation && alterY) {
        y = Math.max(y * Math.cos(rotation * deg2rad2), 4);
      }
      return {
        x: -baseline / 3 * Math.sin(rotation * deg2rad2),
        y
      };
    };
    SVGRenderer2.prototype.pathToSegments = function(path) {
      var ret = [];
      var segment = [];
      var commandLength = {
        A: 8,
        C: 7,
        H: 2,
        L: 3,
        M: 3,
        Q: 5,
        S: 5,
        T: 3,
        V: 2
      };
      for (var i = 0; i < path.length; i++) {
        if (isString5(segment[0]) && isNumber9(path[i]) && segment.length === commandLength[segment[0].toUpperCase()]) {
          path.splice(i, 0, segment[0].replace("M", "L").replace("m", "l"));
        }
        if (typeof path[i] === "string") {
          if (segment.length) {
            ret.push(segment.slice(0));
          }
          segment.length = 0;
        }
        segment.push(path[i]);
      }
      ret.push(segment.slice(0));
      return ret;
    };
    SVGRenderer2.prototype.label = function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
      return new SVGLabel_default(this, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className);
    };
    SVGRenderer2.prototype.alignElements = function() {
      this.alignedObjects.forEach(function(el) {
        return el.align();
      });
    };
    return SVGRenderer2;
  }()
);
extend5(SVGRenderer.prototype, {
  /**
   * A pointer to the renderer's associated Element class. The VMLRenderer
   * will have a pointer to VMLElement here.
   *
   * @name Highcharts.SVGRenderer#Element
   * @type {Highcharts.SVGElement}
   */
  Element: SVGElement_default,
  SVG_NS: SVG_NS4,
  /**
   * A collection of characters mapped to HTML entities. When `useHTML` on an
   * element is true, these entities will be rendered correctly by HTML. In
   * the SVG pseudo-HTML, they need to be unescaped back to simple characters,
   * so for example `&lt;` will render as `<`.
   *
   * @example
   * // Add support for unescaping quotes
   * Highcharts.SVGRenderer.prototype.escapes['"'] = '&quot;';
   *
   * @name Highcharts.SVGRenderer#escapes
   * @type {Highcharts.Dictionary<string>}
   */
  escapes: {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "'": "&#39;",
    '"': "&quot;"
  },
  /**
   * An extendable collection of functions for defining symbol paths.
   *
   * @name Highcharts.SVGRenderer#symbols
   * @type {Highcharts.SymbolDictionary}
   */
  symbols: Symbols_default,
  /**
   * Dummy function for plugins, called every time the renderer is updated.
   * Prior to Highcharts 5, this was used for the canvg renderer.
   *
   * @deprecated
   * @function Highcharts.SVGRenderer#draw
   */
  draw: noop2
});
RendererRegistry_default.registerRendererType("svg", SVGRenderer, true);
var SVGRenderer_default = SVGRenderer;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/HTMLElement.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var isFirefox2 = Globals_default.isFirefox;
var isMS2 = Globals_default.isMS;
var isWebKit2 = Globals_default.isWebKit;
var win7 = Globals_default.win;
var css5 = Utilities_default.css;
var defined8 = Utilities_default.defined;
var extend6 = Utilities_default.extend;
var pick11 = Utilities_default.pick;
var pInt6 = Utilities_default.pInt;
var HTMLElement = (
  /** @class */
  function(_super) {
    __extends2(HTMLElement2, _super);
    function HTMLElement2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HTMLElement2.compose = function(SVGElementClass) {
      if (HTMLElement2.composedClasses.indexOf(SVGElementClass) === -1) {
        HTMLElement2.composedClasses.push(SVGElementClass);
        var htmlElementProto = HTMLElement2.prototype, svgElementProto = SVGElementClass.prototype;
        svgElementProto.getSpanCorrection = htmlElementProto.getSpanCorrection;
        svgElementProto.htmlCss = htmlElementProto.htmlCss;
        svgElementProto.htmlGetBBox = htmlElementProto.htmlGetBBox;
        svgElementProto.htmlUpdateTransform = htmlElementProto.htmlUpdateTransform;
        svgElementProto.setSpanRotation = htmlElementProto.setSpanRotation;
      }
      return SVGElementClass;
    };
    HTMLElement2.prototype.getSpanCorrection = function(width, baseline, alignCorrection) {
      this.xCorr = -width * alignCorrection;
      this.yCorr = -baseline;
    };
    HTMLElement2.prototype.htmlCss = function(styles) {
      var wrapper = this, element = wrapper.element, isSettingWidth = element.tagName === "SPAN" && styles && "width" in styles, textWidth = pick11(isSettingWidth && styles.width, void 0);
      var doTransform;
      if (isSettingWidth) {
        delete styles.width;
        wrapper.textWidth = textWidth;
        doTransform = true;
      }
      if (styles && styles.textOverflow === "ellipsis") {
        styles.whiteSpace = "nowrap";
        styles.overflow = "hidden";
      }
      wrapper.styles = extend6(wrapper.styles, styles);
      css5(wrapper.element, styles);
      if (doTransform) {
        wrapper.htmlUpdateTransform();
      }
      return wrapper;
    };
    HTMLElement2.prototype.htmlGetBBox = function() {
      var wrapper = this, element = wrapper.element;
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: element.offsetWidth,
        height: element.offsetHeight
      };
    };
    HTMLElement2.prototype.htmlUpdateTransform = function() {
      if (!this.added) {
        this.alignOnAdd = true;
        return;
      }
      var wrapper = this, renderer = wrapper.renderer, elem = wrapper.element, translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0, x = wrapper.x || 0, y = wrapper.y || 0, align = wrapper.textAlign || "left", alignCorrection = {
        left: 0,
        center: 0.5,
        right: 1
      }[align], styles = wrapper.styles, whiteSpace = styles && styles.whiteSpace;
      function getTextPxLength() {
        css5(elem, {
          width: "",
          whiteSpace: whiteSpace || "nowrap"
        });
        return elem.offsetWidth;
      }
      css5(elem, {
        marginLeft: translateX,
        marginTop: translateY
      });
      if (!renderer.styledMode && wrapper.shadows) {
        wrapper.shadows.forEach(function(shadow) {
          css5(shadow, {
            marginLeft: translateX + 1,
            marginTop: translateY + 1
          });
        });
      }
      if (wrapper.inverted) {
        [].forEach.call(elem.childNodes, function(child) {
          renderer.invertChild(child, elem);
        });
      }
      if (elem.tagName === "SPAN") {
        var rotation = wrapper.rotation, textWidth = wrapper.textWidth && pInt6(wrapper.textWidth), currentTextTransform = [
          rotation,
          align,
          elem.innerHTML,
          wrapper.textWidth,
          wrapper.textAlign
        ].join(",");
        var baseline = void 0;
        if (textWidth !== wrapper.oldTextWidth && (textWidth > wrapper.oldTextWidth || (wrapper.textPxLength || getTextPxLength()) > textWidth) && // Only set the width if the text is able to word-wrap, or
        // text-overflow is ellipsis (#9537)
        (/[ \-]/.test(elem.textContent || elem.innerText) || elem.style.textOverflow === "ellipsis")) {
          css5(elem, {
            width: textWidth + "px",
            display: "block",
            whiteSpace: whiteSpace || "normal"
            // #3331
          });
          wrapper.oldTextWidth = textWidth;
          wrapper.hasBoxWidthChanged = true;
        } else {
          wrapper.hasBoxWidthChanged = false;
        }
        if (currentTextTransform !== wrapper.cTT) {
          baseline = renderer.fontMetrics(elem.style.fontSize, elem).b;
          if (defined8(rotation) && (rotation !== (wrapper.oldRotation || 0) || align !== wrapper.oldAlign)) {
            wrapper.setSpanRotation(rotation, alignCorrection, baseline);
          }
          wrapper.getSpanCorrection(
            // Avoid elem.offsetWidth if we can, it affects rendering
            // time heavily (#7656)
            !defined8(rotation) && wrapper.textPxLength || // #7920
            elem.offsetWidth,
            baseline,
            alignCorrection,
            rotation,
            align
          );
        }
        css5(elem, {
          left: x + (wrapper.xCorr || 0) + "px",
          top: y + (wrapper.yCorr || 0) + "px"
        });
        wrapper.cTT = currentTextTransform;
        wrapper.oldRotation = rotation;
        wrapper.oldAlign = align;
      }
    };
    HTMLElement2.prototype.setSpanRotation = function(rotation, alignCorrection, baseline) {
      var getTransformKey = function() {
        return isMS2 && !/Edge/.test(win7.navigator.userAgent) ? "-ms-transform" : isWebKit2 ? "-webkit-transform" : isFirefox2 ? "MozTransform" : win7.opera ? "-o-transform" : void 0;
      };
      var rotationStyle = {}, cssTransformKey = getTransformKey();
      if (cssTransformKey) {
        rotationStyle[cssTransformKey] = rotationStyle.transform = "rotate(" + rotation + "deg)";
        rotationStyle[cssTransformKey + (isFirefox2 ? "Origin" : "-origin")] = rotationStyle.transformOrigin = alignCorrection * 100 + "% " + baseline + "px";
        css5(this.element, rotationStyle);
      }
    };
    HTMLElement2.composedClasses = [];
    return HTMLElement2;
  }(SVGElement_default)
);
var HTMLElement_default = HTMLElement;

// node_modules/highcharts/es-modules/Core/Renderer/HTML/HTMLRenderer.js
var __extends3 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var attr7 = Utilities_default.attr;
var createElement5 = Utilities_default.createElement;
var extend7 = Utilities_default.extend;
var pick12 = Utilities_default.pick;
var HTMLRenderer = (
  /** @class */
  function(_super) {
    __extends3(HTMLRenderer2, _super);
    function HTMLRenderer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HTMLRenderer2.compose = function(SVGRendererClass) {
      if (HTMLRenderer2.composedClasses.indexOf(SVGRendererClass) === -1) {
        HTMLRenderer2.composedClasses.push(SVGRendererClass);
        var htmlRendererProto = HTMLRenderer2.prototype, svgRendererProto = SVGRendererClass.prototype;
        svgRendererProto.html = htmlRendererProto.html;
      }
      return SVGRendererClass;
    };
    HTMLRenderer2.prototype.html = function(str, x, y) {
      var wrapper = this.createElement("span"), element = wrapper.element, renderer = wrapper.renderer, isSVG = renderer.isSVG, addSetters = function(gWrapper, style) {
        ["opacity", "visibility"].forEach(function(prop) {
          gWrapper[prop + "Setter"] = function(value, key, elem) {
            var styleObject = gWrapper.div ? gWrapper.div.style : style;
            SVGElement_default.prototype[prop + "Setter"].call(this, value, key, elem);
            if (styleObject) {
              styleObject[key] = value;
            }
          };
        });
        gWrapper.addedSetters = true;
      };
      wrapper.textSetter = function(value) {
        if (value !== this.textStr) {
          delete this.bBox;
          delete this.oldTextWidth;
          AST_default.setElementHTML(this.element, pick12(value, ""));
          this.textStr = value;
          wrapper.doTransform = true;
        }
      };
      if (isSVG) {
        addSetters(wrapper, wrapper.element.style);
      }
      wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function(value, key) {
        if (key === "align") {
          wrapper.alignValue = wrapper.textAlign = value;
        } else {
          wrapper[key] = value;
        }
        wrapper.doTransform = true;
      };
      wrapper.afterSetters = function() {
        if (this.doTransform) {
          this.htmlUpdateTransform();
          this.doTransform = false;
        }
      };
      wrapper.attr({
        text: str,
        x: Math.round(x),
        y: Math.round(y)
      }).css({
        position: "absolute"
      });
      if (!renderer.styledMode) {
        wrapper.css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
      }
      element.style.whiteSpace = "nowrap";
      wrapper.css = wrapper.htmlCss;
      if (isSVG) {
        wrapper.add = function(svgGroupWrapper) {
          var container = renderer.box.parentNode, parents = [];
          var htmlGroup, parentGroup;
          this.parentGroup = svgGroupWrapper;
          if (svgGroupWrapper) {
            htmlGroup = svgGroupWrapper.div;
            if (!htmlGroup) {
              parentGroup = svgGroupWrapper;
              while (parentGroup) {
                parents.push(parentGroup);
                parentGroup = parentGroup.parentGroup;
              }
              parents.reverse().forEach(function(parentGroup2) {
                var cls = attr7(parentGroup2.element, "class");
                function translateSetter(value, key) {
                  parentGroup2[key] = value;
                  if (key === "translateX") {
                    htmlGroupStyle.left = value + "px";
                  } else {
                    htmlGroupStyle.top = value + "px";
                  }
                  parentGroup2.doTransform = true;
                }
                var parentGroupStyles = parentGroup2.styles || {};
                htmlGroup = parentGroup2.div = parentGroup2.div || createElement5("div", cls ? { className: cls } : void 0, {
                  position: "absolute",
                  left: (parentGroup2.translateX || 0) + "px",
                  top: (parentGroup2.translateY || 0) + "px",
                  display: parentGroup2.display,
                  opacity: parentGroup2.opacity,
                  cursor: parentGroupStyles.cursor,
                  pointerEvents: parentGroupStyles.pointerEvents,
                  visibility: parentGroup2.visibility
                  // the top group is appended to container
                }, htmlGroup || container);
                var htmlGroupStyle = htmlGroup.style;
                extend7(parentGroup2, {
                  // (#7287) Pass htmlGroup to use
                  // the related group
                  classSetter: /* @__PURE__ */ function(htmlGroup2) {
                    return function(value) {
                      this.element.setAttribute("class", value);
                      htmlGroup2.className = value;
                    };
                  }(htmlGroup),
                  on: function() {
                    if (parents[0].div) {
                      wrapper.on.apply({
                        element: parents[0].div,
                        onEvents: parentGroup2.onEvents
                      }, arguments);
                    }
                    return parentGroup2;
                  },
                  translateXSetter: translateSetter,
                  translateYSetter: translateSetter
                });
                if (!parentGroup2.addedSetters) {
                  addSetters(parentGroup2);
                }
              });
            }
          } else {
            htmlGroup = container;
          }
          htmlGroup.appendChild(element);
          wrapper.added = true;
          if (wrapper.alignOnAdd) {
            wrapper.htmlUpdateTransform();
          }
          return wrapper;
        };
      }
      return wrapper;
    };
    HTMLRenderer2.composedClasses = [];
    return HTMLRenderer2;
  }(SVGRenderer_default)
);
var HTMLRenderer_default = HTMLRenderer;

// node_modules/highcharts/es-modules/Core/Axis/AxisDefaults.js
var AxisDefaults;
(function(AxisDefaults2) {
  AxisDefaults2.defaultXAxisOptions = {
    /**
     * When using multiple axis, the ticks of two or more opposite axes
     * will automatically be aligned by adding ticks to the axis or axes
     * with the least ticks, as if `tickAmount` were specified.
     *
     * This can be prevented by setting `alignTicks` to false. If the grid
     * lines look messy, it's a good idea to hide them for the secondary
     * axis by setting `gridLineWidth` to 0.
     *
     * If `startOnTick` or `endOnTick` in an Axis options are set to false,
     * then the `alignTicks ` will be disabled for the Axis.
     *
     * Disabled for logarithmic axes.
     *
     * @product   highcharts highstock gantt
     */
    alignTicks: true,
    /**
     * Whether to allow decimals in this axis' ticks. When counting
     * integers, like persons or hits on a web page, decimals should
     * be avoided in the labels. By default, decimals are allowed on small
     * scale axes.
     *
     * @see [minTickInterval](#xAxis.minTickInterval)
     *
     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/
     *         True by default
     * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/
     *         False
     *
     * @type      {boolean|undefined}
     * @default   undefined
     * @since     2.0
     */
    allowDecimals: void 0,
    /**
     * When using an alternate grid color, a band is painted across the
     * plot area between every other grid line.
     *
     * @sample {highcharts} highcharts/yaxis/alternategridcolor/
     *         Alternate grid color on the Y axis
     * @sample {highstock} stock/xaxis/alternategridcolor/
     *         Alternate grid color on the Y axis
     *
     * @type      {Highcharts.ColorType}
     * @apioption xAxis.alternateGridColor
     */
    /**
     * An array defining breaks in the axis, the sections defined will be
     * left out and all the points shifted closer to each other.
     *
     * @productdesc {highcharts}
     * Requires that the broken-axis.js module is loaded.
     *
     * @sample {highcharts} highcharts/axisbreak/break-simple/
     *         Simple break
     * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/
     *         Advanced with callback
     * @sample {highstock} stock/demo/intraday-breaks/
     *         Break on nights and weekends
     *
     * @type      {Array<*>}
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks
     */
    /**
     * A number indicating how much space should be left between the start
     * and the end of the break. The break size is given in axis units,
     * so for instance on a `datetime` axis, a break size of 3600000 would
     * indicate the equivalent of an hour.
     *
     * @type      {number}
     * @default   0
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks.breakSize
     */
    /**
     * The point where the break starts.
     *
     * @type      {number}
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks.from
     */
    /**
     * Defines an interval after which the break appears again. By default
     * the breaks do not repeat.
     *
     * @type      {number}
     * @default   0
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks.repeat
     */
    /**
     * The point where the break ends.
     *
     * @type      {number}
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.breaks.to
     */
    /**
     * If categories are present for the xAxis, names are used instead of
     * numbers for that axis.
     *
     * Since Highcharts 3.0, categories can also
     * be extracted by giving each point a [name](#series.data) and setting
     * axis [type](#xAxis.type) to `category`. However, if you have multiple
     * series, best practice remains defining the `categories` array.
     *
     * Example: `categories: ['Apples', 'Bananas', 'Oranges']`
     *
     * @sample {highcharts} highcharts/demo/line-labels/
     *         With
     * @sample {highcharts} highcharts/xaxis/categories/
     *         Without
     *
     * @type      {Array<string>}
     * @product   highcharts gantt
     * @apioption xAxis.categories
     */
    /**
     * The highest allowed value for automatically computed axis extremes.
     *
     * @see [floor](#xAxis.floor)
     *
     * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/
     *         Floor and ceiling
     *
     * @type       {number}
     * @since      4.0
     * @product    highcharts highstock gantt
     * @apioption  xAxis.ceiling
     */
    /**
     * A class name that opens for styling the axis by CSS, especially in
     * Highcharts styled mode. The class name is applied to group elements
     * for the grid, axis elements and labels.
     *
     * @sample {highcharts|highstock|highmaps} highcharts/css/axis/
     *         Multiple axes with separate styling
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption xAxis.className
     */
    /**
     * Configure a crosshair that follows either the mouse pointer or the
     * hovered point.
     *
     * In styled mode, the crosshairs are styled in the
     * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or
     * `.highcharts-xaxis-category` classes.
     *
     * @productdesc {highstock}
     * In Highcharts stock, by default, the crosshair is enabled on the
     * X axis and disabled on the Y axis.
     *
     * @sample {highcharts} highcharts/xaxis/crosshair-both/
     *         Crosshair on both axes
     * @sample {highstock} stock/xaxis/crosshairs-xy/
     *         Crosshair on both axes
     * @sample {highmaps} highcharts/xaxis/crosshair-both/
     *         Crosshair on both axes
     *
     * @declare   Highcharts.AxisCrosshairOptions
     * @type      {boolean|*}
     * @default   false
     * @since     4.1
     * @apioption xAxis.crosshair
     */
    /**
     * A class name for the crosshair, especially as a hook for styling.
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption xAxis.crosshair.className
     */
    /**
     * The color of the crosshair. Defaults to `#cccccc` for numeric and
     * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where
     * the crosshair by default highlights the whole category.
     *
     * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     *
     * @type      {Highcharts.ColorType}
     * @default   #cccccc
     * @since     4.1
     * @apioption xAxis.crosshair.color
     */
    /**
     * The dash style for the crosshair. See
     * [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
     * for possible values.
     *
     * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/
     *         Dotted crosshair
     * @sample {highstock} stock/xaxis/crosshair-dashed/
     *         Dashed X axis crosshair
     *
     * @type      {Highcharts.DashStyleValue}
     * @default   Solid
     * @since     4.1
     * @apioption xAxis.crosshair.dashStyle
     */
    /**
     * A label on the axis next to the crosshair.
     *
     * In styled mode, the label is styled with the
     * `.highcharts-crosshair-label` class.
     *
     * @sample {highstock} stock/xaxis/crosshair-label/
     *         Crosshair labels
     * @sample {highstock} highcharts/css/crosshair-label/
     *         Style mode
     *
     * @declare   Highcharts.AxisCrosshairLabelOptions
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label
     */
    /**
     * Alignment of the label compared to the axis. Defaults to `"left"` for
     * right-side axes, `"right"` for left-side axes and `"center"` for
     * horizontal axes.
     *
     * @type      {Highcharts.AlignValue}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.align
     */
    /**
     * The background color for the label. Defaults to the related series
     * color, or `#666666` if that is not available.
     *
     * @type      {Highcharts.ColorType}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.backgroundColor
     */
    /**
     * The border color for the crosshair label
     *
     * @type      {Highcharts.ColorType}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.borderColor
     */
    /**
     * The border corner radius of the crosshair label.
     *
     * @type      {number}
     * @default   3
     * @since     2.1.10
     * @product   highstock
     * @apioption xAxis.crosshair.label.borderRadius
     */
    /**
     * The border width for the crosshair label.
     *
     * @type      {number}
     * @default   0
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.borderWidth
     */
    /**
     * Flag to enable crosshair's label.
     *
     * @sample {highstock} stock/xaxis/crosshairs-xy/
     *         Enabled label for yAxis' crosshair
     *
     * @type      {boolean}
     * @default   false
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.enabled
     */
    /**
     * A format string for the crosshair label. Defaults to `{value}` for
     * numeric axes and `{value:%b %d, %Y}` for datetime axes.
     *
     * @type      {string}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.format
     */
    /**
     * Formatter function for the label text.
     *
     * @type      {Highcharts.XAxisCrosshairLabelFormatterCallbackFunction}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.formatter
     */
    /**
     * Padding inside the crosshair label.
     *
     * @type      {number}
     * @default   8
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.padding
     */
    /**
     * The shape to use for the label box.
     *
     * @type      {string}
     * @default   callout
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.shape
     */
    /**
     * Text styles for the crosshair label.
     *
     * @type      {Highcharts.CSSObject}
     * @default   {"color": "white", "fontWeight": "normal", "fontSize": "11px", "textAlign": "center"}
     * @since     2.1
     * @product   highstock
     * @apioption xAxis.crosshair.label.style
     */
    /**
     * Whether the crosshair should snap to the point or follow the pointer
     * independent of points.
     *
     * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/
     *         True by default
     * @sample {highmaps} maps/demo/latlon-advanced/
     *         Snap is false
     *
     * @type      {boolean}
     * @default   true
     * @since     4.1
     * @apioption xAxis.crosshair.snap
     */
    /**
     * The pixel width of the crosshair. Defaults to 1 for numeric or
     * datetime axes, and for one category width for category axes.
     *
     * @sample {highcharts} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     * @sample {highstock} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     * @sample {highmaps} highcharts/xaxis/crosshair-customized/
     *         Customized crosshairs
     *
     * @type      {number}
     * @default   1
     * @since     4.1
     * @apioption xAxis.crosshair.width
     */
    /**
     * The Z index of the crosshair. Higher Z indices allow drawing the
     * crosshair on top of the series or behind the grid lines.
     *
     * @type      {number}
     * @default   2
     * @since     4.1
     * @apioption xAxis.crosshair.zIndex
     */
    /**
     * Whether to pan axis. If `chart.panning` is enabled, the option
     * allows to disable panning on an individual axis.
     */
    panningEnabled: true,
    /**
     * The Z index for the axis group.
     */
    zIndex: 2,
    /**
     * Whether to zoom axis. If `chart.zoomType` is set, the option allows
     * to disable zooming on an individual axis.
     *
     * @sample {highcharts} highcharts/xaxis/zoomenabled/
     *         Zoom enabled is false
     */
    zoomEnabled: true,
    /**
     * For a datetime axis, the scale will automatically adjust to the
     * appropriate unit. This member gives the default string
     * representations used for each unit. For intermediate values,
     * different units may be used, for example the `day` unit can be used
     * on midnight and `hour` unit be used for intermediate values on the
     * same axis.
     *
     * For an overview of the replacement codes, see
     * [dateFormat](/class-reference/Highcharts#.dateFormat).
     *
     * Defaults to:
     * ```js
     * {
     *     millisecond: '%H:%M:%S.%L',
     *     second: '%H:%M:%S',
     *     minute: '%H:%M',
     *     hour: '%H:%M',
     *     day: '%e. %b',
     *     week: '%e. %b',
     *     month: '%b \'%y',
     *     year: '%Y'
     * }
     * ```
     *
     * @sample {highcharts} highcharts/xaxis/datetimelabelformats/
     *         Different day format on X axis
     * @sample {highstock} stock/xaxis/datetimelabelformats/
     *         More information in x axis labels
     *
     * @declare Highcharts.AxisDateTimeLabelFormatsOptions
     * @product highcharts highstock gantt
     */
    dateTimeLabelFormats: {
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      millisecond: {
        main: "%H:%M:%S.%L",
        range: false
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      second: {
        main: "%H:%M:%S",
        range: false
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      minute: {
        main: "%H:%M",
        range: false
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      hour: {
        main: "%H:%M",
        range: false
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      day: {
        main: "%e. %b"
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      week: {
        main: "%e. %b"
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      month: {
        main: "%b '%y"
      },
      /**
       * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
       * @type {string|*}
       */
      year: {
        main: "%Y"
      }
    },
    /**
     * Whether to force the axis to end on a tick. Use this option with
     * the `maxPadding` option to control the axis end.
     *
     * @productdesc {highstock}
     * In Highcharts Stock, `endOnTick` is always `false` when the navigator
     * is enabled, to prevent jumpy scrolling.
     *
     * @sample {highcharts} highcharts/chart/reflow-true/
     *         True by default
     * @sample {highcharts} highcharts/yaxis/endontick/
     *         False
     * @sample {highstock} stock/demo/basic-line/
     *         True by default
     * @sample {highstock} stock/xaxis/endontick/
     *         False
     *
     * @since 1.2.0
     */
    endOnTick: false,
    /**
     * Event handlers for the axis.
     *
     * @type      {*}
     * @apioption xAxis.events
     */
    /**
     * An event fired after the breaks have rendered.
     *
     * @see [breaks](#xAxis.breaks)
     *
     * @sample {highcharts} highcharts/axisbreak/break-event/
     *         AfterBreak Event
     *
     * @type      {Highcharts.AxisEventCallbackFunction}
     * @since     4.1.0
     * @product   highcharts gantt
     * @apioption xAxis.events.afterBreaks
     */
    /**
     * As opposed to the `setExtremes` event, this event fires after the
     * final min and max values are computed and corrected for `minRange`.
     *
     * Fires when the minimum and maximum is set for the axis, either by
     * calling the `.setExtremes()` method or by selecting an area in the
     * chart. One parameter, `event`, is passed to the function, containing
     * common event information.
     *
     * The new user set minimum and maximum values can be found by
     * `event.min` and `event.max`. These reflect the axis minimum and
     * maximum in axis values. The actual data extremes are found in
     * `event.dataMin` and `event.dataMax`.
     *
     * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
     * @since     2.3
     * @context   Highcharts.Axis
     * @apioption xAxis.events.afterSetExtremes
     */
    /**
     * An event fired when a break from this axis occurs on a point.
     *
     * @see [breaks](#xAxis.breaks)
     *
     * @sample {highcharts} highcharts/axisbreak/break-visualized/
     *         Visualization of a Break
     *
     * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
     * @since     4.1.0
     * @product   highcharts gantt
     * @context   Highcharts.Axis
     * @apioption xAxis.events.pointBreak
     */
    /**
     * An event fired when a point falls inside a break from this axis.
     *
     * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
     * @product   highcharts highstock gantt
     * @context   Highcharts.Axis
     * @apioption xAxis.events.pointInBreak
     */
    /**
     * Fires when the minimum and maximum is set for the axis, either by
     * calling the `.setExtremes()` method or by selecting an area in the
     * chart. One parameter, `event`, is passed to the function,
     * containing common event information.
     *
     * The new user set minimum and maximum values can be found by
     * `event.min` and `event.max`. These reflect the axis minimum and
     * maximum in data values. When an axis is zoomed all the way out from
     * the "Reset zoom" button, `event.min` and `event.max` are null, and
     * the new extremes are set based on `this.dataMin` and `this.dataMax`.
     *
     * @sample {highstock} stock/xaxis/events-setextremes/
     *         Log new extremes on x axis
     *
     * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Axis
     * @apioption xAxis.events.setExtremes
     */
    /**
     * The lowest allowed value for automatically computed axis extremes.
     *
     * @see [ceiling](#yAxis.ceiling)
     *
     * @sample {highcharts} highcharts/yaxis/floor-ceiling/
     *         Floor and ceiling
     * @sample {highstock} stock/demo/lazy-loading/
     *         Prevent negative stock price on Y axis
     *
     * @type      {number}
     * @since     4.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.floor
     */
    /**
     * The dash or dot style of the grid lines. For possible values, see
     * [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
     *
     * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/
     *         Long dashes
     * @sample {highstock} stock/xaxis/gridlinedashstyle/
     *         Long dashes
     *
     * @type      {Highcharts.DashStyleValue}
     * @since     1.2
     */
    gridLineDashStyle: "Solid",
    /**
     * The Z index of the grid lines.
     *
     * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/
     *         A Z index of 4 renders the grid above the graph
     *
     * @product   highcharts highstock gantt
     */
    gridZIndex: 1,
    /**
     * An id for the axis. This can be used after render time to get
     * a pointer to the axis object through `chart.get()`.
     *
     * @sample {highcharts} highcharts/xaxis/id/
     *         Get the object
     * @sample {highstock} stock/xaxis/id/
     *         Get the object
     *
     * @type      {string}
     * @since     1.2.0
     * @apioption xAxis.id
     */
    /**
     * The axis labels show the number or category for each tick.
     *
     * Since v8.0.0: Labels are animated in categorized x-axis with
     * updating data if `tickInterval` and `step` is set to 1.
     *
     * @productdesc {highmaps}
     * X and Y axis labels are by default disabled in Highmaps, but the
     * functionality is inherited from Highcharts and used on `colorAxis`,
     * and can be enabled on X and Y axes too.
     */
    labels: {
      /**
       * What part of the string the given position is anchored to.
       * If `left`, the left side of the string is at the axis position.
       * Can be one of `"left"`, `"center"` or `"right"`. Defaults to
       * an intelligent guess based on which side of the chart the axis
       * is on and the rotation of the label.
       *
       * @see [reserveSpace](#xAxis.labels.reserveSpace)
       *
       * @sample {highcharts} highcharts/xaxis/labels-align-left/
       *         Left
       * @sample {highcharts} highcharts/xaxis/labels-align-right/
       *         Right
       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
       *         Left-aligned labels on a vertical category axis
       *
       * @type       {Highcharts.AlignValue}
       * @apioption  xAxis.labels.align
       */
      /**
       * Whether to allow the axis labels to overlap.
       * When false, overlapping labels are hidden.
       *
       * @sample {highcharts} highcharts/xaxis/labels-allowoverlap-true/
       *         X axis labels overlap enabled
       *
       * @type {boolean}
       * @default false
       * @apioption xAxis.labels.allowOverlap
       *
       */
      /**
       * For horizontal axes, the allowed degrees of label rotation
       * to prevent overlapping labels. If there is enough space,
       * labels are not rotated. As the chart gets narrower, it
       * will start rotating the labels -45 degrees, then remove
       * every second label and try again with rotations 0 and -45 etc.
       * Set it to `undefined` to disable rotation, which will
       * cause the labels to word-wrap if possible. Defaults to `[-45]``
       * on bottom and top axes, `undefined` on left and right axes.
       *
       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/
       *         Default auto rotation of 0 or -45
       * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/
       *         Custom graded auto rotation
       *
       * @type      {Array<number>}
       * @default   undefined
       * @since     4.1.0
       * @product   highcharts highstock gantt
       * @apioption xAxis.labels.autoRotation
       */
      autoRotation: void 0,
      /**
       * When each category width is more than this many pixels, we don't
       * apply auto rotation. Instead, we lay out the axis label with word
       * wrap. A lower limit makes sense when the label contains multiple
       * short words that don't extend the available horizontal space for
       * each label.
       *
       * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/
       *         Lower limit
       *
       * @since     4.1.5
       * @product   highcharts gantt
       */
      autoRotationLimit: 80,
      /**
       * Polar charts only. The label's pixel distance from the perimeter
       * of the plot area.
       *
       * @type      {number}
       * @default   undefined
       * @product   highcharts gantt
       */
      distance: void 0,
      /**
       * Enable or disable the axis labels.
       *
       * @sample {highcharts} highcharts/xaxis/labels-enabled/
       *         X axis labels disabled
       * @sample {highstock} stock/xaxis/labels-enabled/
       *         X axis labels disabled
       *
       * @default {highcharts|highstock|gantt} true
       * @default {highmaps} false
       */
      enabled: true,
      /**
       * A format string for the axis label. The context is available as
       * format string variables. For example, you can use `{text}` to
       * insert the default formatted text. The recommended way of adding
       * units for the label is using `text`, for example `{text} km`.
       *
       * To add custom numeric or datetime formatting, use `{value}` with
       * formatting, for example `{value:.1f}` or `{value:%Y-%m-%d}`.
       *
       * See
       * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
       * for more examples of formatting.
       *
       * The default value is not specified due to the dynamic
       * nature of the default implementation.
       *
       * @sample {highcharts|highstock} highcharts/yaxis/labels-format/
       *         Add units to Y axis label
       * @sample {highcharts} highcharts/xaxis/labels-format-linked/
       *         Linked category names
       * @sample {highcharts} highcharts/xaxis/labels-format-custom/
       *         Custom number format
       *
       * @type      {string}
       * @since     3.0
       * @apioption xAxis.labels.format
       */
      /**
       * Callback JavaScript function to format the label. The value
       * is given by `this.value`. Additional properties for `this` are
       * `axis`, `chart`, `isFirst`, `isLast` and `text` which holds the
       * value of the default formatter.
       *
       * Defaults to a built in function returning a formatted string
       * depending on whether the axis is `category`, `datetime`,
       * `numeric` or other.
       *
       * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/
       *         Linked category names
       * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/
       *         Modified numeric labels
       * @sample {highstock} stock/xaxis/labels-formatter/
       *         Added units on Y axis
       *
       * @type      {Highcharts.AxisLabelsFormatterCallbackFunction}
       * @apioption xAxis.labels.formatter
       */
      /**
       * The number of pixels to indent the labels per level in a treegrid
       * axis.
       *
       * @sample gantt/treegrid-axis/demo
       *         Indentation 10px by default.
       * @sample gantt/treegrid-axis/indentation-0px
       *         Indentation set to 0px.
       *
       * @product gantt
       */
      indentation: 10,
      /**
       * Horizontal axis only. When `staggerLines` is not set,
       * `maxStaggerLines` defines how many lines the axis is allowed to
       * add to automatically avoid overlapping X labels. Set to `1` to
       * disable overlap detection.
       *
       * @deprecated
       * @type      {number}
       * @default   5
       * @since     1.3.3
       * @apioption xAxis.labels.maxStaggerLines
       */
      /**
       * How to handle overflowing labels on horizontal axis. If set to
       * `"allow"`, it will not be aligned at all. By default it
       * `"justify"` labels inside the chart area. If there is room to
       * move it, it will be aligned to the edge, else it will be removed.
       *
       * @since      2.2.5
       * @validvalue ["allow", "justify"]
       */
      overflow: "justify",
      /**
       * The pixel padding for axis labels, to ensure white space between
       * them.
       *
       * @product   highcharts gantt
       */
      padding: 5,
      /**
       * Whether to reserve space for the labels. By default, space is
       * reserved for the labels in these cases:
       *
       * * On all horizontal axes.
       * * On vertical axes if `label.align` is `right` on a left-side
       * axis or `left` on a right-side axis.
       * * On vertical axes if `label.align` is `center`.
       *
       * This can be turned off when for example the labels are rendered
       * inside the plot area instead of outside.
       *
       * @see [labels.align](#xAxis.labels.align)
       *
       * @sample {highcharts} highcharts/xaxis/labels-reservespace/
       *         No reserved space, labels inside plot
       * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
       *         Left-aligned labels on a vertical category axis
       *
       * @type      {boolean}
       * @since     4.1.10
       * @product   highcharts gantt
       * @apioption xAxis.labels.reserveSpace
       */
      reserveSpace: void 0,
      /**
       * Rotation of the labels in degrees. When `undefined`, the
       * `autoRotation` option takes precedence.
       *
       * @sample {highcharts} highcharts/xaxis/labels-rotation/
       *         X axis labels rotated 90
       *
       * @type      {number}
       * @default   0
       * @apioption xAxis.labels.rotation
       */
      rotation: void 0,
      /**
       * Horizontal axes only. The number of lines to spread the labels
       * over to make room or tighter labels. 0 disables staggering.
       *
       * @sample {highcharts} highcharts/xaxis/labels-staggerlines/
       *         Show labels over two lines
       * @sample {highstock} stock/xaxis/labels-staggerlines/
       *         Show labels over two lines
       *
       * @since     2.1
       */
      staggerLines: 0,
      /**
       * To show only every _n_'th label on the axis, set the step to _n_.
       * Setting the step to 2 shows every other label.
       *
       * By default, when 0, the step is calculated automatically to avoid
       * overlap. To prevent this, set it to 1\. This usually only
       * happens on a category axis, and is often a sign that you have
       * chosen the wrong axis type.
       *
       * Read more at
       * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)
       * => What axis should I use?
       *
       * @sample {highcharts} highcharts/xaxis/labels-step/
       *         Showing only every other axis label on a categorized
       *         x-axis
       * @sample {highcharts} highcharts/xaxis/labels-step-auto/
       *         Auto steps on a category axis
       *
       * @since     2.1
       */
      step: 0,
      /**
       * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
       * to render the labels.
       */
      useHTML: false,
      /**
       * The x position offset of all labels relative to the tick
       * positions on the axis.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         Y axis labels placed on grid lines
       */
      x: 0,
      /**
       * The y position offset of all labels relative to the tick
       * positions on the axis. The default makes it adapt to the font
       * size of the bottom axis.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         Y axis labels placed on grid lines
       *
       * @type      {number}
       * @apioption xAxis.labels.y
       */
      /**
       * The Z index for the axis labels.
       */
      zIndex: 7,
      /**
       * CSS styles for the label. Use `whiteSpace: 'nowrap'` to prevent
       * wrapping of category labels. Use `textOverflow: 'none'` to
       * prevent ellipsis (dots).
       *
       * In styled mode, the labels are styled with the
       * `.highcharts-axis-labels` class.
       *
       * @sample {highcharts} highcharts/xaxis/labels-style/
       *         Red X axis labels
       *
       * @type      {Highcharts.CSSObject}
       */
      style: {
        /** @internal */
        color: Palette_default.neutralColor60,
        /** @internal */
        cursor: "default",
        /** @internal */
        fontSize: "11px"
      }
    },
    /**
     * The left position as the horizontal axis. If it's a number, it is
     * interpreted as pixel position relative to the chart.
     *
     * Since Highcharts v5.0.13: If it's a percentage string, it is
     * interpreted as percentages of the plot width, offset from plot area
     * left.
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption xAxis.left
     */
    /**
     * The top position as the vertical axis. If it's a number, it is
     * interpreted as pixel position relative to the chart.
     *
     * Since Highcharts 2: If it's a percentage string, it is interpreted
     * as percentages of the plot height, offset from plot area top.
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption xAxis.top
     */
    /**
     * Index of another axis that this axis is linked to. When an axis is
     * linked to a master axis, it will take the same extremes as
     * the master, but as assigned by min or max or by setExtremes.
     * It can be used to show additional info, or to ease reading the
     * chart by duplicating the scales.
     *
     * @sample {highcharts} highcharts/xaxis/linkedto/
     *         Different string formats of the same date
     * @sample {highcharts} highcharts/yaxis/linkedto/
     *         Y values on both sides
     *
     * @type      {number}
     * @since     2.0.2
     * @product   highcharts highstock gantt
     * @apioption xAxis.linkedTo
     */
    /**
     * The maximum value of the axis. If `null`, the max value is
     * automatically calculated.
     *
     * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value
     * might be rounded up.
     *
     * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended
     * beyond the set max in order to reach the given number of ticks. The
     * same may happen in a chart with multiple axes, determined by [chart.
     * alignTicks](#chart), where a `tickAmount` is applied internally.
     *
     * @sample {highcharts} highcharts/yaxis/max-200/
     *         Y axis max of 200
     * @sample {highcharts} highcharts/yaxis/max-logarithmic/
     *         Y axis max on logarithmic axis
     * @sample {highstock} stock/xaxis/min-max/
     *         Fixed min and max on X axis
     * @sample {highmaps} maps/axis/min-max/
     *         Pre-zoomed to a specific area
     *
     * @type      {number|null}
     * @apioption xAxis.max
     */
    /**
     * Padding of the max value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the highest data value to appear on the edge
     * of the plot area. When the axis' `max` option is set or a max extreme
     * is set using `axis.setExtremes()`, the maxPadding will be ignored.
     *
     * @productdesc {highstock}
     * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
     * are ignored. Use [overscroll](#xAxis.overscroll) instead.
     *
     * @sample {highcharts} highcharts/yaxis/maxpadding/
     *         Max padding of 0.25 on y axis
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
     *         Add some padding
     *
     * @default   {highcharts} 0.01
     * @default   {highstock|highmaps} 0
     * @since     1.2.0
     */
    maxPadding: 0.01,
    /**
     * Deprecated. Use `minRange` instead.
     *
     * @deprecated
     * @type      {number}
     * @product   highcharts highstock
     * @apioption xAxis.maxZoom
     */
    /**
     * The minimum value of the axis. If `null` the min value is
     * automatically calculated.
     *
     * If the [startOnTick](#yAxis.startOnTick) option is true (default),
     * the `min` value might be rounded down.
     *
     * The automatically calculated minimum value is also affected by
     * [floor](#yAxis.floor), [softMin](#yAxis.softMin),
     * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)
     * as well as [series.threshold](#plotOptions.series.threshold)
     * and [series.softThreshold](#plotOptions.series.softThreshold).
     *
     * @sample {highcharts} highcharts/yaxis/min-startontick-false/
     *         -50 with startOnTick to false
     * @sample {highcharts} highcharts/yaxis/min-startontick-true/
     *         -50 with startOnTick true by default
     * @sample {highstock} stock/xaxis/min-max/
     *         Set min and max on X axis
     * @sample {highmaps} maps/axis/min-max/
     *         Pre-zoomed to a specific area
     *
     * @type      {number|null}
     * @apioption xAxis.min
     */
    /**
     * The dash or dot style of the minor grid lines. For possible values,
     * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
     *
     * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/
     *         Long dashes on minor grid lines
     * @sample {highstock} stock/xaxis/minorgridlinedashstyle/
     *         Long dashes on minor grid lines
     *
     * @type      {Highcharts.DashStyleValue}
     * @since     1.2
     */
    minorGridLineDashStyle: "Solid",
    /**
     * Specific tick interval in axis units for the minor ticks. On a linear
     * axis, if `"auto"`, the minor tick interval is calculated as a fifth
     * of the tickInterval. If `null` or `undefined`, minor ticks are not
     * shown.
     *
     * On logarithmic axes, the unit is the power of the value. For example,
     * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,
     * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks
     * between 1 and 10, 10 and 100 etc.
     *
     * If user settings dictate minor ticks to become too dense, they don't
     * make sense, and will be ignored to prevent performance problems.
     *
     * @sample {highcharts} highcharts/yaxis/minortickinterval-null/
     *         Null by default
     * @sample {highcharts} highcharts/yaxis/minortickinterval-5/
     *         5 units
     * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/
     *         "auto"
     * @sample {highcharts} highcharts/yaxis/minortickinterval-log/
     *         0.1
     * @sample {highstock} stock/demo/basic-line/
     *         Null by default
     * @sample {highstock} stock/xaxis/minortickinterval-auto/
     *         "auto"
     *
     * @type      {number|string|null}
     * @apioption xAxis.minorTickInterval
     */
    /**
     * The pixel length of the minor tick marks.
     *
     * @sample {highcharts} highcharts/yaxis/minorticklength/
     *         10px on Y axis
     * @sample {highstock} stock/xaxis/minorticks/
     *         10px on Y axis
     */
    minorTickLength: 2,
    /**
     * The position of the minor tick marks relative to the axis line.
     *  Can be one of `inside` and `outside`.
     *
     * @sample {highcharts} highcharts/yaxis/minortickposition-outside/
     *         Outside by default
     * @sample {highcharts} highcharts/yaxis/minortickposition-inside/
     *         Inside
     * @sample {highstock} stock/xaxis/minorticks/
     *         Inside
     *
     * @validvalue ["inside", "outside"]
     */
    minorTickPosition: "outside",
    /**
     * Enable or disable minor ticks. Unless
     * [minorTickInterval](#xAxis.minorTickInterval) is set, the tick
     * interval is calculated as a fifth of the `tickInterval`.
     *
     * On a logarithmic axis, minor ticks are laid out based on a best
     * guess, attempting to enter approximately 5 minor ticks between
     * each major tick.
     *
     * Prior to v6.0.0, ticks were unabled in auto layout by setting
     * `minorTickInterval` to `"auto"`.
     *
     * @productdesc {highcharts}
     * On axes using [categories](#xAxis.categories), minor ticks are not
     * supported.
     *
     * @sample {highcharts} highcharts/yaxis/minorticks-true/
     *         Enabled on linear Y axis
     *
     * @type      {boolean}
     * @default   false
     * @since     6.0.0
     * @apioption xAxis.minorTicks
     */
    /**
     * The pixel width of the minor tick mark.
     *
     * @sample {highcharts} highcharts/yaxis/minortickwidth/
     *         3px width
     * @sample {highstock} stock/xaxis/minorticks/
     *         1px width
     *
     * @type      {number}
     * @default   0
     * @apioption xAxis.minorTickWidth
     */
    /**
     * Padding of the min value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the lowest data value to appear on the edge
     * of the plot area. When the axis' `min` option is set or a min extreme
     * is set using `axis.setExtremes()`, the minPadding will be ignored.
     *
     * @productdesc {highstock}
     * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
     * are ignored. Use [overscroll](#xAxis.overscroll) instead.
     *
     * @sample {highcharts} highcharts/yaxis/minpadding/
     *         Min padding of 0.2
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
     *         Add some padding
     *
     * @default    {highcharts} 0.01
     * @default    {highstock|highmaps} 0
     * @since      1.2.0
     * @product    highcharts highstock gantt
     */
    minPadding: 0.01,
    /**
     * The minimum range to display on this axis. The entire axis will not
     * be allowed to span over a smaller interval than this. For example,
     * for a datetime axis the main unit is milliseconds. If minRange is
     * set to 3600000, you can't zoom in more than to one hour.
     *
     * The default minRange for the x axis is five times the smallest
     * interval between any of the data points.
     *
     * On a logarithmic axis, the unit for the minimum range is the power.
     * So a minRange of 1 means that the axis can be zoomed to 10-100,
     * 100-1000, 1000-10000 etc.
     *
     * **Note**: The `minPadding`, `maxPadding`, `startOnTick` and
     * `endOnTick` settings also affect how the extremes of the axis
     * are computed.
     *
     * @sample {highcharts} highcharts/xaxis/minrange/
     *         Minimum range of 5
     * @sample {highstock} stock/xaxis/minrange/
     *         Max zoom of 6 months overrides user selections
     * @sample {highmaps} maps/axis/minrange/
     *         Minimum range of 1000
     *
     * @type      {number}
     * @apioption xAxis.minRange
     */
    /**
     * The minimum tick interval allowed in axis values. For example on
     * zooming in on an axis with daily data, this can be used to prevent
     * the axis from showing hours. Defaults to the closest distance between
     * two points on the axis.
     *
     * @type      {number}
     * @since     2.3.0
     * @apioption xAxis.minTickInterval
     */
    /**
     * The distance in pixels from the plot area to the axis line.
     * A positive offset moves the axis with it's line, labels and ticks
     * away from the plot area. This is typically used when two or more
     * axes are displayed on the same side of the plot. With multiple
     * axes the offset is dynamically adjusted to avoid collision, this
     * can be overridden by setting offset explicitly.
     *
     * @sample {highcharts} highcharts/yaxis/offset/
     *         Y axis offset of 70
     * @sample {highcharts} highcharts/yaxis/offset-centered/
     *         Axes positioned in the center of the plot
     * @sample {highstock} stock/xaxis/offset/
     *         Y axis offset by 70 px
     *
     * @type {number}
     */
    offset: void 0,
    /**
     * Whether to display the axis on the opposite side of the normal. The
     * normal is on the left side for vertical axes and bottom for
     * horizontal, so the opposite sides will be right and top respectively.
     * This is typically used with dual or multiple axes.
     *
     * @sample {highcharts} highcharts/yaxis/opposite/
     *         Secondary Y axis opposite
     * @sample {highstock} stock/xaxis/opposite/
     *         Y axis on left side
     *
     * @default   {highcharts|highstock|highmaps} false
     * @default   {gantt} true
     */
    opposite: false,
    /**
     * In an ordinal axis, the points are equally spaced in the chart
     * regardless of the actual time or x distance between them. This means
     * that missing data periods (e.g. nights or weekends for a stock chart)
     * will not take up space in the chart.
     * Having `ordinal: false` will show any gaps created by the `gapSize`
     * setting proportionate to their duration.
     *
     * In stock charts the X axis is ordinal by default, unless
     * the boost module is used and at least one of the series' data length
     * exceeds the [boostThreshold](#series.line.boostThreshold).
     *
     * For an ordinal axis, `minPadding` and `maxPadding` are ignored. Use
     * [overscroll](#xAxis.overscroll) instead.
     *
     * @sample {highstock} stock/xaxis/ordinal-true/
     *         True by default
     * @sample {highstock} stock/xaxis/ordinal-false/
     *         False
     *
     * @see [overscroll](#xAxis.overscroll)
     *
     * @type      {boolean}
     * @default   true
     * @since     1.1
     * @product   highstock
     * @apioption xAxis.ordinal
     */
    /**
     * Additional range on the right side of the xAxis. Works similar to
     * `xAxis.maxPadding`, but value is set in milliseconds. Can be set for
     * both main `xAxis` and the navigator's `xAxis`.
     *
     * @sample {highstock} stock/xaxis/overscroll/
     *         One minute overscroll with live data
     *
     * @type      {number}
     * @default   0
     * @since     6.0.0
     * @product   highstock
     * @apioption xAxis.overscroll
     */
    /**
     * Refers to the index in the [panes](#panes) array. Used for circular
     * gauges and polar charts. When the option is not set then first pane
     * will be used.
     *
     * @sample highcharts/demo/gauge-vu-meter
     *         Two gauges with different center
     *
     * @type      {number}
     * @product   highcharts
     * @apioption xAxis.pane
     */
    /**
     * The zoomed range to display when only defining one or none of `min`
     * or `max`. For example, to show the latest month, a range of one month
     * can be set.
     *
     * @sample {highstock} stock/xaxis/range/
     *         Setting a zoomed range when the rangeSelector is disabled
     *
     * @type      {number}
     * @product   highstock
     * @apioption xAxis.range
     */
    /**
     * Whether to reverse the axis so that the highest number is closest
     * to the origin. If the chart is inverted, the x axis is reversed by
     * default.
     *
     * @sample {highcharts} highcharts/yaxis/reversed/
     *         Reversed Y axis
     * @sample {highstock} stock/xaxis/reversed/
     *         Reversed Y axis
     *
     * @type      {boolean}
     * @default   undefined
     * @apioption xAxis.reversed
     */
    reversed: void 0,
    /**
     * This option determines how stacks should be ordered within a group.
     * For example reversed xAxis also reverses stacks, so first series
     * comes last in a group. To keep order like for non-reversed xAxis
     * enable this option.
     *
     * @sample {highcharts} highcharts/xaxis/reversedstacks/
     *         Reversed stacks comparison
     * @sample {highstock} highcharts/xaxis/reversedstacks/
     *         Reversed stacks comparison
     *
     * @since     6.1.1
     * @product   highcharts highstock
     */
    reversedStacks: false,
    /**
     * An optional scrollbar to display on the X axis in response to
     * limiting the minimum and maximum of the axis values.
     *
     * In styled mode, all the presentational options for the scrollbar are
     * replaced by the classes `.highcharts-scrollbar-thumb`,
     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
     *
     * @sample {highstock} stock/yaxis/heatmap-scrollbars/
     *         Heatmap with both scrollbars
     *
     * @extends   scrollbar
     * @since     4.2.6
     * @product   highstock
     * @apioption xAxis.scrollbar
     */
    /**
     * Whether to show the axis line and title when the axis has no data.
     *
     * @sample {highcharts} highcharts/yaxis/showempty/
     *         When clicking the legend to hide series, one axis preserves
     *         line and title, the other doesn't
     * @sample {highstock} highcharts/yaxis/showempty/
     *         When clicking the legend to hide series, one axis preserves
     *         line and title, the other doesn't
     *
     * @since     1.1
     */
    showEmpty: true,
    /**
     * Whether to show the first tick label.
     *
     * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/
     *         Set to false on X axis
     * @sample {highstock} stock/xaxis/showfirstlabel/
     *         Labels below plot lines on Y axis
     */
    showFirstLabel: true,
    /**
     * Whether to show the last tick label. Defaults to `true` on cartesian
     * charts, and `false` on polar charts.
     *
     * @sample {highcharts} highcharts/xaxis/showlastlabel-true/
     *         Set to true on X axis
     * @sample {highstock} stock/xaxis/showfirstlabel/
     *         Labels below plot lines on Y axis
     *
     * @product   highcharts highstock gantt
     */
    showLastLabel: true,
    /**
     * A soft maximum for the axis. If the series data maximum is less than
     * this, the axis will stay at this maximum, but if the series data
     * maximum is higher, the axis will flex to show all data.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock gantt
     * @apioption xAxis.softMax
     */
    /**
     * A soft minimum for the axis. If the series data minimum is greater
     * than this, the axis will stay at this minimum, but if the series
     * data minimum is lower, the axis will flex to show all data.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock gantt
     * @apioption xAxis.softMin
     */
    /**
     * For datetime axes, this decides where to put the tick between weeks.
     *  0 = Sunday, 1 = Monday.
     *
     * @sample {highcharts} highcharts/xaxis/startofweek-monday/
     *         Monday by default
     * @sample {highcharts} highcharts/xaxis/startofweek-sunday/
     *         Sunday
     * @sample {highstock} stock/xaxis/startofweek-1
     *         Monday by default
     * @sample {highstock} stock/xaxis/startofweek-0
     *         Sunday
     *
     * @product highcharts highstock gantt
     */
    startOfWeek: 1,
    /**
     * Whether to force the axis to start on a tick. Use this option with
     * the `minPadding` option to control the axis start.
     *
     * @productdesc {highstock}
     * In Highcharts Stock, `startOnTick` is always `false` when
     * the navigator is enabled, to prevent jumpy scrolling.
     *
     * @sample {highcharts} highcharts/xaxis/startontick-false/
     *         False by default
     * @sample {highcharts} highcharts/xaxis/startontick-true/
     *         True
     *
     * @since 1.2.0
     */
    startOnTick: false,
    /**
     * The amount of ticks to draw on the axis. This opens up for aligning
     * the ticks of multiple charts or panes within a chart. This option
     * overrides the `tickPixelInterval` option.
     *
     * This option only has an effect on linear axes. Datetime, logarithmic
     * or category axes are not affected.
     *
     * @sample {highcharts} highcharts/yaxis/tickamount/
     *         8 ticks on Y axis
     * @sample {highstock} highcharts/yaxis/tickamount/
     *         8 ticks on Y axis
     *
     * @type      {number}
     * @since     4.1.0
     * @product   highcharts highstock gantt
     * @apioption xAxis.tickAmount
     */
    /**
     * The interval of the tick marks in axis units. When `undefined`, the
     * tick interval is computed to approximately follow the
     * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime
     * axes. On categorized axes, a `undefined` tickInterval will default to
     * 1, one category. Note that datetime axes are based on milliseconds,
     * so for example an interval of one day is expressed as
     * `24 * 3600 * 1000`.
     *
     * On logarithmic axes, the tickInterval is based on powers, so a
     * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A
     * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval
     * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,
     * 40 etc.
     *
     *
     * If the tickInterval is too dense for labels to be drawn, Highcharts
     * may remove ticks.
     *
     * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)
     * option may interfere with the `tickInterval` setting.
     *
     * @see [tickPixelInterval](#xAxis.tickPixelInterval)
     * @see [tickPositions](#xAxis.tickPositions)
     * @see [tickPositioner](#xAxis.tickPositioner)
     *
     * @sample {highcharts} highcharts/xaxis/tickinterval-5/
     *         Tick interval of 5 on a linear axis
     * @sample {highstock} stock/xaxis/tickinterval/
     *         Tick interval of 0.01 on Y axis
     *
     * @type      {number}
     * @apioption xAxis.tickInterval
     */
    /**
     * The pixel length of the main tick marks.
     *
     * @sample {highcharts} highcharts/xaxis/ticklength/
     *         20 px tick length on the X axis
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     */
    tickLength: 10,
    /**
     * If tickInterval is `null` this option sets the approximate pixel
     * interval of the tick marks. Not applicable to categorized axis.
     *
     * The tick interval is also influenced by the [minTickInterval](
     * #xAxis.minTickInterval) option, that, by default prevents ticks from
     * being denser than the data points.
     *
     * @see [tickInterval](#xAxis.tickInterval)
     * @see [tickPositioner](#xAxis.tickPositioner)
     * @see [tickPositions](#xAxis.tickPositions)
     *
     * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/
     *         50 px on X axis
     * @sample {highstock} stock/xaxis/tickpixelinterval/
     *         200 px on X axis
     */
    tickPixelInterval: 100,
    /**
     * For categorized axes only. If `on` the tick mark is placed in the
     * center of the category, if `between` the tick mark is placed between
     * categories. The default is `between` if the `tickInterval` is 1, else
     * `on`.
     *
     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/
     *         "between" by default
     * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/
     *         "on"
     *
     * @product    highcharts gantt
     * @validvalue ["on", "between"]
     */
    tickmarkPlacement: "between",
    /**
     * The position of the major tick marks relative to the axis line.
     * Can be one of `inside` and `outside`.
     *
     * @sample {highcharts} highcharts/xaxis/tickposition-outside/
     *         "outside" by default
     * @sample {highcharts} highcharts/xaxis/tickposition-inside/
     *         "inside"
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     *
     * @validvalue ["inside", "outside"]
     */
    tickPosition: "outside",
    /**
     * A callback function returning array defining where the ticks are
     * laid out on the axis. This overrides the default behaviour of
     * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](
     * #xAxis.tickInterval). The automatic tick positions are accessible
     * through `this.tickPositions` and can be modified by the callback.
     *
     * @see [tickPositions](#xAxis.tickPositions)
     *
     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     *
     * @type      {Highcharts.AxisTickPositionerCallbackFunction}
     * @apioption xAxis.tickPositioner
     */
    /**
     * An array defining where the ticks are laid out on the axis. This
     * overrides the default behaviour of [tickPixelInterval](
     * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).
     *
     * @see [tickPositioner](#xAxis.tickPositioner)
     *
     * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
     *         Demo of tickPositions and tickPositioner
     *
     * @type      {Array<number>}
     * @apioption xAxis.tickPositions
     */
    /**
     * The pixel width of the major tick marks. Defaults to 0 on category
     * axes, otherwise 1.
     *
     * In styled mode, the stroke width is given in the `.highcharts-tick`
     * class, but in order for the element to be generated on category axes,
     * the option must be explicitly set to 1.
     *
     * @sample {highcharts} highcharts/xaxis/tickwidth/
     *         10 px width
     * @sample {highcharts} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     * @sample {highstock} highcharts/css/axis-grid/
     *         Styled mode
     *
     * @type      {undefined|number}
     * @default   {highstock} 1
     * @default   {highmaps} 0
     * @apioption xAxis.tickWidth
     */
    /**
     * The axis title, showing next to the axis line.
     *
     * @productdesc {highmaps}
     * In Highmaps, the axis is hidden by default, but adding an axis title
     * is still possible. X axis and Y axis titles will appear at the bottom
     * and left by default.
     */
    title: {
      /**
       * Alignment of the title relative to the axis values. Possible
       * values are "low", "middle" or "high".
       *
       * @sample {highcharts} highcharts/xaxis/title-align-low/
       *         "low"
       * @sample {highcharts} highcharts/xaxis/title-align-center/
       *         "middle" by default
       * @sample {highcharts} highcharts/xaxis/title-align-high/
       *         "high"
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Place the Y axis title on top of the axis
       * @sample {highstock} stock/xaxis/title-align/
       *         Aligned to "high" value
       *
       * @type {Highcharts.AxisTitleAlignValue}
       */
      align: "middle",
      /**
       * Deprecated. Set the `text` to `undefined` to disable the title.
       *
       * @deprecated
       * @type      {boolean}
       * @product   highcharts
       * @apioption xAxis.title.enabled
       */
      /**
       * The pixel distance between the axis labels or line and the title.
       * Defaults to 0 for horizontal axes, 10 for vertical
       *
       * @sample {highcharts} highcharts/xaxis/title-margin/
       *         Y axis title margin of 60
       *
       * @type      {number}
       * @apioption xAxis.title.margin
       */
      /**
       * The distance of the axis title from the axis line. By default,
       * this distance is computed from the offset width of the labels,
       * the labels' distance from the axis and the title's margin.
       * However when the offset option is set, it overrides all this.
       *
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Place the axis title on top of the axis
       * @sample {highstock} highcharts/yaxis/title-offset/
       *         Place the axis title on top of the Y axis
       *
       * @type      {number}
       * @since     2.2.0
       * @apioption xAxis.title.offset
       */
      /**
       * Whether to reserve space for the title when laying out the axis.
       *
       * @type      {boolean}
       * @default   true
       * @since     5.0.11
       * @product   highcharts highstock gantt
       * @apioption xAxis.title.reserveSpace
       */
      /**
       * The rotation of the text in degrees. 0 is horizontal, 270 is
       * vertical reading from bottom to top.
       *
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Horizontal
       */
      rotation: 0,
      /**
       * The actual text of the axis title. It can contain basic HTML tags
       * like `b`, `i` and `span` with style.
       *
       * @sample {highcharts} highcharts/xaxis/title-text/
       *         Custom HTML
       * @sample {highstock} stock/xaxis/title-text/
       *         Titles for both axes
       *
       * @type      {string|null}
       * @apioption xAxis.title.text
       */
      /**
       * Alignment of the text, can be `"left"`, `"right"` or `"center"`.
       * Default alignment depends on the
       * [title.align](xAxis.title.align):
       *
       * Horizontal axes:
       * - for `align` = `"low"`, `textAlign` is set to `left`
       * - for `align` = `"middle"`, `textAlign` is set to `center`
       * - for `align` = `"high"`, `textAlign` is set to `right`
       *
       * Vertical axes:
       * - for `align` = `"low"` and `opposite` = `true`, `textAlign` is
       *   set to `right`
       * - for `align` = `"low"` and `opposite` = `false`, `textAlign` is
       *   set to `left`
       * - for `align` = `"middle"`, `textAlign` is set to `center`
       * - for `align` = `"high"` and `opposite` = `true` `textAlign` is
       *   set to `left`
       * - for `align` = `"high"` and `opposite` = `false` `textAlign` is
       *   set to `right`
       *
       * @type      {Highcharts.AlignValue}
       * @apioption xAxis.title.textAlign
       */
      /**
       * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
       * to render the axis title.
       *
       * @product   highcharts highstock gantt
       */
      useHTML: false,
      /**
       * Horizontal pixel offset of the title position.
       *
       * @since     4.1.6
       * @product   highcharts highstock gantt
       */
      x: 0,
      /**
       * Vertical pixel offset of the title position.
       *
       * @product   highcharts highstock gantt
       */
      y: 0,
      /**
       * CSS styles for the title. If the title text is longer than the
       * axis length, it will wrap to multiple lines by default. This can
       * be customized by setting `textOverflow: 'ellipsis'`, by
       * setting a specific `width` or by setting `whiteSpace: 'nowrap'`.
       *
       * In styled mode, the stroke width is given in the
       * `.highcharts-axis-title` class.
       *
       * @sample {highcharts} highcharts/xaxis/title-style/
       *         Red
       * @sample {highcharts} highcharts/css/axis/
       *         Styled mode
       *
       * @type    {Highcharts.CSSObject}
       */
      style: {
        /** @internal */
        color: Palette_default.neutralColor60
      }
    },
    /**
     * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
     * or `category`. In a datetime axis, the numbers are given in
     * milliseconds, and tick marks are placed on appropriate values like
     * full hours or days. In a category axis, the
     * [point names](#series.line.data.name) of the chart's series are used
     * for categories, if not a [categories](#xAxis.categories) array is
     * defined.
     *
     * @sample {highcharts} highcharts/xaxis/type-linear/
     *         Linear
     * @sample {highcharts} highcharts/yaxis/type-log/
     *         Logarithmic
     * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
     *         Logarithmic with minor grid lines
     * @sample {highcharts} highcharts/xaxis/type-log-both/
     *         Logarithmic on two axes
     * @sample {highcharts} highcharts/yaxis/type-log-negative/
     *         Logarithmic with extension to emulate negative values
     *
     * @type    {Highcharts.AxisTypeValue}
     * @product highcharts gantt
     */
    type: "linear",
    /**
     * If there are multiple axes on the same side of the chart, the pixel
     * margin between the axes. Defaults to 0 on vertical axes, 15 on
     * horizontal axes.
     *
     * @type      {number}
     * @since     7.0.3
     * @apioption xAxis.margin
     */
    /**
     * Applies only when the axis `type` is `category`. When `uniqueNames`
     * is true, points are placed on the X axis according to their names.
     * If the same point name is repeated in the same or another series,
     * the point is placed on the same X position as other points of the
     * same name. When `uniqueNames` is false, the points are laid out in
     * increasing X positions regardless of their names, and the X axis
     * category will take the name of the last point in each position.
     *
     * @sample {highcharts} highcharts/xaxis/uniquenames-true/
     *         True by default
     * @sample {highcharts} highcharts/xaxis/uniquenames-false/
     *         False
     *
     * @since     4.2.7
     * @product   highcharts gantt
     */
    uniqueNames: true,
    /**
     * Datetime axis only. An array determining what time intervals the
     * ticks are allowed to fall on. Each array item is an array where the
     * first value is the time unit and the second value another array of
     * allowed multiples.
     *
     * Defaults to:
     * ```js
     * units: [[
     *     'millisecond', // unit name
     *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
     * ], [
     *     'second',
     *     [1, 2, 5, 10, 15, 30]
     * ], [
     *     'minute',
     *     [1, 2, 5, 10, 15, 30]
     * ], [
     *     'hour',
     *     [1, 2, 3, 4, 6, 8, 12]
     * ], [
     *     'day',
     *     [1, 2]
     * ], [
     *     'week',
     *     [1, 2]
     * ], [
     *     'month',
     *     [1, 2, 3, 4, 6]
     * ], [
     *     'year',
     *     null
     * ]]
     * ```
     *
     * @type      {Array<Array<string,(Array<number>|null)>>}
     * @product   highcharts highstock gantt
     * @apioption xAxis.units
     */
    /**
     * Whether axis, including axis title, line, ticks and labels, should
     * be visible.
     *
     * @since     4.1.9
     * @product   highcharts highstock gantt
     */
    visible: true,
    /**
     * Color of the minor, secondary grid lines.
     *
     * In styled mode, the stroke width is given in the
     * `.highcharts-minor-grid-line` class.
     *
     * @sample {highcharts} highcharts/yaxis/minorgridlinecolor/
     *         Bright grey lines from Y axis
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/minorgridlinecolor/
     *         Bright grey lines from Y axis
     *
     * @type    {Highcharts.ColorType}
     * @default #f2f2f2
     */
    minorGridLineColor: Palette_default.neutralColor5,
    /**
     * Width of the minor, secondary grid lines.
     *
     * In styled mode, the stroke width is given in the
     * `.highcharts-grid-line` class.
     *
     * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/
     *         2px lines from Y axis
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/minorgridlinewidth/
     *         2px lines from Y axis
     */
    minorGridLineWidth: 1,
    /**
     * Color for the minor tick marks.
     *
     * @sample {highcharts} highcharts/yaxis/minortickcolor/
     *         Black tick marks on Y axis
     * @sample {highstock} stock/xaxis/minorticks/
     *         Black tick marks on Y axis
     *
     * @type    {Highcharts.ColorType}
     * @default #999999
     */
    minorTickColor: Palette_default.neutralColor40,
    /**
     * The color of the line marking the axis itself.
     *
     * In styled mode, the line stroke is given in the
     * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
     *
     * @productdesc {highmaps}
     * In Highmaps, the axis line is hidden by default, because the axis is
     * not visible by default.
     *
     * @sample {highcharts} highcharts/yaxis/linecolor/
     *         A red line on Y axis
     * @sample {highcharts|highstock} highcharts/css/axis/
     *         Axes in styled mode
     * @sample {highstock} stock/xaxis/linecolor/
     *         A red line on X axis
     *
     * @type    {Highcharts.ColorType}
     * @default #ccd6eb
     */
    lineColor: Palette_default.highlightColor20,
    /**
     * The width of the line marking the axis itself.
     *
     * In styled mode, the stroke width is given in the
     * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
     *
     * @sample {highcharts} highcharts/yaxis/linecolor/
     *         A 1px line on Y axis
     * @sample {highcharts|highstock} highcharts/css/axis/
     *         Axes in styled mode
     * @sample {highstock} stock/xaxis/linewidth/
     *         A 2px line on X axis
     *
     * @default {highcharts|highstock} 1
     * @default {highmaps} 0
     */
    lineWidth: 1,
    /**
     * Color of the grid lines extending the ticks across the plot area.
     *
     * In styled mode, the stroke is given in the `.highcharts-grid-line`
     * class.
     *
     * @productdesc {highmaps}
     * In Highmaps, the grid lines are hidden by default.
     *
     * @sample {highcharts} highcharts/yaxis/gridlinecolor/
     *         Green lines
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/gridlinecolor/
     *         Green lines
     *
     * @type    {Highcharts.ColorType}
     * @default #e6e6e6
     */
    gridLineColor: Palette_default.neutralColor10,
    /**
     * The width of the grid lines extending the ticks across the plot area.
     * Defaults to 1 on the Y axis and 0 on the X axis, except for 3d
     * charts.
     *
     * In styled mode, the stroke width is given in the
     * `.highcharts-grid-line` class.
     *
     * @sample {highcharts} highcharts/yaxis/gridlinewidth/
     *         2px lines
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/gridlinewidth/
     *         2px lines
     *
     * @type      {number}
     * @apioption xAxis.gridLineWidth
     */
    gridLineWidth: void 0,
    /**
     * The height as the vertical axis. If it's a number, it is
     * interpreted as pixels.
     *
     * Since Highcharts 2: If it's a percentage string, it is interpreted
     * as percentages of the total plot height.
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption xAxis.height
     */
    /**
     * The width as the horizontal axis. If it's a number, it is interpreted
     * as pixels.
     *
     * Since Highcharts v5.0.13: If it's a percentage string, it is
     * interpreted as percentages of the total plot width.
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption xAxis.width
     */
    /**
     * Color for the main tick marks.
     *
     * In styled mode, the stroke is given in the `.highcharts-tick`
     * class.
     *
     * @sample {highcharts} highcharts/xaxis/tickcolor/
     *         Red ticks on X axis
     * @sample {highcharts|highstock} highcharts/css/axis-grid/
     *         Styled mode
     * @sample {highstock} stock/xaxis/ticks/
     *         Formatted ticks on X axis
     *
     * @type    {Highcharts.ColorType}
     * @default #ccd6eb
     */
    tickColor: Palette_default.highlightColor20
    // tickWidth: 1
  };
  AxisDefaults2.defaultYAxisOptions = {
    /**
     * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`,
     * `category` or `treegrid`. Defaults to `treegrid` for Gantt charts,
     * `linear` for other chart types.
     *
     * In a datetime axis, the numbers are given in milliseconds, and tick
     * marks are placed on appropriate values, like full hours or days. In a
     * category or treegrid axis, the [point names](#series.line.data.name)
     * of the chart's series are used for categories, if a
     * [categories](#xAxis.categories) array is not defined.
     *
     * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
     *         Logarithmic with minor grid lines
     * @sample {highcharts} highcharts/yaxis/type-log-negative/
     *         Logarithmic with extension to emulate negative values
     * @sample {gantt} gantt/treegrid-axis/demo
     *         Treegrid axis
     *
     * @type      {Highcharts.AxisTypeValue}
     * @default   {highcharts} linear
     * @default   {gantt} treegrid
     * @product   highcharts gantt
     * @apioption yAxis.type
     */
    /**
     * The height of the Y axis. If it's a number, it is interpreted as
     * pixels.
     *
     * Since Highcharts 2: If it's a percentage string, it is interpreted as
     * percentages of the total plot height.
     *
     * @see [yAxis.top](#yAxis.top)
     *
     * @sample {highstock} stock/demo/candlestick-and-volume/
     *         Percentage height panes
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption yAxis.height
     */
    /**
     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
     * to represent the maximum value of the Y axis.
     *
     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
     *         Min and max colors
     *
     * @type      {Highcharts.ColorType}
     * @default   #003399
     * @since     4.0
     * @product   highcharts
     * @apioption yAxis.maxColor
     */
    /**
     * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
     * to represent the minimum value of the Y axis.
     *
     * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
     *         Min and max color
     *
     * @type      {Highcharts.ColorType}
     * @default   #e6ebf5
     * @since     4.0
     * @product   highcharts
     * @apioption yAxis.minColor
     */
    /**
     * Whether to reverse the axis so that the highest number is closest
     * to the origin.
     *
     * @sample {highcharts} highcharts/yaxis/reversed/
     *         Reversed Y axis
     * @sample {highstock} stock/xaxis/reversed/
     *         Reversed Y axis
     *
     * @type      {boolean}
     * @default   {highcharts} false
     * @default   {highstock} false
     * @default   {highmaps} true
     * @default   {gantt} true
     * @apioption yAxis.reversed
     */
    /**
     * If `true`, the first series in a stack will be drawn on top in a
     * positive, non-reversed Y axis. If `false`, the first series is in
     * the base of the stack.
     *
     * @sample {highcharts} highcharts/yaxis/reversedstacks-false/
     *         Non-reversed stacks
     * @sample {highstock} highcharts/yaxis/reversedstacks-false/
     *         Non-reversed stacks
     *
     * @type      {boolean}
     * @default   true
     * @since     3.0.10
     * @product   highcharts highstock
     * @apioption yAxis.reversedStacks
     */
    reversedStacks: true,
    /**
     * Solid gauge series only. Color stops for the solid gauge. Use this
     * in cases where a linear gradient between a `minColor` and `maxColor`
     * is not sufficient. The stops is an array of tuples, where the first
     * item is a float between 0 and 1 assigning the relative position in
     * the gradient, and the second item is the color.
     *
     * For solid gauges, the Y axis also inherits the concept of
     * [data classes](https://api.highcharts.com/highmaps#colorAxis.dataClasses)
     * from the Highmaps color axis.
     *
     * @see [minColor](#yAxis.minColor)
     * @see [maxColor](#yAxis.maxColor)
     *
     * @sample {highcharts} highcharts/demo/gauge-solid/
     *         True by default
     *
     * @type      {Array<Array<number,Highcharts.ColorType>>}
     * @since     4.0
     * @product   highcharts
     * @apioption yAxis.stops
     */
    /**
     * The pixel width of the major tick marks.
     *
     * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width
     * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
     *
     * @type      {number}
     * @default   0
     * @product   highcharts highstock gantt
     * @apioption yAxis.tickWidth
     */
    /**
     * Whether to force the axis to end on a tick. Use this option with
     * the `maxPadding` option to control the axis end.
     *
     * This option is always disabled, when panning type is
     * either `y` or `xy`.
     *
     * @see [type](#chart.panning.type)
     *
     *
     * @sample {highcharts} highcharts/chart/reflow-true/
     *         True by default
     * @sample {highcharts} highcharts/yaxis/endontick/
     *         False
     * @sample {highstock} stock/demo/basic-line/
     *         True by default
     * @sample {highstock} stock/xaxis/endontick/
     *         False for Y axis
     *
     * @since 1.2.0
     */
    endOnTick: true,
    /**
     * Padding of the max value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the highest data value to appear on the edge
     * of the plot area. When the axis' `max` option is set or a max extreme
     * is set using `axis.setExtremes()`, the maxPadding will be ignored.
     *
     * Also the `softThreshold` option takes precedence over `maxPadding`,
     * so if the data is tangent to the threshold, `maxPadding` may not
     * apply unless `softThreshold` is set to false.
     *
     * @sample {highcharts} highcharts/yaxis/maxpadding-02/
     *         Max padding of 0.2
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     *
     * @since   1.2.0
     * @product highcharts highstock gantt
     */
    maxPadding: 0.05,
    /**
     * Padding of the min value relative to the length of the axis. A
     * padding of 0.05 will make a 100px axis 5px longer. This is useful
     * when you don't want the lowest data value to appear on the edge
     * of the plot area. When the axis' `min` option is set or a max extreme
     * is set using `axis.setExtremes()`, the maxPadding will be ignored.
     *
     * Also the `softThreshold` option takes precedence over `minPadding`,
     * so if the data is tangent to the threshold, `minPadding` may not
     * apply unless `softThreshold` is set to false.
     *
     * @sample {highcharts} highcharts/yaxis/minpadding/
     *         Min padding of 0.2
     * @sample {highstock} stock/xaxis/minpadding-maxpadding/
     *         Greater min- and maxPadding
     *
     * @since   1.2.0
     * @product highcharts highstock gantt
     */
    minPadding: 0.05,
    /**
     * @productdesc {highstock}
     * In Highcharts Stock 1.x, the Y axis was placed
     * on the left side by default.
     *
     * @sample {highcharts} highcharts/yaxis/opposite/
     *         Secondary Y axis opposite
     * @sample {highstock} stock/xaxis/opposite/
     *         Y axis on left side
     *
     * @type      {boolean}
     * @default   {highstock} true
     * @default   {highcharts} false
     * @product   highstock highcharts gantt
     * @apioption yAxis.opposite
     */
    /**
     * @see [tickInterval](#xAxis.tickInterval)
     * @see [tickPositioner](#xAxis.tickPositioner)
     * @see [tickPositions](#xAxis.tickPositions)
     */
    tickPixelInterval: 72,
    showLastLabel: true,
    /**
     * @extends xAxis.labels
     */
    labels: {
      /**
       * Angular gauges and solid gauges only.
       * The label's pixel distance from the perimeter of the plot area.
       *
       * Since v7.1.2: If it's a percentage string, it is interpreted the
       * same as [series.radius](#plotOptions.gauge.radius), so label can be
       * aligned under the gauge's shape.
       *
       * @sample {highcharts} highcharts/yaxis/labels-distance/
       *         Labels centered under the arc
       *
       * @type      {number|string}
       * @default   -25
       * @product   highcharts
       * @apioption yAxis.labels.distance
       */
      /**
       * The y position offset of all labels relative to the tick
       * positions on the axis. For polar and radial axis consider the use
       * of the [distance](#yAxis.labels.distance) option.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         Y axis labels placed on grid lines
       *
       * @type      {number}
       * @default   {highcharts} 3
       * @default   {highstock} -2
       * @default   {highmaps} 3
       * @apioption yAxis.labels.y
       */
      /**
       * What part of the string the given position is anchored to. Can
       * be one of `"left"`, `"center"` or `"right"`. The exact position
       * also depends on the `labels.x` setting.
       *
       * Angular gauges and solid gauges defaults to `"center"`.
       * Solid gauges with two labels have additional option `"auto"`
       * for automatic horizontal and vertical alignment.
       *
       * @see [yAxis.labels.distance](#yAxis.labels.distance)
       *
       * @sample {highcharts} highcharts/yaxis/labels-align-left/
       *         Left
       * @sample {highcharts} highcharts/series-solidgauge/labels-auto-aligned/
       *         Solid gauge labels auto aligned
       *
       * @type       {Highcharts.AlignValue}
       * @default    {highcharts|highmaps} right
       * @default    {highstock} left
       * @apioption  yAxis.labels.align
       */
      /**
       * The x position offset of all labels relative to the tick
       * positions on the axis. Defaults to -15 for left axis, 15 for
       * right axis.
       *
       * @sample {highcharts} highcharts/xaxis/labels-x/
       *         Y axis labels placed on grid lines
       */
      x: -8
    },
    /**
     * @productdesc {highmaps}
     * In Highmaps, the axis line is hidden by default, because the axis is
     * not visible by default.
     *
     * @type      {Highcharts.ColorType}
     * @apioption yAxis.lineColor
     */
    /**
     * @sample {highcharts} highcharts/yaxis/max-200/
     *         Y axis max of 200
     * @sample {highcharts} highcharts/yaxis/max-logarithmic/
     *         Y axis max on logarithmic axis
     * @sample {highstock} stock/yaxis/min-max/
     *         Fixed min and max on Y axis
     * @sample {highmaps} maps/axis/min-max/
     *         Pre-zoomed to a specific area
     *
     * @apioption yAxis.max
     */
    /**
     * @sample {highcharts} highcharts/yaxis/min-startontick-false/
     *         -50 with startOnTick to false
     * @sample {highcharts} highcharts/yaxis/min-startontick-true/
     *         -50 with startOnTick true by default
     * @sample {highstock} stock/yaxis/min-max/
     *         Fixed min and max on Y axis
     * @sample {highmaps} maps/axis/min-max/
     *         Pre-zoomed to a specific area
     *
     * @apioption yAxis.min
     */
    /**
     * An optional scrollbar to display on the Y axis in response to
     * limiting the minimum an maximum of the axis values.
     *
     * In styled mode, all the presentational options for the scrollbar
     * are replaced by the classes `.highcharts-scrollbar-thumb`,
     * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
     * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
     *
     * @sample {highstock} stock/yaxis/scrollbar/
     *         Scrollbar on the Y axis
     *
     * @extends   scrollbar
     * @since     4.2.6
     * @product   highstock
     * @excluding height
     * @apioption yAxis.scrollbar
     */
    /**
     * Enable the scrollbar on the Y axis.
     *
     * @sample {highstock} stock/yaxis/scrollbar/
     *         Enabled on Y axis
     *
     * @type      {boolean}
     * @default   false
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.enabled
     */
    /**
     * Pixel margin between the scrollbar and the axis elements.
     *
     * @type      {number}
     * @default   10
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.margin
     */
    /**
     * Whether to show the scrollbar when it is fully zoomed out at max
     * range. Setting it to `false` on the Y axis makes the scrollbar stay
     * hidden until the user zooms in, like common in browsers.
     *
     * @type      {boolean}
     * @default   true
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.showFull
     */
    /**
     * The width of a vertical scrollbar or height of a horizontal
     * scrollbar. Defaults to 20 on touch devices.
     *
     * @type      {number}
     * @default   14
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.size
     */
    /**
     * Z index of the scrollbar elements.
     *
     * @type      {number}
     * @default   3
     * @since     4.2.6
     * @product   highstock
     * @apioption yAxis.scrollbar.zIndex
     */
    /**
     * A soft maximum for the axis. If the series data maximum is less
     * than this, the axis will stay at this maximum, but if the series
     * data maximum is higher, the axis will flex to show all data.
     *
     * **Note**: The [series.softThreshold](
     * #plotOptions.series.softThreshold) option takes precedence over this
     * option.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock gantt
     * @apioption yAxis.softMax
     */
    /**
     * A soft minimum for the axis. If the series data minimum is greater
     * than this, the axis will stay at this minimum, but if the series
     * data minimum is lower, the axis will flex to show all data.
     *
     * **Note**: The [series.softThreshold](
     * #plotOptions.series.softThreshold) option takes precedence over this
     * option.
     *
     * @sample highcharts/yaxis/softmin-softmax/
     *         Soft min and max
     *
     * @type      {number}
     * @since     5.0.1
     * @product   highcharts highstock gantt
     * @apioption yAxis.softMin
     */
    /**
     * Defines the horizontal alignment of the stack total label. Can be one
     * of `"left"`, `"center"` or `"right"`. The default value is calculated
     * at runtime and depends on orientation and whether the stack is
     * positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/
     *         Aligned to the left
     * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/
     *         Aligned in center
     * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/
     *         Aligned to the right
     *
     * @type      {Highcharts.AlignValue}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.align
     */
    /**
     * A format string for the data label. Available variables are the same
     * as for `formatter`.
     *
     * @type      {string}
     * @default   {total}
     * @since     3.0.2
     * @product   highcharts highstock
     * @apioption yAxis.stackLabels.format
     */
    /**
     * Rotation of the labels in degrees.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/
     *         Labels rotated 45
     *
     * @type      {number}
     * @default   0
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.rotation
     */
    /**
     * The text alignment for the label. While `align` determines where the
     * texts anchor point is placed with regards to the stack, `textAlign`
     * determines how the text is aligned against its anchor point. Possible
     * values are `"left"`, `"center"` and `"right"`. The default value is
     * calculated at runtime and depends on orientation and whether the
     * stack is positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/
     *         Label in center position but text-aligned left
     *
     * @type      {Highcharts.AlignValue}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.textAlign
     */
    /**
     * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the labels.
     *
     * @type      {boolean}
     * @default   false
     * @since     3.0
     * @product   highcharts highstock
     * @apioption yAxis.stackLabels.useHTML
     */
    /**
     * Defines the vertical alignment of the stack total label. Can be one
     * of `"top"`, `"middle"` or `"bottom"`. The default value is calculated
     * at runtime and depends on orientation and whether the stack is
     * positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/
     *         Vertically aligned top
     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/
     *         Vertically aligned middle
     * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/
     *         Vertically aligned bottom
     *
     * @type      {Highcharts.VerticalAlignValue}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.verticalAlign
     */
    /**
     * The x position offset of the label relative to the left of the
     * stacked bar. The default value is calculated at runtime and depends
     * on orientation and whether the stack is positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-x/
     *         Stack total labels with x offset
     *
     * @type      {number}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.x
     */
    /**
     * The y position offset of the label relative to the tick position
     * on the axis. The default value is calculated at runtime and depends
     * on orientation and whether the stack is positive or negative.
     *
     * @sample {highcharts} highcharts/yaxis/stacklabels-y/
     *         Stack total labels with y offset
     *
     * @type      {number}
     * @since     2.1.5
     * @product   highcharts
     * @apioption yAxis.stackLabels.y
     */
    /**
     * Whether to force the axis to start on a tick. Use this option with
     * the `maxPadding` option to control the axis start.
     *
     * This option is always disabled, when panning type is
     * either `y` or `xy`.
     *
     * @see [type](#chart.panning.type)
     *
     * @sample {highcharts} highcharts/xaxis/startontick-false/
     *         False by default
     * @sample {highcharts} highcharts/xaxis/startontick-true/
     *         True
     * @sample {highstock} stock/xaxis/endontick/
     *         False for Y axis
     *
     * @since   1.2.0
     * @product highcharts highstock gantt
     */
    startOnTick: true,
    title: {
      /**
       * The pixel distance between the axis labels and the title.
       * Positive values are outside the axis line, negative are inside.
       *
       * @sample {highcharts} highcharts/xaxis/title-margin/
       *         Y axis title margin of 60
       *
       * @type      {number}
       * @default   40
       * @apioption yAxis.title.margin
       */
      /**
       * The rotation of the text in degrees. 0 is horizontal, 270 is
       * vertical reading from bottom to top.
       *
       * @sample {highcharts} highcharts/yaxis/title-offset/
       *         Horizontal
       */
      rotation: 270,
      /**
       * The actual text of the axis title. Horizontal texts can contain
       * HTML, but rotated texts are painted using vector techniques and
       * must be clean text. The Y axis title is disabled by setting the
       * `text` option to `undefined`.
       *
       * @sample {highcharts} highcharts/xaxis/title-text/
       *         Custom HTML
       *
       * @type    {string|null}
       * @default {highcharts} Values
       * @default {highstock} undefined
       * @product highcharts highstock gantt
       */
      text: "Values"
    },
    /**
     * The top position of the Y axis. If it's a number, it is interpreted
     * as pixel position relative to the chart.
     *
     * Since Highcharts 2: If it's a percentage string, it is interpreted as
     * percentages of the plot height, offset from plot area top.
     *
     * @see [yAxis.height](#yAxis.height)
     *
     * @sample {highstock} stock/demo/candlestick-and-volume/
     *         Percentage height panes
     *
     * @type      {number|string}
     * @product   highcharts highstock
     * @apioption yAxis.top
     */
    /**
     * The stack labels show the total value for each bar in a stacked
     * column or bar chart. The label will be placed on top of positive
     * columns and below negative columns. In case of an inverted column
     * chart or a bar chart the label is placed to the right of positive
     * bars and to the left of negative bars.
     *
     * @product highcharts
     */
    stackLabels: {
      /**
       * Enable or disable the initial animation when a series is
       * displayed for the `stackLabels`. The animation can also be set as
       * a configuration object. Please note that this option only
       * applies to the initial animation.
       * For other animations, see [chart.animation](#chart.animation)
       * and the animation parameter under the API methods.
       * The following properties are supported:
       *
       * - `defer`: The animation delay time in milliseconds.
       *
       * @sample {highcharts} highcharts/plotoptions/animation-defer/
       *          Animation defer settings
       * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @since 8.2.0
       * @apioption yAxis.stackLabels.animation
       */
      animation: {},
      /**
       * The animation delay time in milliseconds.
       * Set to `0` renders stackLabel immediately.
       * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
       *
       * @type      {number}
       * @since 8.2.0
       * @apioption yAxis.stackLabels.animation.defer
       */
      /**
       * Allow the stack labels to overlap.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
       *         Default false
       *
       * @since   5.0.13
       * @product highcharts
       */
      allowOverlap: false,
      /**
       * The background color or gradient for the stack label.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-box/
       *          Stack labels box options
       * @type      {Highcharts.ColorType}
       * @since 8.1.0
       * @apioption yAxis.stackLabels.backgroundColor
       */
      /**
       * The border color for the stack label. Defaults to `undefined`.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-box/
       *          Stack labels box options
       * @type      {Highcharts.ColorType}
       * @since 8.1.0
       * @apioption yAxis.stackLabels.borderColor
       */
      /**
       * The border radius in pixels for the stack label.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-box/
       *          Stack labels box options
       * @type      {number}
       * @default   0
       * @since 8.1.0
       * @apioption yAxis.stackLabels.borderRadius
       */
      /**
       * The border width in pixels for the stack label.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-box/
       *          Stack labels box options
       * @type      {number}
       * @default   0
       * @since 8.1.0
       * @apioption yAxis.stackLabels.borderWidth
       */
      /**
       * Enable or disable the stack total labels.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/
       *         Enabled stack total labels
       * @sample {highcharts} highcharts/yaxis/stacklabels-enabled-waterfall/
       *         Enabled stack labels in waterfall chart
       *
       * @since   2.1.5
       * @product highcharts
       */
      enabled: false,
      /**
       * Whether to hide stack labels that are outside the plot area.
       * By default, the stack label is moved
       * inside the plot area according to the
       * [overflow](/highcharts/#yAxis/stackLabels/overflow)
       * option.
       *
       * @type  {boolean}
       * @since 7.1.3
       */
      crop: true,
      /**
       * How to handle stack total labels that flow outside the plot area.
       * The default is set to `"justify"`,
       * which aligns them inside the plot area.
       * For columns and bars, this means it will be moved inside the bar.
       * To display stack labels outside the plot area,
       * set `crop` to `false` and `overflow` to `"allow"`.
       *
       * @sample highcharts/yaxis/stacklabels-overflow/
       *         Stack labels flows outside the plot area.
       *
       * @type  {Highcharts.DataLabelsOverflowValue}
       * @since 7.1.3
       */
      overflow: "justify",
      /* eslint-disable valid-jsdoc */
      /**
       * Callback JavaScript function to format the label. The value is
       * given by `this.total`.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/
       *         Added units to stack total value
       *
       * @type    {Highcharts.FormatterCallbackFunction<Highcharts.StackItemObject>}
       * @since   2.1.5
       * @product highcharts
       */
      formatter: function() {
        var numberFormatter = this.axis.chart.numberFormatter;
        return numberFormatter(this.total, -1);
      },
      /**
       * CSS styles for the label.
       *
       * In styled mode, the styles are set in the
       * `.highcharts-stack-label` class.
       *
       * @sample {highcharts} highcharts/yaxis/stacklabels-style/
       *         Red stack total labels
       *
       * @type    {Highcharts.CSSObject}
       * @since   2.1.5
       * @product highcharts
       */
      style: {
        /** @internal */
        color: Palette_default.neutralColor100,
        /** @internal */
        fontSize: "11px",
        /** @internal */
        fontWeight: "bold",
        /** @internal */
        textOutline: "1px contrast"
      }
    },
    gridLineWidth: 1,
    lineWidth: 0
    // tickWidth: 0
  };
  AxisDefaults2.defaultLeftAxisOptions = {
    labels: {
      x: -15
    },
    title: {
      rotation: 270
    }
  };
  AxisDefaults2.defaultRightAxisOptions = {
    labels: {
      x: 15
    },
    title: {
      rotation: 90
    }
  };
  AxisDefaults2.defaultBottomAxisOptions = {
    labels: {
      autoRotation: [-45],
      x: 0
      // overflow: undefined,
      // staggerLines: null
    },
    margin: 15,
    title: {
      rotation: 0
    }
  };
  AxisDefaults2.defaultTopAxisOptions = {
    labels: {
      autoRotation: [-45],
      x: 0
      // overflow: undefined
      // staggerLines: null
    },
    margin: 15,
    title: {
      rotation: 0
    }
  };
})(AxisDefaults || (AxisDefaults = {}));
var AxisDefaults_default = AxisDefaults;

// node_modules/highcharts/es-modules/Core/Foundation.js
var addEvent4 = Utilities_default.addEvent;
var isFunction3 = Utilities_default.isFunction;
var objectEach8 = Utilities_default.objectEach;
var removeEvent3 = Utilities_default.removeEvent;
var registerEventOptions = function(component, options) {
  component.eventOptions = component.eventOptions || {};
  objectEach8(options.events, function(event, eventType) {
    if (component.eventOptions[eventType] !== event) {
      if (component.eventOptions[eventType]) {
        removeEvent3(component, eventType, component.eventOptions[eventType]);
        delete component.eventOptions[eventType];
      }
      if (isFunction3(event)) {
        component.eventOptions[eventType] = event;
        addEvent4(component, eventType, event);
      }
    }
  });
};
var exports = {
  registerEventOptions
};
var Foundation_default = exports;

// node_modules/highcharts/es-modules/Core/Axis/Tick.js
var deg2rad3 = Globals_default.deg2rad;
var clamp3 = Utilities_default.clamp;
var correctFloat2 = Utilities_default.correctFloat;
var defined9 = Utilities_default.defined;
var destroyObjectProperties3 = Utilities_default.destroyObjectProperties;
var extend8 = Utilities_default.extend;
var fireEvent3 = Utilities_default.fireEvent;
var isNumber10 = Utilities_default.isNumber;
var merge9 = Utilities_default.merge;
var objectEach9 = Utilities_default.objectEach;
var pick13 = Utilities_default.pick;
var Tick = (
  /** @class */
  function() {
    function Tick2(axis, pos, type, noLabel, parameters) {
      this.isNew = true;
      this.isNewLabel = true;
      this.axis = axis;
      this.pos = pos;
      this.type = type || "";
      this.parameters = parameters || {};
      this.tickmarkOffset = this.parameters.tickmarkOffset;
      this.options = this.parameters.options;
      fireEvent3(this, "init");
      if (!type && !noLabel) {
        this.addLabel();
      }
    }
    Tick2.prototype.addLabel = function() {
      var tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, categories = axis.categories, log = axis.logarithmic, names = axis.names, pos = tick.pos, labelOptions = pick13(tick.options && tick.options.labels, options.labels), tickPositions = axis.tickPositions, isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], animateLabels = (!labelOptions.step || labelOptions.step === 1) && axis.tickInterval === 1, tickPositionInfo = tickPositions.info;
      var label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;
      var value = this.parameters.category || (categories ? pick13(categories[pos], names[pos], pos) : pos);
      if (log && isNumber10(value)) {
        value = correctFloat2(log.lin2log(value));
      }
      if (axis.dateTime) {
        if (tickPositionInfo) {
          dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[!options.grid && tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName]);
          dateTimeLabelFormat = dateTimeLabelFormats.main;
        } else if (isNumber10(value)) {
          dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats || {});
        }
      }
      tick.isFirst = isFirst;
      tick.isLast = isLast;
      var ctx = {
        axis,
        chart,
        dateTimeLabelFormat,
        isFirst,
        isLast,
        pos,
        tick,
        tickPositionInfo,
        value
      };
      fireEvent3(this, "labelFormat", ctx);
      var labelFormatter = function(ctx2) {
        if (labelOptions.formatter) {
          return labelOptions.formatter.call(ctx2, ctx2);
        }
        if (labelOptions.format) {
          ctx2.text = axis.defaultLabelFormatter.call(ctx2);
          return FormatUtilities_default.format(labelOptions.format, ctx2, chart);
        }
        return axis.defaultLabelFormatter.call(ctx2, ctx2);
      };
      var str = labelFormatter.call(ctx, ctx);
      var list = dateTimeLabelFormats && dateTimeLabelFormats.list;
      if (list) {
        tick.shortenLabel = function() {
          for (i = 0; i < list.length; i++) {
            extend8(ctx, { dateTimeLabelFormat: list[i] });
            label.attr({
              text: labelFormatter.call(ctx, ctx)
            });
            if (label.getBBox().width < axis.getSlotWidth(tick) - 2 * labelOptions.padding) {
              return;
            }
          }
          label.attr({
            text: ""
          });
        };
      } else {
        tick.shortenLabel = void 0;
      }
      if (animateLabels && axis._addedPlotLB) {
        tick.moveLabel(str, labelOptions);
      }
      if (!defined9(label) && !tick.movedLabel) {
        tick.label = label = tick.createLabel({ x: 0, y: 0 }, str, labelOptions);
        tick.rotation = 0;
      } else if (label && label.textStr !== str && !animateLabels) {
        if (label.textWidth && !labelOptions.style.width && !label.styles.width) {
          label.css({ width: null });
        }
        label.attr({ text: str });
        label.textPxLength = label.getBBox().width;
      }
    };
    Tick2.prototype.createLabel = function(xy, str, labelOptions) {
      var axis = this.axis, chart = axis.chart, label = defined9(str) && labelOptions.enabled ? chart.renderer.text(str, xy.x, xy.y, labelOptions.useHTML).add(axis.labelGroup) : null;
      if (label) {
        if (!chart.styledMode) {
          label.css(merge9(labelOptions.style));
        }
        label.textPxLength = label.getBBox().width;
      }
      return label;
    };
    Tick2.prototype.destroy = function() {
      destroyObjectProperties3(this, this.axis);
    };
    Tick2.prototype.getPosition = function(horiz, tickPos, tickmarkOffset, old) {
      var axis = this.axis, chart = axis.chart, cHeight = old && chart.oldChartHeight || chart.chartHeight, pos = {
        x: horiz ? correctFloat2(axis.translate(tickPos + tickmarkOffset, null, null, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
        y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : correctFloat2(cHeight - axis.translate(tickPos + tickmarkOffset, null, null, old) - axis.transB)
      };
      pos.y = clamp3(pos.y, -1e5, 1e5);
      fireEvent3(this, "afterGetPosition", { pos });
      return pos;
    };
    Tick2.prototype.getLabelPosition = function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
      var axis = this.axis, transA = axis.transA, reversed = (
        // #7911
        axis.isLinked && axis.linkedParent ? axis.linkedParent.reversed : axis.reversed
      ), staggerLines = axis.staggerLines, rotCorr = axis.tickRotCorr || { x: 0, y: 0 }, labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === "center" ? 0.5 : 1) : 0, pos = {};
      var yOffset = labelOptions.y, line;
      if (!defined9(yOffset)) {
        if (axis.side === 0) {
          yOffset = label.rotation ? -8 : -label.getBBox().height;
        } else if (axis.side === 2) {
          yOffset = rotCorr.y + 8;
        } else {
          yOffset = Math.cos(label.rotation * deg2rad3) * (rotCorr.y - label.getBBox(false, 0).height / 2);
        }
      }
      x = x + labelOptions.x + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
      y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
      if (staggerLines) {
        line = index / (step || 1) % staggerLines;
        if (axis.opposite) {
          line = staggerLines - line - 1;
        }
        y += line * (axis.labelOffset / staggerLines);
      }
      pos.x = x;
      pos.y = Math.round(y);
      fireEvent3(this, "afterGetLabelPosition", { pos, tickmarkOffset, index });
      return pos;
    };
    Tick2.prototype.getLabelSize = function() {
      return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
    };
    Tick2.prototype.getMarkPath = function(x, y, tickLength, tickWidth, horiz, renderer) {
      return renderer.crispLine([[
        "M",
        x,
        y
      ], [
        "L",
        x + (horiz ? 0 : -tickLength),
        y + (horiz ? tickLength : 0)
      ]], tickWidth);
    };
    Tick2.prototype.handleOverflow = function(xy) {
      var tick = this, axis = this.axis, labelOptions = axis.options.labels, pxPos = xy.x, chartWidth = axis.chart.chartWidth, spacing = axis.chart.spacing, leftBound = pick13(axis.labelLeft, Math.min(axis.pos, spacing[3])), rightBound = pick13(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])), label = this.label, rotation = this.rotation, factor = {
        left: 0,
        center: 0.5,
        right: 1
      }[axis.labelAlign || label.attr("align")], labelWidth = label.getBBox().width, slotWidth = axis.getSlotWidth(tick), xCorrection = factor, css16 = {};
      var modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;
      if (!rotation && labelOptions.overflow === "justify") {
        leftPos = pxPos - factor * labelWidth;
        rightPos = pxPos + (1 - factor) * labelWidth;
        if (leftPos < leftBound) {
          modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
        } else if (rightPos > rightBound) {
          modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
          goRight = -1;
        }
        modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth);
        if (modifiedSlotWidth < slotWidth && axis.labelAlign === "center") {
          xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
        }
        if (labelWidth > modifiedSlotWidth || axis.autoRotation && (label.styles || {}).width) {
          textWidth = modifiedSlotWidth;
        }
      } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
        textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad3) - leftBound);
      } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
        textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad3));
      }
      if (textWidth) {
        if (tick.shortenLabel) {
          tick.shortenLabel();
        } else {
          css16.width = Math.floor(textWidth) + "px";
          if (!(labelOptions.style || {}).textOverflow) {
            css16.textOverflow = "ellipsis";
          }
          label.css(css16);
        }
      }
    };
    Tick2.prototype.moveLabel = function(str, labelOptions) {
      var tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed;
      var moved = false, labelPos, xPos, yPos;
      if (label && label.textStr === str) {
        tick.movedLabel = label;
        moved = true;
        delete tick.label;
      } else {
        objectEach9(axis.ticks, function(currentTick) {
          if (!moved && !currentTick.isNew && currentTick !== tick && currentTick.label && currentTick.label.textStr === str) {
            tick.movedLabel = currentTick.label;
            moved = true;
            currentTick.labelPos = tick.movedLabel.xy;
            delete currentTick.label;
          }
        });
      }
      if (!moved && (tick.labelPos || label)) {
        labelPos = tick.labelPos || label.xy;
        xPos = axis.horiz ? reversed ? 0 : axis.width + axis.left : labelPos.x;
        yPos = axis.horiz ? labelPos.y : reversed ? axis.width + axis.left : 0;
        tick.movedLabel = tick.createLabel({ x: xPos, y: yPos }, str, labelOptions);
        if (tick.movedLabel) {
          tick.movedLabel.attr({ opacity: 0 });
        }
      }
    };
    Tick2.prototype.render = function(index, old, opacity) {
      var tick = this, axis = tick.axis, horiz = axis.horiz, pos = tick.pos, tickmarkOffset = pick13(tick.tickmarkOffset, axis.tickmarkOffset), xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1;
      var labelOpacity = pick13(
        opacity,
        tick.label && tick.label.newOpacity,
        // #15528
        1
      );
      opacity = pick13(opacity, 1);
      this.isActive = true;
      this.renderGridLine(old, opacity, reverseCrisp);
      this.renderMark(xy, opacity, reverseCrisp);
      this.renderLabel(xy, old, labelOpacity, index);
      tick.isNew = false;
      fireEvent3(this, "afterRender");
    };
    Tick2.prototype.renderGridLine = function(old, opacity, reverseCrisp) {
      var tick = this, axis = tick.axis, options = axis.options, attribs = {}, pos = tick.pos, type = tick.type, tickmarkOffset = pick13(tick.tickmarkOffset, axis.tickmarkOffset), renderer = axis.chart.renderer;
      var gridLine = tick.gridLine, gridLinePath, gridLineWidth = options.gridLineWidth, gridLineColor = options.gridLineColor, dashStyle = options.gridLineDashStyle;
      if (tick.type === "minor") {
        gridLineWidth = options.minorGridLineWidth;
        gridLineColor = options.minorGridLineColor;
        dashStyle = options.minorGridLineDashStyle;
      }
      if (!gridLine) {
        if (!axis.chart.styledMode) {
          attribs.stroke = gridLineColor;
          attribs["stroke-width"] = gridLineWidth || 0;
          attribs.dashstyle = dashStyle;
        }
        if (!type) {
          attribs.zIndex = 1;
        }
        if (old) {
          opacity = 0;
        }
        tick.gridLine = gridLine = renderer.path().attr(attribs).addClass("highcharts-" + (type ? type + "-" : "") + "grid-line").add(axis.gridGroup);
      }
      if (gridLine) {
        gridLinePath = axis.getPlotLinePath({
          value: pos + tickmarkOffset,
          lineWidth: gridLine.strokeWidth() * reverseCrisp,
          force: "pass",
          old
        });
        if (gridLinePath) {
          gridLine[old || tick.isNew ? "attr" : "animate"]({
            d: gridLinePath,
            opacity
          });
        }
      }
    };
    Tick2.prototype.renderMark = function(xy, opacity, reverseCrisp) {
      var tick = this, axis = tick.axis, options = axis.options, renderer = axis.chart.renderer, type = tick.type, tickSize = axis.tickSize(type ? type + "Tick" : "tick"), x = xy.x, y = xy.y, tickWidth = pick13(options[type !== "minor" ? "tickWidth" : "minorTickWidth"], !type && axis.isXAxis ? 1 : 0), tickColor = options[type !== "minor" ? "tickColor" : "minorTickColor"];
      var mark = tick.mark;
      var isNewMark = !mark;
      if (tickSize) {
        if (axis.opposite) {
          tickSize[0] = -tickSize[0];
        }
        if (!mark) {
          tick.mark = mark = renderer.path().addClass("highcharts-" + (type ? type + "-" : "") + "tick").add(axis.axisGroup);
          if (!axis.chart.styledMode) {
            mark.attr({
              stroke: tickColor,
              "stroke-width": tickWidth
            });
          }
        }
        mark[isNewMark ? "attr" : "animate"]({
          d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),
          opacity
        });
      }
    };
    Tick2.prototype.renderLabel = function(xy, old, opacity, index) {
      var tick = this, axis = tick.axis, horiz = axis.horiz, options = axis.options, label = tick.label, labelOptions = options.labels, step = labelOptions.step, tickmarkOffset = pick13(tick.tickmarkOffset, axis.tickmarkOffset), x = xy.x, y = xy.y;
      var show = true;
      if (label && isNumber10(x)) {
        label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
        if (tick.isFirst && !tick.isLast && !options.showFirstLabel || tick.isLast && !tick.isFirst && !options.showLastLabel) {
          show = false;
        } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
          tick.handleOverflow(xy);
        }
        if (step && index % step) {
          show = false;
        }
        if (show && isNumber10(xy.y)) {
          xy.opacity = opacity;
          label[tick.isNewLabel ? "attr" : "animate"](xy);
          tick.isNewLabel = false;
        } else {
          label.attr("y", -9999);
          tick.isNewLabel = true;
        }
      }
    };
    Tick2.prototype.replaceMovedLabel = function() {
      var tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed;
      var x, y;
      if (label && !tick.isNew) {
        x = axis.horiz ? reversed ? axis.left : axis.width + axis.left : label.xy.x;
        y = axis.horiz ? label.xy.y : reversed ? axis.width + axis.top : axis.top;
        label.animate({ x, y, opacity: 0 }, void 0, label.destroy);
        delete tick.label;
      }
      axis.isDirty = true;
      tick.label = tick.movedLabel;
      delete tick.movedLabel;
    };
    return Tick2;
  }()
);
var Tick_default = Tick;

// node_modules/highcharts/es-modules/Core/Axis/Axis.js
var animObject3 = AnimationUtilities_default.animObject;
var defaultOptions3 = DefaultOptions_default.defaultOptions;
var registerEventOptions2 = Foundation_default.registerEventOptions;
var deg2rad4 = Globals_default.deg2rad;
var arrayMax2 = Utilities_default.arrayMax;
var arrayMin2 = Utilities_default.arrayMin;
var clamp4 = Utilities_default.clamp;
var correctFloat3 = Utilities_default.correctFloat;
var defined10 = Utilities_default.defined;
var destroyObjectProperties4 = Utilities_default.destroyObjectProperties;
var erase3 = Utilities_default.erase;
var error4 = Utilities_default.error;
var extend9 = Utilities_default.extend;
var fireEvent4 = Utilities_default.fireEvent;
var getMagnitude2 = Utilities_default.getMagnitude;
var isArray5 = Utilities_default.isArray;
var isNumber11 = Utilities_default.isNumber;
var isString6 = Utilities_default.isString;
var merge10 = Utilities_default.merge;
var normalizeTickInterval2 = Utilities_default.normalizeTickInterval;
var objectEach10 = Utilities_default.objectEach;
var pick14 = Utilities_default.pick;
var relativeLength2 = Utilities_default.relativeLength;
var removeEvent4 = Utilities_default.removeEvent;
var splat4 = Utilities_default.splat;
var syncTimeout3 = Utilities_default.syncTimeout;
var Axis = (
  /** @class */
  function() {
    function Axis2(chart, userOptions) {
      this.alternateBands = void 0;
      this.bottom = void 0;
      this.categories = void 0;
      this.chart = void 0;
      this.closestPointRange = void 0;
      this.coll = void 0;
      this.eventOptions = void 0;
      this.hasNames = void 0;
      this.hasVisibleSeries = void 0;
      this.height = void 0;
      this.isLinked = void 0;
      this.labelEdge = void 0;
      this.labelFormatter = void 0;
      this.left = void 0;
      this.len = void 0;
      this.max = void 0;
      this.maxLabelLength = void 0;
      this.min = void 0;
      this.minorTickInterval = void 0;
      this.minorTicks = void 0;
      this.minPixelPadding = void 0;
      this.names = void 0;
      this.offset = void 0;
      this.options = void 0;
      this.overlap = void 0;
      this.paddedTicks = void 0;
      this.plotLinesAndBands = void 0;
      this.plotLinesAndBandsGroups = void 0;
      this.pointRange = void 0;
      this.pointRangePadding = void 0;
      this.pos = void 0;
      this.positiveValuesOnly = void 0;
      this.right = void 0;
      this.series = void 0;
      this.side = void 0;
      this.tickAmount = void 0;
      this.tickInterval = void 0;
      this.tickmarkOffset = void 0;
      this.tickPositions = void 0;
      this.tickRotCorr = void 0;
      this.ticks = void 0;
      this.top = void 0;
      this.transA = void 0;
      this.transB = void 0;
      this.translationSlope = void 0;
      this.userOptions = void 0;
      this.visible = void 0;
      this.width = void 0;
      this.zoomEnabled = void 0;
      this.init(chart, userOptions);
    }
    Axis2.prototype.init = function(chart, userOptions) {
      var isXAxis = userOptions.isX, axis = this;
      axis.chart = chart;
      axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;
      axis.isXAxis = isXAxis;
      axis.coll = axis.coll || (isXAxis ? "xAxis" : "yAxis");
      fireEvent4(this, "init", { userOptions });
      axis.opposite = pick14(userOptions.opposite, axis.opposite);
      axis.side = pick14(
        userOptions.side,
        axis.side,
        axis.horiz ? axis.opposite ? 0 : 2 : (
          // top : bottom
          axis.opposite ? 1 : 3
        )
        // right : left
      );
      axis.setOptions(userOptions);
      var options = this.options, labelsOptions = options.labels, type = options.type;
      axis.userOptions = userOptions;
      axis.minPixelPadding = 0;
      axis.reversed = pick14(options.reversed, axis.reversed);
      axis.visible = options.visible;
      axis.zoomEnabled = options.zoomEnabled;
      axis.hasNames = type === "category" || options.categories === true;
      axis.categories = options.categories || axis.hasNames;
      if (!axis.names) {
        axis.names = [];
        axis.names.keys = {};
      }
      axis.plotLinesAndBandsGroups = {};
      axis.positiveValuesOnly = !!axis.logarithmic;
      axis.isLinked = defined10(options.linkedTo);
      axis.ticks = {};
      axis.labelEdge = [];
      axis.minorTicks = {};
      axis.plotLinesAndBands = [];
      axis.alternateBands = {};
      axis.len = 0;
      axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
      axis.range = options.range;
      axis.offset = options.offset || 0;
      axis.max = null;
      axis.min = null;
      var crosshair = pick14(options.crosshair, splat4(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);
      axis.crosshair = crosshair === true ? {} : crosshair;
      if (chart.axes.indexOf(axis) === -1) {
        if (isXAxis) {
          chart.axes.splice(chart.xAxis.length, 0, axis);
        } else {
          chart.axes.push(axis);
        }
        chart[axis.coll].push(axis);
      }
      axis.series = axis.series || [];
      if (chart.inverted && !axis.isZAxis && isXAxis && typeof axis.reversed === "undefined") {
        axis.reversed = true;
      }
      axis.labelRotation = isNumber11(labelsOptions.rotation) ? labelsOptions.rotation : void 0;
      registerEventOptions2(axis, options);
      fireEvent4(this, "afterInit");
    };
    Axis2.prototype.setOptions = function(userOptions) {
      this.options = merge10(AxisDefaults_default.defaultXAxisOptions, this.coll === "yAxis" && AxisDefaults_default.defaultYAxisOptions, [
        AxisDefaults_default.defaultTopAxisOptions,
        AxisDefaults_default.defaultRightAxisOptions,
        AxisDefaults_default.defaultBottomAxisOptions,
        AxisDefaults_default.defaultLeftAxisOptions
      ][this.side], merge10(
        // if set in setOptions (#1053):
        defaultOptions3[this.coll],
        userOptions
      ));
      fireEvent4(this, "afterSetOptions", { userOptions });
    };
    Axis2.prototype.defaultLabelFormatter = function(ctx) {
      var axis = this.axis, chart = this.chart, numberFormatter = chart.numberFormatter, value = isNumber11(this.value) ? this.value : NaN, time = axis.chart.time, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, lang2 = defaultOptions3.lang, numericSymbols = lang2.numericSymbols, numSymMagnitude = lang2.numericSymbolMagnitude || 1e3, numericSymbolDetector = axis.logarithmic ? Math.abs(value) : axis.tickInterval;
      var i = numericSymbols && numericSymbols.length, multi, ret;
      if (categories) {
        ret = "" + this.value;
      } else if (dateTimeLabelFormat) {
        ret = time.dateFormat(dateTimeLabelFormat, value);
      } else if (i && numericSymbolDetector >= 1e3) {
        while (i-- && typeof ret === "undefined") {
          multi = Math.pow(numSymMagnitude, i + 1);
          if (
            // Only accept a numeric symbol when the distance is more
            // than a full unit. So for example if the symbol is k, we
            // don't accept numbers like 0.5k.
            numericSymbolDetector >= multi && // Accept one decimal before the symbol. Accepts 0.5k but
            // not 0.25k. How does this work with the previous?
            value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0
          ) {
            ret = numberFormatter(value / multi, -1) + numericSymbols[i];
          }
        }
      }
      if (typeof ret === "undefined") {
        if (Math.abs(value) >= 1e4) {
          ret = numberFormatter(value, -1);
        } else {
          ret = numberFormatter(value, -1, void 0, "");
        }
      }
      return ret;
    };
    Axis2.prototype.getSeriesExtremes = function() {
      var axis = this, chart = axis.chart;
      var xExtremes;
      fireEvent4(this, "getSeriesExtremes", null, function() {
        axis.hasVisibleSeries = false;
        axis.dataMin = axis.dataMax = axis.threshold = null;
        axis.softThreshold = !axis.isXAxis;
        if (axis.stacking) {
          axis.stacking.buildStacks();
        }
        axis.series.forEach(function(series) {
          if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
            var seriesOptions = series.options;
            var xData = void 0, threshold = seriesOptions.threshold, seriesDataMin = void 0, seriesDataMax = void 0;
            axis.hasVisibleSeries = true;
            if (axis.positiveValuesOnly && threshold <= 0) {
              threshold = null;
            }
            if (axis.isXAxis) {
              xData = series.xData;
              if (xData.length) {
                var isPositive = function(number) {
                  return number > 0;
                };
                xData = axis.logarithmic ? xData.filter(axis.validatePositiveValue) : xData;
                xExtremes = series.getXExtremes(xData);
                seriesDataMin = xExtremes.min;
                seriesDataMax = xExtremes.max;
                if (!isNumber11(seriesDataMin) && // #5010:
                !(seriesDataMin instanceof Date)) {
                  xData = xData.filter(isNumber11);
                  xExtremes = series.getXExtremes(xData);
                  seriesDataMin = xExtremes.min;
                  seriesDataMax = xExtremes.max;
                }
                if (xData.length) {
                  axis.dataMin = Math.min(pick14(axis.dataMin, seriesDataMin), seriesDataMin);
                  axis.dataMax = Math.max(pick14(axis.dataMax, seriesDataMax), seriesDataMax);
                }
              }
            } else {
              var dataExtremes = series.applyExtremes();
              if (isNumber11(dataExtremes.dataMin)) {
                seriesDataMin = dataExtremes.dataMin;
                axis.dataMin = Math.min(pick14(axis.dataMin, seriesDataMin), seriesDataMin);
              }
              if (isNumber11(dataExtremes.dataMax)) {
                seriesDataMax = dataExtremes.dataMax;
                axis.dataMax = Math.max(pick14(axis.dataMax, seriesDataMax), seriesDataMax);
              }
              if (defined10(threshold)) {
                axis.threshold = threshold;
              }
              if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {
                axis.softThreshold = false;
              }
            }
          }
        });
      });
      fireEvent4(this, "afterGetSeriesExtremes");
    };
    Axis2.prototype.translate = function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
      var axis = this.linkedParent || this, localMin = old && axis.old ? axis.old.min : axis.min, minPixelPadding = axis.minPixelPadding, doPostTranslate = (axis.isOrdinal || axis.brokenAxis && axis.brokenAxis.hasBreaks || axis.logarithmic && handleLog) && axis.lin2val;
      var sign = 1, cvsOffset = 0, localA = old && axis.old ? axis.old.transA : axis.transA, returnValue = 0;
      if (!localA) {
        localA = axis.transA;
      }
      if (cvsCoord) {
        sign *= -1;
        cvsOffset = axis.len;
      }
      if (axis.reversed) {
        sign *= -1;
        cvsOffset -= sign * (axis.sector || axis.len);
      }
      if (backwards) {
        val = val * sign + cvsOffset;
        val -= minPixelPadding;
        returnValue = val / localA + localMin;
        if (doPostTranslate) {
          returnValue = axis.lin2val(returnValue);
        }
      } else {
        if (doPostTranslate) {
          val = axis.val2lin(val);
        }
        returnValue = isNumber11(localMin) ? sign * (val - localMin) * localA + cvsOffset + sign * minPixelPadding + (isNumber11(pointPlacement) ? localA * pointPlacement : 0) : void 0;
      }
      return returnValue;
    };
    Axis2.prototype.toPixels = function(value, paneCoordinates) {
      return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
    };
    Axis2.prototype.toValue = function(pixel, paneCoordinates) {
      return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
    };
    Axis2.prototype.getPlotLinePath = function(options) {
      var axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, old = options.old, value = options.value, lineWidth = options.lineWidth, cHeight = old && chart.oldChartHeight || chart.chartHeight, cWidth = old && chart.oldChartWidth || chart.chartWidth, transB = axis.transB;
      var translatedValue = options.translatedValue, force = options.force, x1, y1, x2, y2, skip;
      function between(x, a, b) {
        if (force !== "pass" && x < a || x > b) {
          if (force) {
            x = clamp4(x, a, b);
          } else {
            skip = true;
          }
        }
        return x;
      }
      var evt = {
        value,
        lineWidth,
        old,
        force,
        acrossPanes: options.acrossPanes,
        translatedValue
      };
      fireEvent4(this, "getPlotLinePath", evt, function(e2) {
        translatedValue = pick14(translatedValue, axis.translate(value, null, null, old));
        translatedValue = clamp4(translatedValue, -1e5, 1e5);
        x1 = x2 = Math.round(translatedValue + transB);
        y1 = y2 = Math.round(cHeight - translatedValue - transB);
        if (!isNumber11(translatedValue)) {
          skip = true;
          force = false;
        } else if (axis.horiz) {
          y1 = axisTop;
          y2 = cHeight - axis.bottom;
          x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
        } else {
          x1 = axisLeft;
          x2 = cWidth - axis.right;
          y1 = y2 = between(y1, axisTop, axisTop + axis.height);
        }
        e2.path = skip && !force ? null : chart.renderer.crispLine([["M", x1, y1], ["L", x2, y2]], lineWidth || 1);
      });
      return evt.path;
    };
    Axis2.prototype.getLinearTickPositions = function(tickInterval, min, max) {
      var roundedMin = correctFloat3(Math.floor(min / tickInterval) * tickInterval), roundedMax = correctFloat3(Math.ceil(max / tickInterval) * tickInterval), tickPositions = [];
      var pos, lastPos, precision;
      if (correctFloat3(roundedMin + tickInterval) === roundedMin) {
        precision = 20;
      }
      if (this.single) {
        return [min];
      }
      pos = roundedMin;
      while (pos <= roundedMax) {
        tickPositions.push(pos);
        pos = correctFloat3(pos + tickInterval, precision);
        if (pos === lastPos) {
          break;
        }
        lastPos = pos;
      }
      return tickPositions;
    };
    Axis2.prototype.getMinorTickInterval = function() {
      var options = this.options;
      if (options.minorTicks === true) {
        return pick14(options.minorTickInterval, "auto");
      }
      if (options.minorTicks === false) {
        return null;
      }
      return options.minorTickInterval;
    };
    Axis2.prototype.getMinorTickPositions = function() {
      var axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, pointRangePadding = axis.pointRangePadding || 0, min = axis.min - pointRangePadding, max = axis.max + pointRangePadding, range = max - min;
      var minorTickPositions = [], pos;
      if (range && range / minorTickInterval < axis.len / 3) {
        var logarithmic_1 = axis.logarithmic;
        if (logarithmic_1) {
          this.paddedTicks.forEach(function(_pos, i, paddedTicks) {
            if (i) {
              minorTickPositions.push.apply(minorTickPositions, logarithmic_1.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
            }
          });
        } else if (axis.dateTime && this.getMinorTickInterval() === "auto") {
          minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));
        } else {
          for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
            if (pos === minorTickPositions[0]) {
              break;
            }
            minorTickPositions.push(pos);
          }
        }
      }
      if (minorTickPositions.length !== 0) {
        axis.trimTicks(minorTickPositions);
      }
      return minorTickPositions;
    };
    Axis2.prototype.adjustForMinRange = function() {
      var axis = this, options = axis.options, log = axis.logarithmic;
      var min = axis.min, max = axis.max, zoomOffset, spaceAvailable, closestDataRange = 0, i, distance, xData, loopLength, minArgs, maxArgs, minRange;
      if (axis.isXAxis && typeof axis.minRange === "undefined" && !log) {
        if (defined10(options.min) || defined10(options.max)) {
          axis.minRange = null;
        } else {
          axis.series.forEach(function(series) {
            xData = series.xData;
            loopLength = series.xIncrement ? 1 : xData.length - 1;
            if (xData.length > 1) {
              for (i = loopLength; i > 0; i--) {
                distance = xData[i] - xData[i - 1];
                if (!closestDataRange || distance < closestDataRange) {
                  closestDataRange = distance;
                }
              }
            }
          });
          axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
        }
      }
      if (max - min < axis.minRange) {
        spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
        minRange = axis.minRange;
        zoomOffset = (minRange - max + min) / 2;
        minArgs = [
          min - zoomOffset,
          pick14(options.min, min - zoomOffset)
        ];
        if (spaceAvailable) {
          minArgs[2] = axis.logarithmic ? axis.logarithmic.log2lin(axis.dataMin) : axis.dataMin;
        }
        min = arrayMax2(minArgs);
        maxArgs = [
          min + minRange,
          pick14(options.max, min + minRange)
        ];
        if (spaceAvailable) {
          maxArgs[2] = log ? log.log2lin(axis.dataMax) : axis.dataMax;
        }
        max = arrayMin2(maxArgs);
        if (max - min < minRange) {
          minArgs[0] = max - minRange;
          minArgs[1] = pick14(options.min, max - minRange);
          min = arrayMax2(minArgs);
        }
      }
      axis.min = min;
      axis.max = max;
    };
    Axis2.prototype.getClosest = function() {
      var ret;
      if (this.categories) {
        ret = 1;
      } else {
        this.series.forEach(function(series) {
          var seriesClosest = series.closestPointRange, visible = series.visible || !series.chart.options.chart.ignoreHiddenSeries;
          if (!series.noSharedTooltip && defined10(seriesClosest) && visible) {
            ret = defined10(ret) ? Math.min(ret, seriesClosest) : seriesClosest;
          }
        });
      }
      return ret;
    };
    Axis2.prototype.nameToX = function(point) {
      var explicitCategories = isArray5(this.categories), names = explicitCategories ? this.categories : this.names;
      var nameX = point.options.x, x;
      point.series.requireSorting = false;
      if (!defined10(nameX)) {
        nameX = this.options.uniqueNames ? explicitCategories ? names.indexOf(point.name) : pick14(names.keys[point.name], -1) : point.series.autoIncrement();
      }
      if (nameX === -1) {
        if (!explicitCategories) {
          x = names.length;
        }
      } else {
        x = nameX;
      }
      if (typeof x !== "undefined") {
        this.names[x] = point.name;
        this.names.keys[point.name] = x;
      }
      return x;
    };
    Axis2.prototype.updateNames = function() {
      var axis = this, names = this.names, i = names.length;
      if (i > 0) {
        Object.keys(names.keys).forEach(function(key) {
          delete names.keys[key];
        });
        names.length = 0;
        this.minRange = this.userMinRange;
        (this.series || []).forEach(function(series) {
          series.xIncrement = null;
          if (!series.points || series.isDirtyData) {
            axis.max = Math.max(axis.max, series.xData.length - 1);
            series.processData();
            series.generatePoints();
          }
          series.data.forEach(function(point, i2) {
            var x;
            if (point && point.options && typeof point.name !== "undefined") {
              x = axis.nameToX(point);
              if (typeof x !== "undefined" && x !== point.x) {
                point.x = x;
                series.xData[i2] = x;
              }
            }
          });
        });
      }
    };
    Axis2.prototype.setAxisTranslation = function() {
      var axis = this, range = axis.max - axis.min, linkedParent = axis.linkedParent, hasCategories = !!axis.categories, isXAxis = axis.isXAxis;
      var pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;
      if (isXAxis || hasCategories || pointRange) {
        closestPointRange = axis.getClosest();
        if (linkedParent) {
          minPointOffset = linkedParent.minPointOffset;
          pointRangePadding = linkedParent.pointRangePadding;
        } else {
          axis.series.forEach(function(series) {
            var seriesPointRange = hasCategories ? 1 : isXAxis ? pick14(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0, pointPlacement = series.options.pointPlacement;
            pointRange = Math.max(pointRange, seriesPointRange);
            if (!axis.single || hasCategories) {
              var isPointPlacementAxis = series.is("xrange") ? !isXAxis : isXAxis;
              minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString6(pointPlacement) ? 0 : seriesPointRange / 2);
              pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === "on" ? 0 : seriesPointRange);
            }
          });
        }
        ordinalCorrection = axis.ordinal && axis.ordinal.slope && closestPointRange ? axis.ordinal.slope / closestPointRange : 1;
        axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
        axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
        axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);
        if (isXAxis) {
          axis.closestPointRange = closestPointRange;
        }
      }
      axis.translationSlope = axis.transA = transA = axis.staticScale || axis.len / (range + pointRangePadding || 1);
      axis.transB = axis.horiz ? axis.left : axis.bottom;
      axis.minPixelPadding = transA * minPointOffset;
      fireEvent4(this, "afterSetAxisTranslation");
    };
    Axis2.prototype.minFromRange = function() {
      var axis = this;
      return axis.max - axis.range;
    };
    Axis2.prototype.setTickInterval = function(secondPass) {
      var axis = this, chart = axis.chart, log = axis.logarithmic, options = axis.options, isXAxis = axis.isXAxis, isLinked = axis.isLinked, tickPixelIntervalOption = options.tickPixelInterval, categories = axis.categories, softThreshold = axis.softThreshold;
      var maxPadding = options.maxPadding, minPadding = options.minPadding, length, linkedParentExtremes, tickIntervalOption = options.tickInterval, threshold = isNumber11(axis.threshold) ? axis.threshold : null, thresholdMin, thresholdMax, hardMin, hardMax;
      if (!axis.dateTime && !categories && !isLinked) {
        this.getTickAmount();
      }
      hardMin = pick14(axis.userMin, options.min);
      hardMax = pick14(axis.userMax, options.max);
      if (isLinked) {
        axis.linkedParent = chart[axis.coll][options.linkedTo];
        linkedParentExtremes = axis.linkedParent.getExtremes();
        axis.min = pick14(linkedParentExtremes.min, linkedParentExtremes.dataMin);
        axis.max = pick14(linkedParentExtremes.max, linkedParentExtremes.dataMax);
        if (options.type !== axis.linkedParent.options.type) {
          error4(11, 1, chart);
        }
      } else {
        if (softThreshold && defined10(threshold)) {
          if (axis.dataMin >= threshold) {
            thresholdMin = threshold;
            minPadding = 0;
          } else if (axis.dataMax <= threshold) {
            thresholdMax = threshold;
            maxPadding = 0;
          }
        }
        axis.min = pick14(hardMin, thresholdMin, axis.dataMin);
        axis.max = pick14(hardMax, thresholdMax, axis.dataMax);
      }
      if (log) {
        if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick14(axis.dataMin, axis.min)) <= 0) {
          error4(10, 1, chart);
        }
        axis.min = correctFloat3(log.log2lin(axis.min), 16);
        axis.max = correctFloat3(log.log2lin(axis.max), 16);
      }
      if (axis.range && defined10(axis.max)) {
        axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange());
        axis.userMax = hardMax = axis.max;
        axis.range = null;
      }
      fireEvent4(axis, "foundExtremes");
      if (axis.beforePadding) {
        axis.beforePadding();
      }
      axis.adjustForMinRange();
      if (!categories && !axis.axisPointRange && !(axis.stacking && axis.stacking.usePercentage) && !isLinked && defined10(axis.min) && defined10(axis.max)) {
        length = axis.max - axis.min;
        if (length) {
          if (!defined10(hardMin) && minPadding) {
            axis.min -= length * minPadding;
          }
          if (!defined10(hardMax) && maxPadding) {
            axis.max += length * maxPadding;
          }
        }
      }
      if (!isNumber11(axis.userMin)) {
        if (isNumber11(options.softMin) && options.softMin < axis.min) {
          axis.min = hardMin = options.softMin;
        }
        if (isNumber11(options.floor)) {
          axis.min = Math.max(axis.min, options.floor);
        }
      }
      if (!isNumber11(axis.userMax)) {
        if (isNumber11(options.softMax) && options.softMax > axis.max) {
          axis.max = hardMax = options.softMax;
        }
        if (isNumber11(options.ceiling)) {
          axis.max = Math.min(axis.max, options.ceiling);
        }
      }
      if (softThreshold && defined10(axis.dataMin)) {
        threshold = threshold || 0;
        if (!defined10(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
          axis.min = axis.options.minRange ? Math.min(threshold, axis.max - axis.minRange) : threshold;
        } else if (!defined10(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
          axis.max = axis.options.minRange ? Math.max(threshold, axis.min + axis.minRange) : threshold;
        }
      }
      if (isNumber11(axis.min) && isNumber11(axis.max) && !this.chart.polar && axis.min > axis.max) {
        if (defined10(axis.options.min)) {
          axis.max = axis.min;
        } else if (defined10(axis.options.max)) {
          axis.min = axis.max;
        }
      }
      if (axis.min === axis.max || typeof axis.min === "undefined" || typeof axis.max === "undefined") {
        axis.tickInterval = 1;
      } else if (isLinked && axis.linkedParent && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
        axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
      } else {
        axis.tickInterval = pick14(
          tickIntervalOption,
          this.tickAmount ? (axis.max - axis.min) / Math.max(this.tickAmount - 1, 1) : void 0,
          // For categoried axis, 1 is default, for linear axis use
          // tickPix
          categories ? 1 : (
            // don't let it be more than the data range
            (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)
          )
        );
      }
      if (isXAxis && !secondPass) {
        axis.series.forEach(function(series) {
          series.forceCrop = series.forceCropping && series.forceCropping();
          series.processData(axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max));
        });
        fireEvent4(this, "postProcessData");
      }
      axis.setAxisTranslation();
      fireEvent4(this, "initialAxisTranslation");
      if (axis.pointRange && !tickIntervalOption) {
        axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
      }
      var minTickInterval = pick14(
        options.minTickInterval,
        // In datetime axes, don't go below the data interval, except when
        // there are scatter-like series involved (#13369).
        axis.dateTime && !axis.series.some(function(s) {
          return s.noSharedTooltip;
        }) ? axis.closestPointRange : 0
      );
      if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
        axis.tickInterval = minTickInterval;
      }
      if (!axis.dateTime && !axis.logarithmic && !tickIntervalOption) {
        axis.tickInterval = normalizeTickInterval2(axis.tickInterval, void 0, getMagnitude2(axis.tickInterval), pick14(
          options.allowDecimals,
          // If the tick interval is greather than 0.5, avoid
          // decimals, as linear axes are often used to render
          // discrete values. #3363. If a tick amount is set, allow
          // decimals by default, as it increases the chances for a
          // good fit.
          axis.tickInterval < 0.5 || this.tickAmount !== void 0
        ), !!this.tickAmount);
      }
      if (!this.tickAmount) {
        axis.tickInterval = axis.unsquish();
      }
      this.setTickPositions();
    };
    Axis2.prototype.setTickPositions = function() {
      var axis = this, options = this.options, tickPositionsOption = options.tickPositions, minorTickIntervalOption = this.getMinorTickInterval(), hasVerticalPanning = this.hasVerticalPanning(), isColorAxis = this.coll === "colorAxis", startOnTick = (isColorAxis || !hasVerticalPanning) && options.startOnTick, endOnTick = (isColorAxis || !hasVerticalPanning) && options.endOnTick;
      var tickPositions, tickPositioner = options.tickPositioner;
      this.tickmarkOffset = this.categories && options.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
      this.minorTickInterval = minorTickIntervalOption === "auto" && this.tickInterval ? this.tickInterval / 5 : minorTickIntervalOption;
      this.single = this.min === this.max && defined10(this.min) && !this.tickAmount && // Data is on integer (#6563)
      (parseInt(this.min, 10) === this.min || // Between integers and decimals are not allowed (#6274)
      options.allowDecimals !== false);
      this.tickPositions = // Find the tick positions. Work on a copy (#1565)
      tickPositions = tickPositionsOption && tickPositionsOption.slice();
      if (!tickPositions) {
        if ((!axis.ordinal || !axis.ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {
          tickPositions = [this.min, this.max];
          error4(19, false, this.chart);
        } else if (axis.dateTime) {
          tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal && axis.ordinal.positions, this.closestPointRange, true);
        } else if (axis.logarithmic) {
          tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
        } else {
          tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
        }
        if (tickPositions.length > this.len) {
          tickPositions = [tickPositions[0], tickPositions.pop()];
          if (tickPositions[0] === tickPositions[1]) {
            tickPositions.length = 1;
          }
        }
        this.tickPositions = tickPositions;
        if (tickPositioner) {
          tickPositioner = tickPositioner.apply(axis, [this.min, this.max]);
          if (tickPositioner) {
            this.tickPositions = tickPositions = tickPositioner;
          }
        }
      }
      this.paddedTicks = tickPositions.slice(0);
      this.trimTicks(tickPositions, startOnTick, endOnTick);
      if (!this.isLinked) {
        if (this.single && tickPositions.length < 2 && !this.categories && !this.series.some(function(s) {
          return s.is("heatmap") && s.options.pointPlacement === "between";
        })) {
          this.min -= 0.5;
          this.max += 0.5;
        }
        if (!tickPositionsOption && !tickPositioner) {
          this.adjustTickAmount();
        }
      }
      fireEvent4(this, "afterSetTickPositions");
    };
    Axis2.prototype.trimTicks = function(tickPositions, startOnTick, endOnTick) {
      var roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = !this.isOrdinal && this.minPointOffset || 0;
      fireEvent4(this, "trimTicks");
      if (!this.isLinked) {
        if (startOnTick && roundedMin !== -Infinity) {
          this.min = roundedMin;
        } else {
          while (this.min - minPointOffset > tickPositions[0]) {
            tickPositions.shift();
          }
        }
        if (endOnTick) {
          this.max = roundedMax;
        } else {
          while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
            tickPositions.pop();
          }
        }
        if (tickPositions.length === 0 && defined10(roundedMin) && !this.options.tickPositions) {
          tickPositions.push((roundedMax + roundedMin) / 2);
        }
      }
    };
    Axis2.prototype.alignToOthers = function() {
      var axis = this, others = (
        // Whether there is another axis to pair with this one
        {}
      ), options = axis.options;
      var hasOther;
      if (
        // Only if alignTicks is true
        this.chart.options.chart.alignTicks !== false && options.alignTicks && // Disabled when startOnTick or endOnTick are false (#7604)
        options.startOnTick !== false && options.endOnTick !== false && // Don't try to align ticks on a log axis, they are not evenly
        // spaced (#6021)
        !axis.logarithmic
      ) {
        this.chart[this.coll].forEach(function(axis2) {
          var otherOptions = axis2.options, horiz = axis2.horiz, key = [
            horiz ? otherOptions.left : otherOptions.top,
            otherOptions.width,
            otherOptions.height,
            otherOptions.pane
          ].join(",");
          if (axis2.series.length) {
            if (others[key]) {
              hasOther = true;
            } else {
              others[key] = 1;
            }
          }
        });
      }
      return hasOther;
    };
    Axis2.prototype.getTickAmount = function() {
      var axis = this, options = this.options, tickPixelInterval = options.tickPixelInterval;
      var tickAmount = options.tickAmount;
      if (!defined10(options.tickInterval) && !tickAmount && this.len < tickPixelInterval && !this.isRadial && !axis.logarithmic && options.startOnTick && options.endOnTick) {
        tickAmount = 2;
      }
      if (!tickAmount && this.alignToOthers()) {
        tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
      }
      if (tickAmount < 4) {
        this.finalTickAmt = tickAmount;
        tickAmount = 5;
      }
      this.tickAmount = tickAmount;
    };
    Axis2.prototype.adjustTickAmount = function() {
      var axis = this, axisOptions = axis.options, tickInterval = axis.tickInterval, tickPositions = axis.tickPositions, tickAmount = axis.tickAmount, finalTickAmt = axis.finalTickAmt, currentTickAmount = tickPositions && tickPositions.length, threshold = pick14(axis.threshold, axis.softThreshold ? 0 : null);
      var len, i;
      if (axis.hasData() && isNumber11(axis.min) && isNumber11(axis.max)) {
        if (currentTickAmount < tickAmount) {
          while (tickPositions.length < tickAmount) {
            if (tickPositions.length % 2 || axis.min === threshold) {
              tickPositions.push(correctFloat3(tickPositions[tickPositions.length - 1] + tickInterval));
            } else {
              tickPositions.unshift(correctFloat3(tickPositions[0] - tickInterval));
            }
          }
          axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);
          axis.min = axisOptions.startOnTick ? tickPositions[0] : Math.min(axis.min, tickPositions[0]);
          axis.max = axisOptions.endOnTick ? tickPositions[tickPositions.length - 1] : Math.max(axis.max, tickPositions[tickPositions.length - 1]);
        } else if (currentTickAmount > tickAmount) {
          axis.tickInterval *= 2;
          axis.setTickPositions();
        }
        if (defined10(finalTickAmt)) {
          i = len = tickPositions.length;
          while (i--) {
            if (
              // Remove every other tick
              finalTickAmt === 3 && i % 2 === 1 || // Remove all but first and last
              finalTickAmt <= 2 && i > 0 && i < len - 1
            ) {
              tickPositions.splice(i, 1);
            }
          }
          axis.finalTickAmt = void 0;
        }
      }
    };
    Axis2.prototype.setScale = function() {
      var axis = this;
      var isDirtyData = false, isXAxisDirty = false;
      axis.series.forEach(function(series) {
        isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;
        isXAxisDirty = isXAxisDirty || series.xAxis && series.xAxis.isDirty || false;
      });
      axis.setAxisSize();
      var isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);
      if (isDirtyAxisLength || isDirtyData || isXAxisDirty || axis.isLinked || axis.forceRedraw || axis.userMin !== (axis.old && axis.old.userMin) || axis.userMax !== (axis.old && axis.old.userMax) || axis.alignToOthers()) {
        if (axis.stacking) {
          axis.stacking.resetStacks();
        }
        axis.forceRedraw = false;
        axis.getSeriesExtremes();
        axis.setTickInterval();
        if (!axis.isDirty) {
          axis.isDirty = isDirtyAxisLength || axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max);
        }
      } else if (axis.stacking) {
        axis.stacking.cleanStacks();
      }
      if (isDirtyData && axis.panningState) {
        axis.panningState.isDirty = true;
      }
      fireEvent4(this, "afterSetScale");
    };
    Axis2.prototype.setExtremes = function(newMin, newMax, redraw, animation, eventArguments) {
      var axis = this, chart = axis.chart;
      redraw = pick14(redraw, true);
      axis.series.forEach(function(serie) {
        delete serie.kdTree;
      });
      eventArguments = extend9(eventArguments, {
        min: newMin,
        max: newMax
      });
      fireEvent4(axis, "setExtremes", eventArguments, function() {
        axis.userMin = newMin;
        axis.userMax = newMax;
        axis.eventArgs = eventArguments;
        if (redraw) {
          chart.redraw(animation);
        }
      });
    };
    Axis2.prototype.zoom = function(newMin, newMax) {
      var axis = this, dataMin = this.dataMin, dataMax = this.dataMax, options = this.options, min = Math.min(dataMin, pick14(options.min, dataMin)), max = Math.max(dataMax, pick14(options.max, dataMax)), evt = {
        newMin,
        newMax
      };
      fireEvent4(this, "zoom", evt, function(e2) {
        var newMin2 = e2.newMin, newMax2 = e2.newMax;
        if (newMin2 !== axis.min || newMax2 !== axis.max) {
          if (!axis.allowZoomOutside) {
            if (defined10(dataMin)) {
              if (newMin2 < min) {
                newMin2 = min;
              }
              if (newMin2 > max) {
                newMin2 = max;
              }
            }
            if (defined10(dataMax)) {
              if (newMax2 < min) {
                newMax2 = min;
              }
              if (newMax2 > max) {
                newMax2 = max;
              }
            }
          }
          axis.displayBtn = typeof newMin2 !== "undefined" || typeof newMax2 !== "undefined";
          axis.setExtremes(newMin2, newMax2, false, void 0, { trigger: "zoom" });
        }
        e2.zoomed = true;
      });
      return evt.zoomed;
    };
    Axis2.prototype.setAxisSize = function() {
      var chart = this.chart, options = this.options, offsets = options.offsets || [0, 0, 0, 0], horiz = this.horiz, width = this.width = Math.round(relativeLength2(pick14(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)), height = this.height = Math.round(relativeLength2(pick14(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)), top = this.top = Math.round(relativeLength2(pick14(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)), left = this.left = Math.round(relativeLength2(pick14(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));
      this.bottom = chart.chartHeight - height - top;
      this.right = chart.chartWidth - width - left;
      this.len = Math.max(horiz ? width : height, 0);
      this.pos = horiz ? left : top;
    };
    Axis2.prototype.getExtremes = function() {
      var axis = this, log = axis.logarithmic;
      return {
        min: log ? correctFloat3(log.lin2log(axis.min)) : axis.min,
        max: log ? correctFloat3(log.lin2log(axis.max)) : axis.max,
        dataMin: axis.dataMin,
        dataMax: axis.dataMax,
        userMin: axis.userMin,
        userMax: axis.userMax
      };
    };
    Axis2.prototype.getThreshold = function(threshold) {
      var axis = this, log = axis.logarithmic, realMin = log ? log.lin2log(axis.min) : axis.min, realMax = log ? log.lin2log(axis.max) : axis.max;
      if (threshold === null || threshold === -Infinity) {
        threshold = realMin;
      } else if (threshold === Infinity) {
        threshold = realMax;
      } else if (realMin > threshold) {
        threshold = realMin;
      } else if (realMax < threshold) {
        threshold = realMax;
      }
      return axis.translate(threshold, 0, 1, 0, 1);
    };
    Axis2.prototype.autoLabelAlign = function(rotation) {
      var angle = (pick14(rotation, 0) - this.side * 90 + 720) % 360, evt = { align: "center" };
      fireEvent4(this, "autoLabelAlign", evt, function(e2) {
        if (angle > 15 && angle < 165) {
          e2.align = "right";
        } else if (angle > 195 && angle < 345) {
          e2.align = "left";
        }
      });
      return evt.align;
    };
    Axis2.prototype.tickSize = function(prefix) {
      var options = this.options, tickWidth = pick14(
        options[prefix === "tick" ? "tickWidth" : "minorTickWidth"],
        // Default to 1 on linear and datetime X axes
        prefix === "tick" && this.isXAxis && !this.categories ? 1 : 0
      );
      var tickLength = options[prefix === "tick" ? "tickLength" : "minorTickLength"], tickSize;
      if (tickWidth && tickLength) {
        if (options[prefix + "Position"] === "inside") {
          tickLength = -tickLength;
        }
        tickSize = [tickLength, tickWidth];
      }
      var e2 = { tickSize };
      fireEvent4(this, "afterTickSize", e2);
      return e2.tickSize;
    };
    Axis2.prototype.labelMetrics = function() {
      var index = this.tickPositions && this.tickPositions[0] || 0;
      return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[index] && this.ticks[index].label);
    };
    Axis2.prototype.unsquish = function() {
      var labelOptions = this.options.labels, horiz = this.horiz, tickInterval = this.tickInterval, slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval), rotationOption = labelOptions.rotation, labelMetrics = this.labelMetrics(), range = Math.max(this.max - this.min, 0), getStep = function(spaceNeeded) {
        var step2 = spaceNeeded / (slotSize || 1);
        step2 = step2 > 1 ? Math.ceil(step2) : 1;
        if (step2 * tickInterval > range && spaceNeeded !== Infinity && slotSize !== Infinity && range) {
          step2 = Math.ceil(range / tickInterval);
        }
        return correctFloat3(step2 * tickInterval);
      };
      var newTickInterval = tickInterval, rotation, step, bestScore = Number.MAX_VALUE, autoRotation;
      if (horiz) {
        if (!labelOptions.staggerLines && !labelOptions.step) {
          if (isNumber11(rotationOption)) {
            autoRotation = [rotationOption];
          } else if (slotSize < labelOptions.autoRotationLimit) {
            autoRotation = labelOptions.autoRotation;
          }
        }
        if (autoRotation) {
          autoRotation.forEach(function(rot) {
            var score;
            if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {
              step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad4 * rot)));
              score = step + Math.abs(rot / 360);
              if (score < bestScore) {
                bestScore = score;
                rotation = rot;
                newTickInterval = step;
              }
            }
          });
        }
      } else if (!labelOptions.step) {
        newTickInterval = getStep(labelMetrics.h);
      }
      this.autoRotation = autoRotation;
      this.labelRotation = pick14(rotation, isNumber11(rotationOption) ? rotationOption : 0);
      return newTickInterval;
    };
    Axis2.prototype.getSlotWidth = function(tick) {
      var chart = this.chart, horiz = this.horiz, labelOptions = this.options.labels, slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), marginLeft = chart.margin[3];
      if (tick && isNumber11(tick.slotWidth)) {
        return tick.slotWidth;
      }
      if (horiz && labelOptions.step < 2) {
        if (labelOptions.rotation) {
          return 0;
        }
        return (this.staggerLines || 1) * this.len / slotCount;
      }
      if (!horiz) {
        var cssWidth = labelOptions.style.width;
        if (cssWidth !== void 0) {
          return parseInt(String(cssWidth), 10);
        }
        if (marginLeft) {
          return marginLeft - chart.spacing[3];
        }
      }
      return chart.chartWidth * 0.33;
    };
    Axis2.prototype.renderUnsquish = function() {
      var chart = this.chart, renderer = chart.renderer, tickPositions = this.tickPositions, ticks = this.ticks, labelOptions = this.options.labels, labelStyleOptions = labelOptions.style, horiz = this.horiz, slotWidth = this.getSlotWidth(), innerWidth = Math.max(1, Math.round(slotWidth - 2 * labelOptions.padding)), attr11 = {}, labelMetrics = this.labelMetrics(), textOverflowOption = labelStyleOptions.textOverflow;
      var commonWidth, commonTextOverflow, maxLabelLength = 0, label, i, pos;
      if (!isString6(labelOptions.rotation)) {
        attr11.rotation = labelOptions.rotation || 0;
      }
      tickPositions.forEach(function(tickPosition) {
        var tick = ticks[tickPosition];
        if (tick.movedLabel) {
          tick.replaceMovedLabel();
        }
        if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {
          maxLabelLength = tick.label.textPxLength;
        }
      });
      this.maxLabelLength = maxLabelLength;
      if (this.autoRotation) {
        if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
          attr11.rotation = this.labelRotation;
        } else {
          this.labelRotation = 0;
        }
      } else if (slotWidth) {
        commonWidth = innerWidth;
        if (!textOverflowOption) {
          commonTextOverflow = "clip";
          i = tickPositions.length;
          while (!horiz && i--) {
            pos = tickPositions[i];
            label = ticks[pos].label;
            if (label) {
              if (label.styles && label.styles.textOverflow === "ellipsis") {
                label.css({ textOverflow: "clip" });
              } else if (label.textPxLength > slotWidth) {
                label.css({ width: slotWidth + "px" });
              }
              if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
                label.specificTextOverflow = "ellipsis";
              }
            }
          }
        }
      }
      if (attr11.rotation) {
        commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;
        if (!textOverflowOption) {
          commonTextOverflow = "ellipsis";
        }
      }
      this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
      if (this.labelAlign) {
        attr11.align = this.labelAlign;
      }
      tickPositions.forEach(function(pos2) {
        var tick = ticks[pos2], label2 = tick && tick.label, widthOption = labelStyleOptions.width, css16 = {};
        if (label2) {
          label2.attr(attr11);
          if (tick.shortenLabel) {
            tick.shortenLabel();
          } else if (commonWidth && !widthOption && // Setting width in this case messes with the bounding box
          // (#7975)
          labelStyleOptions.whiteSpace !== "nowrap" && // Speed optimizing, #7656
          (commonWidth < label2.textPxLength || // Resetting CSS, #4928
          label2.element.tagName === "SPAN")) {
            css16.width = commonWidth + "px";
            if (!textOverflowOption) {
              css16.textOverflow = label2.specificTextOverflow || commonTextOverflow;
            }
            label2.css(css16);
          } else if (label2.styles && label2.styles.width && !css16.width && !widthOption) {
            label2.css({ width: null });
          }
          delete label2.specificTextOverflow;
          tick.rotation = attr11.rotation;
        }
      }, this);
      this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
    };
    Axis2.prototype.hasData = function() {
      return this.series.some(function(s) {
        return s.hasData();
      }) || this.options.showEmpty && defined10(this.min) && defined10(this.max);
    };
    Axis2.prototype.addTitle = function(display) {
      var axis = this, renderer = axis.chart.renderer, horiz = axis.horiz, opposite = axis.opposite, options = axis.options, axisTitleOptions = options.title, styledMode = axis.chart.styledMode;
      var textAlign;
      if (!axis.axisTitle) {
        textAlign = axisTitleOptions.textAlign;
        if (!textAlign) {
          textAlign = (horiz ? {
            low: "left",
            middle: "center",
            high: "right"
          } : {
            low: opposite ? "right" : "left",
            middle: "center",
            high: opposite ? "left" : "right"
          })[axisTitleOptions.align];
        }
        axis.axisTitle = renderer.text(axisTitleOptions.text || "", 0, 0, axisTitleOptions.useHTML).attr({
          zIndex: 7,
          rotation: axisTitleOptions.rotation,
          align: textAlign
        }).addClass("highcharts-axis-title");
        if (!styledMode) {
          axis.axisTitle.css(merge10(axisTitleOptions.style));
        }
        axis.axisTitle.add(axis.axisGroup);
        axis.axisTitle.isNew = true;
      }
      if (!styledMode && !axisTitleOptions.style.width && !axis.isRadial) {
        axis.axisTitle.css({
          width: axis.len + "px"
        });
      }
      axis.axisTitle[display ? "show" : "hide"](display);
    };
    Axis2.prototype.generateTick = function(pos) {
      var axis = this, ticks = axis.ticks;
      if (!ticks[pos]) {
        ticks[pos] = new Tick_default(axis, pos);
      } else {
        ticks[pos].addLabel();
      }
    };
    Axis2.prototype.getOffset = function() {
      var _this = this;
      var axis = this, chart = axis.chart, renderer = chart.renderer, options = axis.options, tickPositions = axis.tickPositions, ticks = axis.ticks, horiz = axis.horiz, side = axis.side, invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side, hasData = axis.hasData(), axisTitleOptions = options.title, labelOptions = options.labels, axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [-1, 1, 1, -1][side], className = options.className, axisParent = axis.axisParent;
      var showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, labelOffsetPadded, lineHeightCorrection;
      axis.showAxis = showAxis = hasData || options.showEmpty;
      axis.staggerLines = axis.horiz && labelOptions.staggerLines || void 0;
      if (!axis.axisGroup) {
        var createGroup = function(name, suffix, zIndex) {
          return renderer.g(name).attr({ zIndex }).addClass("highcharts-" + _this.coll.toLowerCase() + suffix + " " + (_this.isRadial ? "highcharts-radial-axis" + suffix + " " : "") + (className || "")).add(axisParent);
        };
        axis.gridGroup = createGroup("grid", "-grid", options.gridZIndex);
        axis.axisGroup = createGroup("axis", "", options.zIndex);
        axis.labelGroup = createGroup("axis-labels", "-labels", labelOptions.zIndex);
      }
      if (hasData || axis.isLinked) {
        tickPositions.forEach(function(pos) {
          axis.generateTick(pos);
        });
        axis.renderUnsquish();
        axis.reserveSpaceDefault = side === 0 || side === 2 || { 1: "left", 3: "right" }[side] === axis.labelAlign;
        if (pick14(labelOptions.reserveSpace, axis.labelAlign === "center" ? true : null, axis.reserveSpaceDefault)) {
          tickPositions.forEach(function(pos) {
            labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);
          });
        }
        if (axis.staggerLines) {
          labelOffset *= axis.staggerLines;
        }
        axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
      } else {
        objectEach10(ticks, function(tick, n) {
          tick.destroy();
          delete ticks[n];
        });
      }
      if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
        axis.addTitle(showAxis);
        if (showAxis && axisTitleOptions.reserveSpace !== false) {
          axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? "height" : "width"];
          titleOffsetOption = axisTitleOptions.offset;
          titleMargin = defined10(titleOffsetOption) ? 0 : pick14(axisTitleOptions.margin, horiz ? 5 : 10);
        }
      }
      axis.renderLine();
      axis.offset = directionFactor * pick14(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);
      axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 };
      if (side === 0) {
        lineHeightCorrection = -axis.labelMetrics().h;
      } else if (side === 2) {
        lineHeightCorrection = axis.tickRotCorr.y;
      } else {
        lineHeightCorrection = 0;
      }
      labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
      if (labelOffset) {
        labelOffsetPadded -= lineHeightCorrection;
        labelOffsetPadded += directionFactor * (horiz ? pick14(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);
      }
      axis.axisTitleMargin = pick14(titleOffsetOption, labelOffsetPadded);
      if (axis.getMaxLabelDimensions) {
        axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);
      }
      var tickSize = this.tickSize("tick");
      axisOffset[side] = Math.max(
        axisOffset[side],
        (axis.axisTitleMargin || 0) + titleOffset + directionFactor * axis.offset,
        labelOffsetPadded,
        // #3027
        tickPositions && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0
        // #4866
      );
      var clip = options.offset ? 0 : (
        // #4308, #4371:
        Math.floor(axis.axisLine.strokeWidth() / 2) * 2
      );
      clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
      fireEvent4(this, "afterGetOffset");
    };
    Axis2.prototype.getLinePath = function(lineWidth) {
      var chart = this.chart, opposite = this.opposite, offset3 = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset3, lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset3;
      if (opposite) {
        lineWidth *= -1;
      }
      return chart.renderer.crispLine([
        [
          "M",
          horiz ? this.left : lineLeft,
          horiz ? lineTop : this.top
        ],
        [
          "L",
          horiz ? chart.chartWidth - this.right : lineLeft,
          horiz ? lineTop : chart.chartHeight - this.bottom
        ]
      ], lineWidth);
    };
    Axis2.prototype.renderLine = function() {
      if (!this.axisLine) {
        this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup);
        if (!this.chart.styledMode) {
          this.axisLine.attr({
            stroke: this.options.lineColor,
            "stroke-width": this.options.lineWidth,
            zIndex: 7
          });
        }
      }
    };
    Axis2.prototype.getTitlePosition = function() {
      var horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset3 = this.offset, xOption = axisTitleOptions.x, yOption = axisTitleOptions.y, axisTitle = this.axisTitle, fontMetrics = this.chart.renderer.fontMetrics(axisTitleOptions.style.fontSize, axisTitle), textHeightOvershoot = Math.max(axisTitle.getBBox(null, 0).height - fontMetrics.h - 1, 0), alongAxis = {
        low: margin + (horiz ? 0 : axisLength),
        middle: margin + axisLength / 2,
        high: margin + (horiz ? axisLength : 0)
      }[axisTitleOptions.align], offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * // horizontal axis reverses the margin
      (opposite ? -1 : 1) * // so does opposite axes
      this.axisTitleMargin + [
        -textHeightOvershoot,
        textHeightOvershoot,
        fontMetrics.f,
        -textHeightOvershoot
        // left
      ][this.side], titlePosition = {
        x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset3 + xOption,
        y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset3 : alongAxis + yOption
      };
      fireEvent4(this, "afterGetTitlePosition", { titlePosition });
      return titlePosition;
    };
    Axis2.prototype.renderMinorTick = function(pos, slideIn) {
      var axis = this;
      var minorTicks = axis.minorTicks;
      if (!minorTicks[pos]) {
        minorTicks[pos] = new Tick_default(axis, pos, "minor");
      }
      if (slideIn && minorTicks[pos].isNew) {
        minorTicks[pos].render(null, true);
      }
      minorTicks[pos].render(null, false, 1);
    };
    Axis2.prototype.renderTick = function(pos, i, slideIn) {
      var axis = this, isLinked = axis.isLinked, ticks = axis.ticks;
      if (!isLinked || pos >= axis.min && pos <= axis.max || axis.grid && axis.grid.isColumn) {
        if (!ticks[pos]) {
          ticks[pos] = new Tick_default(axis, pos);
        }
        if (slideIn && ticks[pos].isNew) {
          ticks[pos].render(i, true, -1);
        }
        ticks[pos].render(i);
      }
    };
    Axis2.prototype.render = function() {
      var axis = this, chart = axis.chart, log = axis.logarithmic, renderer = chart.renderer, options = axis.options, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, tickmarkOffset = axis.tickmarkOffset, axisLine = axis.axisLine, showAxis = axis.showAxis, animation = animObject3(renderer.globalAnimation);
      var from, to;
      axis.labelEdge.length = 0;
      axis.overlap = false;
      [ticks, minorTicks, alternateBands].forEach(function(coll) {
        objectEach10(coll, function(tick) {
          tick.isActive = false;
        });
      });
      if (axis.hasData() || isLinked) {
        var slideInTicks_1 = axis.chart.hasRendered && axis.old && isNumber11(axis.old.min);
        if (axis.minorTickInterval && !axis.categories) {
          axis.getMinorTickPositions().forEach(function(pos) {
            axis.renderMinorTick(pos, slideInTicks_1);
          });
        }
        if (tickPositions.length) {
          tickPositions.forEach(function(pos, i) {
            axis.renderTick(pos, i, slideInTicks_1);
          });
          if (tickmarkOffset && (axis.min === 0 || axis.single)) {
            if (!ticks[-1]) {
              ticks[-1] = new Tick_default(axis, -1, null, true);
            }
            ticks[-1].render(-1);
          }
        }
        if (alternateGridColor) {
          tickPositions.forEach(function(pos, i) {
            to = typeof tickPositions[i + 1] !== "undefined" ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
            if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
              if (!alternateBands[pos]) {
                alternateBands[pos] = new Globals_default.PlotLineOrBand(axis);
              }
              from = pos + tickmarkOffset;
              alternateBands[pos].options = {
                from: log ? log.lin2log(from) : from,
                to: log ? log.lin2log(to) : to,
                color: alternateGridColor,
                className: "highcharts-alternate-grid"
              };
              alternateBands[pos].render();
              alternateBands[pos].isActive = true;
            }
          });
        }
        if (!axis._addedPlotLB) {
          axis._addedPlotLB = true;
          (options.plotLines || []).concat(options.plotBands || []).forEach(function(plotLineOptions) {
            axis.addPlotBandOrLine(plotLineOptions);
          });
        }
      }
      [ticks, minorTicks, alternateBands].forEach(function(coll) {
        var forDestruction = [], delay = animation.duration, destroyInactiveItems = function() {
          var i = forDestruction.length;
          while (i--) {
            if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
              coll[forDestruction[i]].destroy();
              delete coll[forDestruction[i]];
            }
          }
        };
        objectEach10(coll, function(tick, pos) {
          if (!tick.isActive) {
            tick.render(pos, false, 0);
            tick.isActive = false;
            forDestruction.push(pos);
          }
        });
        syncTimeout3(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);
      });
      if (axisLine) {
        axisLine[axisLine.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(axisLine.strokeWidth())
        });
        axisLine.isPlaced = true;
        axisLine[showAxis ? "show" : "hide"](showAxis);
      }
      if (axisTitle && showAxis) {
        var titleXy = axis.getTitlePosition();
        if (isNumber11(titleXy.y)) {
          axisTitle[axisTitle.isNew ? "attr" : "animate"](titleXy);
          axisTitle.isNew = false;
        } else {
          axisTitle.attr("y", -9999);
          axisTitle.isNew = true;
        }
      }
      if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {
        axis.stacking.renderStackTotals();
      }
      axis.old = {
        len: axis.len,
        max: axis.max,
        min: axis.min,
        transA: axis.transA,
        userMax: axis.userMax,
        userMin: axis.userMin
      };
      axis.isDirty = false;
      fireEvent4(this, "afterRender");
    };
    Axis2.prototype.redraw = function() {
      if (this.visible) {
        this.render();
        this.plotLinesAndBands.forEach(function(plotLine) {
          plotLine.render();
        });
      }
      this.series.forEach(function(series) {
        series.isDirty = true;
      });
    };
    Axis2.prototype.getKeepProps = function() {
      return this.keepProps || Axis2.keepProps;
    };
    Axis2.prototype.destroy = function(keepEvents) {
      var axis = this, plotLinesAndBands = axis.plotLinesAndBands, eventOptions = this.eventOptions;
      fireEvent4(this, "destroy", { keepEvents });
      if (!keepEvents) {
        removeEvent4(axis);
      }
      [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function(coll) {
        destroyObjectProperties4(coll);
      });
      if (plotLinesAndBands) {
        var i = plotLinesAndBands.length;
        while (i--) {
          plotLinesAndBands[i].destroy();
        }
      }
      [
        "axisLine",
        "axisTitle",
        "axisGroup",
        "gridGroup",
        "labelGroup",
        "cross",
        "scrollbar"
      ].forEach(function(prop) {
        if (axis[prop]) {
          axis[prop] = axis[prop].destroy();
        }
      });
      for (var plotGroup in axis.plotLinesAndBandsGroups) {
        axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
      }
      objectEach10(axis, function(val, key) {
        if (axis.getKeepProps().indexOf(key) === -1) {
          delete axis[key];
        }
      });
      this.eventOptions = eventOptions;
    };
    Axis2.prototype.drawCrosshair = function(e2, point) {
      var options = this.crosshair, snap = pick14(options && options.snap, true), chart = this.chart;
      var path, pos, categorized, graphic = this.cross, crossOptions;
      fireEvent4(this, "drawCrosshair", { e: e2, point });
      if (!e2) {
        e2 = this.cross && this.cross.e;
      }
      if (
        // Disabled in options
        !options || // Snap
        (defined10(point) || !snap) === false
      ) {
        this.hideCrosshair();
      } else {
        if (!snap) {
          pos = e2 && (this.horiz ? e2.chartX - this.pos : this.len - e2.chartY + this.pos);
        } else if (defined10(point)) {
          pos = pick14(this.coll !== "colorAxis" ? point.crosshairPos : (
            // 3D axis extension
            null
          ), this.isXAxis ? point.plotX : this.len - point.plotY);
        }
        if (defined10(pos)) {
          crossOptions = {
            // value, only used on radial
            value: point && (this.isXAxis ? point.x : pick14(point.stackY, point.y)),
            translatedValue: pos
          };
          if (chart.polar) {
            extend9(crossOptions, {
              isCrosshair: true,
              chartX: e2 && e2.chartX,
              chartY: e2 && e2.chartY,
              point
            });
          }
          path = this.getPlotLinePath(crossOptions) || null;
        }
        if (!defined10(path)) {
          this.hideCrosshair();
          return;
        }
        categorized = this.categories && !this.isRadial;
        if (!graphic) {
          this.cross = graphic = chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (categorized ? "category " : "thin ") + (options.className || "")).attr({
            zIndex: pick14(options.zIndex, 2)
          }).add();
          if (!chart.styledMode) {
            graphic.attr({
              stroke: options.color || (categorized ? Color_default.parse(Palette_default.highlightColor20).setOpacity(0.25).get() : Palette_default.neutralColor20),
              "stroke-width": pick14(options.width, 1)
            }).css({
              "pointer-events": "none"
            });
            if (options.dashStyle) {
              graphic.attr({
                dashstyle: options.dashStyle
              });
            }
          }
        }
        graphic.show().attr({
          d: path
        });
        if (categorized && !options.width) {
          graphic.attr({
            "stroke-width": this.transA
          });
        }
        this.cross.e = e2;
      }
      fireEvent4(this, "afterDrawCrosshair", { e: e2, point });
    };
    Axis2.prototype.hideCrosshair = function() {
      if (this.cross) {
        this.cross.hide();
      }
      fireEvent4(this, "afterHideCrosshair");
    };
    Axis2.prototype.hasVerticalPanning = function() {
      var panningOptions = this.chart.options.chart.panning;
      return Boolean(panningOptions && panningOptions.enabled && // #14624
      /y/.test(panningOptions.type));
    };
    Axis2.prototype.validatePositiveValue = function(value) {
      return isNumber11(value) && value > 0;
    };
    Axis2.prototype.update = function(options, redraw) {
      var chart = this.chart;
      options = merge10(this.userOptions, options);
      this.destroy(true);
      this.init(chart, options);
      chart.isDirtyBox = true;
      if (pick14(redraw, true)) {
        chart.redraw();
      }
    };
    Axis2.prototype.remove = function(redraw) {
      var chart = this.chart, key = this.coll, axisSeries = this.series;
      var i = axisSeries.length;
      while (i--) {
        if (axisSeries[i]) {
          axisSeries[i].remove(false);
        }
      }
      erase3(chart.axes, this);
      erase3(chart[key], this);
      chart[key].forEach(function(axis, i2) {
        axis.options.index = axis.userOptions.index = i2;
      });
      this.destroy();
      chart.isDirtyBox = true;
      if (pick14(redraw, true)) {
        chart.redraw();
      }
    };
    Axis2.prototype.setTitle = function(titleOptions, redraw) {
      this.update({ title: titleOptions }, redraw);
    };
    Axis2.prototype.setCategories = function(categories, redraw) {
      this.update({ categories }, redraw);
    };
    Axis2.defaultOptions = AxisDefaults_default.defaultXAxisOptions;
    Axis2.keepProps = ["extKey", "hcEvents", "names", "series", "userMax", "userMin"];
    return Axis2;
  }()
);
var Axis_default = Axis;

// node_modules/highcharts/es-modules/Core/Axis/DateTimeAxis.js
var addEvent5 = Utilities_default.addEvent;
var getMagnitude3 = Utilities_default.getMagnitude;
var normalizeTickInterval3 = Utilities_default.normalizeTickInterval;
var timeUnits3 = Utilities_default.timeUnits;
var DateTimeAxis;
(function(DateTimeAxis2) {
  var composedClasses2 = [];
  function compose(AxisClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      AxisClass.keepProps.push("dateTime");
      var axisProto = AxisClass.prototype;
      axisProto.getTimeTicks = getTimeTicks;
      addEvent5(AxisClass, "init", onInit);
    }
    return AxisClass;
  }
  DateTimeAxis2.compose = compose;
  function getTimeTicks() {
    return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
  }
  function onInit(e2) {
    var axis = this;
    var options = e2.userOptions;
    if (options.type !== "datetime") {
      axis.dateTime = void 0;
      return;
    }
    if (!axis.dateTime) {
      axis.dateTime = new Additions(axis);
    }
  }
  var Additions = (
    /** @class */
    function() {
      function Additions2(axis) {
        this.axis = axis;
      }
      Additions2.prototype.normalizeTimeTickInterval = function(tickInterval, unitsOption) {
        var units = unitsOption || [[
          "millisecond",
          [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
          // allowed multiples
        ], [
          "second",
          [1, 2, 5, 10, 15, 30]
        ], [
          "minute",
          [1, 2, 5, 10, 15, 30]
        ], [
          "hour",
          [1, 2, 3, 4, 6, 8, 12]
        ], [
          "day",
          [1, 2]
        ], [
          "week",
          [1, 2]
        ], [
          "month",
          [1, 2, 3, 4, 6]
        ], [
          "year",
          null
        ]];
        var unit = units[units.length - 1], interval = timeUnits3[unit[0]], multiples = unit[1], i;
        for (i = 0; i < units.length; i++) {
          unit = units[i];
          interval = timeUnits3[unit[0]];
          multiples = unit[1];
          if (units[i + 1]) {
            var lessThan = (interval * multiples[multiples.length - 1] + timeUnits3[units[i + 1][0]]) / 2;
            if (tickInterval <= lessThan) {
              break;
            }
          }
        }
        if (interval === timeUnits3.year && tickInterval < 5 * interval) {
          multiples = [1, 2, 5];
        }
        var count = normalizeTickInterval3(tickInterval / interval, multiples, unit[0] === "year" ? (
          // #1913, #2360
          Math.max(getMagnitude3(tickInterval / interval), 1)
        ) : 1);
        return {
          unitRange: interval,
          count,
          unitName: unit[0]
        };
      };
      Additions2.prototype.getXDateFormat = function(x, dateTimeLabelFormats) {
        var axis = this.axis;
        return axis.closestPointRange ? axis.chart.time.getDateFormat(axis.closestPointRange, x, axis.options.startOfWeek, dateTimeLabelFormats) || dateTimeLabelFormats.year : (
          // #2546, 2581
          dateTimeLabelFormats.day
        );
      };
      return Additions2;
    }()
  );
  DateTimeAxis2.Additions = Additions;
})(DateTimeAxis || (DateTimeAxis = {}));
var DateTimeAxis_default = DateTimeAxis;

// node_modules/highcharts/es-modules/Core/Axis/LogarithmicAxis.js
var addEvent6 = Utilities_default.addEvent;
var getMagnitude4 = Utilities_default.getMagnitude;
var normalizeTickInterval4 = Utilities_default.normalizeTickInterval;
var pick15 = Utilities_default.pick;
var LogarithmicAxis;
(function(LogarithmicAxis2) {
  var composedClasses2 = [];
  function compose(AxisClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      AxisClass.keepProps.push("logarithmic");
      addEvent6(AxisClass, "init", onInit);
      addEvent6(AxisClass, "afterInit", onAfterInit);
    }
    return AxisClass;
  }
  LogarithmicAxis2.compose = compose;
  function onInit(e2) {
    var axis = this;
    var options = e2.userOptions;
    var logarithmic = axis.logarithmic;
    if (options.type !== "logarithmic") {
      axis.logarithmic = void 0;
    } else {
      if (!logarithmic) {
        logarithmic = axis.logarithmic = new Additions(axis);
      }
    }
  }
  function onAfterInit() {
    var axis = this;
    var log = axis.logarithmic;
    if (log) {
      axis.lin2val = function(num) {
        return log.lin2log(num);
      };
      axis.val2lin = function(num) {
        return log.log2lin(num);
      };
    }
  }
  var Additions = (
    /** @class */
    function() {
      function Additions2(axis) {
        this.axis = axis;
      }
      Additions2.prototype.getLogTickPositions = function(interval, min, max, minor) {
        var log = this;
        var axis = log.axis;
        var axisLength = axis.len;
        var options = axis.options;
        var positions = [];
        if (!minor) {
          log.minorAutoInterval = void 0;
        }
        if (interval >= 0.5) {
          interval = Math.round(interval);
          positions = axis.getLinearTickPositions(interval, min, max);
        } else if (interval >= 0.08) {
          var roundedMin = Math.floor(min);
          var intermediate = void 0, i = void 0, j = void 0, len = void 0, pos = void 0, lastPos = void 0, break2 = void 0;
          if (interval > 0.3) {
            intermediate = [1, 2, 4];
          } else if (interval > 0.15) {
            intermediate = [1, 2, 4, 6, 8];
          } else {
            intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
          }
          for (i = roundedMin; i < max + 1 && !break2; i++) {
            len = intermediate.length;
            for (j = 0; j < len && !break2; j++) {
              pos = log.log2lin(log.lin2log(i) * intermediate[j]);
              if (pos > min && (!minor || lastPos <= max) && typeof lastPos !== "undefined") {
                positions.push(lastPos);
              }
              if (lastPos > max) {
                break2 = true;
              }
              lastPos = pos;
            }
          }
        } else {
          var realMin = log.lin2log(min), realMax = log.lin2log(max), tickIntervalOption = minor ? axis.getMinorTickInterval() : options.tickInterval, filteredTickIntervalOption = tickIntervalOption === "auto" ? null : tickIntervalOption, tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1), totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
          interval = pick15(filteredTickIntervalOption, log.minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
          interval = normalizeTickInterval4(interval, void 0, getMagnitude4(interval));
          positions = axis.getLinearTickPositions(interval, realMin, realMax).map(log.log2lin);
          if (!minor) {
            log.minorAutoInterval = interval / 5;
          }
        }
        if (!minor) {
          axis.tickInterval = interval;
        }
        return positions;
      };
      Additions2.prototype.lin2log = function(num) {
        return Math.pow(10, num);
      };
      Additions2.prototype.log2lin = function(num) {
        return Math.log(num) / Math.LN10;
      };
      return Additions2;
    }()
  );
  LogarithmicAxis2.Additions = Additions;
})(LogarithmicAxis || (LogarithmicAxis = {}));
var LogarithmicAxis_default = LogarithmicAxis;

// node_modules/highcharts/es-modules/Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js
var erase4 = Utilities_default.erase;
var extend10 = Utilities_default.extend;
var isNumber12 = Utilities_default.isNumber;
var PlotLineOrBandAxis;
(function(PlotLineOrBandAxis2) {
  var composedClasses2 = [];
  var PlotLineOrBandClass;
  function compose(PlotLineOrBandType, AxisClass) {
    if (!PlotLineOrBandClass) {
      PlotLineOrBandClass = PlotLineOrBandType;
    }
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      extend10(AxisClass.prototype, Additions.prototype);
    }
    return AxisClass;
  }
  PlotLineOrBandAxis2.compose = compose;
  var Additions = (
    /** @class */
    function() {
      function Additions2() {
      }
      Additions2.prototype.getPlotBandPath = function(from, to, options) {
        if (options === void 0) {
          options = this.options;
        }
        var toPath = this.getPlotLinePath({
          value: to,
          force: true,
          acrossPanes: options.acrossPanes
        }), result2 = [], horiz = this.horiz, outside = !isNumber12(this.min) || !isNumber12(this.max) || from < this.min && to < this.min || from > this.max && to > this.max;
        var path = this.getPlotLinePath({
          value: from,
          force: true,
          acrossPanes: options.acrossPanes
        }), i, plus = 1, isFlat;
        if (path && toPath) {
          if (outside) {
            isFlat = path.toString() === toPath.toString();
            plus = 0;
          }
          for (i = 0; i < path.length; i += 2) {
            var pathStart = path[i], pathEnd = path[i + 1], toPathStart = toPath[i], toPathEnd = toPath[i + 1];
            if ((pathStart[0] === "M" || pathStart[0] === "L") && (pathEnd[0] === "M" || pathEnd[0] === "L") && (toPathStart[0] === "M" || toPathStart[0] === "L") && (toPathEnd[0] === "M" || toPathEnd[0] === "L")) {
              if (horiz && toPathStart[1] === pathStart[1]) {
                toPathStart[1] += plus;
                toPathEnd[1] += plus;
              } else if (!horiz && toPathStart[2] === pathStart[2]) {
                toPathStart[2] += plus;
                toPathEnd[2] += plus;
              }
              result2.push(["M", pathStart[1], pathStart[2]], ["L", pathEnd[1], pathEnd[2]], ["L", toPathEnd[1], toPathEnd[2]], ["L", toPathStart[1], toPathStart[2]], ["Z"]);
            }
            result2.isFlat = isFlat;
          }
        } else {
          path = null;
        }
        return result2;
      };
      Additions2.prototype.addPlotBand = function(options) {
        return this.addPlotBandOrLine(options, "plotBands");
      };
      Additions2.prototype.addPlotLine = function(options) {
        return this.addPlotBandOrLine(options, "plotLines");
      };
      Additions2.prototype.addPlotBandOrLine = function(options, coll) {
        var _this = this;
        var userOptions = this.userOptions;
        var obj = new PlotLineOrBandClass(this, options);
        if (this.visible) {
          obj = obj.render();
        }
        if (obj) {
          if (!this._addedPlotLB) {
            this._addedPlotLB = true;
            (userOptions.plotLines || []).concat(userOptions.plotBands || []).forEach(function(plotLineOptions) {
              _this.addPlotBandOrLine(plotLineOptions);
            });
          }
          if (coll) {
            var updatedOptions = userOptions[coll] || [];
            updatedOptions.push(options);
            userOptions[coll] = updatedOptions;
          }
          this.plotLinesAndBands.push(obj);
        }
        return obj;
      };
      Additions2.prototype.removePlotBandOrLine = function(id) {
        var plotLinesAndBands = this.plotLinesAndBands, options = this.options, userOptions = this.userOptions;
        if (plotLinesAndBands) {
          var i_1 = plotLinesAndBands.length;
          while (i_1--) {
            if (plotLinesAndBands[i_1].id === id) {
              plotLinesAndBands[i_1].destroy();
            }
          }
          [
            options.plotLines || [],
            userOptions.plotLines || [],
            options.plotBands || [],
            userOptions.plotBands || []
          ].forEach(function(arr) {
            i_1 = arr.length;
            while (i_1--) {
              if ((arr[i_1] || {}).id === id) {
                erase4(arr, arr[i_1]);
              }
            }
          });
        }
      };
      Additions2.prototype.removePlotBand = function(id) {
        this.removePlotBandOrLine(id);
      };
      Additions2.prototype.removePlotLine = function(id) {
        this.removePlotBandOrLine(id);
      };
      return Additions2;
    }()
  );
})(PlotLineOrBandAxis || (PlotLineOrBandAxis = {}));
var PlotLineOrBandAxis_default = PlotLineOrBandAxis;

// node_modules/highcharts/es-modules/Core/Axis/PlotLineOrBand/PlotLineOrBand.js
var arrayMax3 = Utilities_default.arrayMax;
var arrayMin3 = Utilities_default.arrayMin;
var defined11 = Utilities_default.defined;
var destroyObjectProperties5 = Utilities_default.destroyObjectProperties;
var erase5 = Utilities_default.erase;
var fireEvent5 = Utilities_default.fireEvent;
var merge11 = Utilities_default.merge;
var objectEach11 = Utilities_default.objectEach;
var pick16 = Utilities_default.pick;
var PlotLineOrBand = (
  /** @class */
  function() {
    function PlotLineOrBand2(axis, options) {
      this.axis = axis;
      if (options) {
        this.options = options;
        this.id = options.id;
      }
    }
    PlotLineOrBand2.compose = function(AxisClass) {
      return PlotLineOrBandAxis_default.compose(PlotLineOrBand2, AxisClass);
    };
    PlotLineOrBand2.prototype.render = function() {
      fireEvent5(this, "render");
      var plotLine = this, axis = plotLine.axis, horiz = axis.horiz, log = axis.logarithmic, options = plotLine.options, color18 = options.color, zIndex = pick16(options.zIndex, 0), events = options.events, groupAttribs = {}, renderer = axis.chart.renderer;
      var optionsLabel = options.label, label = plotLine.label, to = options.to, from = options.from, value = options.value, svgElem = plotLine.svgElem, path = [], group;
      var isBand = defined11(from) && defined11(to), isLine = defined11(value), isNew = !svgElem, attribs = {
        "class": "highcharts-plot-" + (isBand ? "band " : "line ") + (options.className || "")
      };
      var groupName = isBand ? "bands" : "lines";
      if (log) {
        from = log.log2lin(from);
        to = log.log2lin(to);
        value = log.log2lin(value);
      }
      if (!axis.chart.styledMode) {
        if (isLine) {
          attribs.stroke = color18 || Palette_default.neutralColor40;
          attribs["stroke-width"] = pick16(options.width, 1);
          if (options.dashStyle) {
            attribs.dashstyle = options.dashStyle;
          }
        } else if (isBand) {
          attribs.fill = color18 || Palette_default.highlightColor10;
          if (options.borderWidth) {
            attribs.stroke = options.borderColor;
            attribs["stroke-width"] = options.borderWidth;
          }
        }
      }
      groupAttribs.zIndex = zIndex;
      groupName += "-" + zIndex;
      group = axis.plotLinesAndBandsGroups[groupName];
      if (!group) {
        axis.plotLinesAndBandsGroups[groupName] = group = renderer.g("plot-" + groupName).attr(groupAttribs).add();
      }
      if (isNew) {
        plotLine.svgElem = svgElem = renderer.path().attr(attribs).add(group);
      }
      if (isLine) {
        path = axis.getPlotLinePath({
          value,
          lineWidth: svgElem.strokeWidth(),
          acrossPanes: options.acrossPanes
        });
      } else if (isBand) {
        path = axis.getPlotBandPath(from, to, options);
      } else {
        return;
      }
      if (!plotLine.eventsAdded && events) {
        objectEach11(events, function(event, eventType) {
          svgElem.on(eventType, function(e2) {
            events[eventType].apply(plotLine, [e2]);
          });
        });
        plotLine.eventsAdded = true;
      }
      if ((isNew || !svgElem.d) && path && path.length) {
        svgElem.attr({ d: path });
      } else if (svgElem) {
        if (path) {
          svgElem.show(true);
          svgElem.animate({ d: path });
        } else if (svgElem.d) {
          svgElem.hide();
          if (label) {
            plotLine.label = label = label.destroy();
          }
        }
      }
      if (optionsLabel && (defined11(optionsLabel.text) || defined11(optionsLabel.formatter)) && path && path.length && axis.width > 0 && axis.height > 0 && !path.isFlat) {
        optionsLabel = merge11({
          align: horiz && isBand && "center",
          x: horiz ? !isBand && 4 : 10,
          verticalAlign: !horiz && isBand && "middle",
          y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
          rotation: horiz && !isBand && 90
        }, optionsLabel);
        this.renderLabel(optionsLabel, path, isBand, zIndex);
      } else if (label) {
        label.hide();
      }
      return plotLine;
    };
    PlotLineOrBand2.prototype.renderLabel = function(optionsLabel, path, isBand, zIndex) {
      var plotLine = this, axis = plotLine.axis, renderer = axis.chart.renderer;
      var label = plotLine.label;
      if (!label) {
        plotLine.label = label = renderer.text(this.getLabelText(optionsLabel), 0, 0, optionsLabel.useHTML).attr({
          align: optionsLabel.textAlign || optionsLabel.align,
          rotation: optionsLabel.rotation,
          "class": "highcharts-plot-" + (isBand ? "band" : "line") + "-label " + (optionsLabel.className || ""),
          zIndex
        }).add();
        if (!axis.chart.styledMode) {
          label.css(merge11({
            textOverflow: "ellipsis"
          }, optionsLabel.style));
        }
      }
      var xBounds = path.xBounds || [path[0][1], path[1][1], isBand ? path[2][1] : path[0][1]];
      var yBounds = path.yBounds || [path[0][2], path[1][2], isBand ? path[2][2] : path[0][2]];
      var x = arrayMin3(xBounds);
      var y = arrayMin3(yBounds);
      label.align(optionsLabel, false, {
        x,
        y,
        width: arrayMax3(xBounds) - x,
        height: arrayMax3(yBounds) - y
      });
      if (!label.alignValue || label.alignValue === "left") {
        label.css({
          width: (label.rotation === 90 ? axis.height - (label.alignAttr.y - axis.top) : axis.width - (label.alignAttr.x - axis.left)) + "px"
        });
      }
      label.show(true);
    };
    PlotLineOrBand2.prototype.getLabelText = function(optionsLabel) {
      return defined11(optionsLabel.formatter) ? optionsLabel.formatter.call(this) : optionsLabel.text;
    };
    PlotLineOrBand2.prototype.destroy = function() {
      erase5(this.axis.plotLinesAndBands, this);
      delete this.axis;
      destroyObjectProperties5(this);
    };
    return PlotLineOrBand2;
  }()
);
var PlotLineOrBand_default = PlotLineOrBand;

// node_modules/highcharts/es-modules/Core/Tooltip.js
var format2 = FormatUtilities_default.format;
var doc5 = Globals_default.doc;
var distribute = RendererUtilities_default.distribute;
var addEvent7 = Utilities_default.addEvent;
var clamp5 = Utilities_default.clamp;
var css6 = Utilities_default.css;
var defined12 = Utilities_default.defined;
var discardElement3 = Utilities_default.discardElement;
var extend11 = Utilities_default.extend;
var fireEvent6 = Utilities_default.fireEvent;
var isArray6 = Utilities_default.isArray;
var isNumber13 = Utilities_default.isNumber;
var isString7 = Utilities_default.isString;
var merge12 = Utilities_default.merge;
var pick17 = Utilities_default.pick;
var splat5 = Utilities_default.splat;
var syncTimeout4 = Utilities_default.syncTimeout;
var Tooltip = (
  /** @class */
  function() {
    function Tooltip2(chart, options) {
      this.container = void 0;
      this.crosshairs = [];
      this.distance = 0;
      this.isHidden = true;
      this.isSticky = false;
      this.now = {};
      this.options = {};
      this.outside = false;
      this.chart = chart;
      this.init(chart, options);
    }
    Tooltip2.prototype.applyFilter = function() {
      var chart = this.chart;
      chart.renderer.definition({
        tagName: "filter",
        attributes: {
          id: "drop-shadow-" + chart.index,
          opacity: 0.5
        },
        children: [{
          tagName: "feGaussianBlur",
          attributes: {
            "in": "SourceAlpha",
            stdDeviation: 1
          }
        }, {
          tagName: "feOffset",
          attributes: {
            dx: 1,
            dy: 1
          }
        }, {
          tagName: "feComponentTransfer",
          children: [{
            tagName: "feFuncA",
            attributes: {
              type: "linear",
              slope: 0.3
            }
          }]
        }, {
          tagName: "feMerge",
          children: [{
            tagName: "feMergeNode"
          }, {
            tagName: "feMergeNode",
            attributes: {
              "in": "SourceGraphic"
            }
          }]
        }]
      });
    };
    Tooltip2.prototype.bodyFormatter = function(items) {
      return items.map(function(item) {
        var tooltipOptions = item.series.tooltipOptions;
        return (tooltipOptions[(item.point.formatPrefix || "point") + "Formatter"] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || "point") + "Format"] || "");
      });
    };
    Tooltip2.prototype.cleanSplit = function(force) {
      this.chart.series.forEach(function(series) {
        var tt = series && series.tt;
        if (tt) {
          if (!tt.isActive || force) {
            series.tt = tt.destroy();
          } else {
            tt.isActive = false;
          }
        }
      });
    };
    Tooltip2.prototype.defaultFormatter = function(tooltip) {
      var items = this.points || splat5(this);
      var s;
      s = [tooltip.tooltipFooterHeaderFormatter(items[0])];
      s = s.concat(tooltip.bodyFormatter(items));
      s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));
      return s;
    };
    Tooltip2.prototype.destroy = function() {
      if (this.label) {
        this.label = this.label.destroy();
      }
      if (this.split && this.tt) {
        this.cleanSplit(this.chart, true);
        this.tt = this.tt.destroy();
      }
      if (this.renderer) {
        this.renderer = this.renderer.destroy();
        discardElement3(this.container);
      }
      Utilities_default.clearTimeout(this.hideTimer);
      Utilities_default.clearTimeout(this.tooltipTimeout);
    };
    Tooltip2.prototype.getAnchor = function(points, mouseEvent) {
      var chart = this.chart, pointer = chart.pointer, inverted = chart.inverted, plotTop = chart.plotTop, plotLeft = chart.plotLeft;
      var ret, yAxis, xAxis, plotX = 0, plotY = 0;
      points = splat5(points);
      if (this.followPointer && mouseEvent) {
        if (typeof mouseEvent.chartX === "undefined") {
          mouseEvent = pointer.normalize(mouseEvent);
        }
        ret = [
          mouseEvent.chartX - plotLeft,
          mouseEvent.chartY - plotTop
        ];
      } else if (points[0].tooltipPos) {
        ret = points[0].tooltipPos;
      } else {
        points.forEach(function(point) {
          yAxis = point.series.yAxis;
          xAxis = point.series.xAxis;
          plotX += point.plotX || 0;
          plotY += point.plotLow ? (point.plotLow + (point.plotHigh || 0)) / 2 : point.plotY || 0;
          if (xAxis && yAxis) {
            if (!inverted) {
              plotX += xAxis.pos - plotLeft;
              plotY += yAxis.pos - plotTop;
            } else {
              plotX += plotTop + chart.plotHeight - xAxis.len - xAxis.pos;
              plotY += plotLeft + chart.plotWidth - yAxis.len - yAxis.pos;
            }
          }
        });
        plotX /= points.length;
        plotY /= points.length;
        ret = [
          inverted ? chart.plotWidth - plotY : plotX,
          inverted ? chart.plotHeight - plotX : plotY
        ];
        if (this.shared && points.length > 1 && mouseEvent) {
          if (inverted) {
            ret[0] = mouseEvent.chartX - plotLeft;
          } else {
            ret[1] = mouseEvent.chartY - plotTop;
          }
        }
      }
      return ret.map(Math.round);
    };
    Tooltip2.prototype.getLabel = function() {
      var tooltip = this, styledMode = this.chart.styledMode, options = this.options, className = "tooltip" + (defined12(options.className) ? " " + options.className : ""), pointerEvents = options.style.pointerEvents || (!this.followPointer && options.stickOnContact ? "auto" : "none"), onMouseEnter = function() {
        tooltip.inContact = true;
      }, onMouseLeave = function(e2) {
        var series = tooltip.chart.hoverSeries;
        tooltip.inContact = tooltip.shouldStickOnContact() && tooltip.chart.pointer.inClass(e2.relatedTarget, "highcharts-tooltip");
        if (!tooltip.inContact && series && series.onMouseOut) {
          series.onMouseOut();
        }
      };
      var container, renderer = this.chart.renderer;
      if (!this.label) {
        if (this.outside) {
          var chartStyle = this.chart.options.chart.style, Renderer2 = RendererRegistry_default.getRendererType();
          this.container = container = Globals_default.doc.createElement("div");
          container.className = "highcharts-tooltip-container";
          css6(container, {
            position: "absolute",
            top: "1px",
            pointerEvents,
            zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle && chartStyle.zIndex || 0) + 3)
          });
          addEvent7(container, "mouseenter", onMouseEnter);
          addEvent7(container, "mouseleave", onMouseLeave);
          Globals_default.doc.body.appendChild(container);
          this.renderer = renderer = new Renderer2(container, 0, 0, chartStyle, void 0, void 0, renderer.styledMode);
        }
        if (this.split) {
          this.label = renderer.g(className);
        } else {
          this.label = renderer.label("", 0, 0, options.shape, void 0, void 0, options.useHTML, void 0, className).attr({
            padding: options.padding,
            r: options.borderRadius
          });
          if (!styledMode) {
            this.label.attr({
              fill: options.backgroundColor,
              "stroke-width": options.borderWidth
            }).css(options.style).css({ pointerEvents }).shadow(options.shadow);
          }
        }
        if (styledMode && options.shadow) {
          this.applyFilter();
          this.label.attr({
            filter: "url(#drop-shadow-" + this.chart.index + ")"
          });
        }
        if (tooltip.outside && !tooltip.split) {
          var label_1 = this.label;
          var xSetter_1 = label_1.xSetter, ySetter_1 = label_1.ySetter;
          label_1.xSetter = function(value) {
            xSetter_1.call(label_1, tooltip.distance);
            container.style.left = value + "px";
          };
          label_1.ySetter = function(value) {
            ySetter_1.call(label_1, tooltip.distance);
            container.style.top = value + "px";
          };
        }
        this.label.on("mouseenter", onMouseEnter).on("mouseleave", onMouseLeave).attr({ zIndex: 8 }).add();
      }
      return this.label;
    };
    Tooltip2.prototype.getPosition = function(boxWidth, boxHeight, point) {
      var chart = this.chart, distance = this.distance, ret = {}, h = chart.inverted && point.h || 0, outside = this.outside, outerWidth = outside ? (
        // substract distance to prevent scrollbars
        doc5.documentElement.clientWidth - 2 * distance
      ) : chart.chartWidth, outerHeight = outside ? Math.max(doc5.body.scrollHeight, doc5.documentElement.scrollHeight, doc5.body.offsetHeight, doc5.documentElement.offsetHeight, doc5.documentElement.clientHeight) : chart.chartHeight, chartPosition = chart.pointer.getChartPosition(), scaleX = function(val) {
        return (
          // eslint-disable-line no-confusing-arrow
          val * chartPosition.scaleX
        );
      }, scaleY = function(val) {
        return (
          // eslint-disable-line no-confusing-arrow
          val * chartPosition.scaleY
        );
      }, buildDimensionArray = function(dim) {
        var isX = dim === "x";
        return [
          dim,
          isX ? outerWidth : outerHeight,
          isX ? boxWidth : boxHeight
        ].concat(outside ? [
          // If we are using tooltip.outside, we need to scale the
          // position to match scaling of the container in case there
          // is a transform/zoom on the container. #11329
          isX ? scaleX(boxWidth) : scaleY(boxHeight),
          isX ? chartPosition.left - distance + scaleX(point.plotX + chart.plotLeft) : chartPosition.top - distance + scaleY(point.plotY + chart.plotTop),
          0,
          isX ? outerWidth : outerHeight
        ] : [
          // Not outside, no scaling is needed
          isX ? boxWidth : boxHeight,
          isX ? point.plotX + chart.plotLeft : point.plotY + chart.plotTop,
          isX ? chart.plotLeft : chart.plotTop,
          isX ? chart.plotLeft + chart.plotWidth : chart.plotTop + chart.plotHeight
        ]);
      };
      var first = buildDimensionArray("y"), second = buildDimensionArray("x"), swapped;
      var preferFarSide = !this.followPointer && pick17(point.ttBelow, !chart.inverted === !!point.negative), firstDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2, min, max) {
        var scaledDist = outside ? dim === "y" ? scaleY(distance) : scaleX(distance) : distance, scaleDiff = (innerSize - scaledInnerSize) / 2, roomLeft = scaledInnerSize < point2 - distance, roomRight = point2 + distance + scaledInnerSize < outerSize, alignedLeft = point2 - scaledDist - innerSize + scaleDiff, alignedRight = point2 + scaledDist - scaleDiff;
        if (preferFarSide && roomRight) {
          ret[dim] = alignedRight;
        } else if (!preferFarSide && roomLeft) {
          ret[dim] = alignedLeft;
        } else if (roomLeft) {
          ret[dim] = Math.min(max - scaledInnerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
        } else if (roomRight) {
          ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);
        } else {
          return false;
        }
      }, secondDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2) {
        var retVal;
        if (point2 < distance || point2 > outerSize - distance) {
          retVal = false;
        } else if (point2 < innerSize / 2) {
          ret[dim] = 1;
        } else if (point2 > outerSize - scaledInnerSize / 2) {
          ret[dim] = outerSize - scaledInnerSize - 2;
        } else {
          ret[dim] = point2 - innerSize / 2;
        }
        return retVal;
      }, swap = function(count) {
        var temp = first;
        first = second;
        second = temp;
        swapped = count;
      }, run = function() {
        if (firstDimension.apply(0, first) !== false) {
          if (secondDimension.apply(0, second) === false && !swapped) {
            swap(true);
            run();
          }
        } else if (!swapped) {
          swap(true);
          run();
        } else {
          ret.x = ret.y = 0;
        }
      };
      if (chart.inverted || this.len > 1) {
        swap();
      }
      run();
      return ret;
    };
    Tooltip2.prototype.hide = function(delay) {
      var tooltip = this;
      Utilities_default.clearTimeout(this.hideTimer);
      delay = pick17(delay, this.options.hideDelay);
      if (!this.isHidden) {
        this.hideTimer = syncTimeout4(function() {
          tooltip.getLabel().fadeOut(delay ? void 0 : delay);
          tooltip.isHidden = true;
        }, delay);
      }
    };
    Tooltip2.prototype.init = function(chart, options) {
      this.chart = chart;
      this.options = options;
      this.crosshairs = [];
      this.now = { x: 0, y: 0 };
      this.isHidden = true;
      this.split = options.split && !chart.inverted && !chart.polar;
      this.shared = options.shared || this.split;
      this.outside = pick17(options.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY));
    };
    Tooltip2.prototype.shouldStickOnContact = function() {
      return !!(!this.followPointer && this.options.stickOnContact);
    };
    Tooltip2.prototype.isStickyOnContact = function() {
      return !!(this.shouldStickOnContact() && this.inContact);
    };
    Tooltip2.prototype.move = function(x, y, anchorX, anchorY) {
      var tooltip = this, now = tooltip.now, animate4 = tooltip.options.animation !== false && !tooltip.isHidden && // When we get close to the target position, abort animation and
      // land on the right place (#3056)
      (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1), skipAnchor = tooltip.followPointer || tooltip.len > 1;
      extend11(now, {
        x: animate4 ? (2 * now.x + x) / 3 : x,
        y: animate4 ? (now.y + y) / 2 : y,
        anchorX: skipAnchor ? void 0 : animate4 ? (2 * now.anchorX + anchorX) / 3 : anchorX,
        anchorY: skipAnchor ? void 0 : animate4 ? (now.anchorY + anchorY) / 2 : anchorY
      });
      tooltip.getLabel().attr(now);
      tooltip.drawTracker();
      if (animate4) {
        Utilities_default.clearTimeout(this.tooltipTimeout);
        this.tooltipTimeout = setTimeout(function() {
          if (tooltip) {
            tooltip.move(x, y, anchorX, anchorY);
          }
        }, 32);
      }
    };
    Tooltip2.prototype.refresh = function(pointOrPoints, mouseEvent) {
      var tooltip = this, chart = this.chart, options = tooltip.options, points = splat5(pointOrPoints), point = points[0], pointConfig = [], formatter = options.formatter || tooltip.defaultFormatter, shared = tooltip.shared, styledMode = chart.styledMode;
      var textConfig = {};
      if (!options.enabled) {
        return;
      }
      Utilities_default.clearTimeout(this.hideTimer);
      tooltip.followPointer = !tooltip.split && point.series.tooltipOptions.followPointer;
      var anchor = tooltip.getAnchor(pointOrPoints, mouseEvent), x = anchor[0], y = anchor[1];
      if (shared && !(!isArray6(pointOrPoints) && pointOrPoints.series && pointOrPoints.series.noSharedTooltip)) {
        chart.pointer.applyInactiveState(points);
        points.forEach(function(item) {
          item.setState("hover");
          pointConfig.push(item.getLabelConfig());
        });
        textConfig = {
          x: point.category,
          y: point.y
        };
        textConfig.points = pointConfig;
      } else {
        textConfig = point.getLabelConfig();
      }
      this.len = pointConfig.length;
      var text = formatter.call(textConfig, tooltip);
      var currentSeries = point.series;
      this.distance = pick17(currentSeries.tooltipOptions.distance, 16);
      if (text === false) {
        this.hide();
      } else {
        if (tooltip.split) {
          this.renderSplit(text, points);
        } else {
          var checkX = x;
          var checkY = y;
          if (mouseEvent && chart.pointer.isDirectTouch) {
            checkX = mouseEvent.chartX - chart.plotLeft;
            checkY = mouseEvent.chartY - chart.plotTop;
          }
          if (chart.polar || currentSeries.options.clip === false || currentSeries.shouldShowTooltip(checkX, checkY)) {
            var label = tooltip.getLabel();
            if (!options.style.width || styledMode) {
              label.css({
                width: this.chart.spacingBox.width + "px"
              });
            }
            label.attr({
              text: text && text.join ? text.join("") : text
            });
            label.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + pick17(point.colorIndex, currentSeries.colorIndex));
            if (!styledMode) {
              label.attr({
                stroke: options.borderColor || point.color || currentSeries.color || Palette_default.neutralColor60
              });
            }
            tooltip.updatePosition({
              plotX: x,
              plotY: y,
              negative: point.negative,
              ttBelow: point.ttBelow,
              h: anchor[2] || 0
            });
          } else {
            tooltip.hide();
            return;
          }
        }
        if (tooltip.isHidden && tooltip.label) {
          tooltip.label.attr({
            opacity: 1
          }).show();
        }
        tooltip.isHidden = false;
      }
      fireEvent6(this, "refresh");
    };
    Tooltip2.prototype.renderSplit = function(labels, points) {
      var tooltip = this;
      var chart = tooltip.chart, _a15 = tooltip.chart, chartWidth = _a15.chartWidth, chartHeight = _a15.chartHeight, plotHeight = _a15.plotHeight, plotLeft = _a15.plotLeft, plotTop = _a15.plotTop, pointer = _a15.pointer, _b = _a15.scrollablePixelsY, scrollablePixelsY = _b === void 0 ? 0 : _b, scrollablePixelsX = _a15.scrollablePixelsX, _c = _a15.scrollingContainer, _d = _c === void 0 ? { scrollLeft: 0, scrollTop: 0 } : _c, scrollLeft = _d.scrollLeft, scrollTop = _d.scrollTop, styledMode = _a15.styledMode, distance = tooltip.distance, options = tooltip.options, positioner = tooltip.options.positioner;
      var bounds = tooltip.outside && typeof scrollablePixelsX !== "number" ? doc5.documentElement.getBoundingClientRect() : {
        left: scrollLeft,
        right: scrollLeft + chartWidth,
        top: scrollTop,
        bottom: scrollTop + chartHeight
      };
      var tooltipLabel = tooltip.getLabel();
      var ren = this.renderer || chart.renderer;
      var headerTop = Boolean(chart.xAxis[0] && chart.xAxis[0].opposite);
      var _e = pointer.getChartPosition(), chartLeft = _e.left, chartTop = _e.top;
      var distributionBoxTop = plotTop + scrollTop;
      var headerHeight = 0;
      var adjustedPlotHeight = plotHeight - scrollablePixelsY;
      function getAnchor(point) {
        var isHeader = point.isHeader, _a16 = point.plotX, plotX = _a16 === void 0 ? 0 : _a16, _b2 = point.plotY, plotY = _b2 === void 0 ? 0 : _b2, series = point.series;
        var anchorX;
        var anchorY;
        if (isHeader) {
          anchorX = plotLeft + plotX;
          anchorY = plotTop + plotHeight / 2;
        } else {
          var xAxis = series.xAxis, yAxis = series.yAxis;
          anchorX = xAxis.pos + clamp5(plotX, -distance, xAxis.len + distance);
          if (series.shouldShowTooltip(0, yAxis.pos - plotTop + plotY, {
            ignoreX: true
          })) {
            anchorY = yAxis.pos + plotY;
          }
        }
        anchorX = clamp5(anchorX, bounds.left - distance, bounds.right + distance);
        return { anchorX, anchorY };
      }
      function defaultPositioner(anchorX, anchorY, isHeader, boxWidth, alignedLeft) {
        if (alignedLeft === void 0) {
          alignedLeft = true;
        }
        var y2;
        var x2;
        if (isHeader) {
          y2 = headerTop ? 0 : adjustedPlotHeight;
          x2 = clamp5(anchorX - boxWidth / 2, bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0));
        } else {
          y2 = anchorY - distributionBoxTop;
          x2 = alignedLeft ? anchorX - boxWidth - distance : anchorX + distance;
          x2 = clamp5(x2, alignedLeft ? x2 : bounds.left, bounds.right);
        }
        return { x: x2, y: y2 };
      }
      function updatePartialTooltip(partialTooltip, point, str) {
        var tt = partialTooltip;
        var isHeader = point.isHeader, series = point.series;
        var colorClass = "highcharts-color-" + pick17(point.colorIndex, series.colorIndex, "none");
        if (!tt) {
          var attribs = {
            padding: options.padding,
            r: options.borderRadius
          };
          if (!styledMode) {
            attribs.fill = options.backgroundColor;
            attribs["stroke-width"] = options.borderWidth;
          }
          tt = ren.label("", 0, 0, options[isHeader ? "headerShape" : "shape"], void 0, void 0, options.useHTML).addClass((isHeader ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + colorClass).attr(attribs).add(tooltipLabel);
        }
        tt.isActive = true;
        tt.attr({
          text: str
        });
        if (!styledMode) {
          tt.css(options.style).shadow(options.shadow).attr({
            stroke: options.borderColor || point.color || series.color || Palette_default.neutralColor80
          });
        }
        return tt;
      }
      if (isString7(labels)) {
        labels = [false, labels];
      }
      var boxes = labels.slice(0, points.length + 1).reduce(function(boxes2, str, i) {
        if (str !== false && str !== "") {
          var point = points[i - 1] || {
            // Item 0 is the header. Instead of this, we could also
            // use the crosshair label
            isHeader: true,
            plotX: points[0].plotX,
            plotY: plotHeight,
            series: {}
          };
          var isHeader = point.isHeader;
          var owner = isHeader ? tooltip : point.series;
          var tt = owner.tt = updatePartialTooltip(owner.tt, point, str.toString());
          var bBox = tt.getBBox();
          var boxWidth = bBox.width + tt.strokeWidth();
          if (isHeader) {
            headerHeight = bBox.height;
            adjustedPlotHeight += headerHeight;
            if (headerTop) {
              distributionBoxTop -= headerHeight;
            }
          }
          var _a16 = getAnchor(point), anchorX = _a16.anchorX, anchorY = _a16.anchorY;
          if (typeof anchorY === "number") {
            var size = bBox.height + 1;
            var boxPosition = positioner ? positioner.call(tooltip, boxWidth, size, point) : defaultPositioner(anchorX, anchorY, isHeader, boxWidth);
            boxes2.push({
              // 0-align to the top, 1-align to the bottom
              align: positioner ? 0 : void 0,
              anchorX,
              anchorY,
              boxWidth,
              point,
              rank: pick17(boxPosition.rank, isHeader ? 1 : 0),
              size,
              target: boxPosition.y,
              tt,
              x: boxPosition.x
            });
          } else {
            tt.isActive = false;
          }
        }
        return boxes2;
      }, []);
      if (!positioner && boxes.some(function(box) {
        var outside2 = tooltip.outside;
        var boxStart = (outside2 ? chartLeft : 0) + box.anchorX;
        if (boxStart < bounds.left && boxStart + box.boxWidth < bounds.right) {
          return true;
        }
        return boxStart < chartLeft - bounds.left + box.boxWidth && bounds.right - boxStart > boxStart;
      })) {
        boxes = boxes.map(function(box) {
          var _a16 = defaultPositioner(box.anchorX, box.anchorY, box.point.isHeader, box.boxWidth, false), x2 = _a16.x, y2 = _a16.y;
          return extend11(box, {
            target: y2,
            x: x2
          });
        });
      }
      tooltip.cleanSplit();
      distribute(boxes, adjustedPlotHeight);
      var boxExtremes = {
        left: chartLeft,
        right: chartLeft
      };
      boxes.forEach(function(box) {
        var x2 = box.x, boxWidth = box.boxWidth, isHeader = box.isHeader;
        if (!isHeader) {
          if (tooltip.outside && chartLeft + x2 < boxExtremes.left) {
            boxExtremes.left = chartLeft + x2;
          }
          if (!isHeader && tooltip.outside && boxExtremes.left + boxWidth > boxExtremes.right) {
            boxExtremes.right = chartLeft + x2;
          }
        }
      });
      boxes.forEach(function(box) {
        var x2 = box.x, anchorX = box.anchorX, anchorY = box.anchorY, pos = box.pos, isHeader = box.point.isHeader;
        var attributes = {
          visibility: typeof pos === "undefined" ? "hidden" : "inherit",
          x: x2,
          /* NOTE: y should equal pos to be consistent with !split
           * tooltip, but is currently relative to plotTop. Is left as is
           * to avoid breaking change. Remove distributionBoxTop to make
           * it consistent.
           */
          y: pos + distributionBoxTop,
          anchorX,
          anchorY
        };
        if (tooltip.outside && x2 < anchorX) {
          var offset3 = chartLeft - boxExtremes.left;
          if (offset3 > 0) {
            if (!isHeader) {
              attributes.x = x2 + offset3;
              attributes.anchorX = anchorX + offset3;
            }
            if (isHeader) {
              attributes.x = (boxExtremes.right - boxExtremes.left) / 2;
              attributes.anchorX = anchorX + offset3;
            }
          }
        }
        box.tt.attr(attributes);
      });
      var container = tooltip.container, outside = tooltip.outside, renderer = tooltip.renderer;
      if (outside && container && renderer) {
        var _f = tooltipLabel.getBBox(), width = _f.width, height = _f.height, x = _f.x, y = _f.y;
        renderer.setSize(width + x, height + y, false);
        container.style.left = boxExtremes.left + "px";
        container.style.top = chartTop + "px";
      }
    };
    Tooltip2.prototype.drawTracker = function() {
      var tooltip = this;
      if (tooltip.followPointer || !tooltip.options.stickOnContact) {
        if (tooltip.tracker) {
          tooltip.tracker.destroy();
        }
        return;
      }
      var chart = tooltip.chart;
      var label = tooltip.label;
      var points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;
      if (!label || !points) {
        return;
      }
      var box = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      var anchorPos = this.getAnchor(points);
      var labelBBox = label.getBBox();
      anchorPos[0] += chart.plotLeft - label.translateX;
      anchorPos[1] += chart.plotTop - label.translateY;
      box.x = Math.min(0, anchorPos[0]);
      box.y = Math.min(0, anchorPos[1]);
      box.width = anchorPos[0] < 0 ? Math.max(Math.abs(anchorPos[0]), labelBBox.width - anchorPos[0]) : Math.max(Math.abs(anchorPos[0]), labelBBox.width);
      box.height = anchorPos[1] < 0 ? Math.max(Math.abs(anchorPos[1]), labelBBox.height - Math.abs(anchorPos[1])) : Math.max(Math.abs(anchorPos[1]), labelBBox.height);
      if (tooltip.tracker) {
        tooltip.tracker.attr(box);
      } else {
        tooltip.tracker = label.renderer.rect(box).addClass("highcharts-tracker").add(label);
        if (!chart.styledMode) {
          tooltip.tracker.attr({
            fill: "rgba(0,0,0,0)"
          });
        }
      }
    };
    Tooltip2.prototype.styledModeFormat = function(formatString) {
      return formatString.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
    };
    Tooltip2.prototype.tooltipFooterHeaderFormatter = function(labelConfig, isFooter) {
      var series = labelConfig.series, tooltipOptions = series.tooltipOptions, xAxis = series.xAxis, dateTime = xAxis && xAxis.dateTime, e2 = {
        isFooter,
        labelConfig
      };
      var xDateFormat = tooltipOptions.xDateFormat, formatString = tooltipOptions[isFooter ? "footerFormat" : "headerFormat"];
      fireEvent6(this, "headerFormatter", e2, function(e3) {
        if (dateTime && !xDateFormat && isNumber13(labelConfig.key)) {
          xDateFormat = dateTime.getXDateFormat(labelConfig.key, tooltipOptions.dateTimeLabelFormats);
        }
        if (dateTime && xDateFormat) {
          (labelConfig.point && labelConfig.point.tooltipDateKeys || ["key"]).forEach(function(key) {
            formatString = formatString.replace("{point." + key + "}", "{point." + key + ":" + xDateFormat + "}");
          });
        }
        if (series.chart.styledMode) {
          formatString = this.styledModeFormat(formatString);
        }
        e3.text = format2(formatString, {
          point: labelConfig,
          series
        }, this.chart);
      });
      return e2.text;
    };
    Tooltip2.prototype.update = function(options) {
      this.destroy();
      merge12(true, this.chart.options.tooltip.userOptions, options);
      this.init(this.chart, merge12(true, this.options, options));
    };
    Tooltip2.prototype.updatePosition = function(point) {
      var chart = this.chart, options = this.options, pointer = chart.pointer, label = this.getLabel(), chartPosition = pointer.getChartPosition(), pos = (options.positioner || this.getPosition).call(this, label.width, label.height, point);
      var anchorX = point.plotX + chart.plotLeft, anchorY = point.plotY + chart.plotTop, pad4;
      if (this.outside) {
        pad4 = options.borderWidth + 2 * this.distance;
        this.renderer.setSize(label.width + pad4, label.height + pad4, false);
        if (chartPosition.scaleX !== 1 || chartPosition.scaleY !== 1) {
          css6(this.container, {
            transform: "scale(" + chartPosition.scaleX + ", " + chartPosition.scaleY + ")"
          });
          anchorX *= chartPosition.scaleX;
          anchorY *= chartPosition.scaleY;
        }
        anchorX += chartPosition.left - pos.x;
        anchorY += chartPosition.top - pos.y;
      }
      this.move(
        Math.round(pos.x),
        Math.round(pos.y || 0),
        // can be undefined (#3977)
        anchorX,
        anchorY
      );
    };
    return Tooltip2;
  }()
);
var Tooltip_default = Tooltip;

// node_modules/highcharts/es-modules/Core/Series/Point.js
var animObject4 = AnimationUtilities_default.animObject;
var defaultOptions4 = DefaultOptions_default.defaultOptions;
var format3 = FormatUtilities_default.format;
var addEvent8 = Utilities_default.addEvent;
var defined13 = Utilities_default.defined;
var erase6 = Utilities_default.erase;
var extend12 = Utilities_default.extend;
var fireEvent7 = Utilities_default.fireEvent;
var getNestedProperty3 = Utilities_default.getNestedProperty;
var isArray7 = Utilities_default.isArray;
var isFunction4 = Utilities_default.isFunction;
var isNumber14 = Utilities_default.isNumber;
var isObject5 = Utilities_default.isObject;
var merge13 = Utilities_default.merge;
var objectEach12 = Utilities_default.objectEach;
var pick18 = Utilities_default.pick;
var syncTimeout5 = Utilities_default.syncTimeout;
var removeEvent5 = Utilities_default.removeEvent;
var uniqueKey4 = Utilities_default.uniqueKey;
var Point = (
  /** @class */
  function() {
    function Point4() {
      this.category = void 0;
      this.colorIndex = void 0;
      this.formatPrefix = "point";
      this.id = void 0;
      this.isNull = false;
      this.name = void 0;
      this.options = void 0;
      this.percentage = void 0;
      this.selected = false;
      this.series = void 0;
      this.total = void 0;
      this.visible = true;
      this.x = void 0;
    }
    Point4.prototype.animateBeforeDestroy = function() {
      var point = this, animateParams = { x: point.startXPos, opacity: 0 }, graphicalProps = point.getGraphicalProps();
      graphicalProps.singular.forEach(function(prop) {
        var isDataLabel = prop === "dataLabel";
        point[prop] = point[prop].animate(isDataLabel ? {
          x: point[prop].startXPos,
          y: point[prop].startYPos,
          opacity: 0
        } : animateParams);
      });
      graphicalProps.plural.forEach(function(plural) {
        point[plural].forEach(function(item) {
          if (item.element) {
            item.animate(extend12({ x: point.startXPos }, item.startYPos ? {
              x: item.startXPos,
              y: item.startYPos
            } : {}));
          }
        });
      });
    };
    Point4.prototype.applyOptions = function(options, x) {
      var point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;
      options = Point4.prototype.optionsToObject.call(this, options);
      extend12(point, options);
      point.options = point.options ? extend12(point.options, options) : options;
      if (options.group) {
        delete point.group;
      }
      if (options.dataLabels) {
        delete point.dataLabels;
      }
      if (pointValKey) {
        point.y = Point4.prototype.getNestedProperty.call(point, pointValKey);
      }
      point.isNull = pick18(point.isValid && !point.isValid(), point.x === null || !isNumber14(point.y));
      point.formatPrefix = point.isNull ? "null" : "point";
      if (point.selected) {
        point.state = "select";
      }
      if ("name" in point && typeof x === "undefined" && series.xAxis && series.xAxis.hasNames) {
        point.x = series.xAxis.nameToX(point);
      }
      if (typeof point.x === "undefined" && series) {
        if (typeof x === "undefined") {
          point.x = series.autoIncrement();
        } else {
          point.x = x;
        }
      } else if (isNumber14(options.x) && series.options.relativeXValue) {
        point.x = series.autoIncrement(options.x);
      }
      return point;
    };
    Point4.prototype.destroy = function() {
      var point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject4(globalAnimation);
      var prop;
      function destroyPoint() {
        if (point.graphic || point.dataLabel || point.dataLabels) {
          removeEvent5(point);
          point.destroyElements();
        }
        for (prop in point) {
          point[prop] = null;
        }
      }
      if (point.legendItem) {
        chart.legend.destroyItem(point);
      }
      if (hoverPoints) {
        point.setState();
        erase6(hoverPoints, point);
        if (!hoverPoints.length) {
          chart.hoverPoints = null;
        }
      }
      if (point === chart.hoverPoint) {
        point.onMouseOut();
      }
      if (!dataSorting || !dataSorting.enabled) {
        destroyPoint();
      } else {
        this.animateBeforeDestroy();
        syncTimeout5(destroyPoint, animation.duration);
      }
      chart.pointCount--;
    };
    Point4.prototype.destroyElements = function(kinds) {
      var point = this, props = point.getGraphicalProps(kinds);
      props.singular.forEach(function(prop) {
        point[prop] = point[prop].destroy();
      });
      props.plural.forEach(function(plural) {
        point[plural].forEach(function(item) {
          if (item.element) {
            item.destroy();
          }
        });
        delete point[plural];
      });
    };
    Point4.prototype.firePointEvent = function(eventType, eventArgs, defaultFunction) {
      var point = this, series = this.series, seriesOptions = series.options;
      if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {
        point.importEvents();
      }
      if (eventType === "click" && seriesOptions.allowPointSelect) {
        defaultFunction = function(event) {
          if (point.select) {
            point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
          }
        };
      }
      fireEvent7(point, eventType, eventArgs, defaultFunction);
    };
    Point4.prototype.getClassName = function() {
      var point = this;
      return "highcharts-point" + (point.selected ? " highcharts-point-select" : "") + (point.negative ? " highcharts-negative" : "") + (point.isNull ? " highcharts-null-point" : "") + (typeof point.colorIndex !== "undefined" ? " highcharts-color-" + point.colorIndex : "") + (point.options.className ? " " + point.options.className : "") + (point.zone && point.zone.className ? " " + point.zone.className.replace("highcharts-negative", "") : "");
    };
    Point4.prototype.getGraphicalProps = function(kinds) {
      var point = this, props = [], graphicalProps = { singular: [], plural: [] };
      var prop, i;
      kinds = kinds || { graphic: 1, dataLabel: 1 };
      if (kinds.graphic) {
        props.push("graphic", "upperGraphic", "shadowGroup");
      }
      if (kinds.dataLabel) {
        props.push("dataLabel", "dataLabelUpper", "connector");
      }
      i = props.length;
      while (i--) {
        prop = props[i];
        if (point[prop]) {
          graphicalProps.singular.push(prop);
        }
      }
      ["dataLabel", "connector"].forEach(function(prop2) {
        var plural = prop2 + "s";
        if (kinds[prop2] && point[plural]) {
          graphicalProps.plural.push(plural);
        }
      });
      return graphicalProps;
    };
    Point4.prototype.getLabelConfig = function() {
      return {
        x: this.category,
        y: this.y,
        color: this.color,
        colorIndex: this.colorIndex,
        key: this.name || this.category,
        series: this.series,
        point: this,
        percentage: this.percentage,
        total: this.total || this.stackTotal
      };
    };
    Point4.prototype.getNestedProperty = function(key) {
      if (!key) {
        return;
      }
      if (key.indexOf("custom.") === 0) {
        return getNestedProperty3(key, this.options);
      }
      return this[key];
    };
    Point4.prototype.getZone = function() {
      var series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || "y";
      var zone, i = 0;
      zone = zones[i];
      while (this[zoneAxis] >= zone.value) {
        zone = zones[++i];
      }
      if (!this.nonZonedColor) {
        this.nonZonedColor = this.color;
      }
      if (zone && zone.color && !this.options.color) {
        this.color = zone.color;
      } else {
        this.color = this.nonZonedColor;
      }
      return zone;
    };
    Point4.prototype.hasNewShapeType = function() {
      var point = this;
      var oldShapeType = point.graphic && (point.graphic.symbolName || point.graphic.element.nodeName);
      return oldShapeType !== this.shapeType;
    };
    Point4.prototype.init = function(series, options, x) {
      this.series = series;
      this.applyOptions(options, x);
      this.id = defined13(this.id) ? this.id : uniqueKey4();
      this.resolveColor();
      series.chart.pointCount++;
      fireEvent7(this, "afterInit");
      return this;
    };
    Point4.prototype.optionsToObject = function(options) {
      var series = this.series, keys2 = series.options.keys, pointArrayMap = keys2 || series.pointArrayMap || ["y"], valueCount = pointArrayMap.length;
      var ret = {}, firstItemType, i = 0, j = 0;
      if (isNumber14(options) || options === null) {
        ret[pointArrayMap[0]] = options;
      } else if (isArray7(options)) {
        if (!keys2 && options.length > valueCount) {
          firstItemType = typeof options[0];
          if (firstItemType === "string") {
            ret.name = options[0];
          } else if (firstItemType === "number") {
            ret.x = options[0];
          }
          i++;
        }
        while (j < valueCount) {
          if (!keys2 || typeof options[i] !== "undefined") {
            if (pointArrayMap[j].indexOf(".") > 0) {
              Point4.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);
            } else {
              ret[pointArrayMap[j]] = options[i];
            }
          }
          i++;
          j++;
        }
      } else if (typeof options === "object") {
        ret = options;
        if (options.dataLabels) {
          series._hasPointLabels = true;
        }
        if (options.marker) {
          series._hasPointMarkers = true;
        }
      }
      return ret;
    };
    Point4.prototype.resolveColor = function() {
      var series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;
      var color18, colors, colorCount = optionsChart.colorCount, colorIndex;
      delete this.nonZonedColor;
      if (series.options.colorByPoint) {
        if (!styledMode) {
          colors = series.options.colors || series.chart.options.colors;
          color18 = colors[series.colorCounter];
          colorCount = colors.length;
        }
        colorIndex = series.colorCounter;
        series.colorCounter++;
        if (series.colorCounter === colorCount) {
          series.colorCounter = 0;
        }
      } else {
        if (!styledMode) {
          color18 = series.color;
        }
        colorIndex = series.colorIndex;
      }
      this.colorIndex = pick18(this.options.colorIndex, colorIndex);
      this.color = pick18(this.options.color, color18);
    };
    Point4.prototype.setNestedProperty = function(object, value, key) {
      var nestedKeys = key.split(".");
      nestedKeys.reduce(function(result2, key2, i, arr) {
        var isLastKey = arr.length - 1 === i;
        result2[key2] = isLastKey ? value : isObject5(result2[key2], true) ? result2[key2] : {};
        return result2[key2];
      }, object);
      return object;
    };
    Point4.prototype.tooltipFormatter = function(pointFormat) {
      var series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick18(seriesTooltipOptions.valueDecimals, ""), valuePrefix = seriesTooltipOptions.valuePrefix || "", valueSuffix = seriesTooltipOptions.valueSuffix || "";
      if (series.chart.styledMode) {
        pointFormat = series.chart.tooltip.styledModeFormat(pointFormat);
      }
      (series.pointArrayMap || ["y"]).forEach(function(key) {
        key = "{point." + key;
        if (valuePrefix || valueSuffix) {
          pointFormat = pointFormat.replace(RegExp(key + "}", "g"), valuePrefix + key + "}" + valueSuffix);
        }
        pointFormat = pointFormat.replace(RegExp(key + "}", "g"), key + ":,." + valueDecimals + "f}");
      });
      return format3(pointFormat, {
        point: this,
        series: this.series
      }, series.chart);
    };
    Point4.prototype.update = function(options, redraw, animation, runEvent) {
      var point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;
      var i;
      redraw = pick18(redraw, true);
      function update() {
        point.applyOptions(options);
        var hasDummyGraphic = graphic && point.hasDummyGraphic;
        var shouldDestroyGraphic = point.y === null ? !hasDummyGraphic : hasDummyGraphic;
        if (graphic && shouldDestroyGraphic) {
          point.graphic = graphic.destroy();
          delete point.hasDummyGraphic;
        }
        if (isObject5(options, true)) {
          if (graphic && graphic.element) {
            if (options && options.marker && typeof options.marker.symbol !== "undefined") {
              point.graphic = graphic.destroy();
            }
          }
          if (options && options.dataLabels && point.dataLabel) {
            point.dataLabel = point.dataLabel.destroy();
          }
          if (point.connector) {
            point.connector = point.connector.destroy();
          }
        }
        i = point.index;
        series.updateParallelArrays(point, i);
        seriesOptions.data[i] = isObject5(seriesOptions.data[i], true) || isObject5(options, true) ? point.options : pick18(options, seriesOptions.data[i]);
        series.isDirty = series.isDirtyData = true;
        if (!series.fixedBox && series.hasCartesianSeries) {
          chart.isDirtyBox = true;
        }
        if (seriesOptions.legendType === "point") {
          chart.isDirtyLegend = true;
        }
        if (redraw) {
          chart.redraw(animation);
        }
      }
      if (runEvent === false) {
        update();
      } else {
        point.firePointEvent("update", { options }, update);
      }
    };
    Point4.prototype.remove = function(redraw, animation) {
      this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
    };
    Point4.prototype.select = function(selected, accumulate) {
      var point = this, series = point.series, chart = series.chart;
      selected = pick18(selected, !point.selected);
      this.selectedStaging = selected;
      point.firePointEvent(selected ? "select" : "unselect", { accumulate }, function() {
        point.selected = point.options.selected = selected;
        series.options.data[series.data.indexOf(point)] = point.options;
        point.setState(selected && "select");
        if (!accumulate) {
          chart.getSelectedPoints().forEach(function(loopPoint) {
            var loopSeries = loopPoint.series;
            if (loopPoint.selected && loopPoint !== point) {
              loopPoint.selected = loopPoint.options.selected = false;
              loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
              loopPoint.setState(chart.hoverPoints && loopSeries.options.inactiveOtherPoints ? "inactive" : "");
              loopPoint.firePointEvent("unselect");
            }
          });
        }
      });
      delete this.selectedStaging;
    };
    Point4.prototype.onMouseOver = function(e2) {
      var point = this, series = point.series, chart = series.chart, pointer = chart.pointer;
      e2 = e2 ? pointer.normalize(e2) : (
        // In cases where onMouseOver is called directly without an event
        pointer.getChartCoordinatesFromPoint(point, chart.inverted)
      );
      pointer.runPointActions(e2, point);
    };
    Point4.prototype.onMouseOut = function() {
      var point = this, chart = point.series.chart;
      point.firePointEvent("mouseOut");
      if (!point.series.options.inactiveOtherPoints) {
        (chart.hoverPoints || []).forEach(function(p) {
          p.setState();
        });
      }
      chart.hoverPoints = chart.hoverPoint = null;
    };
    Point4.prototype.importEvents = function() {
      if (!this.hasImportedEvents) {
        var point_1 = this, options = merge13(point_1.series.options.point, point_1.options), events = options.events;
        point_1.events = events;
        objectEach12(events, function(event, eventType) {
          if (isFunction4(event)) {
            addEvent8(point_1, eventType, event);
          }
        });
        this.hasImportedEvents = true;
      }
    };
    Point4.prototype.setState = function(state, move) {
      var point = this, series = point.series, previousState = point.state, stateOptions = series.options.states[state || "normal"] || {}, markerOptions = defaultOptions4.plotOptions[series.type].marker && series.options.marker, normalDisabled = markerOptions && markerOptions.enabled === false, markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || "normal"] || {}, stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = markerOptions && series.markerAttribs;
      var halo = series.halo, markerAttribs, pointAttribs2, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
      state = state || "";
      if (
        // already has this state
        state === point.state && !move || // selected points don't respond to hover
        point.selected && state !== "select" || // series' state options is disabled
        stateOptions.enabled === false || // general point marker's state options is disabled
        state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || // individual point marker's state options is disabled
        state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false
      ) {
        return;
      }
      point.state = state;
      if (hasMarkers) {
        markerAttribs = series.markerAttribs(point, state);
      }
      if (point.graphic && !point.hasDummyGraphic) {
        if (previousState) {
          point.graphic.removeClass("highcharts-point-" + previousState);
        }
        if (state) {
          point.graphic.addClass("highcharts-point-" + state);
        }
        if (!chart.styledMode) {
          pointAttribs2 = series.pointAttribs(point, state);
          pointAttribsAnimation = pick18(chart.options.chart.animation, stateOptions.animation);
          if (series.options.inactiveOtherPoints && isNumber14(pointAttribs2.opacity)) {
            (point.dataLabels || []).forEach(function(label) {
              if (label) {
                label.animate({
                  opacity: pointAttribs2.opacity
                }, pointAttribsAnimation);
              }
            });
            if (point.connector) {
              point.connector.animate({
                opacity: pointAttribs2.opacity
              }, pointAttribsAnimation);
            }
          }
          point.graphic.animate(pointAttribs2, pointAttribsAnimation);
        }
        if (markerAttribs) {
          point.graphic.animate(markerAttribs, pick18(
            // Turn off globally:
            chart.options.chart.animation,
            markerStateOptions.animation,
            markerOptions.animation
          ));
        }
        if (stateMarkerGraphic) {
          stateMarkerGraphic.hide();
        }
      } else {
        if (state && markerStateOptions) {
          newSymbol = pointMarker.symbol || series.symbol;
          if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
            stateMarkerGraphic = stateMarkerGraphic.destroy();
          }
          if (markerAttribs) {
            if (!stateMarkerGraphic) {
              if (newSymbol) {
                series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);
                stateMarkerGraphic.currentSymbol = newSymbol;
              }
            } else {
              stateMarkerGraphic[move ? "animate" : "attr"]({
                x: markerAttribs.x,
                y: markerAttribs.y
              });
            }
          }
          if (!chart.styledMode && stateMarkerGraphic) {
            stateMarkerGraphic.attr(series.pointAttribs(point, state));
          }
        }
        if (stateMarkerGraphic) {
          stateMarkerGraphic[state && point.isInside ? "show" : "hide"]();
          stateMarkerGraphic.element.point = point;
          stateMarkerGraphic.addClass(point.getClassName(), true);
        }
      }
      var haloOptions = stateOptions.halo;
      var markerGraphic = point.graphic || stateMarkerGraphic;
      var markerVisibility = markerGraphic && markerGraphic.visibility || "inherit";
      if (haloOptions && haloOptions.size && markerGraphic && markerVisibility !== "hidden" && !point.isCluster) {
        if (!halo) {
          series.halo = halo = chart.renderer.path().add(markerGraphic.parentGroup);
        }
        halo.show()[move ? "animate" : "attr"]({
          d: point.haloPath(haloOptions.size)
        });
        halo.attr({
          "class": "highcharts-halo highcharts-color-" + pick18(point.colorIndex, series.colorIndex) + (point.className ? " " + point.className : ""),
          "visibility": markerVisibility,
          "zIndex": -1
          // #4929, #8276
        });
        halo.point = point;
        if (!chart.styledMode) {
          halo.attr(extend12({
            "fill": point.color || series.color,
            "fill-opacity": haloOptions.opacity
          }, AST_default.filterUserAttributes(haloOptions.attributes || {})));
        }
      } else if (halo && halo.point && halo.point.haloPath) {
        halo.animate(
          { d: halo.point.haloPath(0) },
          null,
          // Hide after unhovering. The `complete` callback runs in the
          // halo's context (#7681).
          halo.hide
        );
      }
      fireEvent7(point, "afterSetState", { state });
    };
    Point4.prototype.haloPath = function(size) {
      var series = this.series, chart = series.chart;
      return chart.renderer.symbols.circle(Math.floor(this.plotX) - size, this.plotY - size, size * 2, size * 2);
    };
    return Point4;
  }()
);
var Point_default = Point;

// node_modules/highcharts/es-modules/Core/Pointer.js
var color3 = Color_default.parse;
var charts3 = Globals_default.charts;
var noop3 = Globals_default.noop;
var addEvent9 = Utilities_default.addEvent;
var attr8 = Utilities_default.attr;
var css7 = Utilities_default.css;
var defined14 = Utilities_default.defined;
var extend13 = Utilities_default.extend;
var find2 = Utilities_default.find;
var fireEvent8 = Utilities_default.fireEvent;
var isNumber15 = Utilities_default.isNumber;
var isObject6 = Utilities_default.isObject;
var objectEach13 = Utilities_default.objectEach;
var offset2 = Utilities_default.offset;
var pick19 = Utilities_default.pick;
var splat6 = Utilities_default.splat;
var Pointer = (
  /** @class */
  function() {
    function Pointer2(chart, options) {
      this.lastValidTouch = {};
      this.pinchDown = [];
      this.runChartClick = false;
      this.eventsToUnbind = [];
      this.chart = chart;
      this.hasDragged = false;
      this.options = options;
      this.init(chart, options);
    }
    Pointer2.prototype.applyInactiveState = function(points) {
      var activeSeries = [], series;
      (points || []).forEach(function(item) {
        series = item.series;
        activeSeries.push(series);
        if (series.linkedParent) {
          activeSeries.push(series.linkedParent);
        }
        if (series.linkedSeries) {
          activeSeries = activeSeries.concat(series.linkedSeries);
        }
        if (series.navigatorSeries) {
          activeSeries.push(series.navigatorSeries);
        }
      });
      this.chart.series.forEach(function(inactiveSeries) {
        if (activeSeries.indexOf(inactiveSeries) === -1) {
          inactiveSeries.setState("inactive", true);
        } else if (inactiveSeries.options.inactiveOtherPoints) {
          inactiveSeries.setAllPointsToState("inactive");
        }
      });
    };
    Pointer2.prototype.destroy = function() {
      var pointer = this;
      this.eventsToUnbind.forEach(function(unbind) {
        return unbind();
      });
      this.eventsToUnbind = [];
      if (!Globals_default.chartCount) {
        if (Pointer2.unbindDocumentMouseUp) {
          Pointer2.unbindDocumentMouseUp = Pointer2.unbindDocumentMouseUp();
        }
        if (Pointer2.unbindDocumentTouchEnd) {
          Pointer2.unbindDocumentTouchEnd = Pointer2.unbindDocumentTouchEnd();
        }
      }
      clearInterval(pointer.tooltipTimeout);
      objectEach13(pointer, function(_val, prop) {
        pointer[prop] = void 0;
      });
    };
    Pointer2.prototype.drag = function(e2) {
      var chart = this.chart, chartOptions = chart.options.chart, zoomHor = this.zoomHor, zoomVert = this.zoomVert, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, mouseDownX = this.mouseDownX || 0, mouseDownY = this.mouseDownY || 0, panningEnabled = isObject6(chartOptions.panning) ? chartOptions.panning && chartOptions.panning.enabled : chartOptions.panning, panKey = chartOptions.panKey && e2[chartOptions.panKey + "Key"];
      var chartX = e2.chartX, chartY = e2.chartY, clickedInside, size, selectionMarker = this.selectionMarker;
      if (selectionMarker && selectionMarker.touch) {
        return;
      }
      if (chartX < plotLeft) {
        chartX = plotLeft;
      } else if (chartX > plotLeft + plotWidth) {
        chartX = plotLeft + plotWidth;
      }
      if (chartY < plotTop) {
        chartY = plotTop;
      } else if (chartY > plotTop + plotHeight) {
        chartY = plotTop + plotHeight;
      }
      this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));
      if (this.hasDragged > 10) {
        clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop, {
          visiblePlotOnly: true
        });
        if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
          if (!selectionMarker) {
            this.selectionMarker = selectionMarker = chart.renderer.rect(plotLeft, plotTop, zoomHor ? 1 : plotWidth, zoomVert ? 1 : plotHeight, 0).attr({
              "class": "highcharts-selection-marker",
              zIndex: 7
            }).add();
            if (!chart.styledMode) {
              selectionMarker.attr({
                fill: chartOptions.selectionMarkerFill || color3(Palette_default.highlightColor80).setOpacity(0.25).get()
              });
            }
          }
        }
        if (selectionMarker && zoomHor) {
          size = chartX - mouseDownX;
          selectionMarker.attr({
            width: Math.abs(size),
            x: (size > 0 ? 0 : size) + mouseDownX
          });
        }
        if (selectionMarker && zoomVert) {
          size = chartY - mouseDownY;
          selectionMarker.attr({
            height: Math.abs(size),
            y: (size > 0 ? 0 : size) + mouseDownY
          });
        }
        if (clickedInside && !selectionMarker && panningEnabled) {
          chart.pan(e2, chartOptions.panning);
        }
      }
    };
    Pointer2.prototype.dragStart = function(e2) {
      var chart = this.chart;
      chart.mouseIsDown = e2.type;
      chart.cancelClick = false;
      chart.mouseDownX = this.mouseDownX = e2.chartX;
      chart.mouseDownY = this.mouseDownY = e2.chartY;
    };
    Pointer2.prototype.drop = function(e2) {
      var pointer = this, chart = this.chart, hasPinched = this.hasPinched;
      if (this.selectionMarker) {
        var selectionData_1 = {
          originalEvent: e2,
          xAxis: [],
          yAxis: []
        }, selectionBox = this.selectionMarker, selectionLeft_1 = selectionBox.attr ? selectionBox.attr("x") : selectionBox.x, selectionTop_1 = selectionBox.attr ? selectionBox.attr("y") : selectionBox.y, selectionWidth_1 = selectionBox.attr ? selectionBox.attr("width") : selectionBox.width, selectionHeight_1 = selectionBox.attr ? selectionBox.attr("height") : selectionBox.height;
        var runZoom_1;
        if (this.hasDragged || hasPinched) {
          chart.axes.forEach(function(axis) {
            if (axis.zoomEnabled && defined14(axis.min) && (hasPinched || pointer[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[axis.coll]]) && isNumber15(selectionLeft_1) && isNumber15(selectionTop_1)) {
              var horiz = axis.horiz, minPixelPadding = e2.type === "touchend" ? axis.minPixelPadding : 0, selectionMin = axis.toValue((horiz ? selectionLeft_1 : selectionTop_1) + minPixelPadding), selectionMax = axis.toValue((horiz ? selectionLeft_1 + selectionWidth_1 : selectionTop_1 + selectionHeight_1) - minPixelPadding);
              selectionData_1[axis.coll].push({
                axis,
                // Min/max for reversed axes
                min: Math.min(selectionMin, selectionMax),
                max: Math.max(selectionMin, selectionMax)
              });
              runZoom_1 = true;
            }
          });
          if (runZoom_1) {
            fireEvent8(chart, "selection", selectionData_1, function(args) {
              chart.zoom(extend13(args, hasPinched ? { animation: false } : null));
            });
          }
        }
        if (isNumber15(chart.index)) {
          this.selectionMarker = this.selectionMarker.destroy();
        }
        if (hasPinched) {
          this.scaleGroups();
        }
      }
      if (chart && isNumber15(chart.index)) {
        css7(chart.container, { cursor: chart._cursor });
        chart.cancelClick = this.hasDragged > 10;
        chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
        this.pinchDown = [];
      }
    };
    Pointer2.prototype.findNearestKDPoint = function(series, shared, e2) {
      var chart = this.chart;
      var hoverPoint = chart.hoverPoint;
      var tooltip = chart.tooltip;
      if (hoverPoint && tooltip && tooltip.isStickyOnContact()) {
        return hoverPoint;
      }
      var closest;
      function sort(p1, p2) {
        var isCloserX = p1.distX - p2.distX, isCloser = p1.dist - p2.dist, isAbove = (p2.series.group && p2.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex);
        var result2;
        if (isCloserX !== 0 && shared) {
          result2 = isCloserX;
        } else if (isCloser !== 0) {
          result2 = isCloser;
        } else if (isAbove !== 0) {
          result2 = isAbove;
        } else {
          result2 = p1.series.index > p2.series.index ? -1 : 1;
        }
        return result2;
      }
      series.forEach(function(s) {
        var noSharedTooltip = s.noSharedTooltip && shared, compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf("y") < 0, point = s.searchPoint(e2, compareX);
        if (
          // Check that we actually found a point on the series.
          isObject6(point, true) && point.series && // Use the new point if it is closer.
          (!isObject6(closest, true) || sort(closest, point) > 0)
        ) {
          closest = point;
        }
      });
      return closest;
    };
    Pointer2.prototype.getChartCoordinatesFromPoint = function(point, inverted) {
      var series = point.series, xAxis = series.xAxis, yAxis = series.yAxis, shapeArgs = point.shapeArgs;
      if (xAxis && yAxis) {
        var x = pick19(point.clientX, point.plotX);
        var y = point.plotY || 0;
        if (point.isNode && shapeArgs && isNumber15(shapeArgs.x) && isNumber15(shapeArgs.y)) {
          x = shapeArgs.x;
          y = shapeArgs.y;
        }
        return inverted ? {
          chartX: yAxis.len + yAxis.pos - y,
          chartY: xAxis.len + xAxis.pos - x
        } : {
          chartX: x + xAxis.pos,
          chartY: y + yAxis.pos
        };
      }
      if (shapeArgs && shapeArgs.x && shapeArgs.y) {
        return {
          chartX: shapeArgs.x,
          chartY: shapeArgs.y
        };
      }
    };
    Pointer2.prototype.getChartPosition = function() {
      if (this.chartPosition) {
        return this.chartPosition;
      }
      var container = this.chart.container;
      var pos = offset2(container);
      this.chartPosition = {
        left: pos.left,
        top: pos.top,
        scaleX: 1,
        scaleY: 1
      };
      var offsetWidth = container.offsetWidth;
      var offsetHeight = container.offsetHeight;
      if (offsetWidth > 2 && // #13342
      offsetHeight > 2) {
        this.chartPosition.scaleX = pos.width / offsetWidth;
        this.chartPosition.scaleY = pos.height / offsetHeight;
      }
      return this.chartPosition;
    };
    Pointer2.prototype.getCoordinates = function(e2) {
      var coordinates = {
        xAxis: [],
        yAxis: []
      };
      this.chart.axes.forEach(function(axis) {
        coordinates[axis.isXAxis ? "xAxis" : "yAxis"].push({
          axis,
          value: axis.toValue(e2[axis.horiz ? "chartX" : "chartY"])
        });
      });
      return coordinates;
    };
    Pointer2.prototype.getHoverData = function(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, e2) {
      var hoverPoints = [], useExisting = !!(isDirectTouch && existingHoverPoint), filter = function(s) {
        return s.visible && !(!shared && s.directTouch) && // #3821
        pick19(s.options.enableMouseTracking, true);
      };
      var hoverSeries = existingHoverSeries, searchSeries, eventArgs = {
        chartX: e2 ? e2.chartX : void 0,
        chartY: e2 ? e2.chartY : void 0,
        shared
      };
      fireEvent8(this, "beforeGetHoverData", eventArgs);
      var notSticky = hoverSeries && !hoverSeries.stickyTracking;
      searchSeries = notSticky ? (
        // Only search on hovered series if it has stickyTracking false
        [hoverSeries]
      ) : (
        // Filter what series to look in.
        series.filter(function(s) {
          return eventArgs.filter ? eventArgs.filter(s) : filter(s) && s.stickyTracking;
        })
      );
      var hoverPoint = useExisting || !e2 ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, e2);
      hoverSeries = hoverPoint && hoverPoint.series;
      if (hoverPoint) {
        if (shared && !hoverSeries.noSharedTooltip) {
          searchSeries = series.filter(function(s) {
            return eventArgs.filter ? eventArgs.filter(s) : filter(s) && !s.noSharedTooltip;
          });
          searchSeries.forEach(function(s) {
            var point = find2(s.points, function(p) {
              return p.x === hoverPoint.x && !p.isNull;
            });
            if (isObject6(point)) {
              if (s.chart.isBoosting) {
                point = s.getPoint(point);
              }
              hoverPoints.push(point);
            }
          });
        } else {
          hoverPoints.push(hoverPoint);
        }
      }
      eventArgs = { hoverPoint };
      fireEvent8(this, "afterGetHoverData", eventArgs);
      return {
        hoverPoint: eventArgs.hoverPoint,
        hoverSeries,
        hoverPoints
      };
    };
    Pointer2.prototype.getPointFromEvent = function(e2) {
      var target = e2.target, point;
      while (target && !point) {
        point = target.point;
        target = target.parentNode;
      }
      return point;
    };
    Pointer2.prototype.onTrackerMouseOut = function(e2) {
      var chart = this.chart;
      var relatedTarget = e2.relatedTarget || e2.toElement;
      var series = chart.hoverSeries;
      this.isDirectTouch = false;
      if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, "highcharts-tooltip") && (!this.inClass(relatedTarget, "highcharts-series-" + series.index) || // #2499, #4465, #5553
      !this.inClass(relatedTarget, "highcharts-tracker"))) {
        series.onMouseOut();
      }
    };
    Pointer2.prototype.inClass = function(element, className) {
      var elemClassName;
      while (element) {
        elemClassName = attr8(element, "class");
        if (elemClassName) {
          if (elemClassName.indexOf(className) !== -1) {
            return true;
          }
          if (elemClassName.indexOf("highcharts-container") !== -1) {
            return false;
          }
        }
        element = element.parentNode;
      }
    };
    Pointer2.prototype.init = function(chart, options) {
      this.options = options;
      this.chart = chart;
      this.runChartClick = Boolean(options.chart.events && options.chart.events.click);
      this.pinchDown = [];
      this.lastValidTouch = {};
      if (Tooltip_default) {
        chart.tooltip = new Tooltip_default(chart, options.tooltip);
        this.followTouchMove = pick19(options.tooltip.followTouchMove, true);
      }
      this.setDOMEvents();
    };
    Pointer2.prototype.normalize = function(e2, chartPosition) {
      var touches2 = e2.touches;
      var ePos = touches2 ? touches2.length ? touches2.item(0) : pick19(
        // #13534
        touches2.changedTouches,
        e2.changedTouches
      )[0] : e2;
      if (!chartPosition) {
        chartPosition = this.getChartPosition();
      }
      var chartX = ePos.pageX - chartPosition.left, chartY = ePos.pageY - chartPosition.top;
      chartX /= chartPosition.scaleX;
      chartY /= chartPosition.scaleY;
      return extend13(e2, {
        chartX: Math.round(chartX),
        chartY: Math.round(chartY)
      });
    };
    Pointer2.prototype.onContainerClick = function(e2) {
      var chart = this.chart;
      var hoverPoint = chart.hoverPoint;
      var pEvt = this.normalize(e2);
      var plotLeft = chart.plotLeft;
      var plotTop = chart.plotTop;
      if (!chart.cancelClick) {
        if (hoverPoint && this.inClass(pEvt.target, "highcharts-tracker")) {
          fireEvent8(hoverPoint.series, "click", extend13(pEvt, {
            point: hoverPoint
          }));
          if (chart.hoverPoint) {
            hoverPoint.firePointEvent("click", pEvt);
          }
        } else {
          extend13(pEvt, this.getCoordinates(pEvt));
          if (chart.isInsidePlot(pEvt.chartX - plotLeft, pEvt.chartY - plotTop, {
            visiblePlotOnly: true
          })) {
            fireEvent8(chart, "click", pEvt);
          }
        }
      }
    };
    Pointer2.prototype.onContainerMouseDown = function(e2) {
      var isPrimaryButton = ((e2.buttons || e2.button) & 1) === 1;
      e2 = this.normalize(e2);
      if (Globals_default.isFirefox && e2.button !== 0) {
        this.onContainerMouseMove(e2);
      }
      if (typeof e2.button === "undefined" || isPrimaryButton) {
        this.zoomOption(e2);
        if (isPrimaryButton && e2.preventDefault) {
          e2.preventDefault();
        }
        this.dragStart(e2);
      }
    };
    Pointer2.prototype.onContainerMouseLeave = function(e2) {
      var chart = charts3[pick19(Pointer2.hoverChartIndex, -1)];
      var tooltip = this.chart.tooltip;
      if (tooltip && tooltip.shouldStickOnContact() && this.inClass(e2.relatedTarget, "highcharts-tooltip-container")) {
        return;
      }
      e2 = this.normalize(e2);
      if (chart && (e2.relatedTarget || e2.toElement)) {
        chart.pointer.reset();
        chart.pointer.chartPosition = void 0;
      }
      if (
        // #11635, Firefox wheel scroll does not fire out events consistently
        tooltip && !tooltip.isHidden
      ) {
        this.reset();
      }
    };
    Pointer2.prototype.onContainerMouseEnter = function(e2) {
      delete this.chartPosition;
    };
    Pointer2.prototype.onContainerMouseMove = function(e2) {
      var chart = this.chart;
      var pEvt = this.normalize(e2);
      this.setHoverChartIndex();
      if (!pEvt.preventDefault) {
        pEvt.returnValue = false;
      }
      if (chart.mouseIsDown === "mousedown" || this.touchSelect(pEvt)) {
        this.drag(pEvt);
      }
      if (!chart.openMenu && (this.inClass(pEvt.target, "highcharts-tracker") || chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
        visiblePlotOnly: true
      }))) {
        if (this.inClass(pEvt.target, "highcharts-no-tooltip")) {
          this.reset(false, 0);
        } else {
          this.runPointActions(pEvt);
        }
      }
    };
    Pointer2.prototype.onDocumentTouchEnd = function(e2) {
      var hoverChart = charts3[pick19(Pointer2.hoverChartIndex, -1)];
      if (hoverChart) {
        hoverChart.pointer.drop(e2);
      }
    };
    Pointer2.prototype.onContainerTouchMove = function(e2) {
      if (this.touchSelect(e2)) {
        this.onContainerMouseMove(e2);
      } else {
        this.touch(e2);
      }
    };
    Pointer2.prototype.onContainerTouchStart = function(e2) {
      if (this.touchSelect(e2)) {
        this.onContainerMouseDown(e2);
      } else {
        this.zoomOption(e2);
        this.touch(e2, true);
      }
    };
    Pointer2.prototype.onDocumentMouseMove = function(e2) {
      var chart = this.chart;
      var chartPosition = this.chartPosition;
      var pEvt = this.normalize(e2, chartPosition);
      var tooltip = chart.tooltip;
      if (chartPosition && (!tooltip || !tooltip.isStickyOnContact()) && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
        visiblePlotOnly: true
      }) && !this.inClass(pEvt.target, "highcharts-tracker")) {
        this.reset();
      }
    };
    Pointer2.prototype.onDocumentMouseUp = function(e2) {
      var chart = charts3[pick19(Pointer2.hoverChartIndex, -1)];
      if (chart) {
        chart.pointer.drop(e2);
      }
    };
    Pointer2.prototype.pinch = function(e2) {
      var self = this, chart = self.chart, pinchDown = self.pinchDown, touches2 = e2.touches || [], touchesLength = touches2.length, lastValidTouch = self.lastValidTouch, hasZoom = self.hasZoom, transform = {}, fireClickEvent = touchesLength === 1 && (self.inClass(e2.target, "highcharts-tracker") && chart.runTrackerClick || self.runChartClick), clip = {};
      var selectionMarker = self.selectionMarker;
      if (touchesLength > 1) {
        self.initiated = true;
      } else if (touchesLength === 1 && this.followTouchMove) {
        self.initiated = false;
      }
      if (hasZoom && self.initiated && !fireClickEvent && e2.cancelable !== false) {
        e2.preventDefault();
      }
      [].map.call(touches2, function(e3) {
        return self.normalize(e3);
      });
      if (e2.type === "touchstart") {
        [].forEach.call(touches2, function(e3, i) {
          pinchDown[i] = { chartX: e3.chartX, chartY: e3.chartY };
        });
        lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
        lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];
        chart.axes.forEach(function(axis) {
          if (axis.zoomEnabled) {
            var bounds = chart.bounds[axis.horiz ? "h" : "v"], minPixelPadding = axis.minPixelPadding, min = axis.toPixels(Math.min(pick19(axis.options.min, axis.dataMin), axis.dataMin)), max = axis.toPixels(Math.max(pick19(axis.options.max, axis.dataMax), axis.dataMax)), absMin = Math.min(min, max), absMax = Math.max(min, max);
            bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
            bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);
          }
        });
        self.res = true;
      } else if (self.followTouchMove && touchesLength === 1) {
        this.runPointActions(self.normalize(e2));
      } else if (pinchDown.length) {
        if (!selectionMarker) {
          self.selectionMarker = selectionMarker = extend13({
            destroy: noop3,
            touch: true
          }, chart.plotBox);
        }
        self.pinchTranslate(pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch);
        self.hasPinched = hasZoom;
        self.scaleGroups(transform, clip);
        if (self.res) {
          self.res = false;
          this.reset(false, 0);
        }
      }
    };
    Pointer2.prototype.pinchTranslate = function(pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch) {
      if (this.zoomHor) {
        this.pinchTranslateDirection(true, pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch);
      }
      if (this.zoomVert) {
        this.pinchTranslateDirection(false, pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch);
      }
    };
    Pointer2.prototype.pinchTranslateDirection = function(horiz, pinchDown, touches2, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
      var chart = this.chart, xy = horiz ? "x" : "y", XY = horiz ? "X" : "Y", sChartXY = "chart" + XY, wh = horiz ? "width" : "height", plotLeftTop = chart["plot" + (horiz ? "Left" : "Top")], inverted = chart.inverted, bounds = chart.bounds[horiz ? "h" : "v"], singleTouch = pinchDown.length === 1, touch0Start = pinchDown[0][sChartXY], touch1Start = !singleTouch && pinchDown[1][sChartXY], setScale = function() {
        if (typeof touch1Now === "number" && Math.abs(touch0Start - touch1Start) > 20) {
          scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);
        }
        clipXY = (plotLeftTop - touch0Now) / scale + touch0Start;
        selectionWH = chart["plot" + (horiz ? "Width" : "Height")] / scale;
      };
      var selectionWH, selectionXY, clipXY, scale = forcedScale || 1, touch0Now = touches2[0][sChartXY], touch1Now = !singleTouch && touches2[1][sChartXY], outOfBounds;
      setScale();
      selectionXY = clipXY;
      if (selectionXY < bounds.min) {
        selectionXY = bounds.min;
        outOfBounds = true;
      } else if (selectionXY + selectionWH > bounds.max) {
        selectionXY = bounds.max - selectionWH;
        outOfBounds = true;
      }
      if (outOfBounds) {
        touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
        if (typeof touch1Now === "number") {
          touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
        }
        setScale();
      } else {
        lastValidTouch[xy] = [touch0Now, touch1Now];
      }
      if (!inverted) {
        clip[xy] = clipXY - plotLeftTop;
        clip[wh] = selectionWH;
      }
      var scaleKey = inverted ? horiz ? "scaleY" : "scaleX" : "scale" + XY;
      var transformScale = inverted ? 1 / scale : scale;
      selectionMarker[wh] = selectionWH;
      selectionMarker[xy] = selectionXY;
      transform[scaleKey] = scale;
      transform["translate" + XY] = transformScale * plotLeftTop + (touch0Now - transformScale * touch0Start);
    };
    Pointer2.prototype.reset = function(allowMove, delay) {
      var pointer = this, chart = pointer.chart, hoverSeries = chart.hoverSeries, hoverPoint = chart.hoverPoint, hoverPoints = chart.hoverPoints, tooltip = chart.tooltip, tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
      if (allowMove && tooltipPoints) {
        splat6(tooltipPoints).forEach(function(point) {
          if (point.series.isCartesian && typeof point.plotX === "undefined") {
            allowMove = false;
          }
        });
      }
      if (allowMove) {
        if (tooltip && tooltipPoints && splat6(tooltipPoints).length) {
          tooltip.refresh(tooltipPoints);
          if (tooltip.shared && hoverPoints) {
            hoverPoints.forEach(function(point) {
              point.setState(point.state, true);
              if (point.series.isCartesian) {
                if (point.series.xAxis.crosshair) {
                  point.series.xAxis.drawCrosshair(null, point);
                }
                if (point.series.yAxis.crosshair) {
                  point.series.yAxis.drawCrosshair(null, point);
                }
              }
            });
          } else if (hoverPoint) {
            hoverPoint.setState(hoverPoint.state, true);
            chart.axes.forEach(function(axis) {
              if (axis.crosshair && hoverPoint.series[axis.coll] === axis) {
                axis.drawCrosshair(null, hoverPoint);
              }
            });
          }
        }
      } else {
        if (hoverPoint) {
          hoverPoint.onMouseOut();
        }
        if (hoverPoints) {
          hoverPoints.forEach(function(point) {
            point.setState();
          });
        }
        if (hoverSeries) {
          hoverSeries.onMouseOut();
        }
        if (tooltip) {
          tooltip.hide(delay);
        }
        if (pointer.unDocMouseMove) {
          pointer.unDocMouseMove = pointer.unDocMouseMove();
        }
        chart.axes.forEach(function(axis) {
          axis.hideCrosshair();
        });
        pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;
      }
    };
    Pointer2.prototype.runPointActions = function(e2, p) {
      var pointer = this, chart = pointer.chart, series = chart.series, tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : void 0, shared = tooltip ? tooltip.shared : false;
      var hoverPoint = p || chart.hoverPoint, hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries;
      var isDirectTouch = (!e2 || e2.type !== "touchmove") && (!!p || hoverSeries && hoverSeries.directTouch && pointer.isDirectTouch), hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e2);
      hoverPoint = hoverData.hoverPoint;
      hoverSeries = hoverData.hoverSeries;
      var points = hoverData.hoverPoints, followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer && !hoverSeries.tooltipOptions.split, useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;
      if (hoverPoint && // !(hoverSeries && hoverSeries.directTouch) &&
      (hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {
        (chart.hoverPoints || []).forEach(function(p2) {
          if (points.indexOf(p2) === -1) {
            p2.setState();
          }
        });
        if (chart.hoverSeries !== hoverSeries) {
          hoverSeries.onMouseOver();
        }
        pointer.applyInactiveState(points);
        (points || []).forEach(function(p2) {
          p2.setState("hover");
        });
        if (chart.hoverPoint) {
          chart.hoverPoint.firePointEvent("mouseOut");
        }
        if (!hoverPoint.series) {
          return;
        }
        chart.hoverPoints = points;
        chart.hoverPoint = hoverPoint;
        hoverPoint.firePointEvent("mouseOver");
        if (tooltip) {
          tooltip.refresh(useSharedTooltip ? points : hoverPoint, e2);
        }
      } else if (followPointer && tooltip && !tooltip.isHidden) {
        var anchor = tooltip.getAnchor([{}], e2);
        if (chart.isInsidePlot(anchor[0], anchor[1], {
          visiblePlotOnly: true
        })) {
          tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
        }
      }
      if (!pointer.unDocMouseMove) {
        pointer.unDocMouseMove = addEvent9(chart.container.ownerDocument, "mousemove", function(e3) {
          var chart2 = charts3[Pointer2.hoverChartIndex];
          if (chart2) {
            chart2.pointer.onDocumentMouseMove(e3);
          }
        });
        pointer.eventsToUnbind.push(pointer.unDocMouseMove);
      }
      chart.axes.forEach(function drawAxisCrosshair(axis) {
        var snap = pick19((axis.crosshair || {}).snap, true);
        var point;
        if (snap) {
          point = chart.hoverPoint;
          if (!point || point.series[axis.coll] !== axis) {
            point = find2(points, function(p2) {
              return p2.series[axis.coll] === axis;
            });
          }
        }
        if (point || !snap) {
          axis.drawCrosshair(e2, point);
        } else {
          axis.hideCrosshair();
        }
      });
    };
    Pointer2.prototype.scaleGroups = function(attribs, clip) {
      var chart = this.chart;
      chart.series.forEach(function(series) {
        var seriesAttribs = attribs || series.getPlotBox();
        if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
          series.group.attr(seriesAttribs);
          if (series.markerGroup) {
            series.markerGroup.attr(seriesAttribs);
            series.markerGroup.clip(clip ? chart.clipRect : null);
          }
          if (series.dataLabelsGroup) {
            series.dataLabelsGroup.attr(seriesAttribs);
          }
        }
      });
      chart.clipRect.attr(clip || chart.clipBox);
    };
    Pointer2.prototype.setDOMEvents = function() {
      var _this = this;
      var container = this.chart.container, ownerDoc = container.ownerDocument;
      container.onmousedown = this.onContainerMouseDown.bind(this);
      container.onmousemove = this.onContainerMouseMove.bind(this);
      container.onclick = this.onContainerClick.bind(this);
      this.eventsToUnbind.push(addEvent9(container, "mouseenter", this.onContainerMouseEnter.bind(this)));
      this.eventsToUnbind.push(addEvent9(container, "mouseleave", this.onContainerMouseLeave.bind(this)));
      if (!Pointer2.unbindDocumentMouseUp) {
        Pointer2.unbindDocumentMouseUp = addEvent9(ownerDoc, "mouseup", this.onDocumentMouseUp.bind(this));
      }
      var parent = this.chart.renderTo.parentElement;
      while (parent && parent.tagName !== "BODY") {
        this.eventsToUnbind.push(addEvent9(parent, "scroll", function() {
          delete _this.chartPosition;
        }));
        parent = parent.parentElement;
      }
      if (Globals_default.hasTouch) {
        this.eventsToUnbind.push(addEvent9(container, "touchstart", this.onContainerTouchStart.bind(this), { passive: false }));
        this.eventsToUnbind.push(addEvent9(container, "touchmove", this.onContainerTouchMove.bind(this), { passive: false }));
        if (!Pointer2.unbindDocumentTouchEnd) {
          Pointer2.unbindDocumentTouchEnd = addEvent9(ownerDoc, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false });
        }
      }
    };
    Pointer2.prototype.setHoverChartIndex = function() {
      var chart = this.chart;
      var hoverChart = Globals_default.charts[pick19(Pointer2.hoverChartIndex, -1)];
      if (hoverChart && hoverChart !== chart) {
        hoverChart.pointer.onContainerMouseLeave({ relatedTarget: true });
      }
      if (!hoverChart || !hoverChart.mouseIsDown) {
        Pointer2.hoverChartIndex = chart.index;
      }
    };
    Pointer2.prototype.touch = function(e2, start) {
      var chart = this.chart;
      var hasMoved, pinchDown, isInside;
      this.setHoverChartIndex();
      if (e2.touches.length === 1) {
        e2 = this.normalize(e2);
        isInside = chart.isInsidePlot(e2.chartX - chart.plotLeft, e2.chartY - chart.plotTop, {
          visiblePlotOnly: true
        });
        if (isInside && !chart.openMenu) {
          if (start) {
            this.runPointActions(e2);
          }
          if (e2.type === "touchmove") {
            pinchDown = this.pinchDown;
            hasMoved = pinchDown[0] ? Math.sqrt(
              // #5266
              Math.pow(pinchDown[0].chartX - e2.chartX, 2) + Math.pow(pinchDown[0].chartY - e2.chartY, 2)
            ) >= 4 : false;
          }
          if (pick19(hasMoved, true)) {
            this.pinch(e2);
          }
        } else if (start) {
          this.reset();
        }
      } else if (e2.touches.length === 2) {
        this.pinch(e2);
      }
    };
    Pointer2.prototype.touchSelect = function(e2) {
      return Boolean(this.chart.options.chart.zoomBySingleTouch && e2.touches && e2.touches.length === 1);
    };
    Pointer2.prototype.zoomOption = function(e2) {
      var chart = this.chart, options = chart.options.chart, inverted = chart.inverted;
      var zoomType = options.zoomType || "", zoomX, zoomY;
      if (/touch/.test(e2.type)) {
        zoomType = pick19(options.pinchType, zoomType);
      }
      this.zoomX = zoomX = /x/.test(zoomType);
      this.zoomY = zoomY = /y/.test(zoomType);
      this.zoomHor = zoomX && !inverted || zoomY && inverted;
      this.zoomVert = zoomY && !inverted || zoomX && inverted;
      this.hasZoom = zoomX || zoomY;
    };
    return Pointer2;
  }()
);
var Pointer_default = Pointer;

// node_modules/highcharts/es-modules/Core/MSPointer.js
var __extends4 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var charts4 = Globals_default.charts;
var doc6 = Globals_default.doc;
var noop4 = Globals_default.noop;
var win8 = Globals_default.win;
var addEvent10 = Utilities_default.addEvent;
var css8 = Utilities_default.css;
var objectEach14 = Utilities_default.objectEach;
var removeEvent6 = Utilities_default.removeEvent;
var touches = {};
var hasPointerEvent = !!win8.PointerEvent;
function getWebkitTouches() {
  var fake = [];
  fake.item = function(i) {
    return this[i];
  };
  objectEach14(touches, function(touch) {
    fake.push({
      pageX: touch.pageX,
      pageY: touch.pageY,
      target: touch.target
    });
  });
  return fake;
}
function translateMSPointer(e2, method, wktype, func) {
  var chart = charts4[Pointer_default.hoverChartIndex || NaN];
  if ((e2.pointerType === "touch" || e2.pointerType === e2.MSPOINTER_TYPE_TOUCH) && chart) {
    var p = chart.pointer;
    func(e2);
    p[method]({
      type: wktype,
      target: e2.currentTarget,
      preventDefault: noop4,
      touches: getWebkitTouches()
    });
  }
}
var MSPointer = (
  /** @class */
  function(_super) {
    __extends4(MSPointer2, _super);
    function MSPointer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MSPointer2.isRequired = function() {
      return !!(!Globals_default.hasTouch && (win8.PointerEvent || win8.MSPointerEvent));
    };
    MSPointer2.prototype.batchMSEvents = function(fn) {
      fn(this.chart.container, hasPointerEvent ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
      fn(this.chart.container, hasPointerEvent ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
      fn(doc6, hasPointerEvent ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
    };
    MSPointer2.prototype.destroy = function() {
      this.batchMSEvents(removeEvent6);
      _super.prototype.destroy.call(this);
    };
    MSPointer2.prototype.init = function(chart, options) {
      _super.prototype.init.call(this, chart, options);
      if (this.hasZoom) {
        css8(chart.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      }
    };
    MSPointer2.prototype.onContainerPointerDown = function(e2) {
      translateMSPointer(e2, "onContainerTouchStart", "touchstart", function(e3) {
        touches[e3.pointerId] = {
          pageX: e3.pageX,
          pageY: e3.pageY,
          target: e3.currentTarget
        };
      });
    };
    MSPointer2.prototype.onContainerPointerMove = function(e2) {
      translateMSPointer(e2, "onContainerTouchMove", "touchmove", function(e3) {
        touches[e3.pointerId] = { pageX: e3.pageX, pageY: e3.pageY };
        if (!touches[e3.pointerId].target) {
          touches[e3.pointerId].target = e3.currentTarget;
        }
      });
    };
    MSPointer2.prototype.onDocumentPointerUp = function(e2) {
      translateMSPointer(e2, "onDocumentTouchEnd", "touchend", function(e3) {
        delete touches[e3.pointerId];
      });
    };
    MSPointer2.prototype.setDOMEvents = function() {
      _super.prototype.setDOMEvents.call(this);
      if (this.hasZoom || this.followTouchMove) {
        this.batchMSEvents(addEvent10);
      }
    };
    return MSPointer2;
  }(Pointer_default)
);
var MSPointer_default = MSPointer;

// node_modules/highcharts/es-modules/Core/Legend/Legend.js
var animObject5 = AnimationUtilities_default.animObject;
var setAnimation2 = AnimationUtilities_default.setAnimation;
var format4 = FormatUtilities_default.format;
var isFirefox3 = Globals_default.isFirefox;
var marginNames = Globals_default.marginNames;
var win9 = Globals_default.win;
var distribute2 = RendererUtilities_default.distribute;
var addEvent11 = Utilities_default.addEvent;
var createElement6 = Utilities_default.createElement;
var css9 = Utilities_default.css;
var defined15 = Utilities_default.defined;
var discardElement4 = Utilities_default.discardElement;
var find3 = Utilities_default.find;
var fireEvent9 = Utilities_default.fireEvent;
var isNumber16 = Utilities_default.isNumber;
var merge14 = Utilities_default.merge;
var pick20 = Utilities_default.pick;
var relativeLength3 = Utilities_default.relativeLength;
var stableSort3 = Utilities_default.stableSort;
var syncTimeout6 = Utilities_default.syncTimeout;
var wrap2 = Utilities_default.wrap;
var Legend = (
  /** @class */
  function() {
    function Legend2(chart, options) {
      this.allItems = [];
      this.box = void 0;
      this.contentGroup = void 0;
      this.display = false;
      this.group = void 0;
      this.initialItemY = 0;
      this.itemHeight = 0;
      this.itemMarginBottom = 0;
      this.itemMarginTop = 0;
      this.itemX = 0;
      this.itemY = 0;
      this.lastItemY = 0;
      this.lastLineHeight = 0;
      this.legendHeight = 0;
      this.legendWidth = 0;
      this.maxItemWidth = 0;
      this.maxLegendWidth = 0;
      this.offsetWidth = 0;
      this.options = {};
      this.padding = 0;
      this.pages = [];
      this.proximate = false;
      this.scrollGroup = void 0;
      this.symbolHeight = 0;
      this.symbolWidth = 0;
      this.titleHeight = 0;
      this.totalItemWidth = 0;
      this.widthOption = 0;
      this.chart = chart;
      this.init(chart, options);
    }
    Legend2.prototype.init = function(chart, options) {
      this.chart = chart;
      this.setOptions(options);
      if (options.enabled) {
        this.render();
        addEvent11(this.chart, "endResize", function() {
          this.legend.positionCheckboxes();
        });
        if (this.proximate) {
          this.unchartrender = addEvent11(this.chart, "render", function() {
            this.legend.proximatePositions();
            this.legend.positionItems();
          });
        } else if (this.unchartrender) {
          this.unchartrender();
        }
      }
    };
    Legend2.prototype.setOptions = function(options) {
      var padding = pick20(options.padding, 8);
      this.options = options;
      if (!this.chart.styledMode) {
        this.itemStyle = options.itemStyle;
        this.itemHiddenStyle = merge14(this.itemStyle, options.itemHiddenStyle);
      }
      this.itemMarginTop = options.itemMarginTop || 0;
      this.itemMarginBottom = options.itemMarginBottom || 0;
      this.padding = padding;
      this.initialItemY = padding - 5;
      this.symbolWidth = pick20(options.symbolWidth, 16);
      this.pages = [];
      this.proximate = options.layout === "proximate" && !this.chart.inverted;
      this.baseline = void 0;
    };
    Legend2.prototype.update = function(options, redraw) {
      var chart = this.chart;
      this.setOptions(merge14(true, this.options, options));
      this.destroy();
      chart.isDirtyLegend = chart.isDirtyBox = true;
      if (pick20(redraw, true)) {
        chart.redraw();
      }
      fireEvent9(this, "afterUpdate");
    };
    Legend2.prototype.colorizeItem = function(item, visible) {
      item.legendGroup[visible ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
      if (!this.chart.styledMode) {
        var legend = this, options = legend.options, legendItem = item.legendItem, legendLine = item.legendLine, legendSymbol = item.legendSymbol, hiddenColor = legend.itemHiddenStyle.color, textColor = visible ? options.itemStyle.color : hiddenColor, symbolColor = visible ? item.color || hiddenColor : hiddenColor, markerOptions = item.options && item.options.marker;
        var symbolAttr = { fill: symbolColor };
        if (legendItem) {
          legendItem.css({
            fill: textColor,
            color: textColor
            // #1553, oldIE
          });
        }
        if (legendLine) {
          legendLine.attr({ stroke: symbolColor });
        }
        if (legendSymbol) {
          if (markerOptions && legendSymbol.isMarker) {
            symbolAttr = item.pointAttribs();
            if (!visible) {
              symbolAttr.stroke = symbolAttr.fill = hiddenColor;
            }
          }
          legendSymbol.attr(symbolAttr);
        }
      }
      fireEvent9(this, "afterColorizeItem", { item, visible });
    };
    Legend2.prototype.positionItems = function() {
      this.allItems.forEach(this.positionItem, this);
      if (!this.chart.isResizing) {
        this.positionCheckboxes();
      }
    };
    Legend2.prototype.positionItem = function(item) {
      var _this = this;
      var legend = this, options = legend.options, symbolPadding = options.symbolPadding, ltr = !options.rtl, legendItemPos = item._legendItemPos, itemX = legendItemPos[0], itemY = legendItemPos[1], checkbox = item.checkbox, legendGroup = item.legendGroup;
      if (legendGroup && legendGroup.element) {
        var attribs = {
          translateX: ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
          translateY: itemY
        };
        var complete = function() {
          fireEvent9(_this, "afterPositionItem", { item });
        };
        if (defined15(legendGroup.translateY)) {
          legendGroup.animate(attribs, void 0, complete);
        } else {
          legendGroup.attr(attribs);
          complete();
        }
      }
      if (checkbox) {
        checkbox.x = itemX;
        checkbox.y = itemY;
      }
    };
    Legend2.prototype.destroyItem = function(item) {
      var checkbox = item.checkbox;
      ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function(key) {
        if (item[key]) {
          item[key] = item[key].destroy();
        }
      });
      if (checkbox) {
        discardElement4(item.checkbox);
      }
    };
    Legend2.prototype.destroy = function() {
      function destroyItems(key) {
        if (this[key]) {
          this[key] = this[key].destroy();
        }
      }
      this.getAllItems().forEach(function(item) {
        ["legendItem", "legendGroup"].forEach(destroyItems, item);
      });
      [
        "clipRect",
        "up",
        "down",
        "pager",
        "nav",
        "box",
        "title",
        "group"
      ].forEach(destroyItems, this);
      this.display = null;
    };
    Legend2.prototype.positionCheckboxes = function() {
      var alignAttr = this.group && this.group.alignAttr, clipHeight = this.clipHeight || this.legendHeight, titleHeight = this.titleHeight;
      var translateY;
      if (alignAttr) {
        translateY = alignAttr.translateY;
        this.allItems.forEach(function(item) {
          var checkbox = item.checkbox;
          var top;
          if (checkbox) {
            top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;
            css9(checkbox, {
              left: alignAttr.translateX + item.checkboxOffset + checkbox.x - 20 + "px",
              top: top + "px",
              display: this.proximate || top > translateY - 6 && top < translateY + clipHeight - 6 ? "" : "none"
            });
          }
        }, this);
      }
    };
    Legend2.prototype.renderTitle = function() {
      var options = this.options, padding = this.padding, titleOptions = options.title;
      var bBox, titleHeight = 0;
      if (titleOptions.text) {
        if (!this.title) {
          this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, options.useHTML, null, "legend-title").attr({ zIndex: 1 });
          if (!this.chart.styledMode) {
            this.title.css(titleOptions.style);
          }
          this.title.add(this.group);
        }
        if (!titleOptions.width) {
          this.title.css({
            width: this.maxLegendWidth + "px"
          });
        }
        bBox = this.title.getBBox();
        titleHeight = bBox.height;
        this.offsetWidth = bBox.width;
        this.contentGroup.attr({ translateY: titleHeight });
      }
      this.titleHeight = titleHeight;
    };
    Legend2.prototype.setText = function(item) {
      var options = this.options;
      item.legendItem.attr({
        text: options.labelFormat ? format4(options.labelFormat, item, this.chart) : options.labelFormatter.call(item)
      });
    };
    Legend2.prototype.renderItem = function(item) {
      var legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, horizontal = options.layout === "horizontal", symbolWidth = legend.symbolWidth, symbolPadding = options.symbolPadding || 0, itemStyle = legend.itemStyle, itemHiddenStyle = legend.itemHiddenStyle, itemDistance = horizontal ? pick20(options.itemDistance, 20) : 0, ltr = !options.rtl, isSeries = !item.series, series = !isSeries && item.series.drawLegendSymbol ? item.series : item, seriesOptions = series.options, showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox, useHTML = options.useHTML, itemClassName = item.options.className;
      var li = item.legendItem, itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
      if (!li) {
        item.legendGroup = renderer.g("legend-item").addClass("highcharts-" + series.type + "-series highcharts-color-" + item.colorIndex + (itemClassName ? " " + itemClassName : "") + (isSeries ? " highcharts-series-" + item.index : "")).attr({ zIndex: 1 }).add(legend.scrollGroup);
        item.legendItem = li = renderer.text("", ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML);
        if (!chart.styledMode) {
          li.css(merge14(item.visible ? itemStyle : itemHiddenStyle));
        }
        li.attr({
          align: ltr ? "left" : "right",
          zIndex: 2
        }).add(item.legendGroup);
        if (!legend.baseline) {
          legend.fontMetrics = renderer.fontMetrics(chart.styledMode ? 12 : itemStyle.fontSize, li);
          legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;
          li.attr("y", legend.baseline);
          legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
          if (options.squareSymbol) {
            legend.symbolWidth = pick20(options.symbolWidth, Math.max(legend.symbolHeight, 16));
            itemExtraWidth = legend.symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
            if (ltr) {
              li.attr("x", legend.symbolWidth + symbolPadding);
            }
          }
        }
        series.drawLegendSymbol(legend, item);
        if (legend.setItemEvents) {
          legend.setItemEvents(item, li, useHTML);
        }
      }
      if (showCheckbox && !item.checkbox && legend.createCheckboxForItem) {
        legend.createCheckboxForItem(item);
      }
      legend.colorizeItem(item, item.visible);
      if (chart.styledMode || !itemStyle.width) {
        li.css({
          width: (options.itemWidth || legend.widthOption || chart.spacingBox.width) - itemExtraWidth + "px"
        });
      }
      legend.setText(item);
      var bBox = li.getBBox();
      item.itemWidth = item.checkboxOffset = options.itemWidth || item.legendItemWidth || bBox.width + itemExtraWidth;
      legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);
      legend.totalItemWidth += item.itemWidth;
      legend.itemHeight = item.itemHeight = Math.round(item.legendItemHeight || bBox.height || legend.symbolHeight);
    };
    Legend2.prototype.layoutItem = function(item) {
      var options = this.options, padding = this.padding, horizontal = options.layout === "horizontal", itemHeight = item.itemHeight, itemMarginBottom = this.itemMarginBottom, itemMarginTop = this.itemMarginTop, itemDistance = horizontal ? pick20(options.itemDistance, 20) : 0, maxLegendWidth = this.maxLegendWidth, itemWidth = options.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item.itemWidth;
      if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {
        this.itemX = padding;
        if (this.lastLineHeight) {
          this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;
        }
        this.lastLineHeight = 0;
      }
      this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;
      this.lastLineHeight = Math.max(
        // #915
        itemHeight,
        this.lastLineHeight
      );
      item._legendItemPos = [this.itemX, this.itemY];
      if (horizontal) {
        this.itemX += itemWidth;
      } else {
        this.itemY += itemMarginTop + itemHeight + itemMarginBottom;
        this.lastLineHeight = itemHeight;
      }
      this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ? (
        // decrease by itemDistance only when no checkbox #4853
        0
      ) : itemDistance) : itemWidth) + padding, this.offsetWidth);
    };
    Legend2.prototype.getAllItems = function() {
      var allItems = [];
      this.chart.series.forEach(function(series) {
        var seriesOptions = series && series.options;
        if (series && pick20(seriesOptions.showInLegend, !defined15(seriesOptions.linkedTo) ? void 0 : false, true)) {
          allItems = allItems.concat(series.legendItems || (seriesOptions.legendType === "point" ? series.data : series));
        }
      });
      fireEvent9(this, "afterGetAllItems", { allItems });
      return allItems;
    };
    Legend2.prototype.getAlignment = function() {
      var options = this.options;
      if (this.proximate) {
        return options.align.charAt(0) + "tv";
      }
      return options.floating ? "" : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);
    };
    Legend2.prototype.adjustMargins = function(margin, spacing) {
      var chart = this.chart, options = this.options, alignment = this.getAlignment();
      if (alignment) {
        [
          /(lth|ct|rth)/,
          /(rtv|rm|rbv)/,
          /(rbh|cb|lbh)/,
          /(lbv|lm|ltv)/
        ].forEach(function(alignments, side) {
          if (alignments.test(alignment) && !defined15(margin[side])) {
            chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][side] * options[side % 2 ? "x" : "y"] + pick20(options.margin, 12) + spacing[side] + (chart.titleOffset[side] || 0));
          }
        });
      }
    };
    Legend2.prototype.proximatePositions = function() {
      var chart = this.chart, boxes = [], alignLeft = this.options.align === "left";
      this.allItems.forEach(function(item) {
        var lastPoint, height, useFirstPoint = alignLeft, target, top;
        if (item.yAxis) {
          if (item.xAxis.options.reversed) {
            useFirstPoint = !useFirstPoint;
          }
          if (item.points) {
            lastPoint = find3(useFirstPoint ? item.points : item.points.slice(0).reverse(), function(item2) {
              return isNumber16(item2.plotY);
            });
          }
          height = this.itemMarginTop + item.legendItem.getBBox().height + this.itemMarginBottom;
          top = item.yAxis.top - chart.plotTop;
          if (item.visible) {
            target = lastPoint ? lastPoint.plotY : item.yAxis.height;
            target += top - 0.3 * height;
          } else {
            target = top + item.yAxis.height;
          }
          boxes.push({
            target,
            size: height,
            item
          });
        }
      }, this);
      distribute2(boxes, chart.plotHeight).forEach(function(box) {
        if (box.item._legendItemPos) {
          box.item._legendItemPos[1] = chart.plotTop - chart.spacing[0] + box.pos;
        }
      });
    };
    Legend2.prototype.render = function() {
      var legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, padding = legend.padding, allItems = legend.getAllItems();
      var display, legendWidth, legendHeight, legendGroup = legend.group, allowedWidth, box = legend.box;
      legend.itemX = padding;
      legend.itemY = legend.initialItemY;
      legend.offsetWidth = 0;
      legend.lastItemY = 0;
      legend.widthOption = relativeLength3(options.width, chart.spacingBox.width - padding);
      allowedWidth = chart.spacingBox.width - 2 * padding - options.x;
      if (["rm", "lm"].indexOf(legend.getAlignment().substring(0, 2)) > -1) {
        allowedWidth /= 2;
      }
      legend.maxLegendWidth = legend.widthOption || allowedWidth;
      if (!legendGroup) {
        legend.group = legendGroup = renderer.g("legend").addClass(options.className || "").attr({ zIndex: 7 }).add();
        legend.contentGroup = renderer.g().attr({ zIndex: 1 }).add(legendGroup);
        legend.scrollGroup = renderer.g().add(legend.contentGroup);
      }
      legend.renderTitle();
      stableSort3(allItems, function(a, b) {
        return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
      });
      if (options.reversed) {
        allItems.reverse();
      }
      legend.allItems = allItems;
      legend.display = display = !!allItems.length;
      legend.lastLineHeight = 0;
      legend.maxItemWidth = 0;
      legend.totalItemWidth = 0;
      legend.itemHeight = 0;
      allItems.forEach(legend.renderItem, legend);
      allItems.forEach(legend.layoutItem, legend);
      legendWidth = (legend.widthOption || legend.offsetWidth) + padding;
      legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
      legendHeight = legend.handleOverflow(legendHeight);
      legendHeight += padding;
      if (!box) {
        legend.box = box = renderer.rect().addClass("highcharts-legend-box").attr({
          r: options.borderRadius
        }).add(legendGroup);
        box.isNew = true;
      }
      if (!chart.styledMode) {
        box.attr({
          stroke: options.borderColor,
          "stroke-width": options.borderWidth || 0,
          fill: options.backgroundColor || "none"
        }).shadow(options.shadow);
      }
      if (legendWidth > 0 && legendHeight > 0) {
        box[box.isNew ? "attr" : "animate"](box.crisp.call({}, {
          x: 0,
          y: 0,
          width: legendWidth,
          height: legendHeight
        }, box.strokeWidth()));
        box.isNew = false;
      }
      box[display ? "show" : "hide"]();
      if (chart.styledMode && legendGroup.getStyle("display") === "none") {
        legendWidth = legendHeight = 0;
      }
      legend.legendWidth = legendWidth;
      legend.legendHeight = legendHeight;
      if (display) {
        legend.align();
      }
      if (!this.proximate) {
        this.positionItems();
      }
      fireEvent9(this, "afterRender");
    };
    Legend2.prototype.align = function(alignTo) {
      if (alignTo === void 0) {
        alignTo = this.chart.spacingBox;
      }
      var chart = this.chart, options = this.options;
      var y = alignTo.y;
      if (/(lth|ct|rth)/.test(this.getAlignment()) && chart.titleOffset[0] > 0) {
        y += chart.titleOffset[0];
      } else if (/(lbh|cb|rbh)/.test(this.getAlignment()) && chart.titleOffset[2] > 0) {
        y -= chart.titleOffset[2];
      }
      if (y !== alignTo.y) {
        alignTo = merge14(alignTo, { y });
      }
      this.group.align(merge14(options, {
        width: this.legendWidth,
        height: this.legendHeight,
        verticalAlign: this.proximate ? "top" : options.verticalAlign
      }), true, alignTo);
    };
    Legend2.prototype.handleOverflow = function(legendHeight) {
      var legend = this, chart = this.chart, renderer = chart.renderer, options = this.options, optionsY = options.y, alignTop = options.verticalAlign === "top", padding = this.padding, maxHeight = options.maxHeight, navOptions = options.navigation, animation = pick20(navOptions.animation, true), arrowSize = navOptions.arrowSize || 12, pages = this.pages, allItems = this.allItems, clipToHeight = function(height) {
        if (typeof height === "number") {
          clipRect.attr({
            height
          });
        } else if (clipRect) {
          legend.clipRect = clipRect.destroy();
          legend.contentGroup.clip();
        }
        if (legend.contentGroup.div) {
          legend.contentGroup.div.style.clip = height ? "rect(" + padding + "px,9999px," + (padding + height) + "px,0)" : "auto";
        }
      }, addTracker = function(key) {
        legend[key] = renderer.circle(0, 0, arrowSize * 1.3).translate(arrowSize / 2, arrowSize / 2).add(nav);
        if (!chart.styledMode) {
          legend[key].attr("fill", "rgba(0,0,0,0.0001)");
        }
        return legend[key];
      };
      var clipHeight, lastY, spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding, nav = this.nav, clipRect = this.clipRect;
      if (options.layout === "horizontal" && options.verticalAlign !== "middle" && !options.floating) {
        spaceHeight /= 2;
      }
      if (maxHeight) {
        spaceHeight = Math.min(spaceHeight, maxHeight);
      }
      pages.length = 0;
      if (legendHeight && spaceHeight > 0 && legendHeight > spaceHeight && navOptions.enabled !== false) {
        this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
        this.currentPage = pick20(this.currentPage, 1);
        this.fullHeight = legendHeight;
        allItems.forEach(function(item, i) {
          var y = item._legendItemPos[1], h = Math.round(item.legendItem.getBBox().height);
          var len = pages.length;
          if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {
            pages.push(lastY || y);
            len++;
          }
          item.pageIx = len - 1;
          if (lastY) {
            allItems[i - 1].pageIx = len - 1;
          }
          if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight && y !== lastY) {
            pages.push(y);
            item.pageIx = len;
          }
          if (y !== lastY) {
            lastY = y;
          }
        });
        if (!clipRect) {
          clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
          legend.contentGroup.clip(clipRect);
        }
        clipToHeight(clipHeight);
        if (!nav) {
          this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
          this.up = renderer.symbol("triangle", 0, 0, arrowSize, arrowSize).add(nav);
          addTracker("upTracker").on("click", function() {
            legend.scroll(-1, animation);
          });
          this.pager = renderer.text("", 15, 10).addClass("highcharts-legend-navigation");
          if (!chart.styledMode) {
            this.pager.css(navOptions.style);
          }
          this.pager.add(nav);
          this.down = renderer.symbol("triangle-down", 0, 0, arrowSize, arrowSize).add(nav);
          addTracker("downTracker").on("click", function() {
            legend.scroll(1, animation);
          });
        }
        legend.scroll(0);
        legendHeight = spaceHeight;
      } else if (nav) {
        clipToHeight();
        this.nav = nav.destroy();
        this.scrollGroup.attr({
          translateY: 1
        });
        this.clipHeight = 0;
      }
      return legendHeight;
    };
    Legend2.prototype.scroll = function(scrollBy, animation) {
      var _this = this;
      var chart = this.chart, pages = this.pages, pageCount = pages.length, clipHeight = this.clipHeight, navOptions = this.options.navigation, pager = this.pager, padding = this.padding;
      var currentPage = this.currentPage + scrollBy;
      if (currentPage > pageCount) {
        currentPage = pageCount;
      }
      if (currentPage > 0) {
        if (typeof animation !== "undefined") {
          setAnimation2(animation, chart);
        }
        this.nav.attr({
          translateX: padding,
          translateY: clipHeight + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        });
        [this.up, this.upTracker].forEach(function(elem) {
          elem.attr({
            "class": currentPage === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        });
        pager.attr({
          text: currentPage + "/" + pageCount
        });
        [this.down, this.downTracker].forEach(function(elem) {
          elem.attr({
            // adjust to text width
            x: 18 + this.pager.getBBox().width,
            "class": currentPage === pageCount ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }, this);
        if (!chart.styledMode) {
          this.up.attr({
            fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor
          });
          this.upTracker.css({
            cursor: currentPage === 1 ? "default" : "pointer"
          });
          this.down.attr({
            fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
          });
          this.downTracker.css({
            cursor: currentPage === pageCount ? "default" : "pointer"
          });
        }
        this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;
        this.scrollGroup.animate({
          translateY: this.scrollOffset
        });
        this.currentPage = currentPage;
        this.positionCheckboxes();
        var animOptions = animObject5(pick20(animation, chart.renderer.globalAnimation, true));
        syncTimeout6(function() {
          fireEvent9(_this, "afterScroll", { currentPage });
        }, animOptions.duration);
      }
    };
    Legend2.prototype.setItemEvents = function(item, legendItem, useHTML) {
      var legend = this, boxWrapper = legend.chart.renderer.boxWrapper, isPoint = item instanceof Point_default, activeClass = "highcharts-legend-" + (isPoint ? "point" : "series") + "-active", styledMode = legend.chart.styledMode, legendItems = useHTML ? [legendItem, item.legendSymbol] : [item.legendGroup];
      var setOtherItemsState = function(state) {
        legend.allItems.forEach(function(otherItem) {
          if (item !== otherItem) {
            [otherItem].concat(otherItem.linkedSeries || []).forEach(function(otherItem2) {
              otherItem2.setState(state, !isPoint);
            });
          }
        });
      };
      legendItems.forEach(function(element) {
        if (element) {
          element.on("mouseover", function() {
            if (item.visible) {
              setOtherItemsState("inactive");
            }
            item.setState("hover");
            if (item.visible) {
              boxWrapper.addClass(activeClass);
            }
            if (!styledMode) {
              legendItem.css(legend.options.itemHoverStyle);
            }
          }).on("mouseout", function() {
            if (!legend.chart.styledMode) {
              legendItem.css(merge14(item.visible ? legend.itemStyle : legend.itemHiddenStyle));
            }
            setOtherItemsState("");
            boxWrapper.removeClass(activeClass);
            item.setState();
          }).on("click", function(event) {
            var strLegendItemClick = "legendItemClick", fnLegendItemClick = function() {
              if (item.setVisible) {
                item.setVisible();
              }
              setOtherItemsState(item.visible ? "inactive" : "");
            };
            boxWrapper.removeClass(activeClass);
            event = {
              browserEvent: event
            };
            if (item.firePointEvent) {
              item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
            } else {
              fireEvent9(item, strLegendItemClick, event, fnLegendItemClick);
            }
          });
        }
      });
    };
    Legend2.prototype.createCheckboxForItem = function(item) {
      var legend = this;
      item.checkbox = createElement6("input", {
        type: "checkbox",
        className: "highcharts-legend-checkbox",
        checked: item.selected,
        defaultChecked: item.selected
        // required by IE7
      }, legend.options.itemCheckboxStyle, legend.chart.container);
      addEvent11(item.checkbox, "click", function(event) {
        var target = event.target;
        fireEvent9(item.series || item, "checkboxClick", {
          checked: target.checked,
          item
        }, function() {
          item.select();
        });
      });
    };
    return Legend2;
  }()
);
if (/Trident\/7\.0/.test(win9.navigator && win9.navigator.userAgent) || isFirefox3) {
  wrap2(Legend.prototype, "positionItem", function(proceed, item) {
    var legend = this, runPositionItem = function() {
      if (item._legendItemPos) {
        proceed.call(legend, item);
      }
    };
    runPositionItem();
    if (!legend.bubbleLegend) {
      setTimeout(runPositionItem);
    }
  });
}
var Legend_default = Legend;

// node_modules/highcharts/es-modules/Core/Series/SeriesRegistry.js
var defaultOptions5 = DefaultOptions_default.defaultOptions;
var error5 = Utilities_default.error;
var extendClass2 = Utilities_default.extendClass;
var merge15 = Utilities_default.merge;
var SeriesRegistry;
(function(SeriesRegistry2) {
  SeriesRegistry2.seriesTypes = Globals_default.seriesTypes;
  function getSeries(chart, options) {
    if (options === void 0) {
      options = {};
    }
    var optionsChart = chart.options.chart, type = options.type || optionsChart.type || optionsChart.defaultSeriesType || "", SeriesClass = SeriesRegistry2.seriesTypes[type];
    if (!SeriesRegistry2) {
      error5(17, true, chart, { missingModuleFor: type });
    }
    var series = new SeriesClass();
    if (typeof series.init === "function") {
      series.init(chart, options);
    }
    return series;
  }
  SeriesRegistry2.getSeries = getSeries;
  function registerSeriesType(seriesType2, seriesClass) {
    var defaultPlotOptions = defaultOptions5.plotOptions || {}, seriesOptions = seriesClass.defaultOptions;
    if (!seriesClass.prototype.pointClass) {
      seriesClass.prototype.pointClass = Point_default;
    }
    seriesClass.prototype.type = seriesType2;
    if (seriesOptions) {
      defaultPlotOptions[seriesType2] = seriesOptions;
    }
    SeriesRegistry2.seriesTypes[seriesType2] = seriesClass;
  }
  SeriesRegistry2.registerSeriesType = registerSeriesType;
  function seriesType(type, parent, options, seriesProto5, pointProto2) {
    var defaultPlotOptions = defaultOptions5.plotOptions || {};
    parent = parent || "";
    defaultPlotOptions[type] = merge15(defaultPlotOptions[parent], options);
    registerSeriesType(type, extendClass2(SeriesRegistry2.seriesTypes[parent] || function() {
    }, seriesProto5));
    SeriesRegistry2.seriesTypes[type].prototype.type = type;
    if (pointProto2) {
      SeriesRegistry2.seriesTypes[type].prototype.pointClass = extendClass2(Point_default, pointProto2);
    }
    return SeriesRegistry2.seriesTypes[type];
  }
  SeriesRegistry2.seriesType = seriesType;
})(SeriesRegistry || (SeriesRegistry = {}));
var SeriesRegistry_default = SeriesRegistry;

// node_modules/highcharts/es-modules/Core/Chart/Chart.js
var animate3 = AnimationUtilities_default.animate;
var animObject6 = AnimationUtilities_default.animObject;
var setAnimation3 = AnimationUtilities_default.setAnimation;
var numberFormat2 = FormatUtilities_default.numberFormat;
var registerEventOptions3 = Foundation_default.registerEventOptions;
var charts5 = Globals_default.charts;
var doc7 = Globals_default.doc;
var marginNames2 = Globals_default.marginNames;
var svg3 = Globals_default.svg;
var win10 = Globals_default.win;
var defaultOptions6 = DefaultOptions_default.defaultOptions;
var defaultTime3 = DefaultOptions_default.defaultTime;
var seriesTypes = SeriesRegistry_default.seriesTypes;
var addEvent12 = Utilities_default.addEvent;
var attr9 = Utilities_default.attr;
var cleanRecursively2 = Utilities_default.cleanRecursively;
var createElement7 = Utilities_default.createElement;
var css10 = Utilities_default.css;
var defined16 = Utilities_default.defined;
var discardElement5 = Utilities_default.discardElement;
var erase7 = Utilities_default.erase;
var error6 = Utilities_default.error;
var extend14 = Utilities_default.extend;
var find4 = Utilities_default.find;
var fireEvent10 = Utilities_default.fireEvent;
var getStyle3 = Utilities_default.getStyle;
var isArray8 = Utilities_default.isArray;
var isFunction5 = Utilities_default.isFunction;
var isNumber17 = Utilities_default.isNumber;
var isObject7 = Utilities_default.isObject;
var isString8 = Utilities_default.isString;
var merge16 = Utilities_default.merge;
var objectEach15 = Utilities_default.objectEach;
var pick21 = Utilities_default.pick;
var pInt7 = Utilities_default.pInt;
var relativeLength4 = Utilities_default.relativeLength;
var removeEvent7 = Utilities_default.removeEvent;
var splat7 = Utilities_default.splat;
var syncTimeout7 = Utilities_default.syncTimeout;
var uniqueKey5 = Utilities_default.uniqueKey;
var Chart = (
  /** @class */
  function() {
    function Chart3(a, b, c) {
      this.axes = void 0;
      this.axisOffset = void 0;
      this.bounds = void 0;
      this.chartHeight = void 0;
      this.chartWidth = void 0;
      this.clipBox = void 0;
      this.colorCounter = void 0;
      this.container = void 0;
      this.eventOptions = void 0;
      this.index = void 0;
      this.isResizing = void 0;
      this.labelCollectors = void 0;
      this.legend = void 0;
      this.margin = void 0;
      this.numberFormatter = void 0;
      this.options = void 0;
      this.plotBox = void 0;
      this.plotHeight = void 0;
      this.plotLeft = void 0;
      this.plotTop = void 0;
      this.plotWidth = void 0;
      this.pointCount = void 0;
      this.pointer = void 0;
      this.renderer = void 0;
      this.renderTo = void 0;
      this.series = void 0;
      this.sharedClips = {};
      this.spacing = void 0;
      this.spacingBox = void 0;
      this.symbolCounter = void 0;
      this.time = void 0;
      this.titleOffset = void 0;
      this.userOptions = void 0;
      this.xAxis = void 0;
      this.yAxis = void 0;
      this.getArgs(a, b, c);
    }
    Chart3.chart = function(a, b, c) {
      return new Chart3(a, b, c);
    };
    Chart3.prototype.getArgs = function(a, b, c) {
      if (isString8(a) || a.nodeName) {
        this.renderTo = a;
        this.init(b, c);
      } else {
        this.init(a, b);
      }
    };
    Chart3.prototype.init = function(userOptions, callback) {
      var userPlotOptions = userOptions.plotOptions || {};
      fireEvent10(this, "init", { args: arguments }, function() {
        var options = merge16(defaultOptions6, userOptions);
        var optionsChart = options.chart;
        objectEach15(options.plotOptions, function(typeOptions, type) {
          if (isObject7(typeOptions)) {
            typeOptions.tooltip = userPlotOptions[type] && // override by copy:
            merge16(userPlotOptions[type].tooltip) || void 0;
          }
        });
        options.tooltip.userOptions = userOptions.chart && userOptions.chart.forExport && userOptions.tooltip.userOptions || userOptions.tooltip;
        this.userOptions = userOptions;
        this.margin = [];
        this.spacing = [];
        this.bounds = { h: {}, v: {} };
        this.labelCollectors = [];
        this.callback = callback;
        this.isResizing = 0;
        this.options = options;
        this.axes = [];
        this.series = [];
        this.time = userOptions.time && Object.keys(userOptions.time).length ? new Time_default(userOptions.time) : Globals_default.time;
        this.numberFormatter = optionsChart.numberFormatter || numberFormat2;
        this.styledMode = optionsChart.styledMode;
        this.hasCartesianSeries = optionsChart.showAxes;
        var chart = this;
        chart.index = charts5.length;
        charts5.push(chart);
        Globals_default.chartCount++;
        registerEventOptions3(this, optionsChart);
        chart.xAxis = [];
        chart.yAxis = [];
        chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
        fireEvent10(chart, "afterInit");
        chart.firstRender();
      });
    };
    Chart3.prototype.initSeries = function(options) {
      var chart = this, optionsChart = chart.options.chart, type = options.type || optionsChart.type || optionsChart.defaultSeriesType, SeriesClass = seriesTypes[type];
      if (!SeriesClass) {
        error6(17, true, chart, { missingModuleFor: type });
      }
      var series = new SeriesClass();
      if (typeof series.init === "function") {
        series.init(chart, options);
      }
      return series;
    };
    Chart3.prototype.setSeriesData = function() {
      this.getSeriesOrderByLinks().forEach(function(series) {
        if (!series.points && !series.data && series.enabledDataSorting) {
          series.setData(series.options.data, false);
        }
      });
    };
    Chart3.prototype.getSeriesOrderByLinks = function() {
      return this.series.concat().sort(function(a, b) {
        if (a.linkedSeries.length || b.linkedSeries.length) {
          return b.linkedSeries.length - a.linkedSeries.length;
        }
        return 0;
      });
    };
    Chart3.prototype.orderSeries = function(fromIndex) {
      var series = this.series;
      for (var i = fromIndex || 0, iEnd = series.length; i < iEnd; ++i) {
        if (series[i]) {
          series[i].index = i;
          series[i].name = series[i].getName();
        }
      }
    };
    Chart3.prototype.isInsidePlot = function(plotX, plotY, options) {
      var _a15;
      if (options === void 0) {
        options = {};
      }
      var _b = this, inverted = _b.inverted, plotBox = _b.plotBox, plotLeft = _b.plotLeft, plotTop = _b.plotTop, scrollablePlotBox = _b.scrollablePlotBox;
      var scrollLeft = 0, scrollTop = 0;
      if (options.visiblePlotOnly && this.scrollingContainer) {
        _a15 = this.scrollingContainer, scrollLeft = _a15.scrollLeft, scrollTop = _a15.scrollTop;
      }
      var series = options.series, box = options.visiblePlotOnly && scrollablePlotBox || plotBox, x = options.inverted ? plotY : plotX, y = options.inverted ? plotX : plotY, e2 = {
        x,
        y,
        isInsidePlot: true
      };
      if (!options.ignoreX) {
        var xAxis = series && (inverted ? series.yAxis : series.xAxis) || {
          pos: plotLeft,
          len: Infinity
        };
        var chartX = options.paneCoordinates ? xAxis.pos + x : plotLeft + x;
        if (!(chartX >= Math.max(scrollLeft + plotLeft, xAxis.pos) && chartX <= Math.min(scrollLeft + plotLeft + box.width, xAxis.pos + xAxis.len))) {
          e2.isInsidePlot = false;
        }
      }
      if (!options.ignoreY && e2.isInsidePlot) {
        var yAxis = series && (inverted ? series.xAxis : series.yAxis) || {
          pos: plotTop,
          len: Infinity
        };
        var chartY = options.paneCoordinates ? yAxis.pos + y : plotTop + y;
        if (!(chartY >= Math.max(scrollTop + plotTop, yAxis.pos) && chartY <= Math.min(scrollTop + plotTop + box.height, yAxis.pos + yAxis.len))) {
          e2.isInsidePlot = false;
        }
      }
      fireEvent10(this, "afterIsInsidePlot", e2);
      return e2.isInsidePlot;
    };
    Chart3.prototype.redraw = function(animation) {
      fireEvent10(this, "beforeRedraw");
      var chart = this, axes = chart.hasCartesianSeries ? chart.axes : chart.colorAxis || [], series = chart.series, pointer = chart.pointer, legend = chart.legend, legendUserOptions = chart.userOptions.legend, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
      var hasDirtyStacks, hasStackedSeries, i, isDirtyBox = chart.isDirtyBox, redrawLegend = chart.isDirtyLegend, serie;
      if (chart.setResponsive) {
        chart.setResponsive(false);
      }
      setAnimation3(chart.hasRendered ? animation : false, chart);
      if (isHiddenChart) {
        chart.temporaryDisplay();
      }
      chart.layOutTitles();
      i = series.length;
      while (i--) {
        serie = series[i];
        if (serie.options.stacking || serie.options.centerInCategory) {
          hasStackedSeries = true;
          if (serie.isDirty) {
            hasDirtyStacks = true;
            break;
          }
        }
      }
      if (hasDirtyStacks) {
        i = series.length;
        while (i--) {
          serie = series[i];
          if (serie.options.stacking) {
            serie.isDirty = true;
          }
        }
      }
      series.forEach(function(serie2) {
        if (serie2.isDirty) {
          if (serie2.options.legendType === "point") {
            if (typeof serie2.updateTotals === "function") {
              serie2.updateTotals();
            }
            redrawLegend = true;
          } else if (legendUserOptions && (legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {
            redrawLegend = true;
          }
        }
        if (serie2.isDirtyData) {
          fireEvent10(serie2, "updatedData");
        }
      });
      if (redrawLegend && legend && legend.options.enabled) {
        legend.render();
        chart.isDirtyLegend = false;
      }
      if (hasStackedSeries) {
        chart.getStacks();
      }
      axes.forEach(function(axis) {
        axis.updateNames();
        axis.setScale();
      });
      chart.getMargins();
      axes.forEach(function(axis) {
        if (axis.isDirty) {
          isDirtyBox = true;
        }
      });
      axes.forEach(function(axis) {
        var key = axis.min + "," + axis.max;
        if (axis.extKey !== key) {
          axis.extKey = key;
          afterRedraw.push(function() {
            fireEvent10(axis, "afterSetExtremes", extend14(axis.eventArgs, axis.getExtremes()));
            delete axis.eventArgs;
          });
        }
        if (isDirtyBox || hasStackedSeries) {
          axis.redraw();
        }
      });
      if (isDirtyBox) {
        chart.drawChartBox();
      }
      fireEvent10(chart, "predraw");
      series.forEach(function(serie2) {
        if ((isDirtyBox || serie2.isDirty) && serie2.visible) {
          serie2.redraw();
        }
        serie2.isDirtyData = false;
      });
      if (pointer) {
        pointer.reset(true);
      }
      renderer.draw();
      fireEvent10(chart, "redraw");
      fireEvent10(chart, "render");
      if (isHiddenChart) {
        chart.temporaryDisplay(true);
      }
      afterRedraw.forEach(function(callback) {
        callback.call();
      });
    };
    Chart3.prototype.get = function(id) {
      var series = this.series;
      function itemById(item) {
        return item.id === id || item.options && item.options.id === id;
      }
      var ret = (
        // Search axes
        find4(this.axes, itemById) || // Search series
        find4(this.series, itemById)
      );
      for (var i = 0; !ret && i < series.length; i++) {
        ret = find4(series[i].points || [], itemById);
      }
      return ret;
    };
    Chart3.prototype.getAxes = function() {
      var chart = this, options = this.options, xAxisOptions = options.xAxis = splat7(options.xAxis || {}), yAxisOptions = options.yAxis = splat7(options.yAxis || {});
      fireEvent10(this, "getAxes");
      xAxisOptions.forEach(function(axis, i) {
        axis.index = i;
        axis.isX = true;
      });
      yAxisOptions.forEach(function(axis, i) {
        axis.index = i;
      });
      var optionsArray = xAxisOptions.concat(yAxisOptions);
      optionsArray.forEach(function(axisOptions) {
        new Axis_default(chart, axisOptions);
      });
      fireEvent10(this, "afterGetAxes");
    };
    Chart3.prototype.getSelectedPoints = function() {
      return this.series.reduce(function(acc, series) {
        series.getPointsCollection().forEach(function(point) {
          if (pick21(point.selectedStaging, point.selected)) {
            acc.push(point);
          }
        });
        return acc;
      }, []);
    };
    Chart3.prototype.getSelectedSeries = function() {
      return this.series.filter(function(serie) {
        return serie.selected;
      });
    };
    Chart3.prototype.setTitle = function(titleOptions, subtitleOptions, redraw) {
      this.applyDescription("title", titleOptions);
      this.applyDescription("subtitle", subtitleOptions);
      this.applyDescription("caption", void 0);
      this.layOutTitles(redraw);
    };
    Chart3.prototype.applyDescription = function(name, explicitOptions) {
      var chart = this;
      var style = name === "title" ? {
        color: Palette_default.neutralColor80,
        fontSize: this.options.isStock ? "16px" : "18px"
        // #2944
      } : {
        color: Palette_default.neutralColor60
      };
      var options = this.options[name] = merge16(
        // Default styles
        !this.styledMode && { style },
        this.options[name],
        explicitOptions
      );
      var elem = this[name];
      if (elem && explicitOptions) {
        this[name] = elem = elem.destroy();
      }
      if (options && !elem) {
        elem = this.renderer.text(options.text, 0, 0, options.useHTML).attr({
          align: options.align,
          "class": "highcharts-" + name,
          zIndex: options.zIndex || 4
        }).add();
        elem.update = function(updateOptions) {
          var fn = {
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }[name];
          chart[fn](updateOptions);
        };
        if (!this.styledMode) {
          elem.css(options.style);
        }
        this[name] = elem;
      }
    };
    Chart3.prototype.layOutTitles = function(redraw) {
      var titleOffset = [0, 0, 0], renderer = this.renderer, spacingBox = this.spacingBox;
      ["title", "subtitle", "caption"].forEach(function(key) {
        var title = this[key], titleOptions = this.options[key], verticalAlign = titleOptions.verticalAlign || "top", offset3 = key === "title" ? verticalAlign === "top" ? -3 : 0 : (
          // Floating subtitle (#6574)
          verticalAlign === "top" ? titleOffset[0] + 2 : 0
        );
        var titleSize, height;
        if (title) {
          if (!this.styledMode) {
            titleSize = titleOptions.style && titleOptions.style.fontSize;
          }
          titleSize = renderer.fontMetrics(titleSize, title).b;
          title.css({
            width: (titleOptions.width || spacingBox.width + (titleOptions.widthAdjust || 0)) + "px"
          });
          height = Math.round(title.getBBox(titleOptions.useHTML).height);
          title.align(extend14({
            y: verticalAlign === "bottom" ? titleSize : offset3 + titleSize,
            height
          }, titleOptions), false, "spacingBox");
          if (!titleOptions.floating) {
            if (verticalAlign === "top") {
              titleOffset[0] = Math.ceil(titleOffset[0] + height);
            } else if (verticalAlign === "bottom") {
              titleOffset[2] = Math.ceil(titleOffset[2] + height);
            }
          }
        }
      }, this);
      if (titleOffset[0] && (this.options.title.verticalAlign || "top") === "top") {
        titleOffset[0] += this.options.title.margin;
      }
      if (titleOffset[2] && this.options.caption.verticalAlign === "bottom") {
        titleOffset[2] += this.options.caption.margin;
      }
      var requiresDirtyBox = !this.titleOffset || this.titleOffset.join(",") !== titleOffset.join(",");
      this.titleOffset = titleOffset;
      fireEvent10(this, "afterLayOutTitles");
      if (!this.isDirtyBox && requiresDirtyBox) {
        this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
        if (this.hasRendered && pick21(redraw, true) && this.isDirtyBox) {
          this.redraw();
        }
      }
    };
    Chart3.prototype.getChartSize = function() {
      var chart = this, optionsChart = chart.options.chart, widthOption = optionsChart.width, heightOption = optionsChart.height, renderTo = chart.renderTo;
      if (!defined16(widthOption)) {
        chart.containerWidth = getStyle3(renderTo, "width");
      }
      if (!defined16(heightOption)) {
        chart.containerHeight = getStyle3(renderTo, "height");
      }
      chart.chartWidth = Math.max(
        // #1393
        0,
        widthOption || chart.containerWidth || 600
        // #1460
      );
      chart.chartHeight = Math.max(0, relativeLength4(heightOption, chart.chartWidth) || (chart.containerHeight > 1 ? chart.containerHeight : 400));
    };
    Chart3.prototype.temporaryDisplay = function(revert) {
      var node = this.renderTo, tempStyle;
      if (!revert) {
        while (node && node.style) {
          if (!doc7.body.contains(node) && !node.parentNode) {
            node.hcOrigDetached = true;
            doc7.body.appendChild(node);
          }
          if (getStyle3(node, "display", false) === "none" || node.hcOricDetached) {
            node.hcOrigStyle = {
              display: node.style.display,
              height: node.style.height,
              overflow: node.style.overflow
            };
            tempStyle = {
              display: "block",
              overflow: "hidden"
            };
            if (node !== this.renderTo) {
              tempStyle.height = 0;
            }
            css10(node, tempStyle);
            if (!node.offsetWidth) {
              node.style.setProperty("display", "block", "important");
            }
          }
          node = node.parentNode;
          if (node === doc7.body) {
            break;
          }
        }
      } else {
        while (node && node.style) {
          if (node.hcOrigStyle) {
            css10(node, node.hcOrigStyle);
            delete node.hcOrigStyle;
          }
          if (node.hcOrigDetached) {
            doc7.body.removeChild(node);
            node.hcOrigDetached = false;
          }
          node = node.parentNode;
        }
      }
    };
    Chart3.prototype.setClassName = function(className) {
      this.container.className = "highcharts-container " + (className || "");
    };
    Chart3.prototype.getContainer = function() {
      var chart = this, options = chart.options, optionsChart = options.chart, indexAttrName = "data-highcharts-chart", containerId = uniqueKey5();
      var containerStyle, renderTo = chart.renderTo;
      if (!renderTo) {
        chart.renderTo = renderTo = optionsChart.renderTo;
      }
      if (isString8(renderTo)) {
        chart.renderTo = renderTo = doc7.getElementById(renderTo);
      }
      if (!renderTo) {
        error6(13, true, chart);
      }
      var oldChartIndex = pInt7(attr9(renderTo, indexAttrName));
      if (isNumber17(oldChartIndex) && charts5[oldChartIndex] && charts5[oldChartIndex].hasRendered) {
        charts5[oldChartIndex].destroy();
      }
      attr9(renderTo, indexAttrName, chart.index);
      renderTo.innerHTML = "";
      if (!optionsChart.skipClone && !renderTo.offsetWidth) {
        chart.temporaryDisplay();
      }
      chart.getChartSize();
      var chartWidth = chart.chartWidth;
      var chartHeight = chart.chartHeight;
      css10(renderTo, { overflow: "hidden" });
      if (!chart.styledMode) {
        containerStyle = extend14({
          position: "relative",
          // needed for context menu (avoidscrollbars) and content
          // overflow in IE
          overflow: "hidden",
          width: chartWidth + "px",
          height: chartHeight + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
          userSelect: "none",
          "touch-action": "manipulation",
          outline: "none"
        }, optionsChart.style || {});
      }
      var container = createElement7("div", {
        id: containerId
      }, containerStyle, renderTo);
      chart.container = container;
      chart._cursor = container.style.cursor;
      var Renderer2 = optionsChart.renderer || !svg3 ? RendererRegistry_default.getRendererType(optionsChart.renderer) : SVGRenderer_default;
      chart.renderer = new Renderer2(container, chartWidth, chartHeight, void 0, optionsChart.forExport, options.exporting && options.exporting.allowHTML, chart.styledMode);
      setAnimation3(void 0, chart);
      chart.setClassName(optionsChart.className);
      if (!chart.styledMode) {
        chart.renderer.setStyle(optionsChart.style);
      } else {
        for (var key in options.defs) {
          this.renderer.definition(options.defs[key]);
        }
      }
      chart.renderer.chartIndex = chart.index;
      fireEvent10(this, "afterGetContainer");
    };
    Chart3.prototype.getMargins = function(skipAxes) {
      var _a15 = this, spacing = _a15.spacing, margin = _a15.margin, titleOffset = _a15.titleOffset;
      this.resetMargins();
      if (titleOffset[0] && !defined16(margin[0])) {
        this.plotTop = Math.max(this.plotTop, titleOffset[0] + spacing[0]);
      }
      if (titleOffset[2] && !defined16(margin[2])) {
        this.marginBottom = Math.max(this.marginBottom, titleOffset[2] + spacing[2]);
      }
      if (this.legend && this.legend.display) {
        this.legend.adjustMargins(margin, spacing);
      }
      fireEvent10(this, "getMargins");
      if (!skipAxes) {
        this.getAxisMargins();
      }
    };
    Chart3.prototype.getAxisMargins = function() {
      var chart = this, axisOffset = chart.axisOffset = [0, 0, 0, 0], colorAxis = chart.colorAxis, margin = chart.margin, getOffset = function(axes) {
        axes.forEach(function(axis) {
          if (axis.visible) {
            axis.getOffset();
          }
        });
      };
      if (chart.hasCartesianSeries) {
        getOffset(chart.axes);
      } else if (colorAxis && colorAxis.length) {
        getOffset(colorAxis);
      }
      marginNames2.forEach(function(m, side) {
        if (!defined16(margin[side])) {
          chart[m] += axisOffset[side];
        }
      });
      chart.setChartSize();
    };
    Chart3.prototype.reflow = function(e2) {
      var chart = this, optionsChart = chart.options.chart, renderTo = chart.renderTo, hasUserSize = defined16(optionsChart.width) && defined16(optionsChart.height), width = optionsChart.width || getStyle3(renderTo, "width"), height = optionsChart.height || getStyle3(renderTo, "height"), target = e2 ? e2.target : win10;
      delete chart.pointer.chartPosition;
      if (!hasUserSize && !chart.isPrinting && width && height && (target === win10 || target === doc7)) {
        if (width !== chart.containerWidth || height !== chart.containerHeight) {
          Utilities_default.clearTimeout(chart.reflowTimeout);
          chart.reflowTimeout = syncTimeout7(function() {
            if (chart.container) {
              chart.setSize(void 0, void 0, false);
            }
          }, e2 ? 100 : 0);
        }
        chart.containerWidth = width;
        chart.containerHeight = height;
      }
    };
    Chart3.prototype.setReflow = function(reflow) {
      var chart = this;
      if (reflow !== false && !this.unbindReflow) {
        this.unbindReflow = addEvent12(win10, "resize", function(e2) {
          if (chart.options) {
            chart.reflow(e2);
          }
        });
        addEvent12(this, "destroy", this.unbindReflow);
      } else if (reflow === false && this.unbindReflow) {
        this.unbindReflow = this.unbindReflow();
      }
    };
    Chart3.prototype.setSize = function(width, height, animation) {
      var chart = this, renderer = chart.renderer;
      chart.isResizing += 1;
      setAnimation3(animation, chart);
      var globalAnimation = renderer.globalAnimation;
      chart.oldChartHeight = chart.chartHeight;
      chart.oldChartWidth = chart.chartWidth;
      if (typeof width !== "undefined") {
        chart.options.chart.width = width;
      }
      if (typeof height !== "undefined") {
        chart.options.chart.height = height;
      }
      chart.getChartSize();
      if (!chart.styledMode) {
        (globalAnimation ? animate3 : css10)(chart.container, {
          width: chart.chartWidth + "px",
          height: chart.chartHeight + "px"
        }, globalAnimation);
      }
      chart.setChartSize(true);
      renderer.setSize(chart.chartWidth, chart.chartHeight, globalAnimation);
      chart.axes.forEach(function(axis) {
        axis.isDirty = true;
        axis.setScale();
      });
      chart.isDirtyLegend = true;
      chart.isDirtyBox = true;
      chart.layOutTitles();
      chart.getMargins();
      chart.redraw(globalAnimation);
      chart.oldChartHeight = null;
      fireEvent10(chart, "resize");
      syncTimeout7(function() {
        if (chart) {
          fireEvent10(chart, "endResize", null, function() {
            chart.isResizing -= 1;
          });
        }
      }, animObject6(globalAnimation).duration);
    };
    Chart3.prototype.setChartSize = function(skipAxes) {
      var chart = this, inverted = chart.inverted, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, optionsChart = chart.options.chart, spacing = chart.spacing, clipOffset = chart.clipOffset;
      var plotLeft, plotTop, plotWidth, plotHeight;
      chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
      chart.plotTop = plotTop = Math.round(chart.plotTop);
      chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
      chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
      chart.plotSizeX = inverted ? plotHeight : plotWidth;
      chart.plotSizeY = inverted ? plotWidth : plotHeight;
      chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
      chart.spacingBox = renderer.spacingBox = {
        x: spacing[3],
        y: spacing[0],
        width: chartWidth - spacing[3] - spacing[1],
        height: chartHeight - spacing[0] - spacing[2]
      };
      chart.plotBox = renderer.plotBox = {
        x: plotLeft,
        y: plotTop,
        width: plotWidth,
        height: plotHeight
      };
      var plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2), clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2), clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);
      chart.clipBox = {
        x: clipX,
        y: clipY,
        width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX),
        height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))
      };
      if (!skipAxes) {
        chart.axes.forEach(function(axis) {
          axis.setAxisSize();
          axis.setAxisTranslation();
        });
        renderer.alignElements();
      }
      fireEvent10(chart, "afterSetChartSize", { skipAxes });
    };
    Chart3.prototype.resetMargins = function() {
      fireEvent10(this, "resetMargins");
      var chart = this, chartOptions = chart.options.chart;
      ["margin", "spacing"].forEach(function splashArrays(target) {
        var value = chartOptions[target], values = isObject7(value) ? value : [value, value, value, value];
        [
          "Top",
          "Right",
          "Bottom",
          "Left"
        ].forEach(function(sideName, side) {
          chart[target][side] = pick21(chartOptions[target + sideName], values[side]);
        });
      });
      marginNames2.forEach(function(m, side) {
        chart[m] = pick21(chart.margin[side], chart.spacing[side]);
      });
      chart.axisOffset = [0, 0, 0, 0];
      chart.clipOffset = [0, 0, 0, 0];
    };
    Chart3.prototype.drawChartBox = function() {
      var chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, styledMode = chart.styledMode, plotBGImage = chart.plotBGImage, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
      var chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, chartBorderWidth, mgn, bgAttr, verb = "animate";
      if (!chartBackground) {
        chart.chartBackground = chartBackground = renderer.rect().addClass("highcharts-background").add();
        verb = "attr";
      }
      if (!styledMode) {
        chartBorderWidth = optionsChart.borderWidth || 0;
        mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
        bgAttr = {
          fill: chartBackgroundColor || "none"
        };
        if (chartBorderWidth || chartBackground["stroke-width"]) {
          bgAttr.stroke = optionsChart.borderColor;
          bgAttr["stroke-width"] = chartBorderWidth;
        }
        chartBackground.attr(bgAttr).shadow(optionsChart.shadow);
      } else {
        chartBorderWidth = mgn = chartBackground.strokeWidth();
      }
      chartBackground[verb]({
        x: mgn / 2,
        y: mgn / 2,
        width: chartWidth - mgn - chartBorderWidth % 2,
        height: chartHeight - mgn - chartBorderWidth % 2,
        r: optionsChart.borderRadius
      });
      verb = "animate";
      if (!plotBackground) {
        verb = "attr";
        chart.plotBackground = plotBackground = renderer.rect().addClass("highcharts-plot-background").add();
      }
      plotBackground[verb](plotBox);
      if (!styledMode) {
        plotBackground.attr({
          fill: plotBackgroundColor || "none"
        }).shadow(optionsChart.plotShadow);
        if (plotBackgroundImage) {
          if (!plotBGImage) {
            chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
          } else {
            if (plotBackgroundImage !== plotBGImage.attr("href")) {
              plotBGImage.attr("href", plotBackgroundImage);
            }
            plotBGImage.animate(plotBox);
          }
        }
      }
      if (!clipRect) {
        chart.clipRect = renderer.clipRect(clipBox);
      } else {
        clipRect.animate({
          width: clipBox.width,
          height: clipBox.height
        });
      }
      verb = "animate";
      if (!plotBorder) {
        verb = "attr";
        chart.plotBorder = plotBorder = renderer.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
          // Above the grid
        }).add();
      }
      if (!styledMode) {
        plotBorder.attr({
          stroke: optionsChart.plotBorderColor,
          "stroke-width": optionsChart.plotBorderWidth || 0,
          fill: "none"
        });
      }
      plotBorder[verb](plotBorder.crisp({
        x: plotLeft,
        y: plotTop,
        width: plotWidth,
        height: plotHeight
      }, -plotBorder.strokeWidth()));
      chart.isDirtyBox = false;
      fireEvent10(this, "afterDrawChartBox");
    };
    Chart3.prototype.propFromSeries = function() {
      var chart = this, optionsChart = chart.options.chart, seriesOptions = chart.options.series;
      var i, klass, value;
      ["inverted", "angular", "polar"].forEach(function(key) {
        klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
        value = // It is set in the options:
        optionsChart[key] || // The default series class:
        klass && klass.prototype[key];
        i = seriesOptions && seriesOptions.length;
        while (!value && i--) {
          klass = seriesTypes[seriesOptions[i].type];
          if (klass && klass.prototype[key]) {
            value = true;
          }
        }
        chart[key] = value;
      });
    };
    Chart3.prototype.linkSeries = function() {
      var chart = this, chartSeries = chart.series;
      chartSeries.forEach(function(series) {
        series.linkedSeries.length = 0;
      });
      chartSeries.forEach(function(series) {
        var linkedTo = series.options.linkedTo;
        if (isString8(linkedTo)) {
          if (linkedTo === ":previous") {
            linkedTo = chart.series[series.index - 1];
          } else {
            linkedTo = chart.get(linkedTo);
          }
          if (linkedTo && linkedTo.linkedParent !== series) {
            linkedTo.linkedSeries.push(series);
            series.linkedParent = linkedTo;
            if (linkedTo.enabledDataSorting) {
              series.setDataSortingOptions();
            }
            series.visible = pick21(series.options.visible, linkedTo.options.visible, series.visible);
          }
        }
      });
      fireEvent10(this, "afterLinkSeries");
    };
    Chart3.prototype.renderSeries = function() {
      this.series.forEach(function(serie) {
        serie.translate();
        serie.render();
      });
    };
    Chart3.prototype.renderLabels = function() {
      var chart = this, labels = chart.options.labels;
      if (labels.items) {
        labels.items.forEach(function(label) {
          var style = extend14(labels.style, label.style), x = pInt7(style.left) + chart.plotLeft, y = pInt7(style.top) + chart.plotTop + 12;
          delete style.left;
          delete style.top;
          chart.renderer.text(label.html, x, y).attr({ zIndex: 2 }).css(style).add();
        });
      }
    };
    Chart3.prototype.render = function() {
      var chart = this, axes = chart.axes, colorAxis = chart.colorAxis, renderer = chart.renderer, options = chart.options, renderAxes = function(axes2) {
        axes2.forEach(function(axis) {
          if (axis.visible) {
            axis.render();
          }
        });
      };
      var correction = 0;
      chart.setTitle();
      chart.legend = new Legend_default(chart, options.legend);
      if (chart.getStacks) {
        chart.getStacks();
      }
      chart.getMargins(true);
      chart.setChartSize();
      var tempWidth = chart.plotWidth;
      axes.some(function(axis) {
        if (axis.horiz && axis.visible && axis.options.labels.enabled && axis.series.length) {
          correction = 21;
          return true;
        }
      });
      chart.plotHeight = Math.max(chart.plotHeight - correction, 0);
      var tempHeight = chart.plotHeight;
      axes.forEach(function(axis) {
        axis.setScale();
      });
      chart.getAxisMargins();
      var redoHorizontal = tempWidth / chart.plotWidth > 1.1;
      var redoVertical = tempHeight / chart.plotHeight > 1.05;
      if (redoHorizontal || redoVertical) {
        axes.forEach(function(axis) {
          if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {
            axis.setTickInterval(true);
          }
        });
        chart.getMargins();
      }
      chart.drawChartBox();
      if (chart.hasCartesianSeries) {
        renderAxes(axes);
      } else if (colorAxis && colorAxis.length) {
        renderAxes(colorAxis);
      }
      if (!chart.seriesGroup) {
        chart.seriesGroup = renderer.g("series-group").attr({ zIndex: 3 }).add();
      }
      chart.renderSeries();
      chart.renderLabels();
      chart.addCredits();
      if (chart.setResponsive) {
        chart.setResponsive();
      }
      chart.hasRendered = true;
    };
    Chart3.prototype.addCredits = function(credits) {
      var chart = this, creds = merge16(true, this.options.credits, credits);
      if (creds.enabled && !this.credits) {
        this.credits = this.renderer.text(creds.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
          if (creds.href) {
            win10.location.href = creds.href;
          }
        }).attr({
          align: creds.position.align,
          zIndex: 8
        });
        if (!chart.styledMode) {
          this.credits.css(creds.style);
        }
        this.credits.add().align(creds.position);
        this.credits.update = function(options) {
          chart.credits = chart.credits.destroy();
          chart.addCredits(options);
        };
      }
    };
    Chart3.prototype.destroy = function() {
      var chart = this, axes = chart.axes, series = chart.series, container = chart.container, parentNode = container && container.parentNode;
      var i;
      fireEvent10(chart, "destroy");
      if (chart.renderer.forExport) {
        erase7(charts5, chart);
      } else {
        charts5[chart.index] = void 0;
      }
      Globals_default.chartCount--;
      chart.renderTo.removeAttribute("data-highcharts-chart");
      removeEvent7(chart);
      i = axes.length;
      while (i--) {
        axes[i] = axes[i].destroy();
      }
      if (this.scroller && this.scroller.destroy) {
        this.scroller.destroy();
      }
      i = series.length;
      while (i--) {
        series[i] = series[i].destroy();
      }
      [
        "title",
        "subtitle",
        "chartBackground",
        "plotBackground",
        "plotBGImage",
        "plotBorder",
        "seriesGroup",
        "clipRect",
        "credits",
        "pointer",
        "rangeSelector",
        "legend",
        "resetZoomButton",
        "tooltip",
        "renderer"
      ].forEach(function(name) {
        var prop = chart[name];
        if (prop && prop.destroy) {
          chart[name] = prop.destroy();
        }
      });
      if (container) {
        container.innerHTML = "";
        removeEvent7(container);
        if (parentNode) {
          discardElement5(container);
        }
      }
      objectEach15(chart, function(val, key) {
        delete chart[key];
      });
    };
    Chart3.prototype.firstRender = function() {
      var chart = this, options = chart.options;
      if (chart.isReadyToRender && !chart.isReadyToRender()) {
        return;
      }
      chart.getContainer();
      chart.resetMargins();
      chart.setChartSize();
      chart.propFromSeries();
      chart.getAxes();
      (isArray8(options.series) ? options.series : []).forEach(
        // #9680
        function(serieOptions) {
          chart.initSeries(serieOptions);
        }
      );
      chart.linkSeries();
      chart.setSeriesData();
      fireEvent10(chart, "beforeRender");
      if (Pointer_default) {
        if (MSPointer_default.isRequired()) {
          chart.pointer = new MSPointer_default(chart, options);
        } else {
          chart.pointer = new Pointer_default(chart, options);
        }
      }
      chart.render();
      chart.pointer.getChartPosition();
      if (!chart.renderer.imgCount && !chart.hasLoaded) {
        chart.onload();
      }
      chart.temporaryDisplay(true);
    };
    Chart3.prototype.onload = function() {
      this.callbacks.concat([this.callback]).forEach(function(fn) {
        if (fn && typeof this.index !== "undefined") {
          fn.apply(this, [this]);
        }
      }, this);
      fireEvent10(this, "load");
      fireEvent10(this, "render");
      if (defined16(this.index)) {
        this.setReflow(this.options.chart.reflow);
      }
      this.hasLoaded = true;
    };
    Chart3.prototype.addSeries = function(options, redraw, animation) {
      var chart = this;
      var series;
      if (options) {
        redraw = pick21(redraw, true);
        fireEvent10(chart, "addSeries", { options }, function() {
          series = chart.initSeries(options);
          chart.isDirtyLegend = true;
          chart.linkSeries();
          if (series.enabledDataSorting) {
            series.setData(options.data, false);
          }
          fireEvent10(chart, "afterAddSeries", { series });
          if (redraw) {
            chart.redraw(animation);
          }
        });
      }
      return series;
    };
    Chart3.prototype.addAxis = function(options, isX, redraw, animation) {
      return this.createAxis(isX ? "xAxis" : "yAxis", { axis: options, redraw, animation });
    };
    Chart3.prototype.addColorAxis = function(options, redraw, animation) {
      return this.createAxis("colorAxis", { axis: options, redraw, animation });
    };
    Chart3.prototype.createAxis = function(type, options) {
      var axis = new Axis_default(this, merge16(options.axis, {
        index: this[type].length,
        isX: type === "xAxis"
      }));
      if (pick21(options.redraw, true)) {
        this.redraw(options.animation);
      }
      return axis;
    };
    Chart3.prototype.showLoading = function(str) {
      var chart = this, options = chart.options, loadingOptions = options.loading, setLoadingSize = function() {
        if (loadingDiv) {
          css10(loadingDiv, {
            left: chart.plotLeft + "px",
            top: chart.plotTop + "px",
            width: chart.plotWidth + "px",
            height: chart.plotHeight + "px"
          });
        }
      };
      var loadingDiv = chart.loadingDiv, loadingSpan = chart.loadingSpan;
      if (!loadingDiv) {
        chart.loadingDiv = loadingDiv = createElement7("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, chart.container);
      }
      if (!loadingSpan) {
        chart.loadingSpan = loadingSpan = createElement7("span", { className: "highcharts-loading-inner" }, null, loadingDiv);
        addEvent12(chart, "redraw", setLoadingSize);
      }
      loadingDiv.className = "highcharts-loading";
      AST_default.setElementHTML(loadingSpan, pick21(str, options.lang.loading, ""));
      if (!chart.styledMode) {
        css10(loadingDiv, extend14(loadingOptions.style, {
          zIndex: 10
        }));
        css10(loadingSpan, loadingOptions.labelStyle);
        if (!chart.loadingShown) {
          css10(loadingDiv, {
            opacity: 0,
            display: ""
          });
          animate3(loadingDiv, {
            opacity: loadingOptions.style.opacity || 0.5
          }, {
            duration: loadingOptions.showDuration || 0
          });
        }
      }
      chart.loadingShown = true;
      setLoadingSize();
    };
    Chart3.prototype.hideLoading = function() {
      var options = this.options, loadingDiv = this.loadingDiv;
      if (loadingDiv) {
        loadingDiv.className = "highcharts-loading highcharts-loading-hidden";
        if (!this.styledMode) {
          animate3(loadingDiv, {
            opacity: 0
          }, {
            duration: options.loading.hideDuration || 100,
            complete: function() {
              css10(loadingDiv, { display: "none" });
            }
          });
        }
      }
      this.loadingShown = false;
    };
    Chart3.prototype.update = function(options, redraw, oneToOne, animation) {
      var chart = this, adders = {
        credits: "addCredits",
        title: "setTitle",
        subtitle: "setSubtitle",
        caption: "setCaption"
      }, isResponsiveOptions = options.isResponsiveOptions, itemsForRemoval = [];
      var updateAllAxes, updateAllSeries, runSetSize;
      fireEvent10(chart, "update", { options });
      if (!isResponsiveOptions) {
        chart.setResponsive(false, true);
      }
      options = cleanRecursively2(options, chart.options);
      chart.userOptions = merge16(chart.userOptions, options);
      var optionsChart = options.chart;
      if (optionsChart) {
        merge16(true, chart.options.chart, optionsChart);
        if ("className" in optionsChart) {
          chart.setClassName(optionsChart.className);
        }
        if ("reflow" in optionsChart) {
          chart.setReflow(optionsChart.reflow);
        }
        if ("inverted" in optionsChart || "polar" in optionsChart || "type" in optionsChart) {
          chart.propFromSeries();
          updateAllAxes = true;
        }
        if ("alignTicks" in optionsChart) {
          updateAllAxes = true;
        }
        if ("events" in optionsChart) {
          registerEventOptions3(this, optionsChart);
        }
        objectEach15(optionsChart, function(val, key) {
          if (chart.propsRequireUpdateSeries.indexOf("chart." + key) !== -1) {
            updateAllSeries = true;
          }
          if (chart.propsRequireDirtyBox.indexOf(key) !== -1) {
            chart.isDirtyBox = true;
          }
          if (chart.propsRequireReflow.indexOf(key) !== -1) {
            if (isResponsiveOptions) {
              chart.isDirtyBox = true;
            } else {
              runSetSize = true;
            }
          }
        });
        if (!chart.styledMode && optionsChart.style) {
          chart.renderer.setStyle(chart.options.chart.style || {});
        }
      }
      if (!chart.styledMode && options.colors) {
        this.options.colors = options.colors;
      }
      if (options.time) {
        if (this.time === defaultTime3) {
          this.time = new Time_default(options.time);
        }
        merge16(true, chart.options.time, options.time);
      }
      objectEach15(options, function(val, key) {
        if (chart[key] && typeof chart[key].update === "function") {
          chart[key].update(val, false);
        } else if (typeof chart[adders[key]] === "function") {
          chart[adders[key]](val);
        } else if (key !== "colors" && chart.collectionsWithUpdate.indexOf(key) === -1) {
          merge16(true, chart.options[key], options[key]);
        }
        if (key !== "chart" && chart.propsRequireUpdateSeries.indexOf(key) !== -1) {
          updateAllSeries = true;
        }
      });
      this.collectionsWithUpdate.forEach(function(coll) {
        var indexMap;
        if (options[coll]) {
          indexMap = [];
          chart[coll].forEach(function(s, i) {
            if (!s.options.isInternal) {
              indexMap.push(pick21(s.options.index, i));
            }
          });
          splat7(options[coll]).forEach(function(newOptions, i) {
            var hasId = defined16(newOptions.id);
            var item;
            if (hasId) {
              item = chart.get(newOptions.id);
            }
            if (!item && chart[coll]) {
              item = chart[coll][indexMap ? indexMap[i] : i];
              if (item && hasId && defined16(item.options.id)) {
                item = void 0;
              }
            }
            if (item && item.coll === coll) {
              item.update(newOptions, false);
              if (oneToOne) {
                item.touched = true;
              }
            }
            if (!item && oneToOne && chart.collectionsWithInit[coll]) {
              chart.collectionsWithInit[coll][0].apply(
                chart,
                // [newOptions, ...extraArguments, redraw=false]
                [
                  newOptions
                ].concat(
                  // Not all initializers require extra args
                  chart.collectionsWithInit[coll][1] || []
                ).concat([
                  false
                ])
              ).touched = true;
            }
          });
          if (oneToOne) {
            chart[coll].forEach(function(item) {
              if (!item.touched && !item.options.isInternal) {
                itemsForRemoval.push(item);
              } else {
                delete item.touched;
              }
            });
          }
        }
      });
      itemsForRemoval.forEach(function(item) {
        if (item.chart && item.remove) {
          item.remove(false);
        }
      });
      if (updateAllAxes) {
        chart.axes.forEach(function(axis) {
          axis.update({}, false);
        });
      }
      if (updateAllSeries) {
        chart.getSeriesOrderByLinks().forEach(function(series) {
          if (series.chart) {
            series.update({}, false);
          }
        }, this);
      }
      var newWidth = optionsChart && optionsChart.width;
      var newHeight = optionsChart && (isString8(optionsChart.height) ? relativeLength4(optionsChart.height, newWidth || chart.chartWidth) : optionsChart.height);
      if (
        // In this case, run chart.setSize with newWidth and newHeight which
        // are undefined, only for reflowing chart elements because margin
        // or spacing has been set (#8190)
        runSetSize || // In this case, the size is actually set
        isNumber17(newWidth) && newWidth !== chart.chartWidth || isNumber17(newHeight) && newHeight !== chart.chartHeight
      ) {
        chart.setSize(newWidth, newHeight, animation);
      } else if (pick21(redraw, true)) {
        chart.redraw(animation);
      }
      fireEvent10(chart, "afterUpdate", {
        options,
        redraw,
        animation
      });
    };
    Chart3.prototype.setSubtitle = function(options, redraw) {
      this.applyDescription("subtitle", options);
      this.layOutTitles(redraw);
    };
    Chart3.prototype.setCaption = function(options, redraw) {
      this.applyDescription("caption", options);
      this.layOutTitles(redraw);
    };
    Chart3.prototype.showResetZoom = function() {
      var chart = this, lang2 = defaultOptions6.lang, btnOptions = chart.options.chart.resetZoomButton, theme2 = btnOptions.theme, states = theme2.states, alignTo = btnOptions.relativeTo === "chart" || btnOptions.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
      function zoomOut() {
        chart.zoomOut();
      }
      fireEvent10(this, "beforeShowResetZoom", null, function() {
        chart.resetZoomButton = chart.renderer.button(lang2.resetZoom, null, null, zoomOut, theme2, states && states.hover).attr({
          align: btnOptions.position.align,
          title: lang2.resetZoomTitle
        }).addClass("highcharts-reset-zoom").add().align(btnOptions.position, false, alignTo);
      });
      fireEvent10(this, "afterShowResetZoom");
    };
    Chart3.prototype.zoomOut = function() {
      fireEvent10(this, "selection", { resetSelection: true }, this.zoom);
    };
    Chart3.prototype.zoom = function(event) {
      var chart = this, pointer = chart.pointer, mouseDownPos = chart.inverted ? pointer.mouseDownX : pointer.mouseDownY;
      var displayButton = false, hasZoomed;
      if (!event || event.resetSelection) {
        chart.axes.forEach(function(axis) {
          hasZoomed = axis.zoom();
        });
        pointer.initiated = false;
      } else {
        event.xAxis.concat(event.yAxis).forEach(function(axisData) {
          var axis = axisData.axis, axisStartPos = chart.inverted ? axis.left : axis.top, axisEndPos = chart.inverted ? axisStartPos + axis.width : axisStartPos + axis.height, isXAxis = axis.isXAxis;
          var isWithinPane = false;
          if (!isXAxis && mouseDownPos >= axisStartPos && mouseDownPos <= axisEndPos || isXAxis || !defined16(mouseDownPos)) {
            isWithinPane = true;
          }
          if (pointer[isXAxis ? "zoomX" : "zoomY"] && isWithinPane) {
            hasZoomed = axis.zoom(axisData.min, axisData.max);
            if (axis.displayBtn) {
              displayButton = true;
            }
          }
        });
      }
      var resetZoomButton = chart.resetZoomButton;
      if (displayButton && !resetZoomButton) {
        chart.showResetZoom();
      } else if (!displayButton && isObject7(resetZoomButton)) {
        chart.resetZoomButton = resetZoomButton.destroy();
      }
      if (hasZoomed) {
        chart.redraw(pick21(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));
      }
    };
    Chart3.prototype.pan = function(e2, panning) {
      var chart = this, hoverPoints = chart.hoverPoints, panningOptions = typeof panning === "object" ? panning : {
        enabled: panning,
        type: "x"
      }, chartOptions = chart.options.chart, hasMapNavigation = chart.options.mapNavigation && chart.options.mapNavigation.enabled;
      if (chartOptions && chartOptions.panning) {
        chartOptions.panning = panningOptions;
      }
      var type = panningOptions.type;
      var doRedraw;
      fireEvent10(this, "pan", { originalEvent: e2 }, function() {
        if (hoverPoints) {
          hoverPoints.forEach(function(point) {
            point.setState();
          });
        }
        var axes = chart.xAxis;
        if (type === "xy") {
          axes = axes.concat(chart.yAxis);
        } else if (type === "y") {
          axes = chart.yAxis;
        }
        var nextMousePos = {};
        axes.forEach(function(axis) {
          if (!axis.options.panningEnabled || axis.options.isInternal) {
            return;
          }
          var horiz = axis.horiz, mousePos = e2[horiz ? "chartX" : "chartY"], mouseDown = horiz ? "mouseDownX" : "mouseDownY", startPos = chart[mouseDown], halfPointRange = axis.minPointOffset || 0, pointRangeDirection = axis.reversed && !chart.inverted || !axis.reversed && chart.inverted ? -1 : 1, extremes = axis.getExtremes(), panMin = axis.toValue(startPos - mousePos, true) + halfPointRange * pointRangeDirection, panMax = axis.toValue(startPos + axis.len - mousePos, true) - (halfPointRange * pointRangeDirection || axis.isXAxis && axis.pointRangePadding || 0), flipped = panMax < panMin, hasVerticalPanning = axis.hasVerticalPanning();
          var newMin = flipped ? panMax : panMin, newMax = flipped ? panMin : panMax, panningState = axis.panningState, spill;
          if (hasVerticalPanning && !axis.isXAxis && (!panningState || panningState.isDirty)) {
            axis.series.forEach(function(series) {
              var processedData = series.getProcessedData(true), dataExtremes = series.getExtremes(processedData.yData, true);
              if (!panningState) {
                panningState = {
                  startMin: Number.MAX_VALUE,
                  startMax: -Number.MAX_VALUE
                };
              }
              if (isNumber17(dataExtremes.dataMin) && isNumber17(dataExtremes.dataMax)) {
                panningState.startMin = Math.min(pick21(series.options.threshold, Infinity), dataExtremes.dataMin, panningState.startMin);
                panningState.startMax = Math.max(pick21(series.options.threshold, -Infinity), dataExtremes.dataMax, panningState.startMax);
              }
            });
          }
          var paddedMin = Math.min(pick21(panningState && panningState.startMin, extremes.dataMin), halfPointRange ? extremes.min : axis.toValue(axis.toPixels(extremes.min) - axis.minPixelPadding));
          var paddedMax = Math.max(pick21(panningState && panningState.startMax, extremes.dataMax), halfPointRange ? extremes.max : axis.toValue(axis.toPixels(extremes.max) + axis.minPixelPadding));
          axis.panningState = panningState;
          if (!axis.isOrdinal) {
            spill = paddedMin - newMin;
            if (spill > 0) {
              newMax += spill;
              newMin = paddedMin;
            }
            spill = newMax - paddedMax;
            if (spill > 0) {
              newMax = paddedMax;
              newMin -= spill;
            }
            if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max && newMin >= paddedMin && newMax <= paddedMax) {
              axis.setExtremes(newMin, newMax, false, false, { trigger: "pan" });
              if (!chart.resetZoomButton && !hasMapNavigation && // Show reset zoom button only when both newMin and
              // newMax values are between padded axis range.
              newMin !== paddedMin && newMax !== paddedMax && type.match("y")) {
                chart.showResetZoom();
                axis.displayBtn = false;
              }
              doRedraw = true;
            }
            nextMousePos[mouseDown] = mousePos;
          }
        });
        objectEach15(nextMousePos, function(pos, down) {
          chart[down] = pos;
        });
        if (doRedraw) {
          chart.redraw(false);
        }
        css10(chart.container, { cursor: "move" });
      });
    };
    return Chart3;
  }()
);
extend14(Chart.prototype, {
  // Hook for adding callbacks in modules
  callbacks: [],
  /**
   * These collections (arrays) implement `Chart.addSomethig` method used in
   * chart.update() to create new object in the collection. Equivalent for
   * deleting is resolved by simple `Somethig.remove()`.
   *
   * Note: We need to define these references after initializers are bound to
   * chart's prototype.
   */
  collectionsWithInit: {
    // collectionName: [ initializingMethod, [extraArguments] ]
    xAxis: [Chart.prototype.addAxis, [true]],
    yAxis: [Chart.prototype.addAxis, [false]],
    series: [Chart.prototype.addSeries]
  },
  /**
   * These collections (arrays) implement update() methods with support for
   * one-to-one option.
   */
  collectionsWithUpdate: [
    "xAxis",
    "yAxis",
    "series"
  ],
  /**
   * These properties cause isDirtyBox to be set to true when updating. Can be
   * extended from plugins.
   */
  propsRequireDirtyBox: [
    "backgroundColor",
    "borderColor",
    "borderWidth",
    "borderRadius",
    "plotBackgroundColor",
    "plotBackgroundImage",
    "plotBorderColor",
    "plotBorderWidth",
    "plotShadow",
    "shadow"
  ],
  /**
   * These properties require a full reflow of chart elements, best
   * implemented through running `Chart.setSize` internally (#8190).
   * @type {Array}
   */
  propsRequireReflow: [
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "spacing",
    "spacingTop",
    "spacingRight",
    "spacingBottom",
    "spacingLeft"
  ],
  /**
   * These properties cause all series to be updated when updating. Can be
   * extended from plugins.
   */
  propsRequireUpdateSeries: [
    "chart.inverted",
    "chart.polar",
    "chart.ignoreHiddenSeries",
    "chart.type",
    "colors",
    "plotOptions",
    "time",
    "tooltip"
  ]
});
var Chart_default = Chart;

// node_modules/highcharts/es-modules/Core/Legend/LegendSymbol.js
var merge17 = Utilities_default.merge;
var pick22 = Utilities_default.pick;
var LegendSymbol;
(function(LegendSymbol2) {
  function drawLineMarker(legend) {
    var options = this.options, symbolWidth = legend.symbolWidth, symbolHeight = legend.symbolHeight, generalRadius = symbolHeight / 2, renderer = this.chart.renderer, legendItemGroup = this.legendGroup, verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3);
    var attr11 = {}, legendSymbol, markerOptions = options.marker;
    if (!this.chart.styledMode) {
      attr11 = {
        "stroke-width": options.lineWidth || 0
      };
      if (options.dashStyle) {
        attr11.dashstyle = options.dashStyle;
      }
    }
    this.legendLine = renderer.path([
      ["M", 0, verticalCenter],
      ["L", symbolWidth, verticalCenter]
    ]).addClass("highcharts-graph").attr(attr11).add(legendItemGroup);
    if (markerOptions && markerOptions.enabled !== false && symbolWidth) {
      var radius = Math.min(pick22(markerOptions.radius, generalRadius), generalRadius);
      if (this.symbol.indexOf("url") === 0) {
        markerOptions = merge17(markerOptions, {
          width: symbolHeight,
          height: symbolHeight
        });
        radius = 0;
      }
      this.legendSymbol = legendSymbol = renderer.symbol(this.symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius, markerOptions).addClass("highcharts-point").add(legendItemGroup);
      legendSymbol.isMarker = true;
    }
  }
  LegendSymbol2.drawLineMarker = drawLineMarker;
  function drawRectangle(legend, item) {
    var options = legend.options, symbolHeight = legend.symbolHeight, square = options.squareSymbol, symbolWidth = square ? symbolHeight : legend.symbolWidth;
    item.legendSymbol = this.chart.renderer.rect(
      square ? (legend.symbolWidth - symbolHeight) / 2 : 0,
      legend.baseline - symbolHeight + 1,
      // #3988
      symbolWidth,
      symbolHeight,
      pick22(legend.options.symbolRadius, symbolHeight / 2)
    ).addClass("highcharts-point").attr({
      zIndex: 3
    }).add(item.legendGroup);
  }
  LegendSymbol2.drawRectangle = drawRectangle;
})(LegendSymbol || (LegendSymbol = {}));
var LegendSymbol_default = LegendSymbol;

// node_modules/highcharts/es-modules/Core/Series/SeriesDefaults.js
var seriesDefaults = {
  // base series options
  /**
   * The SVG value used for the `stroke-linecap` and `stroke-linejoin`
   * of a line graph. Round means that lines are rounded in the ends and
   * bends.
   *
   * @type       {Highcharts.SeriesLinecapValue}
   * @default    round
   * @since      3.0.7
   * @apioption  plotOptions.line.linecap
   */
  /**
   * Pixel width of the graph line.
   *
   * @see In styled mode, the line stroke-width can be set with the
   *      `.highcharts-graph` class name.
   *
   * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/
   *         On all series
   * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/
   *         On one single series
   *
   * @product highcharts highstock
   *
   * @private
   */
  lineWidth: 2,
  /**
   * For some series, there is a limit that shuts down initial animation
   * by default when the total number of points in the chart is too high.
   * For example, for a column chart and its derivatives, animation does
   * not run if there is more than 250 points totally. To disable this
   * cap, set `animationLimit` to `Infinity`.
   *
   * @type      {number}
   * @apioption plotOptions.series.animationLimit
   */
  /**
   * Allow this series' points to be selected by clicking on the graphic
   * (columns, point markers, pie slices, map areas etc).
   *
   * The selected points can be handled by point select and unselect
   * events, or collectively by the [getSelectedPoints
   * ](/class-reference/Highcharts.Chart#getSelectedPoints) function.
   *
   * And alternative way of selecting points is through dragging.
   *
   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
   *         Line
   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
   *         Column
   * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
   *         Pie
   * @sample {highcharts} highcharts/chart/events-selection-points/
   *         Select a range of points through a drag selection
   * @sample {highmaps} maps/plotoptions/series-allowpointselect/
   *         Map area
   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
   *         Map bubble
   *
   * @since 1.2.0
   *
   * @private
   */
  allowPointSelect: false,
  /**
   * When true, each point or column edge is rounded to its nearest pixel
   * in order to render sharp on screen. In some cases, when there are a
   * lot of densely packed columns, this leads to visible difference
   * in column widths or distance between columns. In these cases,
   * setting `crisp` to `false` may look better, even though each column
   * is rendered blurry.
   *
   * @sample {highcharts} highcharts/plotoptions/column-crisp-false/
   *         Crisp is false
   *
   * @since   5.0.10
   * @product highcharts highstock gantt
   *
   * @private
   */
  crisp: true,
  /**
   * If true, a checkbox is displayed next to the legend item to allow
   * selecting the series. The state of the checkbox is determined by
   * the `selected` option.
   *
   * @productdesc {highmaps}
   * Note that if a `colorAxis` is defined, the color axis is represented
   * in the legend, not the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
   *         Show select box
   *
   * @since 1.2.0
   *
   * @private
   */
  showCheckbox: false,
  /**
   * Enable or disable the initial animation when a series is displayed.
   * The animation can also be set as a configuration object. Please
   * note that this option only applies to the initial animation of the
   * series itself. For other animations, see [chart.animation](
   * #chart.animation) and the animation parameter under the API methods.
   * The following properties are supported:
   *
   * - `defer`: The animation delay time in milliseconds.
   *
   * - `duration`: The duration of the animation in milliseconds.
   *
   * - `easing`: Can be a string reference to an easing function set on
   *   the `Math` object or a function. See the _Custom easing function_
   *   demo below.
   *
   * Due to poor performance, animation is disabled in old IE browsers
   * for several chart types.
   *
   * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
   *         Animation disabled
   * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
   *         Slower animation
   * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
   *         Custom easing function
   * @sample {highstock} stock/plotoptions/animation-slower/
   *         Slower animation
   * @sample {highstock} stock/plotoptions/animation-easing/
   *         Custom easing function
   * @sample {highmaps} maps/plotoptions/series-animation-true/
   *         Animation enabled on map series
   * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
   *         Disabled on mapbubble series
   *
   * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}
   * @default {highcharts} true
   * @default {highstock} true
   * @default {highmaps} false
   *
   * @private
   */
  animation: {
    /** @internal */
    duration: 1e3
  },
  /**
   * @default   0
   * @type      {number}
   * @since     8.2.0
   * @apioption plotOptions.series.animation.defer
   */
  /**
   * An additional class name to apply to the series' graphical elements.
   * This option does not replace default class names of the graphical
   * element.
   *
   * @type      {string}
   * @since     5.0.0
   * @apioption plotOptions.series.className
   */
  /**
   * Disable this option to allow series rendering in the whole plotting
   * area.
   *
   * **Note:** Clipping should be always enabled when
   * [chart.zoomType](#chart.zoomType) is set
   *
   * @sample {highcharts} highcharts/plotoptions/series-clip/
   *         Disabled clipping
   *
   * @default   true
   * @type      {boolean}
   * @since     3.0.0
   * @apioption plotOptions.series.clip
   */
  /**
   * The main color of the series. In line type series it applies to the
   * line and the point markers unless otherwise specified. In bar type
   * series it applies to the bars unless a color is specified per point.
   * The default value is pulled from the `options.colors` array.
   *
   * In styled mode, the color can be defined by the
   * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
   * color can be set with the `.highcharts-series`,
   * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
   * `.highcharts-series-{n}` class, or individual classes given by the
   * `className` option.
   *
   * @productdesc {highmaps}
   * In maps, the series color is rarely used, as most choropleth maps use
   * the color to denote the value of each point. The series color can
   * however be used in a map with multiple series holding categorized
   * data.
   *
   * @sample {highcharts} highcharts/plotoptions/series-color-general/
   *         General plot option
   * @sample {highcharts} highcharts/plotoptions/series-color-specific/
   *         One specific series
   * @sample {highcharts} highcharts/plotoptions/series-color-area/
   *         Area color
   * @sample {highcharts} highcharts/series/infographic/
   *         Pattern fill
   * @sample {highmaps} maps/demo/category-map/
   *         Category map by multiple series
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @apioption plotOptions.series.color
   */
  /**
   * Styled mode only. A specific color index to use for the series, so
   * its graphic representations are given the class name
   * `highcharts-color-{n}`.
   *
   * @type      {number}
   * @since     5.0.0
   * @apioption plotOptions.series.colorIndex
   */
  /**
   * Whether to connect a graph line across null points, or render a gap
   * between the two points on either side of the null.
   *
   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
   *         False by default
   * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
   *         True
   *
   * @type      {boolean}
   * @default   false
   * @product   highcharts highstock
   * @apioption plotOptions.series.connectNulls
   */
  /**
   * You can set the cursor to "pointer" if you have click events attached
   * to the series, to signal to the user that the points and lines can
   * be clicked.
   *
   * In styled mode, the series cursor can be set with the same classes
   * as listed under [series.color](#plotOptions.series.color).
   *
   * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
   *         On line graph
   * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
   *         On columns
   * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
   *         On scatter markers
   * @sample {highstock} stock/plotoptions/cursor/
   *         Pointer on a line graph
   * @sample {highmaps} maps/plotoptions/series-allowpointselect/
   *         Map area
   * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
   *         Map bubble
   *
   * @type      {string|Highcharts.CursorValue}
   * @apioption plotOptions.series.cursor
   */
  /**
   * A reserved subspace to store options and values for customized
   * functionality. Here you can add additional data for your own event
   * callbacks and formatter callbacks.
   *
   * @sample {highcharts} highcharts/point/custom/
   *         Point and series with custom data
   *
   * @type      {Highcharts.Dictionary<*>}
   * @apioption plotOptions.series.custom
   */
  /**
   * Name of the dash style to use for the graph, or for some series types
   * the outline of each shape.
   *
   * In styled mode, the
   * [stroke dash-array](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-dashstyle/)
   * can be set with the same classes as listed under
   * [series.color](#plotOptions.series.color).
   *
   * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
   *         Possible values demonstrated
   * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
   *         Chart suitable for printing in black and white
   * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
   *         Possible values demonstrated
   * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
   *         Possible values demonstrated
   * @sample {highmaps} maps/plotoptions/series-dashstyle/
   *         Dotted borders on a map
   *
   * @type      {Highcharts.DashStyleValue}
   * @default   Solid
   * @since     2.1
   * @apioption plotOptions.series.dashStyle
   */
  /**
   * A description of the series to add to the screen reader information
   * about the series.
   *
   * @type      {string}
   * @since     5.0.0
   * @requires  modules/accessibility
   * @apioption plotOptions.series.description
   */
  /**
   * Options for the series data sorting.
   *
   * @type      {Highcharts.DataSortingOptionsObject}
   * @since     8.0.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.dataSorting
   */
  /**
   * Enable or disable data sorting for the series. Use [xAxis.reversed](
   * #xAxis.reversed) to change the sorting order.
   *
   * @sample {highcharts} highcharts/datasorting/animation/
   *         Data sorting in scatter-3d
   * @sample {highcharts} highcharts/datasorting/labels-animation/
   *         Axis labels animation
   * @sample {highcharts} highcharts/datasorting/dependent-sorting/
   *         Dependent series sorting
   * @sample {highcharts} highcharts/datasorting/independent-sorting/
   *         Independent series sorting
   *
   * @type      {boolean}
   * @since     8.0.0
   * @apioption plotOptions.series.dataSorting.enabled
   */
  /**
   * Whether to allow matching points by name in an update. If this option
   * is disabled, points will be matched by order.
   *
   * @sample {highcharts} highcharts/datasorting/match-by-name/
   *         Enabled match by name
   *
   * @type      {boolean}
   * @since     8.0.0
   * @apioption plotOptions.series.dataSorting.matchByName
   */
  /**
   * Determines what data value should be used to sort by.
   *
   * @sample {highcharts} highcharts/datasorting/sort-key/
   *         Sort key as `z` value
   *
   * @type      {string}
   * @since     8.0.0
   * @default   y
   * @apioption plotOptions.series.dataSorting.sortKey
   */
  /**
   * Enable or disable the mouse tracking for a specific series. This
   * includes point tooltips and click events on graphs and points. For
   * large datasets it improves performance.
   *
   * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/
   *         No mouse tracking
   * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/
   *         No mouse tracking
   *
   * @type      {boolean}
   * @default   true
   * @apioption plotOptions.series.enableMouseTracking
   */
  /**
   * Whether to use the Y extremes of the total chart width or only the
   * zoomed area when zooming in on parts of the X axis. By default, the
   * Y axis adjusts to the min and max of the visible data. Cartesian
   * series only.
   *
   * @type      {boolean}
   * @default   false
   * @since     4.1.6
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.getExtremesFromAll
   */
  /**
   * An array specifying which option maps to which key in the data point
   * array. This makes it convenient to work with unstructured data arrays
   * from different sources.
   *
   * @see [series.data](#series.line.data)
   *
   * @sample {highcharts|highstock} highcharts/series/data-keys/
   *         An extended data array with keys
   * @sample {highcharts|highstock} highcharts/series/data-nested-keys/
   *         Nested keys used to access object properties
   *
   * @type      {Array<string>}
   * @since     4.1.6
   * @apioption plotOptions.series.keys
   */
  /**
   * The line cap used for line ends and line joins on the graph.
   *
   * @type       {Highcharts.SeriesLinecapValue}
   * @default    round
   * @product    highcharts highstock
   * @apioption  plotOptions.series.linecap
   */
  /**
   * The [id](#series.id) of another series to link to. Additionally,
   * the value can be ":previous" to link to the previous series. When
   * two series are linked, only the first one appears in the legend.
   * Toggling the visibility of this also toggles the linked series.
   *
   * If master series uses data sorting and linked series does not have
   * its own sorting definition, the linked series will be sorted in the
   * same order as the master one.
   *
   * @sample {highcharts|highstock} highcharts/demo/arearange-line/
   *         Linked series
   *
   * @type      {string}
   * @since     3.0
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.linkedTo
   */
  /**
   * Options for the corresponding navigator series if `showInNavigator`
   * is `true` for this series. Available options are the same as any
   * series, documented at [plotOptions](#plotOptions.series) and
   * [series](#series).
   *
   * These options are merged with options in [navigator.series](
   * #navigator.series), and will take precedence if the same option is
   * defined both places.
   *
   * @see [navigator.series](#navigator.series)
   *
   * @type      {Highcharts.PlotSeriesOptions}
   * @since     5.0.0
   * @product   highstock
   * @apioption plotOptions.series.navigatorOptions
   */
  /**
   * The color for the parts of the graph or points that are below the
   * [threshold](#plotOptions.series.threshold). Note that `zones` takes
   * precedence over the negative color. Using `negativeColor` is
   * equivalent to applying a zone with value of 0.
   *
   * @see In styled mode, a negative color is applied by setting this option
   *      to `true` combined with the `.highcharts-negative` class name.
   *
   * @sample {highcharts} highcharts/plotoptions/series-negative-color/
   *         Spline, area and column
   * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/
   *         Arearange
   * @sample {highcharts} highcharts/css/series-negative-color/
   *         Styled mode
   * @sample {highstock} highcharts/plotoptions/series-negative-color/
   *         Spline, area and column
   * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/
   *         Arearange
   * @sample {highmaps} highcharts/plotoptions/series-negative-color/
   *         Spline, area and column
   * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/
   *         Arearange
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     3.0
   * @apioption plotOptions.series.negativeColor
   */
  /**
   * Same as
   * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),
   * but for an individual series. Overrides the chart wide configuration.
   *
   * @type      {Function}
   * @since     5.0.12
   * @apioption plotOptions.series.pointDescriptionFormatter
   */
  /**
   * If no x values are given for the points in a series, `pointInterval`
   * defines the interval of the x values. For example, if a series
   * contains one value every decade starting from year 0, set
   * `pointInterval` to `10`. In true `datetime` axes, the `pointInterval`
   * is set in milliseconds.
   *
   * It can be also be combined with `pointIntervalUnit` to draw irregular
   * time intervals.
   *
   * If combined with `relativeXValue`, an x value can be set on each
   * point, and the `pointInterval` is added x times to the `pointStart`
   * setting.
   *
   * Please note that this options applies to the _series data_, not the
   * interval of the axis ticks, which is independent.
   *
   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
   *         Datetime X axis
   * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
   *         Relative x value
   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
   *         Using pointStart and pointInterval
   * @sample {highstock} stock/plotoptions/relativexvalue/
   *         Relative x value
   *
   * @type      {number}
   * @default   1
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.pointInterval
   */
  /**
   * On datetime series, this allows for setting the
   * [pointInterval](#plotOptions.series.pointInterval) to irregular time
   * units, `day`, `month` and `year`. A day is usually the same as 24
   * hours, but `pointIntervalUnit` also takes the DST crossover into
   * consideration when dealing with local time. Combine this option with
   * `pointInterval` to draw weeks, quarters, 6 months, 10 years etc.
   *
   * Please note that this options applies to the _series data_, not the
   * interval of the axis ticks, which is independent.
   *
   * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/
   *         One point a month
   * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/
   *         One point a month
   *
   * @type       {string}
   * @since      4.1.0
   * @product    highcharts highstock gantt
   * @validvalue ["day", "month", "year"]
   * @apioption  plotOptions.series.pointIntervalUnit
   */
  /**
   * Possible values: `"on"`, `"between"`, `number`.
   *
   * In a column chart, when pointPlacement is `"on"`, the point will not
   * create any padding of the X axis. In a polar column chart this means
   * that the first column points directly north. If the pointPlacement is
   * `"between"`, the columns will be laid out between ticks. This is
   * useful for example for visualising an amount between two points in
   * time or in a certain sector of a polar chart.
   *
   * Since Highcharts 3.0.2, the point placement can also be numeric,
   * where 0 is on the axis value, -0.5 is between this value and the
   * previous, and 0.5 is between this value and the next. Unlike the
   * textual options, numeric point placement options won't affect axis
   * padding.
   *
   * Note that pointPlacement needs a [pointRange](
   * #plotOptions.series.pointRange) to work. For column series this is
   * computed, but for line-type series it needs to be set.
   *
   * For the `xrange` series type and gantt charts, if the Y axis is a
   * category axis, the `pointPlacement` applies to the Y axis rather than
   * the (typically datetime) X axis.
   *
   * Defaults to `undefined` in cartesian charts, `"between"` in polar
   * charts.
   *
   * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
   *
   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/
   *         Between in a column chart
   * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/
   *         Numeric placement for custom layout
   * @sample {highcharts|highstock} maps/plotoptions/heatmap-pointplacement/
   *         Placement in heatmap
   *
   * @type      {string|number}
   * @since     2.3.0
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.pointPlacement
   */
  /**
   * If no x values are given for the points in a series, pointStart
   * defines on what value to start. For example, if a series contains one
   * yearly value starting from 1945, set pointStart to 1945.
   *
   * If combined with `relativeXValue`, an x value can be set on each
   * point. The x value from the point options is multiplied by
   * `pointInterval` and added to `pointStart` to produce a modified x
   * value.
   *
   * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/
   *         Linear
   * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
   *         Datetime
   * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
   *         Relative x value
   * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
   *         Using pointStart and pointInterval
   * @sample {highstock} stock/plotoptions/relativexvalue/
   *         Relative x value
   *
   * @type      {number}
   * @default   0
   * @product   highcharts highstock gantt
   * @apioption plotOptions.series.pointStart
   */
  /**
   * When true, X values in the data set are relative to the current
   * `pointStart`, `pointInterval` and `pointIntervalUnit` settings. This
   * allows compression of the data for datasets with irregular X values.
   *
   * The real X values are computed on the formula `f(x) = ax + b`, where
   * `a` is the `pointInterval` (optionally with a time unit given by
   * `pointIntervalUnit`), and `b` is the `pointStart`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
   *         Relative X value
   * @sample {highstock} stock/plotoptions/relativexvalue/
   *         Relative X value
   *
   * @type      {boolean}
   * @default   false
   * @product   highcharts highstock
   * @apioption plotOptions.series.relativeXValue
   */
  /**
   * Whether to select the series initially. If `showCheckbox` is true,
   * the checkbox next to the series name in the legend will be checked
   * for a selected series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-selected/
   *         One out of two series selected
   *
   * @type      {boolean}
   * @default   false
   * @since     1.2.0
   * @apioption plotOptions.series.selected
   */
  /**
   * Whether to apply a drop shadow to the graph line. Since 2.3 the
   * shadow can be an object configuration containing `color`, `offsetX`,
   * `offsetY`, `opacity` and `width`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-shadow/
   *         Shadow enabled
   *
   * @type      {boolean|Highcharts.ShadowOptionsObject}
   * @default   false
   * @apioption plotOptions.series.shadow
   */
  /**
   * Whether to display this particular series or series type in the
   * legend. Standalone series are shown in legend by default, and linked
   * series are not. Since v7.2.0 it is possible to show series that use
   * colorAxis by setting this option to `true`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
   *         One series in the legend, one hidden
   *
   * @type      {boolean}
   * @apioption plotOptions.series.showInLegend
   */
  /**
   * Whether or not to show the series in the navigator. Takes precedence
   * over [navigator.baseSeries](#navigator.baseSeries) if defined.
   *
   * @type      {boolean}
   * @since     5.0.0
   * @product   highstock
   * @apioption plotOptions.series.showInNavigator
   */
  /**
   * If set to `true`, the accessibility module will skip past the points
   * in this series for keyboard navigation.
   *
   * @type      {boolean}
   * @since     5.0.12
   * @apioption plotOptions.series.skipKeyboardNavigation
   */
  /**
   * Whether to stack the values of each series on top of each other.
   * Possible values are `undefined` to disable, `"normal"` to stack by
   * value or `"percent"`.
   *
   * When stacking is enabled, data must be sorted
   * in ascending X order.
   *
   * Some stacking options are related to specific series types. In the
   * streamgraph series type, the stacking option is set to `"stream"`.
   * The second one is `"overlap"`, which only applies to waterfall
   * series.
   *
   * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
   *
   * @sample {highcharts} highcharts/plotoptions/series-stacking-line/
   *         Line
   * @sample {highcharts} highcharts/plotoptions/series-stacking-column/
   *         Column
   * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/
   *         Bar
   * @sample {highcharts} highcharts/plotoptions/series-stacking-area/
   *         Area
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/
   *         Line
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/
   *         Column
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/
   *         Bar
   * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/
   *         Area
   * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-normal-stacking
   *         Waterfall with normal stacking
   * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-overlap-stacking
   *         Waterfall with overlap stacking
   * @sample {highstock} stock/plotoptions/stacking/
   *         Area
   *
   * @type       {string}
   * @product    highcharts highstock
   * @validvalue ["normal", "overlap", "percent", "stream"]
   * @apioption  plotOptions.series.stacking
   */
  /**
   * Whether to apply steps to the line. Possible values are `left`,
   * `center` and `right`.
   *
   * @sample {highcharts} highcharts/plotoptions/line-step/
   *         Different step line options
   * @sample {highcharts} highcharts/plotoptions/area-step/
   *         Stepped, stacked area
   * @sample {highstock} stock/plotoptions/line-step/
   *         Step line
   *
   * @type       {string}
   * @since      1.2.5
   * @product    highcharts highstock
   * @validvalue ["left", "center", "right"]
   * @apioption  plotOptions.series.step
   */
  /**
   * The threshold, also called zero level or base level. For line type
   * series this is only used in conjunction with
   * [negativeColor](#plotOptions.series.negativeColor).
   *
   * @see [softThreshold](#plotOptions.series.softThreshold).
   *
   * @type      {number|null}
   * @default   0
   * @since     3.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.threshold
   */
  /**
   * Set the initial visibility of the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-visible/
   *         Two series, one hidden and one visible
   * @sample {highstock} stock/plotoptions/series-visibility/
   *         Hidden series
   *
   * @type      {boolean}
   * @default   true
   * @apioption plotOptions.series.visible
   */
  /**
   * Defines the Axis on which the zones are applied.
   *
   * @see [zones](#plotOptions.series.zones)
   *
   * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/
   *         Zones on the X-Axis
   * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/
   *         Zones on the X-Axis
   *
   * @type      {string}
   * @default   y
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zoneAxis
   */
  /**
   * General event handlers for the series items. These event hooks can
   * also be attached to the series at run time using the
   * `Highcharts.addEvent` function.
   *
   * @declare Highcharts.SeriesEventsOptionsObject
   *
   * @private
   */
  events: {},
  /**
   * Fires after the series has finished its initial animation, or in case
   * animation is disabled, immediately as the series is displayed.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/
   *         Show label after animate
   * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/
   *         Show label after animate
   *
   * @type      {Highcharts.SeriesAfterAnimateCallbackFunction}
   * @since     4.0
   * @product   highcharts highstock gantt
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.afterAnimate
   */
  /**
   * Fires when the checkbox next to the series' name in the legend is
   * clicked. One parameter, `event`, is passed to the function. The state
   * of the checkbox is found by `event.checked`. The checked item is
   * found by `event.item`. Return `false` to prevent the default action
   * which is to toggle the select state of the series.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
   *         Alert checkbox status
   *
   * @type      {Highcharts.SeriesCheckboxClickCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.checkboxClick
   */
  /**
   * Fires when the series is clicked. One parameter, `event`, is passed
   * to the function, containing common event information. Additionally,
   * `event.point` holds a pointer to the nearest point on the graph.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-click/
   *         Alert click info
   * @sample {highstock} stock/plotoptions/series-events-click/
   *         Alert click info
   * @sample {highmaps} maps/plotoptions/series-events-click/
   *         Display click info in subtitle
   *
   * @type      {Highcharts.SeriesClickCallbackFunction}
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.click
   */
  /**
   * Fires when the series is hidden after chart generation time, either
   * by clicking the legend item or by calling `.hide()`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-hide/
   *         Alert when the series is hidden by clicking the legend item
   *
   * @type      {Highcharts.SeriesHideCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.hide
   */
  /**
   * Fires when the legend item belonging to the series is clicked. One
   * parameter, `event`, is passed to the function. The default action
   * is to toggle the visibility of the series. This can be prevented
   * by returning `false` or calling `event.preventDefault()`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-legenditemclick/
   *         Confirm hiding and showing
   *
   * @type      {Highcharts.SeriesLegendItemClickCallbackFunction}
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.legendItemClick
   */
  /**
   * Fires when the mouse leaves the graph. One parameter, `event`, is
   * passed to the function, containing common event information. If the
   * [stickyTracking](#plotOptions.series) option is true, `mouseOut`
   * doesn't happen before the mouse enters another graph or leaves the
   * plot area.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
   *         With sticky tracking by default
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
   *         Without sticky tracking
   *
   * @type      {Highcharts.SeriesMouseOutCallbackFunction}
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.mouseOut
   */
  /**
   * Fires when the mouse enters the graph. One parameter, `event`, is
   * passed to the function, containing common event information.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
   *         With sticky tracking by default
   * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
   *         Without sticky tracking
   *
   * @type      {Highcharts.SeriesMouseOverCallbackFunction}
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.mouseOver
   */
  /**
   * Fires when the series is shown after chart generation time, either
   * by clicking the legend item or by calling `.show()`.
   *
   * @sample {highcharts} highcharts/plotoptions/series-events-show/
   *         Alert when the series is shown by clicking the legend item.
   *
   * @type      {Highcharts.SeriesShowCallbackFunction}
   * @since     1.2.0
   * @context   Highcharts.Series
   * @apioption plotOptions.series.events.show
   */
  /**
   * Options for the point markers of line-like series. Properties like
   * `fillColor`, `lineColor` and `lineWidth` define the visual appearance
   * of the markers. Other series types, like column series, don't have
   * markers, but have visual options on the series level instead.
   *
   * In styled mode, the markers can be styled with the
   * `.highcharts-point`, `.highcharts-point-hover` and
   * `.highcharts-point-select` class names.
   *
   * @declare Highcharts.PointMarkerOptionsObject
   *
   * @private
   */
  marker: {
    /**
     * Enable or disable the point marker. If `undefined`, the markers
     * are hidden when the data is dense, and shown for more widespread
     * data points.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/
     *         Disabled markers
     * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/
     *         Disabled in normal state but enabled on hover
     * @sample {highstock} stock/plotoptions/series-marker/
     *         Enabled markers
     *
     * @type      {boolean}
     * @default   {highcharts} undefined
     * @default   {highstock} false
     * @apioption plotOptions.series.marker.enabled
     */
    /**
     * The threshold for how dense the point markers should be before
     * they are hidden, given that `enabled` is not defined. The number
     * indicates the horizontal distance between the two closest points
     * in the series, as multiples of the `marker.radius`. In other
     * words, the default value of 2 means points are hidden if
     * overlapping horizontally.
     *
     * @sample highcharts/plotoptions/series-marker-enabledthreshold
     *         A higher threshold
     *
     * @since 6.0.5
     */
    enabledThreshold: 2,
    /**
     * The fill color of the point marker. When `undefined`, the series'
     * or point's color is used.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
     *         White fill
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption plotOptions.series.marker.fillColor
     */
    /**
     * Image markers only. Set the image width explicitly. When using
     * this option, a `width` must also be set.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     *
     * @type      {number}
     * @since     4.0.4
     * @apioption plotOptions.series.marker.height
     */
    /**
     * The color of the point marker's outline. When `undefined`, the
     * series' or point's color is used.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
     *         Inherit from series color (undefined)
     *
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    lineColor: Palette_default.backgroundColor,
    /**
     * The width of the point marker's outline.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
     *         2px blue marker
     */
    lineWidth: 0,
    /**
     * The radius of the point marker.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-radius/
     *         Bigger markers
     *
     * @default {highstock} 2
     * @default {highcharts} 4
     *
     */
    radius: 4,
    /**
     * A predefined shape or symbol for the marker. When undefined, the
     * symbol is pulled from options.symbols. Other possible values are
     * `'circle'`, `'square'`,`'diamond'`, `'triangle'` and
     * `'triangle-down'`.
     *
     * Additionally, the URL to a graphic can be given on this form:
     * `'url(graphic.png)'`. Note that for the image to be applied to
     * exported charts, its URL needs to be accessible by the export
     * server.
     *
     * Custom callbacks for symbol path generation can also be added to
     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
     * used by its method name, as shown in the demo.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
     *         Predefined, graphic and custom markers
     * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
     *         Predefined, graphic and custom markers
     *
     * @type      {string}
     * @apioption plotOptions.series.marker.symbol
     */
    /**
     * Image markers only. Set the image width explicitly. When using
     * this option, a `height` must also be set.
     *
     * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
     *         Fixed width and height
     *
     * @type      {number}
     * @since     4.0.4
     * @apioption plotOptions.series.marker.width
     */
    /**
     * States for a single point marker.
     *
     * @declare Highcharts.PointStatesOptionsObject
     */
    states: {
      /**
       * The normal state of a single point marker. Currently only
       * used for setting animation when returning to normal state
       * from hover.
       *
       * @declare Highcharts.PointStatesNormalOptionsObject
       */
      normal: {
        /**
         * Animation when returning to normal state after hovering.
         *
         * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
         */
        animation: true
      },
      /**
       * The hover state for a single point marker.
       *
       * @declare Highcharts.PointStatesHoverOptionsObject
       */
      hover: {
        /**
         * Animation when hovering over the marker.
         *
         * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
         */
        animation: {
          /** @internal */
          duration: 50
        },
        /**
         * Enable or disable the point marker.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/
         *         Disabled hover state
         */
        enabled: true,
        /**
         * The fill color of the marker in hover state. When
         * `undefined`, the series' or point's fillColor for normal
         * state is used.
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption plotOptions.series.marker.states.hover.fillColor
         */
        /**
         * The color of the point marker's outline. When
         * `undefined`, the series' or point's lineColor for normal
         * state is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/
         *         White fill color, black line color
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption plotOptions.series.marker.states.hover.lineColor
         */
        /**
         * The width of the point marker's outline. When
         * `undefined`, the series' or point's lineWidth for normal
         * state is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/
         *         3px line width
         *
         * @type      {number}
         * @apioption plotOptions.series.marker.states.hover.lineWidth
         */
        /**
         * The radius of the point marker. In hover state, it
         * defaults to the normal state's radius + 2 as per the
         * [radiusPlus](#plotOptions.series.marker.states.hover.radiusPlus)
         * option.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/
         *         10px radius
         *
         * @type      {number}
         * @apioption plotOptions.series.marker.states.hover.radius
         */
        /**
         * The number of pixels to increase the radius of the
         * hovered point.
         *
         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         5 pixels greater radius on hover
         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         5 pixels greater radius on hover
         *
         * @since 4.0.3
         */
        radiusPlus: 2,
        /**
         * The additional line width for a hovered point.
         *
         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         2 pixels wider on hover
         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
         *         2 pixels wider on hover
         *
         * @since 4.0.3
         */
        lineWidthPlus: 1
      },
      /**
       * The appearance of the point marker when selected. In order to
       * allow a point to be selected, set the
       * `series.allowPointSelect` option to true.
       *
       * @declare Highcharts.PointStatesSelectOptionsObject
       */
      select: {
        /**
         * Enable or disable visible feedback for selection.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-enabled/
         *         Disabled select state
         *
         * @type      {boolean}
         * @default   true
         * @apioption plotOptions.series.marker.states.select.enabled
         */
        /**
         * The radius of the point marker. In hover state, it
         * defaults to the normal state's radius + 2.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-radius/
         *         10px radius for selected points
         *
         * @type      {number}
         * @apioption plotOptions.series.marker.states.select.radius
         */
        /**
         * The fill color of the point marker.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/
         *         Solid red discs for selected points
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        fillColor: Palette_default.neutralColor20,
        /**
         * The color of the point marker's outline. When
         * `undefined`, the series' or point's color is used.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/
         *         Red line color for selected points
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        lineColor: Palette_default.neutralColor100,
        /**
         * The width of the point marker's outline.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/
         *         3px line width for selected points
         */
        lineWidth: 2
      }
    }
  },
  /**
   * Properties for each single point.
   *
   * @declare Highcharts.PlotSeriesPointOptions
   *
   * @private
   */
  point: {
    /**
     * Fires when a point is clicked. One parameter, `event`, is passed
     * to the function, containing common event information.
     *
     * If the `series.allowPointSelect` option is true, the default
     * action for the point's click event is to toggle the point's
     * select state. Returning `false` cancels this action.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-click/
     *         Click marker to alert values
     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/
     *         Click column
     * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/
     *         Go to URL
     * @sample {highmaps} maps/plotoptions/series-point-events-click/
     *         Click marker to display values
     * @sample {highmaps} maps/plotoptions/series-point-events-click-url/
     *         Go to URL
     *
     * @type      {Highcharts.PointClickCallbackFunction}
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.click
     */
    /**
     * Fires when the mouse leaves the area close to the point. One
     * parameter, `event`, is passed to the function, containing common
     * event information.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
     *         Show values in the chart's corner on mouse over
     *
     * @type      {Highcharts.PointMouseOutCallbackFunction}
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.mouseOut
     */
    /**
     * Fires when the mouse enters the area close to the point. One
     * parameter, `event`, is passed to the function, containing common
     * event information.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
     *         Show values in the chart's corner on mouse over
     *
     * @type      {Highcharts.PointMouseOverCallbackFunction}
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.mouseOver
     */
    /**
     * Fires when the point is removed using the `.remove()` method. One
     * parameter, `event`, is passed to the function. Returning `false`
     * cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/
     *         Remove point and confirm
     *
     * @type      {Highcharts.PointRemoveCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.remove
     */
    /**
     * Fires when the point is selected either programmatically or
     * following a click on the point. One parameter, `event`, is passed
     * to the function. Returning `false` cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-select/
     *         Report the last selected point
     * @sample {highmaps} maps/plotoptions/series-allowpointselect/
     *         Report select and unselect
     *
     * @type      {Highcharts.PointSelectCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.select
     */
    /**
     * Fires when the point is unselected either programmatically or
     * following a click on the point. One parameter, `event`, is passed
     * to the function.
     *  Returning `false` cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/
     *         Report the last unselected point
     * @sample {highmaps} maps/plotoptions/series-allowpointselect/
     *         Report select and unselect
     *
     * @type      {Highcharts.PointUnselectCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.unselect
     */
    /**
     * Fires when the point is updated programmatically through the
     * `.update()` method. One parameter, `event`, is passed to the
     * function. The new point options can be accessed through
     * `event.options`. Returning `false` cancels the operation.
     *
     * @sample {highcharts} highcharts/plotoptions/series-point-events-update/
     *         Confirm point updating
     *
     * @type      {Highcharts.PointUpdateCallbackFunction}
     * @since     1.2.0
     * @context   Highcharts.Point
     * @apioption plotOptions.series.point.events.update
     */
    /**
     * Events for each single point.
     *
     * @declare Highcharts.PointEventsOptionsObject
     */
    events: {}
  },
  /**
   * Options for the series data labels, appearing next to each data
   * point.
   *
   * Since v6.2.0, multiple data labels can be applied to each single
   * point by defining them as an array of configs.
   *
   * In styled mode, the data labels can be styled with the
   * `.highcharts-data-label-box` and `.highcharts-data-label` class names
   * ([see example](https://www.highcharts.com/samples/highcharts/css/series-datalabels)).
   *
   * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled
   *         Data labels enabled
   * @sample {highcharts} highcharts/plotoptions/series-datalabels-multiple
   *         Multiple data labels on a bar series
   * @sample {highcharts} highcharts/css/series-datalabels
   *         Style mode example
   *
   * @type    {*|Array<*>}
   * @product highcharts highstock highmaps gantt
   *
   * @private
   */
  dataLabels: {
    /**
     * Enable or disable the initial animation when a series is
     * displayed for the `dataLabels`. The animation can also be set as
     * a configuration object. Please note that this option only
     * applies to the initial animation.
     * For other animations, see [chart.animation](#chart.animation)
     * and the animation parameter under the API methods.
     * The following properties are supported:
     *
     * - `defer`: The animation delay time in milliseconds.
     *
     * @sample {highcharts} highcharts/plotoptions/animation-defer/
     *          Animation defer settings
     *
     * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
     * @since     8.2.0
     * @apioption plotOptions.series.dataLabels.animation
     */
    animation: {},
    /**
     * The animation delay time in milliseconds.
     * Set to `0` renders dataLabel immediately.
     * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
     *
     * @type      {number}
     * @since     8.2.0
     * @apioption plotOptions.series.dataLabels.animation.defer
     */
    /**
     * The alignment of the data label compared to the point. If
     * `right`, the right side of the label should be touching the
     * point. For points with an extent, like columns, the alignments
     * also dictates how to align it inside the box, as given with the
     * [inside](#plotOptions.column.dataLabels.inside)
     * option. Can be one of `left`, `center` or `right`.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/
     *         Left aligned
     * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
     *         Data labels inside the bar
     *
     * @type {Highcharts.AlignValue|null}
     */
    align: "center",
    /**
     * Whether to allow data labels to overlap. To make the labels less
     * sensitive for overlapping, the
     * [dataLabels.padding](#plotOptions.series.dataLabels.padding)
     * can be set to 0.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-allowoverlap-false/
     *         Don't allow overlap
     *
     * @type      {boolean}
     * @default   false
     * @since     4.1.0
     * @apioption plotOptions.series.dataLabels.allowOverlap
     */
    /**
     * The background color or gradient for the data label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highmaps} maps/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.backgroundColor
     */
    /**
     * The border color for the data label. Defaults to `undefined`.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.borderColor
     */
    /**
     * The border radius in pixels for the data label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highmaps} maps/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {number}
     * @default   0
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.borderRadius
     */
    /**
     * The border width in pixels for the data label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {number}
     * @default   0
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.borderWidth
     */
    /**
     * A class name for the data label. Particularly in styled mode,
     * this can be used to give each series' or point's data label
     * unique styling. In addition to this option, a default color class
     * name is added so that we can give the labels a contrast text
     * shadow.
     *
     * @sample {highcharts} highcharts/css/data-label-contrast/
     *         Contrast text shadow
     * @sample {highcharts} highcharts/css/series-datalabels/
     *         Styling by CSS
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption plotOptions.series.dataLabels.className
     */
    /**
     * The text color for the data labels. Defaults to `undefined`. For
     * certain series types, like column or map, the data labels can be
     * drawn inside the points. In this case the data label will be
     * drawn with maximum contrast by default. Additionally, it will be
     * given a `text-outline` style with the opposite color, to further
     * increase the contrast. This can be overridden by setting the
     * `text-outline` style to `none` in the `dataLabels.style` option.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
     *         Red data labels
     * @sample {highmaps} maps/demo/color-axis/
     *         White data labels
     *
     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @apioption plotOptions.series.dataLabels.color
     */
    /**
     * Whether to hide data labels that are outside the plot area. By
     * default, the data label is moved inside the plot area according
     * to the
     * [overflow](#plotOptions.series.dataLabels.overflow)
     * option.
     *
     * @type      {boolean}
     * @default   true
     * @since     2.3.3
     * @apioption plotOptions.series.dataLabels.crop
     */
    /**
     * Whether to defer displaying the data labels until the initial
     * series animation has finished. Setting to `false` renders the
     * data label immediately. If set to `true` inherits the defer
     * time set in [plotOptions.series.animation](#plotOptions.series.animation).
     * If set to a number, a defer time is specified in milliseconds.
     *
     * @sample highcharts/plotoptions/animation-defer
     *         Set defer time
     *
     * @since     4.0.0
     * @type      {boolean|number}
     * @product   highcharts highstock gantt
     */
    defer: true,
    /**
     * Enable or disable the data labels.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/
     *         Data labels enabled
     * @sample {highmaps} maps/demo/color-axis/
     *         Data labels enabled
     *
     * @type      {boolean}
     * @default   false
     * @apioption plotOptions.series.dataLabels.enabled
     */
    /**
     * A declarative filter to control of which data labels to display.
     * The declarative filter is designed for use when callback
     * functions are not available, like when the chart options require
     * a pure JSON structure or for use with graphical editors. For
     * programmatic control, use the `formatter` instead, and return
     * `undefined` to disable a single data label.
     *
     * @example
     * filter: {
     *     property: 'percentage',
     *     operator: '>',
     *     value: 4
     * }
     *
     * @sample {highcharts} highcharts/demo/pie-monochrome
     *         Data labels filtered by percentage
     *
     * @declare   Highcharts.DataLabelsFilterOptionsObject
     * @since     6.0.3
     * @apioption plotOptions.series.dataLabels.filter
     */
    /**
     * The operator to compare by. Can be one of `>`, `<`, `>=`, `<=`,
     * `==`, and `===`.
     *
     * @type       {string}
     * @validvalue [">", "<", ">=", "<=", "==", "==="]
     * @apioption  plotOptions.series.dataLabels.filter.operator
     */
    /**
     * The point property to filter by. Point options are passed
     * directly to properties, additionally there are `y` value,
     * `percentage` and others listed under {@link Highcharts.Point}
     * members.
     *
     * @type      {string}
     * @apioption plotOptions.series.dataLabels.filter.property
     */
    /**
     * The value to compare against.
     *
     * @type      {number}
     * @apioption plotOptions.series.dataLabels.filter.value
     */
    /**
     * A
     * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
     * for the data label. Available variables are the same as for
     * `formatter`.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
     *         Add a unit
     * @sample {highmaps} maps/plotoptions/series-datalabels-format/
     *         Formatted value in the data label
     *
     * @type      {string}
     * @default   y
     * @default   point.value
     * @since     3.0
     * @apioption plotOptions.series.dataLabels.format
     */
    // eslint-disable-next-line valid-jsdoc
    /**
     * Callback JavaScript function to format the data label. Note that
     * if a `format` is defined, the format takes precedence and the
     * formatter is ignored.
     *
     * @sample {highmaps} maps/plotoptions/series-datalabels-format/
     *         Formatted value
     *
     * @type {Highcharts.DataLabelsFormatterCallbackFunction}
     */
    formatter: function() {
      var numberFormatter = this.series.chart.numberFormatter;
      return typeof this.y !== "number" ? "" : numberFormatter(this.y, -1);
    },
    /**
     * For points with an extent, like columns or map areas, whether to
     * align the data label inside the box or to the actual value point.
     * Defaults to `false` in most cases, `true` in stacked columns.
     *
     * @type      {boolean}
     * @since     3.0
     * @apioption plotOptions.series.dataLabels.inside
     */
    /**
     * Format for points with the value of null. Works analogously to
     * [format](#plotOptions.series.dataLabels.format). `nullFormat` can
     * be applied only to series which support displaying null points.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
     *         Format data label and tooltip for null point.
     *
     * @type      {boolean|string}
     * @since     7.1.0
     * @apioption plotOptions.series.dataLabels.nullFormat
     */
    /**
     * Callback JavaScript function that defines formatting for points
     * with the value of null. Works analogously to
     * [formatter](#plotOptions.series.dataLabels.formatter).
     * `nullPointFormatter` can be applied only to series which support
     * displaying null points.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
     *         Format data label and tooltip for null point.
     *
     * @type      {Highcharts.DataLabelsFormatterCallbackFunction}
     * @since     7.1.0
     * @apioption plotOptions.series.dataLabels.nullFormatter
     */
    /**
     * How to handle data labels that flow outside the plot area. The
     * default is `"justify"`, which aligns them inside the plot area.
     * For columns and bars, this means it will be moved inside the bar.
     * To display data labels outside the plot area, set `crop` to
     * `false` and `overflow` to `"allow"`.
     *
     * @type       {Highcharts.DataLabelsOverflowValue}
     * @default    justify
     * @since      3.0.6
     * @apioption  plotOptions.series.dataLabels.overflow
     */
    /**
     * When either the `borderWidth` or the `backgroundColor` is set,
     * this is the padding within the box.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     * @sample {highmaps} maps/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @since 2.2.1
     */
    padding: 5,
    /**
     * Aligns data labels relative to points. If `center` alignment is
     * not possible, it defaults to `right`.
     *
     * @type      {Highcharts.AlignValue}
     * @default   center
     * @apioption plotOptions.series.dataLabels.position
     */
    /**
     * Text rotation in degrees. Note that due to a more complex
     * structure, backgrounds, borders and padding will be lost on a
     * rotated data label.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
     *         Vertical labels
     *
     * @type      {number}
     * @default   0
     * @apioption plotOptions.series.dataLabels.rotation
     */
    /**
     * The shadow of the box. Works best with `borderWidth` or
     * `backgroundColor`. Since 2.3 the shadow can be an object
     * configuration containing `color`, `offsetX`, `offsetY`, `opacity`
     * and `width`.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
     *         Data labels box options
     *
     * @type      {boolean|Highcharts.ShadowOptionsObject}
     * @default   false
     * @since     2.2.1
     * @apioption plotOptions.series.dataLabels.shadow
     */
    /**
     * The name of a symbol to use for the border around the label.
     * Symbols are predefined functions on the Renderer object.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-shape/
     *         A callout for annotations
     *
     * @type      {string}
     * @default   square
     * @since     4.1.2
     * @apioption plotOptions.series.dataLabels.shape
     */
    /**
     * Styles for the label. The default `color` setting is
     * `"contrast"`, which is a pseudo color that Highcharts picks up
     * and applies the maximum contrast to the underlying point item,
     * for example the bar in a bar chart.
     *
     * The `textOutline` is a pseudo property that applies an outline of
     * the given width with the given color, which by default is the
     * maximum contrast to the text. So a bright text color will result
     * in a black text outline for maximum readability on a mixed
     * background. In some cases, especially with grayscale text, the
     * text outline doesn't work well, in which cases it can be disabled
     * by setting it to `"none"`. When `useHTML` is true, the
     * `textOutline` will not be picked up. In this, case, the same
     * effect can be acheived through the `text-shadow` CSS property.
     *
     * For some series types, where each point has an extent, like for
     * example tree maps, the data label may overflow the point. There
     * are two strategies for handling overflow. By default, the text
     * will wrap to multiple lines. The other strategy is to set
     * `style.textOverflow` to `ellipsis`, which will keep the text on
     * one line plus it will break inside long words.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
     *         Bold labels
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow/
     *         Long labels truncated with an ellipsis in a pie
     * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap/
     *         Long labels are wrapped in a pie
     * @sample {highmaps} maps/demo/color-axis/
     *         Bold labels
     *
     * @type      {Highcharts.CSSObject}
     * @since     4.1.0
     * @apioption plotOptions.series.dataLabels.style
     */
    style: {
      /** @internal */
      fontSize: "11px",
      /** @internal */
      fontWeight: "bold",
      /** @internal */
      color: "contrast",
      /** @internal */
      textOutline: "1px contrast"
    },
    /**
     * Options for a label text which should follow marker's shape.
     * Border and background are disabled for a label that follows a
     * path.
     *
     * **Note:** Only SVG-based renderer supports this option. Setting
     * `useHTML` to true will disable this option.
     *
     * @declare   Highcharts.DataLabelsTextPathOptionsObject
     * @since     7.1.0
     * @apioption plotOptions.series.dataLabels.textPath
     */
    /**
     * Presentation attributes for the text path.
     *
     * @type      {Highcharts.SVGAttributes}
     * @since     7.1.0
     * @apioption plotOptions.series.dataLabels.textPath.attributes
     */
    /**
     * Enable or disable `textPath` option for link's or marker's data
     * labels.
     *
     * @type      {boolean}
     * @since     7.1.0
     * @apioption plotOptions.series.dataLabels.textPath.enabled
     */
    /**
     * Whether to
     * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
     * to render the labels.
     *
     * @type      {boolean}
     * @default   false
     * @apioption plotOptions.series.dataLabels.useHTML
     */
    /**
     * The vertical alignment of a data label. Can be one of `top`,
     * `middle` or `bottom`. The default value depends on the data, for
     * instance in a column chart, the label is above positive values
     * and below negative values.
     *
     * @type  {Highcharts.VerticalAlignValue|null}
     * @since 2.3.3
     */
    verticalAlign: "bottom",
    /**
     * The x position offset of the label relative to the point in
     * pixels.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
     *         Vertical and positioned
     * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
     *         Data labels inside the bar
     */
    x: 0,
    /**
     * The Z index of the data labels. The default Z index puts it above
     * the series. Use a Z index of 2 to display it behind the series.
     *
     * @type      {number}
     * @default   6
     * @since     2.3.5
     * @apioption plotOptions.series.dataLabels.z
     */
    /**
     * The y position offset of the label relative to the point in
     * pixels.
     *
     * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
     *         Vertical and positioned
     */
    y: 0
  },
  /**
   * When the series contains less points than the crop threshold, all
   * points are drawn, even if the points fall outside the visible plot
   * area at the current zoom. The advantage of drawing all points
   * (including markers and columns), is that animation is performed on
   * updates. On the other hand, when the series contains more points than
   * the crop threshold, the series data is cropped to only contain points
   * that fall within the plot area. The advantage of cropping away
   * invisible points is to increase performance on large series.
   *
   * @since   2.2
   * @product highcharts highstock
   *
   * @private
   */
  cropThreshold: 300,
  /**
   * Opacity of a series parts: line, fill (e.g. area) and dataLabels.
   *
   * @see [states.inactive.opacity](#plotOptions.series.states.inactive.opacity)
   *
   * @since 7.1.0
   *
   * @private
   */
  opacity: 1,
  /**
   * The width of each point on the x axis. For example in a column chart
   * with one value each day, the pointRange would be 1 day (= 24 * 3600
   * * 1000 milliseconds). This is normally computed automatically, but
   * this option can be used to override the automatic value.
   *
   * @product highstock
   *
   * @private
   */
  pointRange: 0,
  /**
   * When this is true, the series will not cause the Y axis to cross
   * the zero plane (or [threshold](#plotOptions.series.threshold) option)
   * unless the data actually crosses the plane.
   *
   * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
   * 3 will make the Y axis show negative values according to the
   * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
   * at 0.
   *
   * @since   4.1.9
   * @product highcharts highstock
   *
   * @private
   */
  softThreshold: true,
  /**
   * @declare Highcharts.SeriesStatesOptionsObject
   *
   * @private
   */
  states: {
    /**
     * The normal state of a series, or for point items in column, pie
     * and similar series. Currently only used for setting animation
     * when returning to normal state from hover.
     *
     * @declare Highcharts.SeriesStatesNormalOptionsObject
     */
    normal: {
      /**
       * Animation when returning to normal state after hovering.
       *
           * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
       */
      animation: true
    },
    /**
     * Options for the hovered series. These settings override the
     * normal state options when a series is moused over or touched.
     *
     * @declare Highcharts.SeriesStatesHoverOptionsObject
     */
    hover: {
      /**
       * Enable separate styles for the hovered series to visualize
       * that the user hovers either the series itself or the legend.
       *
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/
       *         Line
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/
       *         Column
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/
       *         Pie
       *
       * @type      {boolean}
       * @default   true
       * @since     1.2
       * @apioption plotOptions.series.states.hover.enabled
       */
      /**
       * Animation setting for hovering the graph in line-type series.
       *
       * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
       * @since   5.0.8
       * @product highcharts highstock
       */
      animation: {
        /**
         * The duration of the hover animation in milliseconds. By
         * default the hover state animates quickly in, and slowly
         * back to normal.
         *
         * @internal
         */
        duration: 50
      },
      /**
       * Pixel width of the graph line. By default this property is
       * undefined, and the `lineWidthPlus` property dictates how much
       * to increase the linewidth from normal state.
       *
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/
       *         5px line on hover
       *
       * @type      {number}
       * @product   highcharts highstock
       * @apioption plotOptions.series.states.hover.lineWidth
       */
      /**
       * The additional line width for the graph of a hovered series.
       *
       * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
       *         5 pixels wider
       * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
       *         5 pixels wider
       *
       * @since   4.0.3
       * @product highcharts highstock
       */
      lineWidthPlus: 1,
      /**
       * In Highcharts 1.0, the appearance of all markers belonging
       * to the hovered series. For settings on the hover state of the
       * individual point, see
       * [marker.states.hover](#plotOptions.series.marker.states.hover).
       *
       * @deprecated
       *
       * @extends   plotOptions.series.marker
       * @excluding states
       * @product   highcharts highstock
       */
      marker: {
        // lineWidth: base + 1,
        // radius: base + 1
      },
      /**
       * Options for the halo appearing around the hovered point in
       * line-type series as well as outside the hovered slice in pie
       * charts. By default the halo is filled by the current point or
       * series color with an opacity of 0.25\. The halo can be
       * disabled by setting the `halo` option to `null`.
       *
       * In styled mode, the halo is styled with the
       * `.highcharts-halo` class, with colors inherited from
       * `.highcharts-color-{n}`.
       *
       * @sample {highcharts} highcharts/plotoptions/halo/
       *         Halo options
       * @sample {highstock} highcharts/plotoptions/halo/
       *         Halo options
       *
       * @declare Highcharts.SeriesStatesHoverHaloOptionsObject
       * @type    {null|*}
       * @since   4.0
       * @product highcharts highstock
       */
      halo: {
        /**
         * A collection of SVG attributes to override the appearance
         * of the halo, for example `fill`, `stroke` and
         * `stroke-width`.
         *
         * @type      {Highcharts.SVGAttributes}
         * @since     4.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.states.hover.halo.attributes
         */
        /**
         * The pixel size of the halo. For point markers this is the
         * radius of the halo. For pie slices it is the width of the
         * halo outside the slice. For bubbles it defaults to 5 and
         * is the width of the halo outside the bubble.
         *
         * @since   4.0
         * @product highcharts highstock
         */
        size: 10,
        /**
         * Opacity for the halo unless a specific fill is overridden
         * using the `attributes` setting. Note that Highcharts is
         * only able to apply opacity to colors of hex or rgb(a)
         * formats.
         *
         * @since   4.0
         * @product highcharts highstock
         */
        opacity: 0.25
      }
    },
    /**
     * Specific options for point in selected states, after being
     * selected by
     * [allowPointSelect](#plotOptions.series.allowPointSelect)
     * or programmatically.
     *
     * @sample maps/plotoptions/series-allowpointselect/
     *         Allow point select demo
     *
     * @declare   Highcharts.SeriesStatesSelectOptionsObject
     * @extends   plotOptions.series.states.hover
     * @excluding brightness
     */
    select: {
      animation: {
        /** @internal */
        duration: 0
      }
    },
    /**
     * The opposite state of a hover for series.
     *
     * @sample highcharts/plotoptions/series-states-inactive-disabled
     *         Disabled inactive state
     *
     * @declare Highcharts.SeriesStatesInactiveOptionsObject
     */
    inactive: {
      /**
       * Enable or disable the inactive state for a series
       *
       * @sample highcharts/plotoptions/series-states-inactive-disabled
       *         Disabled inactive state
       *
       * @type {boolean}
       * @default true
       * @apioption plotOptions.series.states.inactive.enabled
       */
      /**
       * The animation for entering the inactive state.
       *
       * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
       */
      animation: {
        /** @internal */
        duration: 50
      },
      /**
       * Opacity of series elements (dataLabels, line, area).
       *
       * @type {number}
       */
      opacity: 0.2
    }
  },
  /**
   * Sticky tracking of mouse events. When true, the `mouseOut` event on a
   * series isn't triggered until the mouse moves over another series, or
   * out of the plot area. When false, the `mouseOut` event on a series is
   * triggered when the mouse leaves the area around the series' graph or
   * markers. This also implies the tooltip when not shared. When
   * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
   * will be hidden when moving the mouse between series. Defaults to true
   * for line and area type series, but to false for columns, pies etc.
   *
   * **Note:** The boost module will force this option because of
   * technical limitations.
   *
   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
   *         True by default
   * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
   *         False
   *
   * @default {highcharts} true
   * @default {highstock} true
   * @default {highmaps} false
   * @since   2.0
   *
   * @private
   */
  stickyTracking: true,
  /**
   * A configuration object for the tooltip rendering of each single
   * series. Properties are inherited from [tooltip](#tooltip), but only
   * the following properties can be defined on a series level.
   *
   * @declare   Highcharts.SeriesTooltipOptionsObject
   * @since     2.3
   * @extends   tooltip
   * @excluding animation, backgroundColor, borderColor, borderRadius,
   *            borderWidth, className, crosshairs, enabled, formatter,
   *            headerShape, hideDelay, outside, padding, positioner,
   *            shadow, shape, shared, snap, split, stickOnContact,
   *            style, useHTML
   * @apioption plotOptions.series.tooltip
   */
  /**
   * When a series contains a data array that is longer than this, only
   * one dimensional arrays of numbers, or two dimensional arrays with
   * x and y values are allowed. Also, only the first point is tested,
   * and the rest are assumed to be the same format. This saves expensive
   * data checking and indexing in long series. Set it to `0` disable.
   *
   * Note:
   * In boost mode turbo threshold is forced. Only array of numbers or
   * two dimensional arrays are allowed.
   *
   * @since   2.2
   * @product highcharts highstock gantt
   *
   * @private
   */
  turboThreshold: 1e3,
  /**
   * An array defining zones within a series. Zones can be applied to the
   * X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`
   * option. The zone definitions have to be in ascending order regarding
   * to the value.
   *
   * In styled mode, the color zones are styled with the
   * `.highcharts-zone-{n}` class, or custom classed from the `className`
   * option
   * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).
   *
   * @see [zoneAxis](#plotOptions.series.zoneAxis)
   *
   * @sample {highcharts} highcharts/series/color-zones-simple/
   *         Color zones
   * @sample {highstock} highcharts/series/color-zones-simple/
   *         Color zones
   *
   * @declare   Highcharts.SeriesZonesOptionsObject
   * @type      {Array<*>}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones
   */
  /**
   * Styled mode only. A custom class name for the zone.
   *
   * @sample highcharts/css/color-zones/
   *         Zones styled by class name
   *
   * @type      {string}
   * @since     5.0.0
   * @apioption plotOptions.series.zones.className
   */
  /**
   * Defines the color of the series.
   *
   * @see [series color](#plotOptions.series.color)
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.color
   */
  /**
   * A name for the dash style to use for the graph.
   *
   * @see [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
   *
   * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/
   *         Dashed line indicates prognosis
   *
   * @type      {Highcharts.DashStyleValue}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.dashStyle
   */
  /**
   * Defines the fill color for the series (in area type series)
   *
   * @see [fillColor](#plotOptions.area.fillColor)
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.fillColor
   */
  /**
   * The value up to where the zone extends, if undefined the zones
   * stretches to the last value in the series.
   *
   * @type      {number}
   * @since     4.1.0
   * @product   highcharts highstock
   * @apioption plotOptions.series.zones.value
   */
  /**
   * When using dual or multiple color axes, this number defines which
   * colorAxis the particular series is connected to. It refers to
   * either the
   * {@link #colorAxis.id|axis id}
   * or the index of the axis in the colorAxis array, with 0 being the
   * first. Set this option to false to prevent a series from connecting
   * to the default color axis.
   *
   * Since v7.2.0 the option can also be an axis id or an axis index
   * instead of a boolean flag.
   *
   * @sample highcharts/coloraxis/coloraxis-with-pie/
   *         Color axis with pie series
   * @sample highcharts/coloraxis/multiple-coloraxis/
   *         Multiple color axis
   *
   * @type      {number|string|boolean}
   * @default   0
   * @product   highcharts highstock highmaps
   * @apioption plotOptions.series.colorAxis
   */
  /**
   * Determines what data value should be used to calculate point color
   * if `colorAxis` is used. Requires to set `min` and `max` if some
   * custom point property is used or if approximation for data grouping
   * is set to `'sum'`.
   *
   * @sample highcharts/coloraxis/custom-color-key/
   *         Custom color key
   * @sample highcharts/coloraxis/changed-default-color-key/
   *         Changed default color key
   *
   * @type      {string}
   * @default   y
   * @since     7.2.0
   * @product   highcharts highstock highmaps
   * @apioption plotOptions.series.colorKey
   */
  /**
   * Determines whether the series should look for the nearest point
   * in both dimensions or just the x-dimension when hovering the series.
   * Defaults to `'xy'` for scatter series and `'x'` for most other
   * series. If the data has duplicate x-values, it is recommended to
   * set this to `'xy'` to allow hovering over all points.
   *
   * Applies only to series types using nearest neighbor search (not
   * direct hover) for tooltip.
   *
   * @sample {highcharts} highcharts/series/findnearestpointby/
   *         Different hover behaviors
   * @sample {highstock} highcharts/series/findnearestpointby/
   *         Different hover behaviors
   * @sample {highmaps} highcharts/series/findnearestpointby/
   *         Different hover behaviors
   *
   * @since      5.0.10
   * @validvalue ["x", "xy"]
   *
   * @private
   */
  findNearestPointBy: "x"
};
var SeriesDefaults_default = seriesDefaults;

// node_modules/highcharts/es-modules/Core/Series/Series.js
var animObject7 = AnimationUtilities_default.animObject;
var setAnimation4 = AnimationUtilities_default.setAnimation;
var defaultOptions7 = DefaultOptions_default.defaultOptions;
var registerEventOptions4 = Foundation_default.registerEventOptions;
var hasTouch = Globals_default.hasTouch;
var svg4 = Globals_default.svg;
var win11 = Globals_default.win;
var seriesTypes2 = SeriesRegistry_default.seriesTypes;
var addEvent13 = Utilities_default.addEvent;
var arrayMax4 = Utilities_default.arrayMax;
var arrayMin4 = Utilities_default.arrayMin;
var clamp6 = Utilities_default.clamp;
var cleanRecursively3 = Utilities_default.cleanRecursively;
var correctFloat4 = Utilities_default.correctFloat;
var defined17 = Utilities_default.defined;
var erase8 = Utilities_default.erase;
var error7 = Utilities_default.error;
var extend15 = Utilities_default.extend;
var find5 = Utilities_default.find;
var fireEvent11 = Utilities_default.fireEvent;
var getNestedProperty4 = Utilities_default.getNestedProperty;
var isArray9 = Utilities_default.isArray;
var isNumber18 = Utilities_default.isNumber;
var isString9 = Utilities_default.isString;
var merge18 = Utilities_default.merge;
var objectEach16 = Utilities_default.objectEach;
var pick23 = Utilities_default.pick;
var removeEvent8 = Utilities_default.removeEvent;
var splat8 = Utilities_default.splat;
var syncTimeout8 = Utilities_default.syncTimeout;
var Series = (
  /** @class */
  function() {
    function Series16() {
      this._i = void 0;
      this.chart = void 0;
      this.data = void 0;
      this.eventOptions = void 0;
      this.eventsToUnbind = void 0;
      this.index = void 0;
      this.linkedSeries = void 0;
      this.options = void 0;
      this.points = void 0;
      this.processedXData = void 0;
      this.processedYData = void 0;
      this.tooltipOptions = void 0;
      this.userOptions = void 0;
      this.xAxis = void 0;
      this.yAxis = void 0;
      this.zones = void 0;
    }
    Series16.prototype.init = function(chart, userOptions) {
      fireEvent11(this, "init", { options: userOptions });
      var series = this, chartSeries = chart.series;
      this.eventsToUnbind = [];
      series.chart = chart;
      series.options = series.setOptions(userOptions);
      var options = series.options;
      series.linkedSeries = [];
      series.bindAxes();
      extend15(series, {
        /**
         * The series name as given in the options. Defaults to
         * "Series {n}".
         *
         * @name Highcharts.Series#name
         * @type {string}
         */
        name: options.name,
        state: "",
        /**
         * Read only. The series' visibility state as set by {@link
         * Series#show}, {@link Series#hide}, or in the initial
         * configuration.
         *
         * @name Highcharts.Series#visible
         * @type {boolean}
         */
        visible: options.visible !== false,
        /**
         * Read only. The series' selected state as set by {@link
         * Highcharts.Series#select}.
         *
         * @name Highcharts.Series#selected
         * @type {boolean}
         */
        selected: options.selected === true
        // false by default
      });
      registerEventOptions4(this, options);
      var events = options.events;
      if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {
        chart.runTrackerClick = true;
      }
      series.getColor();
      series.getSymbol();
      series.parallelArrays.forEach(function(key) {
        if (!series[key + "Data"]) {
          series[key + "Data"] = [];
        }
      });
      if (series.isCartesian) {
        chart.hasCartesianSeries = true;
      }
      var lastSeries;
      if (chartSeries.length) {
        lastSeries = chartSeries[chartSeries.length - 1];
      }
      series._i = pick23(lastSeries && lastSeries._i, -1) + 1;
      series.opacity = series.options.opacity;
      chart.orderSeries(this.insert(chartSeries));
      if (options.dataSorting && options.dataSorting.enabled) {
        series.setDataSortingOptions();
      } else if (!series.points && !series.data) {
        series.setData(options.data, false);
      }
      fireEvent11(this, "afterInit");
    };
    Series16.prototype.is = function(type) {
      return seriesTypes2[type] && this instanceof seriesTypes2[type];
    };
    Series16.prototype.insert = function(collection) {
      var indexOption = this.options.index;
      var i;
      if (isNumber18(indexOption)) {
        i = collection.length;
        while (i--) {
          if (indexOption >= pick23(collection[i].options.index, collection[i]._i)) {
            collection.splice(i + 1, 0, this);
            break;
          }
        }
        if (i === -1) {
          collection.unshift(this);
        }
        i = i + 1;
      } else {
        collection.push(this);
      }
      return pick23(i, collection.length - 1);
    };
    Series16.prototype.bindAxes = function() {
      var series = this, seriesOptions = series.options, chart = series.chart;
      var axisOptions;
      fireEvent11(this, "bindAxes", null, function() {
        (series.axisTypes || []).forEach(function(AXIS) {
          var index = 0;
          chart[AXIS].forEach(function(axis) {
            axisOptions = axis.options;
            if (seriesOptions[AXIS] === index && !axisOptions.isInternal || typeof seriesOptions[AXIS] !== "undefined" && seriesOptions[AXIS] === axisOptions.id || typeof seriesOptions[AXIS] === "undefined" && axisOptions.index === 0) {
              series.insert(axis.series);
              series[AXIS] = axis;
              axis.isDirty = true;
            }
            if (!axisOptions.isInternal) {
              index++;
            }
          });
          if (!series[AXIS] && series.optionalAxis !== AXIS) {
            error7(18, true, chart);
          }
        });
      });
      fireEvent11(this, "afterBindAxes");
    };
    Series16.prototype.updateParallelArrays = function(point, i) {
      var series = point.series, args = arguments, fn = isNumber18(i) ? (
        // Insert the value in the given position
        function(key) {
          var val = key === "y" && series.toYData ? series.toYData(point) : point[key];
          series[key + "Data"][i] = val;
        }
      ) : (
        // Apply the method specified in i with the following
        // arguments as arguments
        function(key) {
          Array.prototype[i].apply(series[key + "Data"], Array.prototype.slice.call(args, 2));
        }
      );
      series.parallelArrays.forEach(fn);
    };
    Series16.prototype.hasData = function() {
      return this.visible && typeof this.dataMax !== "undefined" && typeof this.dataMin !== "undefined" || // #3703
      this.visible && this.yData && this.yData.length > 0;
    };
    Series16.prototype.autoIncrement = function(x) {
      var options = this.options, pointIntervalUnit = options.pointIntervalUnit, relativeXValue = options.relativeXValue, time = this.chart.time;
      var xIncrement = this.xIncrement, date, pointInterval;
      xIncrement = pick23(xIncrement, options.pointStart, 0);
      this.pointInterval = pointInterval = pick23(this.pointInterval, options.pointInterval, 1);
      if (relativeXValue && isNumber18(x)) {
        pointInterval *= x;
      }
      if (pointIntervalUnit) {
        date = new time.Date(xIncrement);
        if (pointIntervalUnit === "day") {
          time.set("Date", date, time.get("Date", date) + pointInterval);
        } else if (pointIntervalUnit === "month") {
          time.set("Month", date, time.get("Month", date) + pointInterval);
        } else if (pointIntervalUnit === "year") {
          time.set("FullYear", date, time.get("FullYear", date) + pointInterval);
        }
        pointInterval = date.getTime() - xIncrement;
      }
      if (relativeXValue && isNumber18(x)) {
        return xIncrement + pointInterval;
      }
      this.xIncrement = xIncrement + pointInterval;
      return xIncrement;
    };
    Series16.prototype.setDataSortingOptions = function() {
      var options = this.options;
      extend15(this, {
        requireSorting: false,
        sorted: false,
        enabledDataSorting: true,
        allowDG: false
      });
      if (!defined17(options.pointRange)) {
        options.pointRange = 1;
      }
    };
    Series16.prototype.setOptions = function(itemOptions) {
      var chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, userOptions = chart.userOptions || {}, seriesUserOptions = merge18(itemOptions), styledMode = chart.styledMode, e2 = {
        plotOptions,
        userOptions: seriesUserOptions
      };
      var zone;
      fireEvent11(this, "setOptions", e2);
      var typeOptions = e2.plotOptions[this.type], userPlotOptions = userOptions.plotOptions || {};
      this.userOptions = e2.userOptions;
      var options = merge18(
        typeOptions,
        plotOptions.series,
        // #3881, chart instance plotOptions[type] should trump
        // plotOptions.series
        userOptions.plotOptions && userOptions.plotOptions[this.type],
        seriesUserOptions
      );
      this.tooltipOptions = merge18(
        defaultOptions7.tooltip,
        // 1
        defaultOptions7.plotOptions.series && defaultOptions7.plotOptions.series.tooltip,
        // 2
        defaultOptions7.plotOptions[this.type].tooltip,
        // 3
        chartOptions.tooltip.userOptions,
        // 4
        plotOptions.series && plotOptions.series.tooltip,
        // 5
        plotOptions[this.type].tooltip,
        // 6
        seriesUserOptions.tooltip
        // 7
      );
      this.stickyTracking = pick23(seriesUserOptions.stickyTracking, userPlotOptions[this.type] && userPlotOptions[this.type].stickyTracking, userPlotOptions.series && userPlotOptions.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking);
      if (typeOptions.marker === null) {
        delete options.marker;
      }
      this.zoneAxis = options.zoneAxis;
      var zones = this.zones = (options.zones || []).slice();
      if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
        zone = {
          value: options[this.zoneAxis + "Threshold"] || options.threshold || 0,
          className: "highcharts-negative"
        };
        if (!styledMode) {
          zone.color = options.negativeColor;
          zone.fillColor = options.negativeFillColor;
        }
        zones.push(zone);
      }
      if (zones.length) {
        if (defined17(zones[zones.length - 1].value)) {
          zones.push(styledMode ? {} : {
            color: this.color,
            fillColor: this.fillColor
          });
        }
      }
      fireEvent11(this, "afterSetOptions", { options });
      return options;
    };
    Series16.prototype.getName = function() {
      return pick23(this.options.name, "Series " + (this.index + 1));
    };
    Series16.prototype.getCyclic = function(prop, value, defaults) {
      var chart = this.chart, userOptions = this.userOptions, indexName = prop + "Index", counterName = prop + "Counter", len = defaults ? defaults.length : pick23(chart.options.chart[prop + "Count"], chart[prop + "Count"]);
      var i, setting;
      if (!value) {
        setting = pick23(userOptions[indexName], userOptions["_" + indexName]);
        if (defined17(setting)) {
          i = setting;
        } else {
          if (!chart.series.length) {
            chart[counterName] = 0;
          }
          userOptions["_" + indexName] = i = chart[counterName] % len;
          chart[counterName] += 1;
        }
        if (defaults) {
          value = defaults[i];
        }
      }
      if (typeof i !== "undefined") {
        this[indexName] = i;
      }
      this[prop] = value;
    };
    Series16.prototype.getColor = function() {
      if (this.chart.styledMode) {
        this.getCyclic("color");
      } else if (this.options.colorByPoint) {
        this.color = Palette_default.neutralColor20;
      } else {
        this.getCyclic("color", this.options.color || defaultOptions7.plotOptions[this.type].color, this.chart.options.colors);
      }
    };
    Series16.prototype.getPointsCollection = function() {
      return (this.hasGroupedData ? this.points : this.data) || [];
    };
    Series16.prototype.getSymbol = function() {
      var seriesMarkerOption = this.options.marker;
      this.getCyclic("symbol", seriesMarkerOption.symbol, this.chart.options.symbols);
    };
    Series16.prototype.findPointIndex = function(optionsObject, fromIndex) {
      var id = optionsObject.id, x = optionsObject.x, oldData = this.points, dataSorting = this.options.dataSorting;
      var matchingPoint, matchedById, pointIndex;
      if (id) {
        var item = this.chart.get(id);
        if (item instanceof Point_default) {
          matchingPoint = item;
        }
      } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
        var matcher = function(oldPoint) {
          return !oldPoint.touched && oldPoint.index === optionsObject.index;
        };
        if (dataSorting && dataSorting.matchByName) {
          matcher = function(oldPoint) {
            return !oldPoint.touched && oldPoint.name === optionsObject.name;
          };
        } else if (this.options.relativeXValue) {
          matcher = function(oldPoint) {
            return !oldPoint.touched && oldPoint.options.x === optionsObject.x;
          };
        }
        matchingPoint = find5(oldData, matcher);
        if (!matchingPoint) {
          return void 0;
        }
      }
      if (matchingPoint) {
        pointIndex = matchingPoint && matchingPoint.index;
        if (typeof pointIndex !== "undefined") {
          matchedById = true;
        }
      }
      if (typeof pointIndex === "undefined" && isNumber18(x)) {
        pointIndex = this.xData.indexOf(x, fromIndex);
      }
      if (pointIndex !== -1 && typeof pointIndex !== "undefined" && this.cropped) {
        pointIndex = pointIndex >= this.cropStart ? pointIndex - this.cropStart : pointIndex;
      }
      if (!matchedById && isNumber18(pointIndex) && oldData[pointIndex] && oldData[pointIndex].touched) {
        pointIndex = void 0;
      }
      return pointIndex;
    };
    Series16.prototype.updateData = function(data, animation) {
      var options = this.options, dataSorting = options.dataSorting, oldData = this.points, pointsToAdd = [], requireSorting = this.requireSorting, equalLength = data.length === oldData.length;
      var hasUpdatedByKey, i, point, lastIndex, succeeded = true;
      this.xIncrement = null;
      data.forEach(function(pointOptions, i2) {
        var optionsObject = defined17(pointOptions) && this.pointClass.prototype.optionsToObject.call({ series: this }, pointOptions) || {};
        var pointIndex;
        var x = optionsObject.x, id = optionsObject.id;
        if (id || isNumber18(x)) {
          pointIndex = this.findPointIndex(optionsObject, lastIndex);
          if (pointIndex === -1 || typeof pointIndex === "undefined") {
            pointsToAdd.push(pointOptions);
          } else if (oldData[pointIndex] && pointOptions !== options.data[pointIndex]) {
            oldData[pointIndex].update(pointOptions, false, null, false);
            oldData[pointIndex].touched = true;
            if (requireSorting) {
              lastIndex = pointIndex + 1;
            }
          } else if (oldData[pointIndex]) {
            oldData[pointIndex].touched = true;
          }
          if (!equalLength || i2 !== pointIndex || dataSorting && dataSorting.enabled || this.hasDerivedData) {
            hasUpdatedByKey = true;
          }
        } else {
          pointsToAdd.push(pointOptions);
        }
      }, this);
      if (hasUpdatedByKey) {
        i = oldData.length;
        while (i--) {
          point = oldData[i];
          if (point && !point.touched && point.remove) {
            point.remove(false, animation);
          }
        }
      } else if (equalLength && (!dataSorting || !dataSorting.enabled)) {
        data.forEach(function(point2, i2) {
          if (point2 !== oldData[i2].y && oldData[i2].update) {
            oldData[i2].update(point2, false, null, false);
          }
        });
        pointsToAdd.length = 0;
      } else {
        succeeded = false;
      }
      oldData.forEach(function(point2) {
        if (point2) {
          point2.touched = false;
        }
      });
      if (!succeeded) {
        return false;
      }
      pointsToAdd.forEach(function(point2) {
        this.addPoint(point2, false, null, null, false);
      }, this);
      if (this.xIncrement === null && this.xData && this.xData.length) {
        this.xIncrement = arrayMax4(this.xData);
        this.autoIncrement();
      }
      return true;
    };
    Series16.prototype.setData = function(data, redraw, animation, updatePoints) {
      var series = this, oldData = series.points, oldDataLength = oldData && oldData.length || 0, options = series.options, chart = series.chart, dataSorting = options.dataSorting, xAxis = series.xAxis, turboThreshold = options.turboThreshold, xData = this.xData, yData = this.yData, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, keys2 = options.keys;
      var i, pt, updatedData, indexOfX = 0, indexOfY = 1, firstPoint = null;
      data = data || [];
      var dataLength = data.length;
      redraw = pick23(redraw, true);
      if (dataSorting && dataSorting.enabled) {
        data = this.sortData(data);
      }
      if (updatePoints !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && // Soft updating has no benefit in boost, and causes JS error
      // (#8355)
      !series.isSeriesBoosting) {
        updatedData = this.updateData(data, animation);
      }
      if (!updatedData) {
        series.xIncrement = null;
        series.colorCounter = 0;
        this.parallelArrays.forEach(function(key) {
          series[key + "Data"].length = 0;
        });
        if (turboThreshold && dataLength > turboThreshold) {
          firstPoint = series.getFirstValidPoint(data);
          if (isNumber18(firstPoint)) {
            for (i = 0; i < dataLength; i++) {
              xData[i] = this.autoIncrement();
              yData[i] = data[i];
            }
          } else if (isArray9(firstPoint)) {
            if (valueCount) {
              for (i = 0; i < dataLength; i++) {
                pt = data[i];
                xData[i] = pt[0];
                yData[i] = pt.slice(1, valueCount + 1);
              }
            } else {
              if (keys2) {
                indexOfX = keys2.indexOf("x");
                indexOfY = keys2.indexOf("y");
                indexOfX = indexOfX >= 0 ? indexOfX : 0;
                indexOfY = indexOfY >= 0 ? indexOfY : 1;
              }
              for (i = 0; i < dataLength; i++) {
                pt = data[i];
                xData[i] = pt[indexOfX];
                yData[i] = pt[indexOfY];
              }
            }
          } else {
            error7(12, false, chart);
          }
        } else {
          for (i = 0; i < dataLength; i++) {
            if (typeof data[i] !== "undefined") {
              pt = { series };
              series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
              series.updateParallelArrays(pt, i);
            }
          }
        }
        if (yData && isString9(yData[0])) {
          error7(14, true, chart);
        }
        series.data = [];
        series.options.data = series.userOptions.data = data;
        i = oldDataLength;
        while (i--) {
          if (oldData[i] && oldData[i].destroy) {
            oldData[i].destroy();
          }
        }
        if (xAxis) {
          xAxis.minRange = xAxis.userMinRange;
        }
        series.isDirty = chart.isDirtyBox = true;
        series.isDirtyData = !!oldData;
        animation = false;
      }
      if (options.legendType === "point") {
        this.processData();
        this.generatePoints();
      }
      if (redraw) {
        chart.redraw(animation);
      }
    };
    Series16.prototype.sortData = function(data) {
      var series = this, options = series.options, dataSorting = options.dataSorting, sortKey = dataSorting.sortKey || "y", getPointOptionsObject = function(series2, pointOptions) {
        return defined17(pointOptions) && series2.pointClass.prototype.optionsToObject.call({
          series: series2
        }, pointOptions) || {};
      };
      data.forEach(function(pointOptions, i) {
        data[i] = getPointOptionsObject(series, pointOptions);
        data[i].index = i;
      }, this);
      var sortedData = data.concat().sort(function(a, b) {
        var aValue = getNestedProperty4(sortKey, a);
        var bValue = getNestedProperty4(sortKey, b);
        return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;
      });
      sortedData.forEach(function(point, i) {
        point.x = i;
      }, this);
      if (series.linkedSeries) {
        series.linkedSeries.forEach(function(linkedSeries) {
          var options2 = linkedSeries.options, seriesData = options2.data;
          if ((!options2.dataSorting || !options2.dataSorting.enabled) && seriesData) {
            seriesData.forEach(function(pointOptions, i) {
              seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);
              if (data[i]) {
                seriesData[i].x = data[i].x;
                seriesData[i].index = i;
              }
            });
            linkedSeries.setData(seriesData, false);
          }
        });
      }
      return data;
    };
    Series16.prototype.getProcessedData = function(forceExtremesFromAll) {
      var series = this, xAxis = series.xAxis, options = series.options, cropThreshold = options.cropThreshold, getExtremesFromAll = forceExtremesFromAll || series.getExtremesFromAll || options.getExtremesFromAll, isCartesian = series.isCartesian, val2lin = xAxis && xAxis.val2lin, isLog = !!(xAxis && xAxis.logarithmic);
      var croppedData, cropped, cropStart = 0, distance, closestPointRange, i, xExtremes, min, max, processedXData = series.xData, processedYData = series.yData, throwOnUnsorted = series.requireSorting, updatingNames = false;
      var dataLength = processedXData.length;
      if (xAxis) {
        xExtremes = xAxis.getExtremes();
        min = xExtremes.min;
        max = xExtremes.max;
        updatingNames = xAxis.categories && !xAxis.names.length;
      }
      if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
        if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
          processedXData = [];
          processedYData = [];
        } else if (series.yData && (processedXData[0] < min || processedXData[dataLength - 1] > max)) {
          croppedData = this.cropData(series.xData, series.yData, min, max);
          processedXData = croppedData.xData;
          processedYData = croppedData.yData;
          cropStart = croppedData.start;
          cropped = true;
        }
      }
      i = processedXData.length || 1;
      while (--i) {
        distance = isLog ? val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) : processedXData[i] - processedXData[i - 1];
        if (distance > 0 && (typeof closestPointRange === "undefined" || distance < closestPointRange)) {
          closestPointRange = distance;
        } else if (distance < 0 && throwOnUnsorted && !updatingNames) {
          error7(15, false, series.chart);
          throwOnUnsorted = false;
        }
      }
      return {
        xData: processedXData,
        yData: processedYData,
        cropped,
        cropStart,
        closestPointRange
      };
    };
    Series16.prototype.processData = function(force) {
      var series = this, xAxis = series.xAxis;
      if (series.isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
        return false;
      }
      var processedData = series.getProcessedData();
      series.cropped = processedData.cropped;
      series.cropStart = processedData.cropStart;
      series.processedXData = processedData.xData;
      series.processedYData = processedData.yData;
      series.closestPointRange = series.basePointRange = processedData.closestPointRange;
    };
    Series16.prototype.cropData = function(xData, yData, min, max, cropShoulder) {
      var dataLength = xData.length;
      var i, j, cropStart = 0, cropEnd = dataLength;
      cropShoulder = pick23(cropShoulder, this.cropShoulder);
      for (i = 0; i < dataLength; i++) {
        if (xData[i] >= min) {
          cropStart = Math.max(0, i - cropShoulder);
          break;
        }
      }
      for (j = i; j < dataLength; j++) {
        if (xData[j] > max) {
          cropEnd = j + cropShoulder;
          break;
        }
      }
      return {
        xData: xData.slice(cropStart, cropEnd),
        yData: yData.slice(cropStart, cropEnd),
        start: cropStart,
        end: cropEnd
      };
    };
    Series16.prototype.generatePoints = function() {
      var series = this, options = series.options, dataOptions = options.data, processedXData = series.processedXData, processedYData = series.processedYData, PointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, hasGroupedData = series.hasGroupedData, keys2 = options.keys, points = [], groupCropStartIndex = options.dataGrouping && options.dataGrouping.groupAll ? cropStart : 0;
      var dataLength, cursor, point, i, data = series.data;
      if (!data && !hasGroupedData) {
        var arr = [];
        arr.length = dataOptions.length;
        data = series.data = arr;
      }
      if (keys2 && hasGroupedData) {
        series.options.keys = false;
      }
      for (i = 0; i < processedDataLength; i++) {
        cursor = cropStart + i;
        if (!hasGroupedData) {
          point = data[cursor];
          if (!point && typeof dataOptions[cursor] !== "undefined") {
            data[cursor] = point = new PointClass().init(series, dataOptions[cursor], processedXData[i]);
          }
        } else {
          point = new PointClass().init(series, [processedXData[i]].concat(splat8(processedYData[i])));
          point.dataGroup = series.groupMap[groupCropStartIndex + i];
          if (point.dataGroup.options) {
            point.options = point.dataGroup.options;
            extend15(point, point.dataGroup.options);
            delete point.dataLabels;
          }
        }
        if (point) {
          point.index = hasGroupedData ? groupCropStartIndex + i : cursor;
          points[i] = point;
        }
      }
      series.options.keys = keys2;
      if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
        for (i = 0; i < dataLength; i++) {
          if (i === cropStart && !hasGroupedData) {
            i += processedDataLength;
          }
          if (data[i]) {
            data[i].destroyElements();
            data[i].plotX = void 0;
          }
        }
      }
      series.data = data;
      series.points = points;
      fireEvent11(this, "afterGeneratePoints");
    };
    Series16.prototype.getXExtremes = function(xData) {
      return {
        min: arrayMin4(xData),
        max: arrayMax4(xData)
      };
    };
    Series16.prototype.getExtremes = function(yData, forceExtremesFromAll) {
      var xAxis = this.xAxis, yAxis = this.yAxis, xData = this.processedXData || this.xData, activeYData = [], shoulder = this.requireSorting ? this.cropShoulder : 0, positiveValuesOnly = yAxis ? yAxis.positiveValuesOnly : false;
      var xExtremes, validValue, withinRange, x, y, i, j, xMin = 0, xMax = 0, activeCounter = 0;
      yData = yData || this.stackedYData || this.processedYData || [];
      var yDataLength = yData.length;
      if (xAxis) {
        xExtremes = xAxis.getExtremes();
        xMin = xExtremes.min;
        xMax = xExtremes.max;
      }
      for (i = 0; i < yDataLength; i++) {
        x = xData[i];
        y = yData[i];
        validValue = (isNumber18(y) || isArray9(y)) && (y.length || y > 0 || !positiveValuesOnly);
        withinRange = forceExtremesFromAll || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !xAxis || // for colorAxis support
        (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax;
        if (validValue && withinRange) {
          j = y.length;
          if (j) {
            while (j--) {
              if (isNumber18(y[j])) {
                activeYData[activeCounter++] = y[j];
              }
            }
          } else {
            activeYData[activeCounter++] = y;
          }
        }
      }
      var dataExtremes = {
        dataMin: arrayMin4(activeYData),
        dataMax: arrayMax4(activeYData)
      };
      fireEvent11(this, "afterGetExtremes", { dataExtremes });
      return dataExtremes;
    };
    Series16.prototype.applyExtremes = function() {
      var dataExtremes = this.getExtremes();
      this.dataMin = dataExtremes.dataMin;
      this.dataMax = dataExtremes.dataMax;
      return dataExtremes;
    };
    Series16.prototype.getFirstValidPoint = function(data) {
      var dataLength = data.length;
      var i = 0, firstPoint = null;
      while (firstPoint === null && i < dataLength) {
        firstPoint = data[i];
        i++;
      }
      return firstPoint;
    };
    Series16.prototype.translate = function() {
      if (!this.processedXData) {
        this.processData();
      }
      this.generatePoints();
      var series = this, options = series.options, stacking = options.stacking, xAxis = series.xAxis, categories = xAxis.categories, enabledDataSorting = series.enabledDataSorting, yAxis = series.yAxis, points = series.points, dataLength = points.length, hasModifyValue = !!series.modifyValue, pointPlacement = series.pointPlacementToXValue(), dynamicallyPlaced = Boolean(pointPlacement), threshold = options.threshold, stackThreshold = options.startFromThreshold ? threshold : 0, zoneAxis = this.zoneAxis || "y";
      var i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;
      function limitedRange(val) {
        return clamp6(val, -1e5, 1e5);
      }
      for (i = 0; i < dataLength; i++) {
        var point = points[i], xValue = point.x;
        var pointStack = void 0, stackValues = void 0, yValue = point.y, yBottom = point.low;
        var stack = stacking && yAxis.stacking && yAxis.stacking.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? "-" : "") + series.stackKey];
        if (yAxis.positiveValuesOnly && !yAxis.validatePositiveValue(yValue) || xAxis.positiveValuesOnly && !xAxis.validatePositiveValue(xValue)) {
          point.isNull = true;
        }
        point.plotX = plotX = correctFloat4(
          // #5236
          limitedRange(xAxis.translate(
            // #3923
            xValue,
            0,
            0,
            0,
            1,
            pointPlacement,
            this.type === "flags"
          ))
          // #3923
        );
        if (stacking && series.visible && stack && stack[xValue]) {
          stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
          if (!point.isNull) {
            pointStack = stack[xValue];
            stackValues = pointStack.points[stackIndicator.key];
          }
        }
        if (isArray9(stackValues)) {
          yBottom = stackValues[0];
          yValue = stackValues[1];
          if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {
            yBottom = pick23(isNumber18(threshold) && threshold, yAxis.min);
          }
          if (yAxis.positiveValuesOnly && yBottom <= 0) {
            yBottom = null;
          }
          point.total = point.stackTotal = pointStack.total;
          point.percentage = pointStack.total && point.y / pointStack.total * 100;
          point.stackY = yValue;
          if (!series.irregularWidths) {
            pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);
          }
        }
        point.yBottom = defined17(yBottom) ? limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) : null;
        if (hasModifyValue) {
          yValue = series.modifyValue(yValue, point);
        }
        point.plotY = void 0;
        if (isNumber18(yValue)) {
          var translated = yAxis.translate(yValue, false, true, false, true);
          if (typeof translated !== "undefined") {
            point.plotY = limitedRange(translated);
          }
        }
        point.isInside = this.isPointInside(point);
        point.clientX = dynamicallyPlaced ? correctFloat4(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)) : plotX;
        point.negative = point[zoneAxis] < (options[zoneAxis + "Threshold"] || threshold || 0);
        point.category = categories && typeof categories[point.x] !== "undefined" ? categories[point.x] : point.x;
        if (!point.isNull && point.visible !== false) {
          if (typeof lastPlotX !== "undefined") {
            closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
          }
          lastPlotX = plotX;
        }
        point.zone = this.zones.length && point.getZone();
        if (!point.graphic && series.group && enabledDataSorting) {
          point.isNew = true;
        }
      }
      series.closestPointRangePx = closestPointRangePx;
      fireEvent11(this, "afterTranslate");
    };
    Series16.prototype.getValidPoints = function(points, insideOnly, allowNull) {
      var chart = this.chart;
      return (points || this.points || []).filter(function(point) {
        if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, { inverted: chart.inverted })) {
          return false;
        }
        return point.visible !== false && (allowNull || !point.isNull);
      });
    };
    Series16.prototype.getClipBox = function(animation, finalBox) {
      var series = this, options = series.options, chart = series.chart, inverted = chart.inverted, xAxis = series.xAxis, yAxis = xAxis && series.yAxis, scrollablePlotAreaOptions = chart.options.chart.scrollablePlotArea || {};
      var clipBox;
      if (animation && options.clip === false && yAxis) {
        clipBox = inverted ? {
          y: -chart.chartWidth + yAxis.len + yAxis.pos,
          height: chart.chartWidth,
          width: chart.chartHeight,
          x: -chart.chartHeight + xAxis.len + xAxis.pos
        } : {
          y: -yAxis.pos,
          height: chart.chartHeight,
          width: chart.chartWidth,
          x: -xAxis.pos
        };
      } else {
        clipBox = series.clipBox || chart.clipBox;
        if (finalBox) {
          clipBox.width = chart.plotSizeX;
          clipBox.x = (chart.scrollablePixelsX || 0) * (scrollablePlotAreaOptions.scrollPositionX || 0);
        }
      }
      return !finalBox ? clipBox : {
        width: clipBox.width,
        x: clipBox.x
      };
    };
    Series16.prototype.getSharedClipKey = function(animation) {
      if (this.sharedClipKey) {
        return this.sharedClipKey;
      }
      var sharedClipKey = [
        animation && animation.duration,
        animation && animation.easing,
        animation && animation.defer,
        this.getClipBox(animation).height,
        this.options.xAxis,
        this.options.yAxis
      ].join(",");
      if (this.options.clip !== false || animation) {
        this.sharedClipKey = sharedClipKey;
      }
      return sharedClipKey;
    };
    Series16.prototype.setClip = function(animation) {
      var chart = this.chart, options = this.options, renderer = chart.renderer, inverted = chart.inverted, seriesClipBox = this.clipBox, clipBox = this.getClipBox(animation), sharedClipKey = this.getSharedClipKey(animation);
      var clipRect = chart.sharedClips[sharedClipKey], markerClipRect = chart.sharedClips[sharedClipKey + "m"];
      if (animation) {
        clipBox.width = 0;
        if (inverted) {
          clipBox.x = chart.plotHeight + (options.clip !== false ? 0 : chart.plotTop);
        }
      }
      if (!clipRect) {
        if (animation) {
          chart.sharedClips[sharedClipKey + "m"] = markerClipRect = renderer.clipRect(
            // include the width of the first marker
            inverted ? (chart.plotSizeX || 0) + 99 : -99,
            inverted ? -chart.plotLeft : -chart.plotTop,
            99,
            inverted ? chart.chartWidth : chart.chartHeight
          );
        }
        chart.sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
        clipRect.count = { length: 0 };
      } else if (!chart.hasLoaded) {
        clipRect.attr(clipBox);
      }
      if (animation) {
        if (!clipRect.count[this.index]) {
          clipRect.count[this.index] = true;
          clipRect.count.length += 1;
        }
      }
      if (options.clip !== false || animation) {
        this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
        this.markerGroup.clip(markerClipRect);
      }
      if (!animation) {
        if (clipRect.count[this.index]) {
          delete clipRect.count[this.index];
          clipRect.count.length -= 1;
        }
        if (clipRect.count.length === 0) {
          if (!seriesClipBox) {
            chart.sharedClips[sharedClipKey] = clipRect.destroy();
          }
          if (markerClipRect) {
            chart.sharedClips[sharedClipKey + "m"] = markerClipRect.destroy();
          }
        }
      }
    };
    Series16.prototype.animate = function(init) {
      var series = this, chart = series.chart, animation = animObject7(series.options.animation), sharedClipKey = this.sharedClipKey;
      if (init) {
        series.setClip(animation);
      } else if (sharedClipKey) {
        var clipRect = chart.sharedClips[sharedClipKey];
        var markerClipRect = chart.sharedClips[sharedClipKey + "m"];
        var finalBox = series.getClipBox(animation, true);
        if (clipRect) {
          clipRect.animate(finalBox, animation);
        }
        if (markerClipRect) {
          markerClipRect.animate({
            width: finalBox.width + 99,
            x: finalBox.x - (chart.inverted ? 0 : 99)
          }, animation);
        }
      }
    };
    Series16.prototype.afterAnimate = function() {
      this.setClip();
      fireEvent11(this, "afterAnimate");
      this.finishedAnimating = true;
    };
    Series16.prototype.drawPoints = function() {
      var series = this, points = series.points, chart = series.chart, options = series.options, seriesMarkerOptions = options.marker, markerGroup = series[series.specialGroup] || series.markerGroup, xAxis = series.xAxis, globallyEnabled = pick23(
        seriesMarkerOptions.enabled,
        !xAxis || xAxis.isRadial ? true : null,
        // Use larger or equal as radius is null in bubbles (#6321)
        series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius
      );
      var i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;
      if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {
        for (i = 0; i < points.length; i++) {
          point = points[i];
          graphic = point.graphic;
          verb = graphic ? "animate" : "attr";
          pointMarkerOptions = point.marker || {};
          hasPointMarker = !!point.marker;
          var shouldDrawMarker = (globallyEnabled && typeof pointMarkerOptions.enabled === "undefined" || pointMarkerOptions.enabled) && !point.isNull && point.visible !== false;
          if (shouldDrawMarker) {
            var symbol = pick23(pointMarkerOptions.symbol, series.symbol, "rect");
            markerAttribs = series.markerAttribs(point, point.selected && "select");
            if (series.enabledDataSorting) {
              point.startXPos = xAxis.reversed ? -(markerAttribs.width || 0) : xAxis.width;
            }
            var isInside = point.isInside !== false;
            if (graphic) {
              graphic[isInside ? "show" : "hide"](isInside).animate(markerAttribs);
            } else if (isInside && ((markerAttribs.width || 0) > 0 || point.hasImage)) {
              point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);
              if (series.enabledDataSorting && chart.hasRendered) {
                graphic.attr({
                  x: point.startXPos
                });
                verb = "animate";
              }
            }
            if (graphic && verb === "animate") {
              graphic[isInside ? "show" : "hide"](isInside).animate(markerAttribs);
            }
            if (graphic && !chart.styledMode) {
              graphic[verb](series.pointAttribs(point, point.selected && "select"));
            }
            if (graphic) {
              graphic.addClass(point.getClassName(), true);
            }
          } else if (graphic) {
            point.graphic = graphic.destroy();
          }
        }
      }
    };
    Series16.prototype.markerAttribs = function(point, state) {
      var seriesOptions = this.options, seriesMarkerOptions = seriesOptions.marker, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol;
      var seriesStateOptions, pointStateOptions, radius = pick23(pointMarkerOptions.radius, seriesMarkerOptions.radius);
      if (state) {
        seriesStateOptions = seriesMarkerOptions.states[state];
        pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];
        radius = pick23(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0));
      }
      point.hasImage = symbol && symbol.indexOf("url") === 0;
      if (point.hasImage) {
        radius = 0;
      }
      var attribs = {
        // Math.floor for #1843:
        x: seriesOptions.crisp ? Math.floor(point.plotX - radius) : point.plotX - radius,
        y: point.plotY - radius
      };
      if (radius) {
        attribs.width = attribs.height = 2 * radius;
      }
      return attribs;
    };
    Series16.prototype.pointAttribs = function(point, state) {
      var seriesMarkerOptions = this.options.marker, pointOptions = point && point.options, pointMarkerOptions = pointOptions && pointOptions.marker || {}, pointColorOption = pointOptions && pointOptions.color, pointColor = point && point.color, zoneColor = point && point.zone && point.zone.color;
      var seriesStateOptions, pointStateOptions, color18 = this.color, fill, stroke, strokeWidth = pick23(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth), opacity = 1;
      color18 = pointColorOption || zoneColor || pointColor || color18;
      fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color18;
      stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color18;
      state = state || "normal";
      if (state) {
        seriesStateOptions = seriesMarkerOptions.states[state];
        pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
        strokeWidth = pick23(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick23(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));
        fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
        stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
        opacity = pick23(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);
      }
      return {
        "stroke": stroke,
        "stroke-width": strokeWidth,
        "fill": fill,
        "opacity": opacity
      };
    };
    Series16.prototype.destroy = function(keepEventsForUpdate) {
      var series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(win11.navigator.userAgent), data = series.data || [];
      var destroy, i, point, axis;
      fireEvent11(series, "destroy");
      this.removeEvents(keepEventsForUpdate);
      (series.axisTypes || []).forEach(function(AXIS) {
        axis = series[AXIS];
        if (axis && axis.series) {
          erase8(axis.series, series);
          axis.isDirty = axis.forceRedraw = true;
        }
      });
      if (series.legendItem) {
        series.chart.legend.destroyItem(series);
      }
      i = data.length;
      while (i--) {
        point = data[i];
        if (point && point.destroy) {
          point.destroy();
        }
      }
      if (series.clips) {
        series.clips.forEach(function(clip) {
          return clip.destroy();
        });
      }
      Utilities_default.clearTimeout(series.animationTimeout);
      objectEach16(series, function(val, prop) {
        if (val instanceof SVGElement_default && !val.survive) {
          destroy = issue134 && prop === "group" ? "hide" : "destroy";
          val[destroy]();
        }
      });
      if (chart.hoverSeries === series) {
        chart.hoverSeries = void 0;
      }
      erase8(chart.series, series);
      chart.orderSeries();
      objectEach16(series, function(val, prop) {
        if (!keepEventsForUpdate || prop !== "hcEvents") {
          delete series[prop];
        }
      });
    };
    Series16.prototype.applyZones = function() {
      var series = this, chart = this.chart, renderer = chart.renderer, zones = this.zones, clips = this.clips || [], graph = this.graph, area = this.area, chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight), axis = this[(this.zoneAxis || "y") + "Axis"], inverted = chart.inverted;
      var translatedFrom, translatedTo, clipAttr, extremes, reversed, horiz, pxRange, pxPosMin, pxPosMax, zoneArea, zoneGraph, ignoreZones = false;
      if (zones.length && (graph || area) && axis && typeof axis.min !== "undefined") {
        reversed = axis.reversed;
        horiz = axis.horiz;
        if (graph && !this.showLine) {
          graph.hide();
        }
        if (area) {
          area.hide();
        }
        extremes = axis.getExtremes();
        zones.forEach(function(threshold, i) {
          translatedFrom = reversed ? horiz ? chart.plotWidth : 0 : horiz ? 0 : axis.toPixels(extremes.min) || 0;
          translatedFrom = clamp6(pick23(translatedTo, translatedFrom), 0, chartSizeMax);
          translatedTo = clamp6(Math.round(axis.toPixels(pick23(threshold.value, extremes.max), true) || 0), 0, chartSizeMax);
          if (ignoreZones) {
            translatedFrom = translatedTo = axis.toPixels(extremes.max);
          }
          pxRange = Math.abs(translatedFrom - translatedTo);
          pxPosMin = Math.min(translatedFrom, translatedTo);
          pxPosMax = Math.max(translatedFrom, translatedTo);
          if (axis.isXAxis) {
            clipAttr = {
              x: inverted ? pxPosMax : pxPosMin,
              y: 0,
              width: pxRange,
              height: chartSizeMax
            };
            if (!horiz) {
              clipAttr.x = chart.plotHeight - clipAttr.x;
            }
          } else {
            clipAttr = {
              x: 0,
              y: inverted ? pxPosMax : pxPosMin,
              width: chartSizeMax,
              height: pxRange
            };
            if (horiz) {
              clipAttr.y = chart.plotWidth - clipAttr.y;
            }
          }
          if (inverted && renderer.isVML) {
            if (axis.isXAxis) {
              clipAttr = {
                x: 0,
                y: reversed ? pxPosMin : pxPosMax,
                height: clipAttr.width,
                width: chart.chartWidth
              };
            } else {
              clipAttr = {
                x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
                y: 0,
                width: clipAttr.height,
                height: chart.chartHeight
              };
            }
          }
          if (clips[i]) {
            clips[i].animate(clipAttr);
          } else {
            clips[i] = renderer.clipRect(clipAttr);
          }
          zoneArea = series["zone-area-" + i];
          zoneGraph = series["zone-graph-" + i];
          if (graph && zoneGraph) {
            zoneGraph.clip(clips[i]);
          }
          if (area && zoneArea) {
            zoneArea.clip(clips[i]);
          }
          ignoreZones = threshold.value > extremes.max;
          if (series.resetZones && translatedTo === 0) {
            translatedTo = void 0;
          }
        });
        this.clips = clips;
      } else if (series.visible) {
        if (graph) {
          graph.show(true);
        }
        if (area) {
          area.show(true);
        }
      }
    };
    Series16.prototype.invertGroups = function(inverted) {
      var series = this, chart = series.chart;
      function setInvert() {
        ["group", "markerGroup"].forEach(function(groupName) {
          if (series[groupName]) {
            if (chart.renderer.isVML) {
              series[groupName].attr({
                width: series.yAxis.len,
                height: series.xAxis.len
              });
            }
            series[groupName].width = series.yAxis.len;
            series[groupName].height = series.xAxis.len;
            series[groupName].invert(series.isRadialSeries ? false : inverted);
          }
        });
      }
      if (!series.xAxis) {
        return;
      }
      series.eventsToUnbind.push(addEvent13(chart, "resize", setInvert));
      setInvert();
      series.invertGroups = setInvert;
    };
    Series16.prototype.plotGroup = function(prop, name, visibility, zIndex, parent) {
      var group = this[prop];
      var isNew = !group, attrs = {
        visibility,
        zIndex: zIndex || 0.1
        // IE8 and pointer logic use this
      };
      if (typeof this.opacity !== "undefined" && !this.chart.styledMode && this.state !== "inactive") {
        attrs.opacity = this.opacity;
      }
      if (isNew) {
        this[prop] = group = this.chart.renderer.g().add(parent);
      }
      group.addClass("highcharts-" + name + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (defined17(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (group.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
      group.attr(attrs)[isNew ? "attr" : "animate"](this.getPlotBox());
      return group;
    };
    Series16.prototype.getPlotBox = function() {
      var chart = this.chart;
      var xAxis = this.xAxis, yAxis = this.yAxis;
      if (chart.inverted) {
        xAxis = yAxis;
        yAxis = this.xAxis;
      }
      return {
        translateX: xAxis ? xAxis.left : chart.plotLeft,
        translateY: yAxis ? yAxis.top : chart.plotTop,
        scaleX: 1,
        scaleY: 1
      };
    };
    Series16.prototype.removeEvents = function(keepEventsForUpdate) {
      var series = this;
      if (!keepEventsForUpdate) {
        removeEvent8(series);
      }
      if (series.eventsToUnbind.length) {
        series.eventsToUnbind.forEach(function(unbind) {
          unbind();
        });
        series.eventsToUnbind.length = 0;
      }
    };
    Series16.prototype.render = function() {
      var series = this, chart = series.chart, options = series.options, animOptions = animObject7(options.animation), visibility = series.visible ? "inherit" : "hidden", zIndex = options.zIndex, hasRendered = series.hasRendered, chartSeriesGroup = chart.seriesGroup, inverted = chart.inverted;
      var animDuration = !series.finishedAnimating && chart.renderer.isSVG && animOptions.duration;
      fireEvent11(this, "render");
      var group = series.plotGroup("group", "series", visibility, zIndex, chartSeriesGroup);
      series.markerGroup = series.plotGroup("markerGroup", "markers", visibility, zIndex, chartSeriesGroup);
      if (animDuration && series.animate) {
        series.animate(true);
      }
      group.inverted = pick23(series.invertible, series.isCartesian) ? inverted : false;
      if (series.drawGraph) {
        series.drawGraph();
        series.applyZones();
      }
      if (series.visible) {
        series.drawPoints();
      }
      if (series.drawDataLabels) {
        series.drawDataLabels();
      }
      if (series.redrawPoints) {
        series.redrawPoints();
      }
      if (series.drawTracker && series.options.enableMouseTracking !== false) {
        series.drawTracker();
      }
      series.invertGroups(inverted);
      if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
        group.clip(chart.clipRect);
      }
      if (animDuration && series.animate) {
        series.animate();
      }
      if (!hasRendered) {
        if (animDuration && animOptions.defer) {
          animDuration += animOptions.defer;
        }
        series.animationTimeout = syncTimeout8(function() {
          series.afterAnimate();
        }, animDuration || 0);
      }
      series.isDirty = false;
      series.hasRendered = true;
      fireEvent11(series, "afterRender");
    };
    Series16.prototype.redraw = function() {
      var series = this, chart = series.chart, wasDirty = series.isDirty || series.isDirtyData, group = series.group, xAxis = series.xAxis, yAxis = series.yAxis;
      if (group) {
        if (chart.inverted) {
          group.attr({
            width: chart.plotWidth,
            height: chart.plotHeight
          });
        }
        group.animate({
          translateX: pick23(xAxis && xAxis.left, chart.plotLeft),
          translateY: pick23(yAxis && yAxis.top, chart.plotTop)
        });
      }
      series.translate();
      series.render();
      if (wasDirty) {
        delete this.kdTree;
      }
    };
    Series16.prototype.searchPoint = function(e2, compareX) {
      var series = this, xAxis = series.xAxis, yAxis = series.yAxis, inverted = series.chart.inverted;
      return this.searchKDTree({
        clientX: inverted ? xAxis.len - e2.chartY + xAxis.pos : e2.chartX - xAxis.pos,
        plotY: inverted ? yAxis.len - e2.chartX + yAxis.pos : e2.chartY - yAxis.pos
      }, compareX, e2);
    };
    Series16.prototype.buildKDTree = function(e2) {
      this.buildingKdTree = true;
      var series = this, dimensions = series.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
      function _kdtree(points, depth, dimensions2) {
        var length = points && points.length;
        var axis, median;
        if (length) {
          axis = series.kdAxisArray[depth % dimensions2];
          points.sort(function(a, b) {
            return a[axis] - b[axis];
          });
          median = Math.floor(length / 2);
          return {
            point: points[median],
            left: _kdtree(points.slice(0, median), depth + 1, dimensions2),
            right: _kdtree(points.slice(median + 1), depth + 1, dimensions2)
          };
        }
      }
      function startRecursive() {
        series.kdTree = _kdtree(series.getValidPoints(
          null,
          // For line-type series restrict to plot area, but
          // column-type series not (#3916, #4511)
          !series.directTouch
        ), dimensions, dimensions);
        series.buildingKdTree = false;
      }
      delete series.kdTree;
      syncTimeout8(startRecursive, series.options.kdNow || e2 && e2.type === "touchstart" ? 0 : 1);
    };
    Series16.prototype.searchKDTree = function(point, compareX, e2) {
      var series = this, kdX = this.kdAxisArray[0], kdY = this.kdAxisArray[1], kdComparer = compareX ? "distX" : "dist", kdDimensions = series.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
      function setDistance(p1, p2) {
        var x = defined17(p1[kdX]) && defined17(p2[kdX]) ? Math.pow(p1[kdX] - p2[kdX], 2) : null, y = defined17(p1[kdY]) && defined17(p2[kdY]) ? Math.pow(p1[kdY] - p2[kdY], 2) : null, r = (x || 0) + (y || 0);
        p2.dist = defined17(r) ? Math.sqrt(r) : Number.MAX_VALUE;
        p2.distX = defined17(x) ? Math.sqrt(x) : Number.MAX_VALUE;
      }
      function _search(search, tree, depth, dimensions) {
        var point2 = tree.point, axis = series.kdAxisArray[depth % dimensions];
        var nPoint1, nPoint2, ret = point2;
        setDistance(search, point2);
        var tdist = search[axis] - point2[axis], sideA = tdist < 0 ? "left" : "right", sideB = tdist < 0 ? "right" : "left";
        if (tree[sideA]) {
          nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);
          ret = nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point2;
        }
        if (tree[sideB]) {
          if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
            nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
            ret = nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret;
          }
        }
        return ret;
      }
      if (!this.kdTree && !this.buildingKdTree) {
        this.buildKDTree(e2);
      }
      if (this.kdTree) {
        return _search(point, this.kdTree, kdDimensions, kdDimensions);
      }
    };
    Series16.prototype.pointPlacementToXValue = function() {
      var _a15 = this, _b = _a15.options, pointPlacement = _b.pointPlacement, pointRange = _b.pointRange, axis = _a15.xAxis;
      var factor = pointPlacement;
      if (factor === "between") {
        factor = axis.reversed ? -0.5 : 0.5;
      }
      return isNumber18(factor) ? factor * (pointRange || axis.pointRange) : 0;
    };
    Series16.prototype.isPointInside = function(point) {
      var isInside = typeof point.plotY !== "undefined" && typeof point.plotX !== "undefined" && point.plotY >= 0 && point.plotY <= this.yAxis.len && // #3519
      point.plotX >= 0 && point.plotX <= this.xAxis.len;
      return isInside;
    };
    Series16.prototype.drawTracker = function() {
      var series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath), chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip.snap, tracker = series.tracker, onMouseOver = function(e2) {
        if (chart.hoverSeries !== series) {
          series.onMouseOver();
        }
      }, TRACKER_FILL2 = "rgba(192,192,192," + (svg4 ? 1e-4 : 2e-3) + ")";
      var i;
      if (tracker) {
        tracker.attr({ d: trackerPath });
      } else if (series.graph) {
        series.tracker = renderer.path(trackerPath).attr({
          visibility: series.visible ? "visible" : "hidden",
          zIndex: 2
        }).addClass(trackByArea ? "highcharts-tracker-area" : "highcharts-tracker-line").add(series.group);
        if (!chart.styledMode) {
          series.tracker.attr({
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            stroke: TRACKER_FILL2,
            fill: trackByArea ? TRACKER_FILL2 : "none",
            "stroke-width": series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap)
          });
        }
        [
          series.tracker,
          series.markerGroup,
          series.dataLabelsGroup
        ].forEach(function(tracker2) {
          if (tracker2) {
            tracker2.addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e2) {
              pointer.onTrackerMouseOut(e2);
            });
            if (options.cursor && !chart.styledMode) {
              tracker2.css({ cursor: options.cursor });
            }
            if (hasTouch) {
              tracker2.on("touchstart", onMouseOver);
            }
          }
        });
      }
      fireEvent11(this, "afterDrawTracker");
    };
    Series16.prototype.addPoint = function(options, redraw, shift, animation, withEvent) {
      var series = this, seriesOptions = series.options, data = series.data, chart = series.chart, xAxis = series.xAxis, names = xAxis && xAxis.hasNames && xAxis.names, dataOptions = seriesOptions.data, xData = series.xData;
      var isInTheMiddle, i;
      redraw = pick23(redraw, true);
      var point = { series };
      series.pointClass.prototype.applyOptions.apply(point, [options]);
      var x = point.x;
      i = xData.length;
      if (series.requireSorting && x < xData[i - 1]) {
        isInTheMiddle = true;
        while (i && xData[i - 1] > x) {
          i--;
        }
      }
      series.updateParallelArrays(point, "splice", i, 0, 0);
      series.updateParallelArrays(point, i);
      if (names && point.name) {
        names[x] = point.name;
      }
      dataOptions.splice(i, 0, options);
      if (isInTheMiddle) {
        series.data.splice(i, 0, null);
        series.processData();
      }
      if (seriesOptions.legendType === "point") {
        series.generatePoints();
      }
      if (shift) {
        if (data[0] && data[0].remove) {
          data[0].remove(false);
        } else {
          data.shift();
          series.updateParallelArrays(point, "shift");
          dataOptions.shift();
        }
      }
      if (withEvent !== false) {
        fireEvent11(series, "addPoint", { point });
      }
      series.isDirty = true;
      series.isDirtyData = true;
      if (redraw) {
        chart.redraw(animation);
      }
    };
    Series16.prototype.removePoint = function(i, redraw, animation) {
      var series = this, data = series.data, point = data[i], points = series.points, chart = series.chart, remove = function() {
        if (points && points.length === data.length) {
          points.splice(i, 1);
        }
        data.splice(i, 1);
        series.options.data.splice(i, 1);
        series.updateParallelArrays(point || { series }, "splice", i, 1);
        if (point) {
          point.destroy();
        }
        series.isDirty = true;
        series.isDirtyData = true;
        if (redraw) {
          chart.redraw();
        }
      };
      setAnimation4(animation, chart);
      redraw = pick23(redraw, true);
      if (point) {
        point.firePointEvent("remove", null, remove);
      } else {
        remove();
      }
    };
    Series16.prototype.remove = function(redraw, animation, withEvent, keepEvents) {
      var series = this, chart = series.chart;
      function remove() {
        series.destroy(keepEvents);
        chart.isDirtyLegend = chart.isDirtyBox = true;
        chart.linkSeries();
        if (pick23(redraw, true)) {
          chart.redraw(animation);
        }
      }
      if (withEvent !== false) {
        fireEvent11(series, "remove", null, remove);
      } else {
        remove();
      }
    };
    Series16.prototype.update = function(options, redraw) {
      options = cleanRecursively3(options, this.userOptions);
      fireEvent11(this, "update", { options });
      var series = this, chart = series.chart, oldOptions = series.userOptions, initialType = series.initialType || series.type, plotOptions = chart.options.plotOptions, initialSeriesProto = seriesTypes2[initialType].prototype, groups = [
        "group",
        "markerGroup",
        "dataLabelsGroup",
        "transformGroup"
      ], animation = series.finishedAnimating && { animation: false }, kinds = {};
      var seriesOptions, n, preserve = [
        "eventOptions",
        "navigatorSeries",
        "baseSeries"
      ], newType = options.type || oldOptions.type || chart.options.chart.type;
      var keepPoints = !// Indicators, histograms etc recalculate the data. It should be
      // possible to omit this.
      (this.hasDerivedData || // New type requires new point classes
      newType && newType !== this.type || // New options affecting how the data points are built
      typeof options.pointStart !== "undefined" || typeof options.pointInterval !== "undefined" || typeof options.relativeXValue !== "undefined" || // Changes to data grouping requires new points in new group
      series.hasOptionChanged("dataGrouping") || series.hasOptionChanged("pointStart") || series.hasOptionChanged("pointInterval") || series.hasOptionChanged("pointIntervalUnit") || series.hasOptionChanged("keys"));
      newType = newType || initialType;
      if (keepPoints) {
        preserve.push(
          "data",
          "isDirtyData",
          "points",
          "processedXData",
          "processedYData",
          "xIncrement",
          "cropped",
          "_hasPointMarkers",
          "_hasPointLabels",
          "clips",
          // #15420
          // Networkgraph (#14397)
          "nodes",
          "layout",
          // Map specific, consider moving it to series-specific preserve-
          // properties (#10617)
          "mapMap",
          "mapData",
          "minY",
          "maxY",
          "minX",
          "maxX"
        );
        if (options.visible !== false) {
          preserve.push("area", "graph");
        }
        series.parallelArrays.forEach(function(key) {
          preserve.push(key + "Data");
        });
        if (options.data) {
          if (options.dataSorting) {
            extend15(series.options.dataSorting, options.dataSorting);
          }
          this.setData(options.data, false);
        }
      }
      options = merge18(oldOptions, animation, {
        // When oldOptions.index is null it should't be cleared.
        // Otherwise navigator series will have wrong indexes (#10193).
        index: typeof oldOptions.index === "undefined" ? series.index : oldOptions.index,
        pointStart: pick23(
          // when updating from blank (#7933)
          plotOptions && plotOptions.series && plotOptions.series.pointStart,
          oldOptions.pointStart,
          // when updating after addPoint
          series.xData[0]
        )
      }, !keepPoints && { data: series.options.data }, options);
      if (keepPoints && options.data) {
        options.data = series.options.data;
      }
      preserve = groups.concat(preserve);
      preserve.forEach(function(prop) {
        preserve[prop] = series[prop];
        delete series[prop];
      });
      var casting = false;
      if (seriesTypes2[newType]) {
        casting = newType !== series.type;
        series.remove(false, false, false, true);
        if (casting) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(series, seriesTypes2[newType].prototype);
          } else {
            var ownEvents = Object.hasOwnProperty.call(series, "hcEvents") && series.hcEvents;
            for (n in initialSeriesProto) {
              series[n] = void 0;
            }
            extend15(series, seriesTypes2[newType].prototype);
            if (ownEvents) {
              series.hcEvents = ownEvents;
            } else {
              delete series.hcEvents;
            }
          }
        }
      } else {
        error7(17, true, chart, { missingModuleFor: newType });
      }
      preserve.forEach(function(prop) {
        series[prop] = preserve[prop];
      });
      series.init(chart, options);
      if (keepPoints && this.points) {
        seriesOptions = series.options;
        if (seriesOptions.visible === false) {
          kinds.graphic = 1;
          kinds.dataLabel = 1;
        } else if (!series._hasPointLabels) {
          var marker = seriesOptions.marker, dataLabels = seriesOptions.dataLabels;
          if (marker && (marker.enabled === false || (oldOptions.marker && oldOptions.marker.symbol) !== marker.symbol)) {
            kinds.graphic = 1;
          }
          if (dataLabels && dataLabels.enabled === false) {
            kinds.dataLabel = 1;
          }
        }
        this.points.forEach(function(point) {
          if (point && point.series) {
            point.resolveColor();
            if (Object.keys(kinds).length) {
              point.destroyElements(kinds);
            }
            if (seriesOptions.showInLegend === false && point.legendItem) {
              chart.legend.destroyItem(point);
            }
          }
        }, this);
      }
      series.initialType = initialType;
      chart.linkSeries();
      if (casting && series.linkedSeries.length) {
        series.isDirtyData = true;
      }
      fireEvent11(this, "afterUpdate");
      if (pick23(redraw, true)) {
        chart.redraw(keepPoints ? void 0 : false);
      }
    };
    Series16.prototype.setName = function(name) {
      this.name = this.options.name = this.userOptions.name = name;
      this.chart.isDirtyLegend = true;
    };
    Series16.prototype.hasOptionChanged = function(optionName) {
      var chart = this.chart, option = this.options[optionName], plotOptions = chart.options.plotOptions, oldOption = this.userOptions[optionName];
      if (oldOption) {
        return option !== oldOption;
      }
      return option !== pick23(plotOptions && plotOptions[this.type] && plotOptions[this.type][optionName], plotOptions && plotOptions.series && plotOptions.series[optionName], option);
    };
    Series16.prototype.onMouseOver = function() {
      var series = this, chart = series.chart, hoverSeries = chart.hoverSeries, pointer = chart.pointer;
      pointer.setHoverChartIndex();
      if (hoverSeries && hoverSeries !== series) {
        hoverSeries.onMouseOut();
      }
      if (series.options.events.mouseOver) {
        fireEvent11(series, "mouseOver");
      }
      series.setState("hover");
      chart.hoverSeries = series;
    };
    Series16.prototype.onMouseOut = function() {
      var series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
      chart.hoverSeries = null;
      if (hoverPoint) {
        hoverPoint.onMouseOut();
      }
      if (series && options.events.mouseOut) {
        fireEvent11(series, "mouseOut");
      }
      if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
        tooltip.hide();
      }
      chart.series.forEach(function(s) {
        s.setState("", true);
      });
    };
    Series16.prototype.setState = function(state, inherit) {
      var series = this, options = series.options, graph = series.graph, inactiveOtherPoints = options.inactiveOtherPoints, stateOptions = options.states, stateAnimation = pick23(stateOptions[state || "normal"] && stateOptions[state || "normal"].animation, series.chart.options.chart.animation);
      var attribs, lineWidth = options.lineWidth, i = 0, opacity = options.opacity;
      state = state || "";
      if (series.state !== state) {
        [
          series.group,
          series.markerGroup,
          series.dataLabelsGroup
        ].forEach(function(group) {
          if (group) {
            if (series.state) {
              group.removeClass("highcharts-series-" + series.state);
            }
            if (state) {
              group.addClass("highcharts-series-" + state);
            }
          }
        });
        series.state = state;
        if (!series.chart.styledMode) {
          if (stateOptions[state] && stateOptions[state].enabled === false) {
            return;
          }
          if (state) {
            lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0);
            opacity = pick23(stateOptions[state].opacity, opacity);
          }
          if (graph && !graph.dashstyle) {
            attribs = {
              "stroke-width": lineWidth
            };
            graph.animate(attribs, stateAnimation);
            while (series["zone-graph-" + i]) {
              series["zone-graph-" + i].animate(attribs, stateAnimation);
              i = i + 1;
            }
          }
          if (!inactiveOtherPoints) {
            [
              series.group,
              series.markerGroup,
              series.dataLabelsGroup,
              series.labelBySeries
            ].forEach(function(group) {
              if (group) {
                group.animate({
                  opacity
                }, stateAnimation);
              }
            });
          }
        }
      }
      if (inherit && inactiveOtherPoints && series.points) {
        series.setAllPointsToState(state || void 0);
      }
    };
    Series16.prototype.setAllPointsToState = function(state) {
      this.points.forEach(function(point) {
        if (point.setState) {
          point.setState(state);
        }
      });
    };
    Series16.prototype.setVisible = function(vis, redraw) {
      var series = this, chart = series.chart, legendItem = series.legendItem, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
      series.visible = vis = series.options.visible = series.userOptions.visible = typeof vis === "undefined" ? !oldVisibility : vis;
      var showOrHide = vis ? "show" : "hide";
      [
        "group",
        "dataLabelsGroup",
        "markerGroup",
        "tracker",
        "tt"
      ].forEach(function(key) {
        if (series[key]) {
          series[key][showOrHide]();
        }
      });
      if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
        series.onMouseOut();
      }
      if (legendItem) {
        chart.legend.colorizeItem(series, vis);
      }
      series.isDirty = true;
      if (series.options.stacking) {
        chart.series.forEach(function(otherSeries) {
          if (otherSeries.options.stacking && otherSeries.visible) {
            otherSeries.isDirty = true;
          }
        });
      }
      series.linkedSeries.forEach(function(otherSeries) {
        otherSeries.setVisible(vis, false);
      });
      if (ignoreHiddenSeries) {
        chart.isDirtyBox = true;
      }
      fireEvent11(series, showOrHide);
      if (redraw !== false) {
        chart.redraw();
      }
    };
    Series16.prototype.show = function() {
      this.setVisible(true);
    };
    Series16.prototype.hide = function() {
      this.setVisible(false);
    };
    Series16.prototype.select = function(selected) {
      var series = this;
      series.selected = selected = this.options.selected = typeof selected === "undefined" ? !series.selected : selected;
      if (series.checkbox) {
        series.checkbox.checked = selected;
      }
      fireEvent11(series, selected ? "select" : "unselect");
    };
    Series16.prototype.shouldShowTooltip = function(plotX, plotY, options) {
      if (options === void 0) {
        options = {};
      }
      options.series = this;
      options.visiblePlotOnly = true;
      return this.chart.isInsidePlot(plotX, plotY, options);
    };
    Series16.defaultOptions = SeriesDefaults_default;
    return Series16;
  }()
);
extend15(Series.prototype, {
  axisTypes: ["xAxis", "yAxis"],
  coll: "series",
  colorCounter: 0,
  cropShoulder: 1,
  directTouch: false,
  drawLegendSymbol: LegendSymbol_default.drawLineMarker,
  isCartesian: true,
  kdAxisArray: ["clientX", "plotY"],
  // each point's x and y values are stored in this.xData and this.yData:
  parallelArrays: ["x", "y"],
  pointClass: Point_default,
  requireSorting: true,
  // requires the data to be sorted:
  sorted: true
});
SeriesRegistry_default.series = Series;
var Series_default = Series;

// node_modules/highcharts/es-modules/Extensions/ScrollablePlotArea.js
var stop3 = AnimationUtilities_default.stop;
var addEvent14 = Utilities_default.addEvent;
var createElement8 = Utilities_default.createElement;
var merge19 = Utilities_default.merge;
var pick24 = Utilities_default.pick;
addEvent14(Chart_default, "afterSetChartSize", function(e2) {
  var scrollablePlotArea = this.options.chart.scrollablePlotArea, scrollableMinWidth = scrollablePlotArea && scrollablePlotArea.minWidth, scrollableMinHeight = scrollablePlotArea && scrollablePlotArea.minHeight, scrollablePixelsX, scrollablePixelsY, corrections;
  if (!this.renderer.forExport) {
    if (scrollableMinWidth) {
      this.scrollablePixelsX = scrollablePixelsX = Math.max(0, scrollableMinWidth - this.chartWidth);
      if (scrollablePixelsX) {
        this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge19(this.plotBox);
        this.plotBox.width = this.plotWidth += scrollablePixelsX;
        if (this.inverted) {
          this.clipBox.height += scrollablePixelsX;
        } else {
          this.clipBox.width += scrollablePixelsX;
        }
        corrections = {
          // Corrections for right side
          1: { name: "right", value: scrollablePixelsX }
        };
      }
    } else if (scrollableMinHeight) {
      this.scrollablePixelsY = scrollablePixelsY = Math.max(0, scrollableMinHeight - this.chartHeight);
      if (scrollablePixelsY) {
        this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge19(this.plotBox);
        this.plotBox.height = this.plotHeight += scrollablePixelsY;
        if (this.inverted) {
          this.clipBox.width += scrollablePixelsY;
        } else {
          this.clipBox.height += scrollablePixelsY;
        }
        corrections = {
          2: { name: "bottom", value: scrollablePixelsY }
        };
      }
    }
    if (corrections && !e2.skipAxes) {
      this.axes.forEach(function(axis) {
        if (corrections[axis.side]) {
          axis.getPlotLinePath = function() {
            var marginName = corrections[axis.side].name, correctionValue = corrections[axis.side].value, margin = this[marginName], path;
            this[marginName] = margin - correctionValue;
            path = Axis_default.prototype.getPlotLinePath.apply(this, arguments);
            this[marginName] = margin;
            return path;
          };
        } else {
          axis.setAxisSize();
          axis.setAxisTranslation();
        }
      });
    }
  }
});
addEvent14(Chart_default, "render", function() {
  if (this.scrollablePixelsX || this.scrollablePixelsY) {
    if (this.setUpScrolling) {
      this.setUpScrolling();
    }
    this.applyFixed();
  } else if (this.fixedDiv) {
    this.applyFixed();
  }
});
Chart_default.prototype.setUpScrolling = function() {
  var _this = this;
  var css16 = {
    WebkitOverflowScrolling: "touch",
    overflowX: "hidden",
    overflowY: "hidden"
  };
  if (this.scrollablePixelsX) {
    css16.overflowX = "auto";
  }
  if (this.scrollablePixelsY) {
    css16.overflowY = "auto";
  }
  this.scrollingParent = createElement8("div", {
    className: "highcharts-scrolling-parent"
  }, {
    position: "relative"
  }, this.renderTo);
  this.scrollingContainer = createElement8("div", {
    "className": "highcharts-scrolling"
  }, css16, this.scrollingParent);
  addEvent14(this.scrollingContainer, "scroll", function() {
    if (_this.pointer) {
      delete _this.pointer.chartPosition;
    }
  });
  this.innerContainer = createElement8("div", {
    "className": "highcharts-inner-container"
  }, null, this.scrollingContainer);
  this.innerContainer.appendChild(this.container);
  this.setUpScrolling = null;
};
Chart_default.prototype.moveFixedElements = function() {
  var container = this.container, fixedRenderer = this.fixedRenderer, fixedSelectors = [
    ".highcharts-contextbutton",
    ".highcharts-credits",
    ".highcharts-legend",
    ".highcharts-legend-checkbox",
    ".highcharts-navigator-series",
    ".highcharts-navigator-xaxis",
    ".highcharts-navigator-yaxis",
    ".highcharts-navigator",
    ".highcharts-reset-zoom",
    ".highcharts-drillup-button",
    ".highcharts-scrollbar",
    ".highcharts-subtitle",
    ".highcharts-title"
  ], axisClass;
  if (this.scrollablePixelsX && !this.inverted) {
    axisClass = ".highcharts-yaxis";
  } else if (this.scrollablePixelsX && this.inverted) {
    axisClass = ".highcharts-xaxis";
  } else if (this.scrollablePixelsY && !this.inverted) {
    axisClass = ".highcharts-xaxis";
  } else if (this.scrollablePixelsY && this.inverted) {
    axisClass = ".highcharts-yaxis";
  }
  if (axisClass) {
    fixedSelectors.push(axisClass + ":not(.highcharts-radial-axis)", axisClass + "-labels:not(.highcharts-radial-axis-labels)");
  }
  fixedSelectors.forEach(function(className) {
    [].forEach.call(container.querySelectorAll(className), function(elem) {
      (elem.namespaceURI === fixedRenderer.SVG_NS ? fixedRenderer.box : fixedRenderer.box.parentNode).appendChild(elem);
      elem.style.pointerEvents = "auto";
    });
  });
};
Chart_default.prototype.applyFixed = function() {
  var firstTime = !this.fixedDiv, chartOptions = this.options.chart, scrollableOptions = chartOptions.scrollablePlotArea, Renderer2 = RendererRegistry_default.getRendererType();
  var fixedRenderer, scrollableWidth, scrollableHeight;
  if (firstTime) {
    this.fixedDiv = createElement8("div", {
      className: "highcharts-fixed"
    }, {
      position: "absolute",
      overflow: "hidden",
      pointerEvents: "none",
      zIndex: (chartOptions.style && chartOptions.style.zIndex || 0) + 2,
      top: 0
    }, null, true);
    if (this.scrollingContainer) {
      this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer);
    }
    this.renderTo.style.overflow = "visible";
    this.fixedRenderer = fixedRenderer = new Renderer2(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style);
    this.scrollableMask = fixedRenderer.path().attr({
      fill: this.options.chart.backgroundColor || "#fff",
      "fill-opacity": pick24(scrollableOptions.opacity, 0.85),
      zIndex: -1
    }).addClass("highcharts-scrollable-mask").add();
    addEvent14(this, "afterShowResetZoom", this.moveFixedElements);
    addEvent14(this, "afterDrilldown", this.moveFixedElements);
    addEvent14(this, "afterLayOutTitles", this.moveFixedElements);
  } else {
    this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
  }
  if (this.scrollableDirty || firstTime) {
    this.scrollableDirty = false;
    this.moveFixedElements();
  }
  scrollableWidth = this.chartWidth + (this.scrollablePixelsX || 0);
  scrollableHeight = this.chartHeight + (this.scrollablePixelsY || 0);
  stop3(this.container);
  this.container.style.width = scrollableWidth + "px";
  this.container.style.height = scrollableHeight + "px";
  this.renderer.boxWrapper.attr({
    width: scrollableWidth,
    height: scrollableHeight,
    viewBox: [0, 0, scrollableWidth, scrollableHeight].join(" ")
  });
  this.chartBackground.attr({
    width: scrollableWidth,
    height: scrollableHeight
  });
  this.scrollingContainer.style.height = this.chartHeight + "px";
  if (firstTime) {
    if (scrollableOptions.scrollPositionX) {
      this.scrollingContainer.scrollLeft = this.scrollablePixelsX * scrollableOptions.scrollPositionX;
    }
    if (scrollableOptions.scrollPositionY) {
      this.scrollingContainer.scrollTop = this.scrollablePixelsY * scrollableOptions.scrollPositionY;
    }
  }
  var axisOffset = this.axisOffset, maskTop = this.plotTop - axisOffset[0] - 1, maskLeft = this.plotLeft - axisOffset[3] - 1, maskBottom = this.plotTop + this.plotHeight + axisOffset[2] + 1, maskRight = this.plotLeft + this.plotWidth + axisOffset[1] + 1, maskPlotRight = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), maskPlotBottom = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0), d;
  if (this.scrollablePixelsX) {
    d = [
      // Left side
      ["M", 0, maskTop],
      ["L", this.plotLeft - 1, maskTop],
      ["L", this.plotLeft - 1, maskBottom],
      ["L", 0, maskBottom],
      ["Z"],
      // Right side
      ["M", maskPlotRight, maskTop],
      ["L", this.chartWidth, maskTop],
      ["L", this.chartWidth, maskBottom],
      ["L", maskPlotRight, maskBottom],
      ["Z"]
    ];
  } else if (this.scrollablePixelsY) {
    d = [
      // Top side
      ["M", maskLeft, 0],
      ["L", maskLeft, this.plotTop - 1],
      ["L", maskRight, this.plotTop - 1],
      ["L", maskRight, 0],
      ["Z"],
      // Bottom side
      ["M", maskLeft, maskPlotBottom],
      ["L", maskLeft, this.chartHeight],
      ["L", maskRight, this.chartHeight],
      ["L", maskRight, maskPlotBottom],
      ["Z"]
    ];
  } else {
    d = [["M", 0, 0]];
  }
  if (this.redrawTrigger !== "adjustHeight") {
    this.scrollableMask.attr({ d });
  }
};
addEvent14(Axis_default, "afterInit", function() {
  this.chart.scrollableDirty = true;
});
addEvent14(Series_default, "show", function() {
  this.chart.scrollableDirty = true;
});

// node_modules/highcharts/es-modules/Core/Axis/StackingAxis.js
var getDeferredAnimation2 = AnimationUtilities_default.getDeferredAnimation;
var addEvent15 = Utilities_default.addEvent;
var destroyObjectProperties6 = Utilities_default.destroyObjectProperties;
var fireEvent12 = Utilities_default.fireEvent;
var isNumber19 = Utilities_default.isNumber;
var objectEach17 = Utilities_default.objectEach;
var StackingAxis;
(function(StackingAxis2) {
  var composedClasses2 = [];
  function compose(AxisClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      addEvent15(AxisClass, "init", onInit);
      addEvent15(AxisClass, "destroy", onDestroy);
    }
    return AxisClass;
  }
  StackingAxis2.compose = compose;
  function onDestroy() {
    var stacking = this.stacking;
    if (!stacking) {
      return;
    }
    var stacks = stacking.stacks;
    objectEach17(stacks, function(stack, stackKey) {
      destroyObjectProperties6(stack);
      stacks[stackKey] = null;
    });
    if (stacking && stacking.stackTotalGroup) {
      stacking.stackTotalGroup.destroy();
    }
  }
  function onInit() {
    var axis = this;
    if (!axis.stacking) {
      axis.stacking = new Additions(axis);
    }
  }
  var Additions = (
    /** @class */
    function() {
      function Additions2(axis) {
        this.oldStacks = {};
        this.stacks = {};
        this.stacksTouched = 0;
        this.axis = axis;
      }
      Additions2.prototype.buildStacks = function() {
        var stacking = this;
        var axis = stacking.axis;
        var axisSeries = axis.series;
        var reversedStacks = axis.options.reversedStacks;
        var len = axisSeries.length;
        var actualSeries, i;
        if (!axis.isXAxis) {
          stacking.usePercentage = false;
          i = len;
          while (i--) {
            actualSeries = axisSeries[reversedStacks ? i : len - i - 1];
            actualSeries.setStackedPoints();
            actualSeries.setGroupedPoints();
          }
          for (i = 0; i < len; i++) {
            axisSeries[i].modifyStacks();
          }
          fireEvent12(axis, "afterBuildStacks");
        }
      };
      Additions2.prototype.cleanStacks = function() {
        var stacking = this, axis = stacking.axis;
        var stacks;
        if (!axis.isXAxis) {
          if (stacking.oldStacks) {
            stacks = stacking.stacks = stacking.oldStacks;
          }
          objectEach17(stacks, function(type) {
            objectEach17(type, function(stack) {
              stack.cumulative = stack.total;
            });
          });
        }
      };
      Additions2.prototype.resetStacks = function() {
        var stacking = this, axis = stacking.axis, stacks = stacking.stacks;
        if (!axis.isXAxis) {
          objectEach17(stacks, function(type) {
            objectEach17(type, function(stack, x) {
              if (isNumber19(stack.touched) && stack.touched < stacking.stacksTouched) {
                stack.destroy();
                delete type[x];
              } else {
                stack.total = null;
                stack.cumulative = null;
              }
            });
          });
        }
      };
      Additions2.prototype.renderStackTotals = function() {
        var stacking = this, axis = stacking.axis, chart = axis.chart, renderer = chart.renderer, stacks = stacking.stacks, stackLabelsAnim = axis.options.stackLabels && axis.options.stackLabels.animation, animationConfig = getDeferredAnimation2(chart, stackLabelsAnim || false), stackTotalGroup = stacking.stackTotalGroup = stacking.stackTotalGroup || renderer.g("stack-labels").attr({
          visibility: "visible",
          zIndex: 6,
          opacity: 0
        }).add();
        stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
        objectEach17(stacks, function(type) {
          objectEach17(type, function(stack) {
            stack.render(stackTotalGroup);
          });
        });
        stackTotalGroup.animate({
          opacity: 1
        }, animationConfig);
      };
      return Additions2;
    }()
  );
  StackingAxis2.Additions = Additions;
})(StackingAxis || (StackingAxis = {}));
var StackingAxis_default = StackingAxis;

// node_modules/highcharts/es-modules/Extensions/Stacking.js
var format5 = FormatUtilities_default.format;
var correctFloat5 = Utilities_default.correctFloat;
var defined18 = Utilities_default.defined;
var destroyObjectProperties7 = Utilities_default.destroyObjectProperties;
var isArray10 = Utilities_default.isArray;
var isNumber20 = Utilities_default.isNumber;
var objectEach18 = Utilities_default.objectEach;
var pick25 = Utilities_default.pick;
var StackItem = (
  /** @class */
  function() {
    function StackItem2(axis, options, isNegative, x, stackOption) {
      var inverted = axis.chart.inverted;
      this.axis = axis;
      this.isNegative = isNegative;
      this.options = options = options || {};
      this.x = x;
      this.total = null;
      this.points = {};
      this.hasValidPoints = false;
      this.stack = stackOption;
      this.leftCliff = 0;
      this.rightCliff = 0;
      this.alignOptions = {
        align: options.align || (inverted ? isNegative ? "left" : "right" : "center"),
        verticalAlign: options.verticalAlign || (inverted ? "middle" : isNegative ? "bottom" : "top"),
        y: options.y,
        x: options.x
      };
      this.textAlign = options.textAlign || (inverted ? isNegative ? "right" : "left" : "center");
    }
    StackItem2.prototype.destroy = function() {
      destroyObjectProperties7(this, this.axis);
    };
    StackItem2.prototype.render = function(group) {
      var chart = this.axis.chart, options = this.options, formatOption = options.format, attr11 = {}, str = formatOption ? (
        // format the text in the label
        format5(formatOption, this, chart)
      ) : options.formatter.call(this);
      if (this.label) {
        this.label.attr({ text: str, visibility: "hidden" });
      } else {
        this.label = chart.renderer.label(str, null, null, options.shape, null, null, options.useHTML, false, "stack-labels");
        attr11 = {
          r: options.borderRadius || 0,
          text: str,
          rotation: options.rotation,
          padding: pick25(options.padding, 5),
          visibility: "hidden"
          // hidden until setOffset is called
        };
        if (!chart.styledMode) {
          attr11.fill = options.backgroundColor;
          attr11.stroke = options.borderColor;
          attr11["stroke-width"] = options.borderWidth;
          this.label.css(options.style);
        }
        this.label.attr(attr11);
        if (!this.label.added) {
          this.label.add(group);
        }
      }
      this.label.labelrank = chart.plotSizeY;
    };
    StackItem2.prototype.setOffset = function(xOffset, xWidth, boxBottom, boxTop, defaultX) {
      var stackItem = this, axis = stackItem.axis, chart = axis.chart, y = axis.translate(axis.stacking.usePercentage ? 100 : boxTop ? boxTop : stackItem.total, 0, 0, 0, 1), yZero = axis.translate(boxBottom ? boxBottom : 0), h = defined18(y) && Math.abs(y - yZero), x = pick25(defaultX, chart.xAxis[0].translate(stackItem.x)) + xOffset, stackBox = defined18(y) && stackItem.getStackBox(chart, stackItem, x, y, xWidth, h, axis), label = stackItem.label, isNegative = stackItem.isNegative, isJustify = pick25(stackItem.options.overflow, "justify") === "justify", textAlign = stackItem.textAlign, visible;
      if (label && stackBox) {
        var bBox = label.getBBox(), padding = label.padding, boxOffsetX = void 0, boxOffsetY = void 0;
        if (textAlign === "left") {
          boxOffsetX = chart.inverted ? -padding : padding;
        } else if (textAlign === "right") {
          boxOffsetX = bBox.width;
        } else {
          if (chart.inverted && textAlign === "center") {
            boxOffsetX = bBox.width / 2;
          } else {
            boxOffsetX = chart.inverted ? isNegative ? bBox.width + padding : -padding : bBox.width / 2;
          }
        }
        boxOffsetY = chart.inverted ? bBox.height / 2 : isNegative ? -padding : bBox.height;
        stackItem.alignOptions.x = pick25(stackItem.options.x, 0);
        stackItem.alignOptions.y = pick25(stackItem.options.y, 0);
        stackBox.x -= boxOffsetX;
        stackBox.y -= boxOffsetY;
        label.align(stackItem.alignOptions, null, stackBox);
        if (chart.isInsidePlot(label.alignAttr.x + boxOffsetX - stackItem.alignOptions.x, label.alignAttr.y + boxOffsetY - stackItem.alignOptions.y)) {
          label.show();
        } else {
          label.alignAttr.y = -9999;
          isJustify = false;
        }
        if (isJustify) {
          Series_default.prototype.justifyDataLabel.call(this.axis, label, stackItem.alignOptions, label.alignAttr, bBox, stackBox);
        }
        label.attr({
          x: label.alignAttr.x,
          y: label.alignAttr.y
        });
        if (pick25(!isJustify && stackItem.options.crop, true)) {
          visible = isNumber20(label.x) && isNumber20(label.y) && chart.isInsidePlot(label.x - padding + label.width, label.y) && chart.isInsidePlot(label.x + padding, label.y);
          if (!visible) {
            label.hide();
          }
        }
      }
    };
    StackItem2.prototype.getStackBox = function(chart, stackItem, x, y, xWidth, h, axis) {
      var reversed = stackItem.axis.reversed, inverted = chart.inverted, axisPos = axis.height + axis.pos - (inverted ? chart.plotLeft : chart.plotTop), neg = stackItem.isNegative && !reversed || !stackItem.isNegative && reversed;
      return {
        x: inverted ? neg ? y - axis.right : y - h + axis.pos - chart.plotLeft : x + chart.xAxis[0].transB - chart.plotLeft,
        y: inverted ? axis.height - x - xWidth : neg ? axisPos - y - h : axisPos - y,
        width: inverted ? h : xWidth,
        height: inverted ? xWidth : h
      };
    };
    return StackItem2;
  }()
);
Chart_default.prototype.getStacks = function() {
  var chart = this, inverted = chart.inverted;
  chart.yAxis.forEach(function(axis) {
    if (axis.stacking && axis.stacking.stacks && axis.hasVisibleSeries) {
      axis.stacking.oldStacks = axis.stacking.stacks;
    }
  });
  chart.series.forEach(function(series) {
    var xAxisOptions = series.xAxis && series.xAxis.options || {};
    if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
      series.stackKey = [
        series.type,
        pick25(series.options.stack, ""),
        inverted ? xAxisOptions.top : xAxisOptions.left,
        inverted ? xAxisOptions.height : xAxisOptions.width
      ].join(",");
    }
  });
};
StackingAxis_default.compose(Axis_default);
Series_default.prototype.setGroupedPoints = function() {
  var stacking = this.yAxis.stacking;
  if (this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && // With stacking enabled, we already have stacks that we can compute
  // from
  !this.options.stacking && // With only one series, we don't need to consider centerInCategory
  this.chart.series.length > 1) {
    Series_default.prototype.setStackedPoints.call(this, "group");
  } else if (stacking) {
    objectEach18(stacking.stacks, function(type, key) {
      if (key.slice(-5) === "group") {
        objectEach18(type, function(stack) {
          return stack.destroy();
        });
        delete stacking.stacks[key];
      }
    });
  }
};
Series_default.prototype.setStackedPoints = function(stackingParam) {
  var stacking = stackingParam || this.options.stacking;
  if (!stacking || this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false) {
    return;
  }
  var series = this, xData = series.processedXData, yData = series.processedYData, stackedYData = [], yDataLength = yData.length, seriesOptions = series.options, threshold = seriesOptions.threshold, stackThreshold = pick25(seriesOptions.startFromThreshold && threshold, 0), stackOption = seriesOptions.stack, stackKey = stackingParam ? series.type + "," + stacking : series.stackKey, negKey = "-" + stackKey, negStacks = series.negStacks, yAxis = series.yAxis, stacks = yAxis.stacking.stacks, oldStacks = yAxis.stacking.oldStacks, stackIndicator, isNegative, stack, other, key, pointKey, i, x, y;
  yAxis.stacking.stacksTouched += 1;
  for (i = 0; i < yDataLength; i++) {
    x = xData[i];
    y = yData[i];
    stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
    pointKey = stackIndicator.key;
    isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
    key = isNegative ? negKey : stackKey;
    if (!stacks[key]) {
      stacks[key] = {};
    }
    if (!stacks[key][x]) {
      if (oldStacks[key] && oldStacks[key][x]) {
        stacks[key][x] = oldStacks[key][x];
        stacks[key][x].total = null;
      } else {
        stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
      }
    }
    stack = stacks[key][x];
    if (y !== null) {
      stack.points[pointKey] = stack.points[series.index] = [pick25(stack.cumulative, stackThreshold)];
      if (!defined18(stack.cumulative)) {
        stack.base = pointKey;
      }
      stack.touched = yAxis.stacking.stacksTouched;
      if (stackIndicator.index > 0 && series.singleStacks === false) {
        stack.points[pointKey][0] = stack.points[series.index + "," + x + ",0"][0];
      }
    } else {
      stack.points[pointKey] = stack.points[series.index] = null;
    }
    if (stacking === "percent") {
      other = isNegative ? stackKey : negKey;
      if (negStacks && stacks[other] && stacks[other][x]) {
        other = stacks[other][x];
        stack.total = other.total = Math.max(other.total, stack.total) + Math.abs(y) || 0;
      } else {
        stack.total = correctFloat5(stack.total + (Math.abs(y) || 0));
      }
    } else if (stacking === "group") {
      if (isArray10(y)) {
        y = y[0];
      }
      if (y !== null) {
        stack.total = (stack.total || 0) + 1;
      }
    } else {
      stack.total = correctFloat5(stack.total + (y || 0));
    }
    if (stacking === "group") {
      stack.cumulative = (stack.total || 1) - 1;
    } else {
      stack.cumulative = pick25(stack.cumulative, stackThreshold) + (y || 0);
    }
    if (y !== null) {
      stack.points[pointKey].push(stack.cumulative);
      stackedYData[i] = stack.cumulative;
      stack.hasValidPoints = true;
    }
  }
  if (stacking === "percent") {
    yAxis.stacking.usePercentage = true;
  }
  if (stacking !== "group") {
    this.stackedYData = stackedYData;
  }
  yAxis.stacking.oldStacks = {};
};
Series_default.prototype.modifyStacks = function() {
  var series = this, yAxis = series.yAxis, stackKey = series.stackKey, stacks = yAxis.stacking.stacks, processedXData = series.processedXData, stackIndicator, stacking = series.options.stacking;
  if (series[stacking + "Stacker"]) {
    [stackKey, "-" + stackKey].forEach(function(key) {
      var i = processedXData.length, x, stack, pointExtremes;
      while (i--) {
        x = processedXData[i];
        stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);
        stack = stacks[key] && stacks[key][x];
        pointExtremes = stack && stack.points[stackIndicator.key];
        if (pointExtremes) {
          series[stacking + "Stacker"](pointExtremes, stack, i);
        }
      }
    });
  }
};
Series_default.prototype.percentStacker = function(pointExtremes, stack, i) {
  var totalFactor = stack.total ? 100 / stack.total : 0;
  pointExtremes[0] = correctFloat5(pointExtremes[0] * totalFactor);
  pointExtremes[1] = correctFloat5(pointExtremes[1] * totalFactor);
  this.stackedYData[i] = pointExtremes[1];
};
Series_default.prototype.getStackIndicator = function(stackIndicator, x, index, key) {
  if (!defined18(stackIndicator) || stackIndicator.x !== x || key && stackIndicator.key !== key) {
    stackIndicator = {
      x,
      index: 0,
      key
    };
  } else {
    stackIndicator.index++;
  }
  stackIndicator.key = [index, x, stackIndicator.index].join(",");
  return stackIndicator;
};
Globals_default.StackItem = StackItem;
var Stacking_default = Globals_default.StackItem;

// node_modules/highcharts/es-modules/Series/Line/LineSeries.js
var __extends5 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var defined19 = Utilities_default.defined;
var merge20 = Utilities_default.merge;
var LineSeries = (
  /** @class */
  function(_super) {
    __extends5(LineSeries7, _super);
    function LineSeries7() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    LineSeries7.prototype.drawGraph = function() {
      var series = this, options = this.options, graphPath = (this.gappedPath || this.getGraphPath).call(this), styledMode = this.chart.styledMode;
      var props = [[
        "graph",
        "highcharts-graph"
      ]];
      if (!styledMode) {
        props[0].push(options.lineColor || this.color || Palette_default.neutralColor20, options.dashStyle);
      }
      props = series.getZonesGraphs(props);
      props.forEach(function(prop, i) {
        var graphKey = prop[0];
        var attribs, graph = series[graphKey];
        var verb = graph ? "animate" : "attr";
        if (graph) {
          graph.endX = series.preventGraphAnimation ? null : graphPath.xMap;
          graph.animate({ d: graphPath });
        } else if (graphPath.length) {
          series[graphKey] = graph = series.chart.renderer.path(graphPath).addClass(prop[1]).attr({ zIndex: 1 }).add(series.group);
        }
        if (graph && !styledMode) {
          attribs = {
            "stroke": prop[2],
            "stroke-width": options.lineWidth,
            // Polygon series use filled graph
            "fill": series.fillGraph && series.color || "none"
          };
          if (prop[3]) {
            attribs.dashstyle = prop[3];
          } else if (options.linecap !== "square") {
            attribs["stroke-linecap"] = attribs["stroke-linejoin"] = "round";
          }
          graph[verb](attribs).shadow(i < 2 && options.shadow);
        }
        if (graph) {
          graph.startX = graphPath.xMap;
          graph.isArea = graphPath.isArea;
        }
      });
    };
    LineSeries7.prototype.getGraphPath = function(points, nullsAsZeroes, connectCliffs) {
      var series = this, options = series.options, graphPath = [], xMap = [];
      var gap, step = options.step;
      points = points || series.points;
      var reversed = points.reversed;
      if (reversed) {
        points.reverse();
      }
      step = {
        right: 1,
        center: 2
      }[step] || step && 3;
      if (step && reversed) {
        step = 4 - step;
      }
      points = this.getValidPoints(points, false, !(options.connectNulls && !nullsAsZeroes && !connectCliffs));
      points.forEach(function(point, i) {
        var plotX = point.plotX, plotY = point.plotY, lastPoint = points[i - 1];
        var pathToPoint;
        if ((point.leftCliff || lastPoint && lastPoint.rightCliff) && !connectCliffs) {
          gap = true;
        }
        if (point.isNull && !defined19(nullsAsZeroes) && i > 0) {
          gap = !options.connectNulls;
        } else if (point.isNull && !nullsAsZeroes) {
          gap = true;
        } else {
          if (i === 0 || gap) {
            pathToPoint = [[
              "M",
              point.plotX,
              point.plotY
            ]];
          } else if (series.getPointSpline) {
            pathToPoint = [series.getPointSpline(points, point, i)];
          } else if (step) {
            if (step === 1) {
              pathToPoint = [[
                "L",
                lastPoint.plotX,
                plotY
              ]];
            } else if (step === 2) {
              pathToPoint = [[
                "L",
                (lastPoint.plotX + plotX) / 2,
                lastPoint.plotY
              ], [
                "L",
                (lastPoint.plotX + plotX) / 2,
                plotY
              ]];
            } else {
              pathToPoint = [[
                "L",
                plotX,
                lastPoint.plotY
              ]];
            }
            pathToPoint.push([
              "L",
              plotX,
              plotY
            ]);
          } else {
            pathToPoint = [[
              "L",
              plotX,
              plotY
            ]];
          }
          xMap.push(point.x);
          if (step) {
            xMap.push(point.x);
            if (step === 2) {
              xMap.push(point.x);
            }
          }
          graphPath.push.apply(graphPath, pathToPoint);
          gap = false;
        }
      });
      graphPath.xMap = xMap;
      series.graphPath = graphPath;
      return graphPath;
    };
    LineSeries7.prototype.getZonesGraphs = function(props) {
      this.zones.forEach(function(zone, i) {
        var propset = [
          "zone-graph-" + i,
          "highcharts-graph highcharts-zone-graph-" + i + " " + (zone.className || "")
        ];
        if (!this.chart.styledMode) {
          propset.push(zone.color || this.color, zone.dashStyle || this.options.dashStyle);
        }
        props.push(propset);
      }, this);
      return props;
    };
    LineSeries7.defaultOptions = merge20(Series_default.defaultOptions, {
      // nothing here yet
    });
    return LineSeries7;
  }(Series_default)
);
SeriesRegistry_default.registerSeriesType("line", LineSeries);
var LineSeries_default = LineSeries;

// node_modules/highcharts/es-modules/Series/Area/AreaSeries.js
var __extends6 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color4 = Color_default.parse;
var LineSeries2 = SeriesRegistry_default.seriesTypes.line;
var extend16 = Utilities_default.extend;
var merge21 = Utilities_default.merge;
var objectEach19 = Utilities_default.objectEach;
var pick26 = Utilities_default.pick;
var AreaSeries = (
  /** @class */
  function(_super) {
    __extends6(AreaSeries3, _super);
    function AreaSeries3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    AreaSeries3.prototype.drawGraph = function() {
      this.areaPath = [];
      _super.prototype.drawGraph.apply(this);
      var series = this, areaPath = this.areaPath, options = this.options, zones = this.zones, props = [[
        "area",
        "highcharts-area",
        this.color,
        options.fillColor
      ]];
      zones.forEach(function(zone, i) {
        props.push([
          "zone-area-" + i,
          "highcharts-area highcharts-zone-area-" + i + " " + zone.className,
          zone.color || series.color,
          zone.fillColor || options.fillColor
        ]);
      });
      props.forEach(function(prop) {
        var areaKey = prop[0], area = series[areaKey], verb = area ? "animate" : "attr", attribs = {};
        if (area) {
          area.endX = series.preventGraphAnimation ? null : areaPath.xMap;
          area.animate({ d: areaPath });
        } else {
          attribs.zIndex = 0;
          area = series[areaKey] = series.chart.renderer.path(areaPath).addClass(prop[1]).add(series.group);
          area.isArea = true;
        }
        if (!series.chart.styledMode) {
          attribs.fill = pick26(prop[3], color4(prop[2]).setOpacity(pick26(options.fillOpacity, 0.75)).get());
        }
        area[verb](attribs);
        area.startX = areaPath.xMap;
        area.shiftUnit = options.step ? 2 : 1;
      });
    };
    AreaSeries3.prototype.getGraphPath = function(points) {
      var getGraphPath = LineSeries2.prototype.getGraphPath, graphPath, options = this.options, stacking = options.stacking, yAxis = this.yAxis, topPath, bottomPath, bottomPoints = [], graphPoints = [], seriesIndex = this.index, i, areaPath, plotX, stacks = yAxis.stacking.stacks[this.stackKey], threshold = options.threshold, translatedThreshold = Math.round(
        // #10909
        yAxis.getThreshold(options.threshold)
      ), isNull, yBottom, connectNulls = pick26(
        // #10574
        options.connectNulls,
        stacking === "percent"
      ), addDummyPoints = function(i2, otherI, side) {
        var point = points[i2], stackedValues = stacking && stacks[point.x].points[seriesIndex], nullVal = point[side + "Null"] || 0, cliffVal = point[side + "Cliff"] || 0, top, bottom, isNull2 = true;
        if (cliffVal || nullVal) {
          top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
          bottom = stackedValues[0] + cliffVal;
          isNull2 = !!nullVal;
        } else if (!stacking && points[otherI] && points[otherI].isNull) {
          top = bottom = threshold;
        }
        if (typeof top !== "undefined") {
          graphPoints.push({
            plotX,
            plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
            isNull: isNull2,
            isCliff: true
          });
          bottomPoints.push({
            plotX,
            plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),
            doCurve: false
            // #1041, gaps in areaspline areas
          });
        }
      };
      points = points || this.points;
      if (stacking) {
        points = this.getStackPoints(points);
      }
      for (i = 0; i < points.length; i++) {
        if (!stacking) {
          points[i].leftCliff = points[i].rightCliff = points[i].leftNull = points[i].rightNull = void 0;
        }
        isNull = points[i].isNull;
        plotX = pick26(points[i].rectPlotX, points[i].plotX);
        yBottom = stacking ? pick26(points[i].yBottom, translatedThreshold) : translatedThreshold;
        if (!isNull || connectNulls) {
          if (!connectNulls) {
            addDummyPoints(i, i - 1, "left");
          }
          if (!(isNull && !stacking && connectNulls)) {
            graphPoints.push(points[i]);
            bottomPoints.push({
              x: i,
              plotX,
              plotY: yBottom
            });
          }
          if (!connectNulls) {
            addDummyPoints(i, i + 1, "right");
          }
        }
      }
      topPath = getGraphPath.call(this, graphPoints, true, true);
      bottomPoints.reversed = true;
      bottomPath = getGraphPath.call(this, bottomPoints, true, true);
      var firstBottomPoint = bottomPath[0];
      if (firstBottomPoint && firstBottomPoint[0] === "M") {
        bottomPath[0] = ["L", firstBottomPoint[1], firstBottomPoint[2]];
      }
      areaPath = topPath.concat(bottomPath);
      if (areaPath.length) {
        areaPath.push(["Z"]);
      }
      graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);
      areaPath.xMap = topPath.xMap;
      this.areaPath = areaPath;
      return graphPath;
    };
    AreaSeries3.prototype.getStackPoints = function(points) {
      var series = this, segment = [], keys2 = [], xAxis = this.xAxis, yAxis = this.yAxis, stack = yAxis.stacking.stacks[this.stackKey], pointMap = {}, yAxisSeries = yAxis.series, seriesLength = yAxisSeries.length, upOrDown = yAxis.options.reversedStacks ? 1 : -1, seriesIndex = yAxisSeries.indexOf(series);
      points = points || this.points;
      if (this.options.stacking) {
        for (var i = 0; i < points.length; i++) {
          points[i].leftNull = points[i].rightNull = void 0;
          pointMap[points[i].x] = points[i];
        }
        objectEach19(stack, function(stackX, x) {
          if (stackX.total !== null) {
            keys2.push(x);
          }
        });
        keys2.sort(function(a, b) {
          return a - b;
        });
        var visibleSeries_1 = yAxisSeries.map(function(s) {
          return s.visible;
        });
        keys2.forEach(function(x, idx) {
          var y = 0, stackPoint, stackedValues;
          if (pointMap[x] && !pointMap[x].isNull) {
            segment.push(pointMap[x]);
            [-1, 1].forEach(function(direction) {
              var nullName = direction === 1 ? "rightNull" : "leftNull", cliffName = direction === 1 ? "rightCliff" : "leftCliff", cliff = 0, otherStack = stack[keys2[idx + direction]];
              if (otherStack) {
                var i3 = seriesIndex;
                while (i3 >= 0 && i3 < seriesLength) {
                  var si2 = yAxisSeries[i3].index;
                  stackPoint = otherStack.points[si2];
                  if (!stackPoint) {
                    if (si2 === series.index) {
                      pointMap[x][nullName] = true;
                    } else if (visibleSeries_1[i3]) {
                      stackedValues = stack[x].points[si2];
                      if (stackedValues) {
                        cliff -= stackedValues[1] - stackedValues[0];
                      }
                    }
                  }
                  i3 += upOrDown;
                }
              }
              pointMap[x][cliffName] = cliff;
            });
          } else {
            var i2 = seriesIndex;
            while (i2 >= 0 && i2 < seriesLength) {
              var si = yAxisSeries[i2].index;
              stackPoint = stack[x].points[si];
              if (stackPoint) {
                y = stackPoint[1];
                break;
              }
              i2 += upOrDown;
            }
            y = pick26(y, 0);
            y = yAxis.translate(
              // #6272
              y,
              0,
              1,
              0,
              1
            );
            segment.push({
              isNull: true,
              plotX: xAxis.translate(
                // #6272
                x,
                0,
                0,
                0,
                1
              ),
              x,
              plotY: y,
              yBottom: y
            });
          }
        });
      }
      return segment;
    };
    AreaSeries3.defaultOptions = merge21(LineSeries2.defaultOptions, {
      /**
       * @see [fillColor](#plotOptions.area.fillColor)
       * @see [fillOpacity](#plotOptions.area.fillOpacity)
       *
       * @apioption plotOptions.area.color
       */
      /**
       * Fill color or gradient for the area. When `null`, the series' `color`
       * is used with the series' `fillOpacity`.
       *
       * In styled mode, the fill color can be set with the `.highcharts-area`
       * class name.
       *
       * @see [color](#plotOptions.area.color)
       * @see [fillOpacity](#plotOptions.area.fillOpacity)
       *
       * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/
       *         Null by default
       * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/
       *         Gradient
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product   highcharts highstock
       * @apioption plotOptions.area.fillColor
       */
      /**
       * Fill opacity for the area. When you set an explicit `fillColor`,
       * the `fillOpacity` is not applied. Instead, you should define the
       * opacity in the `fillColor` with an rgba color definition. The
       * `fillOpacity` setting, also the default setting, overrides the alpha
       * component of the `color` setting.
       *
       * In styled mode, the fill opacity can be set with the
       * `.highcharts-area` class name.
       *
       * @see [color](#plotOptions.area.color)
       * @see [fillColor](#plotOptions.area.fillColor)
       *
       * @sample {highcharts} highcharts/plotoptions/area-fillopacity/
       *         Automatic fill color and fill opacity of 0.1
       *
       * @type      {number}
       * @default   {highcharts} 0.75
       * @default   {highstock} 0.75
       * @product   highcharts highstock
       * @apioption plotOptions.area.fillOpacity
       */
      /**
       * A separate color for the graph line. By default the line takes the
       * `color` of the series, but the lineColor setting allows setting a
       * separate color for the line without altering the `fillColor`.
       *
       * In styled mode, the line stroke can be set with the
       * `.highcharts-graph` class name.
       *
       * @sample {highcharts} highcharts/plotoptions/area-linecolor/
       *         Dark gray line
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product   highcharts highstock
       * @apioption plotOptions.area.lineColor
       */
      /**
       * A separate color for the negative part of the area.
       *
       * In styled mode, a negative color is set with the
       * `.highcharts-negative` class name.
       *
       * @see [negativeColor](#plotOptions.area.negativeColor)
       *
       * @sample {highcharts} highcharts/css/series-negative-color/
       *         Negative color in styled mode
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.area.negativeFillColor
       */
      /**
       * Whether the whole area or just the line should respond to mouseover
       * tooltips and other mouse or touch events.
       *
       * @sample {highcharts|highstock} highcharts/plotoptions/area-trackbyarea/
       *         Display the tooltip when the area is hovered
       *
       * @type      {boolean}
       * @default   false
       * @since     1.1.6
       * @product   highcharts highstock
       * @apioption plotOptions.area.trackByArea
       */
      /**
       * The Y axis value to serve as the base for the area, for
       * distinguishing between values above and below a threshold. The area
       * between the graph and the threshold is filled.
       *
       * * If a number is given, the Y axis will scale to the threshold.
       * * If `null`, the scaling behaves like a line series with fill between
       *   the graph and the Y axis minimum.
       * * If `Infinity` or `-Infinity`, the area between the graph and the
       *   corresponding Y axis extreme is filled (since v6.1.0).
       *
       * @sample {highcharts} highcharts/plotoptions/area-threshold/
       *         A threshold of 100
       * @sample {highcharts} highcharts/plotoptions/area-threshold-infinity/
       *         A threshold of Infinity
       *
       * @type    {number|null}
       * @since   2.0
       * @product highcharts highstock
       */
      threshold: 0
    });
    return AreaSeries3;
  }(LineSeries2)
);
extend16(AreaSeries.prototype, {
  singleStacks: false,
  drawLegendSymbol: LegendSymbol_default.drawRectangle
});
SeriesRegistry_default.registerSeriesType("area", AreaSeries);
var AreaSeries_default = AreaSeries;

// node_modules/highcharts/es-modules/Series/Spline/SplineSeries.js
var __extends7 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LineSeries3 = SeriesRegistry_default.seriesTypes.line;
var merge22 = Utilities_default.merge;
var pick27 = Utilities_default.pick;
var SplineSeries = (
  /** @class */
  function(_super) {
    __extends7(SplineSeries3, _super);
    function SplineSeries3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    SplineSeries3.prototype.getPointSpline = function(points, point, i) {
      var smoothing = 1.5, denom = smoothing + 1, plotX = point.plotX || 0, plotY = point.plotY || 0, lastPoint = points[i - 1], nextPoint = points[i + 1], leftContX, leftContY, rightContX, rightContY, ret;
      function doCurve(otherPoint) {
        return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false && // #6387, area splines next to null:
        !point.isCliff;
      }
      if (doCurve(lastPoint) && doCurve(nextPoint)) {
        var lastX = lastPoint.plotX || 0, lastY = lastPoint.plotY || 0, nextX = nextPoint.plotX || 0, nextY = nextPoint.plotY || 0, correction = 0;
        leftContX = (smoothing * plotX + lastX) / denom;
        leftContY = (smoothing * plotY + lastY) / denom;
        rightContX = (smoothing * plotX + nextX) / denom;
        rightContY = (smoothing * plotY + nextY) / denom;
        if (rightContX !== leftContX) {
          correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;
        }
        leftContY += correction;
        rightContY += correction;
        if (leftContY > lastY && leftContY > plotY) {
          leftContY = Math.max(lastY, plotY);
          rightContY = 2 * plotY - leftContY;
        } else if (leftContY < lastY && leftContY < plotY) {
          leftContY = Math.min(lastY, plotY);
          rightContY = 2 * plotY - leftContY;
        }
        if (rightContY > nextY && rightContY > plotY) {
          rightContY = Math.max(nextY, plotY);
          leftContY = 2 * plotY - rightContY;
        } else if (rightContY < nextY && rightContY < plotY) {
          rightContY = Math.min(nextY, plotY);
          leftContY = 2 * plotY - rightContY;
        }
        point.rightContX = rightContX;
        point.rightContY = rightContY;
      }
      ret = [
        "C",
        pick27(lastPoint.rightContX, lastPoint.plotX, 0),
        pick27(lastPoint.rightContY, lastPoint.plotY, 0),
        pick27(leftContX, plotX, 0),
        pick27(leftContY, plotY, 0),
        plotX,
        plotY
      ];
      lastPoint.rightContX = lastPoint.rightContY = void 0;
      return ret;
    };
    SplineSeries3.defaultOptions = merge22(LineSeries3.defaultOptions);
    return SplineSeries3;
  }(LineSeries3)
);
SeriesRegistry_default.registerSeriesType("spline", SplineSeries);
var SplineSeries_default = SplineSeries;

// node_modules/highcharts/es-modules/Series/AreaSpline/AreaSplineSeries.js
var __extends8 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var areaProto = AreaSeries_default.prototype;
var extend17 = Utilities_default.extend;
var merge23 = Utilities_default.merge;
var AreaSplineSeries = (
  /** @class */
  function(_super) {
    __extends8(AreaSplineSeries2, _super);
    function AreaSplineSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.points = void 0;
      _this.options = void 0;
      return _this;
    }
    AreaSplineSeries2.defaultOptions = merge23(SplineSeries_default.defaultOptions, AreaSeries_default.defaultOptions);
    return AreaSplineSeries2;
  }(SplineSeries_default)
);
extend17(AreaSplineSeries.prototype, {
  getGraphPath: areaProto.getGraphPath,
  getStackPoints: areaProto.getStackPoints,
  drawGraph: areaProto.drawGraph,
  drawLegendSymbol: LegendSymbol_default.drawRectangle
});
SeriesRegistry_default.registerSeriesType("areaspline", AreaSplineSeries);

// node_modules/highcharts/es-modules/Series/Column/ColumnSeries.js
var __extends9 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var animObject8 = AnimationUtilities_default.animObject;
var color5 = Color_default.parse;
var hasTouch2 = Globals_default.hasTouch;
var noop5 = Globals_default.noop;
var clamp7 = Utilities_default.clamp;
var css11 = Utilities_default.css;
var defined20 = Utilities_default.defined;
var extend18 = Utilities_default.extend;
var fireEvent13 = Utilities_default.fireEvent;
var isArray11 = Utilities_default.isArray;
var isNumber21 = Utilities_default.isNumber;
var merge24 = Utilities_default.merge;
var pick28 = Utilities_default.pick;
var objectEach20 = Utilities_default.objectEach;
var ColumnSeries = (
  /** @class */
  function(_super) {
    __extends9(ColumnSeries19, _super);
    function ColumnSeries19() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.borderWidth = void 0;
      _this.data = void 0;
      _this.group = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    ColumnSeries19.prototype.animate = function(init) {
      var series = this, yAxis = this.yAxis, options = series.options, inverted = this.chart.inverted, attr11 = {}, translateProp = inverted ? "translateX" : "translateY";
      var translateStart, translatedThreshold;
      if (init) {
        attr11.scaleY = 1e-3;
        translatedThreshold = clamp7(yAxis.toPixels(options.threshold), yAxis.pos, yAxis.pos + yAxis.len);
        if (inverted) {
          attr11.translateX = translatedThreshold - yAxis.len;
        } else {
          attr11.translateY = translatedThreshold;
        }
        if (series.clipBox) {
          series.setClip();
        }
        series.group.attr(attr11);
      } else {
        translateStart = Number(series.group.attr(translateProp));
        series.group.animate({ scaleY: 1 }, extend18(animObject8(series.options.animation), {
          // Do the scale synchronously to ensure smooth
          // updating (#5030, #7228)
          step: function(val, fx) {
            if (series.group) {
              attr11[translateProp] = translateStart + fx.pos * (yAxis.pos - translateStart);
              series.group.attr(attr11);
            }
          }
        }));
      }
    };
    ColumnSeries19.prototype.init = function(chart, options) {
      _super.prototype.init.apply(this, arguments);
      var series = this;
      chart = series.chart;
      if (chart.hasRendered) {
        chart.series.forEach(function(otherSeries) {
          if (otherSeries.type === series.type) {
            otherSeries.isDirty = true;
          }
        });
      }
    };
    ColumnSeries19.prototype.getColumnMetrics = function() {
      var series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedStacks = xAxis.options.reversedStacks, reverseStacks = xAxis.reversed && !reversedStacks || !xAxis.reversed && reversedStacks, stackGroups = {};
      var stackKey, columnCount = 0;
      if (options.grouping === false) {
        columnCount = 1;
      } else {
        series.chart.series.forEach(function(otherSeries) {
          var otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;
          var columnIndex;
          if (otherSeries.type === series.type && (otherSeries.visible || !series.chart.options.chart.ignoreHiddenSeries) && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
            if (otherOptions.stacking && otherOptions.stacking !== "group") {
              stackKey = otherSeries.stackKey;
              if (typeof stackGroups[stackKey] === "undefined") {
                stackGroups[stackKey] = columnCount++;
              }
              columnIndex = stackGroups[stackKey];
            } else if (otherOptions.grouping !== false) {
              columnIndex = columnCount++;
            }
            otherSeries.columnIndex = columnIndex;
          }
        });
      }
      var categoryWidth = Math.min(
        Math.abs(xAxis.transA) * (xAxis.ordinal && xAxis.ordinal.slope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1),
        // #2610
        xAxis.len
        // #1535
      ), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick28(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1);
      series.columnMetrics = {
        width: pointWidth,
        offset: pointXOffset,
        paddedWidth: pointOffsetWidth,
        columnCount
      };
      return series.columnMetrics;
    };
    ColumnSeries19.prototype.crispCol = function(x, y, w2, h) {
      var chart = this.chart, borderWidth = this.borderWidth, xCrisp = -(borderWidth % 2 ? 0.5 : 0);
      var right, yCrisp = borderWidth % 2 ? 0.5 : 1;
      if (chart.inverted && chart.renderer.isVML) {
        yCrisp += 1;
      }
      if (this.options.crisp) {
        right = Math.round(x + w2) + xCrisp;
        x = Math.round(x) + xCrisp;
        w2 = right - x;
      }
      var bottom = Math.round(y + h) + yCrisp, fromTop = Math.abs(y) <= 0.5 && bottom > 0.5;
      y = Math.round(y) + yCrisp;
      h = bottom - y;
      if (fromTop && h) {
        y -= 1;
        h += 1;
      }
      return {
        x,
        y,
        width: w2,
        height: h
      };
    };
    ColumnSeries19.prototype.adjustForMissingColumns = function(x, pointWidth, point, metrics) {
      var _this = this;
      var stacking = this.options.stacking;
      if (!point.isNull && metrics.columnCount > 1) {
        var indexInCategory_1 = 0;
        var totalInCategory_1 = 0;
        objectEach20(this.yAxis.stacking && this.yAxis.stacking.stacks, function(stack) {
          if (typeof point.x === "number") {
            var stackItem = stack[point.x.toString()];
            if (stackItem) {
              var pointValues = stackItem.points[_this.index], total = stackItem.total;
              if (stacking) {
                if (pointValues) {
                  indexInCategory_1 = totalInCategory_1;
                }
                if (stackItem.hasValidPoints) {
                  totalInCategory_1++;
                }
              } else if (isArray11(pointValues)) {
                indexInCategory_1 = pointValues[1];
                totalInCategory_1 = total || 0;
              }
            }
          }
        });
        var boxWidth = (totalInCategory_1 - 1) * metrics.paddedWidth + pointWidth;
        x = (point.plotX || 0) + boxWidth / 2 - pointWidth - indexInCategory_1 * metrics.paddedWidth;
      }
      return x;
    };
    ColumnSeries19.prototype.translate = function() {
      var series = this, chart = series.chart, options = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick28(
        options.borderWidth,
        dense ? 0 : 1
        // #3635
      ), xAxis = series.xAxis, yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick28(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax;
      var seriesBarW = series.barW = Math.max(seriesPointWidth, 1 + 2 * borderWidth);
      if (chart.inverted) {
        translatedThreshold -= 0.5;
      }
      if (options.pointPadding) {
        seriesBarW = Math.ceil(seriesBarW);
      }
      Series_default.prototype.translate.apply(series);
      series.points.forEach(function(point) {
        var yBottom = pick28(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, plotY = clamp7(point.plotY, -safeDistance, yAxis.len + safeDistance);
        var up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;
        if (minPointLength && Math.abs(barH) < minPointLength) {
          barH = minPointLength;
          up = !yAxis.reversed && !point.negative || yAxis.reversed && point.negative;
          if (isNumber21(threshold) && isNumber21(dataMax) && point.y === threshold && dataMax <= threshold && // and if there's room for it (#7311)
          (yAxis.min || 0) < threshold && // if all points are the same value (i.e zero) not draw
          // as negative points (#10646), but only if there's room
          // for it (#14876)
          (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {
            up = !up;
          }
          barY = Math.abs(barY - translatedThreshold) > minPointLength ? (
            // ...keep position
            yBottom - minPointLength
          ) : (
            // #1485, #4051
            translatedThreshold - (up ? minPointLength : 0)
          );
        }
        if (defined20(point.options.pointWidth)) {
          pointWidth = barW = Math.ceil(point.options.pointWidth);
          barX -= Math.round((pointWidth - seriesPointWidth) / 2);
        }
        if (options.centerInCategory) {
          barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);
        }
        point.barX = barX;
        point.pointWidth = pointWidth;
        point.tooltipPos = chart.inverted ? [
          clamp7(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft),
          xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2,
          barH
        ] : [
          xAxis.left - chart.plotLeft + barX + barW / 2,
          clamp7(plotY + yAxis.pos - chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop),
          barH
        ];
        point.shapeType = series.pointClass.prototype.shapeType || "rect";
        point.shapeArgs = series.crispCol.apply(series, point.isNull ? (
          // #3169, drilldown from null must have a position to work
          // from #6585, dataLabel should be placed on xAxis, not
          // floating in the middle of the chart
          [barX, translatedThreshold, barW, 0]
        ) : [barX, barY, barW, barH]);
      });
    };
    ColumnSeries19.prototype.drawGraph = function() {
      this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
    };
    ColumnSeries19.prototype.pointAttribs = function(point, state) {
      var options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || "borderColor", strokeWidthOption = p2o["stroke-width"] || "borderWidth";
      var stateOptions, zone, brightness, fill = point && point.color || this.color, stroke = point && point[strokeOption] || options[strokeOption] || fill, dashstyle = point && point.options.dashStyle || options.dashStyle, strokeWidth = point && point[strokeWidthOption] || options[strokeWidthOption] || this[strokeWidthOption] || 0, opacity = pick28(point && point.opacity, options.opacity, 1);
      if (point && this.zones.length) {
        zone = point.getZone();
        fill = point.options.color || zone && (zone.color || point.nonZonedColor) || this.color;
        if (zone) {
          stroke = zone.borderColor || stroke;
          dashstyle = zone.dashStyle || dashstyle;
          strokeWidth = zone.borderWidth || strokeWidth;
        }
      }
      if (state && point) {
        stateOptions = merge24(
          options.states[state],
          // #6401
          point.options.states && point.options.states[state] || {}
        );
        brightness = stateOptions.brightness;
        fill = stateOptions.color || typeof brightness !== "undefined" && color5(fill).brighten(stateOptions.brightness).get() || fill;
        stroke = stateOptions[strokeOption] || stroke;
        strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
        dashstyle = stateOptions.dashStyle || dashstyle;
        opacity = pick28(stateOptions.opacity, opacity);
      }
      var ret = {
        fill,
        stroke,
        "stroke-width": strokeWidth,
        opacity
      };
      if (dashstyle) {
        ret.dashstyle = dashstyle;
      }
      return ret;
    };
    ColumnSeries19.prototype.drawPoints = function() {
      var series = this, chart = this.chart, options = series.options, renderer = chart.renderer, animationLimit = options.animationLimit || 250;
      var shapeArgs;
      series.points.forEach(function(point) {
        var plotY = point.plotY;
        var graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ? "animate" : "attr";
        if (isNumber21(plotY) && point.y !== null) {
          shapeArgs = point.shapeArgs;
          if (graphic && point.hasNewShapeType()) {
            graphic = graphic.destroy();
          }
          if (series.enabledDataSorting) {
            point.startXPos = series.xAxis.reversed ? -(shapeArgs ? shapeArgs.width || 0 : 0) : series.xAxis.width;
          }
          if (!graphic) {
            point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);
            if (graphic && series.enabledDataSorting && chart.hasRendered && chart.pointCount < animationLimit) {
              graphic.attr({
                x: point.startXPos
              });
              hasGraphic = true;
              verb = "animate";
            }
          }
          if (graphic && hasGraphic) {
            graphic[verb](merge24(shapeArgs));
          }
          if (options.borderRadius) {
            graphic[verb]({
              r: options.borderRadius
            });
          }
          if (!chart.styledMode) {
            graphic[verb](series.pointAttribs(point, point.selected && "select")).shadow(point.allowShadow !== false && options.shadow, null, options.stacking && !options.borderRadius);
          }
          if (graphic) {
            graphic.addClass(point.getClassName(), true);
            graphic.attr({
              visibility: point.visible ? "inherit" : "hidden"
            });
          }
        } else if (graphic) {
          point.graphic = graphic.destroy();
        }
      });
    };
    ColumnSeries19.prototype.drawTracker = function() {
      var series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function(e2) {
        var point = pointer.getPointFromEvent(e2);
        if (typeof point !== "undefined") {
          pointer.isDirectTouch = true;
          point.onMouseOver(e2);
        }
      };
      var dataLabels;
      series.points.forEach(function(point) {
        dataLabels = isArray11(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
        if (point.graphic) {
          point.graphic.element.point = point;
        }
        dataLabels.forEach(function(dataLabel) {
          if (dataLabel.div) {
            dataLabel.div.point = point;
          } else {
            dataLabel.element.point = point;
          }
        });
      });
      if (!series._hasTracking) {
        series.trackerGroups.forEach(function(key) {
          if (series[key]) {
            series[key].addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e2) {
              pointer.onTrackerMouseOut(e2);
            });
            if (hasTouch2) {
              series[key].on("touchstart", onMouseOver);
            }
            if (!chart.styledMode && series.options.cursor) {
              series[key].css(css11).css({ cursor: series.options.cursor });
            }
          }
        });
        series._hasTracking = true;
      }
      fireEvent13(this, "afterDrawTracker");
    };
    ColumnSeries19.prototype.remove = function() {
      var series = this, chart = series.chart;
      if (chart.hasRendered) {
        chart.series.forEach(function(otherSeries) {
          if (otherSeries.type === series.type) {
            otherSeries.isDirty = true;
          }
        });
      }
      Series_default.prototype.remove.apply(series, arguments);
    };
    ColumnSeries19.defaultOptions = merge24(Series_default.defaultOptions, {
      /**
       * The corner radius of the border surrounding each column or bar.
       *
       * @sample {highcharts} highcharts/plotoptions/column-borderradius/
       *         Rounded columns
       *
       * @product highcharts highstock gantt
       *
       * @private
       */
      borderRadius: 0,
      /**
       * When using automatic point colors pulled from the global
       * [colors](colors) or series-specific
       * [plotOptions.column.colors](series.colors) collections, this option
       * determines whether the chart should receive one color per series or
       * one color per point.
       *
       * In styled mode, the `colors` or `series.colors` arrays are not
       * supported, and instead this option gives the points individual color
       * class names on the form `highcharts-color-{n}`.
       *
       * @see [series colors](#plotOptions.column.colors)
       *
       * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/
       *         False by default
       * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/
       *         True
       *
       * @type      {boolean}
       * @default   false
       * @since     2.0
       * @product   highcharts highstock gantt
       * @apioption plotOptions.column.colorByPoint
       */
      /**
       * A series specific or series type specific color set to apply instead
       * of the global [colors](#colors) when [colorByPoint](
       * #plotOptions.column.colorByPoint) is true.
       *
       * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
       * @since     3.0
       * @product   highcharts highstock gantt
       * @apioption plotOptions.column.colors
       */
      /**
       * When `true`, the columns will center in the category, ignoring null
       * or missing points. When `false`, space will be reserved for null or
       * missing points.
       *
       * @sample {highcharts} highcharts/series-column/centerincategory/
       *         Center in category
       *
       * @since   8.0.1
       * @product highcharts highstock gantt
       *
       * @private
       */
      centerInCategory: false,
      /**
       * Padding between each value groups, in x axis units.
       *
       * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/
       *         0.2 by default
       * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/
       *         No group padding - all columns are evenly spaced
       *
       * @product highcharts highstock gantt
       *
       * @private
       */
      groupPadding: 0.2,
      /**
       * Whether to group non-stacked columns or to let them render
       * independent of each other. Non-grouped columns will be laid out
       * individually and overlap each other.
       *
       * @sample {highcharts} highcharts/plotoptions/column-grouping-false/
       *         Grouping disabled
       * @sample {highstock} highcharts/plotoptions/column-grouping-false/
       *         Grouping disabled
       *
       * @type      {boolean}
       * @default   true
       * @since     2.3.0
       * @product   highcharts highstock gantt
       * @apioption plotOptions.column.grouping
       */
      /**
       * @ignore-option
       * @private
       */
      marker: null,
      /**
       * The maximum allowed pixel width for a column, translated to the
       * height of a bar in a bar chart. This prevents the columns from
       * becoming too wide when there is a small number of points in the
       * chart.
       *
       * @see [pointWidth](#plotOptions.column.pointWidth)
       *
       * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/
       *         Limited to 50
       * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/
       *         Limited to 50
       *
       * @type      {number}
       * @since     4.1.8
       * @product   highcharts highstock gantt
       * @apioption plotOptions.column.maxPointWidth
       */
      /**
       * Padding between each column or bar, in x axis units.
       *
       * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/
       *         0.1 by default
       * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/
       *          0.25
       * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/
       *         0 for tightly packed columns
       *
       * @product highcharts highstock gantt
       *
       * @private
       */
      pointPadding: 0.1,
      /**
       * A pixel value specifying a fixed width for each column or bar point.
       * When set to `undefined`, the width is calculated from the
       * `pointPadding` and `groupPadding`. The width effects the dimension
       * that is not based on the point value. For column series it is the
       * hoizontal length and for bar series it is the vertical length.
       *
       * @see [maxPointWidth](#plotOptions.column.maxPointWidth)
       *
       * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/
       *         20px wide columns regardless of chart width or the amount of
       *         data points
       *
       * @type      {number}
       * @since     1.2.5
       * @product   highcharts highstock gantt
       * @apioption plotOptions.column.pointWidth
       */
      /**
       * A pixel value specifying a fixed width for the column or bar.
       * Overrides pointWidth on the series.
       *
       * @see [series.pointWidth](#plotOptions.column.pointWidth)
       *
       * @type      {number}
       * @default   undefined
       * @since     7.0.0
       * @product   highcharts highstock gantt
       * @apioption series.column.data.pointWidth
       */
      /**
       * The minimal height for a column or width for a bar. By default,
       * 0 values are not shown. To visualize a 0 (or close to zero) point,
       * set the minimal point length to a pixel value like 3\. In stacked
       * column charts, minPointLength might not be respected for tightly
       * packed values.
       *
       * @sample {highcharts} highcharts/plotoptions/column-minpointlength/
       *         Zero base value
       * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/
       *         Positive and negative close to zero values
       *
       * @product highcharts highstock gantt
       *
       * @private
       */
      minPointLength: 0,
      /**
       * When the series contains less points than the crop threshold, all
       * points are drawn, event if the points fall outside the visible plot
       * area at the current zoom. The advantage of drawing all points
       * (including markers and columns), is that animation is performed on
       * updates. On the other hand, when the series contains more points than
       * the crop threshold, the series data is cropped to only contain points
       * that fall within the plot area. The advantage of cropping away
       * invisible points is to increase performance on large series.
       *
       * @product highcharts highstock gantt
       *
       * @private
       */
      cropThreshold: 50,
      /**
       * The X axis range that each point is valid for. This determines the
       * width of the column. On a categorized axis, the range will be 1
       * by default (one category unit). On linear and datetime axes, the
       * range will be computed as the distance between the two closest data
       * points.
       *
       * The default `null` means it is computed automatically, but this
       * option can be used to override the automatic value.
       *
       * This option is set by default to 1 if data sorting is enabled.
       *
       * @sample {highcharts} highcharts/plotoptions/column-pointrange/
       *         Set the point range to one day on a data set with one week
       *         between the points
       *
       * @type    {number|null}
       * @since   2.3
       * @product highcharts highstock gantt
       *
       * @private
       */
      pointRange: null,
      states: {
        /**
         * Options for the hovered point. These settings override the normal
         * state options when a point is moused over or touched.
         *
         * @extends   plotOptions.series.states.hover
         * @excluding halo, lineWidth, lineWidthPlus, marker
         * @product   highcharts highstock gantt
         */
        hover: {
          /** @ignore-option */
          halo: false,
          /**
           * A specific border color for the hovered point. Defaults to
           * inherit the normal state border color.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product   highcharts gantt
           * @apioption plotOptions.column.states.hover.borderColor
           */
          /**
           * A specific color for the hovered point.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product   highcharts gantt
           * @apioption plotOptions.column.states.hover.color
           */
          /**
           * How much to brighten the point on interaction. Requires the
           * main color to be defined in hex or rgb(a) format.
           *
           * In styled mode, the hover brightening is by default replaced
           * with a fill-opacity set in the `.highcharts-point:hover`
           * rule.
           *
           * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/
           *         Brighten by 0.5
           *
           * @product highcharts highstock gantt
           */
          brightness: 0.1
        },
        /**
         * Options for the selected point. These settings override the
         * normal state options when a point is selected.
         *
         * @extends   plotOptions.series.states.select
         * @excluding halo, lineWidth, lineWidthPlus, marker
         * @product   highcharts highstock gantt
         */
        select: {
          /**
           * A specific color for the selected point.
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default #cccccc
           * @product highcharts highstock gantt
           */
          color: Palette_default.neutralColor20,
          /**
           * A specific border color for the selected point.
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default #000000
           * @product highcharts highstock gantt
           */
          borderColor: Palette_default.neutralColor100
        }
      },
      dataLabels: {
        align: void 0,
        verticalAlign: void 0,
        /**
         * The y position offset of the label relative to the point in
         * pixels.
         *
         * @type {number}
         */
        y: void 0
      },
      // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/
      /**
       * @ignore-option
       * @private
       */
      startFromThreshold: true,
      stickyTracking: false,
      tooltip: {
        distance: 6
      },
      /**
       * The Y axis value to serve as the base for the columns, for
       * distinguishing between values above and below a threshold. If `null`,
       * the columns extend from the padding Y axis minimum.
       *
       * @type    {number|null}
       * @since   2.0
       * @product highcharts
       *
       * @private
       */
      threshold: 0,
      /**
       * The width of the border surrounding each column or bar. Defaults to
       * `1` when there is room for a border, but to `0` when the columns are
       * so dense that a border would cover the next column.
       *
       * In styled mode, the stroke width can be set with the
       * `.highcharts-point` rule.
       *
       * @sample {highcharts} highcharts/plotoptions/column-borderwidth/
       *         2px black border
       *
       * @type      {number}
       * @default   undefined
       * @product   highcharts highstock gantt
       * @apioption plotOptions.column.borderWidth
       */
      /**
       * The color of the border surrounding each column or bar.
       *
       * In styled mode, the border stroke can be set with the
       * `.highcharts-point` rule.
       *
       * @sample {highcharts} highcharts/plotoptions/column-bordercolor/
       *         Dark gray border
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   #ffffff
       * @product   highcharts highstock gantt
       *
       * @private
       */
      borderColor: Palette_default.backgroundColor
    });
    return ColumnSeries19;
  }(Series_default)
);
extend18(ColumnSeries.prototype, {
  cropShoulder: 0,
  // When tooltip is not shared, this series (and derivatives) requires
  // direct touch/hover. KD-tree does not apply.
  directTouch: true,
  /**
   * Use a solid rectangle like the area series types
   *
   * @private
   * @function Highcharts.seriesTypes.column#drawLegendSymbol
   *
   * @param {Highcharts.Legend} legend
   *        The legend object
   *
   * @param {Highcharts.Series|Highcharts.Point} item
   *        The series (this) or point
   */
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  getSymbol: noop5,
  // use separate negative stacks, unlike area stacks where a negative
  // point is substracted from previous (#1910)
  negStacks: true,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("column", ColumnSeries);
var ColumnSeries_default = ColumnSeries;

// node_modules/highcharts/es-modules/Core/Series/DataLabel.js
var getDeferredAnimation3 = AnimationUtilities_default.getDeferredAnimation;
var format6 = FormatUtilities_default.format;
var defined21 = Utilities_default.defined;
var extend19 = Utilities_default.extend;
var fireEvent14 = Utilities_default.fireEvent;
var isArray12 = Utilities_default.isArray;
var merge25 = Utilities_default.merge;
var objectEach21 = Utilities_default.objectEach;
var pick29 = Utilities_default.pick;
var splat9 = Utilities_default.splat;
var DataLabel;
(function(DataLabel2) {
  var composedClasses2 = [];
  function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
    var series = this, chart = this.chart, inverted = this.isCartesian && chart.inverted, enabledDataSorting = this.enabledDataSorting, plotX = pick29(point.dlBox && point.dlBox.centerX, point.plotX, -9999), plotY = pick29(point.plotY, -9999), bBox = dataLabel.getBBox(), rotation = options.rotation, align = options.align, isInsidePlot = chart.isInsidePlot(plotX, Math.round(plotY), {
      inverted,
      paneCoordinates: true,
      series
    }), setStartPos = function(alignOptions) {
      if (enabledDataSorting && series.xAxis && !justify) {
        series.setDataLabelStartPos(point, dataLabel, isNew, isInsidePlot, alignOptions);
      }
    };
    var baseline, normRotation, negRotation, rotCorr, alignAttr, justify = pick29(options.overflow, enabledDataSorting ? "none" : "justify") === "justify", visible = this.visible && point.visible !== false && (point.series.forceDL || enabledDataSorting && !justify || isInsidePlot || // If the data label is inside the align box, it is
    // enough that parts of the align box is inside the
    // plot area (#12370). When stacking, it is always
    // inside regardless of the option (#15148).
    pick29(options.inside, !!this.options.stacking) && alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, {
      inverted,
      paneCoordinates: true,
      series
    }));
    if (visible) {
      baseline = chart.renderer.fontMetrics(chart.styledMode ? void 0 : options.style.fontSize, dataLabel).b;
      alignTo = extend19({
        x: inverted ? this.yAxis.len - plotY : plotX,
        y: Math.round(inverted ? this.xAxis.len - plotX : plotY),
        width: 0,
        height: 0
      }, alignTo);
      extend19(options, {
        width: bBox.width,
        height: bBox.height
      });
      if (rotation) {
        justify = false;
        rotCorr = chart.renderer.rotCorr(baseline, rotation);
        alignAttr = {
          x: alignTo.x + (options.x || 0) + alignTo.width / 2 + rotCorr.x,
          y: alignTo.y + (options.y || 0) + { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] * alignTo.height
        };
        setStartPos(alignAttr);
        dataLabel[isNew ? "attr" : "animate"](alignAttr).attr({
          align
        });
        normRotation = (rotation + 720) % 360;
        negRotation = normRotation > 180 && normRotation < 360;
        if (align === "left") {
          alignAttr.y -= negRotation ? bBox.height : 0;
        } else if (align === "center") {
          alignAttr.x -= bBox.width / 2;
          alignAttr.y -= bBox.height / 2;
        } else if (align === "right") {
          alignAttr.x -= bBox.width;
          alignAttr.y -= negRotation ? 0 : bBox.height;
        }
        dataLabel.placed = true;
        dataLabel.alignAttr = alignAttr;
      } else {
        setStartPos(alignTo);
        dataLabel.align(options, void 0, alignTo);
        alignAttr = dataLabel.alignAttr;
      }
      if (justify && alignTo.height >= 0) {
        this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);
      } else if (pick29(options.crop, true)) {
        visible = chart.isInsidePlot(alignAttr.x, alignAttr.y, {
          paneCoordinates: true,
          series
        }) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height, {
          paneCoordinates: true,
          series
        });
      }
      if (options.shape && !rotation) {
        dataLabel[isNew ? "attr" : "animate"]({
          anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,
          anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY
        });
      }
    }
    if (isNew && enabledDataSorting) {
      dataLabel.placed = false;
    }
    if (!visible && (!enabledDataSorting || justify)) {
      dataLabel.hide(true);
      dataLabel.placed = false;
    }
  }
  function applyFilter(point, options) {
    var filter = options.filter;
    if (filter) {
      var op = filter.operator;
      var prop = point[filter.property];
      var val = filter.value;
      if (op === ">" && prop > val || op === "<" && prop < val || op === ">=" && prop >= val || op === "<=" && prop <= val || op === "==" && prop == val || // eslint-disable-line eqeqeq
      op === "===" && prop === val) {
        return true;
      }
      return false;
    }
    return true;
  }
  function compose(SeriesClass) {
    if (composedClasses2.indexOf(SeriesClass) === -1) {
      var seriesProto5 = SeriesClass.prototype;
      composedClasses2.push(SeriesClass);
      seriesProto5.alignDataLabel = alignDataLabel;
      seriesProto5.drawDataLabels = drawDataLabels;
      seriesProto5.justifyDataLabel = justifyDataLabel;
      seriesProto5.setDataLabelStartPos = setDataLabelStartPos;
    }
  }
  DataLabel2.compose = compose;
  function drawDataLabels() {
    var series = this, chart = series.chart, seriesOptions = series.options, points = series.points, hasRendered = series.hasRendered || 0, renderer = chart.renderer;
    var seriesDlOptions = seriesOptions.dataLabels, pointOptions, dataLabelsGroup;
    var dataLabelAnim = seriesDlOptions.animation, animationConfig = seriesDlOptions.defer ? getDeferredAnimation3(chart, dataLabelAnim, series) : { defer: 0, duration: 0 };
    seriesDlOptions = mergeArrays(mergeArrays(chart.options.plotOptions && chart.options.plotOptions.series && chart.options.plotOptions.series.dataLabels, chart.options.plotOptions && chart.options.plotOptions[series.type] && chart.options.plotOptions[series.type].dataLabels), seriesDlOptions);
    fireEvent14(this, "drawDataLabels");
    if (isArray12(seriesDlOptions) || seriesDlOptions.enabled || series._hasPointLabels) {
      dataLabelsGroup = series.plotGroup(
        "dataLabelsGroup",
        "data-labels",
        !hasRendered ? "hidden" : "inherit",
        // #5133, #10220
        seriesDlOptions.zIndex || 6
      );
      dataLabelsGroup.attr({ opacity: +hasRendered });
      if (!hasRendered) {
        var group = series.dataLabelsGroup;
        if (group) {
          if (series.visible) {
            dataLabelsGroup.show(true);
          }
          group[seriesOptions.animation ? "animate" : "attr"]({ opacity: 1 }, animationConfig);
        }
      }
      points.forEach(function(point) {
        pointOptions = splat9(mergeArrays(seriesDlOptions, point.dlOptions || // dlOptions is used in treemaps
        point.options && point.options.dataLabels));
        pointOptions.forEach(function(labelOptions, i) {
          var labelEnabled = labelOptions.enabled && // #2282, #4641, #7112, #10049
          (!point.isNull || point.dataLabelOnNull) && applyFilter(point, labelOptions), connector = point.connectors ? point.connectors[i] : point.connector;
          var labelConfig, formatString, labelText, style, rotation, attr11, dataLabel = point.dataLabels ? point.dataLabels[i] : point.dataLabel;
          var labelDistance = pick29(labelOptions.distance, point.labelDistance), isNew = !dataLabel;
          if (labelEnabled) {
            labelConfig = point.getLabelConfig();
            formatString = pick29(labelOptions[point.formatPrefix + "Format"], labelOptions.format);
            labelText = defined21(formatString) ? format6(formatString, labelConfig, chart) : (labelOptions[point.formatPrefix + "Formatter"] || labelOptions.formatter).call(labelConfig, labelOptions);
            style = labelOptions.style;
            rotation = labelOptions.rotation;
            if (!chart.styledMode) {
              style.color = pick29(labelOptions.color, style.color, series.color, Palette_default.neutralColor100);
              if (style.color === "contrast") {
                point.contrastColor = renderer.getContrast(point.color || series.color);
                style.color = !defined21(labelDistance) && labelOptions.inside || labelDistance < 0 || !!seriesOptions.stacking ? point.contrastColor : Palette_default.neutralColor100;
              } else {
                delete point.contrastColor;
              }
              if (seriesOptions.cursor) {
                style.cursor = seriesOptions.cursor;
              }
            }
            attr11 = {
              r: labelOptions.borderRadius || 0,
              rotation,
              padding: labelOptions.padding,
              zIndex: 1
            };
            if (!chart.styledMode) {
              attr11.fill = labelOptions.backgroundColor;
              attr11.stroke = labelOptions.borderColor;
              attr11["stroke-width"] = labelOptions.borderWidth;
            }
            objectEach21(attr11, function(val, name) {
              if (typeof val === "undefined") {
                delete attr11[name];
              }
            });
          }
          if (dataLabel && (!labelEnabled || !defined21(labelText))) {
            point.dataLabel = point.dataLabel && point.dataLabel.destroy();
            if (point.dataLabels) {
              if (point.dataLabels.length === 1) {
                delete point.dataLabels;
              } else {
                delete point.dataLabels[i];
              }
            }
            if (!i) {
              delete point.dataLabel;
            }
            if (connector) {
              point.connector = point.connector.destroy();
              if (point.connectors) {
                if (point.connectors.length === 1) {
                  delete point.connectors;
                } else {
                  delete point.connectors[i];
                }
              }
            }
          } else if (labelEnabled && defined21(labelText)) {
            if (!dataLabel) {
              point.dataLabels = point.dataLabels || [];
              dataLabel = point.dataLabels[i] = rotation ? (
                // Labels don't rotate, use text element
                renderer.text(labelText, 0, -9999, labelOptions.useHTML).addClass("highcharts-data-label")
              ) : (
                // We can use label
                renderer.label(labelText, 0, -9999, labelOptions.shape, null, null, labelOptions.useHTML, null, "data-label")
              );
              if (!i) {
                point.dataLabel = dataLabel;
              }
              dataLabel.addClass(" highcharts-data-label-color-" + point.colorIndex + " " + (labelOptions.className || "") + // #3398
              (labelOptions.useHTML ? " highcharts-tracker" : ""));
            } else {
              attr11.text = labelText;
            }
            dataLabel.options = labelOptions;
            dataLabel.attr(attr11);
            if (!chart.styledMode) {
              dataLabel.css(style).shadow(labelOptions.shadow);
            }
            if (!dataLabel.added) {
              dataLabel.add(dataLabelsGroup);
            }
            if (labelOptions.textPath && !labelOptions.useHTML) {
              dataLabel.setTextPath(point.getDataLabelPath && point.getDataLabelPath(dataLabel) || point.graphic, labelOptions.textPath);
              if (point.dataLabelPath && !labelOptions.textPath.enabled) {
                point.dataLabelPath = point.dataLabelPath.destroy();
              }
            }
            series.alignDataLabel(point, dataLabel, labelOptions, null, isNew);
          }
        });
      });
    }
    fireEvent14(this, "afterDrawDataLabels");
  }
  function justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew) {
    var chart = this.chart, align = options.align, verticalAlign = options.verticalAlign, padding = dataLabel.box ? 0 : dataLabel.padding || 0;
    var _a15 = options.x, x = _a15 === void 0 ? 0 : _a15, _b = options.y, y = _b === void 0 ? 0 : _b, off, justified;
    off = (alignAttr.x || 0) + padding;
    if (off < 0) {
      if (align === "right" && x >= 0) {
        options.align = "left";
        options.inside = true;
      } else {
        x -= off;
      }
      justified = true;
    }
    off = (alignAttr.x || 0) + bBox.width - padding;
    if (off > chart.plotWidth) {
      if (align === "left" && x <= 0) {
        options.align = "right";
        options.inside = true;
      } else {
        x += chart.plotWidth - off;
      }
      justified = true;
    }
    off = alignAttr.y + padding;
    if (off < 0) {
      if (verticalAlign === "bottom" && y >= 0) {
        options.verticalAlign = "top";
        options.inside = true;
      } else {
        y -= off;
      }
      justified = true;
    }
    off = (alignAttr.y || 0) + bBox.height - padding;
    if (off > chart.plotHeight) {
      if (verticalAlign === "top" && y <= 0) {
        options.verticalAlign = "bottom";
        options.inside = true;
      } else {
        y += chart.plotHeight - off;
      }
      justified = true;
    }
    if (justified) {
      options.x = x;
      options.y = y;
      dataLabel.placed = !isNew;
      dataLabel.align(options, void 0, alignTo);
    }
    return justified;
  }
  function mergeArrays(one, two) {
    var res = [], i;
    if (isArray12(one) && !isArray12(two)) {
      res = one.map(function(el) {
        return merge25(el, two);
      });
    } else if (isArray12(two) && !isArray12(one)) {
      res = two.map(function(el) {
        return merge25(one, el);
      });
    } else if (!isArray12(one) && !isArray12(two)) {
      res = merge25(one, two);
    } else {
      i = Math.max(one.length, two.length);
      while (i--) {
        res[i] = merge25(one[i], two[i]);
      }
    }
    return res;
  }
  function setDataLabelStartPos(point, dataLabel, isNew, isInside, alignOptions) {
    var chart = this.chart, inverted = chart.inverted, xAxis = this.xAxis, reversed = xAxis.reversed, labelCenter = inverted ? dataLabel.height / 2 : dataLabel.width / 2, pointWidth = point.pointWidth, halfWidth = pointWidth ? pointWidth / 2 : 0;
    dataLabel.startXPos = inverted ? alignOptions.x : reversed ? -labelCenter - halfWidth : xAxis.width - labelCenter + halfWidth;
    dataLabel.startYPos = inverted ? reversed ? this.yAxis.height - labelCenter + halfWidth : -labelCenter - halfWidth : alignOptions.y;
    if (!isInside) {
      dataLabel.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, dataLabel.hide);
    } else if (dataLabel.visibility === "hidden") {
      dataLabel.show();
      dataLabel.attr({ opacity: 0 }).animate({ opacity: 1 });
    }
    if (!chart.hasRendered) {
      return;
    }
    if (isNew) {
      dataLabel.attr({ x: dataLabel.startXPos, y: dataLabel.startYPos });
    }
    dataLabel.placed = true;
  }
})(DataLabel || (DataLabel = {}));
var DataLabel_default = DataLabel;

// node_modules/highcharts/es-modules/Series/Column/ColumnDataLabel.js
var Series2 = SeriesRegistry_default.series;
var merge26 = Utilities_default.merge;
var pick30 = Utilities_default.pick;
var ColumnDataLabel;
(function(ColumnDataLabel3) {
  var composedClasses2 = [];
  function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
    var inverted = this.chart.inverted, series = point.series, dlBox = point.dlBox || point.shapeArgs, below = pick30(
      point.below,
      // range series
      point.plotY > pick30(this.translatedThreshold, series.yAxis.len)
    ), inside = pick30(options.inside, !!this.options.stacking), overshoot;
    if (dlBox) {
      alignTo = merge26(dlBox);
      if (alignTo.y < 0) {
        alignTo.height += alignTo.y;
        alignTo.y = 0;
      }
      overshoot = alignTo.y + alignTo.height - series.yAxis.len;
      if (overshoot > 0 && overshoot < alignTo.height) {
        alignTo.height -= overshoot;
      }
      if (inverted) {
        alignTo = {
          x: series.yAxis.len - alignTo.y - alignTo.height,
          y: series.xAxis.len - alignTo.x - alignTo.width,
          width: alignTo.height,
          height: alignTo.width
        };
      }
      if (!inside) {
        if (inverted) {
          alignTo.x += below ? 0 : alignTo.width;
          alignTo.width = 0;
        } else {
          alignTo.y += below ? alignTo.height : 0;
          alignTo.height = 0;
        }
      }
    }
    options.align = pick30(options.align, !inverted || inside ? "center" : below ? "right" : "left");
    options.verticalAlign = pick30(options.verticalAlign, inverted || inside ? "middle" : below ? "top" : "bottom");
    Series2.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
    if (options.inside && point.contrastColor) {
      dataLabel.css({
        color: point.contrastColor
      });
    }
  }
  function compose(ColumnSeriesClass) {
    DataLabel_default.compose(Series2);
    if (composedClasses2.indexOf(ColumnSeriesClass) === -1) {
      composedClasses2.push(ColumnSeriesClass);
      ColumnSeriesClass.prototype.alignDataLabel = alignDataLabel;
    }
  }
  ColumnDataLabel3.compose = compose;
})(ColumnDataLabel || (ColumnDataLabel = {}));
var ColumnDataLabel_default = ColumnDataLabel;

// node_modules/highcharts/es-modules/Series/Bar/BarSeries.js
var __extends10 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var extend20 = Utilities_default.extend;
var merge27 = Utilities_default.merge;
var BarSeries = (
  /** @class */
  function(_super) {
    __extends10(BarSeries2, _super);
    function BarSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    BarSeries2.defaultOptions = merge27(ColumnSeries_default.defaultOptions, {
      // nothing here yet
    });
    return BarSeries2;
  }(ColumnSeries_default)
);
extend20(BarSeries.prototype, {
  inverted: true
});
SeriesRegistry_default.registerSeriesType("bar", BarSeries);

// node_modules/highcharts/es-modules/Series/Scatter/ScatterSeries.js
var __extends11 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var addEvent16 = Utilities_default.addEvent;
var extend21 = Utilities_default.extend;
var merge28 = Utilities_default.merge;
var ScatterSeries = (
  /** @class */
  function(_super) {
    __extends11(ScatterSeries6, _super);
    function ScatterSeries6() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    ScatterSeries6.prototype.applyJitter = function() {
      var series = this, jitter = this.options.jitter, len = this.points.length;
      function unrandom(seed) {
        var rand = Math.sin(seed) * 1e4;
        return rand - Math.floor(rand);
      }
      if (jitter) {
        this.points.forEach(function(point, i) {
          ["x", "y"].forEach(function(dim, j) {
            var axis, plotProp = "plot" + dim.toUpperCase(), min, max, translatedJitter;
            if (jitter[dim] && !point.isNull) {
              axis = series[dim + "Axis"];
              translatedJitter = jitter[dim] * axis.transA;
              if (axis && !axis.isLog) {
                min = Math.max(0, point[plotProp] - translatedJitter);
                max = Math.min(axis.len, point[plotProp] + translatedJitter);
                point[plotProp] = min + (max - min) * unrandom(i + j * len);
                if (dim === "x") {
                  point.clientX = point.plotX;
                }
              }
            }
          });
        });
      }
    };
    ScatterSeries6.prototype.drawGraph = function() {
      if (this.options.lineWidth) {
        _super.prototype.drawGraph.call(this);
      } else if (this.graph) {
        this.graph = this.graph.destroy();
      }
    };
    ScatterSeries6.defaultOptions = merge28(LineSeries_default.defaultOptions, {
      /**
       * The width of the line connecting the data points.
       *
       * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-none/
       *         0 by default
       * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-1/
       *         1px
       *
       * @product highcharts highstock
       */
      lineWidth: 0,
      findNearestPointBy: "xy",
      /**
       * Apply a jitter effect for the rendered markers. When plotting
       * discrete values, a little random noise may help telling the points
       * apart. The jitter setting applies a random displacement of up to `n`
       * axis units in either direction. So for example on a horizontal X
       * axis, setting the `jitter.x` to 0.24 will render the point in a
       * random position between 0.24 units to the left and 0.24 units to the
       * right of the true axis position. On a category axis, setting it to
       * 0.5 will fill up the bin and make the data appear continuous.
       *
       * When rendered on top of a box plot or a column series, a jitter value
       * of 0.24 will correspond to the underlying series' default
       * [groupPadding](
       * https://api.highcharts.com/highcharts/plotOptions.column.groupPadding)
       * and [pointPadding](
       * https://api.highcharts.com/highcharts/plotOptions.column.pointPadding)
       * settings.
       *
       * @sample {highcharts} highcharts/series-scatter/jitter
       *         Jitter on a scatter plot
       *
       * @sample {highcharts} highcharts/series-scatter/jitter-boxplot
       *         Jittered scatter plot on top of a box plot
       *
       * @product highcharts highstock
       * @since 7.0.2
       */
      jitter: {
        /**
         * The maximal X offset for the random jitter effect.
         */
        x: 0,
        /**
         * The maximal Y offset for the random jitter effect.
         */
        y: 0
      },
      marker: {
        enabled: true
        // Overrides auto-enabling in line series (#3647)
      },
      /**
       * Sticky tracking of mouse events. When true, the `mouseOut` event
       * on a series isn't triggered until the mouse moves over another
       * series, or out of the plot area. When false, the `mouseOut` event on
       * a series is triggered when the mouse leaves the area around the
       * series' graph or markers. This also implies the tooltip. When
       * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
       * will be hidden when moving the mouse between series.
       *
       * @type      {boolean}
       * @default   false
       * @product   highcharts highstock
       * @apioption plotOptions.scatter.stickyTracking
       */
      /**
       * A configuration object for the tooltip rendering of each single
       * series. Properties are inherited from [tooltip](#tooltip).
       * Overridable properties are `headerFormat`, `pointFormat`,
       * `yDecimals`, `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other
       * series, in a scatter plot the series.name by default shows in the
       * headerFormat and point.x and point.y in the pointFormat.
       *
       * @product highcharts highstock
       */
      tooltip: {
        headerFormat: '<span style="color:{point.color}"></span> <span style="font-size: 10px"> {series.name}</span><br/>',
        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
      }
    });
    return ScatterSeries6;
  }(LineSeries_default)
);
extend21(ScatterSeries.prototype, {
  drawTracker: ColumnSeries_default.prototype.drawTracker,
  sorted: false,
  requireSorting: false,
  noSharedTooltip: true,
  trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
  takeOrdinalPosition: false
  // #2342
});
addEvent16(ScatterSeries, "afterTranslate", function() {
  this.applyJitter();
});
SeriesRegistry_default.registerSeriesType("scatter", ScatterSeries);
var ScatterSeries_default = ScatterSeries;

// node_modules/highcharts/es-modules/Mixins/CenteredSeries.js
var isNumber22 = Utilities_default.isNumber;
var pick31 = Utilities_default.pick;
var relativeLength5 = Utilities_default.relativeLength;
var deg2rad5 = Globals_default.deg2rad;
var centeredSeriesMixin = Globals_default.CenteredSeriesMixin = {
  /**
   * Get the center of the pie based on the size and center options relative
   * to the plot area. Borrowed by the polar and gauge series types.
   *
   * @private
   * @function Highcharts.CenteredSeriesMixin.getCenter
   *
   * @return {Array<number>}
   */
  getCenter: function() {
    var options = this.options, chart = this.chart, slicingRoom = 2 * (options.slicedOffset || 0), handleSlicingRoom, plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options.center, smallestSize = Math.min(plotWidth, plotHeight), size = options.size, innerSize = options.innerSize || 0, positions, i, value;
    if (typeof size === "string") {
      size = parseFloat(size);
    }
    if (typeof innerSize === "string") {
      innerSize = parseFloat(innerSize);
    }
    positions = [
      pick31(centerOption[0], "50%"),
      pick31(centerOption[1], "50%"),
      // Prevent from negative values
      pick31(size && size < 0 ? void 0 : options.size, "100%"),
      pick31(innerSize && innerSize < 0 ? void 0 : options.innerSize || 0, "0%")
    ];
    if (chart.angular && !(this instanceof Series_default)) {
      positions[3] = 0;
    }
    for (i = 0; i < 4; ++i) {
      value = positions[i];
      handleSlicingRoom = i < 2 || i === 2 && /%$/.test(value);
      positions[i] = relativeLength5(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);
    }
    if (positions[3] > positions[2]) {
      positions[3] = positions[2];
    }
    return positions;
  },
  /**
   * getStartAndEndRadians - Calculates start and end angles in radians.
   * Used in series types such as pie and sunburst.
   *
   * @private
   * @function Highcharts.CenteredSeriesMixin.getStartAndEndRadians
   *
   * @param {number} [start]
   *        Start angle in degrees.
   *
   * @param {number} [end]
   *        Start angle in degrees.
   *
   * @return {Highcharts.RadianAngles}
   *         Returns an object containing start and end angles as radians.
   */
  getStartAndEndRadians: function(start, end) {
    var startAngle = isNumber22(start) ? start : 0, endAngle = isNumber22(end) && // must be a number
    end > startAngle && // must be larger than the start angle
    // difference must be less than 360 degrees
    end - startAngle < 360 ? end : startAngle + 360, correction = -90;
    return {
      start: deg2rad5 * (startAngle + correction),
      end: deg2rad5 * (endAngle + correction)
    };
  }
};
var CenteredSeries_default = centeredSeriesMixin;

// node_modules/highcharts/es-modules/Series/Pie/PiePoint.js
var __extends12 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var setAnimation5 = AnimationUtilities_default.setAnimation;
var addEvent17 = Utilities_default.addEvent;
var defined22 = Utilities_default.defined;
var extend22 = Utilities_default.extend;
var isNumber23 = Utilities_default.isNumber;
var pick32 = Utilities_default.pick;
var relativeLength6 = Utilities_default.relativeLength;
var PiePoint = (
  /** @class */
  function(_super) {
    __extends12(PiePoint5, _super);
    function PiePoint5() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.labelDistance = void 0;
      _this.options = void 0;
      _this.series = void 0;
      return _this;
    }
    PiePoint5.prototype.getConnectorPath = function() {
      var labelPosition = this.labelPosition, options = this.series.options.dataLabels, predefinedShapes = this.connectorShapes;
      var connectorShape = options.connectorShape;
      if (predefinedShapes[connectorShape]) {
        connectorShape = predefinedShapes[connectorShape];
      }
      return connectorShape.call(this, {
        // pass simplified label position object for user's convenience
        x: labelPosition.final.x,
        y: labelPosition.final.y,
        alignment: labelPosition.alignment
      }, labelPosition.connectorPosition, options);
    };
    PiePoint5.prototype.getTranslate = function() {
      return this.sliced ? this.slicedTranslation : {
        translateX: 0,
        translateY: 0
      };
    };
    PiePoint5.prototype.haloPath = function(size) {
      var shapeArgs = this.shapeArgs;
      return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(shapeArgs.x, shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
        // Substract 1px to ensure the background is not bleeding
        // through between the halo and the slice (#7495).
        innerR: shapeArgs.r - 1,
        start: shapeArgs.start,
        end: shapeArgs.end
      });
    };
    PiePoint5.prototype.init = function() {
      var _this = this;
      _super.prototype.init.apply(this, arguments);
      this.name = pick32(this.name, "Slice");
      var toggleSlice = function(e2) {
        _this.slice(e2.type === "select");
      };
      addEvent17(this, "select", toggleSlice);
      addEvent17(this, "unselect", toggleSlice);
      return this;
    };
    PiePoint5.prototype.isValid = function() {
      return isNumber23(this.y) && this.y >= 0;
    };
    PiePoint5.prototype.setVisible = function(vis, redraw) {
      var _this = this;
      var series = this.series, chart = series.chart, ignoreHiddenPoint = series.options.ignoreHiddenPoint;
      redraw = pick32(redraw, ignoreHiddenPoint);
      if (vis !== this.visible) {
        this.visible = this.options.visible = vis = typeof vis === "undefined" ? !this.visible : vis;
        series.options.data[series.data.indexOf(this)] = this.options;
        ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function(key) {
          if (_this[key]) {
            _this[key][vis ? "show" : "hide"](vis);
          }
        });
        if (this.legendItem) {
          chart.legend.colorizeItem(this, vis);
        }
        if (!vis && this.state === "hover") {
          this.setState("");
        }
        if (ignoreHiddenPoint) {
          series.isDirty = true;
        }
        if (redraw) {
          chart.redraw();
        }
      }
    };
    PiePoint5.prototype.slice = function(sliced, redraw, animation) {
      var series = this.series, chart = series.chart;
      setAnimation5(animation, chart);
      redraw = pick32(redraw, true);
      this.sliced = this.options.sliced = sliced = defined22(sliced) ? sliced : !this.sliced;
      series.options.data[series.data.indexOf(this)] = this.options;
      if (this.graphic) {
        this.graphic.animate(this.getTranslate());
      }
      if (this.shadowGroup) {
        this.shadowGroup.animate(this.getTranslate());
      }
    };
    return PiePoint5;
  }(Point_default)
);
extend22(PiePoint.prototype, {
  connectorShapes: {
    // only one available before v7.0.0
    fixedOffset: function(labelPosition, connectorPosition, options) {
      var breakAt = connectorPosition.breakAt, touchingSliceAt = connectorPosition.touchingSliceAt, lineSegment = options.softConnector ? [
        "C",
        // 1st control point (of the curve)
        labelPosition.x + // 5 gives the connector a little horizontal bend
        (labelPosition.alignment === "left" ? -5 : 5),
        labelPosition.y,
        2 * breakAt.x - touchingSliceAt.x,
        2 * breakAt.y - touchingSliceAt.y,
        breakAt.x,
        breakAt.y
        //
      ] : [
        "L",
        breakAt.x,
        breakAt.y
      ];
      return [
        ["M", labelPosition.x, labelPosition.y],
        lineSegment,
        ["L", touchingSliceAt.x, touchingSliceAt.y]
      ];
    },
    straight: function(labelPosition, connectorPosition) {
      var touchingSliceAt = connectorPosition.touchingSliceAt;
      return [
        ["M", labelPosition.x, labelPosition.y],
        ["L", touchingSliceAt.x, touchingSliceAt.y]
      ];
    },
    crookedLine: function(labelPosition, connectorPosition, options) {
      var touchingSliceAt = connectorPosition.touchingSliceAt, series = this.series, pieCenterX = series.center[0], plotWidth = series.chart.plotWidth, plotLeft = series.chart.plotLeft, alignment = labelPosition.alignment, radius = this.shapeArgs.r, crookDistance = relativeLength6(
        // % to fraction
        options.crookDistance,
        1
      ), crookX = alignment === "left" ? pieCenterX + radius + (plotWidth + plotLeft - pieCenterX - radius) * (1 - crookDistance) : plotLeft + (pieCenterX - radius) * crookDistance, segmentWithCrook = [
        "L",
        crookX,
        labelPosition.y
      ];
      var useCrook = true;
      if (alignment === "left" ? crookX > labelPosition.x || crookX < touchingSliceAt.x : crookX < labelPosition.x || crookX > touchingSliceAt.x) {
        useCrook = false;
      }
      var path = [["M", labelPosition.x, labelPosition.y]];
      if (useCrook) {
        path.push(segmentWithCrook);
      }
      path.push(["L", touchingSliceAt.x, touchingSliceAt.y]);
      return path;
    }
  }
});
var PiePoint_default = PiePoint;

// node_modules/highcharts/es-modules/Series/Pie/PieSeries.js
var __extends13 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var getStartAndEndRadians = CenteredSeries_default.getStartAndEndRadians;
var noop6 = Globals_default.noop;
var clamp8 = Utilities_default.clamp;
var extend23 = Utilities_default.extend;
var fireEvent15 = Utilities_default.fireEvent;
var merge29 = Utilities_default.merge;
var pick33 = Utilities_default.pick;
var relativeLength7 = Utilities_default.relativeLength;
var PieSeries = (
  /** @class */
  function(_super) {
    __extends13(PieSeries5, _super);
    function PieSeries5() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.center = void 0;
      _this.data = void 0;
      _this.maxLabelDistance = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    PieSeries5.prototype.animate = function(init) {
      var series = this, points = series.points, startAngleRad = series.startAngleRad;
      if (!init) {
        points.forEach(function(point) {
          var graphic = point.graphic, args = point.shapeArgs;
          if (graphic && args) {
            graphic.attr({
              // animate from inner radius (#779)
              r: pick33(point.startR, series.center && series.center[3] / 2),
              start: startAngleRad,
              end: startAngleRad
            });
            graphic.animate({
              r: args.r,
              start: args.start,
              end: args.end
            }, series.options.animation);
          }
        });
      }
    };
    PieSeries5.prototype.drawEmpty = function() {
      var start = this.startAngleRad, end = this.endAngleRad, options = this.options;
      var centerX, centerY;
      if (this.total === 0 && this.center) {
        centerX = this.center[0];
        centerY = this.center[1];
        if (!this.graph) {
          this.graph = this.chart.renderer.arc(centerX, centerY, this.center[1] / 2, 0, start, end).addClass("highcharts-empty-series").add(this.group);
        }
        this.graph.attr({
          d: Symbols_default.arc(centerX, centerY, this.center[2] / 2, 0, {
            start,
            end,
            innerR: this.center[3] / 2
          })
        });
        if (!this.chart.styledMode) {
          this.graph.attr({
            "stroke-width": options.borderWidth,
            fill: options.fillColor || "none",
            stroke: options.color || Palette_default.neutralColor20
          });
        }
      } else if (this.graph) {
        this.graph = this.graph.destroy();
      }
    };
    PieSeries5.prototype.drawPoints = function() {
      var renderer = this.chart.renderer;
      this.points.forEach(function(point) {
        if (point.graphic && point.hasNewShapeType()) {
          point.graphic = point.graphic.destroy();
        }
        if (!point.graphic) {
          point.graphic = renderer[point.shapeType](point.shapeArgs).add(point.series.group);
          point.delayedRendering = true;
        }
      });
    };
    PieSeries5.prototype.generatePoints = function() {
      _super.prototype.generatePoints.call(this);
      this.updateTotals();
    };
    PieSeries5.prototype.getX = function(y, left, point) {
      var center = this.center, radius = this.radii ? this.radii[point.index] || 0 : center[2] / 2;
      var angle = Math.asin(clamp8((y - center[1]) / (radius + point.labelDistance), -1, 1));
      var x = center[0] + (left ? -1 : 1) * (Math.cos(angle) * (radius + point.labelDistance)) + (point.labelDistance > 0 ? (left ? -1 : 1) * this.options.dataLabels.padding : 0);
      return x;
    };
    PieSeries5.prototype.hasData = function() {
      return !!this.processedXData.length;
    };
    PieSeries5.prototype.redrawPoints = function() {
      var series = this, chart = series.chart, renderer = chart.renderer, shadow = series.options.shadow;
      var groupTranslation, graphic, pointAttr, shapeArgs;
      this.drawEmpty();
      if (shadow && !series.shadowGroup && !chart.styledMode) {
        series.shadowGroup = renderer.g("shadow").attr({ zIndex: -1 }).add(series.group);
      }
      series.points.forEach(function(point) {
        var animateTo = {};
        graphic = point.graphic;
        if (!point.isNull && graphic) {
          var shadowGroup = void 0;
          shapeArgs = point.shapeArgs;
          groupTranslation = point.getTranslate();
          if (!chart.styledMode) {
            shadowGroup = point.shadowGroup;
            if (shadow && !shadowGroup) {
              shadowGroup = point.shadowGroup = renderer.g("shadow").add(series.shadowGroup);
            }
            if (shadowGroup) {
              shadowGroup.attr(groupTranslation);
            }
            pointAttr = series.pointAttribs(point, point.selected && "select");
          }
          if (!point.delayedRendering) {
            graphic.setRadialReference(series.center);
            if (!chart.styledMode) {
              merge29(true, animateTo, pointAttr);
            }
            merge29(true, animateTo, shapeArgs, groupTranslation);
            graphic.animate(animateTo);
          } else {
            graphic.setRadialReference(series.center).attr(shapeArgs).attr(groupTranslation);
            if (!chart.styledMode) {
              graphic.attr(pointAttr).attr({ "stroke-linejoin": "round" }).shadow(shadow, shadowGroup);
            }
            point.delayedRendering = false;
          }
          graphic.attr({
            visibility: point.visible ? "inherit" : "hidden"
          });
          graphic.addClass(point.getClassName(), true);
        } else if (graphic) {
          point.graphic = graphic.destroy();
        }
      });
    };
    PieSeries5.prototype.sortByAngle = function(points, sign) {
      points.sort(function(a, b) {
        return typeof a.angle !== "undefined" && (b.angle - a.angle) * sign;
      });
    };
    PieSeries5.prototype.translate = function(positions) {
      this.generatePoints();
      var series = this, precision = 1e3, options = series.options, slicedOffset = options.slicedOffset, connectorOffset = slicedOffset + (options.borderWidth || 0), radians = getStartAndEndRadians(options.startAngle, options.endAngle), startAngleRad = series.startAngleRad = radians.start, endAngleRad = series.endAngleRad = radians.end, circ = endAngleRad - startAngleRad, points = series.points, labelDistance = options.dataLabels.distance, ignoreHiddenPoint = options.ignoreHiddenPoint, len = points.length;
      var finalConnectorOffset, start, end, angle, radiusX, radiusY, i, point, cumulative = 0;
      if (!positions) {
        series.center = positions = series.getCenter();
      }
      for (i = 0; i < len; i++) {
        point = points[i];
        start = startAngleRad + cumulative * circ;
        if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
          cumulative += point.percentage / 100;
        }
        end = startAngleRad + cumulative * circ;
        var shapeArgs = {
          x: positions[0],
          y: positions[1],
          r: positions[2] / 2,
          innerR: positions[3] / 2,
          start: Math.round(start * precision) / precision,
          end: Math.round(end * precision) / precision
        };
        point.shapeType = "arc";
        point.shapeArgs = shapeArgs;
        point.labelDistance = pick33(point.options.dataLabels && point.options.dataLabels.distance, labelDistance);
        point.labelDistance = relativeLength7(point.labelDistance, shapeArgs.r);
        series.maxLabelDistance = Math.max(series.maxLabelDistance || 0, point.labelDistance);
        angle = (end + start) / 2;
        if (angle > 1.5 * Math.PI) {
          angle -= 2 * Math.PI;
        } else if (angle < -Math.PI / 2) {
          angle += 2 * Math.PI;
        }
        point.slicedTranslation = {
          translateX: Math.round(Math.cos(angle) * slicedOffset),
          translateY: Math.round(Math.sin(angle) * slicedOffset)
        };
        radiusX = Math.cos(angle) * positions[2] / 2;
        radiusY = Math.sin(angle) * positions[2] / 2;
        point.tooltipPos = [
          positions[0] + radiusX * 0.7,
          positions[1] + radiusY * 0.7
        ];
        point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
        point.angle = angle;
        finalConnectorOffset = Math.min(connectorOffset, point.labelDistance / 5);
        point.labelPosition = {
          natural: {
            // initial position of the data label - it's utilized for
            // finding the final position for the label
            x: positions[0] + radiusX + Math.cos(angle) * point.labelDistance,
            y: positions[1] + radiusY + Math.sin(angle) * point.labelDistance
          },
          "final": {
            // used for generating connector path -
            // initialized later in drawDataLabels function
            // x: undefined,
            // y: undefined
          },
          // left - pie on the left side of the data label
          // right - pie on the right side of the data label
          // center - data label overlaps the pie
          alignment: point.labelDistance < 0 ? "center" : point.half ? "right" : "left",
          connectorPosition: {
            breakAt: {
              x: positions[0] + radiusX + Math.cos(angle) * finalConnectorOffset,
              y: positions[1] + radiusY + Math.sin(angle) * finalConnectorOffset
            },
            touchingSliceAt: {
              x: positions[0] + radiusX,
              y: positions[1] + radiusY
            }
          }
        };
      }
      fireEvent15(series, "afterTranslate");
    };
    PieSeries5.prototype.updateTotals = function() {
      var points = this.points, len = points.length, ignoreHiddenPoint = this.options.ignoreHiddenPoint;
      var i, point, total = 0;
      for (i = 0; i < len; i++) {
        point = points[i];
        if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
          total += point.y;
        }
      }
      this.total = total;
      for (i = 0; i < len; i++) {
        point = points[i];
        point.percentage = total > 0 && (point.visible || !ignoreHiddenPoint) ? point.y / total * 100 : 0;
        point.total = total;
      }
    };
    PieSeries5.defaultOptions = merge29(Series_default.defaultOptions, {
      /**
       * @excluding legendItemClick
       * @apioption plotOptions.pie.events
       */
      /**
       * Fires when the checkbox next to the point name in the legend is
       * clicked. One parameter, event, is passed to the function. The state
       * of the checkbox is found by event.checked. The checked item is found
       * by event.item. Return false to prevent the default action which is to
       * toggle the select state of the series.
       *
       * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
       *         Alert checkbox status
       *
       * @type      {Function}
       * @since     1.2.0
       * @product   highcharts
       * @context   Highcharts.Point
       * @apioption plotOptions.pie.events.checkboxClick
       */
      /**
       * Fires when the legend item belonging to the pie point (slice) is
       * clicked. The `this` keyword refers to the point itself. One
       * parameter, `event`, is passed to the function, containing common
       * event information. The default action is to toggle the visibility of
       * the point. This can be prevented by calling `event.preventDefault()`.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-point-events-legenditemclick/
       *         Confirm toggle visibility
       *
       * @type      {Highcharts.PointLegendItemClickCallbackFunction}
       * @since     1.2.0
       * @product   highcharts
       * @apioption plotOptions.pie.point.events.legendItemClick
       */
      /**
       * The center of the pie chart relative to the plot area. Can be
       * percentages or pixel values. The default behaviour (as of 3.0) is to
       * center the pie so that all slices and data labels are within the plot
       * area. As a consequence, the pie may actually jump around in a chart
       * with dynamic values, as the data labels move. In that case, the
       * center should be explicitly set, for example to `["50%", "50%"]`.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-center/
       *         Centered at 100, 100
       *
       * @type    {Array<(number|string|null),(number|string|null)>}
       * @default [null, null]
       * @product highcharts
       *
       * @private
       */
      center: [null, null],
      /**
       * The color of the pie series. A pie series is represented as an empty
       * circle if the total sum of its values is 0. Use this property to
       * define the color of its border.
       *
       * In styled mode, the color can be defined by the
       * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
       * color can be set with the `.highcharts-series`,
       * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
       * `.highcharts-series-{n}` class, or individual classes given by the
       * `className` option.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-emptyseries/
       *         Empty pie series
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   ${palette.neutralColor20}
       * @apioption plotOptions.pie.color
       */
      /**
       * @product highcharts
       *
       * @private
       */
      clip: false,
      /**
       * @ignore-option
       *
       * @private
       */
      colorByPoint: true,
      /**
       * A series specific or series type specific color set to use instead
       * of the global [colors](#colors).
       *
       * @sample {highcharts} highcharts/demo/pie-monochrome/
       *         Set default colors for all pies
       *
       * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.pie.colors
       */
      /**
       * @declare   Highcharts.SeriesPieDataLabelsOptionsObject
       * @extends   plotOptions.series.dataLabels
       * @excluding align, allowOverlap, inside, staggerLines, step
       * @private
       */
      dataLabels: {
        /**
         * Alignment method for data labels. Possible values are:
         *
         * - `toPlotEdges`: Each label touches the nearest vertical edge of
         *   the plot area.
         *
         * - `connectors`: Connectors have the same x position and the
         *   widest label of each half (left & right) touches the nearest
         *   vertical edge of the plot area.
         *
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-alignto-connectors/
         *         alignTo: connectors
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-alignto-plotedges/
         *         alignTo: plotEdges
         *
         * @type      {string}
         * @since     7.0.0
         * @product   highcharts
         * @apioption plotOptions.pie.dataLabels.alignTo
         */
        allowOverlap: true,
        /**
         * The color of the line connecting the data label to the pie slice.
         * The default color is the same as the point's color.
         *
         * In styled mode, the connector stroke is given in the
         * `.highcharts-data-label-connector` class.
         *
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorcolor/
         *         Blue connectors
         * @sample {highcharts} highcharts/css/pie-point/
         *         Styled connectors
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     2.1
         * @product   highcharts
         * @apioption plotOptions.pie.dataLabels.connectorColor
         */
        /**
         * The distance from the data label to the connector. Note that
         * data labels also have a default `padding`, so in order for the
         * connector to touch the text, the `padding` must also be 0.
         *
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorpadding/
         *         No padding
         *
         * @since   2.1
         * @product highcharts
         */
        connectorPadding: 5,
        /**
         * Specifies the method that is used to generate the connector path.
         * Highcharts provides 3 built-in connector shapes: `'fixedOffset'`
         * (default), `'straight'` and `'crookedLine'`. Using
         * `'crookedLine'` has the most sense (in most of the cases) when
         * `'alignTo'` is set.
         *
         * Users can provide their own method by passing a function instead
         * of a String. 3 arguments are passed to the callback:
         *
         * - Object that holds the information about the coordinates of the
         *   label (`x` & `y` properties) and how the label is located in
         *   relation to the pie (`alignment` property). `alignment` can by
         *   one of the following:
         *   `'left'` (pie on the left side of the data label),
         *   `'right'` (pie on the right side of the data label) or
         *   `'center'` (data label overlaps the pie).
         *
         * - Object that holds the information about the position of the
         *   connector. Its `touchingSliceAt`  porperty tells the position
         *   of the place where the connector touches the slice.
         *
         * - Data label options
         *
         * The function has to return an SVG path definition in array form
         * (see the example).
         *
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorshape-string/
         *         connectorShape is a String
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorshape-function/
         *         connectorShape is a function
         *
         * @type    {string|Function}
         * @since   7.0.0
         * @product highcharts
         */
        connectorShape: "fixedOffset",
        /**
         * The width of the line connecting the data label to the pie slice.
         *
         * In styled mode, the connector stroke width is given in the
         * `.highcharts-data-label-connector` class.
         *
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorwidth-disabled/
         *         Disable the connector
         * @sample {highcharts} highcharts/css/pie-point/
         *         Styled connectors
         *
         * @type      {number}
         * @default   1
         * @since     2.1
         * @product   highcharts
         * @apioption plotOptions.pie.dataLabels.connectorWidth
         */
        /**
         * Works only if `connectorShape` is `'crookedLine'`. It defines how
         * far from the vertical plot edge the coonnector path should be
         * crooked.
         *
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-crookdistance/
         *         crookDistance set to 90%
         *
         * @since   7.0.0
         * @product highcharts
         */
        crookDistance: "70%",
        /**
         * The distance of the data label from the pie's edge. Negative
         * numbers put the data label on top of the pie slices. Can also be
         * defined as a percentage of pie's radius. Connectors are only
         * shown for data labels outside the pie.
         *
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-distance/
         *         Data labels on top of the pie
         *
         * @type    {number|string}
         * @since   2.1
         * @product highcharts
         */
        distance: 30,
        enabled: true,
        /**
         * A
         * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
         * for the data label. Available variables are the same as for
         * `formatter`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
         *         Add a unit
         *
         * @type      {string}
         * @default   undefined
         * @since     3.0
         * @apioption plotOptions.pie.dataLabels.format
         */
        // eslint-disable-next-line valid-jsdoc
        /**
         * Callback JavaScript function to format the data label. Note that
         * if a `format` is defined, the format takes precedence and the
         * formatter is ignored.
         *
         * @type {Highcharts.DataLabelsFormatterCallbackFunction}
         * @default function () { return this.point.isNull ? void 0 : this.point.name; }
         */
        formatter: function() {
          return this.point.isNull ? void 0 : this.point.name;
        },
        /**
         * Whether to render the connector as a soft arc or a line with
         * sharp break. Works only if `connectorShape` equals to
         * `fixedOffset`.
         *
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-true/
         *         Soft
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-false/
         *         Non soft
         *
         * @since   2.1.7
         * @product highcharts
         */
        softConnector: true,
        /**
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow
         *         Long labels truncated with an ellipsis
         * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap
         *         Long labels are wrapped
         *
         * @type      {Highcharts.CSSObject}
         * @apioption plotOptions.pie.dataLabels.style
         */
        x: 0
      },
      /**
       * If the total sum of the pie's values is 0, the series is represented
       * as an empty circle . The `fillColor` option defines the color of that
       * circle. Use [pie.borderWidth](#plotOptions.pie.borderWidth) to set
       * the border thickness.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-emptyseries/
       *         Empty pie series
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @private
       */
      fillColor: void 0,
      /**
       * The end angle of the pie in degrees where 0 is top and 90 is right.
       * Defaults to `startAngle` plus 360.
       *
       * @sample {highcharts} highcharts/demo/pie-semi-circle/
       *         Semi-circle donut
       *
       * @type      {number}
       * @since     1.3.6
       * @product   highcharts
       * @apioption plotOptions.pie.endAngle
       */
      /**
       * Equivalent to [chart.ignoreHiddenSeries](#chart.ignoreHiddenSeries),
       * this option tells whether the series shall be redrawn as if the
       * hidden point were `null`.
       *
       * The default value changed from `false` to `true` with Highcharts
       * 3.0.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-ignorehiddenpoint/
       *         True, the hiddden point is ignored
       *
       * @since   2.3.0
       * @product highcharts
       *
       * @private
       */
      ignoreHiddenPoint: true,
      /**
       * @ignore-option
       *
       * @private
       */
      inactiveOtherPoints: true,
      /**
       * The size of the inner diameter for the pie. A size greater than 0
       * renders a donut chart. Can be a percentage or pixel value.
       * Percentages are relative to the pie size. Pixel values are given as
       * integers.
       *
       *
       * Note: in Highcharts < 4.1.2, the percentage was relative to the plot
       * area, not the pie size.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-innersize-80px/
       *         80px inner size
       * @sample {highcharts} highcharts/plotoptions/pie-innersize-50percent/
       *         50% of the plot area
       * @sample {highcharts} highcharts/demo/3d-pie-donut/
       *         3D donut
       *
       * @type      {number|string}
       * @default   0
       * @since     2.0
       * @product   highcharts
       * @apioption plotOptions.pie.innerSize
       */
      /**
       * @ignore-option
       *
       * @private
       */
      legendType: "point",
      /**
       * @ignore-option
       *
       * @private
       */
      marker: null,
      /**
       * The minimum size for a pie in response to auto margins. The pie will
       * try to shrink to make room for data labels in side the plot area,
       *  but only to this size.
       *
       * @type      {number|string}
       * @default   80
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.pie.minSize
       */
      /**
       * The diameter of the pie relative to the plot area. Can be a
       * percentage or pixel value. Pixel values are given as integers. The
       * default behaviour (as of 3.0) is to scale to the plot area and give
       * room for data labels within the plot area.
       * [slicedOffset](#plotOptions.pie.slicedOffset) is also included in the
       * default size calculation. As a consequence, the size of the pie may
       * vary when points are updated and data labels more around. In that
       * case it is best to set a fixed value, for example `"75%"`.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-size/
       *         Smaller pie
       *
       * @type    {number|string|null}
       * @product highcharts
       *
       * @private
       */
      size: null,
      /**
       * Whether to display this particular series or series type in the
       * legend. Since 2.1, pies are not shown in the legend by default.
       *
       * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
       *         One series in the legend, one hidden
       *
       * @product highcharts
       *
       * @private
       */
      showInLegend: false,
      /**
       * If a point is sliced, moved out from the center, how many pixels
       * should it be moved?.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-slicedoffset-20/
       *         20px offset
       *
       * @product highcharts
       *
       * @private
       */
      slicedOffset: 10,
      /**
       * The start angle of the pie slices in degrees where 0 is top and 90
       * right.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-startangle-90/
       *         Start from right
       *
       * @type      {number}
       * @default   0
       * @since     2.3.4
       * @product   highcharts
       * @apioption plotOptions.pie.startAngle
       */
      /**
       * Sticky tracking of mouse events. When true, the `mouseOut` event
       * on a series isn't triggered until the mouse moves over another
       * series, or out of the plot area. When false, the `mouseOut` event on
       * a series is triggered when the mouse leaves the area around the
       * series'  graph or markers. This also implies the tooltip. When
       * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
       * will be hidden when moving the mouse between series.
       *
       * @product highcharts
       *
       * @private
       */
      stickyTracking: false,
      tooltip: {
        followPointer: true
      },
      /**
       * The color of the border surrounding each slice. When `null`, the
       * border takes the same color as the slice fill. This can be used
       * together with a `borderWidth` to fill drawing gaps created by
       * antialiazing artefacts in borderless pies.
       *
       * In styled mode, the border stroke is given in the `.highcharts-point`
       * class.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-bordercolor-black/
       *         Black border
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default #ffffff
       * @product highcharts
       *
       * @private
       */
      borderColor: Palette_default.backgroundColor,
      /**
       * The width of the border surrounding each slice.
       *
       * When setting the border width to 0, there may be small gaps between
       * the slices due to SVG antialiasing artefacts. To work around this,
       * keep the border width at 0.5 or 1, but set the `borderColor` to
       * `null` instead.
       *
       * In styled mode, the border stroke width is given in the
       * `.highcharts-point` class.
       *
       * @sample {highcharts} highcharts/plotoptions/pie-borderwidth/
       *         3px border
       *
       * @product highcharts
       *
       * @private
       */
      borderWidth: 1,
      /**
       * @ignore-options
       * @private
       */
      lineWidth: void 0,
      states: {
        /**
         * @extends   plotOptions.series.states.hover
         * @excluding marker, lineWidth, lineWidthPlus
         * @product   highcharts
         */
        hover: {
          /**
           * How much to brighten the point on interaction. Requires the
           * main color to be defined in hex or rgb(a) format.
           *
           * In styled mode, the hover brightness is by default replaced
           * by a fill-opacity given in the `.highcharts-point-hover`
           * class.
           *
           * @sample {highcharts} highcharts/plotoptions/pie-states-hover-brightness/
           *         Brightened by 0.5
           *
           * @product highcharts
           */
          brightness: 0.1
        }
      }
    });
    return PieSeries5;
  }(Series_default)
);
extend23(PieSeries.prototype, {
  axisTypes: [],
  directTouch: true,
  drawGraph: void 0,
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  drawTracker: ColumnSeries_default.prototype.drawTracker,
  getCenter: CenteredSeries_default.getCenter,
  getSymbol: noop6,
  isCartesian: false,
  noSharedTooltip: true,
  pointAttribs: ColumnSeries_default.prototype.pointAttribs,
  pointClass: PiePoint_default,
  requireSorting: false,
  searchPoint: noop6,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("pie", PieSeries);
var PieSeries_default = PieSeries;

// node_modules/highcharts/es-modules/Series/Pie/PieDataLabel.js
var noop7 = Globals_default.noop;
var distribute3 = RendererUtilities_default.distribute;
var Series3 = SeriesRegistry_default.series;
var arrayMax5 = Utilities_default.arrayMax;
var clamp9 = Utilities_default.clamp;
var defined23 = Utilities_default.defined;
var merge30 = Utilities_default.merge;
var pick34 = Utilities_default.pick;
var relativeLength8 = Utilities_default.relativeLength;
var ColumnDataLabel2;
(function(ColumnDataLabel3) {
  var composedClasses2 = [];
  var dataLabelPositioners = {
    // Based on the value computed in Highcharts' distribute algorithm.
    radialDistributionY: function(point) {
      return point.top + point.distributeBox.pos;
    },
    // get the x - use the natural x position for labels near the
    // top and bottom, to prevent the top and botton slice
    // connectors from touching each other on either side
    // Based on the value computed in Highcharts' distribute algorithm.
    radialDistributionX: function(series, point, y, naturalY) {
      return series.getX(y < point.top + 2 || y > point.bottom - 2 ? naturalY : y, point.half, point);
    },
    // dataLabels.distance determines the x position of the label
    justify: function(point, radius, seriesCenter) {
      return seriesCenter[0] + (point.half ? -1 : 1) * (radius + point.labelDistance);
    },
    // Left edges of the left-half labels touch the left edge of the plot
    // area. Right edges of the right-half labels touch the right edge of
    // the plot area.
    alignToPlotEdges: function(dataLabel, half, plotWidth, plotLeft) {
      var dataLabelWidth = dataLabel.getBBox().width;
      return half ? dataLabelWidth + plotLeft : plotWidth - dataLabelWidth - plotLeft;
    },
    // Connectors of each side end in the same x position. Labels are
    // aligned to them. Left edge of the widest left-half label touches the
    // left edge of the plot area. Right edge of the widest right-half label
    // touches the right edge of the plot area.
    alignToConnectors: function(points, half, plotWidth, plotLeft) {
      var maxDataLabelWidth = 0, dataLabelWidth;
      points.forEach(function(point) {
        dataLabelWidth = point.dataLabel.getBBox().width;
        if (dataLabelWidth > maxDataLabelWidth) {
          maxDataLabelWidth = dataLabelWidth;
        }
      });
      return half ? maxDataLabelWidth + plotLeft : plotWidth - maxDataLabelWidth - plotLeft;
    }
  };
  function compose(PieSeriesClass) {
    DataLabel_default.compose(Series3);
    if (composedClasses2.indexOf(PieSeriesClass) === -1) {
      composedClasses2.push(PieSeriesClass);
      var pieProto2 = PieSeriesClass.prototype;
      pieProto2.dataLabelPositioners = dataLabelPositioners;
      pieProto2.alignDataLabel = noop7;
      pieProto2.drawDataLabels = drawDataLabels;
      pieProto2.placeDataLabels = placeDataLabels;
      pieProto2.verifyDataLabelOverflow = verifyDataLabelOverflow;
    }
  }
  ColumnDataLabel3.compose = compose;
  function drawDataLabels() {
    var series = this, data = series.data, chart = series.chart, options = series.options.dataLabels || {}, connectorPadding = options.connectorPadding, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotLeft = chart.plotLeft, maxWidth = Math.round(chart.chartWidth / 3), seriesCenter = series.center, radius = seriesCenter[2] / 2, centerY = seriesCenter[1], halves = [
      [],
      []
      // left
    ], overflow = [0, 0, 0, 0], dataLabelPositioners2 = series.dataLabelPositioners;
    var point, connectorWidth, connector, dataLabel, dataLabelWidth, labelPosition, labelHeight, x, y, visibility, j, pointDataLabelsOptions;
    if (!series.visible || !options.enabled && !series._hasPointLabels) {
      return;
    }
    data.forEach(function(point2) {
      if (point2.dataLabel && point2.visible && point2.dataLabel.shortened) {
        point2.dataLabel.attr({
          width: "auto"
        }).css({
          width: "auto",
          textOverflow: "clip"
        });
        point2.dataLabel.shortened = false;
      }
    });
    Series3.prototype.drawDataLabels.apply(series);
    data.forEach(function(point2) {
      if (point2.dataLabel) {
        if (point2.visible) {
          halves[point2.half].push(point2);
          point2.dataLabel._pos = null;
          if (!defined23(options.style.width) && !defined23(point2.options.dataLabels && point2.options.dataLabels.style && point2.options.dataLabels.style.width)) {
            if (point2.dataLabel.getBBox().width > maxWidth) {
              point2.dataLabel.css({
                // Use a fraction of the maxWidth to avoid
                // wrapping close to the end of the string.
                width: Math.round(maxWidth * 0.7) + "px"
              });
              point2.dataLabel.shortened = true;
            }
          }
        } else {
          point2.dataLabel = point2.dataLabel.destroy();
          if (point2.dataLabels && point2.dataLabels.length === 1) {
            delete point2.dataLabels;
          }
        }
      }
    });
    halves.forEach(function(points, i) {
      var length = points.length, positions = [];
      var top, bottom, naturalY, sideOverflow, size, distributionLength;
      if (!length) {
        return;
      }
      series.sortByAngle(points, i - 0.5);
      if (series.maxLabelDistance > 0) {
        top = Math.max(0, centerY - radius - series.maxLabelDistance);
        bottom = Math.min(centerY + radius + series.maxLabelDistance, chart.plotHeight);
        points.forEach(function(point2) {
          if (point2.labelDistance > 0 && point2.dataLabel) {
            point2.top = Math.max(0, centerY - radius - point2.labelDistance);
            point2.bottom = Math.min(centerY + radius + point2.labelDistance, chart.plotHeight);
            size = point2.dataLabel.getBBox().height || 21;
            point2.distributeBox = {
              target: point2.labelPosition.natural.y - point2.top + size / 2,
              size,
              rank: point2.y
            };
            positions.push(point2.distributeBox);
          }
        });
        distributionLength = bottom + size - top;
        distribute3(positions, distributionLength, distributionLength / 5);
      }
      for (j = 0; j < length; j++) {
        point = points[j];
        labelPosition = point.labelPosition;
        dataLabel = point.dataLabel;
        visibility = point.visible === false ? "hidden" : "inherit";
        naturalY = labelPosition.natural.y;
        y = naturalY;
        if (positions && defined23(point.distributeBox)) {
          if (typeof point.distributeBox.pos === "undefined") {
            visibility = "hidden";
          } else {
            labelHeight = point.distributeBox.size;
            y = dataLabelPositioners2.radialDistributionY(point);
          }
        }
        delete point.positionIndex;
        if (options.justify) {
          x = dataLabelPositioners2.justify(point, radius, seriesCenter);
        } else {
          switch (options.alignTo) {
            case "connectors":
              x = dataLabelPositioners2.alignToConnectors(points, i, plotWidth, plotLeft);
              break;
            case "plotEdges":
              x = dataLabelPositioners2.alignToPlotEdges(dataLabel, i, plotWidth, plotLeft);
              break;
            default:
              x = dataLabelPositioners2.radialDistributionX(series, point, y, naturalY);
          }
        }
        dataLabel._attr = {
          visibility,
          align: labelPosition.alignment
        };
        pointDataLabelsOptions = point.options.dataLabels || {};
        dataLabel._pos = {
          x: x + pick34(pointDataLabelsOptions.x, options.x) + // (#12985)
          ({
            left: connectorPadding,
            right: -connectorPadding
          }[labelPosition.alignment] || 0),
          // 10 is for the baseline (label vs text)
          y: y + pick34(pointDataLabelsOptions.y, options.y) - // (#12985)
          10
        };
        labelPosition.final.x = x;
        labelPosition.final.y = y;
        if (pick34(options.crop, true)) {
          dataLabelWidth = dataLabel.getBBox().width;
          sideOverflow = null;
          if (x - dataLabelWidth < connectorPadding && i === 1) {
            sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);
            overflow[3] = Math.max(sideOverflow, overflow[3]);
          } else if (x + dataLabelWidth > plotWidth - connectorPadding && i === 0) {
            sideOverflow = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);
            overflow[1] = Math.max(sideOverflow, overflow[1]);
          }
          if (y - labelHeight / 2 < 0) {
            overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);
          } else if (y + labelHeight / 2 > plotHeight) {
            overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);
          }
          dataLabel.sideOverflow = sideOverflow;
        }
      }
    });
    if (arrayMax5(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
      this.placeDataLabels();
      this.points.forEach(function(point2) {
        pointDataLabelsOptions = merge30(options, point2.options.dataLabels);
        connectorWidth = pick34(pointDataLabelsOptions.connectorWidth, 1);
        if (connectorWidth) {
          var isNew = void 0;
          connector = point2.connector;
          dataLabel = point2.dataLabel;
          if (dataLabel && dataLabel._pos && point2.visible && point2.labelDistance > 0) {
            visibility = dataLabel._attr.visibility;
            isNew = !connector;
            if (isNew) {
              point2.connector = connector = chart.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + point2.colorIndex + (point2.className ? " " + point2.className : "")).add(series.dataLabelsGroup);
              if (!chart.styledMode) {
                connector.attr({
                  "stroke-width": connectorWidth,
                  "stroke": pointDataLabelsOptions.connectorColor || point2.color || Palette_default.neutralColor60
                });
              }
            }
            connector[isNew ? "attr" : "animate"]({
              d: point2.getConnectorPath()
            });
            connector.attr("visibility", visibility);
          } else if (connector) {
            point2.connector = connector.destroy();
          }
        }
      });
    }
  }
  function placeDataLabels() {
    this.points.forEach(function(point) {
      var dataLabel = point.dataLabel, _pos;
      if (dataLabel && point.visible) {
        _pos = dataLabel._pos;
        if (_pos) {
          if (dataLabel.sideOverflow) {
            dataLabel._attr.width = Math.max(dataLabel.getBBox().width - dataLabel.sideOverflow, 0);
            dataLabel.css({
              width: dataLabel._attr.width + "px",
              textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
            });
            dataLabel.shortened = true;
          }
          dataLabel.attr(dataLabel._attr);
          dataLabel[dataLabel.moved ? "animate" : "attr"](_pos);
          dataLabel.moved = true;
        } else if (dataLabel) {
          dataLabel.attr({ y: -9999 });
        }
      }
      delete point.distributeBox;
    }, this);
  }
  function verifyDataLabelOverflow(overflow) {
    var center = this.center, options = this.options, centerOption = options.center, minSize = options.minSize || 80, newSize = minSize, ret = options.size !== null;
    if (!ret) {
      if (centerOption[0] !== null) {
        newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);
      } else {
        newSize = Math.max(
          // horizontal overflow
          center[2] - overflow[1] - overflow[3],
          minSize
        );
        center[0] += (overflow[3] - overflow[1]) / 2;
      }
      if (centerOption[1] !== null) {
        newSize = clamp9(newSize, minSize, center[2] - Math.max(overflow[0], overflow[2]));
      } else {
        newSize = clamp9(
          newSize,
          minSize,
          // vertical overflow
          center[2] - overflow[0] - overflow[2]
        );
        center[1] += (overflow[0] - overflow[2]) / 2;
      }
      if (newSize < center[2]) {
        center[2] = newSize;
        center[3] = Math.min(
          // #3632
          relativeLength8(options.innerSize || 0, newSize),
          newSize
        );
        this.translate(center);
        if (this.drawDataLabels) {
          this.drawDataLabels();
        }
      } else {
        ret = true;
      }
    }
    return ret;
  }
})(ColumnDataLabel2 || (ColumnDataLabel2 = {}));
var PieDataLabel_default = ColumnDataLabel2;

// node_modules/highcharts/es-modules/Extensions/OverlappingDataLabels.js
var addEvent18 = Utilities_default.addEvent;
var fireEvent16 = Utilities_default.fireEvent;
var isArray13 = Utilities_default.isArray;
var isNumber24 = Utilities_default.isNumber;
var objectEach22 = Utilities_default.objectEach;
var pick35 = Utilities_default.pick;
addEvent18(Chart_default, "render", function collectAndHide() {
  var chart = this, labels = [];
  (this.labelCollectors || []).forEach(function(collector) {
    labels = labels.concat(collector());
  });
  (this.yAxis || []).forEach(function(yAxis) {
    if (yAxis.stacking && yAxis.options.stackLabels && !yAxis.options.stackLabels.allowOverlap) {
      objectEach22(yAxis.stacking.stacks, function(stack) {
        objectEach22(stack, function(stackItem) {
          if (stackItem.label && stackItem.label.visibility !== "hidden") {
            labels.push(stackItem.label);
          }
        });
      });
    }
  });
  (this.series || []).forEach(function(series) {
    var dlOptions = series.options.dataLabels;
    if (series.visible && !(dlOptions.enabled === false && !series._hasPointLabels)) {
      var push = function(points) {
        return points.forEach(function(point) {
          if (point.visible) {
            var dataLabels = isArray13(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
            dataLabels.forEach(function(label) {
              var options = label.options;
              label.labelrank = pick35(options.labelrank, point.labelrank, point.shapeArgs && point.shapeArgs.height);
              if (!options.allowOverlap) {
                labels.push(label);
              } else {
                label.oldOpacity = label.opacity;
                label.newOpacity = 1;
                hideOrShow(label, chart);
              }
            });
          }
        });
      };
      push(series.nodes || []);
      push(series.points);
    }
  });
  this.hideOverlappingLabels(labels);
});
Chart_default.prototype.hideOverlappingLabels = function(labels) {
  var chart = this, len = labels.length, ren = chart.renderer, label, i, j, label1, label2, box1, box2, isLabelAffected = false, isIntersectRect = function(box12, box22) {
    return !(box22.x >= box12.x + box12.width || box22.x + box22.width <= box12.x || box22.y >= box12.y + box12.height || box22.y + box22.height <= box12.y);
  }, getAbsoluteBox = function(label3) {
    var pos, parent, bBox, padding = label3.box ? 0 : label3.padding || 0, lineHeightCorrection = 0, xOffset = 0, boxWidth, alignValue;
    if (label3 && (!label3.alignAttr || label3.placed)) {
      pos = label3.alignAttr || {
        x: label3.attr("x"),
        y: label3.attr("y")
      };
      parent = label3.parentGroup;
      if (!label3.width) {
        bBox = label3.getBBox();
        label3.width = bBox.width;
        label3.height = bBox.height;
        lineHeightCorrection = ren.fontMetrics(null, label3.element).h;
      }
      boxWidth = label3.width - 2 * padding;
      alignValue = {
        left: "0",
        center: "0.5",
        right: "1"
      }[label3.alignValue];
      if (alignValue) {
        xOffset = +alignValue * boxWidth;
      } else if (isNumber24(label3.x) && Math.round(label3.x) !== label3.translateX) {
        xOffset = label3.x - label3.translateX;
      }
      return {
        x: pos.x + (parent.translateX || 0) + padding - (xOffset || 0),
        y: pos.y + (parent.translateY || 0) + padding - lineHeightCorrection,
        width: label3.width - 2 * padding,
        height: label3.height - 2 * padding
      };
    }
  };
  for (i = 0; i < len; i++) {
    label = labels[i];
    if (label) {
      label.oldOpacity = label.opacity;
      label.newOpacity = 1;
      label.absoluteBox = getAbsoluteBox(label);
    }
  }
  labels.sort(function(a, b) {
    return (b.labelrank || 0) - (a.labelrank || 0);
  });
  for (i = 0; i < len; i++) {
    label1 = labels[i];
    box1 = label1 && label1.absoluteBox;
    for (j = i + 1; j < len; ++j) {
      label2 = labels[j];
      box2 = label2 && label2.absoluteBox;
      if (box1 && box2 && label1 !== label2 && // #6465, polar chart with connectEnds
      label1.newOpacity !== 0 && label2.newOpacity !== 0) {
        if (isIntersectRect(box1, box2)) {
          (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
        }
      }
    }
  }
  labels.forEach(function(label3) {
    if (hideOrShow(label3, chart)) {
      isLabelAffected = true;
    }
  });
  if (isLabelAffected) {
    fireEvent16(chart, "afterHideAllOverlappingLabels");
  }
};
function hideOrShow(label, chart) {
  var complete, newOpacity, isLabelAffected = false;
  if (label) {
    newOpacity = label.newOpacity;
    if (label.oldOpacity !== newOpacity) {
      if (label.alignAttr && label.placed) {
        label[newOpacity ? "removeClass" : "addClass"]("highcharts-data-label-hidden");
        complete = function() {
          if (!chart.styledMode) {
            label.css({ pointerEvents: newOpacity ? "auto" : "none" });
          }
        };
        isLabelAffected = true;
        label.alignAttr.opacity = newOpacity;
        label[label.isOld ? "animate" : "attr"](label.alignAttr, null, complete);
        fireEvent16(chart, "afterHideOverlappingLabel");
      } else {
        label.attr({
          opacity: newOpacity
        });
      }
    }
    label.isOld = true;
  }
  return isLabelAffected;
}

// node_modules/highcharts/es-modules/Core/Responsive.js
var extend24 = Utilities_default.extend;
var find6 = Utilities_default.find;
var isArray14 = Utilities_default.isArray;
var isObject8 = Utilities_default.isObject;
var merge31 = Utilities_default.merge;
var objectEach23 = Utilities_default.objectEach;
var pick36 = Utilities_default.pick;
var splat10 = Utilities_default.splat;
var uniqueKey6 = Utilities_default.uniqueKey;
var Responsive;
(function(Responsive2) {
  var composedClasses2 = [];
  function compose(ChartClass) {
    if (composedClasses2.indexOf(ChartClass) === -1) {
      composedClasses2.push(ChartClass);
      extend24(ChartClass.prototype, Additions.prototype);
    }
    return ChartClass;
  }
  Responsive2.compose = compose;
  var Additions = (
    /** @class */
    function() {
      function Additions2() {
      }
      Additions2.prototype.currentOptions = function(options) {
        var chart = this, ret = {};
        function getCurrent(options2, curr, ret2, depth) {
          var i;
          objectEach23(options2, function(val, key) {
            if (!depth && chart.collectionsWithUpdate.indexOf(key) > -1 && curr[key]) {
              val = splat10(val);
              ret2[key] = [];
              for (i = 0; i < Math.max(val.length, curr[key].length); i++) {
                if (curr[key][i]) {
                  if (val[i] === void 0) {
                    ret2[key][i] = curr[key][i];
                  } else {
                    ret2[key][i] = {};
                    getCurrent(val[i], curr[key][i], ret2[key][i], depth + 1);
                  }
                }
              }
            } else if (isObject8(val)) {
              ret2[key] = isArray14(val) ? [] : {};
              getCurrent(val, curr[key] || {}, ret2[key], depth + 1);
            } else if (typeof curr[key] === "undefined") {
              ret2[key] = null;
            } else {
              ret2[key] = curr[key];
            }
          });
        }
        getCurrent(options, this.options, ret, 0);
        return ret;
      };
      Additions2.prototype.matchResponsiveRule = function(rule, matches) {
        var condition = rule.condition, fn = condition.callback || function() {
          return this.chartWidth <= pick36(condition.maxWidth, Number.MAX_VALUE) && this.chartHeight <= pick36(condition.maxHeight, Number.MAX_VALUE) && this.chartWidth >= pick36(condition.minWidth, 0) && this.chartHeight >= pick36(condition.minHeight, 0);
        };
        if (fn.call(this)) {
          matches.push(rule._id);
        }
      };
      Additions2.prototype.setResponsive = function(redraw, reset) {
        var _this = this;
        var options = this.options.responsive, currentResponsive = this.currentResponsive;
        var ruleIds = [], undoOptions;
        if (!reset && options && options.rules) {
          options.rules.forEach(function(rule) {
            if (typeof rule._id === "undefined") {
              rule._id = uniqueKey6();
            }
            _this.matchResponsiveRule(
              rule,
              ruleIds
              /* , redraw */
            );
          }, this);
        }
        var mergedOptions = merge31.apply(void 0, ruleIds.map(function(ruleId) {
          return find6((options || {}).rules || [], function(rule) {
            return rule._id === ruleId;
          });
        }).map(function(rule) {
          return rule && rule.chartOptions;
        }));
        mergedOptions.isResponsiveOptions = true;
        ruleIds = ruleIds.toString() || void 0;
        var currentRuleIds = currentResponsive && currentResponsive.ruleIds;
        if (ruleIds !== currentRuleIds) {
          if (currentResponsive) {
            this.update(currentResponsive.undoOptions, redraw, true);
          }
          if (ruleIds) {
            undoOptions = this.currentOptions(mergedOptions);
            undoOptions.isResponsiveOptions = true;
            this.currentResponsive = {
              ruleIds,
              mergedOptions,
              undoOptions
            };
            this.update(mergedOptions, redraw, true);
          } else {
            this.currentResponsive = void 0;
          }
        }
      };
      return Additions2;
    }()
  );
})(Responsive || (Responsive = {}));
var Responsive_default = Responsive;

// node_modules/highcharts/es-modules/masters/highcharts.src.js
var G = Globals_default;
G.animate = AnimationUtilities_default.animate;
G.animObject = AnimationUtilities_default.animObject;
G.getDeferredAnimation = AnimationUtilities_default.getDeferredAnimation;
G.setAnimation = AnimationUtilities_default.setAnimation;
G.stop = AnimationUtilities_default.stop;
G.timers = Fx_default.timers;
G.AST = AST_default;
G.Axis = Axis_default;
G.Chart = Chart_default;
G.chart = Chart_default.chart;
G.Fx = Fx_default;
G.Legend = Legend_default;
G.PlotLineOrBand = PlotLineOrBand_default;
G.Point = Point_default;
G.Pointer = MSPointer_default.isRequired() ? MSPointer_default : Pointer_default;
G.Series = Series_default;
G.SVGElement = SVGElement_default;
G.SVGRenderer = SVGRenderer_default;
G.Tick = Tick_default;
G.Time = Time_default;
G.Tooltip = Tooltip_default;
G.Color = Color_default;
G.color = Color_default.parse;
HTMLRenderer_default.compose(SVGRenderer_default);
HTMLElement_default.compose(SVGElement_default);
G.defaultOptions = DefaultOptions_default.defaultOptions;
G.getOptions = DefaultOptions_default.getOptions;
G.time = DefaultOptions_default.defaultTime;
G.setOptions = DefaultOptions_default.setOptions;
G.dateFormat = FormatUtilities_default.dateFormat;
G.format = FormatUtilities_default.format;
G.numberFormat = FormatUtilities_default.numberFormat;
G.addEvent = Utilities_default.addEvent;
G.arrayMax = Utilities_default.arrayMax;
G.arrayMin = Utilities_default.arrayMin;
G.attr = Utilities_default.attr;
G.clearTimeout = Utilities_default.clearTimeout;
G.correctFloat = Utilities_default.correctFloat;
G.createElement = Utilities_default.createElement;
G.css = Utilities_default.css;
G.defined = Utilities_default.defined;
G.destroyObjectProperties = Utilities_default.destroyObjectProperties;
G.discardElement = Utilities_default.discardElement;
G.distribute = RendererUtilities_default.distribute;
G.erase = Utilities_default.erase;
G.error = Utilities_default.error;
G.extend = Utilities_default.extend;
G.extendClass = Utilities_default.extendClass;
G.find = Utilities_default.find;
G.fireEvent = Utilities_default.fireEvent;
G.getMagnitude = Utilities_default.getMagnitude;
G.getStyle = Utilities_default.getStyle;
G.inArray = Utilities_default.inArray;
G.isArray = Utilities_default.isArray;
G.isClass = Utilities_default.isClass;
G.isDOMElement = Utilities_default.isDOMElement;
G.isFunction = Utilities_default.isFunction;
G.isNumber = Utilities_default.isNumber;
G.isObject = Utilities_default.isObject;
G.isString = Utilities_default.isString;
G.keys = Utilities_default.keys;
G.merge = Utilities_default.merge;
G.normalizeTickInterval = Utilities_default.normalizeTickInterval;
G.objectEach = Utilities_default.objectEach;
G.offset = Utilities_default.offset;
G.pad = Utilities_default.pad;
G.pick = Utilities_default.pick;
G.pInt = Utilities_default.pInt;
G.relativeLength = Utilities_default.relativeLength;
G.removeEvent = Utilities_default.removeEvent;
G.seriesType = SeriesRegistry_default.seriesType;
G.splat = Utilities_default.splat;
G.stableSort = Utilities_default.stableSort;
G.syncTimeout = Utilities_default.syncTimeout;
G.timeUnits = Utilities_default.timeUnits;
G.uniqueKey = Utilities_default.uniqueKey;
G.useSerialIds = Utilities_default.useSerialIds;
G.wrap = Utilities_default.wrap;
ColumnDataLabel_default.compose(ColumnSeries_default);
DataLabel_default.compose(Series_default);
DateTimeAxis_default.compose(Axis_default);
LogarithmicAxis_default.compose(Axis_default);
PieDataLabel_default.compose(PieSeries_default);
PlotLineOrBand_default.compose(Axis_default);
Responsive_default.compose(Chart_default);
var highcharts_src_default = G;

// node_modules/highcharts/es-modules/Core/Axis/OrdinalAxis.js
var addEvent19 = Utilities_default.addEvent;
var correctFloat6 = Utilities_default.correctFloat;
var css12 = Utilities_default.css;
var defined24 = Utilities_default.defined;
var error8 = Utilities_default.error;
var pick37 = Utilities_default.pick;
var timeUnits4 = Utilities_default.timeUnits;
var composedClasses = [];
var OrdinalAxis;
(function(OrdinalAxis2) {
  function compose(AxisClass, SeriesClass, ChartClass) {
    if (composedClasses.indexOf(AxisClass) === -1) {
      composedClasses.push(AxisClass);
      var axisProto = AxisClass.prototype;
      axisProto.getTimeTicks = getTimeTicks;
      axisProto.index2val = index2val;
      axisProto.lin2val = lin2val;
      axisProto.val2lin = val2lin;
      axisProto.ordinal2lin = axisProto.val2lin;
      addEvent19(AxisClass, "afterInit", onAxisAfterInit);
      addEvent19(AxisClass, "foundExtremes", onAxisFoundExtremes);
      addEvent19(AxisClass, "afterSetScale", onAxisAfterSetScale);
      addEvent19(AxisClass, "initialAxisTranslation", onAxisInitialAxisTranslation);
    }
    if (composedClasses.indexOf(ChartClass) === -1) {
      composedClasses.push(ChartClass);
      addEvent19(ChartClass, "pan", onChartPan);
    }
    if (composedClasses.indexOf(SeriesClass) === -1) {
      composedClasses.push(SeriesClass);
      addEvent19(SeriesClass, "updatedData", onSeriesUpdatedData);
    }
    return AxisClass;
  }
  OrdinalAxis2.compose = compose;
  function getTimeTicks(normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {
    if (positions === void 0) {
      positions = [];
    }
    if (closestDistance === void 0) {
      closestDistance = 0;
    }
    var higherRanks = {}, tickPixelIntervalOption = this.options.tickPixelInterval, time = this.chart.time, segmentStarts = [];
    var end, segmentPositions, hasCrossedHigherRank, info, outsideMax, start = 0, groupPositions = [], lastGroupPosition = -Number.MAX_VALUE;
    if (!this.options.ordinal && !this.options.breaks || !positions || positions.length < 3 || typeof min === "undefined") {
      return time.getTimeTicks.apply(time, arguments);
    }
    var posLength = positions.length;
    for (end = 0; end < posLength; end++) {
      outsideMax = end && positions[end - 1] > max;
      if (positions[end] < min) {
        start = end;
      }
      if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {
        if (positions[end] > lastGroupPosition) {
          segmentPositions = time.getTimeTicks(normalizedInterval, positions[start], positions[end], startOfWeek);
          while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {
            segmentPositions.shift();
          }
          if (segmentPositions.length) {
            lastGroupPosition = segmentPositions[segmentPositions.length - 1];
          }
          segmentStarts.push(groupPositions.length);
          groupPositions = groupPositions.concat(segmentPositions);
        }
        start = end + 1;
      }
      if (outsideMax) {
        break;
      }
    }
    if (segmentPositions) {
      info = segmentPositions.info;
      if (findHigherRanks && info.unitRange <= timeUnits4.hour) {
        end = groupPositions.length - 1;
        for (start = 1; start < end; start++) {
          if (time.dateFormat("%d", groupPositions[start]) !== time.dateFormat("%d", groupPositions[start - 1])) {
            higherRanks[groupPositions[start]] = "day";
            hasCrossedHigherRank = true;
          }
        }
        if (hasCrossedHigherRank) {
          higherRanks[groupPositions[0]] = "day";
        }
        info.higherRanks = higherRanks;
      }
      info.segmentStarts = segmentStarts;
      groupPositions.info = info;
    } else {
      error8(12, false, this.chart);
    }
    if (findHigherRanks && defined24(tickPixelIntervalOption)) {
      var length_1 = groupPositions.length, translatedArr = [], distances = [];
      var itemToRemove = void 0, translated = void 0, lastTranslated = void 0, medianDistance = void 0, distance = void 0, i = length_1;
      while (i--) {
        translated = this.translate(groupPositions[i]);
        if (lastTranslated) {
          distances[i] = lastTranslated - translated;
        }
        translatedArr[i] = lastTranslated = translated;
      }
      distances.sort();
      medianDistance = distances[Math.floor(distances.length / 2)];
      if (medianDistance < tickPixelIntervalOption * 0.6) {
        medianDistance = null;
      }
      i = groupPositions[length_1 - 1] > max ? length_1 - 1 : length_1;
      lastTranslated = void 0;
      while (i--) {
        translated = translatedArr[i];
        distance = Math.abs(lastTranslated - translated);
        if (lastTranslated && distance < tickPixelIntervalOption * 0.8 && (medianDistance === null || distance < medianDistance * 0.8)) {
          if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {
            itemToRemove = i + 1;
            lastTranslated = translated;
          } else {
            itemToRemove = i;
          }
          groupPositions.splice(itemToRemove, 1);
        } else {
          lastTranslated = translated;
        }
      }
    }
    return groupPositions;
  }
  function index2val(index) {
    var axis = this, ordinal = axis.ordinal, ordinalPositions = ordinal.positions;
    if (!ordinalPositions) {
      return index;
    }
    var i = ordinalPositions.length - 1, distance;
    if (index < 0) {
      index = ordinalPositions[0];
    } else if (index > i) {
      index = ordinalPositions[i];
    } else {
      i = Math.floor(index);
      distance = index - i;
    }
    if (typeof distance !== "undefined" && typeof ordinalPositions[i] !== "undefined") {
      return ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0);
    }
    return index;
  }
  function lin2val(val) {
    var axis = this, ordinal = axis.ordinal, localMin = axis.old ? axis.old.min : axis.min, localA = axis.old ? axis.old.transA : axis.transA;
    var positions = ordinal.positions;
    if (!positions) {
      return val;
    }
    var pixelVal = (val - localMin) * localA + axis.minPixelPadding, isInside = pixelVal > 0 && pixelVal < axis.left + axis.len;
    if (!isInside) {
      if (!ordinal.extendedOrdinalPositions) {
        ordinal.extendedOrdinalPositions = ordinal.getExtendedPositions();
      }
      positions = ordinal.extendedOrdinalPositions;
    }
    if (positions && positions.length) {
      var index = ordinal.getIndexOfPoint(pixelVal, positions), mantissa = correctFloat6(index % 1);
      if (index >= 0 && index < positions.length) {
        var leftNeighbour = positions[Math.floor(index)], rightNeighbour = positions[Math.ceil(index)], distance = rightNeighbour - leftNeighbour;
        return positions[Math.floor(index)] + mantissa * distance;
      }
      var positionsLength = positions.length, firstPositionsValue = positions[0], lastPositionsValue = positions[positionsLength - 1], slope = (lastPositionsValue - firstPositionsValue) / (positionsLength - 1);
      if (index < 0) {
        return firstPositionsValue + slope * index;
      }
      return lastPositionsValue + slope * (index - positionsLength);
    }
    return val;
  }
  function getIndexInArray(ordinalPositions, val) {
    var index = OrdinalAxis2.Additions.findIndexOf(ordinalPositions, val, true);
    if (ordinalPositions[index] === val) {
      return index;
    }
    var percent = (val - ordinalPositions[index]) / (ordinalPositions[index + 1] - ordinalPositions[index]);
    return index + percent;
  }
  function onAxisAfterInit() {
    var axis = this;
    if (!axis.ordinal) {
      axis.ordinal = new OrdinalAxis2.Additions(axis);
    }
  }
  function onAxisFoundExtremes() {
    var axis = this;
    if (axis.isXAxis && defined24(axis.options.overscroll) && axis.max === axis.dataMax && // Panning is an execption. We don't want to apply
    // overscroll when panning over the dataMax
    (!axis.chart.mouseIsDown || axis.isInternal) && // Scrollbar buttons are the other execption:
    (!axis.eventArgs || axis.eventArgs && axis.eventArgs.trigger !== "navigator")) {
      axis.max += axis.options.overscroll;
      if (!axis.isInternal && defined24(axis.userMin)) {
        axis.min += axis.options.overscroll;
      }
    }
  }
  function onAxisAfterSetScale() {
    var axis = this;
    if (axis.horiz && !axis.isDirty) {
      axis.isDirty = axis.isOrdinal && axis.chart.navigator && !axis.chart.navigator.adaptToUpdatedData;
    }
  }
  function onAxisInitialAxisTranslation() {
    var axis = this;
    if (axis.ordinal) {
      axis.ordinal.beforeSetTickPositions();
      axis.tickInterval = axis.ordinal.postProcessTickInterval(axis.tickInterval);
    }
  }
  function onChartPan(e2) {
    var chart = this, xAxis = chart.xAxis[0], overscroll = xAxis.options.overscroll, chartX = e2.originalEvent.chartX, panning = chart.options.chart.panning;
    var runBase = false;
    if (panning && panning.type !== "y" && xAxis.options.ordinal && xAxis.series.length) {
      var mouseDownX = chart.mouseDownX, extremes = xAxis.getExtremes(), dataMax = extremes.dataMax, min = extremes.min, max = extremes.max, hoverPoints = chart.hoverPoints, closestPointRange = xAxis.closestPointRange || xAxis.ordinal && xAxis.ordinal.overscrollPointsRange, pointPixelWidth = xAxis.translationSlope * (xAxis.ordinal.slope || closestPointRange), movedUnits = (mouseDownX - chartX) / pointPixelWidth, extendedAxis = { ordinal: { positions: xAxis.ordinal.getExtendedPositions() } }, index2val_1 = xAxis.index2val, val2lin_1 = xAxis.val2lin;
      var trimmedRange = void 0, ordinalPositions = void 0, searchAxisLeft = void 0, searchAxisRight = void 0;
      if (!extendedAxis.ordinal.positions) {
        runBase = true;
      } else if (Math.abs(movedUnits) > 1) {
        if (hoverPoints) {
          hoverPoints.forEach(function(point) {
            point.setState();
          });
        }
        if (movedUnits < 0) {
          searchAxisLeft = extendedAxis;
          searchAxisRight = xAxis.ordinal.positions ? xAxis : extendedAxis;
        } else {
          searchAxisLeft = xAxis.ordinal.positions ? xAxis : extendedAxis;
          searchAxisRight = extendedAxis;
        }
        ordinalPositions = searchAxisRight.ordinal.positions;
        if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
          ordinalPositions.push(dataMax);
        }
        chart.fixedRange = max - min;
        trimmedRange = xAxis.navigatorAxis.toFixedRange(null, null, index2val_1.apply(searchAxisLeft, [
          val2lin_1.apply(searchAxisLeft, [min, true]) + movedUnits
        ]), index2val_1.apply(searchAxisRight, [
          val2lin_1.apply(searchAxisRight, [max, true]) + movedUnits
        ]));
        if (trimmedRange.min >= Math.min(extremes.dataMin, min) && trimmedRange.max <= Math.max(dataMax, max) + overscroll) {
          xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, { trigger: "pan" });
        }
        chart.mouseDownX = chartX;
        css12(chart.container, { cursor: "move" });
      }
    } else {
      runBase = true;
    }
    if (runBase || panning && /y/.test(panning.type)) {
      if (overscroll) {
        xAxis.max = xAxis.dataMax + overscroll;
      }
    } else {
      e2.preventDefault();
    }
  }
  function onSeriesUpdatedData() {
    var xAxis = this.xAxis;
    if (xAxis && xAxis.options.ordinal) {
      delete xAxis.ordinal.index;
      delete xAxis.ordinal.extendedOrdinalPositions;
    }
  }
  function val2lin(val, toIndex) {
    var axis = this, ordinal = axis.ordinal, ordinalPositions = ordinal.positions;
    var slope = ordinal.slope, extendedOrdinalPositions = ordinal.extendedOrdinalPositions;
    if (!ordinalPositions) {
      return val;
    }
    var ordinalLength = ordinalPositions.length;
    var ordinalIndex;
    if (ordinalPositions[0] <= val && ordinalPositions[ordinalLength - 1] >= val) {
      ordinalIndex = getIndexInArray(ordinalPositions, val);
    } else {
      if (!extendedOrdinalPositions) {
        extendedOrdinalPositions = ordinal.getExtendedPositions && ordinal.getExtendedPositions();
        ordinal.extendedOrdinalPositions = extendedOrdinalPositions;
      }
      if (!(extendedOrdinalPositions && extendedOrdinalPositions.length)) {
        return val;
      }
      var length_2 = extendedOrdinalPositions.length;
      if (!slope) {
        slope = (extendedOrdinalPositions[length_2 - 1] - extendedOrdinalPositions[0]) / length_2;
      }
      var originalPositionsReference = getIndexInArray(extendedOrdinalPositions, ordinalPositions[0]);
      if (val >= extendedOrdinalPositions[0] && val <= extendedOrdinalPositions[length_2 - 1]) {
        ordinalIndex = getIndexInArray(extendedOrdinalPositions, val) - originalPositionsReference;
      } else {
        if (val < extendedOrdinalPositions[0]) {
          var diff = extendedOrdinalPositions[0] - val, approximateIndexOffset = diff / slope;
          ordinalIndex = -originalPositionsReference - approximateIndexOffset;
        } else {
          var diff = val - extendedOrdinalPositions[length_2 - 1], approximateIndexOffset = diff / slope;
          ordinalIndex = approximateIndexOffset + length_2 - originalPositionsReference;
        }
      }
    }
    return toIndex ? ordinalIndex : slope * (ordinalIndex || 0) + ordinal.offset;
  }
  var Additions = (
    /** @class */
    function() {
      function Additions2(axis) {
        this.index = {};
        this.axis = axis;
      }
      Additions2.prototype.beforeSetTickPositions = function() {
        var axis = this.axis, ordinal = axis.ordinal, extremes = axis.getExtremes(), min = extremes.min, max = extremes.max, hasBreaks = axis.isXAxis && !!axis.options.breaks, isOrdinal = axis.options.ordinal, ignoreHiddenSeries = axis.chart.options.chart.ignoreHiddenSeries;
        var len, uniqueOrdinalPositions, dist, minIndex, maxIndex, slope, i, hasBoostedSeries, ordinalPositions = [], overscrollPointsRange = Number.MAX_VALUE, useOrdinal = false;
        if (isOrdinal || hasBreaks) {
          axis.series.forEach(function(series, i2) {
            uniqueOrdinalPositions = [];
            if ((!ignoreHiddenSeries || series.visible !== false) && (series.takeOrdinalPosition !== false || hasBreaks)) {
              ordinalPositions = ordinalPositions.concat(series.processedXData);
              len = ordinalPositions.length;
              ordinalPositions.sort(function(a, b) {
                return a - b;
              });
              overscrollPointsRange = Math.min(overscrollPointsRange, pick37(
                // Check for a single-point series:
                series.closestPointRange,
                overscrollPointsRange
              ));
              if (len) {
                i2 = 0;
                while (i2 < len - 1) {
                  if (ordinalPositions[i2] !== ordinalPositions[i2 + 1]) {
                    uniqueOrdinalPositions.push(ordinalPositions[i2 + 1]);
                  }
                  i2++;
                }
                if (uniqueOrdinalPositions[0] !== ordinalPositions[0]) {
                  uniqueOrdinalPositions.unshift(ordinalPositions[0]);
                }
                ordinalPositions = uniqueOrdinalPositions;
              }
            }
            if (series.isSeriesBoosting) {
              hasBoostedSeries = true;
            }
          });
          if (hasBoostedSeries) {
            ordinalPositions.length = 0;
          }
          len = ordinalPositions.length;
          if (len > 2) {
            dist = ordinalPositions[1] - ordinalPositions[0];
            i = len - 1;
            while (i-- && !useOrdinal) {
              if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
                useOrdinal = true;
              }
            }
            if (!axis.options.keepOrdinalPadding && (ordinalPositions[0] - min > dist || max - ordinalPositions[ordinalPositions.length - 1] > dist)) {
              useOrdinal = true;
            }
          } else if (axis.options.overscroll) {
            if (len === 2) {
              overscrollPointsRange = ordinalPositions[1] - ordinalPositions[0];
            } else if (len === 1) {
              overscrollPointsRange = axis.options.overscroll;
              ordinalPositions = [
                ordinalPositions[0],
                ordinalPositions[0] + overscrollPointsRange
              ];
            } else {
              overscrollPointsRange = ordinal.overscrollPointsRange;
            }
          }
          if (useOrdinal || axis.forceOrdinal) {
            if (axis.options.overscroll) {
              ordinal.overscrollPointsRange = overscrollPointsRange;
              ordinalPositions = ordinalPositions.concat(ordinal.getOverscrollPositions());
            }
            ordinal.positions = ordinalPositions;
            minIndex = axis.ordinal2lin(
              // #5979
              Math.max(min, ordinalPositions[0]),
              true
            );
            maxIndex = Math.max(axis.ordinal2lin(Math.min(max, ordinalPositions[ordinalPositions.length - 1]), true), 1);
            ordinal.slope = slope = (max - min) / (maxIndex - minIndex);
            ordinal.offset = min - minIndex * slope;
          } else {
            ordinal.overscrollPointsRange = pick37(axis.closestPointRange, ordinal.overscrollPointsRange);
            ordinal.positions = axis.ordinal.slope = ordinal.offset = void 0;
          }
        }
        axis.isOrdinal = isOrdinal && useOrdinal;
        ordinal.groupIntervalFactor = null;
      };
      Additions2.findIndexOf = function(sortedArray, key, indirectSearch) {
        var start = 0, end = sortedArray.length - 1, middle;
        while (start < end) {
          middle = Math.ceil((start + end) / 2);
          if (sortedArray[middle] <= key) {
            start = middle;
          } else {
            end = middle - 1;
          }
        }
        if (sortedArray[start] === key) {
          return start;
        }
        return !indirectSearch ? -1 : start;
      };
      Additions2.prototype.getExtendedPositions = function() {
        var ordinal = this, axis = ordinal.axis, axisProto = axis.constructor.prototype, chart = axis.chart, grouping = axis.series[0].currentDataGrouping, key = grouping ? grouping.count + grouping.unitName : "raw", overscroll = axis.options.overscroll, extremes = axis.getExtremes();
        var fakeAxis, fakeSeries = void 0, ordinalIndex = ordinal.index;
        if (!ordinalIndex) {
          ordinalIndex = ordinal.index = {};
        }
        if (!ordinalIndex[key]) {
          fakeAxis = {
            series: [],
            chart,
            forceOrdinal: false,
            getExtremes: function() {
              return {
                min: extremes.dataMin,
                max: extremes.dataMax + overscroll
              };
            },
            getGroupPixelWidth: axisProto.getGroupPixelWidth,
            getTimeTicks: axisProto.getTimeTicks,
            options: {
              ordinal: true
            },
            ordinal: {
              getGroupIntervalFactor: this.getGroupIntervalFactor
            },
            ordinal2lin: axisProto.ordinal2lin,
            getIndexOfPoint: axisProto.getIndexOfPoint,
            val2lin: axisProto.val2lin
            // #2590
          };
          fakeAxis.ordinal.axis = fakeAxis;
          axis.series.forEach(function(series) {
            fakeSeries = {
              xAxis: fakeAxis,
              xData: series.xData.slice(),
              chart,
              destroyGroupedData: Globals_default.noop,
              getProcessedData: Series_default.prototype.getProcessedData,
              applyGrouping: Series_default.prototype.applyGrouping
            };
            fakeSeries.xData = fakeSeries.xData.concat(ordinal.getOverscrollPositions());
            fakeSeries.options = {
              dataGrouping: grouping ? {
                firstAnchor: "firstPoint",
                anchor: "middle",
                lastAnchor: "lastPoint",
                enabled: true,
                forced: true,
                // doesn't matter which, use the fastest
                approximation: "open",
                units: [[
                  grouping.unitName,
                  [grouping.count]
                ]]
              } : {
                enabled: false
              }
            };
            fakeAxis.series.push(fakeSeries);
            series.processData.apply(fakeSeries);
          });
          axis.applyGrouping.call(fakeAxis);
          if (fakeSeries.closestPointRange !== fakeSeries.basePointRange && fakeSeries.currentDataGrouping) {
            fakeAxis.forceOrdinal = true;
          }
          axis.ordinal.beforeSetTickPositions.apply({ axis: fakeAxis });
          ordinalIndex[key] = fakeAxis.ordinal.positions;
        }
        return ordinalIndex[key];
      };
      Additions2.prototype.getGroupIntervalFactor = function(xMin, xMax, series) {
        var ordinal = this, axis = ordinal.axis, processedXData = series.processedXData, len = processedXData.length, distances = [];
        var median, i, groupIntervalFactor = ordinal.groupIntervalFactor;
        if (!groupIntervalFactor) {
          for (i = 0; i < len - 1; i++) {
            distances[i] = processedXData[i + 1] - processedXData[i];
          }
          distances.sort(function(a, b) {
            return a - b;
          });
          median = distances[Math.floor(len / 2)];
          xMin = Math.max(xMin, processedXData[0]);
          xMax = Math.min(xMax, processedXData[len - 1]);
          ordinal.groupIntervalFactor = groupIntervalFactor = len * median / (xMax - xMin);
        }
        return groupIntervalFactor;
      };
      Additions2.prototype.getIndexOfPoint = function(val, ordinalArray) {
        var ordinal = this, axis = ordinal.axis, firstPointVal = ordinal.positions ? ordinal.positions[0] : 0;
        var firstPointX = axis.series[0].points && axis.series[0].points[0] && axis.series[0].points[0].plotX || axis.minPixelPadding;
        if (axis.series.length > 1) {
          axis.series.forEach(function(series) {
            if (defined24(series.points[0]) && defined24(series.points[0].plotX) && series.points[0].plotX < firstPointX) {
              firstPointX = series.points[0].plotX;
            }
          });
        }
        var ordinalPointPixelInterval = axis.translationSlope * (ordinal.slope || axis.closestPointRange || ordinal.overscrollPointsRange), shiftIndex = (val - firstPointX) / ordinalPointPixelInterval;
        return Additions2.findIndexOf(ordinalArray, firstPointVal) + shiftIndex;
      };
      Additions2.prototype.getOverscrollPositions = function() {
        var ordinal = this, axis = ordinal.axis, extraRange = axis.options.overscroll, distance = ordinal.overscrollPointsRange, positions = [], max = axis.dataMax;
        if (defined24(distance)) {
          while (max <= axis.dataMax + extraRange) {
            max += distance;
            positions.push(max);
          }
        }
        return positions;
      };
      Additions2.prototype.postProcessTickInterval = function(tickInterval) {
        var ordinal = this, axis = ordinal.axis, ordinalSlope = ordinal.slope;
        var ret;
        if (ordinalSlope) {
          if (!axis.options.breaks) {
            ret = tickInterval / (ordinalSlope / axis.closestPointRange);
          } else {
            ret = axis.closestPointRange || tickInterval;
          }
        } else {
          ret = tickInterval;
        }
        return ret;
      };
      return Additions2;
    }()
  );
  OrdinalAxis2.Additions = Additions;
})(OrdinalAxis || (OrdinalAxis = {}));
var OrdinalAxis_default = OrdinalAxis;

// node_modules/highcharts/es-modules/Core/Axis/BrokenAxis.js
var addEvent20 = Utilities_default.addEvent;
var find7 = Utilities_default.find;
var fireEvent17 = Utilities_default.fireEvent;
var isArray15 = Utilities_default.isArray;
var isNumber25 = Utilities_default.isNumber;
var pick38 = Utilities_default.pick;
var BrokenAxis;
(function(BrokenAxis2) {
  var composedClasses2 = [];
  function compose(AxisClass, SeriesClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      AxisClass.keepProps.push("brokenAxis");
      addEvent20(AxisClass, "init", onAxisInit);
      addEvent20(AxisClass, "afterInit", onAxisAfterInit);
      addEvent20(AxisClass, "afterSetTickPositions", onAxisAfterSetTickPositions);
      addEvent20(AxisClass, "afterSetOptions", onAxisAfterSetOptions);
    }
    if (composedClasses2.indexOf(SeriesClass) === -1) {
      composedClasses2.push(SeriesClass);
      var seriesProto5 = SeriesClass.prototype;
      seriesProto5.drawBreaks = seriesDrawBreaks;
      seriesProto5.gappedPath = seriesGappedPath;
      addEvent20(SeriesClass, "afterGeneratePoints", onSeriesAfterGeneratePoints);
      addEvent20(SeriesClass, "afterRender", onSeriesAfterRender);
    }
    return AxisClass;
  }
  BrokenAxis2.compose = compose;
  function onAxisAfterInit() {
    if (typeof this.brokenAxis !== "undefined") {
      this.brokenAxis.setBreaks(this.options.breaks, false);
    }
  }
  function onAxisAfterSetOptions() {
    var axis = this;
    if (axis.brokenAxis && axis.brokenAxis.hasBreaks) {
      axis.options.ordinal = false;
    }
  }
  function onAxisAfterSetTickPositions() {
    var axis = this, brokenAxis = axis.brokenAxis;
    if (brokenAxis && brokenAxis.hasBreaks) {
      var tickPositions = axis.tickPositions, info = axis.tickPositions.info, newPositions = [];
      for (var i = 0; i < tickPositions.length; i++) {
        if (!brokenAxis.isInAnyBreak(tickPositions[i])) {
          newPositions.push(tickPositions[i]);
        }
      }
      axis.tickPositions = newPositions;
      axis.tickPositions.info = info;
    }
  }
  function onAxisInit() {
    var axis = this;
    if (!axis.brokenAxis) {
      axis.brokenAxis = new Additions(axis);
    }
  }
  function onSeriesAfterGeneratePoints() {
    var _a15 = this, isDirty = _a15.isDirty, connectNulls = _a15.options.connectNulls, points = _a15.points, xAxis = _a15.xAxis, yAxis = _a15.yAxis;
    if (isDirty) {
      var i = points.length;
      while (i--) {
        var point = points[i];
        var nullGap = point.y === null && connectNulls === false;
        var isPointInBreak = !nullGap && (xAxis && xAxis.brokenAxis && xAxis.brokenAxis.isInAnyBreak(point.x, true) || yAxis && yAxis.brokenAxis && yAxis.brokenAxis.isInAnyBreak(point.y, true));
        point.visible = isPointInBreak ? false : point.options.visible !== false;
      }
    }
  }
  function onSeriesAfterRender() {
    this.drawBreaks(this.xAxis, ["x"]);
    this.drawBreaks(this.yAxis, pick38(this.pointArrayMap, ["y"]));
  }
  function seriesDrawBreaks(axis, keys2) {
    var series = this, points = series.points;
    var breaks, threshold, eventName, y;
    if (axis && // #5950
    axis.brokenAxis && axis.brokenAxis.hasBreaks) {
      var brokenAxis_1 = axis.brokenAxis;
      keys2.forEach(function(key) {
        breaks = brokenAxis_1 && brokenAxis_1.breakArray || [];
        threshold = axis.isXAxis ? axis.min : pick38(series.options.threshold, axis.min);
        points.forEach(function(point) {
          y = pick38(point["stack" + key.toUpperCase()], point[key]);
          breaks.forEach(function(brk) {
            if (isNumber25(threshold) && isNumber25(y)) {
              eventName = false;
              if (threshold < brk.from && y > brk.to || threshold > brk.from && y < brk.from) {
                eventName = "pointBreak";
              } else if (threshold < brk.from && y > brk.from && y < brk.to || threshold > brk.from && y > brk.to && y < brk.from) {
                eventName = "pointInBreak";
              }
              if (eventName) {
                fireEvent17(axis, eventName, { point, brk });
              }
            }
          });
        });
      });
    }
  }
  function seriesGappedPath() {
    var currentDataGrouping = this.currentDataGrouping, groupingSize = currentDataGrouping && currentDataGrouping.gapSize, points = this.points.slice(), yAxis = this.yAxis;
    var gapSize = this.options.gapSize, i = points.length - 1, stack;
    if (gapSize && i > 0) {
      if (this.options.gapUnit !== "value") {
        gapSize *= this.basePointRange;
      }
      if (groupingSize && groupingSize > gapSize && // Except when DG is forced (e.g. from other series)
      // and has lower granularity than actual points (#11351)
      groupingSize >= this.basePointRange) {
        gapSize = groupingSize;
      }
      var current = void 0, next = void 0;
      while (i--) {
        if (!(next && next.visible !== false)) {
          next = points[i + 1];
        }
        current = points[i];
        if (next.visible === false || current.visible === false) {
          continue;
        }
        if (next.x - current.x > gapSize) {
          var xRange = (current.x + next.x) / 2;
          points.splice(
            // insert after this one
            i + 1,
            0,
            {
              isNull: true,
              x: xRange
            }
          );
          if (yAxis.stacking && this.options.stacking) {
            stack = yAxis.stacking.stacks[this.stackKey][xRange] = new Stacking_default(yAxis, yAxis.options.stackLabels, false, xRange, this.stack);
            stack.total = 0;
          }
        }
        next = current;
      }
    }
    return this.getGraphPath(points);
  }
  var Additions = (
    /** @class */
    function() {
      function Additions2(axis) {
        this.hasBreaks = false;
        this.axis = axis;
      }
      Additions2.isInBreak = function(brk, val) {
        var repeat = brk.repeat || Infinity, from = brk.from, length = brk.to - brk.from, test = val >= from ? (val - from) % repeat : repeat - (from - val) % repeat;
        var ret;
        if (!brk.inclusive) {
          ret = test < length && test !== 0;
        } else {
          ret = test <= length;
        }
        return ret;
      };
      Additions2.lin2Val = function(val) {
        var axis = this;
        var brokenAxis = axis.brokenAxis;
        var breakArray = brokenAxis && brokenAxis.breakArray;
        if (!breakArray || !isNumber25(val)) {
          return val;
        }
        var nval = val, brk, i;
        for (i = 0; i < breakArray.length; i++) {
          brk = breakArray[i];
          if (brk.from >= nval) {
            break;
          } else if (brk.to < nval) {
            nval += brk.len;
          } else if (Additions2.isInBreak(brk, nval)) {
            nval += brk.len;
          }
        }
        return nval;
      };
      Additions2.val2Lin = function(val) {
        var axis = this;
        var brokenAxis = axis.brokenAxis;
        var breakArray = brokenAxis && brokenAxis.breakArray;
        if (!breakArray || !isNumber25(val)) {
          return val;
        }
        var nval = val, brk, i;
        for (i = 0; i < breakArray.length; i++) {
          brk = breakArray[i];
          if (brk.to <= val) {
            nval -= brk.len;
          } else if (brk.from >= val) {
            break;
          } else if (Additions2.isInBreak(brk, val)) {
            nval -= val - brk.from;
            break;
          }
        }
        return nval;
      };
      Additions2.prototype.findBreakAt = function(x, breaks) {
        return find7(breaks, function(b) {
          return b.from < x && x < b.to;
        });
      };
      Additions2.prototype.isInAnyBreak = function(val, testKeep) {
        var brokenAxis = this, axis = brokenAxis.axis, breaks = axis.options.breaks || [];
        var i = breaks.length, inbrk, keep, ret;
        if (i && isNumber25(val)) {
          while (i--) {
            if (Additions2.isInBreak(breaks[i], val)) {
              inbrk = true;
              if (!keep) {
                keep = pick38(breaks[i].showPoints, !axis.isXAxis);
              }
            }
          }
          if (inbrk && testKeep) {
            ret = inbrk && !keep;
          } else {
            ret = inbrk;
          }
        }
        return ret;
      };
      Additions2.prototype.setBreaks = function(breaks, redraw) {
        var brokenAxis = this;
        var axis = brokenAxis.axis;
        var hasBreaks = isArray15(breaks) && !!breaks.length;
        axis.isDirty = brokenAxis.hasBreaks !== hasBreaks;
        brokenAxis.hasBreaks = hasBreaks;
        axis.options.breaks = axis.userOptions.breaks = breaks;
        axis.forceRedraw = true;
        axis.series.forEach(function(series) {
          series.isDirty = true;
        });
        if (!hasBreaks && axis.val2lin === Additions2.val2Lin) {
          delete axis.val2lin;
          delete axis.lin2val;
        }
        if (hasBreaks) {
          axis.userOptions.ordinal = false;
          axis.lin2val = Additions2.lin2Val;
          axis.val2lin = Additions2.val2Lin;
          axis.setExtremes = function(newMin, newMax, redraw2, animation, eventArguments) {
            if (brokenAxis.hasBreaks) {
              var breaks_1 = this.options.breaks || [];
              var axisBreak = void 0;
              while (axisBreak = brokenAxis.findBreakAt(newMin, breaks_1)) {
                newMin = axisBreak.to;
              }
              while (axisBreak = brokenAxis.findBreakAt(newMax, breaks_1)) {
                newMax = axisBreak.from;
              }
              if (newMax < newMin) {
                newMax = newMin;
              }
            }
            axis.constructor.prototype.setExtremes.call(this, newMin, newMax, redraw2, animation, eventArguments);
          };
          axis.setAxisTranslation = function() {
            axis.constructor.prototype.setAxisTranslation.call(this);
            brokenAxis.unitLength = void 0;
            if (brokenAxis.hasBreaks) {
              var breaks_2 = axis.options.breaks || [], breakArrayT_1 = [], breakArray_1 = [], pointRangePadding = pick38(axis.pointRangePadding, 0);
              var length_1 = 0, inBrk_1, repeat_1, min_1 = axis.userMin || axis.min, max_1 = axis.userMax || axis.max, start_1, i_1;
              breaks_2.forEach(function(brk) {
                repeat_1 = brk.repeat || Infinity;
                if (isNumber25(min_1) && isNumber25(max_1)) {
                  if (Additions2.isInBreak(brk, min_1)) {
                    min_1 += brk.to % repeat_1 - min_1 % repeat_1;
                  }
                  if (Additions2.isInBreak(brk, max_1)) {
                    max_1 -= max_1 % repeat_1 - brk.from % repeat_1;
                  }
                }
              });
              breaks_2.forEach(function(brk) {
                start_1 = brk.from;
                repeat_1 = brk.repeat || Infinity;
                if (isNumber25(min_1) && isNumber25(max_1)) {
                  while (start_1 - repeat_1 > min_1) {
                    start_1 -= repeat_1;
                  }
                  while (start_1 < min_1) {
                    start_1 += repeat_1;
                  }
                  for (i_1 = start_1; i_1 < max_1; i_1 += repeat_1) {
                    breakArrayT_1.push({
                      value: i_1,
                      move: "in"
                    });
                    breakArrayT_1.push({
                      value: i_1 + brk.to - brk.from,
                      move: "out",
                      size: brk.breakSize
                    });
                  }
                }
              });
              breakArrayT_1.sort(function(a, b) {
                return a.value === b.value ? (a.move === "in" ? 0 : 1) - (b.move === "in" ? 0 : 1) : a.value - b.value;
              });
              inBrk_1 = 0;
              start_1 = min_1;
              breakArrayT_1.forEach(function(brk) {
                inBrk_1 += brk.move === "in" ? 1 : -1;
                if (inBrk_1 === 1 && brk.move === "in") {
                  start_1 = brk.value;
                }
                if (inBrk_1 === 0 && isNumber25(start_1)) {
                  breakArray_1.push({
                    from: start_1,
                    to: brk.value,
                    len: brk.value - start_1 - (brk.size || 0)
                  });
                  length_1 += brk.value - start_1 - (brk.size || 0);
                }
              });
              brokenAxis.breakArray = breakArray_1;
              if (isNumber25(min_1) && isNumber25(max_1) && isNumber25(axis.min)) {
                brokenAxis.unitLength = max_1 - min_1 - length_1 + pointRangePadding;
                fireEvent17(axis, "afterBreaks");
                if (axis.staticScale) {
                  axis.transA = axis.staticScale;
                } else if (brokenAxis.unitLength) {
                  axis.transA *= (max_1 - axis.min + pointRangePadding) / brokenAxis.unitLength;
                }
                if (pointRangePadding) {
                  axis.minPixelPadding = axis.transA * (axis.minPointOffset || 0);
                }
                axis.min = min_1;
                axis.max = max_1;
              }
            }
          };
        }
        if (pick38(redraw, true)) {
          axis.chart.redraw();
        }
      };
      return Additions2;
    }()
  );
  BrokenAxis2.Additions = Additions;
})(BrokenAxis || (BrokenAxis = {}));
var BrokenAxis_default = BrokenAxis;

// node_modules/highcharts/es-modules/masters/modules/broken-axis.src.js
var G2 = Globals_default;
BrokenAxis_default.compose(G2.Axis, G2.Series);

// node_modules/highcharts/es-modules/Extensions/DataGrouping.js
var format7 = FormatUtilities_default.format;
var seriesProto = Series_default.prototype;
var addEvent21 = Utilities_default.addEvent;
var arrayMax6 = Utilities_default.arrayMax;
var arrayMin5 = Utilities_default.arrayMin;
var correctFloat7 = Utilities_default.correctFloat;
var defined25 = Utilities_default.defined;
var error9 = Utilities_default.error;
var extend25 = Utilities_default.extend;
var isNumber26 = Utilities_default.isNumber;
var merge32 = Utilities_default.merge;
var pick39 = Utilities_default.pick;
var approximations = Globals_default.approximations = {
  sum: function(arr) {
    var len = arr.length, ret;
    if (!len && arr.hasNulls) {
      ret = null;
    } else if (len) {
      ret = 0;
      while (len--) {
        ret += arr[len];
      }
    }
    return ret;
  },
  average: function(arr) {
    var len = arr.length, ret = approximations.sum(arr);
    if (isNumber26(ret) && len) {
      ret = correctFloat7(ret / len);
    }
    return ret;
  },
  // The same as average, but for series with multiple values, like area
  // ranges.
  averages: function() {
    var ret = [];
    [].forEach.call(arguments, function(arr) {
      ret.push(approximations.average(arr));
    });
    return typeof ret[0] === "undefined" ? void 0 : ret;
  },
  open: function(arr) {
    return arr.length ? arr[0] : arr.hasNulls ? null : void 0;
  },
  high: function(arr) {
    return arr.length ? arrayMax6(arr) : arr.hasNulls ? null : void 0;
  },
  low: function(arr) {
    return arr.length ? arrayMin5(arr) : arr.hasNulls ? null : void 0;
  },
  close: function(arr) {
    return arr.length ? arr[arr.length - 1] : arr.hasNulls ? null : void 0;
  },
  // ohlc and range are special cases where a multidimensional array is
  // input and an array is output
  ohlc: function(open, high, low, close) {
    open = approximations.open(open);
    high = approximations.high(high);
    low = approximations.low(low);
    close = approximations.close(close);
    if (isNumber26(open) || isNumber26(high) || isNumber26(low) || isNumber26(close)) {
      return [open, high, low, close];
    }
  },
  range: function(low, high) {
    low = approximations.low(low);
    high = approximations.high(high);
    if (isNumber26(low) || isNumber26(high)) {
      return [low, high];
    }
    if (low === null && high === null) {
      return null;
    }
  }
};
var applyGrouping = function() {
  var series = this, chart = series.chart, options = series.options, dataGroupingOptions = options.dataGrouping, groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick39(dataGroupingOptions.enabled, chart.options.isStock), visible = series.visible || !chart.options.chart.ignoreHiddenSeries, hasGroupedData, skip, lastDataGrouping = this.currentDataGrouping, currentDataGrouping, croppedData, revertRequireSorting = false;
  if (groupingEnabled && !series.requireSorting) {
    series.requireSorting = revertRequireSorting = true;
  }
  skip = skipDataGrouping(series) || !groupingEnabled;
  if (revertRequireSorting) {
    series.requireSorting = false;
  }
  if (!skip) {
    series.destroyGroupedData();
    var i = void 0, processedXData = dataGroupingOptions.groupAll ? series.xData : series.processedXData, processedYData = dataGroupingOptions.groupAll ? series.yData : series.processedYData, plotSizeX = chart.plotSizeX, xAxis = series.xAxis, ordinal = xAxis.options.ordinal, groupPixelWidth = series.groupPixelWidth;
    if (groupPixelWidth && processedXData && processedXData.length) {
      hasGroupedData = true;
      series.isDirty = true;
      series.points = null;
      var extremes = xAxis.getExtremes(), xMin = extremes.min, xMax = extremes.max, groupIntervalFactor = ordinal && xAxis.ordinal && xAxis.ordinal.getGroupIntervalFactor(xMin, xMax, series) || 1, interval = groupPixelWidth * (xMax - xMin) / plotSizeX * groupIntervalFactor, groupPositions = xAxis.getTimeTicks(
        DateTimeAxis_default.Additions.prototype.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),
        // Processed data may extend beyond axis (#4907)
        Math.min(xMin, processedXData[0]),
        Math.max(xMax, processedXData[processedXData.length - 1]),
        xAxis.options.startOfWeek,
        processedXData,
        series.closestPointRange
      ), groupedData = seriesProto.groupData.apply(series, [
        processedXData,
        processedYData,
        groupPositions,
        dataGroupingOptions.approximation
      ]), groupedXData = groupedData.groupedXData, groupedYData = groupedData.groupedYData, gapSize = 0;
      if (dataGroupingOptions && dataGroupingOptions.smoothed && groupedXData.length) {
        dataGroupingOptions.firstAnchor = "firstPoint";
        dataGroupingOptions.anchor = "middle";
        dataGroupingOptions.lastAnchor = "lastPoint";
        error9(32, false, chart, { "dataGrouping.smoothed": "use dataGrouping.anchor" });
      }
      anchorPoints(series, groupedXData, xMax);
      for (i = 1; i < groupPositions.length; i++) {
        if (!groupPositions.info.segmentStarts || groupPositions.info.segmentStarts.indexOf(i) === -1) {
          gapSize = Math.max(groupPositions[i] - groupPositions[i - 1], gapSize);
        }
      }
      currentDataGrouping = groupPositions.info;
      currentDataGrouping.gapSize = gapSize;
      series.closestPointRange = groupPositions.info.totalRange;
      series.groupMap = groupedData.groupMap;
      if (visible) {
        adjustExtremes(xAxis, groupedXData);
      }
      if (dataGroupingOptions.groupAll) {
        series.allGroupedData = groupedYData;
        croppedData = series.cropData(
          groupedXData,
          groupedYData,
          xAxis.min,
          xAxis.max,
          1
          // Ordinal xAxis will remove left-most points otherwise
        );
        groupedXData = croppedData.xData;
        groupedYData = croppedData.yData;
        series.cropStart = croppedData.start;
      }
      series.processedXData = groupedXData;
      series.processedYData = groupedYData;
    } else {
      series.groupMap = null;
    }
    series.hasGroupedData = hasGroupedData;
    series.currentDataGrouping = currentDataGrouping;
    series.preventGraphAnimation = (lastDataGrouping && lastDataGrouping.totalRange) !== (currentDataGrouping && currentDataGrouping.totalRange);
  }
};
var skipDataGrouping = function(series) {
  if (series.isCartesian && !series.isDirty && !series.xAxis.isDirty && !series.yAxis.isDirty) {
    return false;
  }
};
var groupData = function(xData, yData, groupPositions, approximation) {
  var series = this, data = series.data, dataOptions = series.options && series.options.data, groupedXData = [], groupedYData = [], groupMap = [], dataLength = xData.length, pointX, pointY, groupedY, handleYData = !!yData, values = [], approximationFn, pointArrayMap = series.pointArrayMap, pointArrayMapLength = pointArrayMap && pointArrayMap.length, extendedPointArrayMap = ["x"].concat(pointArrayMap || ["y"]), groupAll = this.options.dataGrouping && this.options.dataGrouping.groupAll, pos = 0, start = 0, valuesLen, i, j;
  function getApproximation(approx) {
    if (typeof approx === "function") {
      return approx;
    }
    if (approximations[approx]) {
      return approximations[approx];
    }
    return approximations[series.getDGApproximation && series.getDGApproximation() || "average"];
  }
  approximationFn = getApproximation(approximation);
  if (pointArrayMapLength) {
    pointArrayMap.forEach(function() {
      values.push([]);
    });
  } else {
    values.push([]);
  }
  valuesLen = pointArrayMapLength || 1;
  for (i = 0; i <= dataLength; i++) {
    if (xData[i] >= groupPositions[0]) {
      break;
    }
  }
  for (i; i <= dataLength; i++) {
    while (typeof groupPositions[pos + 1] !== "undefined" && xData[i] >= groupPositions[pos + 1] || i === dataLength) {
      pointX = groupPositions[pos];
      series.dataGroupInfo = {
        start: groupAll ? start : series.cropStart + start,
        length: values[0].length
      };
      groupedY = approximationFn.apply(series, values);
      if (series.pointClass && !defined25(series.dataGroupInfo.options)) {
        series.dataGroupInfo.options = merge32(series.pointClass.prototype.optionsToObject.call({ series }, series.options.data[series.cropStart + start]));
        extendedPointArrayMap.forEach(function(key) {
          delete series.dataGroupInfo.options[key];
        });
      }
      if (typeof groupedY !== "undefined") {
        groupedXData.push(pointX);
        groupedYData.push(groupedY);
        groupMap.push(series.dataGroupInfo);
      }
      start = i;
      for (j = 0; j < valuesLen; j++) {
        values[j].length = 0;
        values[j].hasNulls = false;
      }
      pos += 1;
      if (i === dataLength) {
        break;
      }
    }
    if (i === dataLength) {
      break;
    }
    if (pointArrayMap) {
      var index = series.options.dataGrouping && series.options.dataGrouping.groupAll ? i : series.cropStart + i, point = data && data[index] || series.pointClass.prototype.applyOptions.apply({
        series
      }, [dataOptions[index]]), val = void 0;
      for (j = 0; j < pointArrayMapLength; j++) {
        val = point[pointArrayMap[j]];
        if (isNumber26(val)) {
          values[j].push(val);
        } else if (val === null) {
          values[j].hasNulls = true;
        }
      }
    } else {
      pointY = handleYData ? yData[i] : null;
      if (isNumber26(pointY)) {
        values[0].push(pointY);
      } else if (pointY === null) {
        values[0].hasNulls = true;
      }
    }
  }
  return {
    groupedXData,
    groupedYData,
    groupMap
  };
};
var anchorPoints = function(series, groupedXData, xMax) {
  var options = series.options, dataGroupingOptions = options.dataGrouping, totalRange = series.currentDataGrouping && series.currentDataGrouping.gapSize;
  var i;
  if (dataGroupingOptions && series.xData && totalRange && series.groupMap) {
    var groupedDataLength = groupedXData.length - 1, anchor = dataGroupingOptions.anchor, firstAnchor = pick39(dataGroupingOptions.firstAnchor, anchor), lastAnchor = pick39(dataGroupingOptions.lastAnchor, anchor);
    if (anchor && anchor !== "start") {
      var shiftInterval = totalRange * { middle: 0.5, end: 1 }[anchor];
      i = groupedXData.length - 1;
      while (i-- && i > 0) {
        groupedXData[i] += shiftInterval;
      }
    }
    if (firstAnchor && firstAnchor !== "start" && series.xData[0] >= groupedXData[0]) {
      var groupStart = series.groupMap[0].start, groupLength = series.groupMap[0].length;
      var firstGroupstEnd = void 0;
      if (isNumber26(groupStart) && isNumber26(groupLength)) {
        firstGroupstEnd = groupStart + (groupLength - 1);
      }
      groupedXData[0] = {
        middle: groupedXData[0] + 0.5 * totalRange,
        end: groupedXData[0] + totalRange,
        firstPoint: series.xData[0],
        lastPoint: firstGroupstEnd && series.xData[firstGroupstEnd]
      }[firstAnchor];
    }
    if (lastAnchor && lastAnchor !== "start" && totalRange && groupedXData[groupedDataLength] >= xMax - totalRange) {
      var lastGroupStart = series.groupMap[series.groupMap.length - 1].start;
      groupedXData[groupedDataLength] = {
        middle: groupedXData[groupedDataLength] + 0.5 * totalRange,
        end: groupedXData[groupedDataLength] + totalRange,
        firstPoint: lastGroupStart && series.xData[lastGroupStart],
        lastPoint: series.xData[series.xData.length - 1]
      }[lastAnchor];
    }
  }
};
var adjustExtremes = function(xAxis, groupedXData) {
  if (defined25(groupedXData[0]) && isNumber26(xAxis.min) && isNumber26(xAxis.dataMin) && groupedXData[0] < xAxis.min) {
    if (!defined25(xAxis.options.min) && xAxis.min <= xAxis.dataMin || xAxis.min === xAxis.dataMin) {
      xAxis.min = Math.min(groupedXData[0], xAxis.min);
    }
    xAxis.dataMin = Math.min(groupedXData[0], xAxis.dataMin);
  }
  if (defined25(groupedXData[groupedXData.length - 1]) && isNumber26(xAxis.max) && isNumber26(xAxis.dataMax) && groupedXData[groupedXData.length - 1] > xAxis.max) {
    if (!defined25(xAxis.options.max) && isNumber26(xAxis.dataMax) && xAxis.max >= xAxis.dataMax || xAxis.max === xAxis.dataMax) {
      xAxis.max = Math.max(groupedXData[groupedXData.length - 1], xAxis.max);
    }
    xAxis.dataMax = Math.max(groupedXData[groupedXData.length - 1], xAxis.dataMax);
  }
};
var dataGrouping = {
  approximations,
  groupData
};
var baseProcessData = seriesProto.processData;
var baseGeneratePoints = seriesProto.generatePoints;
var commonOptions = {
  // enabled: null, // (true for stock charts, false for basic),
  // forced: undefined,
  groupPixelWidth: 2,
  // the first one is the point or start value, the second is the start
  // value if we're dealing with range, the third one is the end value if
  // dealing with a range
  dateTimeLabelFormats: {
    millisecond: [
      "%A, %b %e, %H:%M:%S.%L",
      "%A, %b %e, %H:%M:%S.%L",
      "-%H:%M:%S.%L"
    ],
    second: [
      "%A, %b %e, %H:%M:%S",
      "%A, %b %e, %H:%M:%S",
      "-%H:%M:%S"
    ],
    minute: [
      "%A, %b %e, %H:%M",
      "%A, %b %e, %H:%M",
      "-%H:%M"
    ],
    hour: [
      "%A, %b %e, %H:%M",
      "%A, %b %e, %H:%M",
      "-%H:%M"
    ],
    day: [
      "%A, %b %e, %Y",
      "%A, %b %e",
      "-%A, %b %e, %Y"
    ],
    week: [
      "Week from %A, %b %e, %Y",
      "%A, %b %e",
      "-%A, %b %e, %Y"
    ],
    month: [
      "%B %Y",
      "%B",
      "-%B %Y"
    ],
    year: [
      "%Y",
      "%Y",
      "-%Y"
    ]
  }
  // smoothed = false, // enable this for navigator series only
};
var specificOptions = {
  line: {},
  spline: {},
  area: {},
  areaspline: {},
  arearange: {},
  column: {
    groupPixelWidth: 10
  },
  columnrange: {
    groupPixelWidth: 10
  },
  candlestick: {
    groupPixelWidth: 10
  },
  ohlc: {
    groupPixelWidth: 5
  },
  // Move to HeikinAshiSeries.ts aftre refactoring data grouping.
  heikinashi: {
    groupPixelWidth: 10
  }
};
var defaultDataGroupingUnits = Globals_default.defaultDataGroupingUnits = [
  [
    "millisecond",
    [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
    // allowed multiples
  ],
  [
    "second",
    [1, 2, 5, 10, 15, 30]
  ],
  [
    "minute",
    [1, 2, 5, 10, 15, 30]
  ],
  [
    "hour",
    [1, 2, 3, 4, 6, 8, 12]
  ],
  [
    "day",
    [1]
  ],
  [
    "week",
    [1]
  ],
  [
    "month",
    [1, 3, 6]
  ],
  [
    "year",
    null
  ]
];
seriesProto.getDGApproximation = function() {
  if (this.is("arearange")) {
    return "range";
  }
  if (this.is("ohlc")) {
    return "ohlc";
  }
  if (this.is("column")) {
    return "sum";
  }
  return "average";
};
seriesProto.groupData = groupData;
seriesProto.applyGrouping = applyGrouping;
seriesProto.destroyGroupedData = function() {
  if (this.groupedData) {
    this.groupedData.forEach(function(point, i) {
      if (point) {
        this.groupedData[i] = point.destroy ? point.destroy() : null;
      }
    }, this);
    this.groupedData.length = 0;
  }
};
seriesProto.generatePoints = function() {
  baseGeneratePoints.apply(this);
  this.destroyGroupedData();
  this.groupedData = this.hasGroupedData ? this.points : null;
};
Axis_default.prototype.applyGrouping = function() {
  var axis = this, series = axis.series;
  series.forEach(function(series2) {
    series2.groupPixelWidth = void 0;
    series2.groupPixelWidth = axis.getGroupPixelWidth && axis.getGroupPixelWidth();
    if (series2.groupPixelWidth) {
      series2.hasProcessed = true;
    }
    series2.applyGrouping();
  });
};
Axis_default.prototype.getGroupPixelWidth = function() {
  var series = this.series, len = series.length, i, groupPixelWidth = 0, doGrouping = false, dataLength, dgOptions;
  i = len;
  while (i--) {
    dgOptions = series[i].options.dataGrouping;
    if (dgOptions) {
      groupPixelWidth = Math.max(
        groupPixelWidth,
        // Fallback to commonOptions (#9693)
        pick39(dgOptions.groupPixelWidth, commonOptions.groupPixelWidth)
      );
    }
  }
  i = len;
  while (i--) {
    dgOptions = series[i].options.dataGrouping;
    if (dgOptions) {
      dataLength = (series[i].processedXData || series[i].data).length;
      if (series[i].groupPixelWidth || dataLength > this.chart.plotSizeX / groupPixelWidth || dataLength && dgOptions.forced) {
        doGrouping = true;
      }
    }
  }
  return doGrouping ? groupPixelWidth : 0;
};
Axis_default.prototype.setDataGrouping = function(dataGrouping2, redraw) {
  var axis = this;
  var i;
  redraw = pick39(redraw, true);
  if (!dataGrouping2) {
    dataGrouping2 = {
      forced: false,
      units: null
    };
  }
  if (this instanceof Axis_default) {
    i = this.series.length;
    while (i--) {
      this.series[i].update({
        dataGrouping: dataGrouping2
      }, false);
    }
  } else {
    this.chart.options.series.forEach(function(seriesOptions) {
      seriesOptions.dataGrouping = dataGrouping2;
    }, false);
  }
  if (axis.ordinal) {
    axis.ordinal.slope = void 0;
  }
  if (redraw) {
    this.chart.redraw();
  }
};
addEvent21(Axis_default, "postProcessData", Axis_default.prototype.applyGrouping);
addEvent21(Point_default, "update", function() {
  if (this.dataGroup) {
    error9(24, false, this.series.chart);
    return false;
  }
});
addEvent21(Tooltip_default, "headerFormatter", function(e2) {
  var tooltip = this, chart = this.chart, time = chart.time, labelConfig = e2.labelConfig, series = labelConfig.series, options = series.options, tooltipOptions = series.tooltipOptions, dataGroupingOptions = options.dataGrouping, xDateFormat = tooltipOptions.xDateFormat, xDateFormatEnd, xAxis = series.xAxis, currentDataGrouping, dateTimeLabelFormats, labelFormats, formattedKey, formatString = tooltipOptions[e2.isFooter ? "footerFormat" : "headerFormat"];
  if (xAxis && xAxis.options.type === "datetime" && dataGroupingOptions && isNumber26(labelConfig.key)) {
    currentDataGrouping = series.currentDataGrouping;
    dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats || // Fallback to commonOptions (#9693)
    commonOptions.dateTimeLabelFormats;
    if (currentDataGrouping) {
      labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
      if (currentDataGrouping.count === 1) {
        xDateFormat = labelFormats[0];
      } else {
        xDateFormat = labelFormats[1];
        xDateFormatEnd = labelFormats[2];
      }
    } else if (!xDateFormat && dateTimeLabelFormats && xAxis.dateTime) {
      xDateFormat = xAxis.dateTime.getXDateFormat(labelConfig.x, tooltipOptions.dateTimeLabelFormats);
    }
    formattedKey = time.dateFormat(xDateFormat, labelConfig.key);
    if (xDateFormatEnd) {
      formattedKey += time.dateFormat(xDateFormatEnd, labelConfig.key + currentDataGrouping.totalRange - 1);
    }
    if (series.chart.styledMode) {
      formatString = this.styledModeFormat(formatString);
    }
    e2.text = format7(formatString, {
      point: extend25(labelConfig.point, { key: formattedKey }),
      series
    }, chart);
    e2.preventDefault();
  }
});
addEvent21(Series_default, "destroy", seriesProto.destroyGroupedData);
addEvent21(Series_default, "afterSetOptions", function(e2) {
  var options = e2.options, type = this.type, plotOptions = this.chart.options.plotOptions, defaultOptions17 = DefaultOptions_default.defaultOptions.plotOptions[type].dataGrouping, baseOptions = this.useCommonDataGrouping && commonOptions;
  if (specificOptions[type] || baseOptions) {
    if (!defaultOptions17) {
      defaultOptions17 = merge32(commonOptions, specificOptions[type]);
    }
    var rangeSelector = this.chart.rangeSelector;
    options.dataGrouping = merge32(
      baseOptions,
      defaultOptions17,
      plotOptions.series && plotOptions.series.dataGrouping,
      // #1228
      // Set by the StockChart constructor:
      plotOptions[type].dataGrouping,
      this.userOptions.dataGrouping,
      !options.isInternal && rangeSelector && isNumber26(rangeSelector.selected) && rangeSelector.buttonOptions[rangeSelector.selected].dataGrouping
    );
  }
});
addEvent21(Axis_default, "afterSetScale", function() {
  this.series.forEach(function(series) {
    series.hasProcessed = false;
  });
});
Globals_default.dataGrouping = dataGrouping;

// node_modules/highcharts/es-modules/Series/OHLC/OHLCPoint.js
var __extends14 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries2 = SeriesRegistry_default.seriesTypes.column;
var OHLCPoint = (
  /** @class */
  function(_super) {
    __extends14(OHLCPoint2, _super);
    function OHLCPoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.close = void 0;
      _this.high = void 0;
      _this.low = void 0;
      _this.open = void 0;
      _this.options = void 0;
      _this.plotClose = void 0;
      _this.plotOpen = void 0;
      _this.series = void 0;
      return _this;
    }
    OHLCPoint2.prototype.getClassName = function() {
      return _super.prototype.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
    };
    OHLCPoint2.prototype.resolveUpColor = function() {
      if (this.open < this.close && !this.options.color && this.series.options.upColor) {
        this.color = this.series.options.upColor;
      }
    };
    OHLCPoint2.prototype.resolveColor = function() {
      _super.prototype.resolveColor.call(this);
      this.resolveUpColor();
    };
    OHLCPoint2.prototype.getZone = function() {
      var zone = _super.prototype.getZone.call(this);
      this.resolveUpColor();
      return zone;
    };
    OHLCPoint2.prototype.applyOptions = function() {
      _super.prototype.applyOptions.apply(this, arguments);
      if (this.resolveColor) {
        this.resolveColor();
      }
      return this;
    };
    return OHLCPoint2;
  }(ColumnSeries2.prototype.pointClass)
);
var OHLCPoint_default = OHLCPoint;

// node_modules/highcharts/es-modules/Series/OHLC/OHLCSeries.js
var __extends15 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries3 = SeriesRegistry_default.seriesTypes.column;
var extend26 = Utilities_default.extend;
var merge33 = Utilities_default.merge;
var OHLCSeries = (
  /** @class */
  function(_super) {
    __extends15(OHLCSeries3, _super);
    function OHLCSeries3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.yData = void 0;
      return _this;
    }
    OHLCSeries3.prototype.drawPoints = function() {
      var series = this, points = series.points, chart = series.chart, extendStem = function(path, halfStrokeWidth, openOrClose) {
        var start = path[0];
        var end = path[1];
        if (typeof start[2] === "number") {
          start[2] = Math.max(openOrClose + halfStrokeWidth, start[2]);
        }
        if (typeof end[2] === "number") {
          end[2] = Math.min(openOrClose - halfStrokeWidth, end[2]);
        }
      };
      points.forEach(function(point) {
        var plotOpen, plotClose, crispCorr, halfWidth, path, graphic = point.graphic, crispX, isNew = !graphic, strokeWidth;
        if (typeof point.plotY !== "undefined") {
          if (!graphic) {
            point.graphic = graphic = chart.renderer.path().add(series.group);
          }
          if (!chart.styledMode) {
            graphic.attr(series.pointAttribs(point, point.selected && "select"));
          }
          strokeWidth = graphic.strokeWidth();
          crispCorr = strokeWidth % 2 / 2;
          crispX = Math.round(point.plotX) - crispCorr;
          halfWidth = Math.round(point.shapeArgs.width / 2);
          path = [
            ["M", crispX, Math.round(point.yBottom)],
            ["L", crispX, Math.round(point.plotHigh)]
          ];
          if (point.open !== null) {
            plotOpen = Math.round(point.plotOpen) + crispCorr;
            path.push(["M", crispX, plotOpen], ["L", crispX - halfWidth, plotOpen]);
            extendStem(path, strokeWidth / 2, plotOpen);
          }
          if (point.close !== null) {
            plotClose = Math.round(point.plotClose) + crispCorr;
            path.push(["M", crispX, plotClose], ["L", crispX + halfWidth, plotClose]);
            extendStem(path, strokeWidth / 2, plotClose);
          }
          graphic[isNew ? "attr" : "animate"]({ d: path }).addClass(point.getClassName(), true);
        }
      });
    };
    OHLCSeries3.prototype.init = function() {
      _super.prototype.init.apply(this, arguments);
      this.options.stacking = void 0;
    };
    OHLCSeries3.prototype.pointAttribs = function(point, state) {
      var attribs = _super.prototype.pointAttribs.call(this, point, state), options = this.options;
      delete attribs.fill;
      if (!point.options.color && options.upColor && point.open < point.close) {
        attribs.stroke = options.upColor;
      }
      return attribs;
    };
    OHLCSeries3.prototype.toYData = function(point) {
      return [point.open, point.high, point.low, point.close];
    };
    OHLCSeries3.prototype.translate = function() {
      var series = this, yAxis = series.yAxis, hasModifyValue = !!series.modifyValue, translated = [
        "plotOpen",
        "plotHigh",
        "plotLow",
        "plotClose",
        "yBottom"
      ];
      _super.prototype.translate.apply(series);
      series.points.forEach(function(point) {
        [point.open, point.high, point.low, point.close, point.low].forEach(function(value, i) {
          if (value !== null) {
            if (hasModifyValue) {
              value = series.modifyValue(value);
            }
            point[translated[i]] = yAxis.toPixels(value, true);
          }
        });
        point.tooltipPos[1] = point.plotHigh + yAxis.pos - series.chart.plotTop;
      });
    };
    OHLCSeries3.defaultOptions = merge33(ColumnSeries3.defaultOptions, {
      /**
       * The approximate pixel width of each group. If for example a series
       * with 30 points is displayed over a 600 pixel wide plot area, no
       * grouping is performed. If however the series contains so many points
       * that the spacing is less than the groupPixelWidth, Highcharts will
       * try to group it into appropriate groups so that each is more or less
       * two pixels wide. Defaults to `5`.
       *
       * @type      {number}
       * @default   5
       * @product   highstock
       * @apioption plotOptions.ohlc.dataGrouping.groupPixelWidth
       */
      /**
       * The pixel width of the line/border. Defaults to `1`.
       *
       * @sample {highstock} stock/plotoptions/ohlc-linewidth/
       *         A greater line width
       *
       * @type    {number}
       * @default 1
       * @product highstock
       *
       * @private
       */
      lineWidth: 1,
      tooltip: {
        pointFormat: '<span style="color:{point.color}"></span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'
      },
      threshold: null,
      states: {
        /**
         * @extends plotOptions.column.states.hover
         * @product highstock
         */
        hover: {
          /**
           * The pixel width of the line representing the OHLC point.
           *
           * @type    {number}
           * @default 3
           * @product highstock
           */
          lineWidth: 3
        }
      },
      /**
       * Determines which one of `open`, `high`, `low`, `close` values should
       * be represented as `point.y`, which is later used to set dataLabel
       * position and [compare](#plotOptions.series.compare).
       *
       * @sample {highstock} stock/plotoptions/ohlc-pointvalkey/
       *         Possible values
       *
       * @type       {string}
       * @default    close
       * @validvalue ["open", "high", "low", "close"]
       * @product    highstock
       * @apioption  plotOptions.ohlc.pointValKey
       */
      /**
       * @default   close
       * @apioption plotOptions.ohlc.colorKey
       */
      /**
       * Line color for up points.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product   highstock
       * @apioption plotOptions.ohlc.upColor
       */
      stickyTracking: true
    });
    return OHLCSeries3;
  }(ColumnSeries3)
);
extend26(OHLCSeries.prototype, {
  animate: null,
  directTouch: false,
  pointArrayMap: ["open", "high", "low", "close"],
  pointAttrToOptions: {
    stroke: "color",
    "stroke-width": "lineWidth"
  },
  pointValKey: "close"
});
OHLCSeries.prototype.pointClass = OHLCPoint_default;
SeriesRegistry_default.registerSeriesType("ohlc", OHLCSeries);

// node_modules/highcharts/es-modules/Series/Candlestick/CandlestickSeries.js
var __extends16 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var defaultOptions8 = DefaultOptions_default.defaultOptions;
var _a = SeriesRegistry_default.seriesTypes;
var ColumnSeries4 = _a.column;
var OHLCSeries2 = _a.ohlc;
var merge34 = Utilities_default.merge;
var CandlestickSeries = (
  /** @class */
  function(_super) {
    __extends16(CandlestickSeries2, _super);
    function CandlestickSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    CandlestickSeries2.prototype.pointAttribs = function(point, state) {
      var attribs = ColumnSeries4.prototype.pointAttribs.call(this, point, state), options = this.options, isUp = point.open < point.close, stroke = options.lineColor || this.color, color18 = point.color || this.color, stateOptions;
      attribs["stroke-width"] = options.lineWidth;
      attribs.fill = point.options.color || (isUp ? options.upColor || color18 : color18);
      attribs.stroke = point.options.lineColor || (isUp ? options.upLineColor || stroke : stroke);
      if (state) {
        stateOptions = options.states[state];
        attribs.fill = stateOptions.color || attribs.fill;
        attribs.stroke = stateOptions.lineColor || attribs.stroke;
        attribs["stroke-width"] = stateOptions.lineWidth || attribs["stroke-width"];
      }
      return attribs;
    };
    CandlestickSeries2.prototype.drawPoints = function() {
      var series = this, points = series.points, chart = series.chart, reversedYAxis = series.yAxis.reversed;
      points.forEach(function(point) {
        var graphic = point.graphic, plotOpen, plotClose, topBox, bottomBox, hasTopWhisker, hasBottomWhisker, crispCorr, crispX, path, halfWidth, isNew = !graphic;
        if (typeof point.plotY !== "undefined") {
          if (!graphic) {
            point.graphic = graphic = chart.renderer.path().add(series.group);
          }
          if (!series.chart.styledMode) {
            graphic.attr(series.pointAttribs(point, point.selected && "select")).shadow(series.options.shadow);
          }
          crispCorr = graphic.strokeWidth() % 2 / 2;
          crispX = Math.round(point.plotX) - crispCorr;
          plotOpen = point.plotOpen;
          plotClose = point.plotClose;
          topBox = Math.min(plotOpen, plotClose);
          bottomBox = Math.max(plotOpen, plotClose);
          halfWidth = Math.round(point.shapeArgs.width / 2);
          hasTopWhisker = reversedYAxis ? bottomBox !== point.yBottom : Math.round(topBox) !== Math.round(point.plotHigh);
          hasBottomWhisker = reversedYAxis ? Math.round(topBox) !== Math.round(point.plotHigh) : bottomBox !== point.yBottom;
          topBox = Math.round(topBox) + crispCorr;
          bottomBox = Math.round(bottomBox) + crispCorr;
          path = [];
          path.push(
            ["M", crispX - halfWidth, bottomBox],
            ["L", crispX - halfWidth, topBox],
            ["L", crispX + halfWidth, topBox],
            ["L", crispX + halfWidth, bottomBox],
            ["Z"],
            // Ensure a nice rectangle #2602
            ["M", crispX, topBox],
            [
              "L",
              // #460, #2094
              crispX,
              hasTopWhisker ? Math.round(reversedYAxis ? point.yBottom : point.plotHigh) : topBox
            ],
            ["M", crispX, bottomBox],
            [
              "L",
              // #460, #2094
              crispX,
              hasBottomWhisker ? Math.round(reversedYAxis ? point.plotHigh : point.yBottom) : bottomBox
            ]
          );
          graphic[isNew ? "attr" : "animate"]({ d: path }).addClass(point.getClassName(), true);
        }
      });
    };
    CandlestickSeries2.defaultOptions = merge34(OHLCSeries2.defaultOptions, defaultOptions8.plotOptions, {
      /**
       * The specific line color for up candle sticks. The default is to
       * inherit the general `lineColor` setting.
       *
       * @sample {highstock} stock/plotoptions/candlestick-linecolor/
       *         Candlestick line colors
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     1.3.6
       * @product   highstock
       * @apioption plotOptions.candlestick.upLineColor
       */
      /**
       * @type      {Highcharts.DataGroupingApproximationValue|Function}
       * @default   ohlc
       * @product   highstock
       * @apioption plotOptions.candlestick.dataGrouping.approximation
       */
      states: {
        /**
         * @extends plotOptions.column.states.hover
         * @product highstock
         */
        hover: {
          /**
           * The pixel width of the line/border around the candlestick.
           *
           * @product highstock
           */
          lineWidth: 2
        }
      },
      /**
       * @extends plotOptions.ohlc.tooltip
       */
      tooltip: defaultOptions8.plotOptions.ohlc.tooltip,
      /**
       * @type    {number|null}
       * @product highstock
       */
      threshold: null,
      /**
       * The color of the line/border of the candlestick.
       *
       * In styled mode, the line stroke can be set with the
       * `.highcharts-candlestick-series .highcahrts-point` rule.
       *
       * @see [upLineColor](#plotOptions.candlestick.upLineColor)
       *
       * @sample {highstock} stock/plotoptions/candlestick-linecolor/
       *         Candlestick line colors
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default #000000
       * @product highstock
       */
      lineColor: Palette_default.neutralColor100,
      /**
       * The pixel width of the candlestick line/border. Defaults to `1`.
       *
       *
       * In styled mode, the line stroke width can be set with the
       * `.highcharts-candlestick-series .highcahrts-point` rule.
       *
       * @product highstock
       */
      lineWidth: 1,
      /**
       * The fill color of the candlestick when values are rising.
       *
       * In styled mode, the up color can be set with the
       * `.highcharts-candlestick-series .highcharts-point-up` rule.
       *
       * @sample {highstock} stock/plotoptions/candlestick-color/
       *         Custom colors
       * @sample {highstock} highcharts/css/candlestick/
       *         Colors in styled mode
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default #ffffff
       * @product highstock
       */
      upColor: Palette_default.backgroundColor,
      /**
       * @product highstock
       */
      stickyTracking: true
    });
    return CandlestickSeries2;
  }(OHLCSeries2)
);
SeriesRegistry_default.registerSeriesType("candlestick", CandlestickSeries);

// node_modules/highcharts/es-modules/Series/Flags/FlagsPoint.js
var __extends17 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries5 = SeriesRegistry_default.seriesTypes.column;
var isNumber27 = Utilities_default.isNumber;
var FlagsPoint = (
  /** @class */
  function(_super) {
    __extends17(FlagsPoint2, _super);
    function FlagsPoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.series = void 0;
      return _this;
    }
    FlagsPoint2.prototype.isValid = function() {
      return isNumber27(this.y) || typeof this.y === "undefined";
    };
    FlagsPoint2.prototype.hasNewShapeType = function() {
      var shape = this.options.shape || this.series.options.shape;
      return this.graphic && shape && shape !== this.graphic.symbolKey;
    };
    return FlagsPoint2;
  }(ColumnSeries5.prototype.pointClass)
);
var FlagsPoint_default = FlagsPoint;

// node_modules/highcharts/es-modules/Mixins/OnSeries.js
var columnProto = ColumnSeries_default.prototype;
var seriesProto2 = Series_default.prototype;
var defined26 = Utilities_default.defined;
var stableSort4 = Utilities_default.stableSort;
var onSeriesMixin = {
  /* eslint-disable valid-jsdoc */
  /**
   * Override getPlotBox. If the onSeries option is valid, return the plot box
   * of the onSeries, otherwise proceed as usual.
   *
   * @private
   * @function onSeriesMixin.getPlotBox
   * @return {Highcharts.SeriesPlotBoxObject}
   */
  getPlotBox: function() {
    return seriesProto2.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);
  },
  /**
   * Extend the translate method by placing the point on the related series
   *
   * @private
   * @function onSeriesMixin.translate
   * @return {void}
   */
  translate: function() {
    columnProto.translate.apply(this);
    var series = this, options = series.options, chart = series.chart, points = series.points, cursor = points.length - 1, point, lastPoint, optionsOnSeries = options.onSeries, onSeries = optionsOnSeries && chart.get(optionsOnSeries), onKey = options.onKey || "y", step = onSeries && onSeries.options.step, onData = onSeries && onSeries.points, i = onData && onData.length, inverted = chart.inverted, xAxis = series.xAxis, yAxis = series.yAxis, xOffset = 0, leftPoint, lastX, rightPoint, currentDataGrouping, distanceRatio;
    if (onSeries && onSeries.visible && i) {
      xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;
      currentDataGrouping = onSeries.currentDataGrouping;
      lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0);
      stableSort4(points, function(a, b) {
        return a.x - b.x;
      });
      onKey = "plot" + onKey[0].toUpperCase() + onKey.substr(1);
      while (i-- && points[cursor]) {
        leftPoint = onData[i];
        point = points[cursor];
        point.y = leftPoint.y;
        if (leftPoint.x <= point.x && typeof leftPoint[onKey] !== "undefined") {
          if (point.x <= lastX) {
            point.plotY = leftPoint[onKey];
            if (leftPoint.x < point.x && !step) {
              rightPoint = onData[i + 1];
              if (rightPoint && typeof rightPoint[onKey] !== "undefined") {
                distanceRatio = (point.x - leftPoint.x) / (rightPoint.x - leftPoint.x);
                point.plotY += distanceRatio * // the plotY distance
                (rightPoint[onKey] - leftPoint[onKey]);
                point.y += distanceRatio * (rightPoint.y - leftPoint.y);
              }
            }
          }
          cursor--;
          i++;
          if (cursor < 0) {
            break;
          }
        }
      }
    }
    points.forEach(function(point2, i2) {
      var stackIndex;
      point2.plotX += xOffset;
      if (typeof point2.plotY === "undefined" || inverted) {
        if (point2.plotX >= 0 && point2.plotX <= xAxis.len) {
          if (inverted) {
            point2.plotY = xAxis.translate(point2.x, 0, 1, 0, 1);
            point2.plotX = defined26(point2.y) ? yAxis.translate(point2.y, 0, 0, 0, 1) : 0;
          } else {
            point2.plotY = (xAxis.opposite ? 0 : series.yAxis.len) + xAxis.offset;
          }
        } else {
          point2.shapeArgs = {};
        }
      }
      lastPoint = points[i2 - 1];
      if (lastPoint && lastPoint.plotX === point2.plotX) {
        if (typeof lastPoint.stackIndex === "undefined") {
          lastPoint.stackIndex = 0;
        }
        stackIndex = lastPoint.stackIndex + 1;
      }
      point2.stackIndex = stackIndex;
    });
    this.onSeries = onSeries;
  }
  /* eslint-enable valid-jsdoc */
};
var OnSeries_default = onSeriesMixin;

// node_modules/highcharts/es-modules/Series/Flags/FlagsSymbols.js
var symbols = SVGRenderer_default.prototype.symbols;
symbols.flag = function(x, y, w2, h, options) {
  var anchorX = options && options.anchorX || x, anchorY = options && options.anchorY || y;
  var path = symbols.circle(anchorX - 1, anchorY - 1, 2, 2);
  path.push(["M", anchorX, anchorY], ["L", x, y + h], ["L", x, y], ["L", x + w2, y], ["L", x + w2, y + h], ["L", x, y + h], ["Z"]);
  return path;
};
function createPinSymbol(shape) {
  symbols[shape + "pin"] = function(x, y, w2, h, options) {
    var anchorX = options && options.anchorX, anchorY = options && options.anchorY;
    var path;
    if (shape === "circle" && h > w2) {
      x -= Math.round((h - w2) / 2);
      w2 = h;
    }
    path = symbols[shape](x, y, w2, h);
    if (anchorX && anchorY) {
      var labelX = anchorX;
      if (shape === "circle") {
        labelX = x + w2 / 2;
      } else {
        var startSeg = path[0];
        var endSeg = path[1];
        if (startSeg[0] === "M" && endSeg[0] === "L") {
          labelX = (startSeg[1] + endSeg[1]) / 2;
        }
      }
      var labelY = y > anchorY ? y : y + h;
      path.push([
        "M",
        labelX,
        labelY
      ], [
        "L",
        anchorX,
        anchorY
      ]);
      path = path.concat(symbols.circle(anchorX - 1, anchorY - 1, 2, 2));
    }
    return path;
  };
}
createPinSymbol("circle");
createPinSymbol("square");
var Renderer = RendererRegistry_default.getRendererType();
if (Renderer !== SVGRenderer_default) {
  Renderer.prototype.symbols.circlepin = symbols.circlepin;
  Renderer.prototype.symbols.flag = symbols.flag;
  Renderer.prototype.symbols.squarepin = symbols.squarepin;
}

// node_modules/highcharts/es-modules/Series/Flags/FlagsSeries.js
var __extends18 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop8 = Globals_default.noop;
var distribute4 = RendererUtilities_default.distribute;
var Series4 = SeriesRegistry_default.series;
var ColumnSeries6 = SeriesRegistry_default.seriesTypes.column;
var addEvent22 = Utilities_default.addEvent;
var defined27 = Utilities_default.defined;
var extend27 = Utilities_default.extend;
var merge35 = Utilities_default.merge;
var objectEach24 = Utilities_default.objectEach;
var wrap3 = Utilities_default.wrap;
var FlagsSeries = (
  /** @class */
  function(_super) {
    __extends18(FlagsSeries2, _super);
    function FlagsSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    FlagsSeries2.prototype.animate = function(init) {
      if (init) {
        this.setClip();
      }
    };
    FlagsSeries2.prototype.drawPoints = function() {
      var series = this, points = series.points, chart = series.chart, renderer = chart.renderer, plotX, plotY, inverted = chart.inverted, options = series.options, optionsY = options.y, shape, i, point, graphic, stackIndex, anchorY, attribs, outsideRight, yAxis = series.yAxis, boxesMap = {}, boxes = [], centered;
      i = points.length;
      while (i--) {
        point = points[i];
        outsideRight = (inverted ? point.plotY : point.plotX) > series.xAxis.len;
        plotX = point.plotX;
        stackIndex = point.stackIndex;
        shape = point.options.shape || options.shape;
        plotY = point.plotY;
        if (typeof plotY !== "undefined") {
          plotY = point.plotY + optionsY - (typeof stackIndex !== "undefined" && stackIndex * options.stackDistance);
        }
        point.anchorX = stackIndex ? void 0 : point.plotX;
        anchorY = stackIndex ? void 0 : point.plotY;
        centered = shape !== "flag";
        graphic = point.graphic;
        if (typeof plotY !== "undefined" && plotX >= 0 && !outsideRight) {
          if (graphic && point.hasNewShapeType()) {
            graphic = graphic.destroy();
          }
          if (!graphic) {
            graphic = point.graphic = renderer.label("", null, null, shape, null, null, options.useHTML).addClass("highcharts-point").add(series.markerGroup);
            if (point.graphic.div) {
              point.graphic.div.point = point;
            }
            graphic.isNew = true;
          }
          graphic.attr({
            align: centered ? "center" : "left",
            width: options.width,
            height: options.height,
            "text-align": options.textAlign
          });
          if (!chart.styledMode) {
            graphic.attr(series.pointAttribs(point)).css(merge35(options.style, point.style)).shadow(options.shadow);
          }
          if (plotX > 0) {
            plotX -= graphic.strokeWidth() % 2;
          }
          attribs = {
            y: plotY,
            anchorY
          };
          if (options.allowOverlapX) {
            attribs.x = plotX;
            attribs.anchorX = point.anchorX;
          }
          graphic.attr({
            text: point.options.title || options.title || "A"
          })[graphic.isNew ? "attr" : "animate"](attribs);
          if (!options.allowOverlapX) {
            if (!boxesMap[point.plotX]) {
              boxesMap[point.plotX] = {
                align: centered ? 0.5 : 0,
                size: graphic.width,
                target: plotX,
                anchorX: plotX
              };
            } else {
              boxesMap[point.plotX].size = Math.max(boxesMap[point.plotX].size, graphic.width);
            }
          }
          point.tooltipPos = [
            plotX,
            plotY + yAxis.pos - chart.plotTop
          ];
        } else if (graphic) {
          point.graphic = graphic.destroy();
        }
      }
      if (!options.allowOverlapX) {
        objectEach24(boxesMap, function(box) {
          box.plotX = box.anchorX;
          boxes.push(box);
        });
        distribute4(boxes, inverted ? yAxis.len : this.xAxis.len, 100);
        points.forEach(function(point2) {
          var box = point2.graphic && boxesMap[point2.plotX];
          if (box) {
            point2.graphic[point2.graphic.isNew ? "attr" : "animate"]({
              x: box.pos + box.align * box.size,
              anchorX: point2.anchorX
            });
            if (!defined27(box.pos)) {
              point2.graphic.attr({
                x: -9999,
                anchorX: -9999
              });
              point2.graphic.isNew = true;
            } else {
              point2.graphic.isNew = false;
            }
          }
        });
      }
      if (options.useHTML) {
        wrap3(series.markerGroup, "on", function(proceed) {
          return SVGElement_default.prototype.on.apply(
            // for HTML
            // eslint-disable-next-line no-invalid-this
            proceed.apply(this, [].slice.call(arguments, 1)),
            // and for SVG
            [].slice.call(arguments, 1)
          );
        });
      }
    };
    FlagsSeries2.prototype.drawTracker = function() {
      var series = this, points = series.points;
      _super.prototype.drawTracker.call(this);
      points.forEach(function(point) {
        var graphic = point.graphic;
        if (graphic) {
          if (point.unbindMouseOver) {
            point.unbindMouseOver();
          }
          point.unbindMouseOver = addEvent22(graphic.element, "mouseover", function() {
            if (point.stackIndex > 0 && !point.raised) {
              point._y = graphic.y;
              graphic.attr({
                y: point._y - 8
              });
              point.raised = true;
            }
            points.forEach(function(otherPoint) {
              if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {
                otherPoint.graphic.attr({
                  y: otherPoint._y
                });
                otherPoint.raised = false;
              }
            });
          });
        }
      });
    };
    FlagsSeries2.prototype.pointAttribs = function(point, state) {
      var options = this.options, color18 = point && point.color || this.color, lineColor = options.lineColor, lineWidth = point && point.lineWidth, fill = point && point.fillColor || options.fillColor;
      if (state) {
        fill = options.states[state].fillColor;
        lineColor = options.states[state].lineColor;
        lineWidth = options.states[state].lineWidth;
      }
      return {
        fill: fill || color18,
        stroke: lineColor || color18,
        "stroke-width": lineWidth || options.lineWidth || 0
      };
    };
    FlagsSeries2.prototype.setClip = function() {
      Series4.prototype.setClip.apply(this, arguments);
      if (this.options.clip !== false && this.sharedClipKey && this.markerGroup) {
        this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);
      }
    };
    FlagsSeries2.defaultOptions = merge35(ColumnSeries6.defaultOptions, {
      /**
       * In case the flag is placed on a series, on what point key to place
       * it. Line and columns have one key, `y`. In range or OHLC-type series,
       * however, the flag can optionally be placed on the `open`, `high`,
       * `low` or `close` key.
       *
       * @sample {highstock} stock/plotoptions/flags-onkey/
       *         Range series, flag on high
       *
       * @type       {string}
       * @default    y
       * @since      4.2.2
       * @product    highstock
       * @validvalue ["y", "open", "high", "low", "close"]
       * @apioption  plotOptions.flags.onKey
       */
      /**
       * The id of the series that the flags should be drawn on. If no id
       * is given, the flags are drawn on the x axis.
       *
       * @sample {highstock} stock/plotoptions/flags/
       *         Flags on series and on x axis
       *
       * @type      {string}
       * @product   highstock
       * @apioption plotOptions.flags.onSeries
       */
      pointRange: 0,
      /**
       * Whether the flags are allowed to overlap sideways. If `false`, the
       * flags are moved sideways using an algorithm that seeks to place every
       * flag as close as possible to its original position.
       *
       * @sample {highstock} stock/plotoptions/flags-allowoverlapx
       *         Allow sideways overlap
       *
       * @since 6.0.4
       */
      allowOverlapX: false,
      /**
       * The shape of the marker. Can be one of "flag", "circlepin",
       * "squarepin", or an image of the format `url(/path-to-image.jpg)`.
       * Individual shapes can also be set for each point.
       *
       * @sample {highstock} stock/plotoptions/flags/
       *         Different shapes
       *
       * @type    {Highcharts.FlagsShapeValue}
       * @product highstock
       */
      shape: "flag",
      /**
       * When multiple flags in the same series fall on the same value, this
       * number determines the vertical offset between them.
       *
       * @sample {highstock} stock/plotoptions/flags-stackdistance/
       *         A greater stack distance
       *
       * @product highstock
       */
      stackDistance: 12,
      /**
       * Text alignment for the text inside the flag.
       *
       * @since      5.0.0
       * @product    highstock
       * @validvalue ["left", "center", "right"]
       */
      textAlign: "center",
      /**
       * Specific tooltip options for flag series. Flag series tooltips are
       * different from most other types in that a flag doesn't have a data
       * value, so the tooltip rather displays the `text` option for each
       * point.
       *
       * @extends   plotOptions.series.tooltip
       * @excluding changeDecimals, valueDecimals, valuePrefix, valueSuffix
       * @product   highstock
       */
      tooltip: {
        pointFormat: "{point.text}"
      },
      threshold: null,
      /**
       * The text to display on each flag. This can be defined on series
       * level, or individually for each point. Defaults to `"A"`.
       *
       * @type      {string}
       * @default   A
       * @product   highstock
       * @apioption plotOptions.flags.title
       */
      /**
       * The y position of the top left corner of the flag relative to either
       * the series (if onSeries is defined), or the x axis. Defaults to
       * `-30`.
       *
       * @product highstock
       */
      y: -30,
      /**
       * Whether to use HTML to render the flag texts. Using HTML allows for
       * advanced formatting, images and reliable bi-directional text
       * rendering. Note that exported images won't respect the HTML, and that
       * HTML won't respect Z-index settings.
       *
       * @type      {boolean}
       * @default   false
       * @since     1.3
       * @product   highstock
       * @apioption plotOptions.flags.useHTML
       */
      /**
       * Fixed width of the flag's shape. By default, width is autocalculated
       * according to the flag's title.
       *
       * @sample {highstock} stock/demo/flags-shapes/
       *         Flags with fixed width
       *
       * @type      {number}
       * @product   highstock
       * @apioption plotOptions.flags.width
       */
      /**
       * Fixed height of the flag's shape. By default, height is
       * autocalculated according to the flag's title.
       *
       * @type      {number}
       * @product   highstock
       * @apioption plotOptions.flags.height
       */
      /**
       * The fill color for the flags.
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product highstock
       */
      fillColor: Palette_default.backgroundColor,
      /**
       * The color of the line/border of the flag.
       *
       * In styled mode, the stroke is set in the
       * `.highcharts-flag-series.highcharts-point` rule.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   #000000
       * @product   highstock
       * @apioption plotOptions.flags.lineColor
       */
      /**
       * The pixel width of the flag's line/border.
       *
       * @product highstock
       */
      lineWidth: 1,
      states: {
        /**
         * @extends plotOptions.column.states.hover
         * @product highstock
         */
        hover: {
          /**
           * The color of the line/border of the flag.
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product highstock
           */
          lineColor: Palette_default.neutralColor100,
          /**
           * The fill or background color of the flag.
           *
           * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @product highstock
           */
          fillColor: Palette_default.highlightColor20
        }
      },
      /**
       * The text styles of the flag.
       *
       * In styled mode, the styles are set in the
       * `.highcharts-flag-series .highcharts-point` rule.
       *
       * @type    {Highcharts.CSSObject}
       * @default {"fontSize": "11px", "fontWeight": "bold"}
       * @product highstock
       */
      style: {
        /** @ignore-option */
        fontSize: "11px",
        /** @ignore-option */
        fontWeight: "bold"
      }
    });
    return FlagsSeries2;
  }(ColumnSeries6)
);
extend27(FlagsSeries.prototype, {
  allowDG: false,
  /**
   * @private
   * @function Highcharts.seriesTypes.flags#buildKDTree
   */
  buildKDTree: noop8,
  forceCrop: true,
  getPlotBox: OnSeries_default.getPlotBox,
  /**
   * Inherit the initialization from base Series.
   *
   * @private
   * @borrows Highcharts.Series#init as Highcharts.seriesTypes.flags#init
   */
  init: Series4.prototype.init,
  /**
   * Don't invert the flag marker group (#4960).
   *
   * @private
   * @function Highcharts.seriesTypes.flags#invertGroups
   */
  invertGroups: noop8,
  // Flags series group should not be invertible (#14063).
  invertible: false,
  noSharedTooltip: true,
  pointClass: FlagsPoint_default,
  sorted: false,
  takeOrdinalPosition: false,
  trackerGroups: ["markerGroup"],
  translate: OnSeries_default.translate
});
SeriesRegistry_default.registerSeriesType("flags", FlagsSeries);

// node_modules/highcharts/es-modules/Core/Axis/ScrollbarAxis.js
var addEvent23 = Utilities_default.addEvent;
var defined28 = Utilities_default.defined;
var pick40 = Utilities_default.pick;
var ScrollbarAxis = (
  /** @class */
  function() {
    function ScrollbarAxis2() {
    }
    ScrollbarAxis2.compose = function(AxisClass, ScrollbarClass) {
      if (ScrollbarAxis2.composed.indexOf(AxisClass) === -1) {
        ScrollbarAxis2.composed.push(AxisClass);
      } else {
        return AxisClass;
      }
      var getExtremes = function(axis) {
        var axisMin = pick40(axis.options && axis.options.min, axis.min);
        var axisMax = pick40(axis.options && axis.options.max, axis.max);
        return {
          axisMin,
          axisMax,
          scrollMin: defined28(axis.dataMin) ? Math.min(axisMin, axis.min, axis.dataMin, pick40(axis.threshold, Infinity)) : axisMin,
          scrollMax: defined28(axis.dataMax) ? Math.max(axisMax, axis.max, axis.dataMax, pick40(axis.threshold, -Infinity)) : axisMax
        };
      };
      addEvent23(AxisClass, "afterInit", function() {
        var axis = this;
        if (axis.options && axis.options.scrollbar && axis.options.scrollbar.enabled) {
          axis.options.scrollbar.vertical = !axis.horiz;
          axis.options.startOnTick = axis.options.endOnTick = false;
          axis.scrollbar = new ScrollbarClass(axis.chart.renderer, axis.options.scrollbar, axis.chart);
          addEvent23(axis.scrollbar, "changed", function(e2) {
            var _a15 = getExtremes(axis), axisMin = _a15.axisMin, axisMax = _a15.axisMax, unitedMin = _a15.scrollMin, unitedMax = _a15.scrollMax, range = unitedMax - unitedMin, to, from;
            if (!defined28(axisMin) || !defined28(axisMax)) {
              return;
            }
            if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
              to = unitedMin + range * this.to;
              from = unitedMin + range * this.from;
            } else {
              to = unitedMin + range * (1 - this.from);
              from = unitedMin + range * (1 - this.to);
            }
            if (this.shouldUpdateExtremes(e2.DOMType)) {
              axis.setExtremes(from, to, true, e2.DOMType !== "mousemove" && e2.DOMType !== "touchmove", e2);
            } else {
              this.setRange(this.from, this.to);
            }
          });
        }
      });
      addEvent23(AxisClass, "afterRender", function() {
        var axis = this, _a15 = getExtremes(axis), scrollMin = _a15.scrollMin, scrollMax = _a15.scrollMax, scrollbar = axis.scrollbar, offset3 = axis.axisTitleMargin + (axis.titleOffset || 0), scrollbarsOffsets = axis.chart.scrollbarsOffsets, axisMargin = axis.options.margin || 0, offsetsIndex, from, to;
        if (scrollbar) {
          if (axis.horiz) {
            if (!axis.opposite) {
              scrollbarsOffsets[1] += offset3;
            }
            scrollbar.position(axis.left, axis.top + axis.height + 2 + scrollbarsOffsets[1] - (axis.opposite ? axisMargin : 0), axis.width, axis.height);
            if (!axis.opposite) {
              scrollbarsOffsets[1] += axisMargin;
            }
            offsetsIndex = 1;
          } else {
            if (axis.opposite) {
              scrollbarsOffsets[0] += offset3;
            }
            scrollbar.position(axis.left + axis.width + 2 + scrollbarsOffsets[0] - (axis.opposite ? 0 : axisMargin), axis.top, axis.width, axis.height);
            if (axis.opposite) {
              scrollbarsOffsets[0] += axisMargin;
            }
            offsetsIndex = 0;
          }
          scrollbarsOffsets[offsetsIndex] += scrollbar.size + scrollbar.options.margin;
          if (isNaN(scrollMin) || isNaN(scrollMax) || !defined28(axis.min) || !defined28(axis.max) || axis.min === axis.max) {
            scrollbar.setRange(0, 1);
          } else {
            from = (axis.min - scrollMin) / (scrollMax - scrollMin);
            to = (axis.max - scrollMin) / (scrollMax - scrollMin);
            if (axis.horiz && !axis.reversed || !axis.horiz && axis.reversed) {
              scrollbar.setRange(from, to);
            } else {
              scrollbar.setRange(1 - to, 1 - from);
            }
          }
        }
      });
      addEvent23(AxisClass, "afterGetOffset", function() {
        var axis = this, index = axis.horiz ? 2 : 1, scrollbar = axis.scrollbar;
        if (scrollbar) {
          axis.chart.scrollbarsOffsets = [0, 0];
          axis.chart.axisOffset[index] += scrollbar.size + scrollbar.options.margin;
        }
      });
      return AxisClass;
    };
    ScrollbarAxis2.composed = [];
    return ScrollbarAxis2;
  }()
);
var ScrollbarAxis_default = ScrollbarAxis;

// node_modules/highcharts/es-modules/Core/ScrollbarDefaults.js
var isTouchDevice2 = Globals_default.isTouchDevice;
var ScrollbarDefaults = {
  /**
   * The height of the scrollbar. The height also applies to the width
   * of the scroll arrows so that they are always squares. Defaults to
   * 20 for touch devices and 14 for mouse devices.
   *
   * @sample stock/scrollbar/height/
   *         A 30px scrollbar
   *
   * @type    {number}
   * @default 20/14
   */
  height: isTouchDevice2 ? 20 : 14,
  /**
   * The border rounding radius of the bar.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  barBorderRadius: 0,
  /**
   * The corner radius of the scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  buttonBorderRadius: 0,
  /**
   * Enable or disable the scrollbar.
   *
   * @sample stock/scrollbar/enabled/
   *         Disable the scrollbar, only use navigator
   *
   * @type      {boolean}
   * @default   true
   * @apioption scrollbar.enabled
   */
  /**
   * Whether to redraw the main chart as the scrollbar or the navigator
   * zoomed window is moved. Defaults to `true` for modern browsers and
   * `false` for legacy IE browsers as well as mobile devices.
   *
   * @sample stock/scrollbar/liveredraw
   *         Setting live redraw to false
   *
   * @type  {boolean}
   * @since 1.3
   */
  liveRedraw: void 0,
  /**
   * The margin between the scrollbar and its axis when the scrollbar is
   * applied directly to an axis.
   */
  margin: 10,
  /**
   * The minimum width of the scrollbar.
   *
   * @since 1.2.5
   */
  minWidth: 6,
  /**
   * Whether to show or hide the scrollbar when the scrolled content is
   * zoomed out to it full extent.
   *
   * @type      {boolean}
   * @default   true
   * @apioption scrollbar.showFull
   */
  step: 0.2,
  /**
   * The z index of the scrollbar group.
   */
  zIndex: 3,
  /**
   * The background color of the scrollbar itself.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  barBackgroundColor: Palette_default.neutralColor20,
  /**
   * The width of the bar's border.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  barBorderWidth: 1,
  /**
   * The color of the scrollbar's border.
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  barBorderColor: Palette_default.neutralColor20,
  /**
   * The color of the small arrow inside the scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  buttonArrowColor: Palette_default.neutralColor80,
  /**
   * The color of scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  buttonBackgroundColor: Palette_default.neutralColor10,
  /**
   * The color of the border of the scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  buttonBorderColor: Palette_default.neutralColor20,
  /**
   * The border width of the scrollbar buttons.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  buttonBorderWidth: 1,
  /**
   * The color of the small rifles in the middle of the scrollbar.
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  rifleColor: Palette_default.neutralColor80,
  /**
   * The color of the track background.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  trackBackgroundColor: Palette_default.neutralColor5,
  /**
   * The color of the border of the scrollbar track.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  trackBorderColor: Palette_default.neutralColor5,
  /**
   * The corner radius of the border of the scrollbar track.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   *
   * @type      {number}
   * @default   0
   * @apioption scrollbar.trackBorderRadius
   */
  /**
   * The width of the border of the scrollbar track.
   *
   * @sample stock/scrollbar/style/
   *         Scrollbar styling
   */
  trackBorderWidth: 1
};
var ScrollbarDefaults_default = ScrollbarDefaults;

// node_modules/highcharts/es-modules/Core/Scrollbar.js
var defaultOptions9 = DefaultOptions_default.defaultOptions;
var addEvent24 = Utilities_default.addEvent;
var correctFloat8 = Utilities_default.correctFloat;
var defined29 = Utilities_default.defined;
var destroyObjectProperties8 = Utilities_default.destroyObjectProperties;
var fireEvent18 = Utilities_default.fireEvent;
var merge36 = Utilities_default.merge;
var pick41 = Utilities_default.pick;
var removeEvent9 = Utilities_default.removeEvent;
var Scrollbar = (
  /** @class */
  function() {
    function Scrollbar2(renderer, options, chart) {
      this._events = [];
      this.chart = void 0;
      this.chartX = 0;
      this.chartY = 0;
      this.from = 0;
      this.group = void 0;
      this.options = void 0;
      this.renderer = void 0;
      this.scrollbar = void 0;
      this.scrollbarButtons = [];
      this.scrollbarGroup = void 0;
      this.scrollbarLeft = 0;
      this.scrollbarRifles = void 0;
      this.scrollbarStrokeWidth = 1;
      this.scrollbarTop = 0;
      this.size = 0;
      this.to = 0;
      this.track = void 0;
      this.trackBorderWidth = 1;
      this.userOptions = void 0;
      this.x = 0;
      this.y = 0;
      this.init(renderer, options, chart);
    }
    Scrollbar2.compose = function(AxisClass) {
      ScrollbarAxis_default.compose(AxisClass, Scrollbar2);
    };
    Scrollbar2.swapXY = function(path, vertical) {
      if (vertical) {
        path.forEach(function(seg) {
          var len = seg.length;
          var temp;
          for (var i = 0; i < len; i += 2) {
            temp = seg[i + 1];
            if (typeof temp === "number") {
              seg[i + 1] = seg[i + 2];
              seg[i + 2] = temp;
            }
          }
        });
      }
      return path;
    };
    Scrollbar2.prototype.addEvents = function() {
      var buttonsOrder = this.options.inverted ? [1, 0] : [0, 1], buttons = this.scrollbarButtons, bar = this.scrollbarGroup.element, track = this.track.element, mouseDownHandler = this.mouseDownHandler.bind(this), mouseMoveHandler = this.mouseMoveHandler.bind(this), mouseUpHandler = this.mouseUpHandler.bind(this);
      var _events = [
        [buttons[buttonsOrder[0]].element, "click", this.buttonToMinClick.bind(this)],
        [buttons[buttonsOrder[1]].element, "click", this.buttonToMaxClick.bind(this)],
        [track, "click", this.trackClick.bind(this)],
        [bar, "mousedown", mouseDownHandler],
        [bar.ownerDocument, "mousemove", mouseMoveHandler],
        [bar.ownerDocument, "mouseup", mouseUpHandler]
      ];
      if (Globals_default.hasTouch) {
        _events.push([bar, "touchstart", mouseDownHandler], [bar.ownerDocument, "touchmove", mouseMoveHandler], [bar.ownerDocument, "touchend", mouseUpHandler]);
      }
      _events.forEach(function(args) {
        addEvent24.apply(null, args);
      });
      this._events = _events;
    };
    Scrollbar2.prototype.buttonToMaxClick = function(e2) {
      var scroller = this;
      var range = (scroller.to - scroller.from) * pick41(scroller.options.step, 0.2);
      scroller.updatePosition(scroller.from + range, scroller.to + range);
      fireEvent18(scroller, "changed", {
        from: scroller.from,
        to: scroller.to,
        trigger: "scrollbar",
        DOMEvent: e2
      });
    };
    Scrollbar2.prototype.buttonToMinClick = function(e2) {
      var scroller = this;
      var range = correctFloat8(scroller.to - scroller.from) * pick41(scroller.options.step, 0.2);
      scroller.updatePosition(correctFloat8(scroller.from - range), correctFloat8(scroller.to - range));
      fireEvent18(scroller, "changed", {
        from: scroller.from,
        to: scroller.to,
        trigger: "scrollbar",
        DOMEvent: e2
      });
    };
    Scrollbar2.prototype.cursorToScrollbarPosition = function(normalizedEvent) {
      var scroller = this, options = scroller.options, minWidthDifference = options.minWidth > scroller.calculatedWidth ? options.minWidth : 0;
      return {
        chartX: (normalizedEvent.chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference),
        chartY: (normalizedEvent.chartY - scroller.y - scroller.yOffset) / (scroller.barWidth - minWidthDifference)
      };
    };
    Scrollbar2.prototype.destroy = function() {
      var scroller = this, navigator = scroller.chart.scroller;
      scroller.removeEvents();
      [
        "track",
        "scrollbarRifles",
        "scrollbar",
        "scrollbarGroup",
        "group"
      ].forEach(function(prop) {
        if (scroller[prop] && scroller[prop].destroy) {
          scroller[prop] = scroller[prop].destroy();
        }
      });
      if (navigator && scroller === navigator.scrollbar) {
        navigator.scrollbar = null;
        destroyObjectProperties8(navigator.scrollbarButtons);
      }
    };
    Scrollbar2.prototype.drawScrollbarButton = function(index) {
      var scroller = this, renderer = scroller.renderer, scrollbarButtons = scroller.scrollbarButtons, options = scroller.options, size = scroller.size, group = renderer.g().add(scroller.group);
      var tempElem;
      scrollbarButtons.push(group);
      tempElem = renderer.rect().addClass("highcharts-scrollbar-button").add(group);
      if (!scroller.chart.styledMode) {
        tempElem.attr({
          stroke: options.buttonBorderColor,
          "stroke-width": options.buttonBorderWidth,
          fill: options.buttonBackgroundColor
        });
      }
      tempElem.attr(tempElem.crisp({
        x: -0.5,
        y: -0.5,
        width: size + 1,
        height: size + 1,
        r: options.buttonBorderRadius
      }, tempElem.strokeWidth()));
      tempElem = renderer.path(Scrollbar2.swapXY([[
        "M",
        size / 2 + (index ? -1 : 1),
        size / 2 - 3
      ], [
        "L",
        size / 2 + (index ? -1 : 1),
        size / 2 + 3
      ], [
        "L",
        size / 2 + (index ? 2 : -2),
        size / 2
      ]], options.vertical)).addClass("highcharts-scrollbar-arrow").add(scrollbarButtons[index]);
      if (!scroller.chart.styledMode) {
        tempElem.attr({
          fill: options.buttonArrowColor
        });
      }
    };
    Scrollbar2.prototype.init = function(renderer, options, chart) {
      var scroller = this;
      scroller.scrollbarButtons = [];
      scroller.renderer = renderer;
      scroller.userOptions = options;
      scroller.options = merge36(ScrollbarDefaults_default, defaultOptions9.scrollbar, options);
      scroller.chart = chart;
      scroller.size = pick41(scroller.options.size, scroller.options.height);
      if (options.enabled) {
        scroller.render();
        scroller.addEvents();
      }
    };
    Scrollbar2.prototype.mouseDownHandler = function(e2) {
      var scroller = this, normalizedEvent = scroller.chart.pointer.normalize(e2), mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);
      scroller.chartX = mousePosition.chartX;
      scroller.chartY = mousePosition.chartY;
      scroller.initPositions = [scroller.from, scroller.to];
      scroller.grabbedCenter = true;
    };
    Scrollbar2.prototype.mouseMoveHandler = function(e2) {
      var scroller = this, normalizedEvent = scroller.chart.pointer.normalize(e2), options = scroller.options, direction = options.vertical ? "chartY" : "chartX", initPositions = scroller.initPositions || [];
      var scrollPosition, chartPosition, change;
      if (scroller.grabbedCenter && // #4696, scrollbar failed on Android
      (!e2.touches || e2.touches[0][direction] !== 0)) {
        chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];
        scrollPosition = scroller[direction];
        change = chartPosition - scrollPosition;
        scroller.hasDragged = true;
        scroller.updatePosition(initPositions[0] + change, initPositions[1] + change);
        if (scroller.hasDragged) {
          fireEvent18(scroller, "changed", {
            from: scroller.from,
            to: scroller.to,
            trigger: "scrollbar",
            DOMType: e2.type,
            DOMEvent: e2
          });
        }
      }
    };
    Scrollbar2.prototype.mouseUpHandler = function(e2) {
      var scroller = this;
      if (scroller.hasDragged) {
        fireEvent18(scroller, "changed", {
          from: scroller.from,
          to: scroller.to,
          trigger: "scrollbar",
          DOMType: e2.type,
          DOMEvent: e2
        });
      }
      scroller.grabbedCenter = scroller.hasDragged = scroller.chartX = scroller.chartY = null;
    };
    Scrollbar2.prototype.position = function(x, y, width, height) {
      var scroller = this, options = scroller.options, vertical = options.vertical, method = scroller.rendered ? "animate" : "attr";
      var xOffset = height, yOffset = 0;
      scroller.x = x;
      scroller.y = y + this.trackBorderWidth;
      scroller.width = width;
      scroller.height = height;
      scroller.xOffset = xOffset;
      scroller.yOffset = yOffset;
      if (vertical) {
        scroller.width = scroller.yOffset = width = yOffset = scroller.size;
        scroller.xOffset = xOffset = 0;
        scroller.barWidth = height - width * 2;
        scroller.x = x = x + scroller.options.margin;
      } else {
        scroller.height = scroller.xOffset = height = xOffset = scroller.size;
        scroller.barWidth = width - height * 2;
        scroller.y = scroller.y + scroller.options.margin;
      }
      scroller.group[method]({
        translateX: x,
        translateY: scroller.y
      });
      scroller.track[method]({
        width,
        height
      });
      scroller.scrollbarButtons[1][method]({
        translateX: vertical ? 0 : width - xOffset,
        translateY: vertical ? height - yOffset : 0
      });
    };
    Scrollbar2.prototype.removeEvents = function() {
      this._events.forEach(function(args) {
        removeEvent9.apply(null, args);
      });
      this._events.length = 0;
    };
    Scrollbar2.prototype.render = function() {
      var scroller = this, renderer = scroller.renderer, options = scroller.options, size = scroller.size, styledMode = scroller.chart.styledMode, group = renderer.g("scrollbar").attr({
        zIndex: options.zIndex,
        translateY: -99999
      }).add();
      scroller.group = group;
      scroller.track = renderer.rect().addClass("highcharts-scrollbar-track").attr({
        x: 0,
        r: options.trackBorderRadius || 0,
        height: size,
        width: size
      }).add(group);
      if (!styledMode) {
        scroller.track.attr({
          fill: options.trackBackgroundColor,
          stroke: options.trackBorderColor,
          "stroke-width": options.trackBorderWidth
        });
      }
      scroller.trackBorderWidth = scroller.track.strokeWidth();
      scroller.track.attr({
        y: -this.trackBorderWidth % 2 / 2
      });
      scroller.scrollbarGroup = renderer.g().add(group);
      scroller.scrollbar = renderer.rect().addClass("highcharts-scrollbar-thumb").attr({
        height: size,
        width: size,
        r: options.barBorderRadius || 0
      }).add(scroller.scrollbarGroup);
      scroller.scrollbarRifles = renderer.path(Scrollbar2.swapXY([
        ["M", -3, size / 4],
        ["L", -3, 2 * size / 3],
        ["M", 0, size / 4],
        ["L", 0, 2 * size / 3],
        ["M", 3, size / 4],
        ["L", 3, 2 * size / 3]
      ], options.vertical)).addClass("highcharts-scrollbar-rifles").add(scroller.scrollbarGroup);
      if (!styledMode) {
        scroller.scrollbar.attr({
          fill: options.barBackgroundColor,
          stroke: options.barBorderColor,
          "stroke-width": options.barBorderWidth
        });
        scroller.scrollbarRifles.attr({
          stroke: options.rifleColor,
          "stroke-width": 1
        });
      }
      scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();
      scroller.scrollbarGroup.translate(-scroller.scrollbarStrokeWidth % 2 / 2, -scroller.scrollbarStrokeWidth % 2 / 2);
      scroller.drawScrollbarButton(0);
      scroller.drawScrollbarButton(1);
    };
    Scrollbar2.prototype.setRange = function(from, to) {
      var scroller = this, options = scroller.options, vertical = options.vertical, minWidth = options.minWidth, fullWidth = scroller.barWidth, method = this.rendered && !this.hasDragged && !(this.chart.navigator && this.chart.navigator.hasDragged) ? "animate" : "attr";
      if (!defined29(fullWidth)) {
        return;
      }
      var toPX = fullWidth * Math.min(to, 1);
      var fromPX, newSize;
      from = Math.max(from, 0);
      fromPX = Math.ceil(fullWidth * from);
      scroller.calculatedWidth = newSize = correctFloat8(toPX - fromPX);
      if (newSize < minWidth) {
        fromPX = (fullWidth - minWidth + newSize) * from;
        newSize = minWidth;
      }
      var newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);
      var newRiflesPos = newSize / 2 - 0.5;
      scroller.from = from;
      scroller.to = to;
      if (!vertical) {
        scroller.scrollbarGroup[method]({
          translateX: newPos
        });
        scroller.scrollbar[method]({
          width: newSize
        });
        scroller.scrollbarRifles[method]({
          translateX: newRiflesPos
        });
        scroller.scrollbarLeft = newPos;
        scroller.scrollbarTop = 0;
      } else {
        scroller.scrollbarGroup[method]({
          translateY: newPos
        });
        scroller.scrollbar[method]({
          height: newSize
        });
        scroller.scrollbarRifles[method]({
          translateY: newRiflesPos
        });
        scroller.scrollbarTop = newPos;
        scroller.scrollbarLeft = 0;
      }
      if (newSize <= 12) {
        scroller.scrollbarRifles.hide();
      } else {
        scroller.scrollbarRifles.show(true);
      }
      if (options.showFull === false) {
        if (from <= 0 && to >= 1) {
          scroller.group.hide();
        } else {
          scroller.group.show();
        }
      }
      scroller.rendered = true;
    };
    Scrollbar2.prototype.shouldUpdateExtremes = function(eventType) {
      return pick41(this.options.liveRedraw, Globals_default.svg && !Globals_default.isTouchDevice && !this.chart.isBoosting) || // Mouseup always should change extremes
      eventType === "mouseup" || eventType === "touchend" || // Internal events
      !defined29(eventType);
    };
    Scrollbar2.prototype.trackClick = function(e2) {
      var scroller = this;
      var normalizedEvent = scroller.chart.pointer.normalize(e2), range = scroller.to - scroller.from, top = scroller.y + scroller.scrollbarTop, left = scroller.x + scroller.scrollbarLeft;
      if (scroller.options.vertical && normalizedEvent.chartY > top || !scroller.options.vertical && normalizedEvent.chartX > left) {
        scroller.updatePosition(scroller.from + range, scroller.to + range);
      } else {
        scroller.updatePosition(scroller.from - range, scroller.to - range);
      }
      fireEvent18(scroller, "changed", {
        from: scroller.from,
        to: scroller.to,
        trigger: "scrollbar",
        DOMEvent: e2
      });
    };
    Scrollbar2.prototype.update = function(options) {
      this.destroy();
      this.init(this.chart.renderer, merge36(true, this.options, options), this.chart);
    };
    Scrollbar2.prototype.updatePosition = function(from, to) {
      if (to > 1) {
        from = correctFloat8(1 - correctFloat8(to - from));
        to = 1;
      }
      if (from < 0) {
        to = correctFloat8(to - from);
        from = 0;
      }
      this.from = from;
      this.to = to;
    };
    Scrollbar2.defaultOptions = ScrollbarDefaults_default;
    return Scrollbar2;
  }()
);
defaultOptions9.scrollbar = merge36(true, Scrollbar.defaultOptions, defaultOptions9.scrollbar);
var Scrollbar_default = Scrollbar;

// node_modules/highcharts/es-modules/Core/Axis/NavigatorAxis.js
var isTouchDevice3 = Globals_default.isTouchDevice;
var addEvent25 = Utilities_default.addEvent;
var correctFloat9 = Utilities_default.correctFloat;
var defined30 = Utilities_default.defined;
var isNumber28 = Utilities_default.isNumber;
var pick42 = Utilities_default.pick;
var NavigatorAxisAdditions = (
  /** @class */
  function() {
    function NavigatorAxisAdditions2(axis) {
      this.axis = axis;
    }
    NavigatorAxisAdditions2.prototype.destroy = function() {
      this.axis = void 0;
    };
    NavigatorAxisAdditions2.prototype.toFixedRange = function(pxMin, pxMax, fixedMin, fixedMax) {
      var navigator = this;
      var axis = navigator.axis;
      var chart = axis.chart;
      var fixedRange = chart && chart.fixedRange, halfPointRange = (axis.pointRange || 0) / 2, newMin = pick42(fixedMin, axis.translate(pxMin, true, !axis.horiz)), newMax = pick42(fixedMax, axis.translate(pxMax, true, !axis.horiz)), changeRatio = fixedRange && (newMax - newMin) / fixedRange;
      if (!defined30(fixedMin)) {
        newMin = correctFloat9(newMin + halfPointRange);
      }
      if (!defined30(fixedMax)) {
        newMax = correctFloat9(newMax - halfPointRange);
      }
      if (changeRatio > 0.7 && changeRatio < 1.3) {
        if (fixedMax) {
          newMin = newMax - fixedRange;
        } else {
          newMax = newMin + fixedRange;
        }
      }
      if (!isNumber28(newMin) || !isNumber28(newMax)) {
        newMin = newMax = void 0;
      }
      return {
        min: newMin,
        max: newMax
      };
    };
    return NavigatorAxisAdditions2;
  }()
);
var NavigatorAxis = (
  /** @class */
  function() {
    function NavigatorAxis2() {
    }
    NavigatorAxis2.compose = function(AxisClass) {
      AxisClass.keepProps.push("navigatorAxis");
      addEvent25(AxisClass, "init", function() {
        var axis = this;
        if (!axis.navigatorAxis) {
          axis.navigatorAxis = new NavigatorAxisAdditions(axis);
        }
      });
      addEvent25(AxisClass, "zoom", function(e2) {
        var axis = this;
        var chart = axis.chart;
        var chartOptions = chart.options;
        var navigator = chartOptions.navigator;
        var navigatorAxis = axis.navigatorAxis;
        var pinchType = chartOptions.chart.pinchType;
        var rangeSelector = chartOptions.rangeSelector;
        var zoomType = chartOptions.chart.zoomType;
        var previousZoom;
        if (axis.isXAxis && (navigator && navigator.enabled || rangeSelector && rangeSelector.enabled)) {
          if (zoomType === "y") {
            e2.zoomed = false;
          } else if ((!isTouchDevice3 && zoomType === "xy" || isTouchDevice3 && pinchType === "xy") && axis.options.range) {
            previousZoom = navigatorAxis.previousZoom;
            if (defined30(e2.newMin)) {
              navigatorAxis.previousZoom = [axis.min, axis.max];
            } else if (previousZoom) {
              e2.newMin = previousZoom[0];
              e2.newMax = previousZoom[1];
              navigatorAxis.previousZoom = void 0;
            }
          }
        }
        if (typeof e2.zoomed !== "undefined") {
          e2.preventDefault();
        }
      });
    };
    NavigatorAxis2.AdditionsClass = NavigatorAxisAdditions;
    return NavigatorAxis2;
  }()
);
var NavigatorAxis_default = NavigatorAxis;

// node_modules/highcharts/es-modules/Core/Navigator.js
var color6 = Color_default.parse;
var hasTouch3 = Globals_default.hasTouch;
var isTouchDevice4 = Globals_default.isTouchDevice;
var defaultOptions10 = DefaultOptions_default.defaultOptions;
var seriesTypes3 = SeriesRegistry_default.seriesTypes;
var addEvent26 = Utilities_default.addEvent;
var clamp10 = Utilities_default.clamp;
var correctFloat10 = Utilities_default.correctFloat;
var defined31 = Utilities_default.defined;
var destroyObjectProperties9 = Utilities_default.destroyObjectProperties;
var erase9 = Utilities_default.erase;
var extend28 = Utilities_default.extend;
var find8 = Utilities_default.find;
var isArray16 = Utilities_default.isArray;
var isNumber29 = Utilities_default.isNumber;
var merge37 = Utilities_default.merge;
var pick43 = Utilities_default.pick;
var removeEvent10 = Utilities_default.removeEvent;
var splat11 = Utilities_default.splat;
var defaultSeriesType;
var numExt = function(extreme) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var numbers = [].filter.call(args, isNumber29);
  if (numbers.length) {
    return Math[extreme].apply(0, numbers);
  }
};
defaultSeriesType = typeof seriesTypes3.areaspline === "undefined" ? "line" : "areaspline";
extend28(defaultOptions10, {
  /**
   * Maximum range which can be set using the navigator's handles.
   * Opposite of [xAxis.minRange](#xAxis.minRange).
   *
   * @sample {highstock} stock/navigator/maxrange/
   *         Defined max and min range
   *
   * @type      {number}
   * @since     6.0.0
   * @product   highstock gantt
   * @apioption xAxis.maxRange
   */
  /**
   * The navigator is a small series below the main series, displaying
   * a view of the entire data set. It provides tools to zoom in and
   * out on parts of the data as well as panning across the dataset.
   *
   * @product      highstock gantt
   * @optionparent navigator
   */
  navigator: {
    /**
     * Whether the navigator and scrollbar should adapt to updated data
     * in the base X axis. When loading data async, as in the demo below,
     * this should be `false`. Otherwise new data will trigger navigator
     * redraw, which will cause unwanted looping. In the demo below, the
     * data in the navigator is set only once. On navigating, only the main
     * chart content is updated.
     *
     * @sample {highstock} stock/demo/lazy-loading/
     *         Set to false with async data loading
     *
     * @type      {boolean}
     * @default   true
     * @apioption navigator.adaptToUpdatedData
     */
    /**
     * An integer identifying the index to use for the base series, or a
     * string representing the id of the series.
     *
     * **Note**: As of Highcharts 5.0, this is now a deprecated option.
     * Prefer [series.showInNavigator](#plotOptions.series.showInNavigator).
     *
     * @see [series.showInNavigator](#plotOptions.series.showInNavigator)
     *
     * @deprecated
     * @type      {number|string}
     * @default   0
     * @apioption navigator.baseSeries
     */
    /**
     * Enable or disable the navigator.
     *
     * @sample {highstock} stock/navigator/enabled/
     *         Disable the navigator
     *
     * @type      {boolean}
     * @default   true
     * @apioption navigator.enabled
     */
    /**
     * When the chart is inverted, whether to draw the navigator on the
     * opposite side.
     *
     * @type      {boolean}
     * @default   false
     * @since     5.0.8
     * @apioption navigator.opposite
     */
    /**
     * The height of the navigator.
     *
     * @sample {highstock} stock/navigator/height/
     *         A higher navigator
     */
    height: 40,
    /**
     * The distance from the nearest element, the X axis or X axis labels.
     *
     * @sample {highstock} stock/navigator/margin/
     *         A margin of 2 draws the navigator closer to the X axis labels
     */
    margin: 25,
    /**
     * Whether the mask should be inside the range marking the zoomed
     * range, or outside. In Highcharts Stock 1.x it was always `false`.
     *
     * @sample {highstock} stock/navigator/maskinside-false/
     *         False, mask outside
     *
     * @since   2.0
     */
    maskInside: true,
    /**
     * Options for the handles for dragging the zoomed area.
     *
     * @sample {highstock} stock/navigator/handles/
     *         Colored handles
     */
    handles: {
      /**
       * Width for handles.
       *
       * @sample {highstock} stock/navigator/styled-handles/
       *         Styled handles
       *
       * @since   6.0.0
       */
      width: 7,
      /**
       * Height for handles.
       *
       * @sample {highstock} stock/navigator/styled-handles/
       *         Styled handles
       *
       * @since   6.0.0
       */
      height: 15,
      /**
       * Array to define shapes of handles. 0-index for left, 1-index for
       * right.
       *
       * Additionally, the URL to a graphic can be given on this form:
       * `url(graphic.png)`. Note that for the image to be applied to
       * exported charts, its URL needs to be accessible by the export
       * server.
       *
       * Custom callbacks for symbol path generation can also be added to
       * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
       * used by its method name, as shown in the demo.
       *
       * @sample {highstock} stock/navigator/styled-handles/
       *         Styled handles
       *
       * @type    {Array<string>}
       * @default ["navigator-handle", "navigator-handle"]
       * @since   6.0.0
       */
      symbols: ["navigator-handle", "navigator-handle"],
      /**
       * Allows to enable/disable handles.
       *
       * @since   6.0.0
       */
      enabled: true,
      /**
       * The width for the handle border and the stripes inside.
       *
       * @sample {highstock} stock/navigator/styled-handles/
       *         Styled handles
       *
       * @since     6.0.0
       * @apioption navigator.handles.lineWidth
       */
      lineWidth: 1,
      /**
       * The fill for the handle.
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      backgroundColor: Palette_default.neutralColor5,
      /**
       * The stroke for the handle border and the stripes inside.
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      borderColor: Palette_default.neutralColor40
    },
    /**
     * The color of the mask covering the areas of the navigator series
     * that are currently not visible in the main series. The default
     * color is bluish with an opacity of 0.3 to see the series below.
     *
     * @see In styled mode, the mask is styled with the
     *      `.highcharts-navigator-mask` and
     *      `.highcharts-navigator-mask-inside` classes.
     *
     * @sample {highstock} stock/navigator/maskfill/
     *         Blue, semi transparent mask
     *
     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @default rgba(102,133,194,0.3)
     */
    maskFill: color6(Palette_default.highlightColor60).setOpacity(0.3).get(),
    /**
     * The color of the line marking the currently zoomed area in the
     * navigator.
     *
     * @sample {highstock} stock/navigator/outline/
     *         2px blue outline
     *
     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @default #cccccc
     */
    outlineColor: Palette_default.neutralColor20,
    /**
     * The width of the line marking the currently zoomed area in the
     * navigator.
     *
     * @see In styled mode, the outline stroke width is set with the
     *      `.highcharts-navigator-outline` class.
     *
     * @sample {highstock} stock/navigator/outline/
     *         2px blue outline
     *
     * @type    {number}
     */
    outlineWidth: 1,
    /**
     * Options for the navigator series. Available options are the same
     * as any series, documented at [plotOptions](#plotOptions.series)
     * and [series](#series).
     *
     * Unless data is explicitly defined on navigator.series, the data
     * is borrowed from the first series in the chart.
     *
     * Default series options for the navigator series are:
     * ```js
     * series: {
     *     type: 'areaspline',
     *     fillOpacity: 0.05,
     *     dataGrouping: {
     *         smoothed: true
     *     },
     *     lineWidth: 1,
     *     marker: {
     *         enabled: false
     *     }
     * }
     * ```
     *
     * @see In styled mode, the navigator series is styled with the
     *      `.highcharts-navigator-series` class.
     *
     * @sample {highstock} stock/navigator/series-data/
     *         Using a separate data set for the navigator
     * @sample {highstock} stock/navigator/series/
     *         A green navigator series
     *
     * @type {*|Array<*>|Highcharts.SeriesOptionsType|Array<Highcharts.SeriesOptionsType>}
     */
    series: {
      /**
       * The type of the navigator series.
       *
       * Heads up:
       * In column-type navigator, zooming is limited to at least one
       * point with its `pointRange`.
       *
       * @sample {highstock} stock/navigator/column/
       *         Column type navigator
       *
       * @type    {string}
       * @default {highstock} `areaspline` if defined, otherwise `line`
       * @default {gantt} gantt
       */
      type: defaultSeriesType,
      /**
       * The fill opacity of the navigator series.
       */
      fillOpacity: 0.05,
      /**
       * The pixel line width of the navigator series.
       */
      lineWidth: 1,
      /**
       * @ignore-option
       */
      compare: null,
      /**
       * Unless data is explicitly defined, the data is borrowed from the
       * first series in the chart.
       *
       * @type      {Array<number|Array<number|string|null>|object|null>}
       * @product   highstock
       * @apioption navigator.series.data
       */
      /**
       * Data grouping options for the navigator series.
       *
       * @extends plotOptions.series.dataGrouping
       */
      dataGrouping: {
        approximation: "average",
        enabled: true,
        groupPixelWidth: 2,
        // Replace smoothed property by anchors, #12455.
        firstAnchor: "firstPoint",
        anchor: "middle",
        lastAnchor: "lastPoint",
        // Day and week differs from plotOptions.series.dataGrouping
        units: [
          ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
          ["second", [1, 2, 5, 10, 15, 30]],
          ["minute", [1, 2, 5, 10, 15, 30]],
          ["hour", [1, 2, 3, 4, 6, 8, 12]],
          ["day", [1, 2, 3, 4]],
          ["week", [1, 2, 3]],
          ["month", [1, 3, 6]],
          ["year", null]
        ]
      },
      /**
       * Data label options for the navigator series. Data labels are
       * disabled by default on the navigator series.
       *
       * @extends plotOptions.series.dataLabels
       */
      dataLabels: {
        enabled: false,
        zIndex: 2
        // #1839
      },
      id: "highcharts-navigator-series",
      className: "highcharts-navigator-series",
      /**
       * Sets the fill color of the navigator series.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @apioption navigator.series.color
       */
      /**
       * Line color for the navigator series. Allows setting the color
       * while disallowing the default candlestick setting.
       *
       * @type {Highcharts.ColorString|null}
       */
      lineColor: null,
      marker: {
        enabled: false
      },
      /**
       * Since Highcharts Stock v8, default value is the same as default
       * `pointRange` defined for a specific type (e.g. `null` for
       * column type).
       *
       * In Highcharts Stock version < 8, defaults to 0.
       *
       * @extends plotOptions.series.pointRange
       * @type {number|null}
       * @apioption navigator.series.pointRange
       */
      /**
       * The threshold option. Setting it to 0 will make the default
       * navigator area series draw its area from the 0 value and up.
       *
       * @type {number|null}
       */
      threshold: null
    },
    /**
     * Options for the navigator X axis. Default series options for the
     * navigator xAxis are:
     * ```js
     * xAxis: {
     *     tickWidth: 0,
     *     lineWidth: 0,
     *     gridLineWidth: 1,
     *     tickPixelInterval: 200,
     *     labels: {
     *            align: 'left',
     *         style: {
     *             color: '#888'
     *         },
     *         x: 3,
     *         y: -4
     *     }
     * }
     * ```
     *
     * @extends   xAxis
     * @excluding linkedTo, maxZoom, minRange, opposite, range, scrollbar,
     *            showEmpty, maxRange
     */
    xAxis: {
      /**
       * Additional range on the right side of the xAxis. Works similar to
       * xAxis.maxPadding, but value is set in milliseconds.
       * Can be set for both, main xAxis and navigator's xAxis.
       *
       * @since   6.0.0
       */
      overscroll: 0,
      className: "highcharts-navigator-xaxis",
      tickLength: 0,
      lineWidth: 0,
      gridLineColor: Palette_default.neutralColor10,
      gridLineWidth: 1,
      tickPixelInterval: 200,
      labels: {
        align: "left",
        /**
         * @type {Highcharts.CSSObject}
         */
        style: {
          /** @ignore */
          color: Palette_default.neutralColor40
        },
        x: 3,
        y: -4
      },
      crosshair: false
    },
    /**
     * Options for the navigator Y axis. Default series options for the
     * navigator yAxis are:
     * ```js
     * yAxis: {
     *     gridLineWidth: 0,
     *     startOnTick: false,
     *     endOnTick: false,
     *     minPadding: 0.1,
     *     maxPadding: 0.1,
     *     labels: {
     *         enabled: false
     *     },
     *     title: {
     *         text: null
     *     },
     *     tickWidth: 0
     * }
     * ```
     *
     * @extends   yAxis
     * @excluding height, linkedTo, maxZoom, minRange, ordinal, range,
     *            showEmpty, scrollbar, top, units, maxRange, minLength,
     *            maxLength, resize
     */
    yAxis: {
      className: "highcharts-navigator-yaxis",
      gridLineWidth: 0,
      startOnTick: false,
      endOnTick: false,
      minPadding: 0.1,
      maxPadding: 0.1,
      labels: {
        enabled: false
      },
      crosshair: false,
      title: {
        text: null
      },
      tickLength: 0,
      tickWidth: 0
    }
  }
});
RendererRegistry_default.getRendererType().prototype.symbols["navigator-handle"] = function(_x, _y, _w, _h, options) {
  var halfWidth = (options && options.width || 0) / 2, markerPosition = Math.round(halfWidth / 3) + 0.5, height = options && options.height || 0;
  return [
    ["M", -halfWidth - 1, 0.5],
    ["L", halfWidth, 0.5],
    ["L", halfWidth, height + 0.5],
    ["L", -halfWidth - 1, height + 0.5],
    ["L", -halfWidth - 1, 0.5],
    ["M", -markerPosition, 4],
    ["L", -markerPosition, height - 3],
    ["M", markerPosition - 1, 4],
    ["L", markerPosition - 1, height - 3]
  ];
};
var Navigator = (
  /** @class */
  function() {
    function Navigator2(chart) {
      this.baseSeries = void 0;
      this.chart = void 0;
      this.handles = void 0;
      this.height = void 0;
      this.left = void 0;
      this.navigatorEnabled = void 0;
      this.navigatorGroup = void 0;
      this.navigatorOptions = void 0;
      this.navigatorSeries = void 0;
      this.navigatorSize = void 0;
      this.opposite = void 0;
      this.outline = void 0;
      this.outlineHeight = void 0;
      this.range = void 0;
      this.rendered = void 0;
      this.shades = void 0;
      this.size = void 0;
      this.top = void 0;
      this.xAxis = void 0;
      this.yAxis = void 0;
      this.zoomedMax = void 0;
      this.zoomedMin = void 0;
      this.init(chart);
    }
    Navigator2.prototype.drawHandle = function(x, index, inverted, verb) {
      var navigator = this, height = navigator.navigatorOptions.handles.height;
      navigator.handles[index][verb](inverted ? {
        translateX: Math.round(navigator.left + navigator.height / 2),
        translateY: Math.round(navigator.top + parseInt(x, 10) + 0.5 - height)
      } : {
        translateX: Math.round(navigator.left + parseInt(x, 10)),
        translateY: Math.round(navigator.top + navigator.height / 2 - height / 2 - 1)
      });
    };
    Navigator2.prototype.drawOutline = function(zoomedMin, zoomedMax, inverted, verb) {
      var navigator = this, maskInside = navigator.navigatorOptions.maskInside, outlineWidth = navigator.outline.strokeWidth(), halfOutline = outlineWidth / 2, outlineCorrection = outlineWidth % 2 / 2, outlineHeight = navigator.outlineHeight, scrollbarHeight = navigator.scrollbarHeight || 0, navigatorSize = navigator.size, left = navigator.left - scrollbarHeight, navigatorTop = navigator.top, verticalMin, path;
      if (inverted) {
        left -= halfOutline;
        verticalMin = navigatorTop + zoomedMax + outlineCorrection;
        zoomedMax = navigatorTop + zoomedMin + outlineCorrection;
        path = [
          ["M", left + outlineHeight, navigatorTop - scrollbarHeight - outlineCorrection],
          ["L", left + outlineHeight, verticalMin],
          ["L", left, verticalMin],
          ["L", left, zoomedMax],
          ["L", left + outlineHeight, zoomedMax],
          ["L", left + outlineHeight, navigatorTop + navigatorSize + scrollbarHeight]
        ];
        if (maskInside) {
          path.push(
            ["M", left + outlineHeight, verticalMin - halfOutline],
            // upper left of zoomed range
            ["L", left + outlineHeight, zoomedMax + halfOutline]
            // upper right of z.r.
          );
        }
      } else {
        zoomedMin += left + scrollbarHeight - outlineCorrection;
        zoomedMax += left + scrollbarHeight - outlineCorrection;
        navigatorTop += halfOutline;
        path = [
          ["M", left, navigatorTop],
          ["L", zoomedMin, navigatorTop],
          ["L", zoomedMin, navigatorTop + outlineHeight],
          ["L", zoomedMax, navigatorTop + outlineHeight],
          ["L", zoomedMax, navigatorTop],
          ["L", left + navigatorSize + scrollbarHeight * 2, navigatorTop]
          // right
        ];
        if (maskInside) {
          path.push(
            ["M", zoomedMin - halfOutline, navigatorTop],
            // upper left of zoomed range
            ["L", zoomedMax + halfOutline, navigatorTop]
            // upper right of z.r.
          );
        }
      }
      navigator.outline[verb]({
        d: path
      });
    };
    Navigator2.prototype.drawMasks = function(zoomedMin, zoomedMax, inverted, verb) {
      var navigator = this, left = navigator.left, top = navigator.top, navigatorHeight = navigator.height, height, width, x, y;
      if (inverted) {
        x = [left, left, left];
        y = [top, top + zoomedMin, top + zoomedMax];
        width = [navigatorHeight, navigatorHeight, navigatorHeight];
        height = [
          zoomedMin,
          zoomedMax - zoomedMin,
          navigator.size - zoomedMax
        ];
      } else {
        x = [left, left + zoomedMin, left + zoomedMax];
        y = [top, top, top];
        width = [
          zoomedMin,
          zoomedMax - zoomedMin,
          navigator.size - zoomedMax
        ];
        height = [navigatorHeight, navigatorHeight, navigatorHeight];
      }
      navigator.shades.forEach(function(shade, i) {
        shade[verb]({
          x: x[i],
          y: y[i],
          width: width[i],
          height: height[i]
        });
      });
    };
    Navigator2.prototype.renderElements = function() {
      var navigator = this, navigatorOptions = navigator.navigatorOptions, maskInside = navigatorOptions.maskInside, chart = navigator.chart, inverted = chart.inverted, renderer = chart.renderer, navigatorGroup, mouseCursor = {
        cursor: inverted ? "ns-resize" : "ew-resize"
      };
      navigator.navigatorGroup = navigatorGroup = renderer.g("navigator").attr({
        zIndex: 8,
        visibility: "hidden"
      }).add();
      [
        !maskInside,
        maskInside,
        !maskInside
      ].forEach(function(hasMask, index) {
        navigator.shades[index] = renderer.rect().addClass("highcharts-navigator-mask" + (index === 1 ? "-inside" : "-outside")).add(navigatorGroup);
        if (!chart.styledMode) {
          navigator.shades[index].attr({
            fill: hasMask ? navigatorOptions.maskFill : "rgba(0,0,0,0)"
          }).css(index === 1 && mouseCursor);
        }
      });
      navigator.outline = renderer.path().addClass("highcharts-navigator-outline").add(navigatorGroup);
      if (!chart.styledMode) {
        navigator.outline.attr({
          "stroke-width": navigatorOptions.outlineWidth,
          stroke: navigatorOptions.outlineColor
        });
      }
      if (navigatorOptions.handles.enabled) {
        [0, 1].forEach(function(index) {
          navigatorOptions.handles.inverted = chart.inverted;
          navigator.handles[index] = renderer.symbol(navigatorOptions.handles.symbols[index], -navigatorOptions.handles.width / 2 - 1, 0, navigatorOptions.handles.width, navigatorOptions.handles.height, navigatorOptions.handles);
          navigator.handles[index].attr({ zIndex: 7 - index }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][index]).add(navigatorGroup);
          if (!chart.styledMode) {
            var handlesOptions = navigatorOptions.handles;
            navigator.handles[index].attr({
              fill: handlesOptions.backgroundColor,
              stroke: handlesOptions.borderColor,
              "stroke-width": handlesOptions.lineWidth
            }).css(mouseCursor);
          }
        });
      }
    };
    Navigator2.prototype.update = function(options) {
      (this.series || []).forEach(function(series) {
        if (series.baseSeries) {
          delete series.baseSeries.navigatorSeries;
        }
      });
      this.destroy();
      var chartOptions = this.chart.options;
      merge37(true, chartOptions.navigator, this.options, options);
      this.init(this.chart);
    };
    Navigator2.prototype.render = function(min, max, pxMin, pxMax) {
      var navigator = this, chart = navigator.chart, navigatorWidth, scrollbarLeft, scrollbarTop, scrollbarHeight = navigator.scrollbarHeight, navigatorSize, xAxis = navigator.xAxis, pointRange = xAxis.pointRange || 0, scrollbarXAxis = xAxis.navigatorAxis.fake ? chart.xAxis[0] : xAxis, navigatorEnabled = navigator.navigatorEnabled, zoomedMin, zoomedMax, rendered = navigator.rendered, inverted = chart.inverted, verb, newMin, newMax, currentRange, minRange = chart.xAxis[0].minRange, maxRange = chart.xAxis[0].options.maxRange;
      if (this.hasDragged && !defined31(pxMin)) {
        return;
      }
      min = correctFloat10(min - pointRange / 2);
      max = correctFloat10(max + pointRange / 2);
      if (!isNumber29(min) || !isNumber29(max)) {
        if (rendered) {
          pxMin = 0;
          pxMax = pick43(xAxis.width, scrollbarXAxis.width);
        } else {
          return;
        }
      }
      navigator.left = pick43(
        xAxis.left,
        // in case of scrollbar only, without navigator
        chart.plotLeft + scrollbarHeight + (inverted ? chart.plotWidth : 0)
      );
      navigator.size = zoomedMax = navigatorSize = pick43(xAxis.len, (inverted ? chart.plotHeight : chart.plotWidth) - 2 * scrollbarHeight);
      if (inverted) {
        navigatorWidth = scrollbarHeight;
      } else {
        navigatorWidth = navigatorSize + 2 * scrollbarHeight;
      }
      pxMin = pick43(pxMin, xAxis.toPixels(min, true));
      pxMax = pick43(pxMax, xAxis.toPixels(max, true));
      if (!isNumber29(pxMin) || Math.abs(pxMin) === Infinity) {
        pxMin = 0;
        pxMax = navigatorWidth;
      }
      newMin = xAxis.toValue(pxMin, true);
      newMax = xAxis.toValue(pxMax, true);
      currentRange = Math.abs(correctFloat10(newMax - newMin));
      if (currentRange < minRange) {
        if (this.grabbedLeft) {
          pxMin = xAxis.toPixels(newMax - minRange - pointRange, true);
        } else if (this.grabbedRight) {
          pxMax = xAxis.toPixels(newMin + minRange + pointRange, true);
        }
      } else if (defined31(maxRange) && correctFloat10(currentRange - pointRange) > maxRange) {
        if (this.grabbedLeft) {
          pxMin = xAxis.toPixels(newMax - maxRange - pointRange, true);
        } else if (this.grabbedRight) {
          pxMax = xAxis.toPixels(newMin + maxRange + pointRange, true);
        }
      }
      navigator.zoomedMax = clamp10(Math.max(pxMin, pxMax), 0, zoomedMax);
      navigator.zoomedMin = clamp10(navigator.fixedWidth ? navigator.zoomedMax - navigator.fixedWidth : Math.min(pxMin, pxMax), 0, zoomedMax);
      navigator.range = navigator.zoomedMax - navigator.zoomedMin;
      zoomedMax = Math.round(navigator.zoomedMax);
      zoomedMin = Math.round(navigator.zoomedMin);
      if (navigatorEnabled) {
        navigator.navigatorGroup.attr({
          visibility: "visible"
        });
        verb = rendered && !navigator.hasDragged ? "animate" : "attr";
        navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
        navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
        if (navigator.navigatorOptions.handles.enabled) {
          navigator.drawHandle(zoomedMin, 0, inverted, verb);
          navigator.drawHandle(zoomedMax, 1, inverted, verb);
        }
      }
      if (navigator.scrollbar) {
        if (inverted) {
          scrollbarTop = navigator.top - scrollbarHeight;
          scrollbarLeft = navigator.left - scrollbarHeight + (navigatorEnabled || !scrollbarXAxis.opposite ? 0 : (
            // Multiple axes has offsets:
            (scrollbarXAxis.titleOffset || 0) + // Self margin from the axis.title
            scrollbarXAxis.axisTitleMargin
          ));
          scrollbarHeight = navigatorSize + 2 * scrollbarHeight;
        } else {
          scrollbarTop = navigator.top + (navigatorEnabled ? navigator.height : -scrollbarHeight);
          scrollbarLeft = navigator.left - scrollbarHeight;
        }
        navigator.scrollbar.position(scrollbarLeft, scrollbarTop, navigatorWidth, scrollbarHeight);
        navigator.scrollbar.setRange(
          // Use real value, not rounded because range can be very small
          // (#1716)
          navigator.zoomedMin / (navigatorSize || 1),
          navigator.zoomedMax / (navigatorSize || 1)
        );
      }
      navigator.rendered = true;
    };
    Navigator2.prototype.addMouseEvents = function() {
      var navigator = this, chart = navigator.chart, container = chart.container, eventsToUnbind = [], mouseMoveHandler, mouseUpHandler;
      navigator.mouseMoveHandler = mouseMoveHandler = function(e2) {
        navigator.onMouseMove(e2);
      };
      navigator.mouseUpHandler = mouseUpHandler = function(e2) {
        navigator.onMouseUp(e2);
      };
      eventsToUnbind = navigator.getPartsEvents("mousedown");
      eventsToUnbind.push(addEvent26(chart.renderTo, "mousemove", mouseMoveHandler), addEvent26(container.ownerDocument, "mouseup", mouseUpHandler));
      if (hasTouch3) {
        eventsToUnbind.push(addEvent26(chart.renderTo, "touchmove", mouseMoveHandler), addEvent26(container.ownerDocument, "touchend", mouseUpHandler));
        eventsToUnbind.concat(navigator.getPartsEvents("touchstart"));
      }
      navigator.eventsToUnbind = eventsToUnbind;
      if (navigator.series && navigator.series[0]) {
        eventsToUnbind.push(addEvent26(navigator.series[0].xAxis, "foundExtremes", function() {
          chart.navigator.modifyNavigatorAxisExtremes();
        }));
      }
    };
    Navigator2.prototype.getPartsEvents = function(eventName) {
      var navigator = this, events = [];
      ["shades", "handles"].forEach(function(name) {
        navigator[name].forEach(function(navigatorItem, index) {
          events.push(addEvent26(navigatorItem.element, eventName, function(e2) {
            navigator[name + "Mousedown"](e2, index);
          }));
        });
      });
      return events;
    };
    Navigator2.prototype.shadesMousedown = function(e2, index) {
      e2 = this.chart.pointer.normalize(e2);
      var navigator = this, chart = navigator.chart, xAxis = navigator.xAxis, zoomedMin = navigator.zoomedMin, navigatorPosition = navigator.left, navigatorSize = navigator.size, range = navigator.range, chartX = e2.chartX, fixedMax, fixedMin, ext, left;
      if (chart.inverted) {
        chartX = e2.chartY;
        navigatorPosition = navigator.top;
      }
      if (index === 1) {
        navigator.grabbedCenter = chartX;
        navigator.fixedWidth = range;
        navigator.dragOffset = chartX - zoomedMin;
      } else {
        left = chartX - navigatorPosition - range / 2;
        if (index === 0) {
          left = Math.max(0, left);
        } else if (index === 2 && left + range >= navigatorSize) {
          left = navigatorSize - range;
          if (navigator.reversedExtremes) {
            left -= range;
            fixedMin = navigator.getUnionExtremes().dataMin;
          } else {
            fixedMax = navigator.getUnionExtremes().dataMax;
          }
        }
        if (left !== zoomedMin) {
          navigator.fixedWidth = range;
          ext = xAxis.navigatorAxis.toFixedRange(left, left + range, fixedMin, fixedMax);
          if (defined31(ext.min)) {
            chart.xAxis[0].setExtremes(
              Math.min(ext.min, ext.max),
              Math.max(ext.min, ext.max),
              true,
              null,
              // auto animation
              { trigger: "navigator" }
            );
          }
        }
      }
    };
    Navigator2.prototype.handlesMousedown = function(e2, index) {
      e2 = this.chart.pointer.normalize(e2);
      var navigator = this, chart = navigator.chart, baseXAxis = chart.xAxis[0], reverse = navigator.reversedExtremes;
      if (index === 0) {
        navigator.grabbedLeft = true;
        navigator.otherHandlePos = navigator.zoomedMax;
        navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;
      } else {
        navigator.grabbedRight = true;
        navigator.otherHandlePos = navigator.zoomedMin;
        navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;
      }
      chart.fixedRange = null;
    };
    Navigator2.prototype.onMouseMove = function(e2) {
      var navigator = this, chart = navigator.chart, left = navigator.left, navigatorSize = navigator.navigatorSize, range = navigator.range, dragOffset = navigator.dragOffset, inverted = chart.inverted, chartX;
      if (!e2.touches || e2.touches[0].pageX !== 0) {
        e2 = chart.pointer.normalize(e2);
        chartX = e2.chartX;
        if (inverted) {
          left = navigator.top;
          chartX = e2.chartY;
        }
        if (navigator.grabbedLeft) {
          navigator.hasDragged = true;
          navigator.render(0, 0, chartX - left, navigator.otherHandlePos);
        } else if (navigator.grabbedRight) {
          navigator.hasDragged = true;
          navigator.render(0, 0, navigator.otherHandlePos, chartX - left);
        } else if (navigator.grabbedCenter) {
          navigator.hasDragged = true;
          if (chartX < dragOffset) {
            chartX = dragOffset;
          } else if (chartX > navigatorSize + dragOffset - range) {
            chartX = navigatorSize + dragOffset - range;
          }
          navigator.render(0, 0, chartX - dragOffset, chartX - dragOffset + range);
        }
        if (navigator.hasDragged && navigator.scrollbar && pick43(
          navigator.scrollbar.options.liveRedraw,
          // By default, don't run live redraw on VML, on touch
          // devices or if the chart is in boost.
          Globals_default.svg && !isTouchDevice4 && !this.chart.isBoosting
        )) {
          e2.DOMType = e2.type;
          setTimeout(function() {
            navigator.onMouseUp(e2);
          }, 0);
        }
      }
    };
    Navigator2.prototype.onMouseUp = function(e2) {
      var navigator = this, chart = navigator.chart, xAxis = navigator.xAxis, scrollbar = navigator.scrollbar, DOMEvent = e2.DOMEvent || e2, inverted = chart.inverted, verb = navigator.rendered && !navigator.hasDragged ? "animate" : "attr", zoomedMax, zoomedMin, unionExtremes, fixedMin, fixedMax, ext;
      if (
        // MouseUp is called for both, navigator and scrollbar (that order),
        // which causes calling afterSetExtremes twice. Prevent first call
        // by checking if scrollbar is going to set new extremes (#6334)
        navigator.hasDragged && (!scrollbar || !scrollbar.hasDragged) || e2.trigger === "scrollbar"
      ) {
        unionExtremes = navigator.getUnionExtremes();
        if (navigator.zoomedMin === navigator.otherHandlePos) {
          fixedMin = navigator.fixedExtreme;
        } else if (navigator.zoomedMax === navigator.otherHandlePos) {
          fixedMax = navigator.fixedExtreme;
        }
        if (navigator.zoomedMax === navigator.size) {
          fixedMax = navigator.reversedExtremes ? unionExtremes.dataMin : unionExtremes.dataMax;
        }
        if (navigator.zoomedMin === 0) {
          fixedMin = navigator.reversedExtremes ? unionExtremes.dataMax : unionExtremes.dataMin;
        }
        ext = xAxis.navigatorAxis.toFixedRange(navigator.zoomedMin, navigator.zoomedMax, fixedMin, fixedMax);
        if (defined31(ext.min)) {
          chart.xAxis[0].setExtremes(
            Math.min(ext.min, ext.max),
            Math.max(ext.min, ext.max),
            true,
            // Run animation when clicking buttons, scrollbar track etc,
            // but not when dragging handles or scrollbar
            navigator.hasDragged ? false : null,
            {
              trigger: "navigator",
              triggerOp: "navigator-drag",
              DOMEvent
              // #1838
            }
          );
        }
      }
      if (e2.DOMType !== "mousemove" && e2.DOMType !== "touchmove") {
        navigator.grabbedLeft = navigator.grabbedRight = navigator.grabbedCenter = navigator.fixedWidth = navigator.fixedExtreme = navigator.otherHandlePos = navigator.hasDragged = navigator.dragOffset = null;
      }
      if (navigator.navigatorEnabled && isNumber29(navigator.zoomedMin) && isNumber29(navigator.zoomedMax)) {
        zoomedMin = Math.round(navigator.zoomedMin);
        zoomedMax = Math.round(navigator.zoomedMax);
        if (navigator.shades) {
          navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
        }
        if (navigator.outline) {
          navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
        }
        if (navigator.navigatorOptions.handles.enabled && Object.keys(navigator.handles).length === navigator.handles.length) {
          navigator.drawHandle(zoomedMin, 0, inverted, verb);
          navigator.drawHandle(zoomedMax, 1, inverted, verb);
        }
      }
    };
    Navigator2.prototype.removeEvents = function() {
      if (this.eventsToUnbind) {
        this.eventsToUnbind.forEach(function(unbind) {
          unbind();
        });
        this.eventsToUnbind = void 0;
      }
      this.removeBaseSeriesEvents();
    };
    Navigator2.prototype.removeBaseSeriesEvents = function() {
      var baseSeries = this.baseSeries || [];
      if (this.navigatorEnabled && baseSeries[0]) {
        if (this.navigatorOptions.adaptToUpdatedData !== false) {
          baseSeries.forEach(function(series) {
            removeEvent10(series, "updatedData", this.updatedDataHandler);
          }, this);
        }
        if (baseSeries[0].xAxis) {
          removeEvent10(baseSeries[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes);
        }
      }
    };
    Navigator2.prototype.init = function(chart) {
      var chartOptions = chart.options, navigatorOptions = chartOptions.navigator, navigatorEnabled = navigatorOptions.enabled, scrollbarOptions = chartOptions.scrollbar, scrollbarEnabled = scrollbarOptions.enabled, height = navigatorEnabled ? navigatorOptions.height : 0, scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;
      this.handles = [];
      this.shades = [];
      this.chart = chart;
      this.setBaseSeries();
      this.height = height;
      this.scrollbarHeight = scrollbarHeight;
      this.scrollbarEnabled = scrollbarEnabled;
      this.navigatorEnabled = navigatorEnabled;
      this.navigatorOptions = navigatorOptions;
      this.scrollbarOptions = scrollbarOptions;
      this.outlineHeight = height + scrollbarHeight;
      this.opposite = pick43(navigatorOptions.opposite, Boolean(!navigatorEnabled && chart.inverted));
      var navigator = this, baseSeries = navigator.baseSeries, xAxisIndex = chart.xAxis.length, yAxisIndex = chart.yAxis.length, baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis || chart.xAxis[0] || { options: {} };
      chart.isDirtyBox = true;
      if (navigator.navigatorEnabled) {
        navigator.xAxis = new Axis_default(chart, merge37({
          // inherit base xAxis' break and ordinal options
          breaks: baseXaxis.options.breaks,
          ordinal: baseXaxis.options.ordinal
        }, navigatorOptions.xAxis, {
          id: "navigator-x-axis",
          yAxis: "navigator-y-axis",
          isX: true,
          type: "datetime",
          index: xAxisIndex,
          isInternal: true,
          offset: 0,
          keepOrdinalPadding: true,
          startOnTick: false,
          endOnTick: false,
          minPadding: 0,
          maxPadding: 0,
          zoomEnabled: false
        }, chart.inverted ? {
          offsets: [scrollbarHeight, 0, -scrollbarHeight, 0],
          width: height
        } : {
          offsets: [0, -scrollbarHeight, 0, scrollbarHeight],
          height
        }));
        navigator.yAxis = new Axis_default(chart, merge37(navigatorOptions.yAxis, {
          id: "navigator-y-axis",
          alignTicks: false,
          offset: 0,
          index: yAxisIndex,
          isInternal: true,
          reversed: pick43(navigatorOptions.yAxis && navigatorOptions.yAxis.reversed, chart.yAxis[0] && chart.yAxis[0].reversed, false),
          zoomEnabled: false
        }, chart.inverted ? {
          width: height
        } : {
          height
        }));
        if (baseSeries || navigatorOptions.series.data) {
          navigator.updateNavigatorSeries(false);
        } else if (chart.series.length === 0) {
          navigator.unbindRedraw = addEvent26(chart, "beforeRedraw", function() {
            if (chart.series.length > 0 && !navigator.series) {
              navigator.setBaseSeries();
              navigator.unbindRedraw();
            }
          });
        }
        navigator.reversedExtremes = chart.inverted && !navigator.xAxis.reversed || !chart.inverted && navigator.xAxis.reversed;
        navigator.renderElements();
        navigator.addMouseEvents();
      } else {
        navigator.xAxis = {
          chart,
          navigatorAxis: {
            fake: true
          },
          translate: function(value, reverse) {
            var axis = chart.xAxis[0], ext = axis.getExtremes(), scrollTrackWidth = axis.len - 2 * scrollbarHeight, min = numExt("min", axis.options.min, ext.dataMin), valueRange = numExt("max", axis.options.max, ext.dataMax) - min;
            return reverse ? (
              // from pixel to value
              value * valueRange / scrollTrackWidth + min
            ) : (
              // from value to pixel
              scrollTrackWidth * (value - min) / valueRange
            );
          },
          toPixels: function(value) {
            return this.translate(value);
          },
          toValue: function(value) {
            return this.translate(value, true);
          }
        };
        navigator.xAxis.navigatorAxis.axis = navigator.xAxis;
        navigator.xAxis.navigatorAxis.toFixedRange = NavigatorAxis_default.AdditionsClass.prototype.toFixedRange.bind(navigator.xAxis.navigatorAxis);
      }
      if (chart.options.scrollbar.enabled) {
        chart.scrollbar = navigator.scrollbar = new Scrollbar_default(chart.renderer, merge37(chart.options.scrollbar, {
          margin: navigator.navigatorEnabled ? 0 : 10,
          vertical: chart.inverted
        }), chart);
        addEvent26(navigator.scrollbar, "changed", function(e2) {
          var range = navigator.size, to = range * this.to, from = range * this.from;
          navigator.hasDragged = navigator.scrollbar.hasDragged;
          navigator.render(0, 0, from, to);
          if (this.shouldUpdateExtremes(e2.DOMType)) {
            setTimeout(function() {
              navigator.onMouseUp(e2);
            });
          }
        });
      }
      navigator.addBaseSeriesEvents();
      navigator.addChartEvents();
    };
    Navigator2.prototype.getUnionExtremes = function(returnFalseOnNoBaseSeries) {
      var baseAxis = this.chart.xAxis[0], navAxis = this.xAxis, navAxisOptions = navAxis.options, baseAxisOptions = baseAxis.options, ret;
      if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
        ret = {
          dataMin: pick43(
            // #4053
            navAxisOptions && navAxisOptions.min,
            numExt("min", baseAxisOptions.min, baseAxis.dataMin, navAxis.dataMin, navAxis.min)
          ),
          dataMax: pick43(navAxisOptions && navAxisOptions.max, numExt("max", baseAxisOptions.max, baseAxis.dataMax, navAxis.dataMax, navAxis.max))
        };
      }
      return ret;
    };
    Navigator2.prototype.setBaseSeries = function(baseSeriesOptions, redraw) {
      var chart = this.chart, baseSeries = this.baseSeries = [];
      baseSeriesOptions = baseSeriesOptions || chart.options && chart.options.navigator.baseSeries || (chart.series.length ? (
        // Find the first non-navigator series (#8430)
        find8(chart.series, function(s) {
          return !s.options.isInternal;
        }).index
      ) : 0);
      (chart.series || []).forEach(function(series, i) {
        if (
          // Don't include existing nav series
          !series.options.isInternal && (series.options.showInNavigator || (i === baseSeriesOptions || series.options.id === baseSeriesOptions) && series.options.showInNavigator !== false)
        ) {
          baseSeries.push(series);
        }
      });
      if (this.xAxis && !this.xAxis.navigatorAxis.fake) {
        this.updateNavigatorSeries(true, redraw);
      }
    };
    Navigator2.prototype.updateNavigatorSeries = function(addEvents, redraw) {
      var navigator = this, chart = navigator.chart, baseSeries = navigator.baseSeries, baseOptions, mergedNavSeriesOptions, chartNavigatorSeriesOptions = navigator.navigatorOptions.series, baseNavigatorOptions, navSeriesMixin = {
        enableMouseTracking: false,
        index: null,
        linkedTo: null,
        group: "nav",
        padXAxis: false,
        xAxis: "navigator-x-axis",
        yAxis: "navigator-y-axis",
        showInLegend: false,
        stacking: void 0,
        isInternal: true,
        states: {
          inactive: {
            opacity: 1
          }
        }
      }, navigatorSeries = navigator.series = (navigator.series || []).filter(function(navSeries) {
        var base = navSeries.baseSeries;
        if (baseSeries.indexOf(base) < 0) {
          if (base) {
            removeEvent10(base, "updatedData", navigator.updatedDataHandler);
            delete base.navigatorSeries;
          }
          if (navSeries.chart) {
            navSeries.destroy();
          }
          return false;
        }
        return true;
      });
      if (baseSeries && baseSeries.length) {
        baseSeries.forEach(function eachBaseSeries(base) {
          var linkedNavSeries = base.navigatorSeries, userNavOptions = extend28(
            // Grab color and visibility from base as default
            {
              color: base.color,
              visible: base.visible
            },
            !isArray16(chartNavigatorSeriesOptions) ? chartNavigatorSeriesOptions : defaultOptions10.navigator.series
          );
          if (linkedNavSeries && navigator.navigatorOptions.adaptToUpdatedData === false) {
            return;
          }
          navSeriesMixin.name = "Navigator " + baseSeries.length;
          baseOptions = base.options || {};
          baseNavigatorOptions = baseOptions.navigatorOptions || {};
          userNavOptions.dataLabels = splat11(userNavOptions.dataLabels);
          mergedNavSeriesOptions = merge37(baseOptions, navSeriesMixin, userNavOptions, baseNavigatorOptions);
          mergedNavSeriesOptions.pointRange = pick43(
            // Stricte set pointRange in options
            userNavOptions.pointRange,
            baseNavigatorOptions.pointRange,
            // Fallback to default values, e.g. `null` for column
            defaultOptions10.plotOptions[mergedNavSeriesOptions.type || "line"].pointRange
          );
          var navigatorSeriesData = baseNavigatorOptions.data || userNavOptions.data;
          navigator.hasNavigatorData = navigator.hasNavigatorData || !!navigatorSeriesData;
          mergedNavSeriesOptions.data = navigatorSeriesData || baseOptions.data && baseOptions.data.slice(0);
          if (linkedNavSeries && linkedNavSeries.options) {
            linkedNavSeries.update(mergedNavSeriesOptions, redraw);
          } else {
            base.navigatorSeries = chart.initSeries(mergedNavSeriesOptions);
            base.navigatorSeries.baseSeries = base;
            navigatorSeries.push(base.navigatorSeries);
          }
        });
      }
      if (chartNavigatorSeriesOptions.data && !(baseSeries && baseSeries.length) || isArray16(chartNavigatorSeriesOptions)) {
        navigator.hasNavigatorData = false;
        chartNavigatorSeriesOptions = splat11(chartNavigatorSeriesOptions);
        chartNavigatorSeriesOptions.forEach(function(userSeriesOptions, i) {
          navSeriesMixin.name = "Navigator " + (navigatorSeries.length + 1);
          mergedNavSeriesOptions = merge37(defaultOptions10.navigator.series, {
            // Since we don't have a base series to pull color from,
            // try to fake it by using color from series with same
            // index. Otherwise pull from the colors array. We need
            // an explicit color as otherwise updates will increment
            // color counter and we'll get a new color for each
            // update of the nav series.
            color: chart.series[i] && !chart.series[i].options.isInternal && chart.series[i].color || chart.options.colors[i] || chart.options.colors[0]
          }, navSeriesMixin, userSeriesOptions);
          mergedNavSeriesOptions.data = userSeriesOptions.data;
          if (mergedNavSeriesOptions.data) {
            navigator.hasNavigatorData = true;
            navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions));
          }
        });
      }
      if (addEvents) {
        this.addBaseSeriesEvents();
      }
    };
    Navigator2.prototype.addBaseSeriesEvents = function() {
      var navigator = this, baseSeries = navigator.baseSeries || [];
      if (baseSeries[0] && baseSeries[0].xAxis) {
        baseSeries[0].eventsToUnbind.push(addEvent26(baseSeries[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
      }
      baseSeries.forEach(function(base) {
        base.eventsToUnbind.push(addEvent26(base, "show", function() {
          if (this.navigatorSeries) {
            this.navigatorSeries.setVisible(true, false);
          }
        }));
        base.eventsToUnbind.push(addEvent26(base, "hide", function() {
          if (this.navigatorSeries) {
            this.navigatorSeries.setVisible(false, false);
          }
        }));
        if (this.navigatorOptions.adaptToUpdatedData !== false) {
          if (base.xAxis) {
            base.eventsToUnbind.push(addEvent26(base, "updatedData", this.updatedDataHandler));
          }
        }
        base.eventsToUnbind.push(addEvent26(base, "remove", function() {
          if (this.navigatorSeries) {
            erase9(navigator.series, this.navigatorSeries);
            if (defined31(this.navigatorSeries.options)) {
              this.navigatorSeries.remove(false);
            }
            delete this.navigatorSeries;
          }
        }));
      }, this);
    };
    Navigator2.prototype.getBaseSeriesMin = function(currentSeriesMin) {
      return this.baseSeries.reduce(function(min, series) {
        return Math.min(min, series.xData ? series.xData[0] : min);
      }, currentSeriesMin);
    };
    Navigator2.prototype.modifyNavigatorAxisExtremes = function() {
      var xAxis = this.xAxis, unionExtremes;
      if (typeof xAxis.getExtremes !== "undefined") {
        unionExtremes = this.getUnionExtremes(true);
        if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {
          xAxis.min = unionExtremes.dataMin;
          xAxis.max = unionExtremes.dataMax;
        }
      }
    };
    Navigator2.prototype.modifyBaseAxisExtremes = function() {
      var baseXAxis = this, navigator = baseXAxis.chart.navigator, baseExtremes = baseXAxis.getExtremes(), baseMin = baseExtremes.min, baseMax = baseExtremes.max, baseDataMin = baseExtremes.dataMin, baseDataMax = baseExtremes.dataMax, range = baseMax - baseMin, stickToMin = navigator.stickToMin, stickToMax = navigator.stickToMax, overscroll = pick43(baseXAxis.options.overscroll, 0), newMax, newMin, navigatorSeries = navigator.series && navigator.series[0], hasSetExtremes = !!baseXAxis.setExtremes, unmutable = baseXAxis.eventArgs && baseXAxis.eventArgs.trigger === "rangeSelectorButton";
      if (!unmutable) {
        if (stickToMin) {
          newMin = baseDataMin;
          newMax = newMin + range;
        }
        if (stickToMax) {
          newMax = baseDataMax + overscroll;
          if (!stickToMin) {
            newMin = Math.max(
              baseDataMin,
              // don't go below data extremes (#13184)
              newMax - range,
              navigator.getBaseSeriesMin(navigatorSeries && navigatorSeries.xData ? navigatorSeries.xData[0] : -Number.MAX_VALUE)
            );
          }
        }
        if (hasSetExtremes && (stickToMin || stickToMax)) {
          if (isNumber29(newMin)) {
            baseXAxis.min = baseXAxis.userMin = newMin;
            baseXAxis.max = baseXAxis.userMax = newMax;
          }
        }
      }
      navigator.stickToMin = navigator.stickToMax = null;
    };
    Navigator2.prototype.updatedDataHandler = function() {
      var navigator = this.chart.navigator, baseSeries = this, navigatorSeries = this.navigatorSeries;
      navigator.stickToMax = navigator.reversedExtremes ? Math.round(navigator.zoomedMin) === 0 : Math.round(navigator.zoomedMax) >= Math.round(navigator.size);
      navigator.stickToMin = navigator.shouldStickToMin(baseSeries, navigator);
      if (navigatorSeries && !navigator.hasNavigatorData) {
        navigatorSeries.options.pointStart = baseSeries.xData[0];
        navigatorSeries.setData(baseSeries.options.data, false, null, false);
      }
    };
    Navigator2.prototype.shouldStickToMin = function(baseSeries, navigator) {
      var xDataMin = navigator.getBaseSeriesMin(baseSeries.xData[0]), xAxis = baseSeries.xAxis, max = xAxis.max, min = xAxis.min, range = xAxis.options.range;
      var stickToMin = true;
      if (isNumber29(max) && isNumber29(min)) {
        if (range && max - xDataMin > 0) {
          stickToMin = max - xDataMin < range && !this.chart.fixedRange;
        } else {
          stickToMin = min <= xDataMin;
        }
      } else {
        stickToMin = false;
      }
      return stickToMin;
    };
    Navigator2.prototype.addChartEvents = function() {
      if (!this.eventsToUnbind) {
        this.eventsToUnbind = [];
      }
      this.eventsToUnbind.push(
        // Move the scrollbar after redraw, like after data updata even if
        // axes don't redraw
        addEvent26(this.chart, "redraw", function() {
          var navigator = this.navigator, xAxis = navigator && (navigator.baseSeries && navigator.baseSeries[0] && navigator.baseSeries[0].xAxis || this.xAxis[0]);
          if (xAxis) {
            navigator.render(xAxis.min, xAxis.max);
          }
        }),
        // Make room for the navigator, can be placed around the chart:
        addEvent26(this.chart, "getMargins", function() {
          var chart = this, navigator = chart.navigator, marginName = navigator.opposite ? "plotTop" : "marginBottom";
          if (chart.inverted) {
            marginName = navigator.opposite ? "marginRight" : "plotLeft";
          }
          chart[marginName] = (chart[marginName] || 0) + (navigator.navigatorEnabled || !chart.inverted ? navigator.outlineHeight : 0) + navigator.navigatorOptions.margin;
        })
      );
    };
    Navigator2.prototype.destroy = function() {
      this.removeEvents();
      if (this.xAxis) {
        erase9(this.chart.xAxis, this.xAxis);
        erase9(this.chart.axes, this.xAxis);
      }
      if (this.yAxis) {
        erase9(this.chart.yAxis, this.yAxis);
        erase9(this.chart.axes, this.yAxis);
      }
      (this.series || []).forEach(function(s) {
        if (s.destroy) {
          s.destroy();
        }
      });
      [
        "series",
        "xAxis",
        "yAxis",
        "shades",
        "outline",
        "scrollbarTrack",
        "scrollbarRifles",
        "scrollbarGroup",
        "scrollbar",
        "navigatorGroup",
        "rendered"
      ].forEach(function(prop) {
        if (this[prop] && this[prop].destroy) {
          this[prop].destroy();
        }
        this[prop] = null;
      }, this);
      [this.handles].forEach(function(coll) {
        destroyObjectProperties9(coll);
      }, this);
    };
    return Navigator2;
  }()
);
if (!Globals_default.Navigator) {
  Globals_default.Navigator = Navigator;
  NavigatorAxis_default.compose(Axis_default);
  addEvent26(Chart_default, "beforeShowResetZoom", function() {
    var chartOptions = this.options, navigator = chartOptions.navigator, rangeSelector = chartOptions.rangeSelector;
    if ((navigator && navigator.enabled || rangeSelector && rangeSelector.enabled) && (!isTouchDevice4 && chartOptions.chart.zoomType === "x" || isTouchDevice4 && chartOptions.chart.pinchType === "x")) {
      return false;
    }
  });
  addEvent26(Chart_default, "beforeRender", function() {
    var options = this.options;
    if (options.navigator.enabled || options.scrollbar.enabled) {
      this.scroller = this.navigator = new Navigator(this);
    }
  });
  addEvent26(Chart_default, "afterSetChartSize", function() {
    var legend = this.legend, navigator = this.navigator, scrollbarHeight, legendOptions, xAxis, yAxis;
    if (navigator) {
      legendOptions = legend && legend.options;
      xAxis = navigator.xAxis;
      yAxis = navigator.yAxis;
      scrollbarHeight = navigator.scrollbarHeight;
      if (this.inverted) {
        navigator.left = navigator.opposite ? this.chartWidth - scrollbarHeight - navigator.height : this.spacing[3] + scrollbarHeight;
        navigator.top = this.plotTop + scrollbarHeight;
      } else {
        navigator.left = pick43(xAxis.left, this.plotLeft + scrollbarHeight);
        navigator.top = navigator.navigatorOptions.top || this.chartHeight - navigator.height - scrollbarHeight - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (legendOptions && legendOptions.verticalAlign === "bottom" && legendOptions.layout !== "proximate" && // #13392
        legendOptions.enabled && !legendOptions.floating ? legend.legendHeight + pick43(legendOptions.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0);
      }
      if (xAxis && yAxis) {
        if (this.inverted) {
          xAxis.options.left = yAxis.options.left = navigator.left;
        } else {
          xAxis.options.top = yAxis.options.top = navigator.top;
        }
        xAxis.setAxisSize();
        yAxis.setAxisSize();
      }
    }
  });
  addEvent26(Chart_default, "update", function(e2) {
    var navigatorOptions = e2.options.navigator || {}, scrollbarOptions = e2.options.scrollbar || {};
    if (!this.navigator && !this.scroller && (navigatorOptions.enabled || scrollbarOptions.enabled)) {
      merge37(true, this.options.navigator, navigatorOptions);
      merge37(true, this.options.scrollbar, scrollbarOptions);
      delete e2.options.navigator;
      delete e2.options.scrollbar;
    }
  });
  addEvent26(Chart_default, "afterUpdate", function(event) {
    if (!this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled)) {
      this.scroller = this.navigator = new Navigator(this);
      if (pick43(event.redraw, true)) {
        this.redraw(event.animation);
      }
    }
  });
  addEvent26(Chart_default, "afterAddSeries", function() {
    if (this.navigator) {
      this.navigator.setBaseSeries(null, false);
    }
  });
  addEvent26(Series_default, "afterUpdate", function() {
    if (this.chart.navigator && !this.options.isInternal) {
      this.chart.navigator.setBaseSeries(null, false);
    }
  });
  Chart_default.prototype.callbacks.push(function(chart) {
    var extremes, navigator = chart.navigator;
    if (navigator && chart.xAxis[0]) {
      extremes = chart.xAxis[0].getExtremes();
      navigator.render(extremes.min, extremes.max);
    }
  });
}
Globals_default.Navigator = Navigator;
var Navigator_default = Globals_default.Navigator;

// node_modules/highcharts/es-modules/Extensions/RangeSelector.js
var defaultOptions11 = DefaultOptions_default.defaultOptions;
var addEvent27 = Utilities_default.addEvent;
var createElement9 = Utilities_default.createElement;
var css13 = Utilities_default.css;
var defined32 = Utilities_default.defined;
var destroyObjectProperties10 = Utilities_default.destroyObjectProperties;
var discardElement6 = Utilities_default.discardElement;
var extend29 = Utilities_default.extend;
var find9 = Utilities_default.find;
var fireEvent19 = Utilities_default.fireEvent;
var isNumber30 = Utilities_default.isNumber;
var merge38 = Utilities_default.merge;
var objectEach25 = Utilities_default.objectEach;
var pad3 = Utilities_default.pad;
var pick44 = Utilities_default.pick;
var pInt8 = Utilities_default.pInt;
var splat12 = Utilities_default.splat;
extend29(defaultOptions11, {
  /**
   * The range selector is a tool for selecting ranges to display within
   * the chart. It provides buttons to select preconfigured ranges in
   * the chart, like 1 day, 1 week, 1 month etc. It also provides input
   * boxes where min and max dates can be manually input.
   *
   * @product      highstock gantt
   * @optionparent rangeSelector
   */
  rangeSelector: {
    /**
     * Whether to enable all buttons from the start. By default buttons are
     * only enabled if the corresponding time range exists on the X axis,
     * but enabling all buttons allows for dynamically loading different
     * time ranges.
     *
     * @sample {highstock} stock/rangeselector/allbuttonsenabled-true/
     *         All buttons enabled
     *
     * @since     2.0.3
     */
    allButtonsEnabled: false,
    /**
     * An array of configuration objects for the buttons.
     *
     * Defaults to:
     * ```js
     * buttons: [{
     *     type: 'month',
     *     count: 1,
     *     text: '1m',
     *     title: 'View 1 month'
     * }, {
     *     type: 'month',
     *     count: 3,
     *     text: '3m',
     *     title: 'View 3 months'
     * }, {
     *     type: 'month',
     *     count: 6,
     *     text: '6m',
     *     title: 'View 6 months'
     * }, {
     *     type: 'ytd',
     *     text: 'YTD',
     *     title: 'View year to date'
     * }, {
     *     type: 'year',
     *     count: 1,
     *     text: '1y',
     *     title: 'View 1 year'
     * }, {
     *     type: 'all',
     *     text: 'All',
     *     title: 'View all'
     * }]
     * ```
     *
     * @sample {highstock} stock/rangeselector/datagrouping/
     *         Data grouping by buttons
     *
     * @type      {Array<*>}
     */
    buttons: void 0,
    /**
     * How many units of the defined type the button should span. If `type`
     * is "month" and `count` is 3, the button spans three months.
     *
     * @type      {number}
     * @default   1
     * @apioption rangeSelector.buttons.count
     */
    /**
     * Fires when clicking on the rangeSelector button. One parameter,
     * event, is passed to the function, containing common event
     * information.
     *
     * ```js
     * click: function(e) {
     *   console.log(this);
     * }
     * ```
     *
     * Return false to stop default button's click action.
     *
     * @sample {highstock} stock/rangeselector/button-click/
     *         Click event on the button
     *
     * @type      {Highcharts.RangeSelectorClickCallbackFunction}
     * @apioption rangeSelector.buttons.events.click
     */
    /**
     * Additional range (in milliseconds) added to the end of the calculated
     * time span.
     *
     * @sample {highstock} stock/rangeselector/min-max-offsets/
     *         Button offsets
     *
     * @type      {number}
     * @default   0
     * @since     6.0.0
     * @apioption rangeSelector.buttons.offsetMax
     */
    /**
     * Additional range (in milliseconds) added to the start of the
     * calculated time span.
     *
     * @sample {highstock} stock/rangeselector/min-max-offsets/
     *         Button offsets
     *
     * @type      {number}
     * @default   0
     * @since     6.0.0
     * @apioption rangeSelector.buttons.offsetMin
     */
    /**
     * When buttons apply dataGrouping on a series, by default zooming
     * in/out will deselect buttons and unset dataGrouping. Enable this
     * option to keep buttons selected when extremes change.
     *
     * @sample {highstock} stock/rangeselector/preserve-datagrouping/
     *         Different preserveDataGrouping settings
     *
     * @type      {boolean}
     * @default   false
     * @since     6.1.2
     * @apioption rangeSelector.buttons.preserveDataGrouping
     */
    /**
     * A custom data grouping object for each button.
     *
     * @see [series.dataGrouping](#plotOptions.series.dataGrouping)
     *
     * @sample {highstock} stock/rangeselector/datagrouping/
     *         Data grouping by range selector buttons
     *
     * @type      {*}
     * @extends   plotOptions.series.dataGrouping
     * @apioption rangeSelector.buttons.dataGrouping
     */
    /**
     * The text for the button itself.
     *
     * @type      {string}
     * @apioption rangeSelector.buttons.text
     */
    /**
     * Explanation for the button, shown as a tooltip on hover, and used by
     * assistive technology.
     *
     * @type      {string}
     * @apioption rangeSelector.buttons.title
     */
    /**
     * Defined the time span for the button. Can be one of `millisecond`,
     * `second`, `minute`, `hour`, `day`, `week`, `month`, `year`, `ytd`,
     * and `all`.
     *
     * @type       {Highcharts.RangeSelectorButtonTypeValue}
     * @apioption  rangeSelector.buttons.type
     */
    /**
     * The space in pixels between the buttons in the range selector.
     */
    buttonSpacing: 5,
    /**
     * Whether to collapse the range selector buttons into a dropdown when
     * there is not enough room to show everything in a single row, instead
     * of dividing the range selector into multiple rows.
     * Can be one of the following:
     *  - `always`: Always collapse
     *  - `responsive`: Only collapse when there is not enough room
     *  - `never`: Never collapse
     *
     * @sample {highstock} stock/rangeselector/dropdown/
     *         Dropdown option
     *
     * @validvalue ["always", "responsive", "never"]
     * @since 9.0.0
     */
    dropdown: "responsive",
    /**
     * Enable or disable the range selector. Default to `true` for stock
     * charts, using the `stockChart` factory.
     *
     * @sample {highstock} stock/rangeselector/enabled/
     *         Disable the range selector
     *
     * @type {boolean|undefined}
     * @default {highstock} true
     */
    enabled: void 0,
    /**
     * The vertical alignment of the rangeselector box. Allowed properties
     * are `top`, `middle`, `bottom`.
     *
     * @sample {highstock} stock/rangeselector/vertical-align-middle/
     *         Middle
     * @sample {highstock} stock/rangeselector/vertical-align-bottom/
     *         Bottom
     *
     * @type  {Highcharts.VerticalAlignValue}
     * @since 6.0.0
     */
    verticalAlign: "top",
    /**
     * A collection of attributes for the buttons. The object takes SVG
     * attributes like `fill`, `stroke`, `stroke-width`, as well as `style`,
     * a collection of CSS properties for the text.
     *
     * The object can also be extended with states, so you can set
     * presentational options for `hover`, `select` or `disabled` button
     * states.
     *
     * CSS styles for the text label.
     *
     * In styled mode, the buttons are styled by the
     * `.highcharts-range-selector-buttons .highcharts-button` rule with its
     * different states.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @type {Highcharts.SVGAttributes}
     */
    buttonTheme: {
      /** @ignore */
      width: 28,
      /** @ignore */
      height: 18,
      /** @ignore */
      padding: 2,
      /** @ignore */
      zIndex: 7
      // #484, #852
    },
    /**
     * When the rangeselector is floating, the plot area does not reserve
     * space for it. This opens for positioning anywhere on the chart.
     *
     * @sample {highstock} stock/rangeselector/floating/
     *         Placing the range selector between the plot area and the
     *         navigator
     *
     * @since 6.0.0
     */
    floating: false,
    /**
     * The x offset of the range selector relative to its horizontal
     * alignment within `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @since 6.0.0
     */
    x: 0,
    /**
     * The y offset of the range selector relative to its horizontal
     * alignment within `chart.spacingLeft` and `chart.spacingRight`.
     *
     * @since 6.0.0
     */
    y: 0,
    /**
     * Deprecated. The height of the range selector. Currently it is
     * calculated dynamically.
     *
     * @deprecated
     * @type  {number|undefined}
     * @since 2.1.9
     */
    height: void 0,
    /**
     * The border color of the date input boxes.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @type      {Highcharts.ColorString}
     * @since     1.3.7
     */
    inputBoxBorderColor: "none",
    /**
     * The pixel height of the date input boxes.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @since     1.3.7
     */
    inputBoxHeight: 17,
    /**
     * The pixel width of the date input boxes. When `undefined`, the width
     * is fitted to the rendered content.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @type   {number|undefined}
     * @since  1.3.7
     */
    inputBoxWidth: void 0,
    /**
     * The date format in the input boxes when not selected for editing.
     * Defaults to `%b %e, %Y`.
     *
     * This is used to determine which type of input to show,
     * `datetime-local`, `date` or `time` and falling back to `text` when
     * the browser does not support the input type or the format contains
     * milliseconds.
     *
     * @sample {highstock} stock/rangeselector/input-type/
     *         Input types
     * @sample {highstock} stock/rangeselector/input-format/
     *         Milliseconds in the range selector
     *
     */
    inputDateFormat: "%b %e, %Y",
    /**
     * A custom callback function to parse values entered in the input boxes
     * and return a valid JavaScript time as milliseconds since 1970.
     * The first argument passed is a value to parse,
     * second is a boolean indicating use of the UTC time.
     *
     * This will only get called for inputs of type `text`. Since v8.2.3,
     * the input type is dynamically determined based on the granularity
     * of the `inputDateFormat` and the browser support.
     *
     * @sample {highstock} stock/rangeselector/input-format/
     *         Milliseconds in the range selector
     *
     * @type      {Highcharts.RangeSelectorParseCallbackFunction}
     * @since     1.3.3
     */
    inputDateParser: void 0,
    /**
     * The date format in the input boxes when they are selected for
     * editing. This must be a format that is recognized by JavaScript
     * Date.parse.
     *
     * This will only be used for inputs of type `text`. Since v8.2.3,
     * the input type is dynamically determined based on the granularity
     * of the `inputDateFormat` and the browser support.
     *
     * @sample {highstock} stock/rangeselector/input-format/
     *         Milliseconds in the range selector
     *
     */
    inputEditDateFormat: "%Y-%m-%d",
    /**
     * Enable or disable the date input boxes.
     */
    inputEnabled: true,
    /**
     * Positioning for the input boxes. Allowed properties are `align`,
     *  `x` and `y`.
     *
     * @since 1.2.4
     */
    inputPosition: {
      /**
       * The alignment of the input box. Allowed properties are `left`,
       * `center`, `right`.
       *
       * @sample {highstock} stock/rangeselector/input-button-position/
       *         Alignment
       *
       * @type  {Highcharts.AlignValue}
       * @since 6.0.0
       */
      align: "right",
      /**
       * X offset of the input row.
       */
      x: 0,
      /**
       * Y offset of the input row.
       */
      y: 0
    },
    /**
     * The space in pixels between the labels and the date input boxes in
     * the range selector.
     *
     * @since 9.0.0
     */
    inputSpacing: 5,
    /**
     * The index of the button to appear pre-selected.
     *
     * @type      {number}
     */
    selected: void 0,
    /**
     * Positioning for the button row.
     *
     * @since 1.2.4
     */
    buttonPosition: {
      /**
       * The alignment of the input box. Allowed properties are `left`,
       * `center`, `right`.
       *
       * @sample {highstock} stock/rangeselector/input-button-position/
       *         Alignment
       *
       * @type  {Highcharts.AlignValue}
       * @since 6.0.0
       */
      align: "left",
      /**
       * X offset of the button row.
       */
      x: 0,
      /**
       * Y offset of the button row.
       */
      y: 0
    },
    /**
     * CSS for the HTML inputs in the range selector.
     *
     * In styled mode, the inputs are styled by the
     * `.highcharts-range-input text` rule in SVG mode, and
     * `input.highcharts-range-selector` when active.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @type      {Highcharts.CSSObject}
     * @apioption rangeSelector.inputStyle
     */
    inputStyle: {
      /** @ignore */
      color: Palette_default.highlightColor80,
      /** @ignore */
      cursor: "pointer"
    },
    /**
     * CSS styles for the labels - the Zoom, From and To texts.
     *
     * In styled mode, the labels are styled by the
     * `.highcharts-range-label` class.
     *
     * @sample {highstock} stock/rangeselector/styling/
     *         Styling the buttons and inputs
     *
     * @type {Highcharts.CSSObject}
     */
    labelStyle: {
      /** @ignore */
      color: Palette_default.neutralColor60
    }
  }
});
extend29(
  defaultOptions11.lang,
  /**
   * Language object. The language object is global and it can't be set
   * on each chart initialization. Instead, use `Highcharts.setOptions` to
   * set it before any chart is initialized.
   *
   * ```js
   * Highcharts.setOptions({
   *     lang: {
   *         months: [
   *             'Janvier', 'Fvrier', 'Mars', 'Avril',
   *             'Mai', 'Juin', 'Juillet', 'Aot',
   *             'Septembre', 'Octobre', 'Novembre', 'Dcembre'
   *         ],
   *         weekdays: [
   *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
   *             'Jeudi', 'Vendredi', 'Samedi'
   *         ]
   *     }
   * });
   * ```
   *
   * @optionparent lang
   */
  {
    /**
     * The text for the label for the range selector buttons.
     *
     * @product highstock gantt
     */
    rangeSelectorZoom: "Zoom",
    /**
     * The text for the label for the "from" input box in the range
     * selector. Since v9.0, this string is empty as the label is not
     * rendered by default.
     *
     * @product highstock gantt
     */
    rangeSelectorFrom: "",
    /**
     * The text for the label for the "to" input box in the range selector.
     *
     * @product highstock gantt
     */
    rangeSelectorTo: ""
  }
);
var RangeSelector = (
  /** @class */
  function() {
    function RangeSelector2(chart) {
      this.buttons = void 0;
      this.buttonOptions = RangeSelector2.prototype.defaultButtons;
      this.initialButtonGroupWidth = 0;
      this.options = void 0;
      this.chart = chart;
      this.init(chart);
    }
    RangeSelector2.prototype.clickButton = function(i, redraw) {
      var rangeSelector = this, chart = rangeSelector.chart, rangeOptions = rangeSelector.buttonOptions[i], baseAxis = chart.xAxis[0], unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis || {}, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, newMin, newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick44(dataMax, baseAxis.max))), type = rangeOptions.type, baseXAxisOptions, range = rangeOptions._range, rangeMin, minSetting, rangeSetting, ctx, ytdExtremes, dataGrouping2 = rangeOptions.dataGrouping;
      if (dataMin === null || dataMax === null) {
        return;
      }
      chart.fixedRange = range;
      rangeSelector.setSelected(i);
      if (dataGrouping2) {
        this.forcedDataGrouping = true;
        Axis_default.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping2, false);
        this.frozenStates = rangeOptions.preserveDataGrouping;
      }
      if (type === "month" || type === "year") {
        if (!baseAxis) {
          range = rangeOptions;
        } else {
          ctx = {
            range: rangeOptions,
            max: newMax,
            chart,
            dataMin,
            dataMax
          };
          newMin = baseAxis.minFromRange.call(ctx);
          if (isNumber30(ctx.newMax)) {
            newMax = ctx.newMax;
          }
        }
      } else if (range) {
        newMin = Math.max(newMax - range, dataMin);
        newMax = Math.min(newMin + range, dataMax);
      } else if (type === "ytd") {
        if (baseAxis) {
          if (typeof dataMax === "undefined") {
            dataMin = Number.MAX_VALUE;
            dataMax = Number.MIN_VALUE;
            chart.series.forEach(function(series) {
              var xData = series.xData;
              dataMin = Math.min(xData[0], dataMin);
              dataMax = Math.max(xData[xData.length - 1], dataMax);
            });
            redraw = false;
          }
          ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC);
          newMin = rangeMin = ytdExtremes.min;
          newMax = ytdExtremes.max;
        } else {
          rangeSelector.deferredYTDClick = i;
          return;
        }
      } else if (type === "all" && baseAxis) {
        if (chart.navigator && chart.navigator.baseSeries[0]) {
          chart.navigator.baseSeries[0].xAxis.options.range = void 0;
        }
        newMin = dataMin;
        newMax = dataMax;
      }
      if (defined32(newMin)) {
        newMin += rangeOptions._offsetMin;
      }
      if (defined32(newMax)) {
        newMax += rangeOptions._offsetMax;
      }
      if (this.dropdown) {
        this.dropdown.selectedIndex = i + 1;
      }
      if (!baseAxis) {
        baseXAxisOptions = splat12(chart.options.xAxis)[0];
        rangeSetting = baseXAxisOptions.range;
        baseXAxisOptions.range = range;
        minSetting = baseXAxisOptions.min;
        baseXAxisOptions.min = rangeMin;
        addEvent27(chart, "load", function resetMinAndRange() {
          baseXAxisOptions.range = rangeSetting;
          baseXAxisOptions.min = minSetting;
        });
      } else {
        baseAxis.setExtremes(
          newMin,
          newMax,
          pick44(redraw, true),
          void 0,
          // auto animation
          {
            trigger: "rangeSelectorButton",
            rangeSelectorButton: rangeOptions
          }
        );
      }
      fireEvent19(this, "afterBtnClick");
    };
    RangeSelector2.prototype.setSelected = function(selected) {
      this.selected = this.options.selected = selected;
    };
    RangeSelector2.prototype.init = function(chart) {
      var rangeSelector = this, options = chart.options.rangeSelector, buttonOptions = options.buttons || rangeSelector.defaultButtons.slice(), selectedOption = options.selected, blurInputs = function() {
        var minInput = rangeSelector.minInput, maxInput = rangeSelector.maxInput;
        if (minInput && minInput.blur) {
          fireEvent19(minInput, "blur");
        }
        if (maxInput && maxInput.blur) {
          fireEvent19(maxInput, "blur");
        }
      };
      rangeSelector.chart = chart;
      rangeSelector.options = options;
      rangeSelector.buttons = [];
      rangeSelector.buttonOptions = buttonOptions;
      this.eventsToUnbind = [];
      this.eventsToUnbind.push(addEvent27(chart.container, "mousedown", blurInputs));
      this.eventsToUnbind.push(addEvent27(chart, "resize", blurInputs));
      buttonOptions.forEach(rangeSelector.computeButtonRange);
      if (typeof selectedOption !== "undefined" && buttonOptions[selectedOption]) {
        this.clickButton(selectedOption, false);
      }
      this.eventsToUnbind.push(addEvent27(chart, "load", function() {
        if (chart.xAxis && chart.xAxis[0]) {
          addEvent27(chart.xAxis[0], "setExtremes", function(e2) {
            if (this.max - this.min !== chart.fixedRange && e2.trigger !== "rangeSelectorButton" && e2.trigger !== "updatedData" && rangeSelector.forcedDataGrouping && !rangeSelector.frozenStates) {
              this.setDataGrouping(false, false);
            }
          });
        }
      }));
    };
    RangeSelector2.prototype.updateButtonStates = function() {
      var rangeSelector = this, chart = this.chart, dropdown = this.dropdown, baseAxis = chart.xAxis[0], actualRange = Math.round(baseAxis.max - baseAxis.min), hasNoData = !baseAxis.hasVisibleSeries, day = 24 * 36e5, unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || baseAxis, dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC), ytdMin = ytdExtremes.min, ytdMax = ytdExtremes.max, selected = rangeSelector.selected, selectedExists = isNumber30(selected), allButtonsEnabled = rangeSelector.options.allButtonsEnabled, buttons = rangeSelector.buttons;
      rangeSelector.buttonOptions.forEach(function(rangeOptions, i) {
        var range = rangeOptions._range, type = rangeOptions.type, count = rangeOptions.count || 1, button = buttons[i], state = 0, disable, select, offsetRange = rangeOptions._offsetMax - rangeOptions._offsetMin, isSelected = i === selected, isTooGreatRange = range > dataMax - dataMin, isTooSmallRange = range < baseAxis.minRange, isYTDButNotSelected = false, isAllButAlreadyShowingAll = false, isSameRange = range === actualRange;
        if ((type === "month" || type === "year") && actualRange + 36e5 >= { month: 28, year: 365 }[type] * day * count - offsetRange && actualRange - 36e5 <= { month: 31, year: 366 }[type] * day * count + offsetRange) {
          isSameRange = true;
        } else if (type === "ytd") {
          isSameRange = ytdMax - ytdMin + offsetRange === actualRange;
          isYTDButNotSelected = !isSelected;
        } else if (type === "all") {
          isSameRange = baseAxis.max - baseAxis.min >= dataMax - dataMin;
          isAllButAlreadyShowingAll = !isSelected && selectedExists && isSameRange;
        }
        disable = !allButtonsEnabled && (isTooGreatRange || isTooSmallRange || isAllButAlreadyShowingAll || hasNoData);
        select = isSelected && isSameRange || isSameRange && !selectedExists && !isYTDButNotSelected || isSelected && rangeSelector.frozenStates;
        if (disable) {
          state = 3;
        } else if (select) {
          selectedExists = true;
          state = 2;
        }
        if (button.state !== state) {
          button.setState(state);
          if (dropdown) {
            dropdown.options[i + 1].disabled = disable;
            if (state === 2) {
              dropdown.selectedIndex = i + 1;
            }
          }
          if (state === 0 && selected === i) {
            rangeSelector.setSelected();
          }
        }
      });
    };
    RangeSelector2.prototype.computeButtonRange = function(rangeOptions) {
      var type = rangeOptions.type, count = rangeOptions.count || 1, fixedTimes = {
        millisecond: 1,
        second: 1e3,
        minute: 60 * 1e3,
        hour: 3600 * 1e3,
        day: 24 * 3600 * 1e3,
        week: 7 * 24 * 3600 * 1e3
      };
      if (fixedTimes[type]) {
        rangeOptions._range = fixedTimes[type] * count;
      } else if (type === "month" || type === "year") {
        rangeOptions._range = {
          month: 30,
          year: 365
        }[type] * 24 * 36e5 * count;
      }
      rangeOptions._offsetMin = pick44(rangeOptions.offsetMin, 0);
      rangeOptions._offsetMax = pick44(rangeOptions.offsetMax, 0);
      rangeOptions._range += rangeOptions._offsetMax - rangeOptions._offsetMin;
    };
    RangeSelector2.prototype.getInputValue = function(name) {
      var input = name === "min" ? this.minInput : this.maxInput;
      var options = this.chart.options.rangeSelector;
      var time = this.chart.time;
      if (input) {
        return (input.type === "text" && options.inputDateParser || this.defaultInputDateParser)(input.value, time.useUTC, time);
      }
      return 0;
    };
    RangeSelector2.prototype.setInputValue = function(name, inputTime) {
      var options = this.options, time = this.chart.time, input = name === "min" ? this.minInput : this.maxInput, dateBox = name === "min" ? this.minDateBox : this.maxDateBox;
      if (input) {
        var hcTimeAttr = input.getAttribute("data-hc-time");
        var updatedTime = defined32(hcTimeAttr) ? Number(hcTimeAttr) : void 0;
        if (defined32(inputTime)) {
          var previousTime = updatedTime;
          if (defined32(previousTime)) {
            input.setAttribute("data-hc-time-previous", previousTime);
          }
          input.setAttribute("data-hc-time", inputTime);
          updatedTime = inputTime;
        }
        input.value = time.dateFormat(this.inputTypeFormats[input.type] || options.inputEditDateFormat, updatedTime);
        if (dateBox) {
          dateBox.attr({
            text: time.dateFormat(options.inputDateFormat, updatedTime)
          });
        }
      }
    };
    RangeSelector2.prototype.setInputExtremes = function(name, min, max) {
      var input = name === "min" ? this.minInput : this.maxInput;
      if (input) {
        var format15 = this.inputTypeFormats[input.type];
        var time = this.chart.time;
        if (format15) {
          var newMin = time.dateFormat(format15, min);
          if (input.min !== newMin) {
            input.min = newMin;
          }
          var newMax = time.dateFormat(format15, max);
          if (input.max !== newMax) {
            input.max = newMax;
          }
        }
      }
    };
    RangeSelector2.prototype.showInput = function(name) {
      var dateBox = name === "min" ? this.minDateBox : this.maxDateBox;
      var input = name === "min" ? this.minInput : this.maxInput;
      if (input && dateBox && this.inputGroup) {
        var isTextInput = input.type === "text";
        var _a15 = this.inputGroup, translateX = _a15.translateX, translateY = _a15.translateY;
        var inputBoxWidth = this.options.inputBoxWidth;
        css13(input, {
          width: isTextInput ? dateBox.width + (inputBoxWidth ? -2 : 20) + "px" : "auto",
          height: isTextInput ? dateBox.height - 2 + "px" : "auto",
          border: "2px solid silver"
        });
        if (isTextInput && inputBoxWidth) {
          css13(input, {
            left: translateX + dateBox.x + "px",
            top: translateY + "px"
          });
        } else {
          css13(input, {
            left: Math.min(Math.round(dateBox.x + translateX - (input.offsetWidth - dateBox.width) / 2), this.chart.chartWidth - input.offsetWidth) + "px",
            top: translateY - (input.offsetHeight - dateBox.height) / 2 + "px"
          });
        }
      }
    };
    RangeSelector2.prototype.hideInput = function(name) {
      var input = name === "min" ? this.minInput : this.maxInput;
      if (input) {
        css13(input, {
          top: "-9999em",
          border: 0,
          width: "1px",
          height: "1px"
        });
      }
    };
    RangeSelector2.prototype.defaultInputDateParser = function(inputDate, useUTC, time) {
      var hasTimezone = function(str) {
        return str.length > 6 && (str.lastIndexOf("-") === str.length - 6 || str.lastIndexOf("+") === str.length - 6);
      };
      var input = inputDate.split("/").join("-").split(" ").join("T");
      if (input.indexOf("T") === -1) {
        input += "T00:00";
      }
      if (useUTC) {
        input += "Z";
      } else if (Globals_default.isSafari && !hasTimezone(input)) {
        var offset3 = new Date(input).getTimezoneOffset() / 60;
        input += offset3 <= 0 ? "+" + pad3(-offset3) + ":00" : "-" + pad3(offset3) + ":00";
      }
      var date = Date.parse(input);
      if (!isNumber30(date)) {
        var parts = inputDate.split("-");
        date = Date.UTC(pInt8(parts[0]), pInt8(parts[1]) - 1, pInt8(parts[2]));
      }
      if (time && useUTC && isNumber30(date)) {
        date += time.getTimezoneOffset(date);
      }
      return date;
    };
    RangeSelector2.prototype.drawInput = function(name) {
      var _a15 = this, chart = _a15.chart, div = _a15.div, inputGroup = _a15.inputGroup;
      var rangeSelector = this, chartStyle = chart.renderer.style || {}, renderer = chart.renderer, options = chart.options.rangeSelector, lang2 = defaultOptions11.lang, isMin = name === "min";
      function updateExtremes() {
        var value = rangeSelector.getInputValue(name), chartAxis = chart.xAxis[0], dataAxis = chart.scroller && chart.scroller.xAxis ? chart.scroller.xAxis : chartAxis, dataMin = dataAxis.dataMin, dataMax = dataAxis.dataMax;
        var maxInput = rangeSelector.maxInput, minInput = rangeSelector.minInput;
        if (value !== Number(input.getAttribute("data-hc-time-previous")) && isNumber30(value)) {
          input.setAttribute("data-hc-time-previous", value);
          if (isMin && maxInput && isNumber30(dataMin)) {
            if (value > Number(maxInput.getAttribute("data-hc-time"))) {
              value = void 0;
            } else if (value < dataMin) {
              value = dataMin;
            }
          } else if (minInput && isNumber30(dataMax)) {
            if (value < Number(minInput.getAttribute("data-hc-time"))) {
              value = void 0;
            } else if (value > dataMax) {
              value = dataMax;
            }
          }
          if (typeof value !== "undefined") {
            chartAxis.setExtremes(isMin ? value : chartAxis.min, isMin ? chartAxis.max : value, void 0, void 0, { trigger: "rangeSelectorInput" });
          }
        }
      }
      var text = lang2[isMin ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
      var label = renderer.label(text, 0).addClass("highcharts-range-label").attr({
        padding: text ? 2 : 0,
        height: text ? options.inputBoxHeight : 0
      }).add(inputGroup);
      var dateBox = renderer.label("", 0).addClass("highcharts-range-input").attr({
        padding: 2,
        width: options.inputBoxWidth,
        height: options.inputBoxHeight,
        "text-align": "center"
      }).on("click", function() {
        rangeSelector.showInput(name);
        rangeSelector[name + "Input"].focus();
      });
      if (!chart.styledMode) {
        dateBox.attr({
          stroke: options.inputBoxBorderColor,
          "stroke-width": 1
        });
      }
      dateBox.add(inputGroup);
      var input = createElement9("input", {
        name,
        className: "highcharts-range-selector"
      }, void 0, div);
      input.setAttribute("type", preferredInputType(options.inputDateFormat || "%b %e, %Y"));
      if (!chart.styledMode) {
        label.css(merge38(chartStyle, options.labelStyle));
        dateBox.css(merge38({
          color: Palette_default.neutralColor80
        }, chartStyle, options.inputStyle));
        css13(input, extend29({
          position: "absolute",
          border: 0,
          boxShadow: "0 0 15px rgba(0,0,0,0.3)",
          width: "1px",
          height: "1px",
          padding: 0,
          textAlign: "center",
          fontSize: chartStyle.fontSize,
          fontFamily: chartStyle.fontFamily,
          top: "-9999em"
          // #4798
        }, options.inputStyle));
      }
      input.onfocus = function() {
        rangeSelector.showInput(name);
      };
      input.onblur = function() {
        if (input === Globals_default.doc.activeElement) {
          updateExtremes();
        }
        rangeSelector.hideInput(name);
        rangeSelector.setInputValue(name);
        input.blur();
      };
      var keyDown = false;
      input.onchange = function() {
        if (!keyDown) {
          updateExtremes();
          rangeSelector.hideInput(name);
          input.blur();
        }
      };
      input.onkeypress = function(event) {
        if (event.keyCode === 13) {
          updateExtremes();
        }
      };
      input.onkeydown = function(event) {
        keyDown = true;
        if (event.keyCode === 38 || event.keyCode === 40) {
          updateExtremes();
        }
      };
      input.onkeyup = function() {
        keyDown = false;
      };
      return { dateBox, input, label };
    };
    RangeSelector2.prototype.getPosition = function() {
      var chart = this.chart, options = chart.options.rangeSelector, top = options.verticalAlign === "top" ? chart.plotTop - chart.axisOffset[0] : 0;
      return {
        buttonTop: top + options.buttonPosition.y,
        inputTop: top + options.inputPosition.y - 10
      };
    };
    RangeSelector2.prototype.getYTDExtremes = function(dataMax, dataMin, useUTC) {
      var time = this.chart.time, min, now = new time.Date(dataMax), year = time.get("FullYear", now), startOfYear = useUTC ? time.Date.UTC(year, 0, 1) : (
        // eslint-disable-line new-cap
        +new time.Date(year, 0, 1)
      );
      min = Math.max(dataMin, startOfYear);
      var ts = now.getTime();
      return {
        max: Math.min(dataMax || ts, ts),
        min
      };
    };
    RangeSelector2.prototype.render = function(min, max) {
      var chart = this.chart, renderer = chart.renderer, container = chart.container, chartOptions = chart.options, options = chartOptions.rangeSelector, inputsZIndex = pick44(chartOptions.chart.style && chartOptions.chart.style.zIndex, 0) + 1, inputEnabled = options.inputEnabled, rendered = this.rendered;
      if (options.enabled === false) {
        return;
      }
      if (!rendered) {
        this.group = renderer.g("range-selector-group").attr({
          zIndex: 7
        }).add();
        this.div = createElement9("div", void 0, {
          position: "relative",
          height: 0,
          zIndex: inputsZIndex
        });
        if (this.buttonOptions.length) {
          this.renderButtons();
        }
        if (container.parentNode) {
          container.parentNode.insertBefore(this.div, container);
        }
        if (inputEnabled) {
          this.inputGroup = renderer.g("input-group").add(this.group);
          var minElems = this.drawInput("min");
          this.minDateBox = minElems.dateBox;
          this.minLabel = minElems.label;
          this.minInput = minElems.input;
          var maxElems = this.drawInput("max");
          this.maxDateBox = maxElems.dateBox;
          this.maxLabel = maxElems.label;
          this.maxInput = maxElems.input;
        }
      }
      if (inputEnabled) {
        this.setInputValue("min", min);
        this.setInputValue("max", max);
        var unionExtremes = chart.scroller && chart.scroller.getUnionExtremes() || chart.xAxis[0] || {};
        if (defined32(unionExtremes.dataMin) && defined32(unionExtremes.dataMax)) {
          var minRange = chart.xAxis[0].minRange || 0;
          this.setInputExtremes("min", unionExtremes.dataMin, Math.min(unionExtremes.dataMax, this.getInputValue("max")) - minRange);
          this.setInputExtremes("max", Math.max(unionExtremes.dataMin, this.getInputValue("min")) + minRange, unionExtremes.dataMax);
        }
        if (this.inputGroup) {
          var x_1 = 0;
          [
            this.minLabel,
            this.minDateBox,
            this.maxLabel,
            this.maxDateBox
          ].forEach(function(label) {
            if (label) {
              var width = label.getBBox().width;
              if (width) {
                label.attr({ x: x_1 });
                x_1 += width + options.inputSpacing;
              }
            }
          });
        }
      }
      this.alignElements();
      this.rendered = true;
    };
    RangeSelector2.prototype.renderButtons = function() {
      var _this = this;
      var _a15 = this, buttons = _a15.buttons, chart = _a15.chart, options = _a15.options;
      var lang2 = defaultOptions11.lang;
      var renderer = chart.renderer;
      var buttonTheme = merge38(options.buttonTheme);
      var states = buttonTheme && buttonTheme.states;
      var width = buttonTheme.width || 28;
      delete buttonTheme.width;
      delete buttonTheme.states;
      this.buttonGroup = renderer.g("range-selector-buttons").add(this.group);
      var dropdown = this.dropdown = createElement9("select", void 0, {
        position: "absolute",
        width: "1px",
        height: "1px",
        padding: 0,
        border: 0,
        top: "-9999em",
        cursor: "pointer",
        opacity: 1e-4
      }, this.div);
      addEvent27(dropdown, "touchstart", function() {
        dropdown.style.fontSize = "16px";
      });
      [
        [Globals_default.isMS ? "mouseover" : "mouseenter"],
        [Globals_default.isMS ? "mouseout" : "mouseleave"],
        ["change", "click"]
      ].forEach(function(_a16) {
        var from = _a16[0], to = _a16[1];
        addEvent27(dropdown, from, function() {
          var button = buttons[_this.currentButtonIndex()];
          if (button) {
            fireEvent19(button.element, to || from);
          }
        });
      });
      this.zoomText = renderer.label(lang2 && lang2.rangeSelectorZoom || "", 0).attr({
        padding: options.buttonTheme.padding,
        height: options.buttonTheme.height,
        paddingLeft: 0,
        paddingRight: 0
      }).add(this.buttonGroup);
      if (!this.chart.styledMode) {
        this.zoomText.css(options.labelStyle);
        buttonTheme["stroke-width"] = pick44(buttonTheme["stroke-width"], 0);
      }
      createElement9("option", {
        textContent: this.zoomText.textStr,
        disabled: true
      }, void 0, dropdown);
      this.buttonOptions.forEach(function(rangeOptions, i) {
        createElement9("option", {
          textContent: rangeOptions.title || rangeOptions.text
        }, void 0, dropdown);
        buttons[i] = renderer.button(rangeOptions.text, 0, 0, function(e2) {
          var buttonEvents = rangeOptions.events && rangeOptions.events.click, callDefaultEvent;
          if (buttonEvents) {
            callDefaultEvent = buttonEvents.call(rangeOptions, e2);
          }
          if (callDefaultEvent !== false) {
            _this.clickButton(i);
          }
          _this.isActive = true;
        }, buttonTheme, states && states.hover, states && states.select, states && states.disabled).attr({
          "text-align": "center",
          width
        }).add(_this.buttonGroup);
        if (rangeOptions.title) {
          buttons[i].attr("title", rangeOptions.title);
        }
      });
    };
    RangeSelector2.prototype.alignElements = function() {
      var _this = this;
      var _a15 = this, buttonGroup = _a15.buttonGroup, buttons = _a15.buttons, chart = _a15.chart, group = _a15.group, inputGroup = _a15.inputGroup, options = _a15.options, zoomText = _a15.zoomText;
      var chartOptions = chart.options;
      var navButtonOptions = chartOptions.exporting && chartOptions.exporting.enabled !== false && chartOptions.navigation && chartOptions.navigation.buttonOptions;
      var buttonPosition = options.buttonPosition, inputPosition = options.inputPosition, verticalAlign = options.verticalAlign;
      var getXOffsetForExportButton = function(group2, position) {
        if (navButtonOptions && _this.titleCollision(chart) && verticalAlign === "top" && position.align === "right" && position.y - group2.getBBox().height - 12 < (navButtonOptions.y || 0) + (navButtonOptions.height || 0) + chart.spacing[0]) {
          return -40;
        }
        return 0;
      };
      var plotLeft = chart.plotLeft;
      if (group && buttonPosition && inputPosition) {
        var translateX = buttonPosition.x - chart.spacing[3];
        if (buttonGroup) {
          this.positionButtons();
          if (!this.initialButtonGroupWidth) {
            var width_1 = 0;
            if (zoomText) {
              width_1 += zoomText.getBBox().width + 5;
            }
            buttons.forEach(function(button, i) {
              width_1 += button.width;
              if (i !== buttons.length - 1) {
                width_1 += options.buttonSpacing;
              }
            });
            this.initialButtonGroupWidth = width_1;
          }
          plotLeft -= chart.spacing[3];
          this.updateButtonStates();
          var xOffsetForExportButton_1 = getXOffsetForExportButton(buttonGroup, buttonPosition);
          this.alignButtonGroup(xOffsetForExportButton_1);
          group.placed = buttonGroup.placed = chart.hasLoaded;
        }
        var xOffsetForExportButton = 0;
        if (inputGroup) {
          xOffsetForExportButton = getXOffsetForExportButton(inputGroup, inputPosition);
          if (inputPosition.align === "left") {
            translateX = plotLeft;
          } else if (inputPosition.align === "right") {
            translateX = -Math.max(chart.axisOffset[1], -xOffsetForExportButton);
          }
          inputGroup.align({
            y: inputPosition.y,
            width: inputGroup.getBBox().width,
            align: inputPosition.align,
            // fix wrong getBBox() value on right align
            x: inputPosition.x + translateX - 2
          }, true, chart.spacingBox);
          inputGroup.placed = chart.hasLoaded;
        }
        this.handleCollision(xOffsetForExportButton);
        group.align({
          verticalAlign
        }, true, chart.spacingBox);
        var alignTranslateY = group.alignAttr.translateY;
        var groupHeight = group.getBBox().height + 20;
        var translateY = 0;
        if (verticalAlign === "bottom") {
          var legendOptions = chart.legend && chart.legend.options;
          var legendHeight = legendOptions && legendOptions.verticalAlign === "bottom" && legendOptions.enabled && !legendOptions.floating ? chart.legend.legendHeight + pick44(legendOptions.margin, 10) : 0;
          groupHeight = groupHeight + legendHeight - 20;
          translateY = alignTranslateY - groupHeight - (options.floating ? 0 : options.y) - (chart.titleOffset ? chart.titleOffset[2] : 0) - 10;
        }
        if (verticalAlign === "top") {
          if (options.floating) {
            translateY = 0;
          }
          if (chart.titleOffset && chart.titleOffset[0]) {
            translateY = chart.titleOffset[0];
          }
          translateY += chart.margin[0] - chart.spacing[0] || 0;
        } else if (verticalAlign === "middle") {
          if (inputPosition.y === buttonPosition.y) {
            translateY = alignTranslateY;
          } else if (inputPosition.y || buttonPosition.y) {
            if (inputPosition.y < 0 || buttonPosition.y < 0) {
              translateY -= Math.min(inputPosition.y, buttonPosition.y);
            } else {
              translateY = alignTranslateY - groupHeight;
            }
          }
        }
        group.translate(options.x, options.y + Math.floor(translateY));
        var _b = this, minInput = _b.minInput, maxInput = _b.maxInput, dropdown = _b.dropdown;
        if (options.inputEnabled && minInput && maxInput) {
          minInput.style.marginTop = group.translateY + "px";
          maxInput.style.marginTop = group.translateY + "px";
        }
        if (dropdown) {
          dropdown.style.marginTop = group.translateY + "px";
        }
      }
    };
    RangeSelector2.prototype.alignButtonGroup = function(xOffsetForExportButton, width) {
      var _a15 = this, chart = _a15.chart, options = _a15.options, buttonGroup = _a15.buttonGroup, buttons = _a15.buttons;
      var buttonPosition = options.buttonPosition;
      var plotLeft = chart.plotLeft - chart.spacing[3];
      var translateX = buttonPosition.x - chart.spacing[3];
      if (buttonPosition.align === "right") {
        translateX += xOffsetForExportButton - plotLeft;
      } else if (buttonPosition.align === "center") {
        translateX -= plotLeft / 2;
      }
      if (buttonGroup) {
        buttonGroup.align({
          y: buttonPosition.y,
          width: pick44(width, this.initialButtonGroupWidth),
          align: buttonPosition.align,
          x: translateX
        }, true, chart.spacingBox);
      }
    };
    RangeSelector2.prototype.positionButtons = function() {
      var _a15 = this, buttons = _a15.buttons, chart = _a15.chart, options = _a15.options, zoomText = _a15.zoomText;
      var verb = chart.hasLoaded ? "animate" : "attr";
      var buttonPosition = options.buttonPosition;
      var plotLeft = chart.plotLeft;
      var buttonLeft = plotLeft;
      if (zoomText && zoomText.visibility !== "hidden") {
        zoomText[verb]({
          x: pick44(plotLeft + buttonPosition.x, plotLeft)
        });
        buttonLeft += buttonPosition.x + zoomText.getBBox().width + 5;
      }
      this.buttonOptions.forEach(function(rangeOptions, i) {
        if (buttons[i].visibility !== "hidden") {
          buttons[i][verb]({ x: buttonLeft });
          buttonLeft += buttons[i].width + options.buttonSpacing;
        } else {
          buttons[i][verb]({ x: plotLeft });
        }
      });
    };
    RangeSelector2.prototype.handleCollision = function(xOffsetForExportButton) {
      var _this = this;
      var _a15 = this, chart = _a15.chart, buttonGroup = _a15.buttonGroup, inputGroup = _a15.inputGroup;
      var _b = this.options, buttonPosition = _b.buttonPosition, dropdown = _b.dropdown, inputPosition = _b.inputPosition;
      var maxButtonWidth = function() {
        var buttonWidth = 0;
        _this.buttons.forEach(function(button) {
          var bBox = button.getBBox();
          if (bBox.width > buttonWidth) {
            buttonWidth = bBox.width;
          }
        });
        return buttonWidth;
      };
      var groupsOverlap = function(buttonGroupWidth) {
        if (inputGroup && buttonGroup) {
          var inputGroupX = inputGroup.alignAttr.translateX + inputGroup.alignOptions.x - xOffsetForExportButton + // getBBox for detecing left margin
          inputGroup.getBBox().x + // 2px padding to not overlap input and label
          2;
          var inputGroupWidth = inputGroup.alignOptions.width;
          var buttonGroupX = buttonGroup.alignAttr.translateX + buttonGroup.getBBox().x;
          return buttonGroupX + buttonGroupWidth > inputGroupX && inputGroupX + inputGroupWidth > buttonGroupX && buttonPosition.y < inputPosition.y + inputGroup.getBBox().height;
        }
        return false;
      };
      var moveInputsDown = function() {
        if (inputGroup && buttonGroup) {
          inputGroup.attr({
            translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -xOffsetForExportButton ? 0 : -xOffsetForExportButton),
            translateY: inputGroup.alignAttr.translateY + buttonGroup.getBBox().height + 10
          });
        }
      };
      if (buttonGroup) {
        if (dropdown === "always") {
          this.collapseButtons(xOffsetForExportButton);
          if (groupsOverlap(maxButtonWidth())) {
            moveInputsDown();
          }
          return;
        }
        if (dropdown === "never") {
          this.expandButtons();
        }
      }
      if (inputGroup && buttonGroup) {
        if (inputPosition.align === buttonPosition.align || // 20 is minimal spacing between elements
        groupsOverlap(this.initialButtonGroupWidth + 20)) {
          if (dropdown === "responsive") {
            this.collapseButtons(xOffsetForExportButton);
            if (groupsOverlap(maxButtonWidth())) {
              moveInputsDown();
            }
          } else {
            moveInputsDown();
          }
        } else if (dropdown === "responsive") {
          this.expandButtons();
        }
      } else if (buttonGroup && dropdown === "responsive") {
        if (this.initialButtonGroupWidth > chart.plotWidth) {
          this.collapseButtons(xOffsetForExportButton);
        } else {
          this.expandButtons();
        }
      }
    };
    RangeSelector2.prototype.collapseButtons = function(xOffsetForExportButton) {
      var _a15 = this, buttons = _a15.buttons, buttonOptions = _a15.buttonOptions, chart = _a15.chart, dropdown = _a15.dropdown, options = _a15.options, zoomText = _a15.zoomText;
      var userButtonTheme = chart.userOptions.rangeSelector && chart.userOptions.rangeSelector.buttonTheme || {};
      var getAttribs = function(text) {
        return {
          text: text ? text + " " : "",
          width: "auto",
          paddingLeft: pick44(options.buttonTheme.paddingLeft, userButtonTheme.padding, 8),
          paddingRight: pick44(options.buttonTheme.paddingRight, userButtonTheme.padding, 8)
        };
      };
      if (zoomText) {
        zoomText.hide();
      }
      var hasActiveButton = false;
      buttonOptions.forEach(function(rangeOptions, i) {
        var button = buttons[i];
        if (button.state !== 2) {
          button.hide();
        } else {
          button.show();
          button.attr(getAttribs(rangeOptions.text));
          hasActiveButton = true;
        }
      });
      if (!hasActiveButton) {
        if (dropdown) {
          dropdown.selectedIndex = 0;
        }
        buttons[0].show();
        buttons[0].attr(getAttribs(this.zoomText && this.zoomText.textStr));
      }
      var align = options.buttonPosition.align;
      this.positionButtons();
      if (align === "right" || align === "center") {
        this.alignButtonGroup(xOffsetForExportButton, buttons[this.currentButtonIndex()].getBBox().width);
      }
      this.showDropdown();
    };
    RangeSelector2.prototype.expandButtons = function() {
      var _a15 = this, buttons = _a15.buttons, buttonOptions = _a15.buttonOptions, options = _a15.options, zoomText = _a15.zoomText;
      this.hideDropdown();
      if (zoomText) {
        zoomText.show();
      }
      buttonOptions.forEach(function(rangeOptions, i) {
        var button = buttons[i];
        button.show();
        button.attr({
          text: rangeOptions.text,
          width: options.buttonTheme.width || 28,
          paddingLeft: pick44(options.buttonTheme.paddingLeft, "unset"),
          paddingRight: pick44(options.buttonTheme.paddingRight, "unset")
        });
        if (button.state < 2) {
          button.setState(0);
        }
      });
      this.positionButtons();
    };
    RangeSelector2.prototype.currentButtonIndex = function() {
      var dropdown = this.dropdown;
      if (dropdown && dropdown.selectedIndex > 0) {
        return dropdown.selectedIndex - 1;
      }
      return 0;
    };
    RangeSelector2.prototype.showDropdown = function() {
      var _a15 = this, buttonGroup = _a15.buttonGroup, buttons = _a15.buttons, chart = _a15.chart, dropdown = _a15.dropdown;
      if (buttonGroup && dropdown) {
        var translateX = buttonGroup.translateX, translateY = buttonGroup.translateY;
        var bBox = buttons[this.currentButtonIndex()].getBBox();
        css13(dropdown, {
          left: chart.plotLeft + translateX + "px",
          top: translateY + 0.5 + "px",
          width: bBox.width + "px",
          height: bBox.height + "px"
        });
        this.hasVisibleDropdown = true;
      }
    };
    RangeSelector2.prototype.hideDropdown = function() {
      var dropdown = this.dropdown;
      if (dropdown) {
        css13(dropdown, {
          top: "-9999em",
          width: "1px",
          height: "1px"
        });
        this.hasVisibleDropdown = false;
      }
    };
    RangeSelector2.prototype.getHeight = function() {
      var rangeSelector = this, options = rangeSelector.options, rangeSelectorGroup = rangeSelector.group, inputPosition = options.inputPosition, buttonPosition = options.buttonPosition, yPosition = options.y, buttonPositionY = buttonPosition.y, inputPositionY = inputPosition.y, rangeSelectorHeight = 0, minPosition;
      if (options.height) {
        return options.height;
      }
      this.alignElements();
      rangeSelectorHeight = rangeSelectorGroup ? (
        // 13px to keep back compatibility
        rangeSelectorGroup.getBBox(true).height + 13 + yPosition
      ) : 0;
      minPosition = Math.min(inputPositionY, buttonPositionY);
      if (inputPositionY < 0 && buttonPositionY < 0 || inputPositionY > 0 && buttonPositionY > 0) {
        rangeSelectorHeight += Math.abs(minPosition);
      }
      return rangeSelectorHeight;
    };
    RangeSelector2.prototype.titleCollision = function(chart) {
      return !(chart.options.title.text || chart.options.subtitle.text);
    };
    RangeSelector2.prototype.update = function(options) {
      var chart = this.chart;
      merge38(true, chart.options.rangeSelector, options);
      this.destroy();
      this.init(chart);
      this.render();
    };
    RangeSelector2.prototype.destroy = function() {
      var rSelector = this, minInput = rSelector.minInput, maxInput = rSelector.maxInput;
      if (rSelector.eventsToUnbind) {
        rSelector.eventsToUnbind.forEach(function(unbind) {
          return unbind();
        });
        rSelector.eventsToUnbind = void 0;
      }
      destroyObjectProperties10(rSelector.buttons);
      if (minInput) {
        minInput.onfocus = minInput.onblur = minInput.onchange = null;
      }
      if (maxInput) {
        maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;
      }
      objectEach25(rSelector, function(val, key) {
        if (val && key !== "chart") {
          if (val instanceof SVGElement_default) {
            val.destroy();
          } else if (val instanceof window.HTMLElement) {
            discardElement6(val);
          }
        }
        if (val !== RangeSelector2.prototype[key]) {
          rSelector[key] = null;
        }
      }, this);
    };
    return RangeSelector2;
  }()
);
RangeSelector.prototype.defaultButtons = [{
  type: "month",
  count: 1,
  text: "1m",
  title: "View 1 month"
}, {
  type: "month",
  count: 3,
  text: "3m",
  title: "View 3 months"
}, {
  type: "month",
  count: 6,
  text: "6m",
  title: "View 6 months"
}, {
  type: "ytd",
  text: "YTD",
  title: "View year to date"
}, {
  type: "year",
  count: 1,
  text: "1y",
  title: "View 1 year"
}, {
  type: "all",
  text: "All",
  title: "View all"
}];
RangeSelector.prototype.inputTypeFormats = {
  "datetime-local": "%Y-%m-%dT%H:%M:%S",
  "date": "%Y-%m-%d",
  "time": "%H:%M:%S"
};
function preferredInputType(format15) {
  var ms = format15.indexOf("%L") !== -1;
  if (ms) {
    return "text";
  }
  var date = ["a", "A", "d", "e", "w", "b", "B", "m", "o", "y", "Y"].some(function(char) {
    return format15.indexOf("%" + char) !== -1;
  });
  var time = ["H", "k", "I", "l", "M", "S"].some(function(char) {
    return format15.indexOf("%" + char) !== -1;
  });
  if (date && time) {
    return "datetime-local";
  }
  if (date) {
    return "date";
  }
  if (time) {
    return "time";
  }
  return "text";
}
Axis_default.prototype.minFromRange = function() {
  var rangeOptions = this.range, type = rangeOptions.type, min, max = this.max, dataMin, range, time = this.chart.time, getTrueRange = function(base, count) {
    var timeName = type === "year" ? "FullYear" : "Month";
    var date = new time.Date(base);
    var basePeriod = time.get(timeName, date);
    time.set(timeName, date, basePeriod + count);
    if (basePeriod === time.get(timeName, date)) {
      time.set("Date", date, 0);
    }
    return date.getTime() - base;
  };
  if (isNumber30(rangeOptions)) {
    min = max - rangeOptions;
    range = rangeOptions;
  } else {
    min = max + getTrueRange(max, -rangeOptions.count);
    if (this.chart) {
      this.chart.fixedRange = max - min;
    }
  }
  dataMin = pick44(this.dataMin, Number.MIN_VALUE);
  if (!isNumber30(min)) {
    min = dataMin;
  }
  if (min <= dataMin) {
    min = dataMin;
    if (typeof range === "undefined") {
      range = getTrueRange(min, rangeOptions.count);
    }
    this.newMax = Math.min(min + range, this.dataMax);
  }
  if (!isNumber30(max)) {
    min = void 0;
  }
  return min;
};
if (!Globals_default.RangeSelector) {
  chartDestroyEvents_1 = [];
  initRangeSelector_1 = function(chart) {
    var extremes, rangeSelector = chart.rangeSelector, legend, alignTo, verticalAlign;
    function render() {
      if (rangeSelector) {
        extremes = chart.xAxis[0].getExtremes();
        legend = chart.legend;
        verticalAlign = rangeSelector && rangeSelector.options.verticalAlign;
        if (isNumber30(extremes.min)) {
          rangeSelector.render(extremes.min, extremes.max);
        }
        if (legend.display && verticalAlign === "top" && verticalAlign === legend.options.verticalAlign) {
          alignTo = merge38(chart.spacingBox);
          if (legend.options.layout === "vertical") {
            alignTo.y = chart.plotTop;
          } else {
            alignTo.y += rangeSelector.getHeight();
          }
          legend.group.placed = false;
          legend.align(alignTo);
        }
      }
    }
    if (rangeSelector) {
      var events = find9(chartDestroyEvents_1, function(e2) {
        return e2[0] === chart;
      });
      if (!events) {
        chartDestroyEvents_1.push([chart, [
          // redraw the scroller on setExtremes
          addEvent27(chart.xAxis[0], "afterSetExtremes", function(e2) {
            if (rangeSelector) {
              rangeSelector.render(e2.min, e2.max);
            }
          }),
          // redraw the scroller chart resize
          addEvent27(chart, "redraw", render)
        ]]);
      }
      render();
    }
  };
  addEvent27(Chart_default, "afterGetContainer", function() {
    if (this.options.rangeSelector && this.options.rangeSelector.enabled) {
      this.rangeSelector = new RangeSelector(this);
    }
  });
  addEvent27(Chart_default, "beforeRender", function() {
    var chart = this, axes = chart.axes, rangeSelector = chart.rangeSelector, verticalAlign;
    if (rangeSelector) {
      if (isNumber30(rangeSelector.deferredYTDClick)) {
        rangeSelector.clickButton(rangeSelector.deferredYTDClick);
        delete rangeSelector.deferredYTDClick;
      }
      axes.forEach(function(axis) {
        axis.updateNames();
        axis.setScale();
      });
      chart.getAxisMargins();
      rangeSelector.render();
      verticalAlign = rangeSelector.options.verticalAlign;
      if (!rangeSelector.options.floating) {
        if (verticalAlign === "bottom") {
          this.extraBottomMargin = true;
        } else if (verticalAlign !== "middle") {
          this.extraTopMargin = true;
        }
      }
    }
  });
  addEvent27(Chart_default, "update", function(e2) {
    var chart = this, options = e2.options, optionsRangeSelector = options.rangeSelector, rangeSelector = chart.rangeSelector, verticalAlign, extraBottomMarginWas = this.extraBottomMargin, extraTopMarginWas = this.extraTopMargin;
    if (optionsRangeSelector && optionsRangeSelector.enabled && !defined32(rangeSelector) && this.options.rangeSelector) {
      this.options.rangeSelector.enabled = true;
      this.rangeSelector = rangeSelector = new RangeSelector(this);
    }
    this.extraBottomMargin = false;
    this.extraTopMargin = false;
    if (rangeSelector) {
      initRangeSelector_1(this);
      verticalAlign = optionsRangeSelector && optionsRangeSelector.verticalAlign || rangeSelector.options && rangeSelector.options.verticalAlign;
      if (!rangeSelector.options.floating) {
        if (verticalAlign === "bottom") {
          this.extraBottomMargin = true;
        } else if (verticalAlign !== "middle") {
          this.extraTopMargin = true;
        }
      }
      if (this.extraBottomMargin !== extraBottomMarginWas || this.extraTopMargin !== extraTopMarginWas) {
        this.isDirtyBox = true;
      }
    }
  });
  addEvent27(Chart_default, "render", function() {
    var chart = this, rangeSelector = chart.rangeSelector, verticalAlign;
    if (rangeSelector && !rangeSelector.options.floating) {
      rangeSelector.render();
      verticalAlign = rangeSelector.options.verticalAlign;
      if (verticalAlign === "bottom") {
        this.extraBottomMargin = true;
      } else if (verticalAlign !== "middle") {
        this.extraTopMargin = true;
      }
    }
  });
  addEvent27(Chart_default, "getMargins", function() {
    var rangeSelector = this.rangeSelector, rangeSelectorHeight;
    if (rangeSelector) {
      rangeSelectorHeight = rangeSelector.getHeight();
      if (this.extraTopMargin) {
        this.plotTop += rangeSelectorHeight;
      }
      if (this.extraBottomMargin) {
        this.marginBottom += rangeSelectorHeight;
      }
    }
  });
  Chart_default.prototype.callbacks.push(initRangeSelector_1);
  addEvent27(Chart_default, "destroy", function destroyEvents() {
    for (var i = 0; i < chartDestroyEvents_1.length; i++) {
      var events = chartDestroyEvents_1[i];
      if (events[0] === this) {
        events[1].forEach(function(unbind) {
          return unbind();
        });
        chartDestroyEvents_1.splice(i, 1);
        return;
      }
    }
  });
  Globals_default.RangeSelector = RangeSelector;
}
var chartDestroyEvents_1;
var initRangeSelector_1;
var RangeSelector_default = RangeSelector;

// node_modules/highcharts/es-modules/Core/Chart/StockChart.js
var __extends19 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var animObject9 = AnimationUtilities_default.animObject;
var format8 = FormatUtilities_default.format;
var getOptions2 = DefaultOptions_default.getOptions;
var pointTooltipFormatter = Point_default.prototype.tooltipFormatter;
var _a2 = Series_default.prototype;
var seriesInit = _a2.init;
var seriesProcessData = _a2.processData;
var addEvent28 = Utilities_default.addEvent;
var arrayMax7 = Utilities_default.arrayMax;
var arrayMin6 = Utilities_default.arrayMin;
var clamp11 = Utilities_default.clamp;
var defined33 = Utilities_default.defined;
var extend30 = Utilities_default.extend;
var find10 = Utilities_default.find;
var isNumber31 = Utilities_default.isNumber;
var isString10 = Utilities_default.isString;
var merge39 = Utilities_default.merge;
var pick45 = Utilities_default.pick;
var splat13 = Utilities_default.splat;
var StockChart = (
  /** @class */
  function(_super) {
    __extends19(StockChart2, _super);
    function StockChart2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StockChart2.prototype.init = function(userOptions, callback) {
      var defaultOptions17 = getOptions2(), xAxisOptions = userOptions.xAxis, yAxisOptions = userOptions.yAxis, navigatorEnabled = pick45(userOptions.navigator && userOptions.navigator.enabled, defaultOptions17.navigator.enabled, true);
      userOptions.xAxis = userOptions.yAxis = void 0;
      var options = merge39(
        {
          chart: {
            panning: {
              enabled: true,
              type: "x"
            },
            pinchType: "x"
          },
          navigator: {
            enabled: navigatorEnabled
          },
          scrollbar: {
            // #4988 - check if setOptions was called
            enabled: pick45(defaultOptions17.scrollbar && defaultOptions17.scrollbar.enabled, true)
          },
          rangeSelector: {
            // #4988 - check if setOptions was called
            enabled: pick45(defaultOptions17.rangeSelector.enabled, true)
          },
          title: {
            text: null
          },
          tooltip: {
            split: pick45(defaultOptions17.tooltip.split, true),
            crosshairs: true
          },
          legend: {
            enabled: false
          }
        },
        userOptions,
        // user's options
        {
          isStock: true
          // internal flag
        }
      );
      userOptions.xAxis = xAxisOptions;
      userOptions.yAxis = yAxisOptions;
      options.xAxis = splat13(userOptions.xAxis || {}).map(function(xAxisOptions2, i) {
        return merge39(
          getDefaultAxisOptions("xAxis", xAxisOptions2),
          defaultOptions17.xAxis,
          // #3802
          defaultOptions17.xAxis && defaultOptions17.xAxis[i],
          // #7690
          xAxisOptions2,
          // user options
          getForcedAxisOptions("xAxis", userOptions)
        );
      });
      options.yAxis = splat13(userOptions.yAxis || {}).map(function(yAxisOptions2, i) {
        return merge39(
          getDefaultAxisOptions("yAxis", yAxisOptions2),
          defaultOptions17.yAxis,
          // #3802
          defaultOptions17.yAxis && defaultOptions17.yAxis[i],
          // #7690
          yAxisOptions2
          // user options
        );
      });
      _super.prototype.init.call(this, options, callback);
    };
    StockChart2.prototype.createAxis = function(type, options) {
      options.axis = merge39(getDefaultAxisOptions(type, options.axis), options.axis, getForcedAxisOptions(type, this.userOptions));
      return _super.prototype.createAxis.call(this, type, options);
    };
    return StockChart2;
  }(Chart_default)
);
(function(StockChart2) {
  function stockChart(a, b, c) {
    return new StockChart2(a, b, c);
  }
  StockChart2.stockChart = stockChart;
})(StockChart || (StockChart = {}));
function getDefaultAxisOptions(type, options) {
  if (type === "xAxis") {
    return {
      minPadding: 0,
      maxPadding: 0,
      overscroll: 0,
      ordinal: true,
      title: {
        text: null
      },
      labels: {
        overflow: "justify"
      },
      showLastLabel: true
    };
  }
  if (type === "yAxis") {
    return {
      labels: {
        y: -2
      },
      opposite: pick45(options.opposite, true),
      /**
       * @default {highcharts} true
       * @default {highstock} false
       * @apioption yAxis.showLastLabel
       *
       * @private
       */
      showLastLabel: !!// #6104, show last label by default for category axes
      (options.categories || options.type === "category"),
      title: {
        text: null
      }
    };
  }
  return {};
}
function getForcedAxisOptions(type, chartOptions) {
  if (type === "xAxis") {
    var defaultOptions17 = getOptions2(), navigatorEnabled = pick45(chartOptions.navigator && chartOptions.navigator.enabled, defaultOptions17.navigator.enabled, true);
    var axisOptions = {
      type: "datetime",
      categories: void 0
    };
    if (navigatorEnabled) {
      axisOptions.startOnTick = false;
      axisOptions.endOnTick = false;
    }
    return axisOptions;
  }
  return {};
}
addEvent28(Series_default, "setOptions", function(e2) {
  var overrides;
  if (this.chart.options.isStock) {
    if (this.is("column") || this.is("columnrange")) {
      overrides = {
        borderWidth: 0,
        shadow: false
      };
    } else if (!this.is("scatter") && !this.is("sma")) {
      overrides = {
        marker: {
          enabled: false,
          radius: 2
        }
      };
    }
    if (overrides) {
      e2.plotOptions[this.type] = merge39(e2.plotOptions[this.type], overrides);
    }
  }
});
addEvent28(Axis_default, "autoLabelAlign", function(e2) {
  var chart = this.chart, options = this.options, panes = chart._labelPanes = chart._labelPanes || {}, key, labelOptions = this.options.labels;
  if (this.chart.options.isStock && this.coll === "yAxis") {
    key = options.top + "," + options.height;
    if (!panes[key] && labelOptions.enabled) {
      if (labelOptions.x === 15) {
        labelOptions.x = 0;
      }
      if (typeof labelOptions.align === "undefined") {
        labelOptions.align = "right";
      }
      panes[key] = this;
      e2.align = "right";
      e2.preventDefault();
    }
  }
});
addEvent28(Axis_default, "destroy", function() {
  var chart = this.chart, key = this.options && this.options.top + "," + this.options.height;
  if (key && chart._labelPanes && chart._labelPanes[key] === this) {
    delete chart._labelPanes[key];
  }
});
addEvent28(Axis_default, "getPlotLinePath", function(e2) {
  var axis = this, series = this.isLinked && !this.series ? this.linkedParent.series : this.series, chart = axis.chart, renderer = chart.renderer, axisLeft = axis.left, axisTop = axis.top, x1, y1, x2, y2, result2 = [], axes = [], axes2, uniqueAxes, translatedValue = e2.translatedValue, value = e2.value, force = e2.force, transVal;
  function getAxis(coll) {
    var otherColl = coll === "xAxis" ? "yAxis" : "xAxis", opt = axis.options[otherColl];
    if (isNumber31(opt)) {
      return [chart[otherColl][opt]];
    }
    if (isString10(opt)) {
      return [chart.get(opt)];
    }
    return series.map(function(s) {
      return s[otherColl];
    });
  }
  if (
    // For stock chart, by default render paths across the panes
    // except the case when `acrossPanes` is disabled by user (#6644)
    chart.options.isStock && e2.acrossPanes !== false && // Ignore in case of colorAxis or zAxis. #3360, #3524, #6720
    axis.coll === "xAxis" || axis.coll === "yAxis"
  ) {
    e2.preventDefault();
    axes = getAxis(axis.coll);
    axes2 = axis.isXAxis ? chart.yAxis : chart.xAxis;
    axes2.forEach(function(A) {
      if (defined33(A.options.id) ? A.options.id.indexOf("navigator") === -1 : true) {
        var a = A.isXAxis ? "yAxis" : "xAxis", rax = defined33(A.options[a]) ? chart[a][A.options[a]] : chart[a][0];
        if (axis === rax) {
          axes.push(A);
        }
      }
    });
    uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]];
    axes.forEach(function(axis2) {
      if (uniqueAxes.indexOf(axis2) === -1 && // Do not draw on axis which overlap completely. #5424
      !find10(uniqueAxes, function(unique) {
        return unique.pos === axis2.pos && unique.len === axis2.len;
      })) {
        uniqueAxes.push(axis2);
      }
    });
    transVal = pick45(translatedValue, axis.translate(value, null, null, e2.old));
    if (isNumber31(transVal)) {
      if (axis.horiz) {
        uniqueAxes.forEach(function(axis2) {
          var skip;
          y1 = axis2.pos;
          y2 = y1 + axis2.len;
          x1 = x2 = Math.round(transVal + axis.transB);
          if (force !== "pass" && (x1 < axisLeft || x1 > axisLeft + axis.width)) {
            if (force) {
              x1 = x2 = clamp11(x1, axisLeft, axisLeft + axis.width);
            } else {
              skip = true;
            }
          }
          if (!skip) {
            result2.push(["M", x1, y1], ["L", x2, y2]);
          }
        });
      } else {
        uniqueAxes.forEach(function(axis2) {
          var skip;
          x1 = axis2.pos;
          x2 = x1 + axis2.len;
          y1 = y2 = Math.round(axisTop + axis.height - transVal);
          if (force !== "pass" && (y1 < axisTop || y1 > axisTop + axis.height)) {
            if (force) {
              y1 = y2 = clamp11(y1, axisTop, axisTop + axis.height);
            } else {
              skip = true;
            }
          }
          if (!skip) {
            result2.push(["M", x1, y1], ["L", x2, y2]);
          }
        });
      }
    }
    e2.path = result2.length > 0 ? renderer.crispPolyLine(result2, e2.lineWidth || 1) : (
      // #3557 getPlotLinePath in regular Highcharts also returns null
      null
    );
  }
});
SVGRenderer_default.prototype.crispPolyLine = function(points, width) {
  for (var i = 0; i < points.length; i = i + 2) {
    var start = points[i], end = points[i + 1];
    if (start[1] === end[1]) {
      start[1] = end[1] = Math.round(start[1]) - width % 2 / 2;
    }
    if (start[2] === end[2]) {
      start[2] = end[2] = Math.round(start[2]) + width % 2 / 2;
    }
  }
  return points;
};
addEvent28(Axis_default, "afterHideCrosshair", function() {
  if (this.crossLabel) {
    this.crossLabel = this.crossLabel.hide();
  }
});
addEvent28(Axis_default, "afterDrawCrosshair", function(event) {
  if (!this.crosshair || !this.crosshair.label || !this.crosshair.label.enabled || !this.cross || !isNumber31(this.min) || !isNumber31(this.max)) {
    return;
  }
  var chart = this.chart, log = this.logarithmic, options = this.crosshair.label, horiz = this.horiz, opposite = this.opposite, left = this.left, top = this.top, crossLabel = this.crossLabel, posx, posy, crossBox, formatOption = options.format, formatFormat = "", limit, align, tickInside = this.options.tickPosition === "inside", snap = this.crosshair.snap !== false, offset3 = 0, e2 = event.e || this.cross && this.cross.e, point = event.point, min = this.min, max = this.max;
  if (log) {
    min = log.lin2log(min);
    max = log.lin2log(max);
  }
  align = horiz ? "center" : opposite ? this.labelAlign === "right" ? "right" : "left" : this.labelAlign === "left" ? "left" : "center";
  if (!crossLabel) {
    crossLabel = this.crossLabel = chart.renderer.label("", 0, void 0, options.shape || "callout").addClass("highcharts-crosshair-label highcharts-color-" + (point ? point.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({
      align: options.align || align,
      padding: pick45(options.padding, 8),
      r: pick45(options.borderRadius, 3),
      zIndex: 2
    }).add(this.labelGroup);
    if (!chart.styledMode) {
      crossLabel.attr({
        fill: options.backgroundColor || point && point.series && point.series.color || // #14888
        Palette_default.neutralColor60,
        stroke: options.borderColor || "",
        "stroke-width": options.borderWidth || 0
      }).css(extend30({
        color: Palette_default.backgroundColor,
        fontWeight: "normal",
        fontSize: "11px",
        textAlign: "center"
      }, options.style || {}));
    }
  }
  if (horiz) {
    posx = snap ? (point.plotX || 0) + left : e2.chartX;
    posy = top + (opposite ? 0 : this.height);
  } else {
    posx = opposite ? this.width + left : 0;
    posy = snap ? (point.plotY || 0) + top : e2.chartY;
  }
  if (!formatOption && !options.formatter) {
    if (this.dateTime) {
      formatFormat = "%b %d, %Y";
    }
    formatOption = "{value" + (formatFormat ? ":" + formatFormat : "") + "}";
  }
  var value = snap ? this.isXAxis ? point.x : point.y : this.toValue(horiz ? e2.chartX : e2.chartY);
  var isInside = point ? point.series.isPointInside(point) : isNumber31(value) && value > min && value < max;
  var text = "";
  if (formatOption) {
    text = format8(formatOption, { value }, chart);
  } else if (options.formatter && isNumber31(value)) {
    text = options.formatter.call(this, value);
  }
  crossLabel.attr({
    text,
    x: posx,
    y: posy,
    visibility: isInside ? "visible" : "hidden"
  });
  crossBox = crossLabel.getBBox();
  if (isNumber31(crossLabel.y)) {
    if (horiz) {
      if (tickInside && !opposite || !tickInside && opposite) {
        posy = crossLabel.y - crossBox.height;
      }
    } else {
      posy = crossLabel.y - crossBox.height / 2;
    }
  }
  if (horiz) {
    limit = {
      left: left - crossBox.x,
      right: left + this.width - crossBox.x
    };
  } else {
    limit = {
      left: this.labelAlign === "left" ? left : 0,
      right: this.labelAlign === "right" ? left + this.width : chart.chartWidth
    };
  }
  if (crossLabel.translateX < limit.left) {
    offset3 = limit.left - crossLabel.translateX;
  }
  if (crossLabel.translateX + crossBox.width >= limit.right) {
    offset3 = -(crossLabel.translateX + crossBox.width - limit.right);
  }
  crossLabel.attr({
    x: posx + offset3,
    y: posy,
    // First set x and y, then anchorX and anchorY, when box is actually
    // calculated, #5702
    anchorX: horiz ? posx : this.opposite ? 0 : chart.chartWidth,
    anchorY: horiz ? this.opposite ? chart.chartHeight : 0 : posy + crossBox.height / 2
  });
});
Series_default.prototype.init = function() {
  seriesInit.apply(this, arguments);
  this.initCompare(this.options.compare);
};
Series_default.prototype.setCompare = function(compare) {
  this.initCompare(compare);
  this.userOptions.compare = compare;
};
Series_default.prototype.initCompare = function(compare) {
  this.modifyValue = compare === "value" || compare === "percent" ? function(value, point) {
    var compareValue = this.compareValue;
    if (typeof value !== "undefined" && typeof compareValue !== "undefined") {
      if (compare === "value") {
        value -= compareValue;
      } else {
        value = 100 * (value / compareValue) - (this.options.compareBase === 100 ? 0 : 100);
      }
      if (point) {
        point.change = value;
      }
      return value;
    }
    return 0;
  } : null;
  if (this.chart.hasRendered) {
    this.isDirty = true;
  }
};
Series_default.prototype.forceCropping = function() {
  var chart = this.chart, options = this.options, dataGroupingOptions = options.dataGrouping, groupingEnabled = this.allowDG !== false && dataGroupingOptions && pick45(dataGroupingOptions.enabled, chart.options.isStock);
  return groupingEnabled;
};
Series_default.prototype.processData = function(force) {
  var series = this, i, keyIndex = -1, processedXData, processedYData, compareStart = series.options.compareStart === true ? 0 : 1, length, compareValue;
  seriesProcessData.apply(this, arguments);
  if (series.xAxis && series.processedYData) {
    processedXData = series.processedXData;
    processedYData = series.processedYData;
    length = processedYData.length;
    if (series.pointArrayMap) {
      keyIndex = series.pointArrayMap.indexOf(series.options.pointValKey || series.pointValKey || "y");
    }
    for (i = 0; i < length - compareStart; i++) {
      compareValue = processedYData[i] && keyIndex > -1 ? processedYData[i][keyIndex] : processedYData[i];
      if (isNumber31(compareValue) && processedXData[i + compareStart] >= series.xAxis.min && compareValue !== 0) {
        series.compareValue = compareValue;
        break;
      }
    }
  }
  return;
};
addEvent28(Series_default, "afterGetExtremes", function(e2) {
  var dataExtremes = e2.dataExtremes;
  if (this.modifyValue && dataExtremes) {
    var extremes = [
      this.modifyValue(dataExtremes.dataMin),
      this.modifyValue(dataExtremes.dataMax)
    ];
    dataExtremes.dataMin = arrayMin6(extremes);
    dataExtremes.dataMax = arrayMax7(extremes);
  }
});
Axis_default.prototype.setCompare = function(compare, redraw) {
  if (!this.isXAxis) {
    this.series.forEach(function(series) {
      series.setCompare(compare);
    });
    if (pick45(redraw, true)) {
      this.chart.redraw();
    }
  }
};
Point_default.prototype.tooltipFormatter = function(pointFormat) {
  var point = this;
  var numberFormatter = point.series.chart.numberFormatter;
  pointFormat = pointFormat.replace("{point.change}", (point.change > 0 ? "+" : "") + numberFormatter(point.change, pick45(point.series.tooltipOptions.changeDecimals, 2)));
  return pointTooltipFormatter.apply(this, [pointFormat]);
};
addEvent28(Series_default, "render", function() {
  var chart = this.chart, clipHeight;
  if (!(chart.is3d && chart.is3d()) && !chart.polar && this.xAxis && !this.xAxis.isRadial && // Gauge, #6192
  this.options.clip !== false) {
    clipHeight = this.yAxis.len;
    if (this.xAxis.axisLine) {
      var dist = chart.plotTop + chart.plotHeight - this.yAxis.pos - this.yAxis.len, lineHeightCorrection = Math.floor(this.xAxis.axisLine.strokeWidth() / 2);
      if (dist >= 0) {
        clipHeight -= Math.max(lineHeightCorrection - dist, 0);
      }
    }
    if (!chart.hasLoaded || !this.clipBox && this.isDirty && !this.isDirtyData) {
      this.clipBox = this.clipBox || merge39(chart.clipBox);
      this.clipBox.width = this.xAxis.len;
      this.clipBox.height = clipHeight;
    }
    if (chart.hasRendered) {
      var animation = animObject9(this.options.animation);
      var sharedClipKey = this.getSharedClipKey(animation);
      var clipRect = chart.sharedClips[sharedClipKey];
      if (clipRect) {
        clipRect.animate({
          width: this.xAxis.len,
          height: clipHeight
        });
        var markerClipRect = chart.sharedClips[sharedClipKey + "m"];
        if (markerClipRect) {
          markerClipRect.animate({
            width: this.xAxis.len
          });
        }
      }
    }
  }
});
addEvent28(Chart_default, "update", function(e2) {
  var options = e2.options;
  if ("scrollbar" in options && this.navigator) {
    merge39(true, this.options.scrollbar, options.scrollbar);
    this.navigator.update({}, false);
    delete options.scrollbar;
  }
});
var StockChart_default = StockChart;

// node_modules/highcharts/es-modules/masters/modules/stock.src.js
var G3 = Globals_default;
G3.Scrollbar = Scrollbar_default;
G3.StockChart = G3.stockChart = StockChart_default.stockChart;
Scrollbar_default.compose(G3.Axis);
OrdinalAxis_default.compose(G3.Axis, G3.Series, G3.Chart);

// node_modules/highcharts/es-modules/masters/highstock.src.js
highcharts_src_default.product = "Highstock";
var highstock_src_default = highcharts_src_default;

// node_modules/highcharts/es-modules/Accessibility/Utils/HTMLUtilities.js
var doc8 = Globals_default.doc;
var win12 = Globals_default.win;
var merge40 = Utilities_default.merge;
function addClass(el, className) {
  if (el.classList) {
    el.classList.add(className);
  } else if (el.className.indexOf(className) < 0) {
    el.className += className;
  }
}
function escapeStringForHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function getElement(id) {
  return doc8.getElementById(id);
}
function getFakeMouseEvent(type) {
  if (typeof win12.MouseEvent === "function") {
    return new win12.MouseEvent(type);
  }
  if (doc8.createEvent) {
    var evt = doc8.createEvent("MouseEvent");
    if (evt.initMouseEvent) {
      evt.initMouseEvent(
        type,
        true,
        // Bubble
        true,
        // Cancel
        win12,
        // View
        type === "click" ? 1 : 0,
        // Detail
        // Coords
        0,
        0,
        0,
        0,
        // Pressed keys
        false,
        false,
        false,
        false,
        0,
        // button
        null
        // related target
      );
      return evt;
    }
  }
  return { type };
}
function getHeadingTagNameForElement(element) {
  var getIncreasedHeadingLevel = function(tagName) {
    var headingLevel = parseInt(tagName.slice(1), 10);
    var newLevel = Math.min(6, headingLevel + 1);
    return "h" + newLevel;
  };
  var isHeading = function(tagName) {
    return /H[1-6]/.test(tagName);
  };
  var getPreviousSiblingsHeading = function(el) {
    var sibling = el;
    while (sibling = sibling.previousSibling) {
      var tagName = sibling.tagName || "";
      if (isHeading(tagName)) {
        return tagName;
      }
    }
    return "";
  };
  var getHeadingRecursive = function(el) {
    var prevSiblingsHeading = getPreviousSiblingsHeading(el);
    if (prevSiblingsHeading) {
      return getIncreasedHeadingLevel(prevSiblingsHeading);
    }
    var parent = el.parentElement;
    if (!parent) {
      return "p";
    }
    var parentTagName = parent.tagName;
    if (isHeading(parentTagName)) {
      return getIncreasedHeadingLevel(parentTagName);
    }
    return getHeadingRecursive(parent);
  };
  return getHeadingRecursive(element);
}
function removeElement(element) {
  if (element && element.parentNode) {
    element.parentNode.removeChild(element);
  }
}
function reverseChildNodes(node) {
  var i = node.childNodes.length;
  while (i--) {
    node.appendChild(node.childNodes[i]);
  }
}
function setElAttrs(el, attrs) {
  Object.keys(attrs).forEach(function(attr11) {
    var val = attrs[attr11];
    if (val === null) {
      el.removeAttribute(attr11);
    } else {
      el.setAttribute(attr11, val);
    }
  });
}
function stripHTMLTagsFromString(str) {
  return typeof str === "string" ? str.replace(/<\/?[^>]+(>|$)/g, "") : str;
}
function visuallyHideElement(element) {
  var hiddenStyle = {
    position: "absolute",
    width: "1px",
    height: "1px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    clip: "rect(1px, 1px, 1px, 1px)",
    marginTop: "-3px",
    "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)",
    filter: "alpha(opacity=1)",
    opacity: "0.01"
  };
  merge40(true, element.style, hiddenStyle);
}
var HTMLUtilities = {
  addClass,
  escapeStringForHTML,
  getElement,
  getFakeMouseEvent,
  getHeadingTagNameForElement,
  removeElement,
  reverseChildNodes,
  setElAttrs,
  stripHTMLTagsFromString,
  visuallyHideElement
};
var HTMLUtilities_default = HTMLUtilities;

// node_modules/highcharts/es-modules/Accessibility/Utils/ChartUtilities.js
var stripHTMLTags = HTMLUtilities_default.stripHTMLTagsFromString;
var doc9 = Globals_default.doc;
var defined34 = Utilities_default.defined;
var find11 = Utilities_default.find;
var fireEvent20 = Utilities_default.fireEvent;
function getChartTitle(chart) {
  return stripHTMLTags(chart.options.title.text || chart.langFormat("accessibility.defaultChartTitle", { chart }));
}
function getAxisDescription(axis) {
  return axis && (axis.userOptions && axis.userOptions.accessibility && axis.userOptions.accessibility.description || axis.axisTitle && axis.axisTitle.textStr || axis.options.id || axis.categories && "categories" || axis.dateTime && "Time" || "values");
}
function getAxisRangeDescription(axis) {
  var axisOptions = axis.options || {};
  if (axisOptions.accessibility && typeof axisOptions.accessibility.rangeDescription !== "undefined") {
    return axisOptions.accessibility.rangeDescription;
  }
  if (axis.categories) {
    return getCategoryAxisRangeDesc(axis);
  }
  if (axis.dateTime && (axis.min === 0 || axis.dataMin === 0)) {
    return getAxisTimeLengthDesc(axis);
  }
  return getAxisFromToDescription(axis);
}
function getCategoryAxisRangeDesc(axis) {
  var chart = axis.chart;
  if (axis.dataMax && axis.dataMin) {
    return chart.langFormat("accessibility.axis.rangeCategories", {
      chart,
      axis,
      numCategories: axis.dataMax - axis.dataMin + 1
    });
  }
  return "";
}
function getAxisTimeLengthDesc(axis) {
  var chart = axis.chart;
  var range = {};
  var rangeUnit = "Seconds";
  range.Seconds = ((axis.max || 0) - (axis.min || 0)) / 1e3;
  range.Minutes = range.Seconds / 60;
  range.Hours = range.Minutes / 60;
  range.Days = range.Hours / 24;
  ["Minutes", "Hours", "Days"].forEach(function(unit) {
    if (range[unit] > 2) {
      rangeUnit = unit;
    }
  });
  var rangeValue = range[rangeUnit].toFixed(
    rangeUnit !== "Seconds" && rangeUnit !== "Minutes" ? 1 : 0
    // Use decimals for days/hours
  );
  return chart.langFormat("accessibility.axis.timeRange" + rangeUnit, {
    chart,
    axis,
    range: rangeValue.replace(".0", "")
  });
}
function getAxisFromToDescription(axis) {
  var chart = axis.chart;
  var dateRangeFormat = chart.options && chart.options.accessibility && chart.options.accessibility.screenReaderSection.axisRangeDateFormat || "";
  var format15 = function(axisKey) {
    return axis.dateTime ? chart.time.dateFormat(dateRangeFormat, axis[axisKey]) : axis[axisKey];
  };
  return chart.langFormat("accessibility.axis.rangeFromTo", {
    chart,
    axis,
    rangeFrom: format15("min"),
    rangeTo: format15("max")
  });
}
function getSeriesFirstPointElement(series) {
  if (series.points && series.points.length) {
    var firstPointWithGraphic = find11(series.points, function(p) {
      return !!p.graphic;
    });
    return firstPointWithGraphic && firstPointWithGraphic.graphic && firstPointWithGraphic.graphic.element;
  }
}
function getSeriesA11yElement(series) {
  var firstPointEl = getSeriesFirstPointElement(series);
  return firstPointEl && firstPointEl.parentNode || series.graph && series.graph.element || series.group && series.group.element;
}
function unhideChartElementFromAT(chart, element) {
  element.setAttribute("aria-hidden", false);
  if (element === chart.renderTo || !element.parentNode || element.parentNode === doc9.body) {
    return;
  }
  Array.prototype.forEach.call(element.parentNode.childNodes, function(node) {
    if (!node.hasAttribute("aria-hidden")) {
      node.setAttribute("aria-hidden", true);
    }
  });
  unhideChartElementFromAT(chart, element.parentNode);
}
function hideSeriesFromAT(series) {
  var seriesEl = getSeriesA11yElement(series);
  if (seriesEl) {
    seriesEl.setAttribute("aria-hidden", true);
  }
}
function getSeriesFromName(chart, name) {
  if (!name) {
    return chart.series;
  }
  return (chart.series || []).filter(function(s) {
    return s.name === name;
  });
}
function getPointFromXY(series, x, y) {
  var i = series.length, res;
  while (i--) {
    res = find11(series[i].points || [], function(p) {
      return p.x === x && p.y === y;
    });
    if (res) {
      return res;
    }
  }
}
function getRelativePointAxisPosition(axis, point) {
  if (!defined34(axis.dataMin) || !defined34(axis.dataMax)) {
    return 0;
  }
  var axisStart = axis.toPixels(axis.dataMin);
  var axisEnd = axis.toPixels(axis.dataMax);
  var positionProp = axis.coll === "xAxis" ? "x" : "y";
  var pointPos = axis.toPixels(point[positionProp] || 0);
  return (pointPos - axisStart) / (axisEnd - axisStart);
}
function scrollToPoint(point) {
  var xAxis = point.series.xAxis;
  var yAxis = point.series.yAxis;
  var axis = xAxis && xAxis.scrollbar ? xAxis : yAxis;
  var scrollbar = axis && axis.scrollbar;
  if (scrollbar && defined34(scrollbar.to) && defined34(scrollbar.from)) {
    var range = scrollbar.to - scrollbar.from;
    var pos = getRelativePointAxisPosition(axis, point);
    scrollbar.updatePosition(pos - range / 2, pos + range / 2);
    fireEvent20(scrollbar, "changed", {
      from: scrollbar.from,
      to: scrollbar.to,
      trigger: "scrollbar",
      DOMEvent: null
    });
  }
}
var ChartUtilities = {
  getChartTitle,
  getAxisDescription,
  getAxisRangeDescription,
  getPointFromXY,
  getSeriesFirstPointElement,
  getSeriesFromName,
  getSeriesA11yElement,
  unhideChartElementFromAT,
  hideSeriesFromAT,
  scrollToPoint
};
var ChartUtilities_default = ChartUtilities;

// node_modules/highcharts/es-modules/Accessibility/KeyboardNavigationHandler.js
var find12 = Utilities_default.find;
function KeyboardNavigationHandler(chart, options) {
  this.chart = chart;
  this.keyCodeMap = options.keyCodeMap || [];
  this.validate = options.validate;
  this.init = options.init;
  this.terminate = options.terminate;
  this.response = {
    success: 1,
    prev: 2,
    next: 3,
    noHandler: 4,
    fail: 5
    // Handler failed
  };
}
KeyboardNavigationHandler.prototype = {
  /**
   * Find handler function(s) for key code in the keyCodeMap and run it.
   *
   * @function KeyboardNavigationHandler#run
   * @param {global.KeyboardEvent} e
   * @return {number} Returns a response code indicating whether the run was
   *      a success/fail/unhandled, or if we should move to next/prev module.
   */
  run: function(e2) {
    var keyCode = e2.which || e2.keyCode;
    var response = this.response.noHandler;
    var handlerCodeSet = find12(this.keyCodeMap, function(codeSet) {
      return codeSet[0].indexOf(keyCode) > -1;
    });
    if (handlerCodeSet) {
      response = handlerCodeSet[1].call(this, keyCode, e2);
    } else if (keyCode === 9) {
      response = this.response[e2.shiftKey ? "prev" : "next"];
    }
    return response;
  }
};
var KeyboardNavigationHandler_default = KeyboardNavigationHandler;

// node_modules/highcharts/es-modules/Accessibility/Utils/DOMElementProvider.js
var doc10 = Globals_default.doc;
var removeElement2 = HTMLUtilities_default.removeElement;
var extend31 = Utilities_default.extend;
var DOMElementProvider = function() {
  this.elements = [];
};
extend31(DOMElementProvider.prototype, {
  /**
   * Create an element and keep track of it for later removal.
   * Same args as document.createElement
   * @private
   */
  createElement: function() {
    var el = doc10.createElement.apply(doc10, arguments);
    this.elements.push(el);
    return el;
  },
  /**
   * Destroy all created elements, removing them from the DOM.
   * @private
   */
  destroyCreatedElements: function() {
    this.elements.forEach(function(element) {
      removeElement2(element);
    });
    this.elements = [];
  }
});
var DOMElementProvider_default = DOMElementProvider;

// node_modules/highcharts/es-modules/Accessibility/Utils/EventProvider.js
var addEvent29 = Utilities_default.addEvent;
var extend32 = Utilities_default.extend;
var EventProvider = function() {
  this.eventRemovers = [];
};
extend32(EventProvider.prototype, {
  /**
   * Add an event to an element and keep track of it for later removal.
   * Same args as Highcharts.addEvent.
   * @private
   * @return {Function}
   */
  addEvent: function() {
    var remover = addEvent29.apply(Globals_default, arguments);
    this.eventRemovers.push(remover);
    return remover;
  },
  /**
   * Remove all added events.
   * @private
   * @return {void}
   */
  removeAddedEvents: function() {
    this.eventRemovers.forEach(function(remover) {
      remover();
    });
    this.eventRemovers = [];
  }
});
var EventProvider_default = EventProvider;

// node_modules/highcharts/es-modules/Accessibility/AccessibilityComponent.js
var unhideChartElementFromAT2 = ChartUtilities_default.unhideChartElementFromAT;
var doc11 = Globals_default.doc;
var win13 = Globals_default.win;
var removeElement3 = HTMLUtilities_default.removeElement;
var getFakeMouseEvent2 = HTMLUtilities_default.getFakeMouseEvent;
var extend33 = Utilities_default.extend;
var fireEvent21 = Utilities_default.fireEvent;
var merge41 = Utilities_default.merge;
var functionsToOverrideByDerivedClasses = {
  /**
   * Called on component initialization.
   */
  init: function() {
  },
  /**
   * Get keyboard navigation handler for this component.
   * @return {Highcharts.KeyboardNavigationHandler}
   */
  getKeyboardNavigation: function() {
  },
  /**
   * Called on updates to the chart, including options changes.
   * Note that this is also called on first render of chart.
   */
  onChartUpdate: function() {
  },
  /**
   * Called on every chart render.
   */
  onChartRender: function() {
  },
  /**
   * Called when accessibility is disabled or chart is destroyed.
   */
  destroy: function() {
  }
};
function AccessibilityComponent() {
}
AccessibilityComponent.prototype = {
  /**
   * Initialize the class
   * @private
   * @param {Highcharts.Chart} chart
   *        Chart object
   */
  initBase: function(chart) {
    this.chart = chart;
    this.eventProvider = new EventProvider_default();
    this.domElementProvider = new DOMElementProvider_default();
    this.keyCodes = {
      left: 37,
      right: 39,
      up: 38,
      down: 40,
      enter: 13,
      space: 32,
      esc: 27,
      tab: 9
    };
  },
  /**
   * Add an event to an element and keep track of it for later removal.
   * See EventProvider for details.
   * @private
   */
  addEvent: function() {
    return this.eventProvider.addEvent.apply(this.eventProvider, arguments);
  },
  /**
   * Create an element and keep track of it for later removal.
   * See DOMElementProvider for details.
   * @private
   */
  createElement: function() {
    return this.domElementProvider.createElement.apply(this.domElementProvider, arguments);
  },
  /**
   * Fire an event on an element that is either wrapped by Highcharts,
   * or a DOM element
   * @private
   * @param {Highcharts.HTMLElement|Highcharts.HTMLDOMElement|
   *  Highcharts.SVGDOMElement|Highcharts.SVGElement} el
   * @param {Event} eventObject
   */
  fireEventOnWrappedOrUnwrappedElement: function(el, eventObject) {
    var type = eventObject.type;
    if (doc11.createEvent && (el.dispatchEvent || el.fireEvent)) {
      if (el.dispatchEvent) {
        el.dispatchEvent(eventObject);
      } else {
        el.fireEvent(type, eventObject);
      }
    } else {
      fireEvent21(el, type, eventObject);
    }
  },
  /**
   * Utility function to attempt to fake a click event on an element.
   * @private
   * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} element
   */
  fakeClickEvent: function(element) {
    if (element) {
      var fakeEventObject = getFakeMouseEvent2("click");
      this.fireEventOnWrappedOrUnwrappedElement(element, fakeEventObject);
    }
  },
  /**
   * Add a new proxy group to the proxy container. Creates the proxy container
   * if it does not exist.
   * @private
   * @param {Highcharts.HTMLAttributes} [attrs]
   * The attributes to set on the new group div.
   * @return {Highcharts.HTMLDOMElement}
   * The new proxy group element.
   */
  addProxyGroup: function(attrs) {
    this.createOrUpdateProxyContainer();
    var groupDiv = this.createElement("div");
    Object.keys(attrs || {}).forEach(function(prop) {
      if (attrs[prop] !== null) {
        groupDiv.setAttribute(prop, attrs[prop]);
      }
    });
    this.chart.a11yProxyContainer.appendChild(groupDiv);
    return groupDiv;
  },
  /**
   * Creates and updates DOM position of proxy container
   * @private
   */
  createOrUpdateProxyContainer: function() {
    var chart = this.chart, rendererSVGEl = chart.renderer.box;
    chart.a11yProxyContainer = chart.a11yProxyContainer || this.createProxyContainerElement();
    if (rendererSVGEl.nextSibling !== chart.a11yProxyContainer) {
      chart.container.insertBefore(chart.a11yProxyContainer, rendererSVGEl.nextSibling);
    }
  },
  /**
   * @private
   * @return {Highcharts.HTMLDOMElement} element
   */
  createProxyContainerElement: function() {
    var pc = doc11.createElement("div");
    pc.className = "highcharts-a11y-proxy-container";
    return pc;
  },
  /**
   * Create an invisible proxy HTML button in the same position as an SVG
   * element
   * @private
   * @param {Highcharts.SVGElement} svgElement
   * The wrapped svg el to proxy.
   * @param {Highcharts.HTMLDOMElement} parentGroup
   * The proxy group element in the proxy container to add this button to.
   * @param {Highcharts.SVGAttributes} [attributes]
   * Additional attributes to set.
   * @param {Highcharts.SVGElement} [posElement]
   * Element to use for positioning instead of svgElement.
   * @param {Function} [preClickEvent]
   * Function to call before click event fires.
   *
   * @return {Highcharts.HTMLDOMElement} The proxy button.
   */
  createProxyButton: function(svgElement, parentGroup, attributes, posElement, preClickEvent) {
    var svgEl = svgElement.element, proxy = this.createElement("button"), attrs = merge41({
      "aria-label": svgEl.getAttribute("aria-label")
    }, attributes);
    Object.keys(attrs).forEach(function(prop) {
      if (attrs[prop] !== null) {
        proxy.setAttribute(prop, attrs[prop]);
      }
    });
    proxy.className = "highcharts-a11y-proxy-button";
    if (svgElement.hasClass("highcharts-no-tooltip")) {
      proxy.className += " highcharts-no-tooltip";
    }
    if (preClickEvent) {
      this.addEvent(proxy, "click", preClickEvent);
    }
    this.setProxyButtonStyle(proxy);
    this.updateProxyButtonPosition(proxy, posElement || svgElement);
    this.proxyMouseEventsForButton(svgEl, proxy);
    parentGroup.appendChild(proxy);
    if (!attrs["aria-hidden"]) {
      unhideChartElementFromAT2(this.chart, proxy);
    }
    return proxy;
  },
  /**
   * Get the position relative to chart container for a wrapped SVG element.
   * @private
   * @param {Highcharts.SVGElement} element
   * The element to calculate position for.
   * @return {Highcharts.BBoxObject}
   * Object with x and y props for the position.
   */
  getElementPosition: function(element) {
    var el = element.element, div = this.chart.renderTo;
    if (div && el && el.getBoundingClientRect) {
      var rectEl = el.getBoundingClientRect(), rectDiv = div.getBoundingClientRect();
      return {
        x: rectEl.left - rectDiv.left,
        y: rectEl.top - rectDiv.top,
        width: rectEl.right - rectEl.left,
        height: rectEl.bottom - rectEl.top
      };
    }
    return { x: 0, y: 0, width: 1, height: 1 };
  },
  /**
   * @private
   * @param {Highcharts.HTMLElement} button The proxy element.
   */
  setProxyButtonStyle: function(button) {
    merge41(true, button.style, {
      borderWidth: "0",
      backgroundColor: "transparent",
      cursor: "pointer",
      outline: "none",
      opacity: "0.001",
      filter: "alpha(opacity=1)",
      zIndex: "999",
      overflow: "hidden",
      padding: "0",
      margin: "0",
      display: "block",
      position: "absolute"
    });
    button.style["-ms-filter"] = "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)";
  },
  /**
   * @private
   * @param {Highcharts.HTMLElement} proxy The proxy to update position of.
   * @param {Highcharts.SVGElement} posElement The element to overlay and take position from.
   */
  updateProxyButtonPosition: function(proxy, posElement) {
    var bBox = this.getElementPosition(posElement);
    merge41(true, proxy.style, {
      width: (bBox.width || 1) + "px",
      height: (bBox.height || 1) + "px",
      left: (Math.round(bBox.x) || 0) + "px",
      top: (Math.round(bBox.y) || 0) + "px"
    });
  },
  /**
   * @private
   * @param {Highcharts.HTMLElement|Highcharts.HTMLDOMElement|
   *  Highcharts.SVGDOMElement|Highcharts.SVGElement} source
   * @param {Highcharts.HTMLElement} button
   */
  proxyMouseEventsForButton: function(source, button) {
    var component = this;
    [
      "click",
      "touchstart",
      "touchend",
      "touchcancel",
      "touchmove",
      "mouseover",
      "mouseenter",
      "mouseleave",
      "mouseout"
    ].forEach(function(evtType) {
      var isTouchEvent = evtType.indexOf("touch") === 0;
      component.addEvent(button, evtType, function(e2) {
        var clonedEvent = isTouchEvent ? component.cloneTouchEvent(e2) : component.cloneMouseEvent(e2);
        if (source) {
          component.fireEventOnWrappedOrUnwrappedElement(source, clonedEvent);
        }
        e2.stopPropagation();
        if (evtType !== "touchstart" && evtType !== "touchmove" && evtType !== "touchend") {
          e2.preventDefault();
        }
      }, { passive: false });
    });
  },
  /**
   * Utility function to clone a mouse event for re-dispatching.
   * @private
   * @param {global.MouseEvent} e The event to clone.
   * @return {global.MouseEvent} The cloned event
   */
  cloneMouseEvent: function(e2) {
    if (typeof win13.MouseEvent === "function") {
      return new win13.MouseEvent(e2.type, e2);
    }
    if (doc11.createEvent) {
      var evt = doc11.createEvent("MouseEvent");
      if (evt.initMouseEvent) {
        evt.initMouseEvent(
          e2.type,
          e2.bubbles,
          // #10561, #12161
          e2.cancelable,
          e2.view || win13,
          e2.detail,
          e2.screenX,
          e2.screenY,
          e2.clientX,
          e2.clientY,
          e2.ctrlKey,
          e2.altKey,
          e2.shiftKey,
          e2.metaKey,
          e2.button,
          e2.relatedTarget
        );
        return evt;
      }
    }
    return getFakeMouseEvent2(e2.type);
  },
  /**
   * Utility function to clone a touch event for re-dispatching.
   * @private
   * @param {global.TouchEvent} e The event to clone.
   * @return {global.TouchEvent} The cloned event
   */
  cloneTouchEvent: function(e2) {
    var touchListToTouchArray = function(l) {
      var touchArray = [];
      for (var i = 0; i < l.length; ++i) {
        var item = l.item(i);
        if (item) {
          touchArray.push(item);
        }
      }
      return touchArray;
    };
    if (typeof win13.TouchEvent === "function") {
      var newEvent = new win13.TouchEvent(e2.type, {
        touches: touchListToTouchArray(e2.touches),
        targetTouches: touchListToTouchArray(e2.targetTouches),
        changedTouches: touchListToTouchArray(e2.changedTouches),
        ctrlKey: e2.ctrlKey,
        shiftKey: e2.shiftKey,
        altKey: e2.altKey,
        metaKey: e2.metaKey,
        bubbles: e2.bubbles,
        cancelable: e2.cancelable,
        composed: e2.composed,
        detail: e2.detail,
        view: e2.view
      });
      if (e2.defaultPrevented) {
        newEvent.preventDefault();
      }
      return newEvent;
    }
    var fakeEvt = this.cloneMouseEvent(e2);
    fakeEvt.touches = e2.touches;
    fakeEvt.changedTouches = e2.changedTouches;
    fakeEvt.targetTouches = e2.targetTouches;
    return fakeEvt;
  },
  /**
   * Remove traces of the component.
   * @private
   */
  destroyBase: function() {
    removeElement3(this.chart.a11yProxyContainer);
    this.domElementProvider.destroyCreatedElements();
    this.eventProvider.removeAddedEvents();
  }
};
extend33(AccessibilityComponent.prototype, functionsToOverrideByDerivedClasses);
var AccessibilityComponent_default = AccessibilityComponent;

// node_modules/highcharts/es-modules/Accessibility/KeyboardNavigation.js
var doc12 = Globals_default.doc;
var win14 = Globals_default.win;
var addEvent30 = Utilities_default.addEvent;
var fireEvent22 = Utilities_default.fireEvent;
var getElement2 = HTMLUtilities_default.getElement;
addEvent30(doc12, "keydown", function(e2) {
  var keycode = e2.which || e2.keyCode;
  var esc = 27;
  if (keycode === esc && Globals_default.charts) {
    Globals_default.charts.forEach(function(chart) {
      if (chart && chart.dismissPopupContent) {
        chart.dismissPopupContent();
      }
    });
  }
});
Chart_default.prototype.dismissPopupContent = function() {
  var chart = this;
  fireEvent22(this, "dismissPopupContent", {}, function() {
    if (chart.tooltip) {
      chart.tooltip.hide(0);
    }
    chart.hideExportMenu();
  });
};
function KeyboardNavigation(chart, components) {
  this.init(chart, components);
}
KeyboardNavigation.prototype = {
  /**
   * Initialize the class
   * @private
   * @param {Highcharts.Chart} chart
   *        Chart object
   * @param {object} components
   *        Map of component names to AccessibilityComponent objects.
   */
  init: function(chart, components) {
    var _this = this;
    var ep = this.eventProvider = new EventProvider_default();
    this.chart = chart;
    this.components = components;
    this.modules = [];
    this.currentModuleIx = 0;
    this.update();
    ep.addEvent(this.tabindexContainer, "keydown", function(e2) {
      return _this.onKeydown(e2);
    });
    ep.addEvent(this.tabindexContainer, "focus", function(e2) {
      return _this.onFocus(e2);
    });
    ["mouseup", "touchend"].forEach(function(eventName) {
      return ep.addEvent(doc12, eventName, function() {
        return _this.onMouseUp();
      });
    });
    ["mousedown", "touchstart"].forEach(function(eventName) {
      return ep.addEvent(chart.renderTo, eventName, function() {
        _this.isClickingChart = true;
      });
    });
    ep.addEvent(chart.renderTo, "mouseover", function() {
      _this.pointerIsOverChart = true;
    });
    ep.addEvent(chart.renderTo, "mouseout", function() {
      _this.pointerIsOverChart = false;
    });
    if (this.modules.length) {
      this.modules[0].init(1);
    }
  },
  /**
   * Update the modules for the keyboard navigation.
   * @param {Array<string>} [order]
   *        Array specifying the tab order of the components.
   */
  update: function(order) {
    var a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, components = this.components;
    this.updateContainerTabindex();
    if (keyboardOptions && keyboardOptions.enabled && order && order.length) {
      this.modules = order.reduce(function(modules, componentName) {
        var navModules = components[componentName].getKeyboardNavigation();
        return modules.concat(navModules);
      }, []);
      this.updateExitAnchor();
    } else {
      this.modules = [];
      this.currentModuleIx = 0;
      this.removeExitAnchor();
    }
  },
  /**
   * Function to run on container focus
   * @private
   * @param {global.FocusEvent} e Browser focus event.
   */
  onFocus: function(e2) {
    var chart = this.chart;
    var focusComesFromChart = e2.relatedTarget && chart.container.contains(e2.relatedTarget);
    if (!this.exiting && !this.tabbingInBackwards && !this.isClickingChart && !focusComesFromChart && this.modules[0]) {
      this.modules[0].init(1);
    }
    this.exiting = false;
  },
  /**
   * Reset chart navigation state if we click outside the chart and it's
   * not already reset.
   * @private
   */
  onMouseUp: function() {
    delete this.isClickingChart;
    if (!this.keyboardReset && !this.pointerIsOverChart) {
      var chart = this.chart, curMod = this.modules && this.modules[this.currentModuleIx || 0];
      if (curMod && curMod.terminate) {
        curMod.terminate();
      }
      if (chart.focusElement) {
        chart.focusElement.removeFocusBorder();
      }
      this.currentModuleIx = 0;
      this.keyboardReset = true;
    }
  },
  /**
   * Function to run on keydown
   * @private
   * @param {global.KeyboardEvent} ev Browser keydown event.
   */
  onKeydown: function(ev) {
    var e2 = ev || win14.event, preventDefault, curNavModule = this.modules && this.modules.length && this.modules[this.currentModuleIx];
    this.keyboardReset = false;
    this.exiting = false;
    if (curNavModule) {
      var response = curNavModule.run(e2);
      if (response === curNavModule.response.success) {
        preventDefault = true;
      } else if (response === curNavModule.response.prev) {
        preventDefault = this.prev();
      } else if (response === curNavModule.response.next) {
        preventDefault = this.next();
      }
      if (preventDefault) {
        e2.preventDefault();
        e2.stopPropagation();
      }
    }
  },
  /**
   * Go to previous module.
   * @private
   */
  prev: function() {
    return this.move(-1);
  },
  /**
   * Go to next module.
   * @private
   */
  next: function() {
    return this.move(1);
  },
  /**
   * Move to prev/next module.
   * @private
   * @param {number} direction
   * Direction to move. +1 for next, -1 for prev.
   * @return {boolean}
   * True if there was a valid module in direction.
   */
  move: function(direction) {
    var curModule = this.modules && this.modules[this.currentModuleIx];
    if (curModule && curModule.terminate) {
      curModule.terminate(direction);
    }
    if (this.chart.focusElement) {
      this.chart.focusElement.removeFocusBorder();
    }
    this.currentModuleIx += direction;
    var newModule = this.modules && this.modules[this.currentModuleIx];
    if (newModule) {
      if (newModule.validate && !newModule.validate()) {
        return this.move(direction);
      }
      if (newModule.init) {
        newModule.init(direction);
        return true;
      }
    }
    this.currentModuleIx = 0;
    this.exiting = true;
    if (direction > 0) {
      this.exitAnchor.focus();
    } else {
      this.tabindexContainer.focus();
    }
    return false;
  },
  /**
   * We use an exit anchor to move focus out of chart whenever we want, by
   * setting focus to this div and not preventing the default tab action. We
   * also use this when users come back into the chart by tabbing back, in
   * order to navigate from the end of the chart.
   * @private
   */
  updateExitAnchor: function() {
    var endMarkerId = "highcharts-end-of-chart-marker-" + this.chart.index, endMarker = getElement2(endMarkerId);
    this.removeExitAnchor();
    if (endMarker) {
      this.makeElementAnExitAnchor(endMarker);
      this.exitAnchor = endMarker;
    } else {
      this.createExitAnchor();
    }
  },
  /**
   * Chart container should have tabindex if navigation is enabled.
   * @private
   */
  updateContainerTabindex: function() {
    var a11yOptions = this.chart.options.accessibility, keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation, shouldHaveTabindex = !(keyboardOptions && keyboardOptions.enabled === false), chart = this.chart, container = chart.container;
    var tabindexContainer;
    if (chart.renderTo.hasAttribute("tabindex")) {
      container.removeAttribute("tabindex");
      tabindexContainer = chart.renderTo;
    } else {
      tabindexContainer = container;
    }
    this.tabindexContainer = tabindexContainer;
    var curTabindex = tabindexContainer.getAttribute("tabindex");
    if (shouldHaveTabindex && !curTabindex) {
      tabindexContainer.setAttribute("tabindex", "0");
    } else if (!shouldHaveTabindex) {
      chart.container.removeAttribute("tabindex");
    }
  },
  /**
   * @private
   */
  makeElementAnExitAnchor: function(el) {
    var chartTabindex = this.tabindexContainer.getAttribute("tabindex") || 0;
    el.setAttribute("class", "highcharts-exit-anchor");
    el.setAttribute("tabindex", chartTabindex);
    el.setAttribute("aria-hidden", false);
    this.addExitAnchorEventsToEl(el);
  },
  /**
   * Add new exit anchor to the chart.
   *
   * @private
   */
  createExitAnchor: function() {
    var chart = this.chart, exitAnchor = this.exitAnchor = doc12.createElement("div");
    chart.renderTo.appendChild(exitAnchor);
    this.makeElementAnExitAnchor(exitAnchor);
  },
  /**
   * @private
   */
  removeExitAnchor: function() {
    if (this.exitAnchor && this.exitAnchor.parentNode) {
      this.exitAnchor.parentNode.removeChild(this.exitAnchor);
      delete this.exitAnchor;
    }
  },
  /**
   * @private
   */
  addExitAnchorEventsToEl: function(element) {
    var chart = this.chart, keyboardNavigation = this;
    this.eventProvider.addEvent(element, "focus", function(ev) {
      var e2 = ev || win14.event, curModule, focusComesFromChart = e2.relatedTarget && chart.container.contains(e2.relatedTarget), comingInBackwards = !(focusComesFromChart || keyboardNavigation.exiting);
      if (comingInBackwards) {
        keyboardNavigation.tabbingInBackwards = true;
        keyboardNavigation.tabindexContainer.focus();
        delete keyboardNavigation.tabbingInBackwards;
        e2.preventDefault();
        if (keyboardNavigation.modules && keyboardNavigation.modules.length) {
          keyboardNavigation.currentModuleIx = keyboardNavigation.modules.length - 1;
          curModule = keyboardNavigation.modules[keyboardNavigation.currentModuleIx];
          if (curModule && curModule.validate && !curModule.validate()) {
            keyboardNavigation.prev();
          } else if (curModule) {
            curModule.init(-1);
          }
        }
      } else {
        keyboardNavigation.exiting = false;
      }
    });
  },
  /**
   * Remove all traces of keyboard navigation.
   * @private
   */
  destroy: function() {
    this.removeExitAnchor();
    this.eventProvider.removeAddedEvents();
    this.chart.container.removeAttribute("tabindex");
  }
};
var KeyboardNavigation_default = KeyboardNavigation;

// node_modules/highcharts/es-modules/Accessibility/Components/LegendComponent.js
var animObject10 = AnimationUtilities_default.animObject;
var addEvent31 = Utilities_default.addEvent;
var extend34 = Utilities_default.extend;
var find13 = Utilities_default.find;
var fireEvent23 = Utilities_default.fireEvent;
var isNumber32 = Utilities_default.isNumber;
var pick46 = Utilities_default.pick;
var syncTimeout9 = Utilities_default.syncTimeout;
var removeElement4 = HTMLUtilities_default.removeElement;
var stripHTMLTags2 = HTMLUtilities_default.stripHTMLTagsFromString;
var getChartTitle2 = ChartUtilities_default.getChartTitle;
function scrollLegendToItem(legend, itemIx) {
  var itemPage = legend.allItems[itemIx].pageIx, curPage = legend.currentPage;
  if (typeof itemPage !== "undefined" && itemPage + 1 !== curPage) {
    legend.scroll(1 + itemPage - curPage);
  }
}
function shouldDoLegendA11y(chart) {
  var items = chart.legend && chart.legend.allItems, legendA11yOptions = chart.options.legend.accessibility || {};
  return !!(items && items.length && !(chart.colorAxis && chart.colorAxis.length) && legendA11yOptions.enabled !== false);
}
Chart_default.prototype.highlightLegendItem = function(ix) {
  var items = this.legend.allItems, oldIx = this.accessibility && this.accessibility.components.legend.highlightedLegendItemIx;
  if (items[ix]) {
    if (isNumber32(oldIx) && items[oldIx]) {
      fireEvent23(items[oldIx].legendGroup.element, "mouseout");
    }
    scrollLegendToItem(this.legend, ix);
    this.setFocusToElement(items[ix].legendItem, items[ix].a11yProxyElement);
    fireEvent23(items[ix].legendGroup.element, "mouseover");
    return true;
  }
  return false;
};
addEvent31(Legend_default, "afterColorizeItem", function(e2) {
  var chart = this.chart, a11yOptions = chart.options.accessibility, legendItem = e2.item;
  if (a11yOptions.enabled && legendItem && legendItem.a11yProxyElement) {
    legendItem.a11yProxyElement.setAttribute("aria-pressed", e2.visible ? "true" : "false");
  }
});
var LegendComponent = function() {
};
LegendComponent.prototype = new AccessibilityComponent_default();
extend34(
  LegendComponent.prototype,
  /** @lends Highcharts.LegendComponent */
  {
    /**
     * Init the component
     * @private
     */
    init: function() {
      var component = this;
      this.proxyElementsList = [];
      this.recreateProxies();
      this.addEvent(Legend_default, "afterScroll", function() {
        if (this.chart === component.chart) {
          component.updateProxiesPositions();
          component.updateLegendItemProxyVisibility();
          this.chart.highlightLegendItem(component.highlightedLegendItemIx);
        }
      });
      this.addEvent(Legend_default, "afterPositionItem", function(e2) {
        if (this.chart === component.chart && this.chart.renderer) {
          component.updateProxyPositionForItem(e2.item);
        }
      });
      this.addEvent(Legend_default, "afterRender", function() {
        if (this.chart === component.chart && this.chart.renderer && component.recreateProxies()) {
          syncTimeout9(function() {
            return component.updateProxiesPositions();
          }, animObject10(pick46(this.chart.renderer.globalAnimation, true)).duration);
        }
      });
    },
    /**
     * @private
     */
    updateLegendItemProxyVisibility: function() {
      var legend = this.chart.legend, items = legend.allItems || [], curPage = legend.currentPage || 1, clipHeight = legend.clipHeight || 0;
      items.forEach(function(item) {
        var itemPage = item.pageIx || 0, y = item._legendItemPos ? item._legendItemPos[1] : 0, h = item.legendItem ? Math.round(item.legendItem.getBBox().height) : 0, hide = y + h - legend.pages[itemPage] > clipHeight || itemPage !== curPage - 1;
        if (item.a11yProxyElement) {
          item.a11yProxyElement.style.visibility = hide ? "hidden" : "visible";
        }
      });
    },
    /**
     * The legend needs updates on every render, in order to update positioning
     * of the proxy overlays.
     */
    onChartRender: function() {
      if (!shouldDoLegendA11y(this.chart)) {
        this.removeProxies();
      }
    },
    /**
     * @private
     */
    onChartUpdate: function() {
      this.updateLegendTitle();
    },
    /**
     * @private
     */
    updateProxiesPositions: function() {
      for (var _i = 0, _a15 = this.proxyElementsList; _i < _a15.length; _i++) {
        var _b = _a15[_i], element = _b.element, posElement = _b.posElement;
        this.updateProxyButtonPosition(element, posElement);
      }
    },
    /**
     * @private
     */
    updateProxyPositionForItem: function(item) {
      var proxyRef = find13(this.proxyElementsList, function(ref) {
        return ref.item === item;
      });
      if (proxyRef) {
        this.updateProxyButtonPosition(proxyRef.element, proxyRef.posElement);
      }
    },
    /**
     * @private
     */
    recreateProxies: function() {
      this.removeProxies();
      if (shouldDoLegendA11y(this.chart)) {
        this.addLegendProxyGroup();
        this.addLegendListContainer();
        this.proxyLegendItems();
        this.updateLegendItemProxyVisibility();
        return true;
      }
      return false;
    },
    /**
     * @private
     */
    removeProxies: function() {
      removeElement4(this.legendProxyGroup);
      this.proxyElementsList = [];
    },
    /**
     * @private
     */
    updateLegendTitle: function() {
      var chart = this.chart;
      var legendTitle = stripHTMLTags2((chart.legend && chart.legend.options.title && chart.legend.options.title.text || "").replace(/<br ?\/?>/g, " "));
      var legendLabel = chart.langFormat("accessibility.legend.legendLabel" + (legendTitle ? "" : "NoTitle"), {
        chart,
        legendTitle,
        chartTitle: getChartTitle2(chart)
      });
      if (this.legendProxyGroup) {
        this.legendProxyGroup.setAttribute("aria-label", legendLabel);
      }
    },
    /**
     * @private
     */
    addLegendProxyGroup: function() {
      var a11yOptions = this.chart.options.accessibility, groupRole = a11yOptions.landmarkVerbosity === "all" ? "region" : null;
      this.legendProxyGroup = this.addProxyGroup({
        "aria-label": "_placeholder_",
        role: groupRole
      });
    },
    /**
     * @private
     */
    addLegendListContainer: function() {
      if (this.legendProxyGroup) {
        var container = this.legendListContainer = this.createElement("ul");
        container.style.listStyle = "none";
        this.legendProxyGroup.appendChild(container);
      }
    },
    /**
     * @private
     */
    proxyLegendItems: function() {
      var component = this, items = this.chart.legend && this.chart.legend.allItems || [];
      items.forEach(function(item) {
        if (item.legendItem && item.legendItem.element) {
          component.proxyLegendItem(item);
        }
      });
    },
    /**
     * @private
     * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item
     */
    proxyLegendItem: function(item) {
      if (!item.legendItem || !item.legendGroup || !this.legendListContainer) {
        return;
      }
      var itemLabel = this.chart.langFormat("accessibility.legend.legendItem", {
        chart: this.chart,
        itemName: stripHTMLTags2(item.name),
        item
      }), attribs = {
        tabindex: -1,
        "aria-pressed": item.visible,
        "aria-label": itemLabel
      }, proxyPositioningElement = item.legendGroup.div ? item.legendItem : item.legendGroup;
      var listItem = this.createElement("li");
      this.legendListContainer.appendChild(listItem);
      item.a11yProxyElement = this.createProxyButton(item.legendItem, listItem, attribs, proxyPositioningElement);
      this.proxyElementsList.push({
        item,
        element: item.a11yProxyElement,
        posElement: proxyPositioningElement
      });
    },
    /**
     * Get keyboard navigation handler for this component.
     * @return {Highcharts.KeyboardNavigationHandler}
     */
    getKeyboardNavigation: function() {
      var keys2 = this.keyCodes, component = this, chart = this.chart;
      return new KeyboardNavigationHandler_default(chart, {
        keyCodeMap: [
          [
            [keys2.left, keys2.right, keys2.up, keys2.down],
            function(keyCode) {
              return component.onKbdArrowKey(this, keyCode);
            }
          ],
          [
            [keys2.enter, keys2.space],
            function(keyCode) {
              if (Globals_default.isFirefox && keyCode === keys2.space) {
                return this.response.success;
              }
              return component.onKbdClick(this);
            }
          ]
        ],
        validate: function() {
          return component.shouldHaveLegendNavigation();
        },
        init: function(direction) {
          return component.onKbdNavigationInit(direction);
        },
        terminate: function() {
          chart.legend.allItems.forEach(function(item) {
            return item.setState("", true);
          });
        }
      });
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
     * @param {number} keyCode
     * @return {number}
     * Response code
     */
    onKbdArrowKey: function(keyboardNavigationHandler, keyCode) {
      var keys2 = this.keyCodes, response = keyboardNavigationHandler.response, chart = this.chart, a11yOptions = chart.options.accessibility, numItems = chart.legend.allItems.length, direction = keyCode === keys2.left || keyCode === keys2.up ? -1 : 1;
      var res = chart.highlightLegendItem(this.highlightedLegendItemIx + direction);
      if (res) {
        this.highlightedLegendItemIx += direction;
        return response.success;
      }
      if (numItems > 1 && a11yOptions.keyboardNavigation.wrapAround) {
        keyboardNavigationHandler.init(direction);
        return response.success;
      }
      return response[direction > 0 ? "next" : "prev"];
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
     * @return {number}
     * Response code
     */
    onKbdClick: function(keyboardNavigationHandler) {
      var legendItem = this.chart.legend.allItems[this.highlightedLegendItemIx];
      if (legendItem && legendItem.a11yProxyElement) {
        fireEvent23(legendItem.a11yProxyElement, "click");
      }
      return keyboardNavigationHandler.response.success;
    },
    /**
     * @private
     * @return {boolean|undefined}
     */
    shouldHaveLegendNavigation: function() {
      var chart = this.chart, legendOptions = chart.options.legend || {}, hasLegend = chart.legend && chart.legend.allItems, hasColorAxis = chart.colorAxis && chart.colorAxis.length, legendA11yOptions = legendOptions.accessibility || {};
      return !!(hasLegend && chart.legend.display && !hasColorAxis && legendA11yOptions.enabled && legendA11yOptions.keyboardNavigation && legendA11yOptions.keyboardNavigation.enabled);
    },
    /**
     * @private
     * @param {number} direction
     */
    onKbdNavigationInit: function(direction) {
      var chart = this.chart, lastIx = chart.legend.allItems.length - 1, ixToHighlight = direction > 0 ? 0 : lastIx;
      chart.highlightLegendItem(ixToHighlight);
      this.highlightedLegendItemIx = ixToHighlight;
    }
  }
);
var LegendComponent_default = LegendComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/MenuComponent.js
var extend35 = Utilities_default.extend;
var getChartTitle3 = ChartUtilities_default.getChartTitle;
var unhideChartElementFromAT3 = ChartUtilities_default.unhideChartElementFromAT;
var removeElement5 = HTMLUtilities_default.removeElement;
var getFakeMouseEvent3 = HTMLUtilities_default.getFakeMouseEvent;
function getExportMenuButtonElement(chart) {
  return chart.exportSVGElements && chart.exportSVGElements[0];
}
Chart_default.prototype.showExportMenu = function() {
  var exportButton = getExportMenuButtonElement(this);
  if (exportButton) {
    var el = exportButton.element;
    if (el.onclick) {
      el.onclick(getFakeMouseEvent3("click"));
    }
  }
};
Chart_default.prototype.hideExportMenu = function() {
  var chart = this, exportList = chart.exportDivElements;
  if (exportList && chart.exportContextMenu) {
    exportList.forEach(function(el) {
      if (el && el.className === "highcharts-menu-item" && el.onmouseout) {
        el.onmouseout(getFakeMouseEvent3("mouseout"));
      }
    });
    chart.highlightedExportItemIx = 0;
    chart.exportContextMenu.hideMenu();
    chart.container.focus();
  }
};
Chart_default.prototype.highlightExportItem = function(ix) {
  var listItem = this.exportDivElements && this.exportDivElements[ix], curHighlighted = this.exportDivElements && this.exportDivElements[this.highlightedExportItemIx], hasSVGFocusSupport;
  if (listItem && listItem.tagName === "LI" && !(listItem.children && listItem.children.length)) {
    hasSVGFocusSupport = !!(this.renderTo.getElementsByTagName("g")[0] || {}).focus;
    if (listItem.focus && hasSVGFocusSupport) {
      listItem.focus();
    }
    if (curHighlighted && curHighlighted.onmouseout) {
      curHighlighted.onmouseout(getFakeMouseEvent3("mouseout"));
    }
    if (listItem.onmouseover) {
      listItem.onmouseover(getFakeMouseEvent3("mouseover"));
    }
    this.highlightedExportItemIx = ix;
    return true;
  }
  return false;
};
Chart_default.prototype.highlightLastExportItem = function() {
  var chart = this, i;
  if (chart.exportDivElements) {
    i = chart.exportDivElements.length;
    while (i--) {
      if (chart.highlightExportItem(i)) {
        return true;
      }
    }
  }
  return false;
};
function exportingShouldHaveA11y(chart) {
  var exportingOpts = chart.options.exporting, exportButton = getExportMenuButtonElement(chart);
  return !!(exportingOpts && exportingOpts.enabled !== false && exportingOpts.accessibility && exportingOpts.accessibility.enabled && exportButton && exportButton.element);
}
var MenuComponent = function() {
};
MenuComponent.prototype = new AccessibilityComponent_default();
extend35(
  MenuComponent.prototype,
  /** @lends Highcharts.MenuComponent */
  {
    /**
     * Init the component
     */
    init: function() {
      var chart = this.chart, component = this;
      this.addEvent(chart, "exportMenuShown", function() {
        component.onMenuShown();
      });
      this.addEvent(chart, "exportMenuHidden", function() {
        component.onMenuHidden();
      });
    },
    /**
     * @private
     */
    onMenuHidden: function() {
      var menu = this.chart.exportContextMenu;
      if (menu) {
        menu.setAttribute("aria-hidden", "true");
      }
      this.isExportMenuShown = false;
      this.setExportButtonExpandedState("false");
    },
    /**
     * @private
     */
    onMenuShown: function() {
      var chart = this.chart, menu = chart.exportContextMenu;
      if (menu) {
        this.addAccessibleContextMenuAttribs();
        unhideChartElementFromAT3(chart, menu);
      }
      this.isExportMenuShown = true;
      this.setExportButtonExpandedState("true");
    },
    /**
     * @private
     * @param {string} stateStr
     */
    setExportButtonExpandedState: function(stateStr) {
      var button = this.exportButtonProxy;
      if (button) {
        button.setAttribute("aria-expanded", stateStr);
      }
    },
    /**
     * Called on each render of the chart. We need to update positioning of the
     * proxy overlay.
     */
    onChartRender: function() {
      var chart = this.chart, a11yOptions = chart.options.accessibility;
      removeElement5(this.exportProxyGroup);
      if (exportingShouldHaveA11y(chart)) {
        this.exportProxyGroup = this.addProxyGroup(
          // Wrap in a region div if verbosity is high
          a11yOptions.landmarkVerbosity === "all" ? {
            "aria-label": chart.langFormat("accessibility.exporting.exportRegionLabel", { chart, chartTitle: getChartTitle3(chart) }),
            "role": "region"
          } : {}
        );
        var button = getExportMenuButtonElement(this.chart);
        this.exportButtonProxy = this.createProxyButton(button, this.exportProxyGroup, {
          "aria-label": chart.langFormat("accessibility.exporting.menuButtonLabel", { chart }),
          "aria-expanded": false
        });
      }
    },
    /**
     * @private
     */
    addAccessibleContextMenuAttribs: function() {
      var chart = this.chart, exportList = chart.exportDivElements;
      if (exportList && exportList.length) {
        exportList.forEach(function(item) {
          if (item) {
            if (item.tagName === "LI" && !(item.children && item.children.length)) {
              item.setAttribute("tabindex", -1);
            } else {
              item.setAttribute("aria-hidden", "true");
            }
          }
        });
        var parentDiv = exportList[0] && exportList[0].parentNode;
        if (parentDiv) {
          parentDiv.removeAttribute("aria-hidden");
          parentDiv.setAttribute("aria-label", chart.langFormat("accessibility.exporting.chartMenuLabel", { chart }));
        }
      }
    },
    /**
     * Get keyboard navigation handler for this component.
     * @return {Highcharts.KeyboardNavigationHandler}
     */
    getKeyboardNavigation: function() {
      var keys2 = this.keyCodes, chart = this.chart, component = this;
      return new KeyboardNavigationHandler_default(chart, {
        keyCodeMap: [
          // Arrow prev handler
          [
            [keys2.left, keys2.up],
            function() {
              return component.onKbdPrevious(this);
            }
          ],
          // Arrow next handler
          [
            [keys2.right, keys2.down],
            function() {
              return component.onKbdNext(this);
            }
          ],
          // Click handler
          [
            [keys2.enter, keys2.space],
            function() {
              return component.onKbdClick(this);
            }
          ]
        ],
        // Only run exporting navigation if exporting support exists and is
        // enabled on chart
        validate: function() {
          return !!chart.exporting && chart.options.exporting.enabled !== false && chart.options.exporting.accessibility.enabled !== false;
        },
        // Focus export menu button
        init: function() {
          var exportBtn = component.exportButtonProxy, exportGroup = chart.exportingGroup;
          if (exportGroup && exportBtn) {
            chart.setFocusToElement(exportGroup, exportBtn);
          }
        },
        // Hide the menu
        terminate: function() {
          chart.hideExportMenu();
        }
      });
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
     * @return {number}
     * Response code
     */
    onKbdPrevious: function(keyboardNavigationHandler) {
      var chart = this.chart, a11yOptions = chart.options.accessibility, response = keyboardNavigationHandler.response, i = chart.highlightedExportItemIx || 0;
      while (i--) {
        if (chart.highlightExportItem(i)) {
          return response.success;
        }
      }
      if (a11yOptions.keyboardNavigation.wrapAround) {
        chart.highlightLastExportItem();
        return response.success;
      }
      return response.prev;
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
     * @return {number}
     * Response code
     */
    onKbdNext: function(keyboardNavigationHandler) {
      var chart = this.chart, a11yOptions = chart.options.accessibility, response = keyboardNavigationHandler.response, i = (chart.highlightedExportItemIx || 0) + 1;
      for (; i < chart.exportDivElements.length; ++i) {
        if (chart.highlightExportItem(i)) {
          return response.success;
        }
      }
      if (a11yOptions.keyboardNavigation.wrapAround) {
        chart.highlightExportItem(0);
        return response.success;
      }
      return response.next;
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
     * @return {number}
     * Response code
     */
    onKbdClick: function(keyboardNavigationHandler) {
      var chart = this.chart, curHighlightedItem = chart.exportDivElements[chart.highlightedExportItemIx], exportButtonElement = getExportMenuButtonElement(chart).element;
      if (this.isExportMenuShown) {
        this.fakeClickEvent(curHighlightedItem);
      } else {
        this.fakeClickEvent(exportButtonElement);
        chart.highlightExportItem(0);
      }
      return keyboardNavigationHandler.response.success;
    }
  }
);
var MenuComponent_default = MenuComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js
var seriesTypes4 = SeriesRegistry_default.seriesTypes;
var doc13 = Globals_default.doc;
var defined35 = Utilities_default.defined;
var extend36 = Utilities_default.extend;
var fireEvent24 = Utilities_default.fireEvent;
var getPointFromXY2 = ChartUtilities_default.getPointFromXY;
var getSeriesFromName2 = ChartUtilities_default.getSeriesFromName;
var scrollToPoint2 = ChartUtilities_default.scrollToPoint;
Series_default.prototype.keyboardMoveVertical = true;
["column", "pie"].forEach(function(type) {
  if (seriesTypes4[type]) {
    seriesTypes4[type].prototype.keyboardMoveVertical = false;
  }
});
function getPointIndex(point) {
  var index = point.index, points = point.series.points;
  var i = points.length;
  if (points[index] !== point) {
    while (i--) {
      if (points[i] === point) {
        return i;
      }
    }
  } else {
    return index;
  }
}
function isSkipSeries(series) {
  var a11yOptions = series.chart.options.accessibility, seriesNavOptions = a11yOptions.keyboardNavigation.seriesNavigation, seriesA11yOptions = series.options.accessibility || {}, seriesKbdNavOptions = seriesA11yOptions.keyboardNavigation;
  return seriesKbdNavOptions && seriesKbdNavOptions.enabled === false || seriesA11yOptions.enabled === false || series.options.enableMouseTracking === false || // #8440
  !series.visible || // Skip all points in a series where pointNavigationEnabledThreshold is
  // reached
  seriesNavOptions.pointNavigationEnabledThreshold && seriesNavOptions.pointNavigationEnabledThreshold <= series.points.length;
}
function isSkipPoint(point) {
  var a11yOptions = point.series.chart.options.accessibility;
  var pointA11yDisabled = point.options.accessibility && point.options.accessibility.enabled === false;
  return point.isNull && a11yOptions.keyboardNavigation.seriesNavigation.skipNullPoints || point.visible === false || point.isInside === false || pointA11yDisabled || isSkipSeries(point.series);
}
function getClosestPoint(point, series, xWeight, yWeight) {
  var minDistance = Infinity, dPoint, minIx, distance, i = series.points.length;
  var hasUndefinedPosition = function(point2) {
    return !(defined35(point2.plotX) && defined35(point2.plotY));
  };
  if (hasUndefinedPosition(point)) {
    return;
  }
  while (i--) {
    dPoint = series.points[i];
    if (hasUndefinedPosition(dPoint)) {
      continue;
    }
    distance = (point.plotX - dPoint.plotX) * (point.plotX - dPoint.plotX) * (xWeight || 1) + (point.plotY - dPoint.plotY) * (point.plotY - dPoint.plotY) * (yWeight || 1);
    if (distance < minDistance) {
      minDistance = distance;
      minIx = i;
    }
  }
  return defined35(minIx) ? series.points[minIx] : void 0;
}
Point_default.prototype.highlight = function() {
  var chart = this.series.chart;
  if (!this.isNull) {
    this.onMouseOver();
  } else {
    if (chart.tooltip) {
      chart.tooltip.hide(0);
    }
  }
  scrollToPoint2(this);
  if (this.graphic) {
    chart.setFocusToElement(this.graphic);
  }
  chart.highlightedPoint = this;
  return this;
};
Chart_default.prototype.highlightAdjacentPoint = function(next) {
  var chart = this, series = chart.series, curPoint = chart.highlightedPoint, curPointIndex = curPoint && getPointIndex(curPoint) || 0, curPoints = curPoint && curPoint.series.points, lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
  var newSeries, newPoint;
  if (!series[0] || !series[0].points) {
    return false;
  }
  if (!curPoint) {
    newPoint = next ? series[0].points[0] : lastPoint;
  } else {
    newSeries = series[curPoint.series.index + (next ? 1 : -1)];
    newPoint = curPoints[curPointIndex + (next ? 1 : -1)];
    if (!newPoint && newSeries) {
      newPoint = newSeries.points[next ? 0 : newSeries.points.length - 1];
    }
    if (!newPoint) {
      return false;
    }
  }
  if (isSkipPoint(newPoint)) {
    newSeries = newPoint.series;
    if (isSkipSeries(newSeries)) {
      chart.highlightedPoint = next ? newSeries.points[newSeries.points.length - 1] : newSeries.points[0];
    } else {
      chart.highlightedPoint = newPoint;
    }
    return chart.highlightAdjacentPoint(next);
  }
  return newPoint.highlight();
};
Series_default.prototype.highlightFirstValidPoint = function() {
  var curPoint = this.chart.highlightedPoint, start = (curPoint && curPoint.series) === this ? getPointIndex(curPoint) : 0, points = this.points, len = points.length;
  if (points && len) {
    for (var i = start; i < len; ++i) {
      if (!isSkipPoint(points[i])) {
        return points[i].highlight();
      }
    }
    for (var j = start; j >= 0; --j) {
      if (!isSkipPoint(points[j])) {
        return points[j].highlight();
      }
    }
  }
  return false;
};
Chart_default.prototype.highlightAdjacentSeries = function(down) {
  var chart = this, curPoint = chart.highlightedPoint, lastSeries = chart.series && chart.series[chart.series.length - 1], lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
  var newSeries, newPoint, adjacentNewPoint;
  if (!chart.highlightedPoint) {
    newSeries = down ? chart.series && chart.series[0] : lastSeries;
    newPoint = down ? newSeries && newSeries.points && newSeries.points[0] : lastPoint;
    return newPoint ? newPoint.highlight() : false;
  }
  newSeries = chart.series[curPoint.series.index + (down ? -1 : 1)];
  if (!newSeries) {
    return false;
  }
  newPoint = getClosestPoint(curPoint, newSeries, 4);
  if (!newPoint) {
    return false;
  }
  if (isSkipSeries(newSeries)) {
    newPoint.highlight();
    adjacentNewPoint = chart.highlightAdjacentSeries(down);
    if (!adjacentNewPoint) {
      curPoint.highlight();
      return false;
    }
    return adjacentNewPoint;
  }
  newPoint.highlight();
  return newPoint.series.highlightFirstValidPoint();
};
Chart_default.prototype.highlightAdjacentPointVertical = function(down) {
  var curPoint = this.highlightedPoint;
  var minDistance = Infinity, bestPoint;
  if (!defined35(curPoint.plotX) || !defined35(curPoint.plotY)) {
    return false;
  }
  this.series.forEach(function(series) {
    if (isSkipSeries(series)) {
      return;
    }
    series.points.forEach(function(point) {
      if (!defined35(point.plotY) || !defined35(point.plotX) || point === curPoint) {
        return;
      }
      var yDistance = point.plotY - curPoint.plotY;
      var width = Math.abs(point.plotX - curPoint.plotX), distance = Math.abs(yDistance) * Math.abs(yDistance) + width * width * 4;
      if (series.yAxis && series.yAxis.reversed) {
        yDistance *= -1;
      }
      if (yDistance <= 0 && down || yDistance >= 0 && !down || // Chk dir
      distance < 5 || // Points in same spot => infinite loop
      isSkipPoint(point)) {
        return;
      }
      if (distance < minDistance) {
        minDistance = distance;
        bestPoint = point;
      }
    });
  });
  return bestPoint ? bestPoint.highlight() : false;
};
function highlightFirstValidPointInChart(chart) {
  var res = false;
  delete chart.highlightedPoint;
  res = chart.series.reduce(function(acc, cur) {
    return acc || cur.highlightFirstValidPoint();
  }, false);
  return res;
}
function highlightLastValidPointInChart(chart) {
  var numSeries = chart.series.length;
  var i = numSeries, res = false;
  while (i--) {
    chart.highlightedPoint = chart.series[i].points[chart.series[i].points.length - 1];
    res = chart.series[i].highlightFirstValidPoint();
    if (res) {
      break;
    }
  }
  return res;
}
function updateChartFocusAfterDrilling(chart) {
  highlightFirstValidPointInChart(chart);
  if (chart.focusElement) {
    chart.focusElement.removeFocusBorder();
  }
}
function SeriesKeyboardNavigation(chart, keyCodes) {
  this.keyCodes = keyCodes;
  this.chart = chart;
}
extend36(
  SeriesKeyboardNavigation.prototype,
  /** @lends Highcharts.SeriesKeyboardNavigation */
  {
    /**
     * Init the keyboard navigation
     */
    init: function() {
      var keyboardNavigation = this, chart = this.chart, e2 = this.eventProvider = new EventProvider_default();
      e2.addEvent(Series_default, "destroy", function() {
        return keyboardNavigation.onSeriesDestroy(this);
      });
      e2.addEvent(chart, "afterDrilldown", function() {
        updateChartFocusAfterDrilling(this);
      });
      e2.addEvent(chart, "drilldown", function(e3) {
        var point = e3.point, series = point.series;
        keyboardNavigation.lastDrilledDownPoint = {
          x: point.x,
          y: point.y,
          seriesName: series ? series.name : ""
        };
      });
      e2.addEvent(chart, "drillupall", function() {
        setTimeout(function() {
          keyboardNavigation.onDrillupAll();
        }, 10);
      });
      e2.addEvent(Point_default, "afterSetState", function() {
        var point = this;
        var pointEl = point.graphic && point.graphic.element;
        if (chart.highlightedPoint === point && doc13.activeElement !== pointEl && pointEl && pointEl.focus) {
          pointEl.focus();
        }
      });
    },
    onDrillupAll: function() {
      var last = this.lastDrilledDownPoint, chart = this.chart, series = last && getSeriesFromName2(chart, last.seriesName);
      var point;
      if (last && series && defined35(last.x) && defined35(last.y)) {
        point = getPointFromXY2(series, last.x, last.y);
      }
      if (chart.container) {
        chart.container.focus();
      }
      if (point && point.highlight) {
        point.highlight();
      }
      if (chart.focusElement) {
        chart.focusElement.removeFocusBorder();
      }
    },
    /**
     * @return {Highcharts.KeyboardNavigationHandler}
     */
    getKeyboardNavigationHandler: function() {
      var keyboardNavigation = this, keys2 = this.keyCodes, chart = this.chart, inverted = chart.inverted;
      return new KeyboardNavigationHandler_default(chart, {
        keyCodeMap: [
          [inverted ? [keys2.up, keys2.down] : [keys2.left, keys2.right], function(keyCode) {
            return keyboardNavigation.onKbdSideways(this, keyCode);
          }],
          [inverted ? [keys2.left, keys2.right] : [keys2.up, keys2.down], function(keyCode) {
            return keyboardNavigation.onKbdVertical(this, keyCode);
          }],
          [[keys2.enter, keys2.space], function(keyCode, event) {
            var point = chart.highlightedPoint;
            if (point) {
              event.point = point;
              fireEvent24(point.series, "click", event);
              point.firePointEvent("click");
            }
            return this.response.success;
          }]
        ],
        init: function(dir) {
          return keyboardNavigation.onHandlerInit(this, dir);
        },
        terminate: function() {
          return keyboardNavigation.onHandlerTerminate();
        }
      });
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} handler
     * @param {number} keyCode
     * @return {number}
     * response
     */
    onKbdSideways: function(handler, keyCode) {
      var keys2 = this.keyCodes, isNext = keyCode === keys2.right || keyCode === keys2.down;
      return this.attemptHighlightAdjacentPoint(handler, isNext);
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} handler
     * @param {number} keyCode
     * @return {number}
     * response
     */
    onKbdVertical: function(handler, keyCode) {
      var chart = this.chart, keys2 = this.keyCodes, isNext = keyCode === keys2.down || keyCode === keys2.right, navOptions = chart.options.accessibility.keyboardNavigation.seriesNavigation;
      if (navOptions.mode && navOptions.mode === "serialize") {
        return this.attemptHighlightAdjacentPoint(handler, isNext);
      }
      var highlightMethod = chart.highlightedPoint && chart.highlightedPoint.series.keyboardMoveVertical ? "highlightAdjacentPointVertical" : "highlightAdjacentSeries";
      chart[highlightMethod](isNext);
      return handler.response.success;
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} handler
     * @param {number} initDirection
     * @return {number}
     * response
     */
    onHandlerInit: function(handler, initDirection) {
      var chart = this.chart;
      if (initDirection > 0) {
        highlightFirstValidPointInChart(chart);
      } else {
        highlightLastValidPointInChart(chart);
      }
      return handler.response.success;
    },
    /**
     * @private
     */
    onHandlerTerminate: function() {
      var chart = this.chart;
      if (chart.tooltip) {
        chart.tooltip.hide(0);
      }
      var hoverSeries = chart.highlightedPoint && chart.highlightedPoint.series;
      if (hoverSeries && hoverSeries.onMouseOut) {
        hoverSeries.onMouseOut();
      }
      if (chart.highlightedPoint && chart.highlightedPoint.onMouseOut) {
        chart.highlightedPoint.onMouseOut();
      }
      delete chart.highlightedPoint;
    },
    /**
     * Function that attempts to highlight next/prev point. Handles wrap around.
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} handler
     * @param {boolean} directionIsNext
     * @return {number}
     * response
     */
    attemptHighlightAdjacentPoint: function(handler, directionIsNext) {
      var chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround, highlightSuccessful = chart.highlightAdjacentPoint(directionIsNext);
      if (!highlightSuccessful) {
        if (wrapAround) {
          return handler.init(directionIsNext ? 1 : -1);
        }
        return handler.response[directionIsNext ? "next" : "prev"];
      }
      return handler.response.success;
    },
    /**
     * @private
     */
    onSeriesDestroy: function(series) {
      var chart = this.chart, currentHighlightedPointDestroyed = chart.highlightedPoint && chart.highlightedPoint.series === series;
      if (currentHighlightedPointDestroyed) {
        delete chart.highlightedPoint;
        if (chart.focusElement) {
          chart.focusElement.removeFocusBorder();
        }
      }
    },
    /**
     * @private
     */
    destroy: function() {
      this.eventProvider.removeAddedEvents();
    }
  }
);
var SeriesKeyboardNavigation_default = SeriesKeyboardNavigation;

// node_modules/highcharts/es-modules/Accessibility/Components/AnnotationsA11y.js
var escapeStringForHTML2 = HTMLUtilities_default.escapeStringForHTML;
var stripHTMLTagsFromString2 = HTMLUtilities_default.stripHTMLTagsFromString;
function getChartAnnotationLabels(chart) {
  var annotations = chart.annotations || [];
  return annotations.reduce(function(acc, cur) {
    if (cur.options && cur.options.visible !== false) {
      acc = acc.concat(cur.labels);
    }
    return acc;
  }, []);
}
function getLabelText(label) {
  return label.options && label.options.accessibility && label.options.accessibility.description || label.graphic && label.graphic.text && label.graphic.text.textStr || "";
}
function getAnnotationLabelDescription(label) {
  var a11yDesc = label.options && label.options.accessibility && label.options.accessibility.description;
  if (a11yDesc) {
    return a11yDesc;
  }
  var chart = label.chart;
  var labelText = getLabelText(label);
  var points = label.points;
  var getAriaLabel = function(point) {
    return point.graphic && point.graphic.element && point.graphic.element.getAttribute("aria-label") || "";
  };
  var getValueDesc = function(point) {
    var valDesc = point.accessibility && point.accessibility.valueDescription || getAriaLabel(point);
    var seriesName = point && point.series.name || "";
    return (seriesName ? seriesName + ", " : "") + "data point " + valDesc;
  };
  var pointValueDescriptions = points.filter(function(p) {
    return !!p.graphic;
  }).map(getValueDesc).filter(function(desc) {
    return !!desc;
  });
  var numPoints = pointValueDescriptions.length;
  var pointsSelector = numPoints > 1 ? "MultiplePoints" : numPoints ? "SinglePoint" : "NoPoints";
  var langFormatStr = "accessibility.screenReaderSection.annotations.description" + pointsSelector;
  var context = {
    annotationText: labelText,
    annotation: label,
    numPoints,
    annotationPoint: pointValueDescriptions[0],
    additionalAnnotationPoints: pointValueDescriptions.slice(1)
  };
  return chart.langFormat(langFormatStr, context);
}
function getAnnotationListItems(chart) {
  var labels = getChartAnnotationLabels(chart);
  return labels.map(function(label) {
    var desc = escapeStringForHTML2(stripHTMLTagsFromString2(getAnnotationLabelDescription(label)));
    return desc ? "<li>" + desc + "</li>" : "";
  });
}
function getAnnotationsInfoHTML(chart) {
  var annotations = chart.annotations;
  if (!(annotations && annotations.length)) {
    return "";
  }
  var annotationItems = getAnnotationListItems(chart);
  return '<ul style="list-style-type: none">' + annotationItems.join(" ") + "</ul>";
}
function getPointAnnotationTexts(point) {
  var labels = getChartAnnotationLabels(point.series.chart);
  var pointLabels = labels.filter(function(label) {
    return label.points.indexOf(point) > -1;
  });
  if (!pointLabels.length) {
    return [];
  }
  return pointLabels.map(function(label) {
    return "" + getLabelText(label);
  });
}
var AnnotationsA11y = {
  getAnnotationsInfoHTML,
  getAnnotationLabelDescription,
  getAnnotationListItems,
  getPointAnnotationTexts
};
var AnnotationsA11y_default = AnnotationsA11y;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/SeriesDescriber.js
var getPointAnnotationTexts2 = AnnotationsA11y_default.getPointAnnotationTexts;
var getAxisDescription2 = ChartUtilities_default.getAxisDescription;
var getSeriesFirstPointElement2 = ChartUtilities_default.getSeriesFirstPointElement;
var getSeriesA11yElement2 = ChartUtilities_default.getSeriesA11yElement;
var unhideChartElementFromAT4 = ChartUtilities_default.unhideChartElementFromAT;
var format9 = FormatUtilities_default.format;
var numberFormat3 = FormatUtilities_default.numberFormat;
var reverseChildNodes2 = HTMLUtilities_default.reverseChildNodes;
var stripHTMLTags3 = HTMLUtilities_default.stripHTMLTagsFromString;
var find14 = Utilities_default.find;
var isNumber33 = Utilities_default.isNumber;
var pick47 = Utilities_default.pick;
var defined36 = Utilities_default.defined;
function findFirstPointWithGraphic(point) {
  var sourcePointIndex = point.index;
  if (!point.series || !point.series.data || !defined36(sourcePointIndex)) {
    return null;
  }
  return find14(point.series.data, function(p) {
    return !!(p && typeof p.index !== "undefined" && p.index > sourcePointIndex && p.graphic && p.graphic.element);
  }) || null;
}
function shouldAddDummyPoint(point) {
  var isSunburst = point.series && point.series.is("sunburst"), isNull = point.isNull;
  return isNull && !isSunburst;
}
function makeDummyElement(point, pos) {
  var renderer = point.series.chart.renderer, dummy = renderer.rect(pos.x, pos.y, 1, 1);
  dummy.attr({
    "class": "highcharts-a11y-dummy-point",
    fill: "none",
    opacity: 0,
    "fill-opacity": 0,
    "stroke-opacity": 0
  });
  return dummy;
}
function addDummyPointElement(point) {
  var series = point.series, firstPointWithGraphic = findFirstPointWithGraphic(point), firstGraphic = firstPointWithGraphic && firstPointWithGraphic.graphic, parentGroup = firstGraphic ? firstGraphic.parentGroup : series.graph || series.group, dummyPos = firstPointWithGraphic ? {
    x: pick47(point.plotX, firstPointWithGraphic.plotX, 0),
    y: pick47(point.plotY, firstPointWithGraphic.plotY, 0)
  } : {
    x: pick47(point.plotX, 0),
    y: pick47(point.plotY, 0)
  }, dummyElement = makeDummyElement(point, dummyPos);
  if (parentGroup && parentGroup.element) {
    point.graphic = dummyElement;
    point.hasDummyGraphic = true;
    dummyElement.add(parentGroup);
    parentGroup.element.insertBefore(dummyElement.element, firstGraphic ? firstGraphic.element : null);
    return dummyElement.element;
  }
}
function hasMorePointsThanDescriptionThreshold(series) {
  var chartA11yOptions = series.chart.options.accessibility, threshold = chartA11yOptions.series.pointDescriptionEnabledThreshold;
  return !!(threshold !== false && series.points && series.points.length >= threshold);
}
function shouldSetScreenReaderPropsOnPoints(series) {
  var seriesA11yOptions = series.options.accessibility || {};
  return !hasMorePointsThanDescriptionThreshold(series) && !seriesA11yOptions.exposeAsGroupOnly;
}
function shouldSetKeyboardNavPropsOnPoints(series) {
  var chartA11yOptions = series.chart.options.accessibility, seriesNavOptions = chartA11yOptions.keyboardNavigation.seriesNavigation;
  return !!(series.points && (series.points.length < seriesNavOptions.pointNavigationEnabledThreshold || seriesNavOptions.pointNavigationEnabledThreshold === false));
}
function shouldDescribeSeriesElement(series) {
  var chart = series.chart, chartOptions = chart.options.chart, chartHas3d = chartOptions.options3d && chartOptions.options3d.enabled, hasMultipleSeries = chart.series.length > 1, describeSingleSeriesOption = chart.options.accessibility.series.describeSingleSeries, exposeAsGroupOnlyOption = (series.options.accessibility || {}).exposeAsGroupOnly, noDescribe3D = chartHas3d && hasMultipleSeries;
  return !noDescribe3D && (hasMultipleSeries || describeSingleSeriesOption || exposeAsGroupOnlyOption || hasMorePointsThanDescriptionThreshold(series));
}
function pointNumberToString(point, value) {
  var chart = point.series.chart, a11yPointOptions = chart.options.accessibility.point || {}, tooltipOptions = point.series.tooltipOptions || {}, lang2 = chart.options.lang;
  if (isNumber33(value)) {
    return numberFormat3(value, a11yPointOptions.valueDecimals || tooltipOptions.valueDecimals || -1, lang2.decimalPoint, lang2.accessibility.thousandsSep || lang2.thousandsSep);
  }
  return value;
}
function getSeriesDescriptionText(series) {
  var seriesA11yOptions = series.options.accessibility || {}, descOpt = seriesA11yOptions.description;
  return descOpt && series.chart.langFormat("accessibility.series.description", {
    description: descOpt,
    series
  }) || "";
}
function getSeriesAxisDescriptionText(series, axisCollection) {
  var axis = series[axisCollection];
  return series.chart.langFormat("accessibility.series." + axisCollection + "Description", {
    name: getAxisDescription2(axis),
    series
  });
}
function getPointA11yTimeDescription(point) {
  var series = point.series, chart = series.chart, a11yOptions = chart.options.accessibility.point || {}, dateXAxis = series.xAxis && series.xAxis.dateTime;
  if (dateXAxis) {
    var tooltipDateFormat = dateXAxis.getXDateFormat(point.x || 0, chart.options.tooltip.dateTimeLabelFormats), dateFormat2 = a11yOptions.dateFormatter && a11yOptions.dateFormatter(point) || a11yOptions.dateFormat || tooltipDateFormat;
    return chart.time.dateFormat(dateFormat2, point.x || 0, void 0);
  }
}
function getPointXDescription(point) {
  var timeDesc = getPointA11yTimeDescription(point), xAxis = point.series.xAxis || {}, pointCategory = xAxis.categories && defined36(point.category) && ("" + point.category).replace("<br/>", " "), canUseId = point.id && point.id.indexOf("highcharts-") < 0, fallback = "x, " + point.x;
  return point.name || timeDesc || pointCategory || (canUseId ? point.id : fallback);
}
function getPointArrayMapValueDescription(point, prefix, suffix) {
  var pre = prefix || "", suf = suffix || "", keyToValStr = function(key) {
    var num = pointNumberToString(point, pick47(point[key], point.options[key]));
    return key + ": " + pre + num + suf;
  }, pointArrayMap = point.series.pointArrayMap;
  return pointArrayMap.reduce(function(desc, key) {
    return desc + (desc.length ? ", " : "") + keyToValStr(key);
  }, "");
}
function getPointValue(point) {
  var series = point.series, a11yPointOpts = series.chart.options.accessibility.point || {}, tooltipOptions = series.tooltipOptions || {}, valuePrefix = a11yPointOpts.valuePrefix || tooltipOptions.valuePrefix || "", valueSuffix = a11yPointOpts.valueSuffix || tooltipOptions.valueSuffix || "", fallbackKey = typeof point.value !== "undefined" ? "value" : "y", fallbackDesc = pointNumberToString(point, point[fallbackKey]);
  if (point.isNull) {
    return series.chart.langFormat("accessibility.series.nullPointValue", {
      point
    });
  }
  if (series.pointArrayMap) {
    return getPointArrayMapValueDescription(point, valuePrefix, valueSuffix);
  }
  return valuePrefix + fallbackDesc + valueSuffix;
}
function getPointAnnotationDescription(point) {
  var chart = point.series.chart;
  var langKey = "accessibility.series.pointAnnotationsDescription";
  var annotations = getPointAnnotationTexts2(point);
  var context = { point, annotations };
  return annotations.length ? chart.langFormat(langKey, context) : "";
}
function getPointValueDescription(point) {
  var series = point.series, chart = series.chart, pointValueDescriptionFormat = chart.options.accessibility.point.valueDescriptionFormat, showXDescription = pick47(series.xAxis && series.xAxis.options.accessibility && series.xAxis.options.accessibility.enabled, !chart.angular), xDesc = showXDescription ? getPointXDescription(point) : "", context = {
    point,
    index: defined36(point.index) ? point.index + 1 : "",
    xDescription: xDesc,
    value: getPointValue(point),
    separator: showXDescription ? ", " : ""
  };
  return format9(pointValueDescriptionFormat, context, chart);
}
function defaultPointDescriptionFormatter(point) {
  var series = point.series, chart = series.chart, valText = getPointValueDescription(point), description = point.options && point.options.accessibility && point.options.accessibility.description, userDescText = description ? " " + description : "", seriesNameText = chart.series.length > 1 && series.name ? " " + series.name + "." : "", annotationsDesc = getPointAnnotationDescription(point), pointAnnotationsText = annotationsDesc ? " " + annotationsDesc : "";
  point.accessibility = point.accessibility || {};
  point.accessibility.valueDescription = valText;
  return valText + userDescText + seriesNameText + pointAnnotationsText;
}
function setPointScreenReaderAttribs(point, pointElement) {
  var series = point.series, a11yPointOptions = series.chart.options.accessibility.point || {}, seriesA11yOptions = series.options.accessibility || {}, label = stripHTMLTags3(seriesA11yOptions.pointDescriptionFormatter && seriesA11yOptions.pointDescriptionFormatter(point) || a11yPointOptions.descriptionFormatter && a11yPointOptions.descriptionFormatter(point) || defaultPointDescriptionFormatter(point));
  pointElement.setAttribute("role", "img");
  pointElement.setAttribute("aria-label", label);
}
function describePointsInSeries(series) {
  var setScreenReaderProps = shouldSetScreenReaderPropsOnPoints(series), setKeyboardProps = shouldSetKeyboardNavPropsOnPoints(series);
  if (setScreenReaderProps || setKeyboardProps) {
    series.points.forEach(function(point) {
      var pointEl = point.graphic && point.graphic.element || shouldAddDummyPoint(point) && addDummyPointElement(point);
      var pointA11yDisabled = point.options && point.options.accessibility && point.options.accessibility.enabled === false;
      if (pointEl) {
        pointEl.setAttribute("tabindex", "-1");
        pointEl.style.outline = "0";
        if (setScreenReaderProps && !pointA11yDisabled) {
          setPointScreenReaderAttribs(point, pointEl);
        } else {
          pointEl.setAttribute("aria-hidden", true);
        }
      }
    });
  }
}
function defaultSeriesDescriptionFormatter(series) {
  var chart = series.chart, chartTypes = chart.types || [], description = getSeriesDescriptionText(series), shouldDescribeAxis = function(coll) {
    return chart[coll] && chart[coll].length > 1 && series[coll];
  }, xAxisInfo = getSeriesAxisDescriptionText(series, "xAxis"), yAxisInfo = getSeriesAxisDescriptionText(series, "yAxis"), summaryContext = {
    name: series.name || "",
    ix: series.index + 1,
    numSeries: chart.series && chart.series.length,
    numPoints: series.points && series.points.length,
    series
  }, combinationSuffix = chartTypes.length > 1 ? "Combination" : "", summary = chart.langFormat("accessibility.series.summary." + series.type + combinationSuffix, summaryContext) || chart.langFormat("accessibility.series.summary.default" + combinationSuffix, summaryContext);
  return summary + (description ? " " + description : "") + (shouldDescribeAxis("yAxis") ? " " + yAxisInfo : "") + (shouldDescribeAxis("xAxis") ? " " + xAxisInfo : "");
}
function describeSeriesElement(series, seriesElement) {
  var seriesA11yOptions = series.options.accessibility || {}, a11yOptions = series.chart.options.accessibility, landmarkVerbosity = a11yOptions.landmarkVerbosity;
  if (seriesA11yOptions.exposeAsGroupOnly) {
    seriesElement.setAttribute("role", "img");
  } else if (landmarkVerbosity === "all") {
    seriesElement.setAttribute("role", "region");
  }
  seriesElement.setAttribute("tabindex", "-1");
  seriesElement.style.outline = "0";
  seriesElement.setAttribute("aria-label", stripHTMLTags3(a11yOptions.series.descriptionFormatter && a11yOptions.series.descriptionFormatter(series) || defaultSeriesDescriptionFormatter(series)));
}
function describeSeries(series) {
  var chart = series.chart, firstPointEl = getSeriesFirstPointElement2(series), seriesEl = getSeriesA11yElement2(series), is3d = chart.is3d && chart.is3d();
  if (seriesEl) {
    if (seriesEl.lastChild === firstPointEl && !is3d) {
      reverseChildNodes2(seriesEl);
    }
    describePointsInSeries(series);
    unhideChartElementFromAT4(chart, seriesEl);
    if (shouldDescribeSeriesElement(series)) {
      describeSeriesElement(series, seriesEl);
    } else {
      seriesEl.setAttribute("aria-label", "");
    }
  }
}
var SeriesDescriber = {
  describeSeries,
  defaultPointDescriptionFormatter,
  defaultSeriesDescriptionFormatter,
  getPointA11yTimeDescription,
  getPointXDescription,
  getPointValue,
  getPointValueDescription
};
var SeriesDescriber_default = SeriesDescriber;

// node_modules/highcharts/es-modules/Accessibility/Utils/Announcer.js
var doc14 = Globals_default.doc;
var setElAttrs2 = HTMLUtilities_default.setElAttrs;
var visuallyHideElement2 = HTMLUtilities_default.visuallyHideElement;
var Announcer = (
  /** @class */
  function() {
    function Announcer2(chart, type) {
      this.chart = chart;
      this.domElementProvider = new DOMElementProvider_default();
      this.announceRegion = this.addAnnounceRegion(type);
    }
    Announcer2.prototype.destroy = function() {
      this.domElementProvider.destroyCreatedElements();
    };
    Announcer2.prototype.announce = function(message) {
      var _this = this;
      AST_default.setElementHTML(this.announceRegion, message);
      if (this.clearAnnouncementRegionTimer) {
        clearTimeout(this.clearAnnouncementRegionTimer);
      }
      this.clearAnnouncementRegionTimer = setTimeout(function() {
        _this.announceRegion.innerHTML = "";
        delete _this.clearAnnouncementRegionTimer;
      }, 1e3);
    };
    Announcer2.prototype.addAnnounceRegion = function(type) {
      var chartContainer = this.chart.announcerContainer || this.createAnnouncerContainer(), div = this.domElementProvider.createElement("div");
      setElAttrs2(div, {
        "aria-hidden": false,
        "aria-live": type
      });
      visuallyHideElement2(div);
      chartContainer.appendChild(div);
      return div;
    };
    Announcer2.prototype.createAnnouncerContainer = function() {
      var chart = this.chart, container = doc14.createElement("div");
      setElAttrs2(container, {
        "aria-hidden": false,
        style: "position:relative",
        "class": "highcharts-announcer-container"
      });
      chart.renderTo.insertBefore(container, chart.renderTo.firstChild);
      chart.announcerContainer = container;
      return container;
    };
    return Announcer2;
  }()
);
var Announcer_default = Announcer;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/NewDataAnnouncer.js
var extend37 = Utilities_default.extend;
var defined37 = Utilities_default.defined;
var getChartTitle4 = ChartUtilities_default.getChartTitle;
var defaultPointDescriptionFormatter2 = SeriesDescriber_default.defaultPointDescriptionFormatter;
var defaultSeriesDescriptionFormatter2 = SeriesDescriber_default.defaultSeriesDescriptionFormatter;
function chartHasAnnounceEnabled(chart) {
  return !!chart.options.accessibility.announceNewData.enabled;
}
function findPointInDataArray(point) {
  var candidates = point.series.data.filter(function(candidate) {
    return point.x === candidate.x && point.y === candidate.y;
  });
  return candidates.length === 1 ? candidates[0] : point;
}
function getUniqueSeries(arrayA, arrayB) {
  var uniqueSeries = (arrayA || []).concat(arrayB || []).reduce(function(acc, cur) {
    acc[cur.name + cur.index] = cur;
    return acc;
  }, {});
  return Object.keys(uniqueSeries).map(function(ix) {
    return uniqueSeries[ix];
  });
}
var NewDataAnnouncer = function(chart) {
  this.chart = chart;
};
extend37(NewDataAnnouncer.prototype, {
  /**
   * Initialize the new data announcer.
   * @private
   */
  init: function() {
    var chart = this.chart;
    var announceOptions = chart.options.accessibility.announceNewData;
    var announceType = announceOptions.interruptUser ? "assertive" : "polite";
    this.lastAnnouncementTime = 0;
    this.dirty = {
      allSeries: {}
    };
    this.eventProvider = new EventProvider_default();
    this.announcer = new Announcer_default(chart, announceType);
    this.addEventListeners();
  },
  /**
   * Remove traces of announcer.
   * @private
   */
  destroy: function() {
    this.eventProvider.removeAddedEvents();
    this.announcer.destroy();
  },
  /**
   * Add event listeners for the announcer
   * @private
   */
  addEventListeners: function() {
    var announcer = this, chart = this.chart, e2 = this.eventProvider;
    e2.addEvent(chart, "afterDrilldown", function() {
      announcer.lastAnnouncementTime = 0;
    });
    e2.addEvent(Series_default, "updatedData", function() {
      announcer.onSeriesUpdatedData(this);
    });
    e2.addEvent(chart, "afterAddSeries", function(e3) {
      announcer.onSeriesAdded(e3.series);
    });
    e2.addEvent(Series_default, "addPoint", function(e3) {
      announcer.onPointAdded(e3.point);
    });
    e2.addEvent(chart, "redraw", function() {
      announcer.announceDirtyData();
    });
  },
  /**
   * On new data in the series, make sure we add it to the dirty list.
   * @private
   * @param {Highcharts.Series} series
   */
  onSeriesUpdatedData: function(series) {
    var chart = this.chart;
    if (series.chart === chart && chartHasAnnounceEnabled(chart)) {
      this.dirty.hasDirty = true;
      this.dirty.allSeries[series.name + series.index] = series;
    }
  },
  /**
   * On new data series added, update dirty list.
   * @private
   * @param {Highcharts.Series} series
   */
  onSeriesAdded: function(series) {
    if (chartHasAnnounceEnabled(this.chart)) {
      this.dirty.hasDirty = true;
      this.dirty.allSeries[series.name + series.index] = series;
      this.dirty.newSeries = defined37(this.dirty.newSeries) ? void 0 : series;
    }
  },
  /**
   * On new point added, update dirty list.
   * @private
   * @param {Highcharts.Point} point
   */
  onPointAdded: function(point) {
    var chart = point.series.chart;
    if (this.chart === chart && chartHasAnnounceEnabled(chart)) {
      this.dirty.newPoint = defined37(this.dirty.newPoint) ? void 0 : point;
    }
  },
  /**
   * Gather what we know and announce the data to user.
   * @private
   */
  announceDirtyData: function() {
    var chart = this.chart, announcer = this;
    if (chart.options.accessibility.announceNewData && this.dirty.hasDirty) {
      var newPoint = this.dirty.newPoint;
      if (newPoint) {
        newPoint = findPointInDataArray(newPoint);
      }
      this.queueAnnouncement(Object.keys(this.dirty.allSeries).map(function(ix) {
        return announcer.dirty.allSeries[ix];
      }), this.dirty.newSeries, newPoint);
      this.dirty = {
        allSeries: {}
      };
    }
  },
  /**
   * Announce to user that there is new data.
   * @private
   * @param {Array<Highcharts.Series>} dirtySeries
   *          Array of series with new data.
   * @param {Highcharts.Series} [newSeries]
   *          If a single new series was added, a reference to this series.
   * @param {Highcharts.Point} [newPoint]
   *          If a single point was added, a reference to this point.
   */
  queueAnnouncement: function(dirtySeries, newSeries, newPoint) {
    var _this = this;
    var chart = this.chart;
    var annOptions = chart.options.accessibility.announceNewData;
    if (annOptions.enabled) {
      var now = +/* @__PURE__ */ new Date();
      var dTime = now - this.lastAnnouncementTime;
      var time = Math.max(0, annOptions.minAnnounceInterval - dTime);
      var allSeries = getUniqueSeries(this.queuedAnnouncement && this.queuedAnnouncement.series, dirtySeries);
      var message = this.buildAnnouncementMessage(allSeries, newSeries, newPoint);
      if (message) {
        if (this.queuedAnnouncement) {
          clearTimeout(this.queuedAnnouncementTimer);
        }
        this.queuedAnnouncement = {
          time: now,
          message,
          series: allSeries
        };
        this.queuedAnnouncementTimer = setTimeout(function() {
          if (_this && _this.announcer) {
            _this.lastAnnouncementTime = +/* @__PURE__ */ new Date();
            _this.announcer.announce(_this.queuedAnnouncement.message);
            delete _this.queuedAnnouncement;
            delete _this.queuedAnnouncementTimer;
          }
        }, time);
      }
    }
  },
  /**
   * Get announcement message for new data.
   * @private
   * @param {Array<Highcharts.Series>} dirtySeries
   *          Array of series with new data.
   * @param {Highcharts.Series} [newSeries]
   *          If a single new series was added, a reference to this series.
   * @param {Highcharts.Point} [newPoint]
   *          If a single point was added, a reference to this point.
   *
   * @return {string|null}
   * The announcement message to give to user.
   */
  buildAnnouncementMessage: function(dirtySeries, newSeries, newPoint) {
    var chart = this.chart, annOptions = chart.options.accessibility.announceNewData;
    if (annOptions.announcementFormatter) {
      var formatterRes = annOptions.announcementFormatter(dirtySeries, newSeries, newPoint);
      if (formatterRes !== false) {
        return formatterRes.length ? formatterRes : null;
      }
    }
    var multiple = Globals_default.charts && Globals_default.charts.length > 1 ? "Multiple" : "Single", langKey = newSeries ? "newSeriesAnnounce" + multiple : newPoint ? "newPointAnnounce" + multiple : "newDataAnnounce", chartTitle = getChartTitle4(chart);
    return chart.langFormat("accessibility.announceNewData." + langKey, {
      chartTitle,
      seriesDesc: newSeries ? defaultSeriesDescriptionFormatter2(newSeries) : null,
      pointDesc: newPoint ? defaultPointDescriptionFormatter2(newPoint) : null,
      point: newPoint,
      series: newSeries
    });
  }
});
var NewDataAnnouncer_default = NewDataAnnouncer;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/ForcedMarkers.js
var addEvent32 = Utilities_default.addEvent;
var merge42 = Utilities_default.merge;
function isWithinDescriptionThreshold(series) {
  var a11yOptions = series.chart.options.accessibility;
  return series.points.length < a11yOptions.series.pointDescriptionEnabledThreshold || a11yOptions.series.pointDescriptionEnabledThreshold === false;
}
function shouldForceMarkers(series) {
  var chart = series.chart, chartA11yEnabled = chart.options.accessibility.enabled, seriesA11yEnabled = (series.options.accessibility && series.options.accessibility.enabled) !== false;
  return chartA11yEnabled && seriesA11yEnabled && isWithinDescriptionThreshold(series);
}
function hasIndividualPointMarkerOptions(series) {
  return !!(series._hasPointMarkers && series.points && series.points.length);
}
function unforceSeriesMarkerOptions(series) {
  var resetMarkerOptions = series.resetA11yMarkerOptions;
  if (resetMarkerOptions) {
    merge42(true, series.options, {
      marker: {
        enabled: resetMarkerOptions.enabled,
        states: {
          normal: {
            opacity: resetMarkerOptions.states && resetMarkerOptions.states.normal && resetMarkerOptions.states.normal.opacity
          }
        }
      }
    });
  }
}
function forceZeroOpacityMarkerOptions(options) {
  merge42(true, options, {
    marker: {
      enabled: true,
      states: {
        normal: {
          opacity: 0
        }
      }
    }
  });
}
function getPointMarkerOpacity(pointOptions) {
  return pointOptions.marker.states && pointOptions.marker.states.normal && pointOptions.marker.states.normal.opacity || 1;
}
function unforcePointMarkerOptions(pointOptions) {
  merge42(true, pointOptions.marker, {
    states: {
      normal: {
        opacity: getPointMarkerOpacity(pointOptions)
      }
    }
  });
}
function handleForcePointMarkers(series) {
  var i = series.points.length;
  while (i--) {
    var point = series.points[i];
    var pointOptions = point.options;
    delete point.hasForcedA11yMarker;
    if (pointOptions.marker) {
      if (pointOptions.marker.enabled) {
        unforcePointMarkerOptions(pointOptions);
        point.hasForcedA11yMarker = false;
      } else {
        forceZeroOpacityMarkerOptions(pointOptions);
        point.hasForcedA11yMarker = true;
      }
    }
  }
}
function addForceMarkersEvents() {
  addEvent32(Series_default, "render", function() {
    var series = this, options = series.options;
    if (shouldForceMarkers(series)) {
      if (options.marker && options.marker.enabled === false) {
        series.a11yMarkersForced = true;
        forceZeroOpacityMarkerOptions(series.options);
      }
      if (hasIndividualPointMarkerOptions(series)) {
        handleForcePointMarkers(series);
      }
    } else if (series.a11yMarkersForced) {
      delete series.a11yMarkersForced;
      unforceSeriesMarkerOptions(series);
    }
  });
  addEvent32(Series_default, "afterSetOptions", function(e2) {
    this.resetA11yMarkerOptions = merge42(e2.options.marker || {}, this.userOptions.marker || {});
  });
  addEvent32(Series_default, "afterRender", function() {
    var series = this;
    if (series.chart.styledMode) {
      if (series.markerGroup) {
        series.markerGroup[series.a11yMarkersForced ? "addClass" : "removeClass"]("highcharts-a11y-markers-hidden");
      }
      if (hasIndividualPointMarkerOptions(series)) {
        series.points.forEach(function(point) {
          if (point.graphic) {
            point.graphic[point.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-hidden");
            point.graphic[point.hasForcedA11yMarker === false ? "addClass" : "removeClass"]("highcharts-a11y-marker-visible");
          }
        });
      }
    }
  });
}
var ForcedMarkers_default = addForceMarkersEvents;

// node_modules/highcharts/es-modules/Accessibility/Components/SeriesComponent/SeriesComponent.js
var extend38 = Utilities_default.extend;
var hideSeriesFromAT2 = ChartUtilities_default.hideSeriesFromAT;
var describeSeries2 = SeriesDescriber_default.describeSeries;
Globals_default.SeriesAccessibilityDescriber = SeriesDescriber_default;
ForcedMarkers_default();
var SeriesComponent = function() {
};
SeriesComponent.prototype = new AccessibilityComponent_default();
extend38(
  SeriesComponent.prototype,
  /** @lends Highcharts.SeriesComponent */
  {
    /**
     * Init the component.
     */
    init: function() {
      this.newDataAnnouncer = new NewDataAnnouncer_default(this.chart);
      this.newDataAnnouncer.init();
      this.keyboardNavigation = new SeriesKeyboardNavigation_default(this.chart, this.keyCodes);
      this.keyboardNavigation.init();
      this.hideTooltipFromATWhenShown();
      this.hideSeriesLabelsFromATWhenShown();
    },
    /**
     * @private
     */
    hideTooltipFromATWhenShown: function() {
      var component = this;
      this.addEvent(Tooltip_default, "refresh", function() {
        if (this.chart === component.chart && this.label && this.label.element) {
          this.label.element.setAttribute("aria-hidden", true);
        }
      });
    },
    /**
     * @private
     */
    hideSeriesLabelsFromATWhenShown: function() {
      this.addEvent(this.chart, "afterDrawSeriesLabels", function() {
        this.series.forEach(function(series) {
          if (series.labelBySeries) {
            series.labelBySeries.attr("aria-hidden", true);
          }
        });
      });
    },
    /**
     * Called on chart render. It is necessary to do this for render in case
     * markers change on zoom/pixel density.
     */
    onChartRender: function() {
      var chart = this.chart;
      chart.series.forEach(function(series) {
        var shouldDescribeSeries = (series.options.accessibility && series.options.accessibility.enabled) !== false && series.visible;
        if (shouldDescribeSeries) {
          describeSeries2(series);
        } else {
          hideSeriesFromAT2(series);
        }
      });
    },
    /**
     * Get keyboard navigation handler for this component.
     * @return {Highcharts.KeyboardNavigationHandler}
     */
    getKeyboardNavigation: function() {
      return this.keyboardNavigation.getKeyboardNavigationHandler();
    },
    /**
     * Remove traces
     */
    destroy: function() {
      this.newDataAnnouncer.destroy();
      this.keyboardNavigation.destroy();
    }
  }
);
var SeriesComponent_default = SeriesComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/ZoomComponent.js
var unhideChartElementFromAT5 = ChartUtilities_default.unhideChartElementFromAT;
var noop9 = Globals_default.noop;
var removeElement6 = HTMLUtilities_default.removeElement;
var setElAttrs3 = HTMLUtilities_default.setElAttrs;
var extend39 = Utilities_default.extend;
var pick48 = Utilities_default.pick;
function chartHasMapZoom(chart) {
  return !!(chart.mapZoom && chart.mapNavButtons && chart.mapNavButtons.length);
}
Globals_default.Axis.prototype.panStep = function(direction, granularity) {
  var gran = granularity || 3, extremes = this.getExtremes(), step = (extremes.max - extremes.min) / gran * direction, newMax = extremes.max + step, newMin = extremes.min + step, size = newMax - newMin;
  if (direction < 0 && newMin < extremes.dataMin) {
    newMin = extremes.dataMin;
    newMax = newMin + size;
  } else if (direction > 0 && newMax > extremes.dataMax) {
    newMax = extremes.dataMax;
    newMin = newMax - size;
  }
  this.setExtremes(newMin, newMax);
};
var ZoomComponent = noop9;
ZoomComponent.prototype = new AccessibilityComponent_default();
extend39(
  ZoomComponent.prototype,
  /** @lends Highcharts.ZoomComponent */
  {
    /**
     * Initialize the component
     */
    init: function() {
      var component = this, chart = this.chart;
      [
        "afterShowResetZoom",
        "afterDrilldown",
        "drillupall"
      ].forEach(function(eventType) {
        component.addEvent(chart, eventType, function() {
          component.updateProxyOverlays();
        });
      });
    },
    /**
     * Called when chart is updated
     */
    onChartUpdate: function() {
      var chart = this.chart, component = this;
      if (chart.mapNavButtons) {
        chart.mapNavButtons.forEach(function(button, i) {
          unhideChartElementFromAT5(chart, button.element);
          component.setMapNavButtonAttrs(button.element, "accessibility.zoom.mapZoom" + (i ? "Out" : "In"));
        });
      }
    },
    /**
     * @private
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} button
     * @param {string} labelFormatKey
     */
    setMapNavButtonAttrs: function(button, labelFormatKey) {
      var chart = this.chart, label = chart.langFormat(labelFormatKey, { chart });
      setElAttrs3(button, {
        tabindex: -1,
        role: "button",
        "aria-label": label
      });
    },
    /**
     * Update the proxy overlays on every new render to ensure positions are
     * correct.
     */
    onChartRender: function() {
      this.updateProxyOverlays();
    },
    /**
     * Update proxy overlays, recreating the buttons.
     */
    updateProxyOverlays: function() {
      var chart = this.chart;
      removeElement6(this.drillUpProxyGroup);
      removeElement6(this.resetZoomProxyGroup);
      if (chart.resetZoomButton) {
        this.recreateProxyButtonAndGroup(chart.resetZoomButton, "resetZoomProxyButton", "resetZoomProxyGroup", chart.langFormat("accessibility.zoom.resetZoomButton", { chart }));
      }
      if (chart.drillUpButton) {
        this.recreateProxyButtonAndGroup(chart.drillUpButton, "drillUpProxyButton", "drillUpProxyGroup", chart.langFormat("accessibility.drillUpButton", {
          chart,
          buttonText: chart.getDrilldownBackText()
        }));
      }
    },
    /**
     * @private
     * @param {Highcharts.SVGElement} buttonEl
     * @param {string} buttonProp
     * @param {string} groupProp
     * @param {string} label
     */
    recreateProxyButtonAndGroup: function(buttonEl, buttonProp, groupProp, label) {
      removeElement6(this[groupProp]);
      this[groupProp] = this.addProxyGroup();
      this[buttonProp] = this.createProxyButton(buttonEl, this[groupProp], { "aria-label": label, tabindex: -1 });
    },
    /**
     * Get keyboard navigation handler for map zoom.
     * @private
     * @return {Highcharts.KeyboardNavigationHandler} The module object
     */
    getMapZoomNavigation: function() {
      var keys2 = this.keyCodes, chart = this.chart, component = this;
      return new KeyboardNavigationHandler_default(chart, {
        keyCodeMap: [
          [
            [keys2.up, keys2.down, keys2.left, keys2.right],
            function(keyCode) {
              return component.onMapKbdArrow(this, keyCode);
            }
          ],
          [
            [keys2.tab],
            function(_keyCode, e2) {
              return component.onMapKbdTab(this, e2);
            }
          ],
          [
            [keys2.space, keys2.enter],
            function() {
              return component.onMapKbdClick(this);
            }
          ]
        ],
        validate: function() {
          return chartHasMapZoom(chart);
        },
        init: function(direction) {
          return component.onMapNavInit(direction);
        }
      });
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
     * @param {number} keyCode
     * @return {number} Response code
     */
    onMapKbdArrow: function(keyboardNavigationHandler, keyCode) {
      var keys2 = this.keyCodes, panAxis = keyCode === keys2.up || keyCode === keys2.down ? "yAxis" : "xAxis", stepDirection = keyCode === keys2.left || keyCode === keys2.up ? -1 : 1;
      this.chart[panAxis][0].panStep(stepDirection);
      return keyboardNavigationHandler.response.success;
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
     * @param {global.KeyboardEvent} event
     * @return {number} Response code
     */
    onMapKbdTab: function(keyboardNavigationHandler, event) {
      var button, chart = this.chart, response = keyboardNavigationHandler.response, isBackwards = event.shiftKey, isMoveOutOfRange = isBackwards && !this.focusedMapNavButtonIx || !isBackwards && this.focusedMapNavButtonIx;
      chart.mapNavButtons[this.focusedMapNavButtonIx].setState(0);
      if (isMoveOutOfRange) {
        chart.mapZoom();
        return response[isBackwards ? "prev" : "next"];
      }
      this.focusedMapNavButtonIx += isBackwards ? -1 : 1;
      button = chart.mapNavButtons[this.focusedMapNavButtonIx];
      chart.setFocusToElement(button.box, button.element);
      button.setState(2);
      return response.success;
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
     * @return {number} Response code
     */
    onMapKbdClick: function(keyboardNavigationHandler) {
      this.fakeClickEvent(this.chart.mapNavButtons[this.focusedMapNavButtonIx].element);
      return keyboardNavigationHandler.response.success;
    },
    /**
     * @private
     * @param {number} direction
     */
    onMapNavInit: function(direction) {
      var chart = this.chart, zoomIn = chart.mapNavButtons[0], zoomOut = chart.mapNavButtons[1], initialButton = direction > 0 ? zoomIn : zoomOut;
      chart.setFocusToElement(initialButton.box, initialButton.element);
      initialButton.setState(2);
      this.focusedMapNavButtonIx = direction > 0 ? 0 : 1;
    },
    /**
     * Get keyboard navigation handler for a simple chart button. Provide the
     * button reference for the chart, and a function to call on click.
     *
     * @private
     * @param {string} buttonProp The property on chart referencing the button.
     * @return {Highcharts.KeyboardNavigationHandler} The module object
     */
    simpleButtonNavigation: function(buttonProp, proxyProp, onClick) {
      var keys2 = this.keyCodes, component = this, chart = this.chart;
      return new KeyboardNavigationHandler_default(chart, {
        keyCodeMap: [
          [
            [keys2.tab, keys2.up, keys2.down, keys2.left, keys2.right],
            function(keyCode, e2) {
              var isBackwards = keyCode === keys2.tab && e2.shiftKey || keyCode === keys2.left || keyCode === keys2.up;
              return this.response[isBackwards ? "prev" : "next"];
            }
          ],
          [
            [keys2.space, keys2.enter],
            function() {
              var res = onClick(this, chart);
              return pick48(res, this.response.success);
            }
          ]
        ],
        validate: function() {
          var hasButton = chart[buttonProp] && chart[buttonProp].box && component[proxyProp];
          return hasButton;
        },
        init: function() {
          chart.setFocusToElement(chart[buttonProp].box, component[proxyProp]);
        }
      });
    },
    /**
     * Get keyboard navigation handlers for this component.
     * @return {Array<Highcharts.KeyboardNavigationHandler>}
     *         List of module objects
     */
    getKeyboardNavigation: function() {
      return [
        this.simpleButtonNavigation("resetZoomButton", "resetZoomProxyButton", function(_handler, chart) {
          chart.zoomOut();
        }),
        this.simpleButtonNavigation("drillUpButton", "drillUpProxyButton", function(handler, chart) {
          chart.drillUp();
          return handler.response.prev;
        }),
        this.getMapZoomNavigation()
      ];
    }
  }
);
var ZoomComponent_default = ZoomComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/RangeSelectorComponent.js
var unhideChartElementFromAT6 = ChartUtilities_default.unhideChartElementFromAT;
var getAxisRangeDescription2 = ChartUtilities_default.getAxisRangeDescription;
var setElAttrs4 = HTMLUtilities_default.setElAttrs;
var addEvent33 = Utilities_default.addEvent;
var extend40 = Utilities_default.extend;
function shouldRunInputNavigation(chart) {
  return Boolean(chart.rangeSelector && chart.rangeSelector.inputGroup && chart.rangeSelector.inputGroup.element.getAttribute("visibility") !== "hidden" && chart.options.rangeSelector.inputEnabled !== false && chart.rangeSelector.minInput && chart.rangeSelector.maxInput);
}
Chart_default.prototype.highlightRangeSelectorButton = function(ix) {
  var buttons = this.rangeSelector && this.rangeSelector.buttons || [];
  var curHighlightedIx = this.highlightedRangeSelectorItemIx;
  var curSelectedIx = this.rangeSelector && this.rangeSelector.selected;
  if (typeof curHighlightedIx !== "undefined" && buttons[curHighlightedIx] && curHighlightedIx !== curSelectedIx) {
    buttons[curHighlightedIx].setState(this.oldRangeSelectorItemState || 0);
  }
  this.highlightedRangeSelectorItemIx = ix;
  if (buttons[ix]) {
    this.setFocusToElement(buttons[ix].box, buttons[ix].element);
    if (ix !== curSelectedIx) {
      this.oldRangeSelectorItemState = buttons[ix].state;
      buttons[ix].setState(1);
    }
    return true;
  }
  return false;
};
addEvent33(RangeSelector_default, "afterBtnClick", function() {
  if (this.chart.accessibility && this.chart.accessibility.components.rangeSelector) {
    return this.chart.accessibility.components.rangeSelector.onAfterBtnClick();
  }
});
var RangeSelectorComponent = function() {
};
RangeSelectorComponent.prototype = new AccessibilityComponent_default();
extend40(
  RangeSelectorComponent.prototype,
  /** @lends Highcharts.RangeSelectorComponent */
  {
    /**
     * Init the component
     * @private
     */
    init: function() {
      var chart = this.chart;
      this.announcer = new Announcer_default(chart, "polite");
    },
    /**
     * Called on first render/updates to the chart, including options changes.
     */
    onChartUpdate: function() {
      var chart = this.chart, component = this, rangeSelector = chart.rangeSelector;
      if (!rangeSelector) {
        return;
      }
      this.updateSelectorVisibility();
      this.setDropdownAttrs();
      if (rangeSelector.buttons && rangeSelector.buttons.length) {
        rangeSelector.buttons.forEach(function(button) {
          component.setRangeButtonAttrs(button);
        });
      }
      if (rangeSelector.maxInput && rangeSelector.minInput) {
        ["minInput", "maxInput"].forEach(function(key, i) {
          var input = rangeSelector[key];
          if (input) {
            unhideChartElementFromAT6(chart, input);
            component.setRangeInputAttrs(input, "accessibility.rangeSelector." + (i ? "max" : "min") + "InputLabel");
          }
        });
      }
    },
    /**
     * Hide buttons from AT when showing dropdown, and vice versa.
     * @private
     */
    updateSelectorVisibility: function() {
      var chart = this.chart;
      var rangeSelector = chart.rangeSelector;
      var dropdown = rangeSelector && rangeSelector.dropdown;
      var buttons = rangeSelector && rangeSelector.buttons || [];
      var hideFromAT = function(el) {
        return el.setAttribute("aria-hidden", true);
      };
      if (rangeSelector && rangeSelector.hasVisibleDropdown && dropdown) {
        unhideChartElementFromAT6(chart, dropdown);
        buttons.forEach(function(btn) {
          return hideFromAT(btn.element);
        });
      } else {
        if (dropdown) {
          hideFromAT(dropdown);
        }
        buttons.forEach(function(btn) {
          return unhideChartElementFromAT6(chart, btn.element);
        });
      }
    },
    /**
     * Set accessibility related attributes on dropdown element.
     * @private
     */
    setDropdownAttrs: function() {
      var chart = this.chart;
      var dropdown = chart.rangeSelector && chart.rangeSelector.dropdown;
      if (dropdown) {
        var label = chart.langFormat("accessibility.rangeSelector.dropdownLabel", { rangeTitle: chart.options.lang.rangeSelectorZoom });
        dropdown.setAttribute("aria-label", label);
        dropdown.setAttribute("tabindex", -1);
      }
    },
    /**
     * @private
     * @param {Highcharts.SVGElement} button
     */
    setRangeButtonAttrs: function(button) {
      setElAttrs4(button.element, {
        tabindex: -1,
        role: "button"
      });
    },
    /**
     * @private
     */
    setRangeInputAttrs: function(input, langKey) {
      var chart = this.chart;
      setElAttrs4(input, {
        tabindex: -1,
        "aria-label": chart.langFormat(langKey, { chart })
      });
    },
    /**
     * @private
     * @param {Highcharts.KeyboardNavigationHandler} keyboardNavigationHandler
     * @param {number} keyCode
     * @return {number} Response code
     */
    onButtonNavKbdArrowKey: function(keyboardNavigationHandler, keyCode) {
      var response = keyboardNavigationHandler.response, keys2 = this.keyCodes, chart = this.chart, wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround, direction = keyCode === keys2.left || keyCode === keys2.up ? -1 : 1, didHighlight = chart.highlightRangeSelectorButton(chart.highlightedRangeSelectorItemIx + direction);
      if (!didHighlight) {
        if (wrapAround) {
          keyboardNavigationHandler.init(direction);
          return response.success;
        }
        return response[direction > 0 ? "next" : "prev"];
      }
      return response.success;
    },
    /**
     * @private
     */
    onButtonNavKbdClick: function(keyboardNavigationHandler) {
      var response = keyboardNavigationHandler.response, chart = this.chart, wasDisabled = chart.oldRangeSelectorItemState === 3;
      if (!wasDisabled) {
        this.fakeClickEvent(chart.rangeSelector.buttons[chart.highlightedRangeSelectorItemIx].element);
      }
      return response.success;
    },
    /**
     * Called whenever a range selector button has been clicked, either by
     * mouse, touch, or kbd/voice/other.
     * @private
     */
    onAfterBtnClick: function() {
      var chart = this.chart;
      var axisRangeDescription = getAxisRangeDescription2(chart.xAxis[0]);
      var announcement = chart.langFormat("accessibility.rangeSelector.clickButtonAnnouncement", { chart, axisRangeDescription });
      if (announcement) {
        this.announcer.announce(announcement);
      }
    },
    /**
     * @private
     */
    onInputKbdMove: function(direction) {
      var chart = this.chart;
      var rangeSel = chart.rangeSelector;
      var newIx = chart.highlightedInputRangeIx = (chart.highlightedInputRangeIx || 0) + direction;
      var newIxOutOfRange = newIx > 1 || newIx < 0;
      if (newIxOutOfRange) {
        if (chart.accessibility) {
          chart.accessibility.keyboardNavigation.tabindexContainer.focus();
          chart.accessibility.keyboardNavigation[direction < 0 ? "prev" : "next"]();
        }
      } else if (rangeSel) {
        var svgEl = rangeSel[newIx ? "maxDateBox" : "minDateBox"];
        var inputEl = rangeSel[newIx ? "maxInput" : "minInput"];
        if (svgEl && inputEl) {
          chart.setFocusToElement(svgEl, inputEl);
        }
      }
    },
    /**
     * @private
     * @param {number} direction
     */
    onInputNavInit: function(direction) {
      var _this = this;
      var component = this;
      var chart = this.chart;
      var buttonIxToHighlight = direction > 0 ? 0 : 1;
      var rangeSel = chart.rangeSelector;
      var svgEl = rangeSel && rangeSel[buttonIxToHighlight ? "maxDateBox" : "minDateBox"];
      var minInput = rangeSel && rangeSel.minInput;
      var maxInput = rangeSel && rangeSel.maxInput;
      var inputEl = buttonIxToHighlight ? maxInput : minInput;
      chart.highlightedInputRangeIx = buttonIxToHighlight;
      if (svgEl && minInput && maxInput) {
        chart.setFocusToElement(svgEl, inputEl);
        if (this.removeInputKeydownHandler) {
          this.removeInputKeydownHandler();
        }
        var keydownHandler = function(e2) {
          var isTab = (e2.which || e2.keyCode) === _this.keyCodes.tab;
          if (isTab) {
            e2.preventDefault();
            e2.stopPropagation();
            component.onInputKbdMove(e2.shiftKey ? -1 : 1);
          }
        };
        var minRemover_1 = addEvent33(minInput, "keydown", keydownHandler);
        var maxRemover_1 = addEvent33(maxInput, "keydown", keydownHandler);
        this.removeInputKeydownHandler = function() {
          minRemover_1();
          maxRemover_1();
        };
      }
    },
    /**
     * @private
     */
    onInputNavTerminate: function() {
      var rangeSel = this.chart.rangeSelector || {};
      if (rangeSel.maxInput) {
        rangeSel.hideInput("max");
      }
      if (rangeSel.minInput) {
        rangeSel.hideInput("min");
      }
      if (this.removeInputKeydownHandler) {
        this.removeInputKeydownHandler();
        delete this.removeInputKeydownHandler;
      }
    },
    /**
     * @private
     */
    initDropdownNav: function() {
      var _this = this;
      var chart = this.chart;
      var rangeSelector = chart.rangeSelector;
      var dropdown = rangeSelector && rangeSelector.dropdown;
      if (rangeSelector && dropdown) {
        chart.setFocusToElement(rangeSelector.buttonGroup, dropdown);
        if (this.removeDropdownKeydownHandler) {
          this.removeDropdownKeydownHandler();
        }
        this.removeDropdownKeydownHandler = addEvent33(dropdown, "keydown", function(e2) {
          var isTab = (e2.which || e2.keyCode) === _this.keyCodes.tab;
          if (isTab) {
            e2.preventDefault();
            e2.stopPropagation();
            if (chart.accessibility) {
              chart.accessibility.keyboardNavigation.tabindexContainer.focus();
              chart.accessibility.keyboardNavigation[e2.shiftKey ? "prev" : "next"]();
            }
          }
        });
      }
    },
    /**
     * Get navigation for the range selector buttons.
     * @private
     * @return {Highcharts.KeyboardNavigationHandler} The module object.
     */
    getRangeSelectorButtonNavigation: function() {
      var chart = this.chart;
      var keys2 = this.keyCodes;
      var component = this;
      return new KeyboardNavigationHandler_default(chart, {
        keyCodeMap: [
          [
            [keys2.left, keys2.right, keys2.up, keys2.down],
            function(keyCode) {
              return component.onButtonNavKbdArrowKey(this, keyCode);
            }
          ],
          [
            [keys2.enter, keys2.space],
            function() {
              return component.onButtonNavKbdClick(this);
            }
          ]
        ],
        validate: function() {
          return !!(chart.rangeSelector && chart.rangeSelector.buttons && chart.rangeSelector.buttons.length);
        },
        init: function(direction) {
          var rangeSelector = chart.rangeSelector;
          if (rangeSelector && rangeSelector.hasVisibleDropdown) {
            component.initDropdownNav();
          } else if (rangeSelector) {
            var lastButtonIx = rangeSelector.buttons.length - 1;
            chart.highlightRangeSelectorButton(direction > 0 ? 0 : lastButtonIx);
          }
        },
        terminate: function() {
          if (component.removeDropdownKeydownHandler) {
            component.removeDropdownKeydownHandler();
            delete component.removeDropdownKeydownHandler;
          }
        }
      });
    },
    /**
     * Get navigation for the range selector input boxes.
     * @private
     * @return {Highcharts.KeyboardNavigationHandler}
     *         The module object.
     */
    getRangeSelectorInputNavigation: function() {
      var chart = this.chart;
      var component = this;
      return new KeyboardNavigationHandler_default(chart, {
        keyCodeMap: [],
        validate: function() {
          return shouldRunInputNavigation(chart);
        },
        init: function(direction) {
          component.onInputNavInit(direction);
        },
        terminate: function() {
          component.onInputNavTerminate();
        }
      });
    },
    /**
     * Get keyboard navigation handlers for this component.
     * @return {Array<Highcharts.KeyboardNavigationHandler>}
     *         List of module objects.
     */
    getKeyboardNavigation: function() {
      return [
        this.getRangeSelectorButtonNavigation(),
        this.getRangeSelectorInputNavigation()
      ];
    },
    /**
     * Remove component traces
     */
    destroy: function() {
      if (this.removeDropdownKeydownHandler) {
        this.removeDropdownKeydownHandler();
      }
      if (this.removeInputKeydownHandler) {
        this.removeInputKeydownHandler();
      }
      if (this.announcer) {
        this.announcer.destroy();
      }
    }
  }
);
var RangeSelectorComponent_default = RangeSelectorComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/InfoRegionsComponent.js
var format10 = FormatUtilities_default.format;
var doc15 = Globals_default.doc;
var extend41 = Utilities_default.extend;
var pick49 = Utilities_default.pick;
var getAnnotationsInfoHTML2 = AnnotationsA11y_default.getAnnotationsInfoHTML;
var getAxisDescription3 = ChartUtilities_default.getAxisDescription;
var getAxisRangeDescription3 = ChartUtilities_default.getAxisRangeDescription;
var getChartTitle5 = ChartUtilities_default.getChartTitle;
var unhideChartElementFromAT7 = ChartUtilities_default.unhideChartElementFromAT;
var addClass2 = HTMLUtilities_default.addClass;
var getElement3 = HTMLUtilities_default.getElement;
var getHeadingTagNameForElement2 = HTMLUtilities_default.getHeadingTagNameForElement;
var setElAttrs5 = HTMLUtilities_default.setElAttrs;
var stripHTMLTagsFromString3 = HTMLUtilities_default.stripHTMLTagsFromString;
var visuallyHideElement3 = HTMLUtilities_default.visuallyHideElement;
function stripEmptyHTMLTags(str) {
  return str.replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "");
}
function getTypeDescForMapChart(chart, formatContext) {
  return formatContext.mapTitle ? chart.langFormat("accessibility.chartTypes.mapTypeDescription", formatContext) : chart.langFormat("accessibility.chartTypes.unknownMap", formatContext);
}
function getTypeDescForCombinationChart(chart, formatContext) {
  return chart.langFormat("accessibility.chartTypes.combinationChart", formatContext);
}
function getTypeDescForEmptyChart(chart, formatContext) {
  return chart.langFormat("accessibility.chartTypes.emptyChart", formatContext);
}
function buildTypeDescriptionFromSeries(chart, types, context) {
  var firstType = types[0], typeExplaination = chart.langFormat("accessibility.seriesTypeDescriptions." + firstType, context), multi = chart.series && chart.series.length < 2 ? "Single" : "Multiple";
  return (chart.langFormat("accessibility.chartTypes." + firstType + multi, context) || chart.langFormat("accessibility.chartTypes.default" + multi, context)) + (typeExplaination ? " " + typeExplaination : "");
}
function getTableSummary(chart) {
  return chart.langFormat("accessibility.table.tableSummary", { chart });
}
Chart_default.prototype.getTypeDescription = function(types) {
  var firstType = types[0], firstSeries = this.series && this.series[0] || {}, formatContext = {
    numSeries: this.series.length,
    numPoints: firstSeries.points && firstSeries.points.length,
    chart: this,
    mapTitle: firstSeries.mapTitle
  };
  if (!firstType) {
    return getTypeDescForEmptyChart(this, formatContext);
  }
  if (firstType === "map") {
    return getTypeDescForMapChart(this, formatContext);
  }
  if (this.types.length > 1) {
    return getTypeDescForCombinationChart(this, formatContext);
  }
  return buildTypeDescriptionFromSeries(this, types, formatContext);
};
var InfoRegionsComponent = function() {
};
InfoRegionsComponent.prototype = new AccessibilityComponent_default();
extend41(
  InfoRegionsComponent.prototype,
  /** @lends Highcharts.InfoRegionsComponent */
  {
    /**
     * Init the component
     * @private
     */
    init: function() {
      var chart = this.chart;
      var component = this;
      this.initRegionsDefinitions();
      this.addEvent(chart, "aftergetTableAST", function(e2) {
        component.onDataTableCreated(e2);
      });
      this.addEvent(chart, "afterViewData", function(tableDiv) {
        component.dataTableDiv = tableDiv;
        setTimeout(function() {
          component.focusDataTable();
        }, 300);
      });
      this.announcer = new Announcer_default(chart, "assertive");
    },
    /**
     * @private
     */
    initRegionsDefinitions: function() {
      var component = this;
      this.screenReaderSections = {
        before: {
          element: null,
          buildContent: function(chart) {
            var formatter = chart.options.accessibility.screenReaderSection.beforeChartFormatter;
            return formatter ? formatter(chart) : component.defaultBeforeChartFormatter(chart);
          },
          insertIntoDOM: function(el, chart) {
            chart.renderTo.insertBefore(el, chart.renderTo.firstChild);
          },
          afterInserted: function() {
            if (typeof component.sonifyButtonId !== "undefined") {
              component.initSonifyButton(component.sonifyButtonId);
            }
            if (typeof component.dataTableButtonId !== "undefined") {
              component.initDataTableButton(component.dataTableButtonId);
            }
          }
        },
        after: {
          element: null,
          buildContent: function(chart) {
            var formatter = chart.options.accessibility.screenReaderSection.afterChartFormatter;
            return formatter ? formatter(chart) : component.defaultAfterChartFormatter();
          },
          insertIntoDOM: function(el, chart) {
            chart.renderTo.insertBefore(el, chart.container.nextSibling);
          },
          afterInserted: function() {
            if (component.chart.accessibility) {
              component.chart.accessibility.keyboardNavigation.updateExitAnchor();
            }
          }
        }
      };
    },
    /**
     * Called on chart render. Have to update the sections on render, in order
     * to get a11y info from series.
     */
    onChartRender: function() {
      var component = this;
      this.linkedDescriptionElement = this.getLinkedDescriptionElement();
      this.setLinkedDescriptionAttrs();
      Object.keys(this.screenReaderSections).forEach(function(regionKey) {
        component.updateScreenReaderSection(regionKey);
      });
    },
    /**
     * @private
     */
    getLinkedDescriptionElement: function() {
      var chartOptions = this.chart.options, linkedDescOption = chartOptions.accessibility.linkedDescription;
      if (!linkedDescOption) {
        return;
      }
      if (typeof linkedDescOption !== "string") {
        return linkedDescOption;
      }
      var query = format10(linkedDescOption, this.chart), queryMatch = doc15.querySelectorAll(query);
      if (queryMatch.length === 1) {
        return queryMatch[0];
      }
    },
    /**
     * @private
     */
    setLinkedDescriptionAttrs: function() {
      var el = this.linkedDescriptionElement;
      if (el) {
        el.setAttribute("aria-hidden", "true");
        addClass2(el, "highcharts-linked-description");
      }
    },
    /**
     * @private
     * @param {string} regionKey The name/key of the region to update
     */
    updateScreenReaderSection: function(regionKey) {
      var chart = this.chart, region = this.screenReaderSections[regionKey], content = region.buildContent(chart), sectionDiv = region.element = region.element || this.createElement("div"), hiddenDiv = sectionDiv.firstChild || this.createElement("div");
      this.setScreenReaderSectionAttribs(sectionDiv, regionKey);
      AST_default.setElementHTML(hiddenDiv, content);
      sectionDiv.appendChild(hiddenDiv);
      region.insertIntoDOM(sectionDiv, chart);
      visuallyHideElement3(hiddenDiv);
      unhideChartElementFromAT7(chart, hiddenDiv);
      if (region.afterInserted) {
        region.afterInserted();
      }
    },
    /**
     * @private
     * @param {Highcharts.HTMLDOMElement} sectionDiv The section element
     * @param {string} regionKey Name/key of the region we are setting attrs for
     */
    setScreenReaderSectionAttribs: function(sectionDiv, regionKey) {
      var labelLangKey = "accessibility.screenReaderSection." + regionKey + "RegionLabel", chart = this.chart, labelText = chart.langFormat(labelLangKey, { chart, chartTitle: getChartTitle5(chart) }), sectionId = "highcharts-screen-reader-region-" + regionKey + "-" + chart.index;
      setElAttrs5(sectionDiv, {
        id: sectionId,
        "aria-label": labelText
      });
      sectionDiv.style.position = "relative";
      if (chart.options.accessibility.landmarkVerbosity === "all" && labelText) {
        sectionDiv.setAttribute("role", "region");
      }
    },
    /**
     * @private
     * @return {string}
     */
    defaultBeforeChartFormatter: function() {
      var chart = this.chart, format15 = chart.options.accessibility.screenReaderSection.beforeChartFormat, axesDesc = this.getAxesDescription(), shouldHaveSonifyBtn = chart.sonify && chart.options.sonification && chart.options.sonification.enabled, sonifyButtonId = "highcharts-a11y-sonify-data-btn-" + chart.index, dataTableButtonId = "hc-linkto-highcharts-data-table-" + chart.index, annotationsList = getAnnotationsInfoHTML2(chart), annotationsTitleStr = chart.langFormat("accessibility.screenReaderSection.annotations.heading", { chart }), context = {
        headingTagName: getHeadingTagNameForElement2(chart.renderTo),
        chartTitle: getChartTitle5(chart),
        typeDescription: this.getTypeDescriptionText(),
        chartSubtitle: this.getSubtitleText(),
        chartLongdesc: this.getLongdescText(),
        xAxisDescription: axesDesc.xAxis,
        yAxisDescription: axesDesc.yAxis,
        playAsSoundButton: shouldHaveSonifyBtn ? this.getSonifyButtonText(sonifyButtonId) : "",
        viewTableButton: chart.getCSV ? this.getDataTableButtonText(dataTableButtonId) : "",
        annotationsTitle: annotationsList ? annotationsTitleStr : "",
        annotationsList
      }, formattedString = Globals_default.i18nFormat(format15, context, chart);
      this.dataTableButtonId = dataTableButtonId;
      this.sonifyButtonId = sonifyButtonId;
      return stripEmptyHTMLTags(formattedString);
    },
    /**
     * @private
     * @return {string}
     */
    defaultAfterChartFormatter: function() {
      var chart = this.chart, format15 = chart.options.accessibility.screenReaderSection.afterChartFormat, context = {
        endOfChartMarker: this.getEndOfChartMarkerText()
      }, formattedString = Globals_default.i18nFormat(format15, context, chart);
      return stripEmptyHTMLTags(formattedString);
    },
    /**
     * @private
     * @return {string}
     */
    getLinkedDescription: function() {
      var el = this.linkedDescriptionElement, content = el && el.innerHTML || "";
      return stripHTMLTagsFromString3(content);
    },
    /**
     * @private
     * @return {string}
     */
    getLongdescText: function() {
      var chartOptions = this.chart.options, captionOptions = chartOptions.caption, captionText = captionOptions && captionOptions.text, linkedDescription = this.getLinkedDescription();
      return chartOptions.accessibility.description || linkedDescription || captionText || "";
    },
    /**
     * @private
     * @return {string}
     */
    getTypeDescriptionText: function() {
      var chart = this.chart;
      return chart.types ? chart.options.accessibility.typeDescription || chart.getTypeDescription(chart.types) : "";
    },
    /**
     * @private
     * @param {string} buttonId
     * @return {string}
     */
    getDataTableButtonText: function(buttonId) {
      var chart = this.chart, buttonText = chart.langFormat("accessibility.table.viewAsDataTableButtonText", { chart, chartTitle: getChartTitle5(chart) });
      return '<button id="' + buttonId + '">' + buttonText + "</button>";
    },
    /**
     * @private
     * @param {string} buttonId
     * @return {string}
     */
    getSonifyButtonText: function(buttonId) {
      var chart = this.chart;
      if (chart.options.sonification && chart.options.sonification.enabled === false) {
        return "";
      }
      var buttonText = chart.langFormat("accessibility.sonification.playAsSoundButtonText", { chart, chartTitle: getChartTitle5(chart) });
      return '<button id="' + buttonId + '">' + buttonText + "</button>";
    },
    /**
     * @private
     * @return {string}
     */
    getSubtitleText: function() {
      var subtitle = this.chart.options.subtitle;
      return stripHTMLTagsFromString3(subtitle && subtitle.text || "");
    },
    /**
     * @private
     * @return {string}
     */
    getEndOfChartMarkerText: function() {
      var chart = this.chart, markerText = chart.langFormat("accessibility.screenReaderSection.endOfChartMarker", { chart }), id = "highcharts-end-of-chart-marker-" + chart.index;
      return '<div id="' + id + '">' + markerText + "</div>";
    },
    /**
     * @private
     * @param {Highcharts.Dictionary<string>} e
     */
    onDataTableCreated: function(e2) {
      var chart = this.chart;
      if (chart.options.accessibility.enabled) {
        if (this.viewDataTableButton) {
          this.viewDataTableButton.setAttribute("aria-expanded", "true");
        }
        var attributes = e2.tree.attributes || {};
        attributes.tabindex = -1;
        attributes.summary = getTableSummary(chart);
        e2.tree.attributes = attributes;
      }
    },
    /**
     * @private
     */
    focusDataTable: function() {
      var tableDiv = this.dataTableDiv, table = tableDiv && tableDiv.getElementsByTagName("table")[0];
      if (table && table.focus) {
        table.focus();
      }
    },
    /**
     * @private
     * @param {string} sonifyButtonId
     */
    initSonifyButton: function(sonifyButtonId) {
      var _this = this;
      var el = this.sonifyButton = getElement3(sonifyButtonId);
      var chart = this.chart;
      var defaultHandler = function(e2) {
        if (el) {
          el.setAttribute("aria-hidden", "true");
          el.setAttribute("aria-label", "");
        }
        e2.preventDefault();
        e2.stopPropagation();
        var announceMsg = chart.langFormat("accessibility.sonification.playAsSoundClickAnnouncement", { chart });
        _this.announcer.announce(announceMsg);
        setTimeout(function() {
          if (el) {
            el.removeAttribute("aria-hidden");
            el.removeAttribute("aria-label");
          }
          if (chart.sonify) {
            chart.sonify();
          }
        }, 1e3);
      };
      if (el && chart) {
        setElAttrs5(el, {
          tabindex: -1
        });
        el.onclick = function(e2) {
          var onPlayAsSoundClick = chart.options.accessibility && chart.options.accessibility.screenReaderSection.onPlayAsSoundClick;
          (onPlayAsSoundClick || defaultHandler).call(this, e2, chart);
        };
      }
    },
    /**
     * Set attribs and handlers for default viewAsDataTable button if exists.
     * @private
     * @param {string} tableButtonId
     */
    initDataTableButton: function(tableButtonId) {
      var el = this.viewDataTableButton = getElement3(tableButtonId), chart = this.chart, tableId = tableButtonId.replace("hc-linkto-", "");
      if (el) {
        setElAttrs5(el, {
          tabindex: -1,
          "aria-expanded": !!getElement3(tableId)
        });
        el.onclick = chart.options.accessibility.screenReaderSection.onViewDataTableClick || function() {
          chart.viewData();
        };
      }
    },
    /**
     * Return object with text description of each of the chart's axes.
     * @private
     * @return {Highcharts.Dictionary<string>}
     */
    getAxesDescription: function() {
      var chart = this.chart, shouldDescribeColl = function(collectionKey, defaultCondition) {
        var axes = chart[collectionKey];
        return axes.length > 1 || axes[0] && pick49(axes[0].options.accessibility && axes[0].options.accessibility.enabled, defaultCondition);
      }, hasNoMap = !!chart.types && chart.types.indexOf("map") < 0, hasCartesian = !!chart.hasCartesianSeries, showXAxes = shouldDescribeColl("xAxis", !chart.angular && hasCartesian && hasNoMap), showYAxes = shouldDescribeColl("yAxis", hasCartesian && hasNoMap), desc = {};
      if (showXAxes) {
        desc.xAxis = this.getAxisDescriptionText("xAxis");
      }
      if (showYAxes) {
        desc.yAxis = this.getAxisDescriptionText("yAxis");
      }
      return desc;
    },
    /**
     * @private
     * @param {string} collectionKey
     * @return {string}
     */
    getAxisDescriptionText: function(collectionKey) {
      var chart = this.chart;
      var axes = chart[collectionKey];
      return chart.langFormat("accessibility.axis." + collectionKey + "Description" + (axes.length > 1 ? "Plural" : "Singular"), {
        chart,
        names: axes.map(function(axis) {
          return getAxisDescription3(axis);
        }),
        ranges: axes.map(function(axis) {
          return getAxisRangeDescription3(axis);
        }),
        numAxes: axes.length
      });
    },
    /**
     * Remove component traces
     */
    destroy: function() {
      if (this.announcer) {
        this.announcer.destroy();
      }
    }
  }
);
var InfoRegionsComponent_default = InfoRegionsComponent;

// node_modules/highcharts/es-modules/Accessibility/Components/ContainerComponent.js
var unhideChartElementFromAT8 = ChartUtilities_default.unhideChartElementFromAT;
var getChartTitle6 = ChartUtilities_default.getChartTitle;
var doc16 = Globals_default.doc;
var stripHTMLTags4 = HTMLUtilities_default.stripHTMLTagsFromString;
var extend42 = Utilities_default.extend;
var ContainerComponent = function() {
};
ContainerComponent.prototype = new AccessibilityComponent_default();
extend42(
  ContainerComponent.prototype,
  /** @lends Highcharts.ContainerComponent */
  {
    /**
     * Called on first render/updates to the chart, including options changes.
     */
    onChartUpdate: function() {
      this.handleSVGTitleElement();
      this.setSVGContainerLabel();
      this.setGraphicContainerAttrs();
      this.setRenderToAttrs();
      this.makeCreditsAccessible();
    },
    /**
     * @private
     */
    handleSVGTitleElement: function() {
      var chart = this.chart, titleId = "highcharts-title-" + chart.index, titleContents = stripHTMLTags4(chart.langFormat("accessibility.svgContainerTitle", {
        chartTitle: getChartTitle6(chart)
      }));
      if (titleContents.length) {
        var titleElement = this.svgTitleElement = this.svgTitleElement || doc16.createElementNS("http://www.w3.org/2000/svg", "title");
        titleElement.textContent = titleContents;
        titleElement.id = titleId;
        chart.renderTo.insertBefore(titleElement, chart.renderTo.firstChild);
      }
    },
    /**
     * @private
     */
    setSVGContainerLabel: function() {
      var chart = this.chart, svgContainerLabel = chart.langFormat("accessibility.svgContainerLabel", {
        chartTitle: getChartTitle6(chart)
      });
      if (chart.renderer.box && svgContainerLabel.length) {
        chart.renderer.box.setAttribute("aria-label", svgContainerLabel);
      }
    },
    /**
     * @private
     */
    setGraphicContainerAttrs: function() {
      var chart = this.chart, label = chart.langFormat("accessibility.graphicContainerLabel", {
        chartTitle: getChartTitle6(chart)
      });
      if (label.length) {
        chart.container.setAttribute("aria-label", label);
      }
    },
    /**
     * @private
     */
    setRenderToAttrs: function() {
      var chart = this.chart;
      if (chart.options.accessibility.landmarkVerbosity !== "disabled") {
        chart.renderTo.setAttribute("role", "region");
      } else {
        chart.renderTo.removeAttribute("role");
      }
      chart.renderTo.setAttribute("aria-label", chart.langFormat("accessibility.chartContainerLabel", {
        title: getChartTitle6(chart),
        chart
      }));
    },
    /**
     * @private
     */
    makeCreditsAccessible: function() {
      var chart = this.chart, credits = chart.credits;
      if (credits) {
        if (credits.textStr) {
          credits.element.setAttribute("aria-label", chart.langFormat("accessibility.credits", { creditsStr: stripHTMLTags4(credits.textStr) }));
        }
        unhideChartElementFromAT8(chart, credits.element);
      }
    },
    /**
     * Empty handler to just set focus on chart
     * @return {Highcharts.KeyboardNavigationHandler}
     */
    getKeyboardNavigation: function() {
      var chart = this.chart;
      return new KeyboardNavigationHandler_default(chart, {
        keyCodeMap: [],
        validate: function() {
          return true;
        },
        init: function() {
          var a11y = chart.accessibility;
          if (a11y) {
            a11y.keyboardNavigation.tabindexContainer.focus();
          }
        }
      });
    },
    /**
     * Accessibility disabled/chart destroyed.
     */
    destroy: function() {
      this.chart.renderTo.setAttribute("aria-hidden", true);
    }
  }
);
var ContainerComponent_default = ContainerComponent;

// node_modules/highcharts/es-modules/Accessibility/HighContrastMode.js
var doc17 = Globals_default.doc;
var isMS3 = Globals_default.isMS;
var win15 = Globals_default.win;
var whcm = {
  /**
   * Detect WHCM in the browser.
   *
   * @function Highcharts#isHighContrastModeActive
   * @private
   * @return {boolean} Returns true if the browser is in High Contrast mode.
   */
  isHighContrastModeActive: function() {
    var isEdge = /(Edg)/.test(win15.navigator.userAgent);
    if (win15.matchMedia && isEdge) {
      return win15.matchMedia("(-ms-high-contrast: active)").matches;
    }
    if (isMS3 && win15.getComputedStyle) {
      var testDiv = doc17.createElement("div");
      var imageSrc = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      testDiv.style.backgroundImage = "url(" + imageSrc + ")";
      doc17.body.appendChild(testDiv);
      var bi = (testDiv.currentStyle || win15.getComputedStyle(testDiv)).backgroundImage;
      doc17.body.removeChild(testDiv);
      return bi === "none";
    }
    return false;
  },
  /**
   * Force high contrast theme for the chart. The default theme is defined in
   * a separate file.
   *
   * @function Highcharts#setHighContrastTheme
   * @private
   * @param {Highcharts.AccessibilityChart} chart The chart to set the theme of.
   * @return {void}
   */
  setHighContrastTheme: function(chart) {
    chart.highContrastModeActive = true;
    var theme2 = chart.options.accessibility.highContrastTheme;
    chart.update(theme2, false);
    chart.series.forEach(function(s) {
      var plotOpts = theme2.plotOptions[s.type] || {};
      s.update({
        color: plotOpts.color || "windowText",
        colors: [plotOpts.color || "windowText"],
        borderColor: plotOpts.borderColor || "window"
      });
      s.points.forEach(function(p) {
        if (p.options && p.options.color) {
          p.update({
            color: plotOpts.color || "windowText",
            borderColor: plotOpts.borderColor || "window"
          }, false);
        }
      });
    });
    chart.redraw();
  }
};
var HighContrastMode_default = whcm;

// node_modules/highcharts/es-modules/Accessibility/HighContrastTheme.js
var theme = {
  chart: {
    backgroundColor: "window"
  },
  title: {
    style: {
      color: "windowText"
    }
  },
  subtitle: {
    style: {
      color: "windowText"
    }
  },
  colorAxis: {
    minColor: "windowText",
    maxColor: "windowText",
    stops: []
  },
  colors: ["windowText"],
  xAxis: {
    gridLineColor: "windowText",
    labels: {
      style: {
        color: "windowText"
      }
    },
    lineColor: "windowText",
    minorGridLineColor: "windowText",
    tickColor: "windowText",
    title: {
      style: {
        color: "windowText"
      }
    }
  },
  yAxis: {
    gridLineColor: "windowText",
    labels: {
      style: {
        color: "windowText"
      }
    },
    lineColor: "windowText",
    minorGridLineColor: "windowText",
    tickColor: "windowText",
    title: {
      style: {
        color: "windowText"
      }
    }
  },
  tooltip: {
    backgroundColor: "window",
    borderColor: "windowText",
    style: {
      color: "windowText"
    }
  },
  plotOptions: {
    series: {
      lineColor: "windowText",
      fillColor: "window",
      borderColor: "windowText",
      edgeColor: "windowText",
      borderWidth: 1,
      dataLabels: {
        connectorColor: "windowText",
        color: "windowText",
        style: {
          color: "windowText",
          textOutline: "none"
        }
      },
      marker: {
        lineColor: "windowText",
        fillColor: "windowText"
      }
    },
    pie: {
      color: "window",
      colors: ["window"],
      borderColor: "windowText",
      borderWidth: 1
    },
    boxplot: {
      fillColor: "window"
    },
    candlestick: {
      lineColor: "windowText",
      fillColor: "window"
    },
    errorbar: {
      fillColor: "window"
    }
  },
  legend: {
    backgroundColor: "window",
    itemStyle: {
      color: "windowText"
    },
    itemHoverStyle: {
      color: "windowText"
    },
    itemHiddenStyle: {
      color: "#555"
    },
    title: {
      style: {
        color: "windowText"
      }
    }
  },
  credits: {
    style: {
      color: "windowText"
    }
  },
  labels: {
    style: {
      color: "windowText"
    }
  },
  drilldown: {
    activeAxisLabelStyle: {
      color: "windowText"
    },
    activeDataLabelStyle: {
      color: "windowText"
    }
  },
  navigation: {
    buttonOptions: {
      symbolStroke: "windowText",
      theme: {
        fill: "window"
      }
    }
  },
  rangeSelector: {
    buttonTheme: {
      fill: "window",
      stroke: "windowText",
      style: {
        color: "windowText"
      },
      states: {
        hover: {
          fill: "window",
          stroke: "windowText",
          style: {
            color: "windowText"
          }
        },
        select: {
          fill: "#444",
          stroke: "windowText",
          style: {
            color: "windowText"
          }
        }
      }
    },
    inputBoxBorderColor: "windowText",
    inputStyle: {
      backgroundColor: "window",
      color: "windowText"
    },
    labelStyle: {
      color: "windowText"
    }
  },
  navigator: {
    handles: {
      backgroundColor: "window",
      borderColor: "windowText"
    },
    outlineColor: "windowText",
    maskFill: "transparent",
    series: {
      color: "windowText",
      lineColor: "windowText"
    },
    xAxis: {
      gridLineColor: "windowText"
    }
  },
  scrollbar: {
    barBackgroundColor: "#444",
    barBorderColor: "windowText",
    buttonArrowColor: "windowText",
    buttonBackgroundColor: "window",
    buttonBorderColor: "windowText",
    rifleColor: "windowText",
    trackBackgroundColor: "window",
    trackBorderColor: "windowText"
  }
};
var HighContrastTheme_default = theme;

// node_modules/highcharts/es-modules/Accessibility/Options/Options.js
var Options = {
  /**
   * Options for configuring accessibility for the chart. Requires the
   * [accessibility module](https://code.highcharts.com/modules/accessibility.js)
   * to be loaded. For a description of the module and information
   * on its features, see
   * [Highcharts Accessibility](https://www.highcharts.com/docs/accessibility/accessibility-module).
   *
   * @since        5.0.0
   * @requires     modules/accessibility
   * @optionparent accessibility
   */
  accessibility: {
    /**
     * Enable accessibility functionality for the chart.
     *
     * @since 5.0.0
     */
    enabled: true,
    /**
     * Accessibility options for the screen reader information sections
     * added before and after the chart.
     *
     * @since 8.0.0
     */
    screenReaderSection: {
      /**
       * Function to run upon clicking the "View as Data Table" link in
       * the screen reader region.
       *
       * By default Highcharts will insert and set focus to a data table
       * representation of the chart.
       *
       * @type      {Highcharts.ScreenReaderClickCallbackFunction}
       * @since 8.0.0
       * @apioption accessibility.screenReaderSection.onViewDataTableClick
       */
      /**
       * Function to run upon clicking the "Play as sound" button in
       * the screen reader region.
       *
       * By default Highcharts will call the `chart.sonify` function.
       *
       * @type      {Highcharts.ScreenReaderClickCallbackFunction}
       * @since 8.0.1
       * @apioption accessibility.screenReaderSection.onPlayAsSoundClick
       */
      /**
       * A formatter function to create the HTML contents of the hidden
       * screen reader information region before the chart. Receives one
       * argument, `chart`, referring to the chart object. Should return a
       * string with the HTML content of the region. By default this
       * returns an automatic description of the chart based on
       * [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}
       * @since 8.0.0
       * @apioption accessibility.screenReaderSection.beforeChartFormatter
       */
      /**
       * Format for the screen reader information region before the chart.
       * Supported HTML tags are `<h1-6>`, `<p>`, `<div>`, `<a>`, `<ul>`,
       * `<ol>`, `<li>`, and `<button>`. Attributes are not supported,
       * except for id on `<div>`, `<a>`, and `<button>`. Id is required
       * on `<a>` and `<button>` in the format `<tag id="abcd">`. Numbers,
       * lower- and uppercase letters, "-" and "#" are valid characters in
       * IDs.
       *
       * The headingTagName is an auto-detected heading (h1-h6) that
       * corresponds to the heading level below the previous heading in
       * the DOM.
       *
       * @since 8.0.0
       */
      beforeChartFormat: "<{headingTagName}>{chartTitle}</{headingTagName}><div>{typeDescription}</div><div>{chartSubtitle}</div><div>{chartLongdesc}</div><div>{playAsSoundButton}</div><div>{viewTableButton}</div><div>{xAxisDescription}</div><div>{yAxisDescription}</div><div>{annotationsTitle}{annotationsList}</div>",
      /**
       * A formatter function to create the HTML contents of the hidden
       * screen reader information region after the chart. Analogous to
       * [beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Chart>}
       * @since 8.0.0
       * @apioption accessibility.screenReaderSection.afterChartFormatter
       */
      /**
       * Format for the screen reader information region after the chart.
       * Analogous to [beforeChartFormat](#accessibility.screenReaderSection.beforeChartFormat).
       *
       * @since 8.0.0
       */
      afterChartFormat: "{endOfChartMarker}",
      /**
       * Date format to use to describe range of datetime axes.
       *
       * For an overview of the replacement codes, see
       * [dateFormat](/class-reference/Highcharts#.dateFormat).
       *
       * @see [point.dateFormat](#accessibility.point.dateFormat)
       *
       * @since 8.0.0
       */
      axisRangeDateFormat: "%Y-%m-%d %H:%M:%S"
    },
    /**
     * Accessibility options global to all data series. Individual series
     * can also have specific [accessibility options](#plotOptions.series.accessibility)
     * set.
     *
     * @since 8.0.0
     */
    series: {
      /**
       * Formatter function to use instead of the default for series
       * descriptions. Receives one argument, `series`, referring to the
       * series to describe. Should return a string with the description
       * of the series for a screen reader user. If `false` is returned,
       * the default formatter will be used for that series.
       *
       * @see [series.description](#plotOptions.series.description)
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Series>}
       * @since 8.0.0
       * @apioption accessibility.series.descriptionFormatter
       */
      /**
       * Whether or not to add series descriptions to charts with a single
       * series.
       *
       * @since 8.0.0
       */
      describeSingleSeries: false,
      /**
       * When a series contains more points than this, we no longer expose
       * information about individual points to screen readers.
       *
       * Set to `false` to disable.
       *
       * @type  {boolean|number}
       * @since 8.0.0
       */
      pointDescriptionEnabledThreshold: 200
    },
    /**
     * Options for descriptions of individual data points.
     *
     * @since 8.0.0
     */
    point: {
      /**
       * Date format to use for points on datetime axes when describing
       * them to screen reader users.
       *
       * Defaults to the same format as in tooltip.
       *
       * For an overview of the replacement codes, see
       * [dateFormat](/class-reference/Highcharts#.dateFormat).
       *
       * @see [dateFormatter](#accessibility.point.dateFormatter)
       *
       * @type      {string}
       * @since 8.0.0
       * @apioption accessibility.point.dateFormat
       */
      /**
       * Formatter function to determine the date/time format used with
       * points on datetime axes when describing them to screen reader
       * users. Receives one argument, `point`, referring to the point
       * to describe. Should return a date format string compatible with
       * [dateFormat](/class-reference/Highcharts#.dateFormat).
       *
       * @see [dateFormat](#accessibility.point.dateFormat)
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}
       * @since 8.0.0
       * @apioption accessibility.point.dateFormatter
       */
      /**
       * Prefix to add to the values in the point descriptions. Uses
       * [tooltip.valuePrefix](#tooltip.valuePrefix) if not defined.
       *
       * @type        {string}
       * @since 8.0.0
       * @apioption   accessibility.point.valuePrefix
       */
      /**
       * Suffix to add to the values in the point descriptions. Uses
       * [tooltip.valueSuffix](#tooltip.valueSuffix) if not defined.
       *
       * @type        {string}
       * @since 8.0.0
       * @apioption   accessibility.point.valueSuffix
       */
      /**
       * Decimals to use for the values in the point descriptions. Uses
       * [tooltip.valueDecimals](#tooltip.valueDecimals) if not defined.
       *
       * @type        {number}
       * @since 8.0.0
       * @apioption   accessibility.point.valueDecimals
       */
      /**
       * Formatter function to use instead of the default for point
       * descriptions.
       *
       * Receives one argument, `point`, referring to the point to
       * describe. Should return a string with the description of the
       * point for a screen reader user. If `false` is returned, the
       * default formatter will be used for that point.
       *
       * Note: Prefer using [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)
       * instead if possible, as default functionality such as describing
       * annotations will be preserved.
       *
       * @see [accessibility.point.valueDescriptionFormat](#accessibility.point.valueDescriptionFormat)
       * @see [point.accessibility.description](#series.line.data.accessibility.description)
       *
       * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}
       * @since 8.0.0
       * @apioption accessibility.point.descriptionFormatter
       */
      /**
       * Format to use for describing the values of data points
       * to assistive technology - including screen readers.
       * The point context is available as `{point}`.
       *
       * Additionally, the series name, annotation info, and
       * description added in `point.accessibility.description`
       * is added by default if relevant. To override this, use the
       * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)
       * option.
       *
       * @see [point.accessibility.description](#series.line.data.accessibility.description)
       * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)
       *
       * @type      {string}
       * @since 8.0.1
       */
      valueDescriptionFormat: "{index}. {xDescription}{separator}{value}."
    },
    /**
     * Amount of landmarks/regions to create for screen reader users. More
     * landmarks can make navigation with screen readers easier, but can
     * be distracting if there are lots of charts on the page. Three modes
     * are available:
     *  - `all`: Adds regions for all series, legend, menu, information
     *      region.
     *  - `one`: Adds a single landmark per chart.
     *  - `disabled`: No landmarks are added.
     *
     * @since 7.1.0
     * @validvalue ["all", "one", "disabled"]
     */
    landmarkVerbosity: "all",
    /**
     * Link the chart to an HTML element describing the contents of the
     * chart.
     *
     * It is always recommended to describe charts using visible text, to
     * improve SEO as well as accessibility for users with disabilities.
     * This option lets an HTML element with a description be linked to the
     * chart, so that screen reader users can connect the two.
     *
     * By setting this option to a string, Highcharts runs the string as an
     * HTML selector query on the entire document. If there is only a single
     * match, this element is linked to the chart. The content of the linked
     * element will be included in the chart description for screen reader
     * users.
     *
     * By default, the chart looks for an adjacent sibling element with the
     * `highcharts-description` class.
     *
     * The feature can be disabled by setting the option to an empty string,
     * or overridden by providing the
     * [accessibility.description](#accessibility.description) option.
     * Alternatively, the HTML element to link can be passed in directly as
     * an HTML node.
     *
     * If you need the description to be part of the exported image,
     * consider using the [caption](#caption) feature.
     *
     * If you need the description to be hidden visually, use the
     * [accessibility.description](#accessibility.description) option.
     *
     * @see [caption](#caption)
     * @see [description](#accessibility.description)
     * @see [typeDescription](#accessibility.typeDescription)
     *
     * @sample highcharts/accessibility/accessible-line
     *         Accessible line chart
     *
     * @type  {string|Highcharts.HTMLDOMElement}
     * @since 8.0.0
     */
    linkedDescription: '*[data-highcharts-chart="{index}"] + .highcharts-description',
    /**
     * A hook for adding custom components to the accessibility module.
     * Should be an object mapping component names to instances of classes
     * inheriting from the Highcharts.AccessibilityComponent base class.
     * Remember to add the component to the
     * [keyboardNavigation.order](#accessibility.keyboardNavigation.order)
     * for the keyboard navigation to be usable.
     *
     * @sample highcharts/accessibility/custom-component
     *         Custom accessibility component
     *
     * @type      {*}
     * @since     7.1.0
     * @apioption accessibility.customComponents
     */
    /**
     * Theme to apply to the chart when Windows High Contrast Mode is
     * detected. By default, a high contrast theme matching the high
     * contrast system system colors is used.
     *
     * @type      {*}
     * @since     7.1.3
     * @apioption accessibility.highContrastTheme
     */
    /**
     * A text description of the chart.
     *
     * **Note: Prefer using [linkedDescription](#accessibility.linkedDescription)
     * or [caption](#caption.text) instead.**
     *
     * If the Accessibility module is loaded, this option is included by
     * default as a long description of the chart in the hidden screen
     * reader information region.
     *
     * Note: Since Highcharts now supports captions and linked descriptions,
     * it is preferred to define the description using those methods, as a
     * visible caption/description benefits all users. If the
     * `accessibility.description` option is defined, the linked description
     * is ignored, and the caption is hidden from screen reader users.
     *
     * @see [linkedDescription](#accessibility.linkedDescription)
     * @see [caption](#caption)
     * @see [typeDescription](#accessibility.typeDescription)
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption accessibility.description
     */
    /**
     * A text description of the chart type.
     *
     * If the Accessibility module is loaded, this will be included in the
     * description of the chart in the screen reader information region.
     *
     * Highcharts will by default attempt to guess the chart type, but for
     * more complex charts it is recommended to specify this property for
     * clarity.
     *
     * @type      {string}
     * @since     5.0.0
     * @apioption accessibility.typeDescription
     */
    /**
     * Options for keyboard navigation.
     *
     * @declare Highcharts.KeyboardNavigationOptionsObject
     * @since   5.0.0
     */
    keyboardNavigation: {
      /**
       * Enable keyboard navigation for the chart.
       *
       * @since 5.0.0
       */
      enabled: true,
      /**
       * Options for the focus border drawn around elements while
       * navigating through them.
       *
       * @sample highcharts/accessibility/custom-focus
       *         Custom focus ring
       *
       * @declare Highcharts.KeyboardNavigationFocusBorderOptionsObject
       * @since   6.0.3
       */
      focusBorder: {
        /**
         * Enable/disable focus border for chart.
         *
         * @since 6.0.3
         */
        enabled: true,
        /**
         * Hide the browser's default focus indicator.
         *
         * @since 6.0.4
         */
        hideBrowserFocusOutline: true,
        /**
         * Style options for the focus border drawn around elements
         * while navigating through them. Note that some browsers in
         * addition draw their own borders for focused elements. These
         * automatic borders can not be styled by Highcharts.
         *
         * In styled mode, the border is given the
         * `.highcharts-focus-border` class.
         *
         * @type    {Highcharts.CSSObject}
         * @since   6.0.3
         */
        style: {
          /** @internal */
          color: Palette_default.highlightColor80,
          /** @internal */
          lineWidth: 2,
          /** @internal */
          borderRadius: 3
        },
        /**
         * Focus border margin around the elements.
         *
         * @since 6.0.3
         */
        margin: 2
      },
      /**
       * Order of tab navigation in the chart. Determines which elements
       * are tabbed to first. Available elements are: `series`, `zoom`,
       * `rangeSelector`, `chartMenu`, `legend` and `container`. In
       * addition, any custom components can be added here. Adding
       * `container` first in order will make the keyboard focus stop on
       * the chart container first, requiring the user to tab again to
       * enter the chart.
       *
       * @type  {Array<string>}
       * @since 7.1.0
       */
      order: ["series", "zoom", "rangeSelector", "legend", "chartMenu"],
      /**
       * Whether or not to wrap around when reaching the end of arrow-key
       * navigation for an element in the chart.
       * @since 7.1.0
       */
      wrapAround: true,
      /**
       * Options for the keyboard navigation of data points and series.
       *
       * @declare Highcharts.KeyboardNavigationSeriesNavigationOptionsObject
       * @since 8.0.0
       */
      seriesNavigation: {
        /**
         * Set the keyboard navigation mode for the chart. Can be
         * "normal" or "serialize". In normal mode, left/right arrow
         * keys move between points in a series, while up/down arrow
         * keys move between series. Up/down navigation acts
         * intelligently to figure out which series makes sense to move
         * to from any given point.
         *
         * In "serialize" mode, points are instead navigated as a single
         * list. Left/right behaves as in "normal" mode. Up/down arrow
         * keys will behave like left/right. This can be useful for
         * unifying navigation behavior with/without screen readers
         * enabled.
         *
         * @type       {string}
         * @default    normal
         * @since 8.0.0
         * @validvalue ["normal", "serialize"]
         * @apioption  accessibility.keyboardNavigation.seriesNavigation.mode
         */
        /**
         * Skip null points when navigating through points with the
         * keyboard.
         *
         * @since 8.0.0
         */
        skipNullPoints: true,
        /**
         * When a series contains more points than this, we no longer
         * allow keyboard navigation for it.
         *
         * Set to `false` to disable.
         *
         * @type  {boolean|number}
         * @since 8.0.0
         */
        pointNavigationEnabledThreshold: false
      }
    },
    /**
     * Options for announcing new data to screen reader users. Useful
     * for dynamic data applications and drilldown.
     *
     * Keep in mind that frequent announcements will not be useful to
     * users, as they won't have time to explore the new data. For these
     * applications, consider making snapshots of the data accessible, and
     * do the announcements in batches.
     *
     * @declare Highcharts.AccessibilityAnnounceNewDataOptionsObject
     * @since   7.1.0
     */
    announceNewData: {
      /**
       * Optional formatter callback for the announcement. Receives
       * up to three arguments. The first argument is always an array
       * of all series that received updates. If an announcement is
       * already queued, the series that received updates for that
       * announcement are also included in this array. The second
       * argument is provided if `chart.addSeries` was called, and
       * there is a new series. In that case, this argument is a
       * reference to the new series. The third argument, similarly,
       * is provided if `series.addPoint` was called, and there is a
       * new point. In that case, this argument is a reference to the
       * new point.
       *
       * The function should return a string with the text to announce
       * to the user. Return empty string to not announce anything.
       * Return `false` to use the default announcement format.
       *
       * @sample highcharts/accessibility/custom-dynamic
       *         High priority live alerts
       *
       * @type      {Highcharts.AccessibilityAnnouncementFormatter}
       * @apioption accessibility.announceNewData.announcementFormatter
       */
      /**
       * Enable announcing new data to screen reader users
       * @sample highcharts/accessibility/accessible-dynamic
       *         Dynamic data accessible
       */
      enabled: false,
      /**
       * Minimum interval between announcements in milliseconds. If
       * new data arrives before this amount of time has passed, it is
       * queued for announcement. If another new data event happens
       * while an announcement is queued, the queued announcement is
       * dropped, and the latest announcement is queued instead. Set
       * to 0 to allow all announcements, but be warned that frequent
       * announcements are disturbing to users.
       */
      minAnnounceInterval: 5e3,
      /**
       * Choose whether or not the announcements should interrupt the
       * screen reader. If not enabled, the user will be notified once
       * idle. It is recommended not to enable this setting unless
       * there is a specific reason to do so.
       */
      interruptUser: false
    }
  },
  /**
   * Accessibility options for a data point.
   *
   * @declare   Highcharts.PointAccessibilityOptionsObject
   * @since     7.1.0
   * @apioption series.line.data.accessibility
   */
  /**
   * Provide a description of the data point, announced to screen readers.
   *
   * @type      {string}
   * @since     7.1.0
   * @apioption series.line.data.accessibility.description
   */
  /**
   * Set to false to disable accessibility functionality for a specific point.
   * The point will not be included in keyboard navigation, and will not be
   * exposed to assistive technology.
   *
   * @type      {boolean}
   * @since 9.0.1
   * @apioption series.line.data.accessibility.enabled
   */
  /**
   * Accessibility options for a series.
   *
   * @declare    Highcharts.SeriesAccessibilityOptionsObject
   * @since      7.1.0
   * @requires   modules/accessibility
   * @apioption  plotOptions.series.accessibility
   */
  /**
   * Enable/disable accessibility functionality for a specific series.
   *
   * @type       {boolean}
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.enabled
   */
  /**
   * Provide a description of the series, announced to screen readers.
   *
   * @type       {string}
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.description
   */
  /**
   * Formatter function to use instead of the default for point
   * descriptions. Same as `accessibility.point.descriptionFormatter`, but for
   * a single series.
   *
   * @see [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter)
   *
   * @type      {Highcharts.ScreenReaderFormatterCallbackFunction<Highcharts.Point>}
   * @since     7.1.0
   * @apioption plotOptions.series.accessibility.pointDescriptionFormatter
   */
  /**
   * Expose only the series element to screen readers, not its points.
   *
   * @type       {boolean}
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.exposeAsGroupOnly
   */
  /**
   * Keyboard navigation for a series
   *
   * @declare    Highcharts.SeriesAccessibilityKeyboardNavigationOptionsObject
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.keyboardNavigation
   */
  /**
   * Enable/disable keyboard navigation support for a specific series.
   *
   * @type       {boolean}
   * @since      7.1.0
   * @apioption  plotOptions.series.accessibility.keyboardNavigation.enabled
   */
  /**
   * Accessibility options for an annotation label.
   *
   * @declare    Highcharts.AnnotationLabelAccessibilityOptionsObject
   * @since 8.0.1
   * @requires   modules/accessibility
   * @apioption  annotations.labelOptions.accessibility
   */
  /**
   * Description of an annotation label for screen readers and other assistive
   * technology.
   *
   * @type       {string}
   * @since 8.0.1
   * @apioption  annotations.labelOptions.accessibility.description
   */
  /**
   * Accessibility options for an axis. Requires the accessibility module.
   *
   * @declare    Highcharts.AxisAccessibilityOptionsObject
   * @since      7.1.0
   * @requires   modules/accessibility
   * @apioption  xAxis.accessibility
   */
  /**
   * Enable axis accessibility features, including axis information in the
   * screen reader information region. If this is disabled on the xAxis, the
   * x values are not exposed to screen readers for the individual data points
   * by default.
   *
   * @type       {boolean}
   * @since      7.1.0
   * @apioption  xAxis.accessibility.enabled
   */
  /**
   * Description for an axis to expose to screen reader users.
   *
   * @type       {string}
   * @since      7.1.0
   * @apioption  xAxis.accessibility.description
   */
  /**
   * Range description for an axis. Overrides the default range description.
   * Set to empty to disable range description for this axis.
   *
   * @type       {string}
   * @since      7.1.0
   * @apioption  xAxis.accessibility.rangeDescription
   */
  /**
   * @optionparent legend
   */
  legend: {
    /**
     * Accessibility options for the legend. Requires the Accessibility
     * module.
     *
     * @since     7.1.0
     * @requires  modules/accessibility
     */
    accessibility: {
      /**
       * Enable accessibility support for the legend.
       *
       * @since  7.1.0
       */
      enabled: true,
      /**
       * Options for keyboard navigation for the legend.
       *
       * @since     7.1.0
       * @requires  modules/accessibility
       */
      keyboardNavigation: {
        /**
         * Enable keyboard navigation for the legend.
         *
         * @see [accessibility.keyboardNavigation](#accessibility.keyboardNavigation.enabled)
         *
         * @since  7.1.0
         */
        enabled: true
      }
    }
  },
  /**
   * @optionparent exporting
   */
  exporting: {
    /**
     * Accessibility options for the exporting menu. Requires the
     * Accessibility module.
     *
     * @since    7.1.0
     * @requires modules/accessibility
     */
    accessibility: {
      /**
       * Enable accessibility support for the export menu.
       *
       * @since 7.1.0
       */
      enabled: true
    }
  }
};
var Options_default = Options;

// node_modules/highcharts/es-modules/Accessibility/Options/LangOptions.js
var langOptions = {
  /**
   * Configure the accessibility strings in the chart. Requires the
   * [accessibility module](https://code.highcharts.com/modules/accessibility.js)
   * to be loaded. For a description of the module and information on its
   * features, see
   * [Highcharts Accessibility](https://www.highcharts.com/docs/chart-concepts/accessibility).
   *
   * For more dynamic control over the accessibility functionality, see
   * [accessibility.point.descriptionFormatter](#accessibility.point.descriptionFormatter),
   * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),
   * and
   * [accessibility.screenReaderSection.beforeChartFormatter](#accessibility.screenReaderSection.beforeChartFormatter).
   *
   * @since        6.0.6
   * @optionparent lang.accessibility
   */
  accessibility: {
    defaultChartTitle: "Chart",
    chartContainerLabel: "{title}. Highcharts interactive chart.",
    svgContainerLabel: "Interactive chart",
    drillUpButton: "{buttonText}",
    credits: "Chart credits: {creditsStr}",
    /**
     * Thousands separator to use when formatting numbers for screen
     * readers. Note that many screen readers will not handle space as a
     * thousands separator, and will consider "11 700" as two numbers.
     *
     * Set to `null` to use the separator defined in
     * [lang.thousandsSep](lang.thousandsSep).
     *
     * @since 7.1.0
     */
    thousandsSep: ",",
    /**
     * Title element text for the chart SVG element. Leave this
     * empty to disable adding the title element. Browsers will display
     * this content when hovering over elements in the chart. Assistive
     * technology may use this element to label the chart.
     *
     * @since 6.0.8
     */
    svgContainerTitle: "",
    /**
     * Set a label on the container wrapping the SVG.
     *
     * @see [chartContainerLabel](#lang.accessibility.chartContainerLabel)
     *
     * @since 8.0.0
     */
    graphicContainerLabel: "",
    /**
     * Language options for the screen reader information sections added
     * before and after the charts.
     *
     * @since 8.0.0
     */
    screenReaderSection: {
      beforeRegionLabel: "Chart screen reader information, {chartTitle}.",
      afterRegionLabel: "",
      /**
       * Language options for annotation descriptions.
       *
       * @since 8.0.1
       */
      annotations: {
        heading: "Chart annotations summary",
        descriptionSinglePoint: "{annotationText}. Related to {annotationPoint}",
        descriptionMultiplePoints: "{annotationText}. Related to {annotationPoint}{ Also related to, #each(additionalAnnotationPoints)}",
        descriptionNoPoints: "{annotationText}"
      },
      /**
       * Label for the end of the chart. Announced by screen readers.
       *
       * @since 8.0.0
       */
      endOfChartMarker: "End of interactive chart."
    },
    /**
     * Language options for sonification.
     *
     * @since 8.0.1
     */
    sonification: {
      playAsSoundButtonText: "Play as sound, {chartTitle}",
      playAsSoundClickAnnouncement: "Play"
    },
    /**
     * Language options for accessibility of the legend.
     *
     * @since 8.0.0
     */
    legend: {
      legendLabelNoTitle: "Toggle series visibility, {chartTitle}",
      legendLabel: "Chart legend: {legendTitle}",
      legendItem: "Show {itemName}"
    },
    /**
     * Chart and map zoom accessibility language options.
     *
     * @since 8.0.0
     */
    zoom: {
      mapZoomIn: "Zoom chart",
      mapZoomOut: "Zoom out chart",
      resetZoomButton: "Reset zoom"
    },
    /**
     * Range selector language options for accessibility.
     *
     * @since 8.0.0
     */
    rangeSelector: {
      dropdownLabel: "{rangeTitle}",
      minInputLabel: "Select start date.",
      maxInputLabel: "Select end date.",
      clickButtonAnnouncement: "Viewing {axisRangeDescription}"
    },
    /**
     * Accessibility language options for the data table.
     *
     * @since 8.0.0
     */
    table: {
      viewAsDataTableButtonText: "View as data table, {chartTitle}",
      tableSummary: "Table representation of chart."
    },
    /**
     * Default announcement for new data in charts. If addPoint or
     * addSeries is used, and only one series/point is added, the
     * `newPointAnnounce` and `newSeriesAnnounce` strings are used.
     * The `...Single` versions will be used if there is only one chart
     * on the page, and the `...Multiple` versions will be used if there
     * are multiple charts on the page. For all other new data events,
     * the `newDataAnnounce` string will be used.
     *
     * @since 7.1.0
     */
    announceNewData: {
      newDataAnnounce: "Updated data for chart {chartTitle}",
      newSeriesAnnounceSingle: "New data series: {seriesDesc}",
      newPointAnnounceSingle: "New data point: {pointDesc}",
      newSeriesAnnounceMultiple: "New data series in chart {chartTitle}: {seriesDesc}",
      newPointAnnounceMultiple: "New data point in chart {chartTitle}: {pointDesc}"
    },
    /**
     * Descriptions of lesser known series types. The relevant
     * description is added to the screen reader information region
     * when these series types are used.
     *
     * @since 6.0.6
     */
    seriesTypeDescriptions: {
      boxplot: "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.",
      arearange: "Arearange charts are line charts displaying a range between a lower and higher value for each point.",
      areasplinerange: "These charts are line charts displaying a range between a lower and higher value for each point.",
      bubble: "Bubble charts are scatter charts where each data point also has a size value.",
      columnrange: "Columnrange charts are column charts displaying a range between a lower and higher value for each point.",
      errorbar: "Errorbar series are used to display the variability of the data.",
      funnel: "Funnel charts are used to display reduction of data in stages.",
      pyramid: "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.",
      waterfall: "A waterfall chart is a column chart where each column contributes towards a total end value."
    },
    /**
     * Chart type description strings. This is added to the chart
     * information region.
     *
     * If there is only a single series type used in the chart, we use
     * the format string for the series type, or default if missing.
     * There is one format string for cases where there is only a single
     * series in the chart, and one for multiple series of the same
     * type.
     *
     * @since 6.0.6
     */
    chartTypes: {
      /* eslint-disable max-len */
      emptyChart: "Empty chart",
      mapTypeDescription: "Map of {mapTitle} with {numSeries} data series.",
      unknownMap: "Map of unspecified region with {numSeries} data series.",
      combinationChart: "Combination chart with {numSeries} data series.",
      defaultSingle: "Chart with {numPoints} data {#plural(numPoints, points, point)}.",
      defaultMultiple: "Chart with {numSeries} data series.",
      splineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
      splineMultiple: "Line chart with {numSeries} lines.",
      lineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
      lineMultiple: "Line chart with {numSeries} lines.",
      columnSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
      columnMultiple: "Bar chart with {numSeries} data series.",
      barSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
      barMultiple: "Bar chart with {numSeries} data series.",
      pieSingle: "Pie chart with {numPoints} {#plural(numPoints, slices, slice)}.",
      pieMultiple: "Pie chart with {numSeries} pies.",
      scatterSingle: "Scatter chart with {numPoints} {#plural(numPoints, points, point)}.",
      scatterMultiple: "Scatter chart with {numSeries} data series.",
      boxplotSingle: "Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.",
      boxplotMultiple: "Boxplot with {numSeries} data series.",
      bubbleSingle: "Bubble chart with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
      bubbleMultiple: "Bubble chart with {numSeries} data series."
    },
    /**
     * Axis description format strings.
     *
     * @since 6.0.6
     */
    axis: {
      /* eslint-disable max-len */
      xAxisDescriptionSingular: "The chart has 1 X axis displaying {names[0]}. {ranges[0]}",
      xAxisDescriptionPlural: "The chart has {numAxes} X axes displaying {#each(names, -1) }and {names[-1]}.",
      yAxisDescriptionSingular: "The chart has 1 Y axis displaying {names[0]}. {ranges[0]}",
      yAxisDescriptionPlural: "The chart has {numAxes} Y axes displaying {#each(names, -1) }and {names[-1]}.",
      timeRangeDays: "Range: {range} days.",
      timeRangeHours: "Range: {range} hours.",
      timeRangeMinutes: "Range: {range} minutes.",
      timeRangeSeconds: "Range: {range} seconds.",
      rangeFromTo: "Range: {rangeFrom} to {rangeTo}.",
      rangeCategories: "Range: {numCategories} categories."
    },
    /**
     * Exporting menu format strings for accessibility module.
     *
     * @since 6.0.6
     */
    exporting: {
      chartMenuLabel: "Chart menu",
      menuButtonLabel: "View chart menu",
      exportRegionLabel: "Chart menu, {chartTitle}"
    },
    /**
     * Lang configuration for different series types. For more dynamic
     * control over the series element descriptions, see
     * [accessibility.seriesDescriptionFormatter](#accessibility.seriesDescriptionFormatter).
     *
     * @since 6.0.6
     */
    series: {
      /**
       * Lang configuration for the series main summary. Each series
       * type has two modes:
       *
       * 1. This series type is the only series type used in the
       *    chart
       *
       * 2. This is a combination chart with multiple series types
       *
       * If a definition does not exist for the specific series type
       * and mode, the 'default' lang definitions are used.
       *
       * @since 6.0.6
       */
      summary: {
        /* eslint-disable max-len */
        "default": "{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        defaultCombination: "{name}, series {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        line: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        lineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
        spline: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        splineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
        column: "{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.",
        columnCombination: "{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.",
        bar: "{name}, bar series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bars, bar)}.",
        barCombination: "{name}, series {ix} of {numSeries}. Bar series with {numPoints} {#plural(numPoints, bars, bar)}.",
        pie: "{name}, pie {ix} of {numSeries} with {numPoints} {#plural(numPoints, slices, slice)}.",
        pieCombination: "{name}, series {ix} of {numSeries}. Pie with {numPoints} {#plural(numPoints, slices, slice)}.",
        scatter: "{name}, scatter plot {ix} of {numSeries} with {numPoints} {#plural(numPoints, points, point)}.",
        scatterCombination: "{name}, series {ix} of {numSeries}, scatter plot with {numPoints} {#plural(numPoints, points, point)}.",
        boxplot: "{name}, boxplot {ix} of {numSeries} with {numPoints} {#plural(numPoints, boxes, box)}.",
        boxplotCombination: "{name}, series {ix} of {numSeries}. Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.",
        bubble: "{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
        bubbleCombination: "{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
        map: "{name}, map {ix} of {numSeries} with {numPoints} {#plural(numPoints, areas, area)}.",
        mapCombination: "{name}, series {ix} of {numSeries}. Map with {numPoints} {#plural(numPoints, areas, area)}.",
        mapline: "{name}, line {ix} of {numSeries} with {numPoints} data {#plural(numPoints, points, point)}.",
        maplineCombination: "{name}, series {ix} of {numSeries}. Line with {numPoints} data {#plural(numPoints, points, point)}.",
        mapbubble: "{name}, bubble series {ix} of {numSeries} with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
        mapbubbleCombination: "{name}, series {ix} of {numSeries}. Bubble series with {numPoints} {#plural(numPoints, bubbles, bubble)}."
      },
      /**
       * User supplied description text. This is added in the point
       * comment description by default if present.
       *
       * @since 6.0.6
       */
      description: "{description}",
      /**
       * xAxis description for series if there are multiple xAxes in
       * the chart.
       *
       * @since 6.0.6
       */
      xAxisDescription: "X axis, {name}",
      /**
       * yAxis description for series if there are multiple yAxes in
       * the chart.
       *
       * @since 6.0.6
       */
      yAxisDescription: "Y axis, {name}",
      /**
       * Description for the value of null points.
       *
       * @since 8.0.0
       */
      nullPointValue: "No value",
      /**
       * Description for annotations on a point, as it is made available
       * to assistive technology.
       *
       * @since 8.0.1
       */
      pointAnnotationsDescription: "{Annotation: #each(annotations). }"
    }
  }
};
var LangOptions_default = langOptions;

// node_modules/highcharts/es-modules/Accessibility/Options/DeprecatedOptions.js
var error10 = Utilities_default.error;
var pick50 = Utilities_default.pick;
function traverseSetOption(root, optionAsArray, val) {
  var opt = root, prop, i = 0;
  for (; i < optionAsArray.length - 1; ++i) {
    prop = optionAsArray[i];
    opt = opt[prop] = pick50(opt[prop], {});
  }
  opt[optionAsArray[optionAsArray.length - 1]] = val;
}
function deprecateFromOptionsMap(chart, rootOldAsArray, rootNewAsArray, mapToNewOptions) {
  function getChildProp(root, propAsArray) {
    return propAsArray.reduce(function(acc, cur) {
      return acc[cur];
    }, root);
  }
  var rootOld = getChildProp(chart.options, rootOldAsArray), rootNew = getChildProp(chart.options, rootNewAsArray);
  Object.keys(mapToNewOptions).forEach(function(oldOptionKey) {
    var _a15;
    var val = rootOld[oldOptionKey];
    if (typeof val !== "undefined") {
      traverseSetOption(rootNew, mapToNewOptions[oldOptionKey], val);
      error10(32, false, chart, (_a15 = {}, _a15[rootOldAsArray.join(".") + "." + oldOptionKey] = rootNewAsArray.join(".") + "." + mapToNewOptions[oldOptionKey].join("."), _a15));
    }
  });
}
function copyDeprecatedChartOptions(chart) {
  var chartOptions = chart.options.chart, a11yOptions = chart.options.accessibility || {};
  ["description", "typeDescription"].forEach(function(prop) {
    var _a15;
    if (chartOptions[prop]) {
      a11yOptions[prop] = chartOptions[prop];
      error10(32, false, chart, (_a15 = {}, _a15["chart." + prop] = "use accessibility." + prop, _a15));
    }
  });
}
function copyDeprecatedAxisOptions(chart) {
  chart.axes.forEach(function(axis) {
    var opts = axis.options;
    if (opts && opts.description) {
      opts.accessibility = opts.accessibility || {};
      opts.accessibility.description = opts.description;
      error10(32, false, chart, { "axis.description": "use axis.accessibility.description" });
    }
  });
}
function copyDeprecatedSeriesOptions(chart) {
  var oldToNewSeriesOptions = {
    description: ["accessibility", "description"],
    exposeElementToA11y: ["accessibility", "exposeAsGroupOnly"],
    pointDescriptionFormatter: [
      "accessibility",
      "pointDescriptionFormatter"
    ],
    skipKeyboardNavigation: [
      "accessibility",
      "keyboardNavigation",
      "enabled"
    ]
  };
  chart.series.forEach(function(series) {
    Object.keys(oldToNewSeriesOptions).forEach(function(oldOption) {
      var _a15;
      var optionVal = series.options[oldOption];
      if (typeof optionVal !== "undefined") {
        traverseSetOption(
          series.options,
          oldToNewSeriesOptions[oldOption],
          // Note that skipKeyboardNavigation has inverted option
          // value, since we set enabled rather than disabled
          oldOption === "skipKeyboardNavigation" ? !optionVal : optionVal
        );
        error10(32, false, chart, (_a15 = {}, _a15["series." + oldOption] = "series." + oldToNewSeriesOptions[oldOption].join("."), _a15));
      }
    });
  });
}
function copyDeprecatedTopLevelAccessibilityOptions(chart) {
  deprecateFromOptionsMap(chart, ["accessibility"], ["accessibility"], {
    pointDateFormat: ["point", "dateFormat"],
    pointDateFormatter: ["point", "dateFormatter"],
    pointDescriptionFormatter: ["point", "descriptionFormatter"],
    pointDescriptionThreshold: [
      "series",
      "pointDescriptionEnabledThreshold"
    ],
    pointNavigationThreshold: [
      "keyboardNavigation",
      "seriesNavigation",
      "pointNavigationEnabledThreshold"
    ],
    pointValueDecimals: ["point", "valueDecimals"],
    pointValuePrefix: ["point", "valuePrefix"],
    pointValueSuffix: ["point", "valueSuffix"],
    screenReaderSectionFormatter: [
      "screenReaderSection",
      "beforeChartFormatter"
    ],
    describeSingleSeries: ["series", "describeSingleSeries"],
    seriesDescriptionFormatter: ["series", "descriptionFormatter"],
    onTableAnchorClick: ["screenReaderSection", "onViewDataTableClick"],
    axisRangeDateFormat: ["screenReaderSection", "axisRangeDateFormat"]
  });
}
function copyDeprecatedKeyboardNavigationOptions(chart) {
  deprecateFromOptionsMap(chart, ["accessibility", "keyboardNavigation"], ["accessibility", "keyboardNavigation", "seriesNavigation"], {
    skipNullPoints: ["skipNullPoints"],
    mode: ["mode"]
  });
}
function copyDeprecatedLangOptions(chart) {
  deprecateFromOptionsMap(chart, ["lang", "accessibility"], ["lang", "accessibility"], {
    legendItem: ["legend", "legendItem"],
    legendLabel: ["legend", "legendLabel"],
    mapZoomIn: ["zoom", "mapZoomIn"],
    mapZoomOut: ["zoom", "mapZoomOut"],
    resetZoomButton: ["zoom", "resetZoomButton"],
    screenReaderRegionLabel: [
      "screenReaderSection",
      "beforeRegionLabel"
    ],
    rangeSelectorButton: ["rangeSelector", "buttonText"],
    rangeSelectorMaxInput: ["rangeSelector", "maxInputLabel"],
    rangeSelectorMinInput: ["rangeSelector", "minInputLabel"],
    svgContainerEnd: ["screenReaderSection", "endOfChartMarker"],
    viewAsDataTable: ["table", "viewAsDataTableButtonText"],
    tableSummary: ["table", "tableSummary"]
  });
}
function copyDeprecatedOptions(chart) {
  copyDeprecatedChartOptions(chart);
  copyDeprecatedAxisOptions(chart);
  if (chart.series) {
    copyDeprecatedSeriesOptions(chart);
  }
  copyDeprecatedTopLevelAccessibilityOptions(chart);
  copyDeprecatedKeyboardNavigationOptions(chart);
  copyDeprecatedLangOptions(chart);
}
var DeprecatedOptions_default = copyDeprecatedOptions;

// node_modules/highcharts/es-modules/Accessibility/A11yI18n.js
var format11 = FormatUtilities_default.format;
var pick51 = Utilities_default.pick;
function stringTrim(str) {
  return str.trim && str.trim() || str.replace(/^\s+|\s+$/g, "");
}
function formatExtendedStatement(statement, ctx) {
  var eachStart = statement.indexOf("#each("), pluralStart = statement.indexOf("#plural("), indexStart = statement.indexOf("["), indexEnd = statement.indexOf("]"), arr, result2;
  if (eachStart > -1) {
    var eachEnd = statement.slice(eachStart).indexOf(")") + eachStart, preEach = statement.substring(0, eachStart), postEach = statement.substring(eachEnd + 1), eachStatement = statement.substring(eachStart + 6, eachEnd), eachArguments = eachStatement.split(","), lenArg = Number(eachArguments[1]), len = void 0;
    result2 = "";
    arr = ctx[eachArguments[0]];
    if (arr) {
      lenArg = isNaN(lenArg) ? arr.length : lenArg;
      len = lenArg < 0 ? arr.length + lenArg : Math.min(lenArg, arr.length);
      for (var i = 0; i < len; ++i) {
        result2 += preEach + arr[i] + postEach;
      }
    }
    return result2.length ? result2 : "";
  }
  if (pluralStart > -1) {
    var pluralEnd = statement.slice(pluralStart).indexOf(")") + pluralStart, pluralStatement = statement.substring(pluralStart + 8, pluralEnd), pluralArguments = pluralStatement.split(","), num = Number(ctx[pluralArguments[0]]);
    switch (num) {
      case 0:
        result2 = pick51(pluralArguments[4], pluralArguments[1]);
        break;
      case 1:
        result2 = pick51(pluralArguments[2], pluralArguments[1]);
        break;
      case 2:
        result2 = pick51(pluralArguments[3], pluralArguments[1]);
        break;
      default:
        result2 = pluralArguments[1];
    }
    return result2 ? stringTrim(result2) : "";
  }
  if (indexStart > -1) {
    var arrayName = statement.substring(0, indexStart), ix = Number(statement.substring(indexStart + 1, indexEnd)), val = void 0;
    arr = ctx[arrayName];
    if (!isNaN(ix) && arr) {
      if (ix < 0) {
        val = arr[arr.length + ix];
        if (typeof val === "undefined") {
          val = arr[0];
        }
      } else {
        val = arr[ix];
        if (typeof val === "undefined") {
          val = arr[arr.length - 1];
        }
      }
    }
    return typeof val !== "undefined" ? val : "";
  }
  return "{" + statement + "}";
}
Globals_default.i18nFormat = function(formatString, context, chart) {
  var getFirstBracketStatement = function(sourceStr, offset3) {
    var str = sourceStr.slice(offset3 || 0), startBracket = str.indexOf("{"), endBracket = str.indexOf("}");
    if (startBracket > -1 && endBracket > startBracket) {
      return {
        statement: str.substring(startBracket + 1, endBracket),
        begin: offset3 + startBracket + 1,
        end: offset3 + endBracket
      };
    }
  }, tokens = [], bracketRes, constRes, cursor = 0;
  do {
    bracketRes = getFirstBracketStatement(formatString, cursor);
    constRes = formatString.substring(cursor, bracketRes && bracketRes.begin - 1);
    if (constRes.length) {
      tokens.push({
        value: constRes,
        type: "constant"
      });
    }
    if (bracketRes) {
      tokens.push({
        value: bracketRes.statement,
        type: "statement"
      });
    }
    cursor = bracketRes ? bracketRes.end + 1 : cursor + 1;
  } while (bracketRes);
  tokens.forEach(function(token) {
    if (token.type === "statement") {
      token.value = formatExtendedStatement(token.value, context);
    }
  });
  return format11(tokens.reduce(function(acc, cur) {
    return acc + cur.value;
  }, ""), context, chart);
};
Chart_default.prototype.langFormat = function(langKey, context) {
  var keys2 = langKey.split("."), formatString = this.options.lang, i = 0;
  for (; i < keys2.length; ++i) {
    formatString = formatString && formatString[keys2[i]];
  }
  return typeof formatString === "string" ? Globals_default.i18nFormat(formatString, context, this) : "";
};

// node_modules/highcharts/es-modules/Accessibility/FocusBorder.js
var addEvent34 = Utilities_default.addEvent;
var extend43 = Utilities_default.extend;
var pick52 = Utilities_default.pick;
var svgElementBorderUpdateTriggers = [
  "x",
  "y",
  "transform",
  "width",
  "height",
  "r",
  "d",
  "stroke-width"
];
function addDestroyFocusBorderHook(el) {
  if (el.focusBorderDestroyHook) {
    return;
  }
  var origDestroy = el.destroy;
  el.destroy = function() {
    if (el.focusBorder && el.focusBorder.destroy) {
      el.focusBorder.destroy();
    }
    return origDestroy.apply(el, arguments);
  };
  el.focusBorderDestroyHook = origDestroy;
}
function removeDestroyFocusBorderHook(el) {
  if (!el.focusBorderDestroyHook) {
    return;
  }
  el.destroy = el.focusBorderDestroyHook;
  delete el.focusBorderDestroyHook;
}
function addUpdateFocusBorderHooks(el) {
  var updateParams = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    updateParams[_i - 1] = arguments[_i];
  }
  if (el.focusBorderUpdateHooks) {
    return;
  }
  el.focusBorderUpdateHooks = {};
  svgElementBorderUpdateTriggers.forEach(function(trigger) {
    var setterKey = trigger + "Setter";
    var origSetter = el[setterKey] || el._defaultSetter;
    el.focusBorderUpdateHooks[setterKey] = origSetter;
    el[setterKey] = function() {
      var ret = origSetter.apply(el, arguments);
      el.addFocusBorder.apply(el, updateParams);
      return ret;
    };
  });
}
function removeUpdateFocusBorderHooks(el) {
  if (!el.focusBorderUpdateHooks) {
    return;
  }
  Object.keys(el.focusBorderUpdateHooks).forEach(function(setterKey) {
    var origSetter = el.focusBorderUpdateHooks[setterKey];
    if (origSetter === el._defaultSetter) {
      delete el[setterKey];
    } else {
      el[setterKey] = origSetter;
    }
  });
  delete el.focusBorderUpdateHooks;
}
extend43(SVGElement_default.prototype, {
  /**
   * @private
   * @function Highcharts.SVGElement#addFocusBorder
   *
   * @param {number} margin
   *
   * @param {SVGAttributes} attribs
   */
  addFocusBorder: function(margin, attribs) {
    if (this.focusBorder) {
      this.removeFocusBorder();
    }
    var bb = this.getBBox(), pad4 = pick52(margin, 3);
    bb.x += this.translateX ? this.translateX : 0;
    bb.y += this.translateY ? this.translateY : 0;
    var borderPosX = bb.x - pad4, borderPosY = bb.y - pad4, borderWidth = bb.width + 2 * pad4, borderHeight = bb.height + 2 * pad4;
    function getTextAnchorCorrection(text) {
      var posXCorrection = 0, posYCorrection = 0;
      if (text.attr("text-anchor") === "middle") {
        posXCorrection = posYCorrection = 0.5;
      } else if (!text.rotation) {
        posYCorrection = 0.75;
      } else {
        posXCorrection = 0.25;
      }
      return {
        x: posXCorrection,
        y: posYCorrection
      };
    }
    var isLabel = this instanceof SVGLabel_default;
    if (this.element.nodeName === "text" || isLabel) {
      var isRotated = !!this.rotation;
      var correction = !isLabel ? getTextAnchorCorrection(this) : {
        x: isRotated ? 1 : 0,
        y: 0
      };
      var attrX = +this.attr("x");
      var attrY = +this.attr("y");
      if (!isNaN(attrX)) {
        borderPosX = attrX - bb.width * correction.x - pad4;
      }
      if (!isNaN(attrY)) {
        borderPosY = attrY - bb.height * correction.y - pad4;
      }
      if (isLabel && isRotated) {
        var temp = borderWidth;
        borderWidth = borderHeight;
        borderHeight = temp;
        if (!isNaN(attrX)) {
          borderPosX = attrX - bb.height * correction.x - pad4;
        }
        if (!isNaN(attrY)) {
          borderPosY = attrY - bb.width * correction.y - pad4;
        }
      }
    }
    this.focusBorder = this.renderer.rect(borderPosX, borderPosY, borderWidth, borderHeight, parseInt((attribs && attribs.r || 0).toString(), 10)).addClass("highcharts-focus-border").attr({
      zIndex: 99
    }).add(this.parentGroup);
    if (!this.renderer.styledMode) {
      this.focusBorder.attr({
        stroke: attribs && attribs.stroke,
        "stroke-width": attribs && attribs.strokeWidth
      });
    }
    addUpdateFocusBorderHooks(this, margin, attribs);
    addDestroyFocusBorderHook(this);
  },
  /**
   * @private
   * @function Highcharts.SVGElement#removeFocusBorder
   */
  removeFocusBorder: function() {
    removeUpdateFocusBorderHooks(this);
    removeDestroyFocusBorderHook(this);
    if (this.focusBorder) {
      this.focusBorder.destroy();
      delete this.focusBorder;
    }
  }
});
Chart_default.prototype.renderFocusBorder = function() {
  var focusElement = this.focusElement, focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder;
  if (focusElement) {
    focusElement.removeFocusBorder();
    if (focusBorderOptions.enabled) {
      focusElement.addFocusBorder(focusBorderOptions.margin, {
        stroke: focusBorderOptions.style.color,
        strokeWidth: focusBorderOptions.style.lineWidth,
        r: focusBorderOptions.style.borderRadius
      });
    }
  }
};
Chart_default.prototype.setFocusToElement = function(svgElement, focusElement) {
  var focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder, browserFocusElement = focusElement || svgElement.element;
  if (browserFocusElement && browserFocusElement.focus) {
    if (!(browserFocusElement.hcEvents && browserFocusElement.hcEvents.focusin)) {
      addEvent34(browserFocusElement, "focusin", function() {
      });
    }
    browserFocusElement.focus();
    if (focusBorderOptions.hideBrowserFocusOutline) {
      browserFocusElement.style.outline = "none";
    }
  }
  if (this.focusElement) {
    this.focusElement.removeFocusBorder();
  }
  this.focusElement = svgElement;
  this.renderFocusBorder();
};

// node_modules/highcharts/es-modules/Accessibility/Accessibility.js
var doc18 = Globals_default.doc;
var defaultOptions12 = DefaultOptions_default.defaultOptions;
var addEvent35 = Utilities_default.addEvent;
var extend44 = Utilities_default.extend;
var fireEvent25 = Utilities_default.fireEvent;
var merge43 = Utilities_default.merge;
merge43(true, defaultOptions12, Options_default, {
  accessibility: {
    highContrastTheme: HighContrastTheme_default
  },
  lang: LangOptions_default
});
Globals_default.A11yChartUtilities = ChartUtilities_default;
Globals_default.A11yHTMLUtilities = HTMLUtilities_default;
Globals_default.KeyboardNavigationHandler = KeyboardNavigationHandler_default;
Globals_default.AccessibilityComponent = AccessibilityComponent_default;
function Accessibility(chart) {
  this.init(chart);
}
Accessibility.prototype = {
  /**
   * Initialize the accessibility class
   * @private
   * @param {Highcharts.Chart} chart
   *        Chart object
   */
  init: function(chart) {
    this.chart = chart;
    if (!doc18.addEventListener || !chart.renderer.isSVG) {
      chart.renderTo.setAttribute("aria-hidden", true);
      return;
    }
    DeprecatedOptions_default(chart);
    this.initComponents();
    this.keyboardNavigation = new KeyboardNavigation_default(chart, this.components);
    this.update();
  },
  /**
   * @private
   */
  initComponents: function() {
    var chart = this.chart, a11yOptions = chart.options.accessibility;
    this.components = {
      container: new ContainerComponent_default(),
      infoRegions: new InfoRegionsComponent_default(),
      legend: new LegendComponent_default(),
      chartMenu: new MenuComponent_default(),
      rangeSelector: new RangeSelectorComponent_default(),
      series: new SeriesComponent_default(),
      zoom: new ZoomComponent_default()
    };
    if (a11yOptions.customComponents) {
      extend44(this.components, a11yOptions.customComponents);
    }
    var components = this.components;
    this.getComponentOrder().forEach(function(componentName) {
      components[componentName].initBase(chart);
      components[componentName].init();
    });
  },
  /**
   * Get order to update components in.
   * @private
   */
  getComponentOrder: function() {
    if (!this.components) {
      return [];
    }
    if (!this.components.series) {
      return Object.keys(this.components);
    }
    var componentsExceptSeries = Object.keys(this.components).filter(function(c) {
      return c !== "series";
    });
    return ["series"].concat(componentsExceptSeries);
  },
  /**
   * Update all components.
   */
  update: function() {
    var components = this.components, chart = this.chart, a11yOptions = chart.options.accessibility;
    fireEvent25(chart, "beforeA11yUpdate");
    chart.types = this.getChartTypes();
    this.getComponentOrder().forEach(function(componentName) {
      components[componentName].onChartUpdate();
      fireEvent25(chart, "afterA11yComponentUpdate", {
        name: componentName,
        component: components[componentName]
      });
    });
    this.keyboardNavigation.update(a11yOptions.keyboardNavigation.order);
    if (!chart.highContrastModeActive && // Only do this once
    HighContrastMode_default.isHighContrastModeActive()) {
      HighContrastMode_default.setHighContrastTheme(chart);
    }
    fireEvent25(chart, "afterA11yUpdate", {
      accessibility: this
    });
  },
  /**
   * Destroy all elements.
   */
  destroy: function() {
    var chart = this.chart || {};
    var components = this.components;
    Object.keys(components).forEach(function(componentName) {
      components[componentName].destroy();
      components[componentName].destroyBase();
    });
    if (this.keyboardNavigation) {
      this.keyboardNavigation.destroy();
    }
    if (chart.renderTo) {
      chart.renderTo.setAttribute("aria-hidden", true);
    }
    if (chart.focusElement) {
      chart.focusElement.removeFocusBorder();
    }
  },
  /**
   * Return a list of the types of series we have in the chart.
   * @private
   */
  getChartTypes: function() {
    var types = {};
    this.chart.series.forEach(function(series) {
      types[series.type] = 1;
    });
    return Object.keys(types);
  }
};
Chart_default.prototype.updateA11yEnabled = function() {
  var a11y = this.accessibility, accessibilityOptions = this.options.accessibility;
  if (accessibilityOptions && accessibilityOptions.enabled) {
    if (a11y) {
      a11y.update();
    } else {
      this.accessibility = a11y = new Accessibility(this);
    }
  } else if (a11y) {
    if (a11y.destroy) {
      a11y.destroy();
    }
    delete this.accessibility;
  } else {
    this.renderTo.setAttribute("aria-hidden", true);
  }
};
addEvent35(Chart_default, "render", function(e2) {
  if (this.a11yDirty && this.renderTo) {
    delete this.a11yDirty;
    this.updateA11yEnabled();
  }
  var a11y = this.accessibility;
  if (a11y) {
    a11y.getComponentOrder().forEach(function(componentName) {
      a11y.components[componentName].onChartRender();
    });
  }
});
addEvent35(Chart_default, "update", function(e2) {
  var newOptions = e2.options.accessibility;
  if (newOptions) {
    if (newOptions.customComponents) {
      this.options.accessibility.customComponents = newOptions.customComponents;
      delete newOptions.customComponents;
    }
    merge43(true, this.options.accessibility, newOptions);
    if (this.accessibility && this.accessibility.destroy) {
      this.accessibility.destroy();
      delete this.accessibility;
    }
  }
  this.a11yDirty = true;
});
addEvent35(Point_default, "update", function() {
  if (this.series.chart.accessibility) {
    this.series.chart.a11yDirty = true;
  }
});
["addSeries", "init"].forEach(function(event) {
  addEvent35(Chart_default, event, function() {
    this.a11yDirty = true;
  });
});
["update", "updatedData", "remove"].forEach(function(event) {
  addEvent35(Series_default, event, function() {
    if (this.chart.accessibility) {
      this.chart.a11yDirty = true;
    }
  });
});
[
  "afterDrilldown",
  "drillupall"
].forEach(function(event) {
  addEvent35(Chart_default, event, function() {
    if (this.accessibility) {
      this.accessibility.update();
    }
  });
});
addEvent35(Chart_default, "destroy", function() {
  if (this.accessibility) {
    this.accessibility.destroy();
  }
});

// node_modules/highcharts/es-modules/Extensions/Annotations/Mixins/EventEmitterMixin.js
var addEvent36 = Utilities_default.addEvent;
var fireEvent26 = Utilities_default.fireEvent;
var objectEach26 = Utilities_default.objectEach;
var pick53 = Utilities_default.pick;
var removeEvent11 = Utilities_default.removeEvent;
var eventEmitterMixin = {
  /**
   * Add emitter events.
   */
  addEvents: function() {
    var emitter = this, addMouseDownEvent = function(element) {
      addEvent36(element, Globals_default.isTouchDevice ? "touchstart" : "mousedown", function(e2) {
        emitter.onMouseDown(e2);
      }, { passive: false });
    };
    addMouseDownEvent(this.graphic.element);
    (emitter.labels || []).forEach(function(label) {
      if (label.options.useHTML && label.graphic.text) {
        addMouseDownEvent(label.graphic.text.element);
      }
    });
    objectEach26(emitter.options.events, function(event, type) {
      var eventHandler = function(e2) {
        if (type !== "click" || !emitter.cancelClick) {
          event.call(emitter, emitter.chart.pointer.normalize(e2), emitter.target);
        }
      };
      if ((emitter.nonDOMEvents || []).indexOf(type) === -1) {
        emitter.graphic.on(type, eventHandler);
      } else {
        addEvent36(emitter, type, eventHandler, { passive: false });
      }
    });
    if (emitter.options.draggable) {
      addEvent36(emitter, "drag", emitter.onDrag);
      if (!emitter.graphic.renderer.styledMode) {
        var cssPointer_1 = {
          cursor: {
            x: "ew-resize",
            y: "ns-resize",
            xy: "move"
          }[emitter.options.draggable]
        };
        emitter.graphic.css(cssPointer_1);
        (emitter.labels || []).forEach(function(label) {
          if (label.options.useHTML && label.graphic.text) {
            label.graphic.text.css(cssPointer_1);
          }
        });
      }
    }
    if (!emitter.isUpdating) {
      fireEvent26(emitter, "add");
    }
  },
  /**
   * Remove emitter document events.
   */
  removeDocEvents: function() {
    if (this.removeDrag) {
      this.removeDrag = this.removeDrag();
    }
    if (this.removeMouseUp) {
      this.removeMouseUp = this.removeMouseUp();
    }
  },
  /**
   * Mouse down handler.
   */
  onMouseDown: function(e2) {
    var emitter = this, pointer = emitter.chart.pointer, prevChartX, prevChartY;
    if (e2.preventDefault) {
      e2.preventDefault();
    }
    if (e2.button === 2) {
      return;
    }
    e2 = pointer.normalize(e2);
    prevChartX = e2.chartX;
    prevChartY = e2.chartY;
    emitter.cancelClick = false;
    emitter.chart.hasDraggedAnnotation = true;
    emitter.removeDrag = addEvent36(Globals_default.doc, Globals_default.isTouchDevice ? "touchmove" : "mousemove", function(e3) {
      emitter.hasDragged = true;
      e3 = pointer.normalize(e3);
      e3.prevChartX = prevChartX;
      e3.prevChartY = prevChartY;
      fireEvent26(emitter, "drag", e3);
      prevChartX = e3.chartX;
      prevChartY = e3.chartY;
    }, Globals_default.isTouchDevice ? { passive: false } : void 0);
    emitter.removeMouseUp = addEvent36(Globals_default.doc, Globals_default.isTouchDevice ? "touchend" : "mouseup", function(e3) {
      var annotation = pick53(emitter.target && emitter.target.annotation, emitter.target);
      if (annotation) {
        annotation.cancelClick = emitter.hasDragged;
      }
      emitter.cancelClick = emitter.hasDragged;
      emitter.hasDragged = false;
      emitter.chart.hasDraggedAnnotation = false;
      fireEvent26(pick53(
        annotation,
        // #15952
        emitter
      ), "afterUpdate");
      emitter.onMouseUp(e3);
    }, Globals_default.isTouchDevice ? { passive: false } : void 0);
  },
  /**
   * Mouse up handler.
   */
  onMouseUp: function(_e) {
    var chart = this.chart, annotation = this.target || this, annotationsOptions = chart.options.annotations, index = chart.annotations.indexOf(annotation);
    this.removeDocEvents();
    annotationsOptions[index] = annotation.options;
  },
  /**
   * Drag and drop event. All basic annotations should share this
   * capability as well as the extended ones.
   */
  onDrag: function(e2) {
    if (this.chart.isInsidePlot(e2.chartX - this.chart.plotLeft, e2.chartY - this.chart.plotTop, {
      visiblePlotOnly: true
    })) {
      var translation_1 = this.mouseMoveToTranslation(e2);
      if (this.options.draggable === "x") {
        translation_1.y = 0;
      }
      if (this.options.draggable === "y") {
        translation_1.x = 0;
      }
      if (this.points.length) {
        this.translate(translation_1.x, translation_1.y);
      } else {
        this.shapes.forEach(function(shape) {
          shape.translate(translation_1.x, translation_1.y);
        });
        this.labels.forEach(function(label) {
          label.translate(translation_1.x, translation_1.y);
        });
      }
      this.redraw(false);
    }
  },
  /**
   * Map mouse move event to the radians.
   */
  mouseMoveToRadians: function(e2, cx, cy) {
    var prevDy = e2.prevChartY - cy, prevDx = e2.prevChartX - cx, dy = e2.chartY - cy, dx = e2.chartX - cx, temp;
    if (this.chart.inverted) {
      temp = prevDx;
      prevDx = prevDy;
      prevDy = temp;
      temp = dx;
      dx = dy;
      dy = temp;
    }
    return Math.atan2(dy, dx) - Math.atan2(prevDy, prevDx);
  },
  /**
   * Map mouse move event to the distance between two following events.
   */
  mouseMoveToTranslation: function(e2) {
    var dx = e2.chartX - e2.prevChartX, dy = e2.chartY - e2.prevChartY, temp;
    if (this.chart.inverted) {
      temp = dy;
      dy = dx;
      dx = temp;
    }
    return {
      x: dx,
      y: dy
    };
  },
  /**
   * Map mouse move to the scale factors.
   *
   * @param {Object} e event
   * @param {number} cx center x
   * @param {number} cy center y
   **/
  mouseMoveToScale: function(e2, cx, cy) {
    var prevDx = e2.prevChartX - cx, prevDy = e2.prevChartY - cy, dx = e2.chartX - cx, dy = e2.chartY - cy, sx = (dx || 1) / (prevDx || 1), sy = (dy || 1) / (prevDy || 1), temp;
    if (this.chart.inverted) {
      temp = sy;
      sy = sx;
      sx = temp;
    }
    return {
      x: sx,
      y: sy
    };
  },
  /**
   * Destroy the event emitter.
   */
  destroy: function() {
    this.removeDocEvents();
    removeEvent11(this);
    this.hcEvents = null;
  }
};
var EventEmitterMixin_default = eventEmitterMixin;

// node_modules/highcharts/es-modules/Extensions/Annotations/ControlPoint.js
var extend45 = Utilities_default.extend;
var merge44 = Utilities_default.merge;
var pick54 = Utilities_default.pick;
var ControlPoint = (
  /** @class */
  function() {
    function ControlPoint2(chart, target, options, index) {
      this.addEvents = EventEmitterMixin_default.addEvents;
      this.graphic = void 0;
      this.mouseMoveToRadians = EventEmitterMixin_default.mouseMoveToRadians;
      this.mouseMoveToScale = EventEmitterMixin_default.mouseMoveToScale;
      this.mouseMoveToTranslation = EventEmitterMixin_default.mouseMoveToTranslation;
      this.onDrag = EventEmitterMixin_default.onDrag;
      this.onMouseDown = EventEmitterMixin_default.onMouseDown;
      this.onMouseUp = EventEmitterMixin_default.onMouseUp;
      this.removeDocEvents = EventEmitterMixin_default.removeDocEvents;
      this.nonDOMEvents = ["drag"];
      this.chart = chart;
      this.target = target;
      this.options = options;
      this.index = pick54(options.index, index);
    }
    ControlPoint2.prototype.setVisibility = function(visible) {
      this.graphic.attr("visibility", visible ? "visible" : "hidden");
      this.options.visible = visible;
    };
    ControlPoint2.prototype.render = function() {
      var chart = this.chart, options = this.options;
      this.graphic = chart.renderer.symbol(options.symbol, 0, 0, options.width, options.height).add(chart.controlPointsGroup).css(options.style);
      this.setVisibility(options.visible);
      this.addEvents();
    };
    ControlPoint2.prototype.redraw = function(animation) {
      this.graphic[animation ? "animate" : "attr"](this.options.positioner.call(this, this.target));
    };
    ControlPoint2.prototype.destroy = function() {
      EventEmitterMixin_default.destroy.call(this);
      if (this.graphic) {
        this.graphic = this.graphic.destroy();
      }
      this.chart = null;
      this.target = null;
      this.options = null;
    };
    ControlPoint2.prototype.update = function(userOptions) {
      var chart = this.chart, target = this.target, index = this.index, options = merge44(true, this.options, userOptions);
      this.destroy();
      this.constructor(chart, target, options, index);
      this.render(chart.controlPointsGroup);
      this.redraw();
    };
    return ControlPoint2;
  }()
);
var ControlPoint_default = ControlPoint;

// node_modules/highcharts/es-modules/Extensions/Annotations/MockPoint.js
var defined38 = Utilities_default.defined;
var extend46 = Utilities_default.extend;
var fireEvent27 = Utilities_default.fireEvent;
var MockPoint = (
  /** @class */
  function() {
    function MockPoint2(chart, target, options) {
      this.isInside = void 0;
      this.negative = void 0;
      this.plotX = void 0;
      this.plotY = void 0;
      this.ttBelow = void 0;
      this.x = void 0;
      this.y = void 0;
      this.mock = true;
      this.series = {
        visible: true,
        chart,
        getPlotBox: Series_default.prototype.getPlotBox
      };
      this.target = target || null;
      this.options = options;
      this.applyOptions(this.getOptions());
    }
    MockPoint2.fromPoint = function(point) {
      return new MockPoint2(point.series.chart, null, {
        x: point.x,
        y: point.y,
        xAxis: point.series.xAxis,
        yAxis: point.series.yAxis
      });
    };
    MockPoint2.pointToPixels = function(point, paneCoordinates) {
      var series = point.series, chart = series.chart, x = point.plotX, y = point.plotY, plotBox;
      if (chart.inverted) {
        if (point.mock) {
          x = point.plotY;
          y = point.plotX;
        } else {
          x = chart.plotWidth - point.plotY;
          y = chart.plotHeight - point.plotX;
        }
      }
      if (series && !paneCoordinates) {
        plotBox = series.getPlotBox();
        x += plotBox.translateX;
        y += plotBox.translateY;
      }
      return {
        x,
        y
      };
    };
    MockPoint2.pointToOptions = function(point) {
      return {
        x: point.x,
        y: point.y,
        xAxis: point.series.xAxis,
        yAxis: point.series.yAxis
      };
    };
    MockPoint2.prototype.hasDynamicOptions = function() {
      return typeof this.options === "function";
    };
    MockPoint2.prototype.getOptions = function() {
      return this.hasDynamicOptions() ? this.options(this.target) : this.options;
    };
    MockPoint2.prototype.applyOptions = function(options) {
      this.command = options.command;
      this.setAxis(options, "x");
      this.setAxis(options, "y");
      this.refresh();
    };
    MockPoint2.prototype.setAxis = function(options, xOrY) {
      var axisName = xOrY + "Axis", axisOptions = options[axisName], chart = this.series.chart;
      this.series[axisName] = axisOptions instanceof Axis_default ? axisOptions : defined38(axisOptions) ? chart[axisName][axisOptions] || chart.get(axisOptions) : null;
    };
    MockPoint2.prototype.toAnchor = function() {
      var anchor = [this.plotX, this.plotY, 0, 0];
      if (this.series.chart.inverted) {
        anchor[0] = this.plotY;
        anchor[1] = this.plotX;
      }
      return anchor;
    };
    MockPoint2.prototype.getLabelConfig = function() {
      return {
        x: this.x,
        y: this.y,
        point: this
      };
    };
    MockPoint2.prototype.isInsidePlot = function() {
      var plotX = this.plotX, plotY = this.plotY, xAxis = this.series.xAxis, yAxis = this.series.yAxis, e2 = {
        x: plotX,
        y: plotY,
        isInsidePlot: true
      };
      if (xAxis) {
        e2.isInsidePlot = defined38(plotX) && plotX >= 0 && plotX <= xAxis.len;
      }
      if (yAxis) {
        e2.isInsidePlot = e2.isInsidePlot && defined38(plotY) && plotY >= 0 && plotY <= yAxis.len;
      }
      fireEvent27(this.series.chart, "afterIsInsidePlot", e2);
      return e2.isInsidePlot;
    };
    MockPoint2.prototype.refresh = function() {
      var series = this.series, xAxis = series.xAxis, yAxis = series.yAxis, options = this.getOptions();
      if (xAxis) {
        this.x = options.x;
        this.plotX = xAxis.toPixels(options.x, true);
      } else {
        this.x = null;
        this.plotX = options.x;
      }
      if (yAxis) {
        this.y = options.y;
        this.plotY = yAxis.toPixels(options.y, true);
      } else {
        this.y = null;
        this.plotY = options.y;
      }
      this.isInside = this.isInsidePlot();
    };
    MockPoint2.prototype.translate = function(_cx, _cy, dx, dy) {
      if (!this.hasDynamicOptions()) {
        this.plotX += dx;
        this.plotY += dy;
        this.refreshOptions();
      }
    };
    MockPoint2.prototype.scale = function(cx, cy, sx, sy) {
      if (!this.hasDynamicOptions()) {
        var x = this.plotX * sx, y = this.plotY * sy, tx = (1 - sx) * cx, ty = (1 - sy) * cy;
        this.plotX = tx + x;
        this.plotY = ty + y;
        this.refreshOptions();
      }
    };
    MockPoint2.prototype.rotate = function(cx, cy, radians) {
      if (!this.hasDynamicOptions()) {
        var cos2 = Math.cos(radians), sin2 = Math.sin(radians), x = this.plotX, y = this.plotY, tx = void 0, ty = void 0;
        x -= cx;
        y -= cy;
        tx = x * cos2 - y * sin2;
        ty = x * sin2 + y * cos2;
        this.plotX = tx + cx;
        this.plotY = ty + cy;
        this.refreshOptions();
      }
    };
    MockPoint2.prototype.refreshOptions = function() {
      var series = this.series, xAxis = series.xAxis, yAxis = series.yAxis;
      this.x = this.options.x = xAxis ? this.options.x = xAxis.toValue(this.plotX, true) : this.plotX;
      this.y = this.options.y = yAxis ? yAxis.toValue(this.plotY, true) : this.plotY;
    };
    return MockPoint2;
  }()
);
var MockPoint_default = MockPoint;

// node_modules/highcharts/es-modules/Extensions/Annotations/Mixins/ControllableMixin.js
var isObject9 = Utilities_default.isObject;
var isString11 = Utilities_default.isString;
var merge45 = Utilities_default.merge;
var splat14 = Utilities_default.splat;
var controllableMixin = {
  /**
   * Init the controllable
   */
  init: function(annotation, options, index) {
    this.annotation = annotation;
    this.chart = annotation.chart;
    this.options = options;
    this.points = [];
    this.controlPoints = [];
    this.index = index;
    this.linkPoints();
    this.addControlPoints();
  },
  /**
   * Redirect attr usage on the controllable graphic element.
   */
  attr: function() {
    this.graphic.attr.apply(this.graphic, arguments);
  },
  /**
   * Get the controllable's points options.
   *
   * @return {Array<Highcharts.PointOptionsObject>}
   * An array of points' options.
   */
  getPointsOptions: function() {
    var options = this.options;
    return options.points || options.point && splat14(options.point);
  },
  /**
   * Utility function for mapping item's options
   * to element's attribute
   *
   * @param {Highcharts.AnnotationsLabelsOptions|Highcharts.AnnotationsShapesOptions} options
   *
   * @return {Highcharts.SVGAttributes}
   * Mapped options.
   */
  attrsFromOptions: function(options) {
    var map = this.constructor.attrsMap, attrs = {}, key, mappedKey, styledMode = this.chart.styledMode;
    for (key in options) {
      mappedKey = map[key];
      if (mappedKey && (!styledMode || ["fill", "stroke", "stroke-width"].indexOf(mappedKey) === -1)) {
        attrs[mappedKey] = options[key];
      }
    }
    return attrs;
  },
  /**
   * Returns object which denotes anchor position - relative and absolute.
   *
   * @param {Highcharts.AnnotationPointType} point
   * A point like object.
   *
   * @return {Highcharts.AnnotationAnchorObject} a controllable anchor
   */
  anchor: function(point) {
    var plotBox = point.series.getPlotBox(), chart = point.series.chart, box = point.mock ? point.toAnchor() : Tooltip_default.prototype.getAnchor.call({
      chart: point.series.chart
    }, point), anchor = {
      x: box[0] + (this.options.x || 0),
      y: box[1] + (this.options.y || 0),
      height: box[2] || 0,
      width: box[3] || 0
    };
    return {
      relativePosition: anchor,
      absolutePosition: merge45(anchor, {
        x: anchor.x + (point.mock ? plotBox.translateX : chart.plotLeft),
        y: anchor.y + (point.mock ? plotBox.translateY : chart.plotTop)
      })
    };
  },
  /**
   * Map point's options to a point-like object.
   *
   * @param {string|Function|Highcharts.AnnotationMockPointOptionsObject|Highcharts.AnnotationPointType} pointOptions
   * Point's options.
   *
   * @param {Highcharts.AnnotationPointType} point
   * A point-like instance.
   *
   * @return {Highcharts.AnnotationPointType|null}
   *         if the point is found/set returns this point, otherwise null
   */
  point: function(pointOptions, point) {
    if (pointOptions && pointOptions.series) {
      return pointOptions;
    }
    if (!point || point.series === null) {
      if (isObject9(pointOptions)) {
        point = new MockPoint_default(this.chart, this, pointOptions);
      } else if (isString11(pointOptions)) {
        point = this.chart.get(pointOptions) || null;
      } else if (typeof pointOptions === "function") {
        var pointConfig = pointOptions.call(point, this);
        point = pointConfig.series ? pointConfig : new MockPoint_default(this.chart, this, pointOptions);
      }
    }
    return point;
  },
  /**
   * Find point-like objects based on points options.
   *
   * @return {Array<Annotation.PointLike>} an array of point-like objects
   */
  linkPoints: function() {
    var pointsOptions = this.getPointsOptions(), points = this.points, len = pointsOptions && pointsOptions.length || 0, i, point;
    for (i = 0; i < len; i++) {
      point = this.point(pointsOptions[i], points[i]);
      if (!point) {
        points.length = 0;
        return;
      }
      if (point.mock) {
        point.refresh();
      }
      points[i] = point;
    }
    return points;
  },
  /**
   * Add control points to a controllable.
   */
  addControlPoints: function() {
    var controlPointsOptions = this.options.controlPoints;
    (controlPointsOptions || []).forEach(function(controlPointOptions, i) {
      var options = merge45(this.options.controlPointOptions, controlPointOptions);
      if (!options.index) {
        options.index = i;
      }
      controlPointsOptions[i] = options;
      this.controlPoints.push(new ControlPoint_default(this.chart, this, options));
    }, this);
  },
  /**
   * Check if a controllable should be rendered/redrawn.
   *
   * @return {boolean}
   * Whether a controllable should be drawn.
   */
  shouldBeDrawn: function() {
    return Boolean(this.points.length);
  },
  /**
   * Render a controllable.
   */
  render: function(_parentGroup) {
    this.controlPoints.forEach(function(controlPoint) {
      controlPoint.render();
    });
  },
  /**
   * Redraw a controllable.
   *
   * @param {boolean} [animation]
   */
  redraw: function(animation) {
    this.controlPoints.forEach(function(controlPoint) {
      controlPoint.redraw(animation);
    });
  },
  /**
   * Transform a controllable with a specific transformation.
   *
   * @param {string} transformation a transformation name
   * @param {number|null} cx origin x transformation
   * @param {number|null} cy origin y transformation
   * @param {number} p1 param for the transformation
   * @param {number} [p2] param for the transformation
   */
  transform: function(transformation, cx, cy, p1, p2) {
    if (this.chart.inverted) {
      var temp = cx;
      cx = cy;
      cy = temp;
    }
    this.points.forEach(function(point, i) {
      this.transformPoint(transformation, cx, cy, p1, p2, i);
    }, this);
  },
  /**
   * Transform a point with a specific transformation
   * If a transformed point is a real point it is replaced with
   * the mock point.
   *
   * @param {string} transformation a transformation name
   * @param {number|null} cx origin x transformation
   * @param {number|null} cy origin y transformation
   * @param {number} p1 param for the transformation
   * @param {number|undefined} p2 param for the transformation
   * @param {number} i index of the point
   */
  transformPoint: function(transformation, cx, cy, p1, p2, i) {
    var point = this.points[i];
    if (!point.mock) {
      point = this.points[i] = MockPoint_default.fromPoint(point);
    }
    point[transformation](cx, cy, p1, p2);
  },
  /**
   * Translate a controllable.
   *
   * @param {number} dx translation for x coordinate
   * @param {number} dy translation for y coordinate
   **/
  translate: function(dx, dy) {
    this.transform("translate", null, null, dx, dy);
  },
  /**
   * Translate a specific point within a controllable.
   *
   * @param {number} dx translation for x coordinate
   * @param {number} dy translation for y coordinate
   * @param {number} i index of the point
   **/
  translatePoint: function(dx, dy, i) {
    this.transformPoint("translate", null, null, dx, dy, i);
  },
  /**
   * Translate shape within controllable item.
   * Replaces `controllable.translate` method.
   *
   * @param {number} dx translation for x coordinate
   * @param {number} dy translation for y coordinate
   */
  translateShape: function(dx, dy) {
    var chart = this.annotation.chart, shapeOptions = this.annotation.userOptions, annotationIndex = chart.annotations.indexOf(this.annotation), chartOptions = chart.options.annotations[annotationIndex];
    this.translatePoint(dx, dy, 0);
    chartOptions[this.collection][this.index].point = this.options.point;
    shapeOptions[this.collection][this.index].point = this.options.point;
  },
  /**
   * Rotate a controllable.
   *
   * @param {number} cx origin x rotation
   * @param {number} cy origin y rotation
   * @param {number} radians
   **/
  rotate: function(cx, cy, radians) {
    this.transform("rotate", cx, cy, radians);
  },
  /**
   * Scale a controllable.
   *
   * @param {number} cx origin x rotation
   * @param {number} cy origin y rotation
   * @param {number} sx scale factor x
   * @param {number} sy scale factor y
   */
  scale: function(cx, cy, sx, sy) {
    this.transform("scale", cx, cy, sx, sy);
  },
  /**
   * Set control points' visibility.
   *
   * @param {boolean} visible
   */
  setControlPointsVisibility: function(visible) {
    this.controlPoints.forEach(function(controlPoint) {
      controlPoint.setVisibility(visible);
    });
  },
  /**
   * Destroy a controllable.
   */
  destroy: function() {
    if (this.graphic) {
      this.graphic = this.graphic.destroy();
    }
    if (this.tracker) {
      this.tracker = this.tracker.destroy();
    }
    this.controlPoints.forEach(function(controlPoint) {
      controlPoint.destroy();
    });
    this.chart = null;
    this.points = null;
    this.controlPoints = null;
    this.options = null;
    if (this.annotation) {
      this.annotation = null;
    }
  },
  /**
   * Update a controllable.
   *
   * @param {Object} newOptions
   */
  update: function(newOptions) {
    var annotation = this.annotation, options = merge45(true, this.options, newOptions), parentGroup = this.graphic.parentGroup;
    this.destroy();
    this.constructor(annotation, options, this.index);
    this.render(parentGroup);
    this.redraw();
  }
};
var ControllableMixin_default = controllableMixin;

// node_modules/highcharts/es-modules/Extensions/Annotations/Mixins/MarkerMixin.js
var addEvent37 = Utilities_default.addEvent;
var defined39 = Utilities_default.defined;
var merge46 = Utilities_default.merge;
var uniqueKey7 = Utilities_default.uniqueKey;
var defaultMarkers = {
  /**
   * @type {Highcharts.ASTNode}
   */
  arrow: {
    tagName: "marker",
    attributes: {
      id: "arrow",
      refY: 5,
      refX: 9,
      markerWidth: 10,
      markerHeight: 10
    },
    /**
     * @type {Array<Highcharts.DefsOptions>}
     */
    children: [{
      tagName: "path",
      attributes: {
        d: "M 0 0 L 10 5 L 0 10 Z",
        "stroke-width": 0
      }
    }]
  },
  /**
   * @type {Highcharts.ASTNode}
   */
  "reverse-arrow": {
    tagName: "marker",
    attributes: {
      id: "reverse-arrow",
      refY: 5,
      refX: 1,
      markerWidth: 10,
      markerHeight: 10
    },
    children: [{
      tagName: "path",
      attributes: {
        // reverse triangle (used as an arrow)
        d: "M 0 5 L 10 0 L 10 10 Z",
        "stroke-width": 0
      }
    }]
  }
};
SVGRenderer_default.prototype.addMarker = function(id, markerOptions) {
  var options = { attributes: { id } };
  var attrs = {
    stroke: markerOptions.color || "none",
    fill: markerOptions.color || "rgba(0, 0, 0, 0.75)"
  };
  options.children = markerOptions.children && markerOptions.children.map(function(child) {
    return merge46(attrs, child);
  });
  var ast = merge46(true, {
    attributes: {
      markerWidth: 20,
      markerHeight: 20,
      refX: 0,
      refY: 0,
      orient: "auto"
    }
  }, markerOptions, options);
  var marker = this.definition(ast);
  marker.id = id;
  return marker;
};
function createMarkerSetter(markerType) {
  return function(value) {
    this.attr(markerType, "url(#" + value + ")");
  };
}
var markerMixin = {
  markerEndSetter: createMarkerSetter("marker-end"),
  markerStartSetter: createMarkerSetter("marker-start"),
  /**
   * Set markers.
   * @private
   * @param {Highcharts.AnnotationControllablePath} item
   */
  setItemMarkers: function(item) {
    var itemOptions = item.options, chart = item.chart, defs = chart.options.defs, fill = itemOptions.fill, color18 = defined39(fill) && fill !== "none" ? fill : itemOptions.stroke, setMarker = function(markerType) {
      var markerId = itemOptions[markerType], def, predefinedMarker, key, marker;
      if (markerId) {
        for (key in defs) {
          def = defs[key];
          if ((markerId === (def.attributes && def.attributes.id) || // Legacy, for
          // unit-tests/annotations/annotations-shapes
          markerId === def.id) && def.tagName === "marker") {
            predefinedMarker = def;
            break;
          }
        }
        if (predefinedMarker) {
          marker = item[markerType] = chart.renderer.addMarker((itemOptions.id || uniqueKey7()) + "-" + markerId, merge46(predefinedMarker, { color: color18 }));
          item.attr(markerType, marker.getAttribute("id"));
        }
      }
    };
    ["markerStart", "markerEnd"].forEach(setMarker);
  }
};
addEvent37(Chart_default, "afterGetContainer", function() {
  this.options.defs = merge46(defaultMarkers, this.options.defs || {});
});
var MarkerMixin_default = markerMixin;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllablePath.js
var extend47 = Utilities_default.extend;
var TRACKER_FILL = "rgba(192,192,192," + (Globals_default.svg ? 1e-4 : 2e-3) + ")";
var ControllablePath = (
  /** @class */
  function() {
    function ControllablePath2(annotation, options, index) {
      this.addControlPoints = ControllableMixin_default.addControlPoints;
      this.anchor = ControllableMixin_default.anchor;
      this.attr = ControllableMixin_default.attr;
      this.attrsFromOptions = ControllableMixin_default.attrsFromOptions;
      this.destroy = ControllableMixin_default.destroy;
      this.getPointsOptions = ControllableMixin_default.getPointsOptions;
      this.init = ControllableMixin_default.init;
      this.linkPoints = ControllableMixin_default.linkPoints;
      this.point = ControllableMixin_default.point;
      this.rotate = ControllableMixin_default.rotate;
      this.scale = ControllableMixin_default.scale;
      this.setControlPointsVisibility = ControllableMixin_default.setControlPointsVisibility;
      this.setMarkers = MarkerMixin_default.setItemMarkers;
      this.transform = ControllableMixin_default.transform;
      this.transformPoint = ControllableMixin_default.transformPoint;
      this.translate = ControllableMixin_default.translate;
      this.translatePoint = ControllableMixin_default.translatePoint;
      this.translateShape = ControllableMixin_default.translateShape;
      this.update = ControllableMixin_default.update;
      this.type = "path";
      this.init(annotation, options, index);
      this.collection = "shapes";
    }
    ControllablePath2.prototype.toD = function() {
      var dOption = this.options.d;
      if (dOption) {
        return typeof dOption === "function" ? dOption.call(this) : dOption;
      }
      var points = this.points, len = points.length, showPath = len, point = points[0], position = showPath && this.anchor(point).absolutePosition, pointIndex = 0, command, d = [];
      if (position) {
        d.push(["M", position.x, position.y]);
        while (++pointIndex < len && showPath) {
          point = points[pointIndex];
          command = point.command || "L";
          position = this.anchor(point).absolutePosition;
          if (command === "M") {
            d.push([command, position.x, position.y]);
          } else if (command === "L") {
            d.push([command, position.x, position.y]);
          } else if (command === "Z") {
            d.push([command]);
          }
          showPath = point.series.visible;
        }
      }
      return showPath ? this.chart.renderer.crispLine(d, this.graphic.strokeWidth()) : null;
    };
    ControllablePath2.prototype.shouldBeDrawn = function() {
      return ControllableMixin_default.shouldBeDrawn.call(this) || Boolean(this.options.d);
    };
    ControllablePath2.prototype.render = function(parent) {
      var options = this.options, attrs = this.attrsFromOptions(options);
      this.graphic = this.annotation.chart.renderer.path([["M", 0, 0]]).attr(attrs).add(parent);
      if (options.className) {
        this.graphic.addClass(options.className);
      }
      this.tracker = this.annotation.chart.renderer.path([["M", 0, 0]]).addClass("highcharts-tracker-line").attr({
        zIndex: 2
      }).add(parent);
      if (!this.annotation.chart.styledMode) {
        this.tracker.attr({
          "stroke-linejoin": "round",
          stroke: TRACKER_FILL,
          fill: TRACKER_FILL,
          "stroke-width": this.graphic.strokeWidth() + options.snap * 2
        });
      }
      ControllableMixin_default.render.call(this);
      extend47(this.graphic, {
        markerStartSetter: MarkerMixin_default.markerStartSetter,
        markerEndSetter: MarkerMixin_default.markerEndSetter
      });
      this.setMarkers(this);
    };
    ControllablePath2.prototype.redraw = function(animation) {
      var d = this.toD(), action = animation ? "animate" : "attr";
      if (d) {
        this.graphic[action]({ d });
        this.tracker[action]({ d });
      } else {
        this.graphic.attr({ d: "M 0 " + -9e9 });
        this.tracker.attr({ d: "M 0 " + -9e9 });
      }
      this.graphic.placed = this.tracker.placed = Boolean(d);
      ControllableMixin_default.redraw.call(this, animation);
    };
    ControllablePath2.attrsMap = {
      dashStyle: "dashstyle",
      strokeWidth: "stroke-width",
      stroke: "stroke",
      fill: "fill",
      zIndex: "zIndex"
    };
    return ControllablePath2;
  }()
);
var ControllablePath_default = ControllablePath;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableRect.js
var merge47 = Utilities_default.merge;
var ControllableRect = (
  /** @class */
  function() {
    function ControllableRect2(annotation, options, index) {
      this.addControlPoints = ControllableMixin_default.addControlPoints;
      this.anchor = ControllableMixin_default.anchor;
      this.attr = ControllableMixin_default.attr;
      this.attrsFromOptions = ControllableMixin_default.attrsFromOptions;
      this.destroy = ControllableMixin_default.destroy;
      this.getPointsOptions = ControllableMixin_default.getPointsOptions;
      this.init = ControllableMixin_default.init;
      this.linkPoints = ControllableMixin_default.linkPoints;
      this.point = ControllableMixin_default.point;
      this.rotate = ControllableMixin_default.rotate;
      this.scale = ControllableMixin_default.scale;
      this.setControlPointsVisibility = ControllableMixin_default.setControlPointsVisibility;
      this.shouldBeDrawn = ControllableMixin_default.shouldBeDrawn;
      this.transform = ControllableMixin_default.transform;
      this.transformPoint = ControllableMixin_default.transformPoint;
      this.translatePoint = ControllableMixin_default.translatePoint;
      this.translateShape = ControllableMixin_default.translateShape;
      this.update = ControllableMixin_default.update;
      this.type = "rect";
      this.translate = ControllableMixin_default.translateShape;
      this.init(annotation, options, index);
      this.collection = "shapes";
    }
    ControllableRect2.prototype.render = function(parent) {
      var attrs = this.attrsFromOptions(this.options);
      this.graphic = this.annotation.chart.renderer.rect(0, -9e9, 0, 0).attr(attrs).add(parent);
      ControllableMixin_default.render.call(this);
    };
    ControllableRect2.prototype.redraw = function(animation) {
      var position = this.anchor(this.points[0]).absolutePosition;
      if (position) {
        this.graphic[animation ? "animate" : "attr"]({
          x: position.x,
          y: position.y,
          width: this.options.width,
          height: this.options.height
        });
      } else {
        this.attr({
          x: 0,
          y: -9e9
        });
      }
      this.graphic.placed = Boolean(position);
      ControllableMixin_default.redraw.call(this, animation);
    };
    ControllableRect2.attrsMap = merge47(ControllablePath_default.attrsMap, {
      width: "width",
      height: "height"
    });
    return ControllableRect2;
  }()
);
var ControllableRect_default = ControllableRect;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableCircle.js
var merge48 = Utilities_default.merge;
var ControllableCircle = (
  /** @class */
  function() {
    function ControllableCircle2(annotation, options, index) {
      this.addControlPoints = ControllableMixin_default.addControlPoints;
      this.anchor = ControllableMixin_default.anchor;
      this.attr = ControllableMixin_default.attr;
      this.attrsFromOptions = ControllableMixin_default.attrsFromOptions;
      this.destroy = ControllableMixin_default.destroy;
      this.getPointsOptions = ControllableMixin_default.getPointsOptions;
      this.init = ControllableMixin_default.init;
      this.linkPoints = ControllableMixin_default.linkPoints;
      this.point = ControllableMixin_default.point;
      this.rotate = ControllableMixin_default.rotate;
      this.scale = ControllableMixin_default.scale;
      this.setControlPointsVisibility = ControllableMixin_default.setControlPointsVisibility;
      this.shouldBeDrawn = ControllableMixin_default.shouldBeDrawn;
      this.transform = ControllableMixin_default.transform;
      this.transformPoint = ControllableMixin_default.transformPoint;
      this.translatePoint = ControllableMixin_default.translatePoint;
      this.translateShape = ControllableMixin_default.translateShape;
      this.update = ControllableMixin_default.update;
      this.type = "circle";
      this.translate = ControllableMixin_default.translateShape;
      this.init(annotation, options, index);
      this.collection = "shapes";
    }
    ControllableCircle2.prototype.render = function(parent) {
      var attrs = this.attrsFromOptions(this.options);
      this.graphic = this.annotation.chart.renderer.circle(0, -9e9, 0).attr(attrs).add(parent);
      ControllableMixin_default.render.call(this);
    };
    ControllableCircle2.prototype.redraw = function(animation) {
      var position = this.anchor(this.points[0]).absolutePosition;
      if (position) {
        this.graphic[animation ? "animate" : "attr"]({
          x: position.x,
          y: position.y,
          r: this.options.r
        });
      } else {
        this.graphic.attr({
          x: 0,
          y: -9e9
        });
      }
      this.graphic.placed = Boolean(position);
      ControllableMixin_default.redraw.call(this, animation);
    };
    ControllableCircle2.prototype.setRadius = function(r) {
      this.options.r = r;
    };
    ControllableCircle2.attrsMap = merge48(ControllablePath_default.attrsMap, { r: "r" });
    return ControllableCircle2;
  }()
);
var ControllableCircle_default = ControllableCircle;

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableLabel.js
var format12 = FormatUtilities_default.format;
var symbols2 = SVGRenderer_default.prototype.symbols;
var extend48 = Utilities_default.extend;
var isNumber34 = Utilities_default.isNumber;
var pick55 = Utilities_default.pick;
var ControllableLabel = (
  /** @class */
  function() {
    function ControllableLabel2(annotation, options, index) {
      this.addControlPoints = ControllableMixin_default.addControlPoints;
      this.attr = ControllableMixin_default.attr;
      this.attrsFromOptions = ControllableMixin_default.attrsFromOptions;
      this.destroy = ControllableMixin_default.destroy;
      this.getPointsOptions = ControllableMixin_default.getPointsOptions;
      this.init = ControllableMixin_default.init;
      this.linkPoints = ControllableMixin_default.linkPoints;
      this.point = ControllableMixin_default.point;
      this.rotate = ControllableMixin_default.rotate;
      this.scale = ControllableMixin_default.scale;
      this.setControlPointsVisibility = ControllableMixin_default.setControlPointsVisibility;
      this.shouldBeDrawn = ControllableMixin_default.shouldBeDrawn;
      this.transform = ControllableMixin_default.transform;
      this.transformPoint = ControllableMixin_default.transformPoint;
      this.translateShape = ControllableMixin_default.translateShape;
      this.update = ControllableMixin_default.update;
      this.init(annotation, options, index);
      this.collection = "labels";
    }
    ControllableLabel2.alignedPosition = function(alignOptions, box) {
      var align = alignOptions.align, vAlign = alignOptions.verticalAlign;
      var x = (box.x || 0) + (alignOptions.x || 0), y = (box.y || 0) + (alignOptions.y || 0), alignFactor, vAlignFactor;
      if (align === "right") {
        alignFactor = 1;
      } else if (align === "center") {
        alignFactor = 2;
      }
      if (alignFactor) {
        x += (box.width - (alignOptions.width || 0)) / alignFactor;
      }
      if (vAlign === "bottom") {
        vAlignFactor = 1;
      } else if (vAlign === "middle") {
        vAlignFactor = 2;
      }
      if (vAlignFactor) {
        y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
      }
      return {
        x: Math.round(x),
        y: Math.round(y)
      };
    };
    ControllableLabel2.justifiedOptions = function(chart, label, alignOptions, alignAttr) {
      var align = alignOptions.align, verticalAlign = alignOptions.verticalAlign, padding = label.box ? 0 : label.padding || 0, bBox = label.getBBox(), options = {
        align,
        verticalAlign,
        x: alignOptions.x,
        y: alignOptions.y,
        width: label.width,
        height: label.height
      }, x = (alignAttr.x || 0) - chart.plotLeft, y = (alignAttr.y || 0) - chart.plotTop;
      var off;
      off = x + padding;
      if (off < 0) {
        if (align === "right") {
          options.align = "left";
        } else {
          options.x = (options.x || 0) - off;
        }
      }
      off = x + bBox.width - padding;
      if (off > chart.plotWidth) {
        if (align === "left") {
          options.align = "right";
        } else {
          options.x = (options.x || 0) + chart.plotWidth - off;
        }
      }
      off = y + padding;
      if (off < 0) {
        if (verticalAlign === "bottom") {
          options.verticalAlign = "top";
        } else {
          options.y = (options.y || 0) - off;
        }
      }
      off = y + bBox.height - padding;
      if (off > chart.plotHeight) {
        if (verticalAlign === "top") {
          options.verticalAlign = "bottom";
        } else {
          options.y = (options.y || 0) + chart.plotHeight - off;
        }
      }
      return options;
    };
    ControllableLabel2.prototype.translatePoint = function(dx, dy) {
      ControllableMixin_default.translatePoint.call(this, dx, dy, 0);
    };
    ControllableLabel2.prototype.translate = function(dx, dy) {
      var chart = this.annotation.chart, labelOptions = this.annotation.userOptions, annotationIndex = chart.annotations.indexOf(this.annotation), chartAnnotations = chart.options.annotations, chartOptions = chartAnnotations[annotationIndex];
      if (chart.inverted) {
        var temp = dx;
        dx = dy;
        dy = temp;
      }
      this.options.x += dx;
      this.options.y += dy;
      chartOptions[this.collection][this.index].x = this.options.x;
      chartOptions[this.collection][this.index].y = this.options.y;
      labelOptions[this.collection][this.index].x = this.options.x;
      labelOptions[this.collection][this.index].y = this.options.y;
    };
    ControllableLabel2.prototype.render = function(parent) {
      var options = this.options, attrs = this.attrsFromOptions(options), style = options.style;
      this.graphic = this.annotation.chart.renderer.label(
        "",
        0,
        -9999,
        // #10055
        options.shape,
        null,
        null,
        options.useHTML,
        null,
        "annotation-label"
      ).attr(attrs).add(parent);
      if (!this.annotation.chart.styledMode) {
        if (style.color === "contrast") {
          style.color = this.annotation.chart.renderer.getContrast(ControllableLabel2.shapesWithoutBackground.indexOf(options.shape) > -1 ? "#FFFFFF" : options.backgroundColor);
        }
        this.graphic.css(options.style).shadow(options.shadow);
      }
      if (options.className) {
        this.graphic.addClass(options.className);
      }
      this.graphic.labelrank = options.labelrank;
      ControllableMixin_default.render.call(this);
    };
    ControllableLabel2.prototype.redraw = function(animation) {
      var options = this.options, text = this.text || options.format || options.text, label = this.graphic, point = this.points[0];
      label.attr({
        text: text ? format12(text, point.getLabelConfig(), this.annotation.chart) : options.formatter.call(point, this)
      });
      var anchor = this.anchor(point);
      var attrs = this.position(anchor);
      if (attrs) {
        label.alignAttr = attrs;
        attrs.anchorX = anchor.absolutePosition.x;
        attrs.anchorY = anchor.absolutePosition.y;
        label[animation ? "animate" : "attr"](attrs);
      } else {
        label.attr({
          x: 0,
          y: -9999
          // #10055
        });
      }
      label.placed = !!attrs;
      ControllableMixin_default.redraw.call(this, animation);
    };
    ControllableLabel2.prototype.anchor = function(_point) {
      var anchor = ControllableMixin_default.anchor.apply(this, arguments), x = this.options.x || 0, y = this.options.y || 0;
      anchor.absolutePosition.x -= x;
      anchor.absolutePosition.y -= y;
      anchor.relativePosition.x -= x;
      anchor.relativePosition.y -= y;
      return anchor;
    };
    ControllableLabel2.prototype.position = function(anchor) {
      var item = this.graphic, chart = this.annotation.chart, point = this.points[0], itemOptions = this.options, anchorAbsolutePosition = anchor.absolutePosition, anchorRelativePosition = anchor.relativePosition;
      var itemPosition, alignTo, itemPosRelativeX, itemPosRelativeY, showItem = point.series.visible && MockPoint_default.prototype.isInsidePlot.call(point);
      var _a15 = item.width, width = _a15 === void 0 ? 0 : _a15, _b = item.height, height = _b === void 0 ? 0 : _b;
      if (showItem) {
        if (itemOptions.distance) {
          itemPosition = Tooltip_default.prototype.getPosition.call({
            chart,
            distance: pick55(itemOptions.distance, 16)
          }, width, height, {
            plotX: anchorRelativePosition.x,
            plotY: anchorRelativePosition.y,
            negative: point.negative,
            ttBelow: point.ttBelow,
            h: anchorRelativePosition.height || anchorRelativePosition.width
          });
        } else if (itemOptions.positioner) {
          itemPosition = itemOptions.positioner.call(this);
        } else {
          alignTo = {
            x: anchorAbsolutePosition.x,
            y: anchorAbsolutePosition.y,
            width: 0,
            height: 0
          };
          itemPosition = ControllableLabel2.alignedPosition(extend48(itemOptions, {
            width,
            height
          }), alignTo);
          if (this.options.overflow === "justify") {
            itemPosition = ControllableLabel2.alignedPosition(ControllableLabel2.justifiedOptions(chart, item, itemOptions, itemPosition), alignTo);
          }
        }
        if (itemOptions.crop) {
          itemPosRelativeX = itemPosition.x - chart.plotLeft;
          itemPosRelativeY = itemPosition.y - chart.plotTop;
          showItem = chart.isInsidePlot(itemPosRelativeX, itemPosRelativeY) && chart.isInsidePlot(itemPosRelativeX + width, itemPosRelativeY + height);
        }
      }
      return showItem ? itemPosition : null;
    };
    ControllableLabel2.attrsMap = {
      backgroundColor: "fill",
      borderColor: "stroke",
      borderWidth: "stroke-width",
      zIndex: "zIndex",
      borderRadius: "r",
      padding: "padding"
    };
    ControllableLabel2.shapesWithoutBackground = ["connector"];
    return ControllableLabel2;
  }()
);
var ControllableLabel_default = ControllableLabel;
symbols2.connector = function(x, y, w2, h, options) {
  var anchorX = options && options.anchorX, anchorY = options && options.anchorY;
  var path, yOffset, lateral = w2 / 2;
  if (isNumber34(anchorX) && isNumber34(anchorY)) {
    path = [["M", anchorX, anchorY]];
    yOffset = y - anchorY;
    if (yOffset < 0) {
      yOffset = -h - yOffset;
    }
    if (yOffset < w2) {
      lateral = anchorX < x + w2 / 2 ? yOffset : w2 - yOffset;
    }
    if (anchorY > y + h) {
      path.push(["L", x + lateral, y + h]);
    } else if (anchorY < y) {
      path.push(["L", x + lateral, y]);
    } else if (anchorX < x) {
      path.push(["L", x, y + h / 2]);
    } else if (anchorX > x + w2) {
      path.push(["L", x + w2, y + h / 2]);
    }
  }
  return path || [];
};

// node_modules/highcharts/es-modules/Extensions/Annotations/Controllables/ControllableImage.js
var ControllableImage = (
  /** @class */
  function() {
    function ControllableImage2(annotation, options, index) {
      this.addControlPoints = ControllableMixin_default.addControlPoints;
      this.anchor = ControllableMixin_default.anchor;
      this.attr = ControllableMixin_default.attr;
      this.attrsFromOptions = ControllableMixin_default.attrsFromOptions;
      this.destroy = ControllableMixin_default.destroy;
      this.getPointsOptions = ControllableMixin_default.getPointsOptions;
      this.init = ControllableMixin_default.init;
      this.linkPoints = ControllableMixin_default.linkPoints;
      this.point = ControllableMixin_default.point;
      this.rotate = ControllableMixin_default.rotate;
      this.scale = ControllableMixin_default.scale;
      this.setControlPointsVisibility = ControllableMixin_default.setControlPointsVisibility;
      this.shouldBeDrawn = ControllableMixin_default.shouldBeDrawn;
      this.transform = ControllableMixin_default.transform;
      this.transformPoint = ControllableMixin_default.transformPoint;
      this.translatePoint = ControllableMixin_default.translatePoint;
      this.translateShape = ControllableMixin_default.translateShape;
      this.update = ControllableMixin_default.update;
      this.type = "image";
      this.translate = ControllableMixin_default.translateShape;
      this.init(annotation, options, index);
      this.collection = "shapes";
    }
    ControllableImage2.prototype.render = function(parent) {
      var attrs = this.attrsFromOptions(this.options), options = this.options;
      this.graphic = this.annotation.chart.renderer.image(options.src, 0, -9e9, options.width, options.height).attr(attrs).add(parent);
      this.graphic.width = options.width;
      this.graphic.height = options.height;
      ControllableMixin_default.render.call(this);
    };
    ControllableImage2.prototype.redraw = function(animation) {
      var anchor = this.anchor(this.points[0]), position = ControllableLabel_default.prototype.position.call(this, anchor);
      if (position) {
        this.graphic[animation ? "animate" : "attr"]({
          x: position.x,
          y: position.y
        });
      } else {
        this.graphic.attr({
          x: 0,
          y: -9e9
        });
      }
      this.graphic.placed = Boolean(position);
      ControllableMixin_default.redraw.call(this, animation);
    };
    ControllableImage2.attrsMap = {
      width: "width",
      height: "height",
      zIndex: "zIndex"
    };
    return ControllableImage2;
  }()
);
var ControllableImage_default = ControllableImage;

// node_modules/highcharts/es-modules/Extensions/Annotations/Annotations.js
var getDeferredAnimation4 = AnimationUtilities_default.getDeferredAnimation;
var chartProto = Chart_default.prototype;
var addEvent38 = Utilities_default.addEvent;
var defined40 = Utilities_default.defined;
var destroyObjectProperties11 = Utilities_default.destroyObjectProperties;
var erase10 = Utilities_default.erase;
var extend49 = Utilities_default.extend;
var find15 = Utilities_default.find;
var fireEvent28 = Utilities_default.fireEvent;
var merge49 = Utilities_default.merge;
var pick56 = Utilities_default.pick;
var splat15 = Utilities_default.splat;
var wrap4 = Utilities_default.wrap;
var Annotation = (
  /** @class */
  function() {
    function Annotation2(chart, userOptions) {
      this.annotation = void 0;
      this.coll = "annotations";
      this.collection = void 0;
      this.animationConfig = void 0;
      this.graphic = void 0;
      this.group = void 0;
      this.labelCollector = void 0;
      this.labelsGroup = void 0;
      this.shapesGroup = void 0;
      var labelsAndShapes;
      this.chart = chart;
      this.points = [];
      this.controlPoints = [];
      this.coll = "annotations";
      this.labels = [];
      this.shapes = [];
      this.options = merge49(this.defaultOptions, userOptions);
      this.userOptions = userOptions;
      labelsAndShapes = this.getLabelsAndShapesOptions(this.options, userOptions);
      this.options.labels = labelsAndShapes.labels;
      this.options.shapes = labelsAndShapes.shapes;
      this.init(chart, this.options);
    }
    Annotation2.prototype.init = function() {
      var chart = this.chart, animOptions = this.options.animation;
      this.linkPoints();
      this.addControlPoints();
      this.addShapes();
      this.addLabels();
      this.setLabelCollector();
      this.animationConfig = getDeferredAnimation4(chart, animOptions);
    };
    Annotation2.prototype.getLabelsAndShapesOptions = function(baseOptions, newOptions) {
      var mergedOptions = {};
      ["labels", "shapes"].forEach(function(name) {
        if (baseOptions[name]) {
          if (newOptions[name]) {
            mergedOptions[name] = splat15(newOptions[name]).map(function(basicOptions, i) {
              return merge49(baseOptions[name][i], basicOptions);
            });
          } else {
            mergedOptions[name] = baseOptions[name];
          }
        }
      });
      return mergedOptions;
    };
    Annotation2.prototype.addShapes = function() {
      (this.options.shapes || []).forEach(function(shapeOptions, i) {
        var shape = this.initShape(shapeOptions, i);
        merge49(true, this.options.shapes[i], shape.options);
      }, this);
    };
    Annotation2.prototype.addLabels = function() {
      (this.options.labels || []).forEach(function(labelsOptions, i) {
        var labels = this.initLabel(labelsOptions, i);
        merge49(true, this.options.labels[i], labels.options);
      }, this);
    };
    Annotation2.prototype.addClipPaths = function() {
      this.setClipAxes();
      if (this.clipXAxis && this.clipYAxis) {
        this.clipRect = this.chart.renderer.clipRect(this.getClipBox());
      }
    };
    Annotation2.prototype.setClipAxes = function() {
      var xAxes = this.chart.xAxis, yAxes = this.chart.yAxis, linkedAxes = (this.options.labels || []).concat(this.options.shapes || []).reduce(function(axes, labelOrShape) {
        var point = labelOrShape && (labelOrShape.point || labelOrShape.points && labelOrShape.points[0]);
        return [
          xAxes[point && point.xAxis] || axes[0],
          yAxes[point && point.yAxis] || axes[1]
        ];
      }, []);
      this.clipXAxis = linkedAxes[0];
      this.clipYAxis = linkedAxes[1];
    };
    Annotation2.prototype.getClipBox = function() {
      if (this.clipXAxis && this.clipYAxis) {
        return {
          x: this.clipXAxis.left,
          y: this.clipYAxis.top,
          width: this.clipXAxis.width,
          height: this.clipYAxis.height
        };
      }
    };
    Annotation2.prototype.setLabelCollector = function() {
      var annotation = this;
      annotation.labelCollector = function() {
        return annotation.labels.reduce(function(labels, label) {
          if (!label.options.allowOverlap) {
            labels.push(label.graphic);
          }
          return labels;
        }, []);
      };
      annotation.chart.labelCollectors.push(annotation.labelCollector);
    };
    Annotation2.prototype.setOptions = function(userOptions) {
      this.options = merge49(this.defaultOptions, userOptions);
    };
    Annotation2.prototype.redraw = function(animation) {
      this.linkPoints();
      if (!this.graphic) {
        this.render();
      }
      if (this.clipRect) {
        this.clipRect.animate(this.getClipBox());
      }
      this.redrawItems(this.shapes, animation);
      this.redrawItems(this.labels, animation);
      ControllableMixin_default.redraw.call(this, animation);
    };
    Annotation2.prototype.redrawItems = function(items, animation) {
      var i = items.length;
      while (i--) {
        this.redrawItem(items[i], animation);
      }
    };
    Annotation2.prototype.renderItems = function(items) {
      var i = items.length;
      while (i--) {
        this.renderItem(items[i]);
      }
    };
    Annotation2.prototype.render = function() {
      var renderer = this.chart.renderer;
      this.graphic = renderer.g("annotation").attr({
        opacity: 0,
        zIndex: this.options.zIndex,
        visibility: this.options.visible ? "visible" : "hidden"
      }).add();
      this.shapesGroup = renderer.g("annotation-shapes").add(this.graphic).clip(this.chart.plotBoxClip);
      this.labelsGroup = renderer.g("annotation-labels").attr({
        // hideOverlappingLabels requires translation
        translateX: 0,
        translateY: 0
      }).add(this.graphic);
      this.addClipPaths();
      if (this.clipRect) {
        this.graphic.clip(this.clipRect);
      }
      this.renderItems(this.shapes);
      this.renderItems(this.labels);
      this.addEvents();
      ControllableMixin_default.render.call(this);
    };
    Annotation2.prototype.setVisibility = function(visible) {
      var options = this.options, navigation2 = this.chart.navigationBindings, visibility = pick56(visible, !options.visible);
      this.graphic.attr("visibility", visibility ? "visible" : "hidden");
      if (!visibility) {
        this.setControlPointsVisibility(false);
        if (navigation2.activeAnnotation === this && navigation2.popup && navigation2.popup.formType === "annotation-toolbar") {
          fireEvent28(navigation2, "closePopup");
        }
      }
      options.visible = visibility;
    };
    Annotation2.prototype.setControlPointsVisibility = function(visible) {
      var setItemControlPointsVisibility = function(item) {
        item.setControlPointsVisibility(visible);
      };
      ControllableMixin_default.setControlPointsVisibility.call(this, visible);
      this.shapes.forEach(setItemControlPointsVisibility);
      this.labels.forEach(setItemControlPointsVisibility);
    };
    Annotation2.prototype.destroy = function() {
      var chart = this.chart, destroyItem = function(item) {
        item.destroy();
      };
      this.labels.forEach(destroyItem);
      this.shapes.forEach(destroyItem);
      this.clipXAxis = null;
      this.clipYAxis = null;
      erase10(chart.labelCollectors, this.labelCollector);
      EventEmitterMixin_default.destroy.call(this);
      ControllableMixin_default.destroy.call(this);
      destroyObjectProperties11(this, chart);
    };
    Annotation2.prototype.remove = function() {
      return this.chart.removeAnnotation(this);
    };
    Annotation2.prototype.update = function(userOptions, redraw) {
      var chart = this.chart, labelsAndShapes = this.getLabelsAndShapesOptions(this.userOptions, userOptions), userOptionsIndex = chart.annotations.indexOf(this), options = merge49(true, this.userOptions, userOptions);
      options.labels = labelsAndShapes.labels;
      options.shapes = labelsAndShapes.shapes;
      this.destroy();
      this.constructor(chart, options);
      chart.options.annotations[userOptionsIndex] = options;
      this.isUpdating = true;
      if (pick56(redraw, true)) {
        chart.redraw();
      }
      fireEvent28(this, "afterUpdate");
      this.isUpdating = false;
    };
    Annotation2.prototype.initShape = function(shapeOptions, index) {
      var options = merge49(this.options.shapeOptions, {
        controlPointOptions: this.options.controlPointOptions
      }, shapeOptions), shape = new Annotation2.shapesMap[options.type](this, options, index);
      shape.itemType = "shape";
      this.shapes.push(shape);
      return shape;
    };
    Annotation2.prototype.initLabel = function(labelOptions, index) {
      var options = merge49(this.options.labelOptions, {
        controlPointOptions: this.options.controlPointOptions
      }, labelOptions), label = new ControllableLabel_default(this, options, index);
      label.itemType = "label";
      this.labels.push(label);
      return label;
    };
    Annotation2.prototype.redrawItem = function(item, animation) {
      item.linkPoints();
      if (!item.shouldBeDrawn()) {
        this.destroyItem(item);
      } else {
        if (!item.graphic) {
          this.renderItem(item);
        }
        item.redraw(pick56(animation, true) && item.graphic.placed);
        if (item.points.length) {
          this.adjustVisibility(item);
        }
      }
    };
    Annotation2.prototype.adjustVisibility = function(item) {
      var hasVisiblePoints = false, label = item.graphic;
      item.points.forEach(function(point) {
        if (point.series.visible !== false && point.visible !== false) {
          hasVisiblePoints = true;
        }
      });
      if (!hasVisiblePoints) {
        label.hide();
      } else if (label.visibility === "hidden") {
        label.show();
      }
    };
    Annotation2.prototype.destroyItem = function(item) {
      erase10(this[item.itemType + "s"], item);
      item.destroy();
    };
    Annotation2.prototype.renderItem = function(item) {
      item.render(item.itemType === "label" ? this.labelsGroup : this.shapesGroup);
    };
    Annotation2.ControlPoint = ControlPoint_default;
    Annotation2.MockPoint = MockPoint_default;
    Annotation2.shapesMap = {
      "rect": ControllableRect_default,
      "circle": ControllableCircle_default,
      "path": ControllablePath_default,
      "image": ControllableImage_default
    };
    Annotation2.types = {};
    return Annotation2;
  }()
);
merge49(
  true,
  Annotation.prototype,
  ControllableMixin_default,
  EventEmitterMixin_default,
  // restore original Annotation implementation after mixin overwrite
  merge49(
    Annotation.prototype,
    /** @lends Highcharts.Annotation# */
    {
      /**
       * List of events for `annotation.options.events` that should not be
       * added to `annotation.graphic` but to the `annotation`.
       *
       * @private
       * @type {Array<string>}
       */
      nonDOMEvents: ["add", "afterUpdate", "drag", "remove"],
      /**
       * A basic type of an annotation. It allows to add custom labels
       * or shapes. The items  can be tied to points, axis coordinates
       * or chart pixel coordinates.
       *
       * @sample highcharts/annotations/basic/
       *         Basic annotations
       * @sample highcharts/demo/annotations/
       *         Advanced annotations
       * @sample highcharts/css/annotations
       *         Styled mode
       * @sample highcharts/annotations-advanced/controllable
       *         Controllable items
       * @sample {highstock} stock/annotations/fibonacci-retracements
       *         Custom annotation, Fibonacci retracement
       *
       * @type         {Array<*>}
       * @since        6.0.0
       * @requires     modules/annotations
       * @optionparent annotations
       *
       * @private
       */
      defaultOptions: {
        /**
         * Sets an ID for an annotation. Can be user later when
         * removing an annotation in [Chart#removeAnnotation(id)](
         * /class-reference/Highcharts.Chart#removeAnnotation) method.
         *
         * @type      {number|string}
         * @apioption annotations.id
         */
        /**
         * Whether the annotation is visible.
         *
         * @sample highcharts/annotations/visible/
         *         Set annotation visibility
         */
        visible: true,
        /**
         * Enable or disable the initial animation when a series is
         * displayed for the `annotation`. The animation can also be set
         * as a configuration object. Please note that this option only
         * applies to the initial animation.
         * For other animations, see [chart.animation](#chart.animation)
         * and the animation parameter under the API methods.
         * The following properties are supported:
         *
         * - `defer`: The animation delay time in milliseconds.
         *
         * @sample {highcharts} highcharts/annotations/defer/
         *          Animation defer settings
         * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
         * @since 8.2.0
         * @apioption annotations.animation
         */
        animation: {},
        /**
         * The animation delay time in milliseconds.
         * Set to `0` renders annotation immediately.
         * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
         *
         * @type      {number}
         * @since 8.2.0
         * @apioption annotations.animation.defer
         */
        /**
         * Allow an annotation to be draggable by a user. Possible
         * values are `'x'`, `'xy'`, `'y'` and `''` (disabled).
         *
         * @sample highcharts/annotations/draggable/
         *         Annotations draggable: 'xy'
         *
         * @type {Highcharts.AnnotationDraggableValue}
         */
        draggable: "xy",
        /**
         * Options for annotation's labels. Each label inherits options
         * from the labelOptions object. An option from the labelOptions
         * can be overwritten by config for a specific label.
         *
         * @requires modules/annotations
         */
        labelOptions: {
          /**
           * The alignment of the annotation's label. If right,
           * the right side of the label should be touching the point.
           *
           * @sample highcharts/annotations/label-position/
           *         Set labels position
           *
           * @type {Highcharts.AlignValue}
           */
          align: "center",
          /**
           * Whether to allow the annotation's labels to overlap.
           * To make the labels less sensitive for overlapping,
           * the can be set to 0.
           *
           * @sample highcharts/annotations/tooltip-like/
           *         Hide overlapping labels
           */
          allowOverlap: false,
          /**
           * The background color or gradient for the annotation's
           * label.
           *
           * @sample highcharts/annotations/label-presentation/
           *         Set labels graphic options
           *
           * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           */
          backgroundColor: "rgba(0, 0, 0, 0.75)",
          /**
           * The border color for the annotation's label.
           *
           * @sample highcharts/annotations/label-presentation/
           *         Set labels graphic options
           *
           * @type {Highcharts.ColorString}
           */
          borderColor: Palette_default.neutralColor100,
          /**
           * The border radius in pixels for the annotaiton's label.
           *
           * @sample highcharts/annotations/label-presentation/
           *         Set labels graphic options
           */
          borderRadius: 3,
          /**
           * The border width in pixels for the annotation's label
           *
           * @sample highcharts/annotations/label-presentation/
           *         Set labels graphic options
           */
          borderWidth: 1,
          /**
           * A class name for styling by CSS.
           *
           * @sample highcharts/css/annotations
           *         Styled mode annotations
           *
           * @since 6.0.5
           */
          className: "highcharts-no-tooltip",
          /**
           * Whether to hide the annotation's label
           * that is outside the plot area.
           *
           * @sample highcharts/annotations/label-crop-overflow/
           *         Crop or justify labels
           */
          crop: false,
          /**
           * The label's pixel distance from the point.
           *
           * @sample highcharts/annotations/label-position/
           *         Set labels position
           *
           * @type      {number}
           * @apioption annotations.labelOptions.distance
           */
          /**
           * A
           * [format](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
           * string for the data label.
           *
           * @see [plotOptions.series.dataLabels.format](plotOptions.series.dataLabels.format.html)
           *
           * @sample highcharts/annotations/label-text/
           *         Set labels text
           *
           * @type      {string}
           * @apioption annotations.labelOptions.format
           */
          /**
           * Alias for the format option.
           *
           * @see [format](annotations.labelOptions.format.html)
           *
           * @sample highcharts/annotations/label-text/
           *         Set labels text
           *
           * @type      {string}
           * @apioption annotations.labelOptions.text
           */
          /**
           * Callback JavaScript function to format the annotation's
           * label. Note that if a `format` or `text` are defined,
           * the format or text take precedence and the formatter is
           * ignored. `This` refers to a point object.
           *
           * @sample highcharts/annotations/label-text/
           *         Set labels text
           *
           * @type    {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
           * @default function () { return defined(this.y) ? this.y : 'Annotation label'; }
           */
          formatter: function() {
            return defined40(this.y) ? this.y : "Annotation label";
          },
          /**
           * Whether the annotation is visible in the exported data
           * table.
           *
           * @sample highcharts/annotations/include-in-data-export/
           *         Do not include in the data export
           *
           * @since 8.2.0
           * @requires modules/export-data
           */
          includeInDataExport: true,
          /**
           * How to handle the annotation's label that flow outside
           * the plot area. The justify option aligns the label inside
           * the plot area.
           *
           * @sample highcharts/annotations/label-crop-overflow/
           *         Crop or justify labels
           *
           * @validvalue ["allow", "justify"]
           */
          overflow: "justify",
          /**
           * When either the borderWidth or the backgroundColor is
           * set, this is the padding within the box.
           *
           * @sample highcharts/annotations/label-presentation/
           *         Set labels graphic options
           */
          padding: 5,
          /**
           * The shadow of the box. The shadow can be an object
           * configuration containing `color`, `offsetX`, `offsetY`,
           * `opacity` and `width`.
           *
           * @sample highcharts/annotations/label-presentation/
           *         Set labels graphic options
           *
           * @type {boolean|Highcharts.ShadowOptionsObject}
           */
          shadow: false,
          /**
           * The name of a symbol to use for the border around the
           * label. Symbols are predefined functions on the Renderer
           * object.
           *
           * @sample highcharts/annotations/shapes/
           *         Available shapes for labels
           */
          shape: "callout",
          /**
           * Styles for the annotation's label.
           *
           * @see [plotOptions.series.dataLabels.style](plotOptions.series.dataLabels.style.html)
           *
           * @sample highcharts/annotations/label-presentation/
           *         Set labels graphic options
           *
           * @type {Highcharts.CSSObject}
           */
          style: {
            /** @ignore */
            fontSize: "11px",
            /** @ignore */
            fontWeight: "normal",
            /** @ignore */
            color: "contrast"
          },
          /**
           * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
           * to render the annotation's label.
           */
          useHTML: false,
          /**
           * The vertical alignment of the annotation's label.
           *
           * @sample highcharts/annotations/label-position/
           *         Set labels position
           *
           * @type {Highcharts.VerticalAlignValue}
           */
          verticalAlign: "bottom",
          /**
           * The x position offset of the label relative to the point.
           * Note that if a `distance` is defined, the distance takes
           * precedence over `x` and `y` options.
           *
           * @sample highcharts/annotations/label-position/
           *         Set labels position
           */
          x: 0,
          /**
           * The y position offset of the label relative to the point.
           * Note that if a `distance` is defined, the distance takes
           * precedence over `x` and `y` options.
           *
           * @sample highcharts/annotations/label-position/
           *         Set labels position
           */
          y: -16
        },
        /**
         * An array of labels for the annotation. For options that apply
         * to multiple labels, they can be added to the
         * [labelOptions](annotations.labelOptions.html).
         *
         * @type      {Array<*>}
         * @extends   annotations.labelOptions
         * @apioption annotations.labels
         */
        /**
         * This option defines the point to which the label will be
         * connected. It can be either the point which exists in the
         * series - it is referenced by the point's id - or a new point
         * with defined x, y properties and optionally axes.
         *
         * @sample highcharts/annotations/mock-point/
         *         Attach annotation to a mock point
         * @sample highcharts/annotations/mock-points/
         *         Attach annotation to a mock point with different ways
         *
         * @declare   Highcharts.AnnotationMockPointOptionsObject
         * @type      {
         *               string|
         *               Highcharts.AnnotationMockPointOptionsObject|
         *               Highcharts.AnnotationMockPointFunction
         *            }
         * @requires  modules/annotations
         * @apioption annotations.labels.point
         */
        /**
         * An array of shapes for the annotation. For options that apply
         * to multiple shapes, then can be added to the
         * [shapeOptions](annotations.shapeOptions.html).
         *
         * @type      {Array<*>}
         * @extends   annotations.shapeOptions
         * @apioption annotations.shapes
         */
        /**
         * This option defines the point to which the shape will be
         * connected. It can be either the point which exists in the
         * series - it is referenced by the point's id - or a new point
         * with defined x, y properties and optionally axes.
         *
         * @sample highcharts/annotations/mock-points/
         *         Attach annotation to a mock point with different ways
         *
         * @declare   Highcharts.AnnotationMockPointOptionsObject
         * @type      {
         *               string|
         *               Highcharts.AnnotationMockPointOptionsObject|
         *               Highcharts.AnnotationMockPointFunction
         *            }
         * @extends   annotations.labels.point
         * @requires  modules/annotations
         * @apioption annotations.shapes.point
         */
        /**
         * An array of points for the shape
         * or a callback function that returns that shape point.
         *
         * This option is available
         * for shapes which can use multiple points such as path. A
         * point can be either a point object or a point's id.
         *
         * @see [annotations.shapes.point](annotations.shapes.point.html)
         *
         * @type      {Array<Highcharts.AnnotationShapePointOptions>}
         * @extends   annotations.labels.point
         * @apioption annotations.shapes.points
         */
        /**
         * The URL for an image to use as the annotation shape. Note,
         * type has to be set to `'image'`.
         *
         * @see [annotations.shapes.type](annotations.shapes.type)
         * @sample highcharts/annotations/shape-src/
         *         Define a marker image url for annotations
         *
         * @type      {string}
         * @apioption annotations.shapes.src
         */
        /**
         * Id of the marker which will be drawn at the final vertex of
         * the path. Custom markers can be defined in defs property.
         *
         * @see [defs.markers](defs.markers.html)
         *
         * @sample highcharts/annotations/custom-markers/
         *         Define a custom marker for annotations
         *
         * @type      {string}
         * @apioption annotations.shapes.markerEnd
         */
        /**
         * Id of the marker which will be drawn at the first vertex of
         * the path. Custom markers can be defined in defs property.
         *
         * @see [defs.markers](defs.markers.html)
         *
         * @sample {highcharts} highcharts/annotations/custom-markers/
         *         Define a custom marker for annotations
         *
         * @type      {string}
         * @apioption annotations.shapes.markerStart
         */
        /**
         * Options for annotation's shapes. Each shape inherits options
         * from the shapeOptions object. An option from the shapeOptions
         * can be overwritten by config for a specific shape.
         *
         * @requires  modules/annotations
         */
        shapeOptions: {
          /**
           * The width of the shape.
           *
           * @sample highcharts/annotations/shape/
           *         Basic shape annotation
           *
           * @type      {number}
           * @apioption annotations.shapeOptions.width
           **/
          /**
           * The height of the shape.
           *
           * @sample highcharts/annotations/shape/
           *         Basic shape annotation
           *
           * @type      {number}
           * @apioption annotations.shapeOptions.height
           */
          /**
           * The type of the shape, e.g. circle or rectangle.
           *
           * @sample highcharts/annotations/shape/
           *         Basic shape annotation
           *
           * @type      {string}
           * @default   rect
           * @apioption annotations.shapeOptions.type
           */
          /**
           * The URL for an image to use as the annotation shape.
           * Note, type has to be set to `'image'`.
           *
           * @see [annotations.shapeOptions.type](annotations.shapeOptions.type)
           * @sample highcharts/annotations/shape-src/
           *         Define a marker image url for annotations
           *
           * @type      {string}
           * @apioption annotations.shapeOptions.src
           */
          /**
           * Name of the dash style to use for the shape's stroke.
           *
           * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
           *         Possible values demonstrated
           *
           * @type      {Highcharts.DashStyleValue}
           * @apioption annotations.shapeOptions.dashStyle
           */
          /**
           * The color of the shape's stroke.
           *
           * @sample highcharts/annotations/shape/
           *         Basic shape annotation
           *
           * @type {Highcharts.ColorString}
           */
          stroke: "rgba(0, 0, 0, 0.75)",
          /**
           * The pixel stroke width of the shape.
           *
           * @sample highcharts/annotations/shape/
           *         Basic shape annotation
           */
          strokeWidth: 1,
          /**
           * The color of the shape's fill.
           *
           * @sample highcharts/annotations/shape/
           *         Basic shape annotation
           *
           * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           */
          fill: "rgba(0, 0, 0, 0.75)",
          /**
           * The radius of the shape.
           *
           * @sample highcharts/annotations/shape/
           *         Basic shape annotation
           */
          r: 0,
          /**
           * Defines additional snapping area around an annotation
           * making this annotation to focus. Defined in pixels.
           */
          snap: 2
        },
        /**
         * Options for annotation's control points. Each control point
         * inherits options from controlPointOptions object.
         * Options from the controlPointOptions can be overwritten
         * by options in a specific control point.
         *
         * @declare   Highcharts.AnnotationControlPointOptionsObject
         * @requires  modules/annotations
         * @apioption annotations.controlPointOptions
         */
        controlPointOptions: {
          /**
           * @type      {Highcharts.AnnotationControlPointPositionerFunction}
           * @apioption annotations.controlPointOptions.positioner
           */
          symbol: "circle",
          width: 10,
          height: 10,
          style: {
            stroke: Palette_default.neutralColor100,
            "stroke-width": 2,
            fill: Palette_default.backgroundColor
          },
          visible: false,
          events: {}
        },
        /**
         * Event callback when annotation is added to the chart.
         *
         * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
         * @since     7.1.0
         * @apioption annotations.events.add
         */
        /**
         * Event callback when annotation is updated (e.g. drag and
         * droppped or resized by control points).
         *
         * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
         * @since     7.1.0
         * @apioption annotations.events.afterUpdate
         */
        /**
         * Event callback when annotation is removed from the chart.
         *
         * @type      {Highcharts.EventCallbackFunction<Highcharts.Annotation>}
         * @since     7.1.0
         * @apioption annotations.events.remove
         */
        /**
         * Events available in annotations.
         *
         * @requires modules/annotations
         */
        events: {},
        /**
         * The Z index of the annotation.
         */
        zIndex: 6
      }
    }
  )
);
Globals_default.extendAnnotation = function(Constructor, BaseConstructor, prototype, defaultOptions17) {
  BaseConstructor = BaseConstructor || Annotation;
  extend49(Constructor.prototype, merge49(BaseConstructor.prototype, prototype));
  Constructor.prototype.defaultOptions = merge49(Constructor.prototype.defaultOptions, defaultOptions17 || {});
};
extend49(
  chartProto,
  /** @lends Highcharts.Chart# */
  {
    initAnnotation: function(userOptions) {
      var Constructor = Annotation.types[userOptions.type] || Annotation, annotation = new Constructor(this, userOptions);
      this.annotations.push(annotation);
      return annotation;
    },
    /**
     * Add an annotation to the chart after render time.
     *
     * @param  {Highcharts.AnnotationsOptions} options
     *         The annotation options for the new, detailed annotation.
     * @param {boolean} [redraw]
     *
     * @return {Highcharts.Annotation} - The newly generated annotation.
     */
    addAnnotation: function(userOptions, redraw) {
      var annotation = this.initAnnotation(userOptions);
      this.options.annotations.push(annotation.options);
      if (pick56(redraw, true)) {
        annotation.redraw();
        annotation.graphic.attr({
          opacity: 1
        });
      }
      return annotation;
    },
    /**
     * Remove an annotation from the chart.
     *
     * @param {number|string|Highcharts.Annotation} idOrAnnotation
     * The annotation's id or direct annotation object.
     */
    removeAnnotation: function(idOrAnnotation) {
      var annotations = this.annotations, annotation = idOrAnnotation.coll === "annotations" ? idOrAnnotation : find15(annotations, function(annotation2) {
        return annotation2.options.id === idOrAnnotation;
      });
      if (annotation) {
        fireEvent28(annotation, "remove");
        erase10(this.options.annotations, annotation.options);
        erase10(annotations, annotation);
        annotation.destroy();
      }
    },
    drawAnnotations: function() {
      this.plotBoxClip.attr(this.plotBox);
      this.annotations.forEach(function(annotation) {
        annotation.redraw();
        annotation.graphic.animate({
          opacity: 1
        }, annotation.animationConfig);
      });
    }
  }
);
chartProto.collectionsWithUpdate.push("annotations");
chartProto.collectionsWithInit.annotations = [chartProto.addAnnotation];
addEvent38(Chart_default, "afterInit", function() {
  this.annotations = [];
  if (!this.options.annotations) {
    this.options.annotations = [];
  }
});
chartProto.callbacks.push(function(chart) {
  chart.plotBoxClip = this.renderer.clipRect(this.plotBox);
  chart.controlPointsGroup = chart.renderer.g("control-points").attr({ zIndex: 99 }).clip(chart.plotBoxClip).add();
  chart.options.annotations.forEach(function(annotationOptions, i) {
    if (
      // Verify that it has not been previously added in a responsive rule
      !chart.annotations.some(function(annotation2) {
        return annotation2.options === annotationOptions;
      })
    ) {
      var annotation = chart.initAnnotation(annotationOptions);
      chart.options.annotations[i] = annotation.options;
    }
  });
  chart.drawAnnotations();
  addEvent38(chart, "redraw", chart.drawAnnotations);
  addEvent38(chart, "destroy", function() {
    chart.plotBoxClip.destroy();
    chart.controlPointsGroup.destroy();
  });
  addEvent38(chart, "exportData", function(event) {
    var annotations = chart.annotations, csvColumnHeaderFormatter = (this.options.exporting && this.options.exporting.csv || {}).columnHeaderFormatter, multiLevelHeaders = !event.dataRows[1].xValues, annotationHeader = chart.options.lang && chart.options.lang.exportData && chart.options.lang.exportData.annotationHeader, columnHeaderFormatter = function(index) {
      var s;
      if (csvColumnHeaderFormatter) {
        s = csvColumnHeaderFormatter(index);
        if (s !== false) {
          return s;
        }
      }
      s = annotationHeader + " " + index;
      if (multiLevelHeaders) {
        return {
          columnTitle: s,
          topLevelColumnTitle: s
        };
      }
      return s;
    }, startRowLength = event.dataRows[0].length, annotationSeparator = chart.options.exporting && chart.options.exporting.csv && chart.options.exporting.csv.annotations && chart.options.exporting.csv.annotations.itemDelimiter, joinAnnotations = chart.options.exporting && chart.options.exporting.csv && chart.options.exporting.csv.annotations && chart.options.exporting.csv.annotations.join;
    annotations.forEach(function(annotation) {
      if (annotation.options.labelOptions.includeInDataExport) {
        annotation.labels.forEach(function(label) {
          if (label.options.text) {
            var annotationText_1 = label.options.text;
            label.points.forEach(function(points) {
              var annotationX = points.x, xAxisIndex = points.series.xAxis ? points.series.xAxis.options.index : -1;
              var wasAdded = false;
              if (xAxisIndex === -1) {
                var n = event.dataRows[0].length, newRow = new Array(n);
                for (var i2 = 0; i2 < n; ++i2) {
                  newRow[i2] = "";
                }
                newRow.push(annotationText_1);
                newRow.xValues = [];
                newRow.xValues[xAxisIndex] = annotationX;
                event.dataRows.push(newRow);
                wasAdded = true;
              }
              if (!wasAdded) {
                event.dataRows.forEach(function(row, rowIndex) {
                  if (!wasAdded && row.xValues && xAxisIndex !== void 0 && annotationX === row.xValues[xAxisIndex]) {
                    if (joinAnnotations && row.length > startRowLength) {
                      row[row.length - 1] += annotationSeparator + annotationText_1;
                    } else {
                      row.push(annotationText_1);
                    }
                    wasAdded = true;
                  }
                });
              }
              if (!wasAdded) {
                var n = event.dataRows[0].length, newRow = new Array(n);
                for (var i2 = 0; i2 < n; ++i2) {
                  newRow[i2] = "";
                }
                newRow[0] = annotationX;
                newRow.push(annotationText_1);
                newRow.xValues = [];
                if (xAxisIndex !== void 0) {
                  newRow.xValues[xAxisIndex] = annotationX;
                }
                event.dataRows.push(newRow);
              }
            });
          }
        });
      }
    });
    var maxRowLen = 0;
    event.dataRows.forEach(function(row) {
      maxRowLen = Math.max(maxRowLen, row.length);
    });
    var newRows = maxRowLen - event.dataRows[0].length;
    for (var i = 0; i < newRows; i++) {
      var header = columnHeaderFormatter(i + 1);
      if (multiLevelHeaders) {
        event.dataRows[0].push(header.topLevelColumnTitle);
        event.dataRows[1].push(header.columnTitle);
      } else {
        event.dataRows[0].push(header);
      }
    }
  });
});
wrap4(Pointer_default.prototype, "onContainerMouseDown", function(proceed) {
  if (!this.chart.hasDraggedAnnotation) {
    proceed.apply(this, Array.prototype.slice.call(arguments, 1));
  }
});
Globals_default.Annotation = Annotation;
var Annotations_default = Annotation;

// node_modules/highcharts/es-modules/Mixins/Navigation.js
var chartNavigation = {
  /**
   * Initializes `chart.navigation` object which delegates `update()` methods
   * to all other common classes (used in exporting and navigationBindings).
   *
   * @private
   * @param {Highcharts.Chart} chart
   *        The chart instance.
   * @return {void}
   */
  initUpdate: function(chart) {
    if (!chart.navigation) {
      chart.navigation = {
        updates: [],
        update: function(options, redraw) {
          this.updates.forEach(function(updateConfig) {
            updateConfig.update.call(updateConfig.context, options, redraw);
          });
        }
      };
    }
  },
  /**
   * Registers an `update()` method in the `chart.navigation` object.
   *
   * @private
   * @param {Highcharts.ChartNavigationUpdateFunction} update
   *        The `update()` method that will be called in `chart.update()`.
   * @param {Highcharts.Chart} chart
   *        The chart instance. `update()` will use that as a context
   *        (`this`).
   * @return {void}
   */
  addUpdate: function(update, chart) {
    if (!chart.navigation) {
      this.initUpdate(chart);
    }
    chart.navigation.updates.push({
      update,
      context: chart
    });
  }
};
var Navigation_default = chartNavigation;

// node_modules/highcharts/es-modules/Extensions/Annotations/NavigationBindings.js
var format13 = FormatUtilities_default.format;
var setOptions2 = DefaultOptions_default.setOptions;
var addEvent39 = Utilities_default.addEvent;
var attr10 = Utilities_default.attr;
var fireEvent29 = Utilities_default.fireEvent;
var isArray17 = Utilities_default.isArray;
var isFunction6 = Utilities_default.isFunction;
var isNumber35 = Utilities_default.isNumber;
var isObject10 = Utilities_default.isObject;
var merge50 = Utilities_default.merge;
var objectEach27 = Utilities_default.objectEach;
var pick57 = Utilities_default.pick;
var doc19 = Globals_default.doc;
var win16 = Globals_default.win;
var PREFIX = "highcharts-";
function closestPolyfill(el, s) {
  var ElementProto = win16.Element.prototype, elementMatches = ElementProto.matches || ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector, ret = null;
  if (ElementProto.closest) {
    ret = ElementProto.closest.call(el, s);
  } else {
    do {
      if (elementMatches.call(el, s)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
  }
  return ret;
}
var bindingsUtils = {
  /**
   * Get field type according to value
   *
   * @private
   * @function Highcharts.NavigationBindingsUtilsObject.getFieldType
   *
   * @param {'boolean'|'number'|'string'} value
   * Atomic type (one of: string, number, boolean)
   *
   * @return {'checkbox'|'number'|'text'}
   * Field type (one of: text, number, checkbox)
   */
  getFieldType: function(value) {
    return {
      "string": "text",
      "number": "number",
      "boolean": "checkbox"
    }[typeof value];
  },
  /**
   * Update size of background (rect) in some annotations: Measure, Simple
   * Rect.
   *
   * @private
   * @function Highcharts.NavigationBindingsUtilsObject.updateRectSize
   *
   * @param {Highcharts.PointerEventObject} event
   * Normalized browser event
   *
   * @param {Highcharts.Annotation} annotation
   * Annotation to be updated
   */
  updateRectSize: function(event, annotation) {
    var chart = annotation.chart, options = annotation.options.typeOptions, xAxis = isNumber35(options.xAxis) && chart.xAxis[options.xAxis], yAxis = isNumber35(options.yAxis) && chart.yAxis[options.yAxis];
    if (xAxis && yAxis) {
      var x = xAxis.toValue(event[xAxis.horiz ? "chartX" : "chartY"]), y = yAxis.toValue(event[yAxis.horiz ? "chartX" : "chartY"]), width = x - options.point.x, height = options.point.y - y;
      annotation.update({
        typeOptions: {
          background: {
            width: chart.inverted ? height : width,
            height: chart.inverted ? width : height
          }
        }
      });
    }
  },
  /**
   * Returns the first xAxis or yAxis that was clicked with its value.
   *
   * @private
   * @function Highcharts.NavigationBindingsUtilsObject#getAssignedAxis
   *
   * @param {Array<Highcharts.PointerAxisCoordinateObject>} coords
   *        All the chart's x or y axes with a current pointer's axis value.
   *
   * @return {Highcharts.PointerAxisCoordinateObject}
   *         Object with a first found axis and its value that pointer
   *         is currently pointing.
   */
  getAssignedAxis: function(coords) {
    return coords.filter(function(coord) {
      var axisMin = coord.axis.min, axisMax = coord.axis.max, minPointOffset = pick57(coord.axis.minPointOffset, 0);
      return isNumber35(axisMin) && isNumber35(axisMax) && coord.value >= axisMin - minPointOffset && coord.value <= axisMax + minPointOffset && // don't count navigator axis
      !coord.axis.options.isInternal;
    })[0];
  }
};
var NavigationBindings = (
  /** @class */
  function() {
    function NavigationBindings2(chart, options) {
      this.boundClassNames = void 0;
      this.selectedButton = void 0;
      this.chart = chart;
      this.options = options;
      this.eventsToUnbind = [];
      this.container = doc19.getElementsByClassName(this.options.bindingsClassName || "");
    }
    NavigationBindings2.prototype.initEvents = function() {
      var navigation2 = this, chart = navigation2.chart, bindingsContainer = navigation2.container, options = navigation2.options;
      navigation2.boundClassNames = {};
      objectEach27(options.bindings || {}, function(value) {
        navigation2.boundClassNames[value.className] = value;
      });
      [].forEach.call(bindingsContainer, function(subContainer) {
        navigation2.eventsToUnbind.push(addEvent39(subContainer, "click", function(event) {
          var bindings = navigation2.getButtonEvents(subContainer, event);
          if (bindings && bindings.button.className.indexOf("highcharts-disabled-btn") === -1) {
            navigation2.bindingsButtonClick(bindings.button, bindings.events, event);
          }
        }));
      });
      objectEach27(options.events || {}, function(callback, eventName) {
        if (isFunction6(callback)) {
          navigation2.eventsToUnbind.push(addEvent39(navigation2, eventName, callback, { passive: false }));
        }
      });
      navigation2.eventsToUnbind.push(addEvent39(chart.container, "click", function(e2) {
        if (!chart.cancelClick && chart.isInsidePlot(e2.chartX - chart.plotLeft, e2.chartY - chart.plotTop, {
          visiblePlotOnly: true
        })) {
          navigation2.bindingsChartClick(this, e2);
        }
      }));
      navigation2.eventsToUnbind.push(addEvent39(chart.container, Globals_default.isTouchDevice ? "touchmove" : "mousemove", function(e2) {
        navigation2.bindingsContainerMouseMove(this, e2);
      }, Globals_default.isTouchDevice ? { passive: false } : void 0));
    };
    NavigationBindings2.prototype.initUpdate = function() {
      var navigation2 = this;
      Navigation_default.addUpdate(function(options) {
        navigation2.update(options);
      }, this.chart);
    };
    NavigationBindings2.prototype.bindingsButtonClick = function(button, events, clickEvent) {
      var navigation2 = this, chart = navigation2.chart;
      if (navigation2.selectedButtonElement) {
        fireEvent29(navigation2, "deselectButton", { button: navigation2.selectedButtonElement });
        if (navigation2.nextEvent) {
          if (navigation2.currentUserDetails && navigation2.currentUserDetails.coll === "annotations") {
            chart.removeAnnotation(navigation2.currentUserDetails);
          }
          navigation2.mouseMoveEvent = navigation2.nextEvent = false;
        }
      }
      navigation2.selectedButton = events;
      navigation2.selectedButtonElement = button;
      fireEvent29(navigation2, "selectButton", { button });
      if (events.init) {
        events.init.call(navigation2, button, clickEvent);
      }
      if (events.start || events.steps) {
        chart.renderer.boxWrapper.addClass(PREFIX + "draw-mode");
      }
    };
    NavigationBindings2.prototype.bindingsChartClick = function(chart, clickEvent) {
      chart = this.chart;
      var navigation2 = this, activeAnnotation = navigation2.activeAnnotation, selectedButton = navigation2.selectedButton, svgContainer = chart.renderer.boxWrapper;
      if (activeAnnotation) {
        if (!activeAnnotation.cancelClick && // #15729
        !clickEvent.activeAnnotation && // Element could be removed in the child action, e.g. button
        clickEvent.target.parentNode && // TO DO: Polyfill for IE11?
        !closestPolyfill(clickEvent.target, "." + PREFIX + "popup")) {
          fireEvent29(navigation2, "closePopup");
        } else if (activeAnnotation.cancelClick) {
          setTimeout(function() {
            activeAnnotation.cancelClick = false;
          }, 0);
        }
      }
      if (!selectedButton || !selectedButton.start) {
        return;
      }
      if (!navigation2.nextEvent) {
        navigation2.currentUserDetails = selectedButton.start.call(navigation2, clickEvent);
        if (navigation2.currentUserDetails && selectedButton.steps) {
          navigation2.stepIndex = 0;
          navigation2.steps = true;
          navigation2.mouseMoveEvent = navigation2.nextEvent = selectedButton.steps[navigation2.stepIndex];
        } else {
          fireEvent29(navigation2, "deselectButton", { button: navigation2.selectedButtonElement });
          svgContainer.removeClass(PREFIX + "draw-mode");
          navigation2.steps = false;
          navigation2.selectedButton = null;
          if (selectedButton.end) {
            selectedButton.end.call(navigation2, clickEvent, navigation2.currentUserDetails);
          }
        }
      } else {
        navigation2.nextEvent(clickEvent, navigation2.currentUserDetails);
        if (navigation2.steps) {
          navigation2.stepIndex++;
          if (selectedButton.steps[navigation2.stepIndex]) {
            navigation2.mouseMoveEvent = navigation2.nextEvent = selectedButton.steps[navigation2.stepIndex];
          } else {
            fireEvent29(navigation2, "deselectButton", { button: navigation2.selectedButtonElement });
            svgContainer.removeClass(PREFIX + "draw-mode");
            if (selectedButton.end) {
              selectedButton.end.call(navigation2, clickEvent, navigation2.currentUserDetails);
            }
            navigation2.nextEvent = false;
            navigation2.mouseMoveEvent = false;
            navigation2.selectedButton = null;
          }
        }
      }
    };
    NavigationBindings2.prototype.bindingsContainerMouseMove = function(_container, moveEvent) {
      if (this.mouseMoveEvent) {
        this.mouseMoveEvent(moveEvent, this.currentUserDetails);
      }
    };
    NavigationBindings2.prototype.fieldsToOptions = function(fields, config2) {
      objectEach27(fields, function(value, field) {
        var parsedValue = parseFloat(value), path = field.split("."), parent = config2, pathLength = path.length - 1;
        if (isNumber35(parsedValue) && !value.match(/px/g) && !field.match(/format/g)) {
          value = parsedValue;
        }
        if (value !== "" && value !== "undefined") {
          path.forEach(function(name, index) {
            var nextName = pick57(path[index + 1], "");
            if (pathLength === index) {
              parent[name] = value;
            } else if (!parent[name]) {
              parent[name] = nextName.match(/\d/g) ? [] : {};
              parent = parent[name];
            } else {
              parent = parent[name];
            }
          });
        }
      });
      return config2;
    };
    NavigationBindings2.prototype.deselectAnnotation = function() {
      if (this.activeAnnotation) {
        this.activeAnnotation.setControlPointsVisibility(false);
        this.activeAnnotation = false;
      }
    };
    NavigationBindings2.prototype.annotationToFields = function(annotation) {
      var options = annotation.options, editables = NavigationBindings2.annotationsEditable, nestedEditables = editables.nestedOptions, getFieldType = this.utils.getFieldType, type = pick57(options.type, options.shapes && options.shapes[0] && options.shapes[0].type, options.labels && options.labels[0] && options.labels[0].itemType, "label"), nonEditables = NavigationBindings2.annotationsNonEditable[options.langKey] || [], visualOptions = {
        langKey: options.langKey,
        type
      };
      function traverse(option, key, parentEditables, parent) {
        var nextParent;
        if (parentEditables && option && nonEditables.indexOf(key) === -1 && ((parentEditables.indexOf && parentEditables.indexOf(key)) >= 0 || parentEditables[key] || // nested array
        parentEditables === true)) {
          if (isArray17(option)) {
            parent[key] = [];
            option.forEach(function(arrayOption, i) {
              if (!isObject10(arrayOption)) {
                traverse(arrayOption, 0, nestedEditables[key], parent[key]);
              } else {
                parent[key][i] = {};
                objectEach27(arrayOption, function(nestedOption, nestedKey) {
                  traverse(nestedOption, nestedKey, nestedEditables[key], parent[key][i]);
                });
              }
            });
          } else if (isObject10(option)) {
            nextParent = {};
            if (isArray17(parent)) {
              parent.push(nextParent);
              nextParent[key] = {};
              nextParent = nextParent[key];
            } else {
              parent[key] = nextParent;
            }
            objectEach27(option, function(nestedOption, nestedKey) {
              traverse(nestedOption, nestedKey, key === 0 ? parentEditables : nestedEditables[key], nextParent);
            });
          } else {
            if (key === "format") {
              parent[key] = [
                format13(option, annotation.labels[0].points[0]).toString(),
                "text"
              ];
            } else if (isArray17(parent)) {
              parent.push([option, getFieldType(option)]);
            } else {
              parent[key] = [option, getFieldType(option)];
            }
          }
        }
      }
      objectEach27(options, function(option, key) {
        if (key === "typeOptions") {
          visualOptions[key] = {};
          objectEach27(options[key], function(typeOption, typeKey) {
            traverse(typeOption, typeKey, nestedEditables, visualOptions[key], true);
          });
        } else {
          traverse(option, key, editables[type], visualOptions);
        }
      });
      return visualOptions;
    };
    NavigationBindings2.prototype.getClickedClassNames = function(container, event) {
      var element = event.target, classNames = [], elemClassName;
      while (element) {
        elemClassName = attr10(element, "class");
        if (elemClassName) {
          classNames = classNames.concat(elemClassName.split(" ").map(function(name) {
            return [
              name,
              element
            ];
          }));
        }
        element = element.parentNode;
        if (element === container) {
          return classNames;
        }
      }
      return classNames;
    };
    NavigationBindings2.prototype.getButtonEvents = function(container, event) {
      var navigation2 = this, classNames = this.getClickedClassNames(container, event), bindings;
      classNames.forEach(function(className) {
        if (navigation2.boundClassNames[className[0]] && !bindings) {
          bindings = {
            events: navigation2.boundClassNames[className[0]],
            button: className[1]
          };
        }
      });
      return bindings;
    };
    NavigationBindings2.prototype.update = function(options) {
      this.options = merge50(true, this.options, options);
      this.removeEvents();
      this.initEvents();
    };
    NavigationBindings2.prototype.removeEvents = function() {
      this.eventsToUnbind.forEach(function(unbinder) {
        unbinder();
      });
    };
    NavigationBindings2.prototype.destroy = function() {
      this.removeEvents();
    };
    NavigationBindings2.annotationsEditable = {
      // `typeOptions` are always available
      // Nested and shared options:
      nestedOptions: {
        labelOptions: ["style", "format", "backgroundColor"],
        labels: ["style"],
        label: ["style"],
        style: ["fontSize", "color"],
        background: ["fill", "strokeWidth", "stroke"],
        innerBackground: ["fill", "strokeWidth", "stroke"],
        outerBackground: ["fill", "strokeWidth", "stroke"],
        shapeOptions: ["fill", "strokeWidth", "stroke"],
        shapes: ["fill", "strokeWidth", "stroke"],
        line: ["strokeWidth", "stroke"],
        backgroundColors: [true],
        connector: ["fill", "strokeWidth", "stroke"],
        crosshairX: ["strokeWidth", "stroke"],
        crosshairY: ["strokeWidth", "stroke"]
      },
      // Simple shapes:
      circle: ["shapes"],
      verticalLine: [],
      label: ["labelOptions"],
      // Measure
      measure: ["background", "crosshairY", "crosshairX"],
      // Others:
      fibonacci: [],
      tunnel: ["background", "line", "height"],
      pitchfork: ["innerBackground", "outerBackground"],
      rect: ["shapes"],
      // Crooked lines, elliots, arrows etc:
      crookedLine: [],
      basicAnnotation: ["shapes", "labelOptions"]
    };
    NavigationBindings2.annotationsNonEditable = {
      rectangle: ["crosshairX", "crosshairY", "label"]
    };
    return NavigationBindings2;
  }()
);
NavigationBindings.prototype.utils = bindingsUtils;
Chart_default.prototype.initNavigationBindings = function() {
  var chart = this, options = chart.options;
  if (options && options.navigation && options.navigation.bindings) {
    chart.navigationBindings = new NavigationBindings(chart, options.navigation);
    chart.navigationBindings.initEvents();
    chart.navigationBindings.initUpdate();
  }
};
addEvent39(Chart_default, "load", function() {
  this.initNavigationBindings();
});
addEvent39(Chart_default, "destroy", function() {
  if (this.navigationBindings) {
    this.navigationBindings.destroy();
  }
});
addEvent39(NavigationBindings, "deselectButton", function() {
  this.selectedButtonElement = null;
});
addEvent39(Annotations_default, "remove", function() {
  if (this.chart.navigationBindings) {
    this.chart.navigationBindings.deselectAnnotation();
  }
});
function selectableAnnotation(annotationType) {
  var originalClick = annotationType.prototype.defaultOptions.events && annotationType.prototype.defaultOptions.events.click;
  function selectAndShowPopup(eventArguments) {
    var annotation = this, navigation2 = annotation.chart.navigationBindings, prevAnnotation = navigation2.activeAnnotation;
    if (originalClick) {
      originalClick.call(annotation, eventArguments);
    }
    if (prevAnnotation !== annotation) {
      navigation2.deselectAnnotation();
      navigation2.activeAnnotation = annotation;
      annotation.setControlPointsVisibility(true);
      fireEvent29(navigation2, "showPopup", {
        annotation,
        formType: "annotation-toolbar",
        options: navigation2.annotationToFields(annotation),
        onSubmit: function(data) {
          var config2 = {}, typeOptions;
          if (data.actionType === "remove") {
            navigation2.activeAnnotation = false;
            navigation2.chart.removeAnnotation(annotation);
          } else {
            navigation2.fieldsToOptions(data.fields, config2);
            navigation2.deselectAnnotation();
            typeOptions = config2.typeOptions;
            if (annotation.options.type === "measure") {
              typeOptions.crosshairY.enabled = typeOptions.crosshairY.strokeWidth !== 0;
              typeOptions.crosshairX.enabled = typeOptions.crosshairX.strokeWidth !== 0;
            }
            annotation.update(config2);
          }
        }
      });
    } else {
      fireEvent29(navigation2, "closePopup");
    }
    eventArguments.activeAnnotation = true;
  }
  merge50(true, annotationType.prototype.defaultOptions.events, {
    click: selectAndShowPopup
  });
}
if (Globals_default.Annotation) {
  selectableAnnotation(Annotations_default);
  objectEach27(Annotations_default.types, function(annotationType) {
    selectableAnnotation(annotationType);
  });
}
setOptions2({
  /**
   * @optionparent lang
   *
   * @private
   */
  lang: {
    /**
     * Configure the Popup strings in the chart. Requires the
     * `annotations.js` or `annotations-advanced.src.js` module to be
     * loaded.
     *
     * @since   7.0.0
     * @product highcharts highstock
     */
    navigation: {
      /**
       * Translations for all field names used in popup.
       *
       * @product highcharts highstock
       */
      popup: {
        simpleShapes: "Simple shapes",
        lines: "Lines",
        circle: "Circle",
        rectangle: "Rectangle",
        label: "Label",
        shapeOptions: "Shape options",
        typeOptions: "Details",
        fill: "Fill",
        format: "Text",
        strokeWidth: "Line width",
        stroke: "Line color",
        title: "Title",
        name: "Name",
        labelOptions: "Label options",
        labels: "Labels",
        backgroundColor: "Background color",
        backgroundColors: "Background colors",
        borderColor: "Border color",
        borderRadius: "Border radius",
        borderWidth: "Border width",
        style: "Style",
        padding: "Padding",
        fontSize: "Font size",
        color: "Color",
        height: "Height",
        shapes: "Shape options"
      }
    }
  },
  /**
   * @optionparent navigation
   * @product      highcharts highstock
   *
   * @private
   */
  navigation: {
    /**
     * A CSS class name where all bindings will be attached to. Multiple
     * charts on the same page should have separate class names to prevent
     * duplicating events.
     *
     * Default value of versions < 7.0.4 `highcharts-bindings-wrapper`
     *
     * @since     7.0.0
     * @type      {string}
     */
    bindingsClassName: "highcharts-bindings-container",
    /**
     * Bindings definitions for custom HTML buttons. Each binding implements
     * simple event-driven interface:
     *
     * - `className`: classname used to bind event to
     *
     * - `init`: initial event, fired on button click
     *
     * - `start`: fired on first click on a chart
     *
     * - `steps`: array of sequential events fired one after another on each
     *   of users clicks
     *
     * - `end`: last event to be called after last step event
     *
     * @type         {Highcharts.Dictionary<Highcharts.NavigationBindingsOptionsObject>|*}
     * @sample       stock/stocktools/stocktools-thresholds
     *               Custom bindings in Highcharts Stock
     * @since        7.0.0
     * @product      highcharts highstock
     */
    bindings: {
      /**
       * A circle annotation bindings. Includes `start` and one event in
       * `steps` array.
       *
       * @type    {Highcharts.NavigationBindingsOptionsObject}
       * @default {"className": "highcharts-circle-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
       */
      circleAnnotation: {
        /** @ignore-option */
        className: "highcharts-circle-annotation",
        /** @ignore-option */
        start: function(e2) {
          var coords = this.chart.pointer.getCoordinates(e2), coordsX = this.utils.getAssignedAxis(coords.xAxis), coordsY = this.utils.getAssignedAxis(coords.yAxis), navigation2 = this.chart.options.navigation;
          if (!coordsX || !coordsY) {
            return;
          }
          return this.chart.addAnnotation(merge50({
            langKey: "circle",
            type: "basicAnnotation",
            shapes: [{
              type: "circle",
              point: {
                x: coordsX.value,
                y: coordsY.value,
                xAxis: coordsX.axis.options.index,
                yAxis: coordsY.axis.options.index
              },
              r: 5
            }]
          }, navigation2.annotationsOptions, navigation2.bindings.circleAnnotation.annotationsOptions));
        },
        /** @ignore-option */
        steps: [
          function(e2, annotation) {
            var mockPointOpts = annotation.options.shapes[0].point, inverted = this.chart.inverted, x, y, distance;
            if (isNumber35(mockPointOpts.xAxis) && isNumber35(mockPointOpts.yAxis)) {
              x = this.chart.xAxis[mockPointOpts.xAxis].toPixels(mockPointOpts.x);
              y = this.chart.yAxis[mockPointOpts.yAxis].toPixels(mockPointOpts.y);
              distance = Math.max(Math.sqrt(Math.pow(inverted ? y - e2.chartX : x - e2.chartX, 2) + Math.pow(inverted ? x - e2.chartY : y - e2.chartY, 2)), 5);
            }
            annotation.update({
              shapes: [{
                r: distance
              }]
            });
          }
        ]
      },
      /**
       * A rectangle annotation bindings. Includes `start` and one event
       * in `steps` array.
       *
       * @type    {Highcharts.NavigationBindingsOptionsObject}
       * @default {"className": "highcharts-rectangle-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
       */
      rectangleAnnotation: {
        /** @ignore-option */
        className: "highcharts-rectangle-annotation",
        /** @ignore-option */
        start: function(e2) {
          var coords = this.chart.pointer.getCoordinates(e2), coordsX = this.utils.getAssignedAxis(coords.xAxis), coordsY = this.utils.getAssignedAxis(coords.yAxis);
          if (!coordsX || !coordsY) {
            return;
          }
          var x = coordsX.value, y = coordsY.value, xAxis = coordsX.axis.options.index, yAxis = coordsY.axis.options.index, navigation2 = this.chart.options.navigation;
          return this.chart.addAnnotation(merge50({
            langKey: "rectangle",
            type: "basicAnnotation",
            shapes: [{
              type: "path",
              points: [
                { xAxis, yAxis, x, y },
                { xAxis, yAxis, x, y },
                { xAxis, yAxis, x, y },
                { xAxis, yAxis, x, y }
              ]
            }]
          }, navigation2.annotationsOptions, navigation2.bindings.rectangleAnnotation.annotationsOptions));
        },
        /** @ignore-option */
        steps: [
          function(e2, annotation) {
            var points = annotation.options.shapes[0].points, coords = this.chart.pointer.getCoordinates(e2), coordsX = this.utils.getAssignedAxis(coords.xAxis), coordsY = this.utils.getAssignedAxis(coords.yAxis), x, y;
            if (coordsX && coordsY) {
              x = coordsX.value;
              y = coordsY.value;
              points[1].x = x;
              points[2].x = x;
              points[2].y = y;
              points[3].y = y;
              annotation.update({
                shapes: [{
                  points
                }]
              });
            }
          }
        ]
      },
      /**
       * A label annotation bindings. Includes `start` event only.
       *
       * @type    {Highcharts.NavigationBindingsOptionsObject}
       * @default {"className": "highcharts-label-annotation", "start": function() {}, "steps": [function() {}], "annotationsOptions": {}}
       */
      labelAnnotation: {
        /** @ignore-option */
        className: "highcharts-label-annotation",
        /** @ignore-option */
        start: function(e2) {
          var coords = this.chart.pointer.getCoordinates(e2), coordsX = this.utils.getAssignedAxis(coords.xAxis), coordsY = this.utils.getAssignedAxis(coords.yAxis), navigation2 = this.chart.options.navigation;
          if (!coordsX || !coordsY) {
            return;
          }
          return this.chart.addAnnotation(merge50({
            langKey: "label",
            type: "basicAnnotation",
            labelOptions: {
              format: "{y:.2f}"
            },
            labels: [{
              point: {
                xAxis: coordsX.axis.options.index,
                yAxis: coordsY.axis.options.index,
                x: coordsX.value,
                y: coordsY.value
              },
              overflow: "none",
              crop: true
            }]
          }, navigation2.annotationsOptions, navigation2.bindings.labelAnnotation.annotationsOptions));
        }
      }
    },
    /**
     * Path where Highcharts will look for icons. Change this to use icons
     * from a different server.
     *
     * @type      {string}
     * @default   https://code.highcharts.com/9.2.2/gfx/stock-icons/
     * @since     7.1.3
     * @apioption navigation.iconsURL
     */
    /**
     * A `showPopup` event. Fired when selecting for example an annotation.
     *
     * @type      {Function}
     * @apioption navigation.events.showPopup
     */
    /**
     * A `closePopup` event. Fired when Popup should be hidden, for example
     * when clicking on an annotation again.
     *
     * @type      {Function}
     * @apioption navigation.events.closePopup
     */
    /**
     * Event fired on a button click.
     *
     * @type      {Function}
     * @sample    highcharts/annotations/gui/
     *            Change icon in a dropddown on event
     * @sample    highcharts/annotations/gui-buttons/
     *            Change button class on event
     * @apioption navigation.events.selectButton
     */
    /**
     * Event fired when button state should change, for example after
     * adding an annotation.
     *
     * @type      {Function}
     * @sample    highcharts/annotations/gui/
     *            Change icon in a dropddown on event
     * @sample    highcharts/annotations/gui-buttons/
     *            Change button class on event
     * @apioption navigation.events.deselectButton
     */
    /**
     * Events to communicate between Stock Tools and custom GUI.
     *
     * @since        7.0.0
     * @product      highcharts highstock
     * @optionparent navigation.events
     */
    events: {},
    /**
     * Additional options to be merged into all annotations.
     *
     * @sample stock/stocktools/navigation-annotation-options
     *         Set red color of all line annotations
     *
     * @type      {Highcharts.AnnotationsOptions}
     * @extends   annotations
     * @exclude   crookedLine, elliottWave, fibonacci, infinityLine,
     *            measure, pitchfork, tunnel, verticalLine, basicAnnotation
     * @apioption navigation.annotationsOptions
     */
    annotationsOptions: {
      animation: {
        defer: 0
      }
    }
  }
});
addEvent39(Chart_default, "render", function() {
  var chart = this, navigationBindings = chart.navigationBindings, disabledClassName = "highcharts-disabled-btn";
  if (chart && navigationBindings) {
    var buttonsEnabled_1 = false;
    chart.series.forEach(function(series) {
      if (!series.options.isInternal && series.visible) {
        buttonsEnabled_1 = true;
      }
    });
    objectEach27(navigationBindings.boundClassNames, function(value, key) {
      if (chart.navigationBindings && chart.navigationBindings.container && chart.navigationBindings.container[0]) {
        var buttonNode = chart.navigationBindings.container[0].querySelectorAll("." + key);
        if (buttonNode) {
          for (var i = 0; i < buttonNode.length; i++) {
            var button = buttonNode[i];
            if (value.noDataState === "normal") {
              if (button.className.indexOf(disabledClassName) !== -1) {
                button.classList.remove(disabledClassName);
              }
            } else if (!buttonsEnabled_1) {
              if (button.className.indexOf(disabledClassName) === -1) {
                button.className += " " + disabledClassName;
              }
            } else {
              if (button.className.indexOf(disabledClassName) !== -1) {
                button.classList.remove(disabledClassName);
              }
            }
          }
        }
      }
    });
  }
});
addEvent39(NavigationBindings, "closePopup", function() {
  this.deselectAnnotation();
});
var NavigationBindings_default = NavigationBindings;

// node_modules/highcharts/es-modules/Extensions/Annotations/Popup.js
var doc20 = Globals_default.doc;
var isFirefox4 = Globals_default.isFirefox;
var getOptions3 = DefaultOptions_default.getOptions;
var addEvent40 = Utilities_default.addEvent;
var createElement10 = Utilities_default.createElement;
var defined41 = Utilities_default.defined;
var fireEvent30 = Utilities_default.fireEvent;
var isArray18 = Utilities_default.isArray;
var isObject11 = Utilities_default.isObject;
var isString12 = Utilities_default.isString;
var objectEach28 = Utilities_default.objectEach;
var pick58 = Utilities_default.pick;
var stableSort5 = Utilities_default.stableSort;
var wrap5 = Utilities_default.wrap;
var indexFilter = /\d/g;
var PREFIX2 = "highcharts-";
var DIV = "div";
var INPUT = "input";
var LABEL = "label";
var BUTTON = "button";
var SELECT = "select";
var OPTION = "option";
var SPAN = "span";
var UL = "ul";
var LI = "li";
var H3 = "h3";
wrap5(Pointer_default.prototype, "onContainerMouseDown", function(proceed, e2) {
  var popupClass = e2.target && e2.target.className;
  if (!(isString12(popupClass) && popupClass.indexOf(PREFIX2 + "popup-field") >= 0)) {
    proceed.apply(this, Array.prototype.slice.call(arguments, 1));
  }
});
Globals_default.Popup = function(parentDiv, iconsURL, chart) {
  this.init(parentDiv, iconsURL, chart);
};
Globals_default.Popup.prototype = {
  /**
   * Initialize the popup. Create base div and add close button.
   * @private
   * @param {Highcharts.HTMLDOMElement} parentDiv
   * Container where popup should be placed
   * @param {string} iconsURL
   * Icon URL
   */
  init: function(parentDiv, iconsURL, chart) {
    this.chart = chart;
    this.container = createElement10(DIV, {
      className: PREFIX2 + "popup highcharts-no-tooltip"
    }, null, parentDiv);
    this.lang = this.getLangpack();
    this.iconsURL = iconsURL;
    this.addCloseBtn();
  },
  /**
   * Create HTML element and attach click event (close popup).
   * @private
   */
  addCloseBtn: function() {
    var _self = this, closeBtn;
    var iconsURL = this.iconsURL;
    closeBtn = createElement10(DIV, {
      className: PREFIX2 + "popup-close"
    }, null, this.container);
    closeBtn.style["background-image"] = "url(" + (iconsURL.match(/png|svg|jpeg|jpg|gif/ig) ? iconsURL : iconsURL + "close.svg") + ")";
    ["click", "touchstart"].forEach(function(eventName) {
      addEvent40(closeBtn, eventName, function() {
        if (_self.chart) {
          fireEvent30(_self.chart.navigationBindings, "closePopup");
        } else {
          _self.closePopup();
        }
      });
    });
  },
  /**
   * Create two columns (divs) in HTML.
   * @private
   * @param {Highcharts.HTMLDOMElement} container
   * Container of columns
   * @return {Highcharts.Dictionary<Highcharts.HTMLDOMElement>}
   * Reference to two HTML columns (lhsCol, rhsCol)
   */
  addColsContainer: function(container) {
    var rhsCol, lhsCol;
    lhsCol = createElement10(DIV, {
      className: PREFIX2 + "popup-lhs-col"
    }, null, container);
    rhsCol = createElement10(DIV, {
      className: PREFIX2 + "popup-rhs-col"
    }, null, container);
    createElement10(DIV, {
      className: PREFIX2 + "popup-rhs-col-wrapper"
    }, null, rhsCol);
    return {
      lhsCol,
      rhsCol
    };
  },
  /**
   * Create input with label.
   * @private
   * @param {string} option
   * Chain of fields i.e params.styles.fontSize
   * @param {string} type
   * Indicator type
   * @param {Highhcharts.HTMLDOMElement}
   * Container where elements should be added
   * @param {string} value
   * Default value of input i.e period value is 14, extracted from
   * defaultOptions (ADD mode) or series options (EDIT mode)
   */
  addInput: function(option, type, parentDiv, value) {
    var optionParamList = option.split("."), optionName = optionParamList[optionParamList.length - 1], lang2 = this.lang, inputName = PREFIX2 + type + "-" + optionName;
    if (!inputName.match(indexFilter)) {
      createElement10(LABEL, {
        htmlFor: inputName
      }, void 0, parentDiv).appendChild(doc20.createTextNode(lang2[optionName] || optionName));
    }
    if (value !== "") {
      createElement10(INPUT, {
        name: inputName,
        value: value[0],
        type: value[1],
        className: PREFIX2 + "popup-field"
      }, void 0, parentDiv).setAttribute(PREFIX2 + "data-name", option);
    }
  },
  /**
   * Create button.
   * @private
   * @param {Highcharts.HTMLDOMElement} parentDiv
   * Container where elements should be added
   * @param {string} label
   * Text placed as button label
   * @param {string} type
   * add | edit | remove
   * @param {Function} callback
   * On click callback
   * @param {Highcharts.HTMLDOMElement} fieldsDiv
   * Container where inputs are generated
   * @return {Highcharts.HTMLDOMElement}
   * HTML button
   */
  addButton: function(parentDiv, label, type, callback, fieldsDiv) {
    var _self = this, closePopup = this.closePopup, getFields = this.getFields, button;
    button = createElement10(BUTTON, void 0, void 0, parentDiv);
    button.appendChild(doc20.createTextNode(label));
    ["click", "touchstart"].forEach(function(eventName) {
      addEvent40(button, eventName, function() {
        closePopup.call(_self);
        return callback(getFields(fieldsDiv, type));
      });
    });
    return button;
  },
  /**
   * Get values from all inputs and create JSON.
   * @private
   * @param {Highcharts.HTMLDOMElement} - container where inputs are created
   * @param {string} - add | edit | remove
   * @return {Highcharts.PopupFieldsObject} - fields
   */
  getFields: function(parentDiv, type) {
    var inputList = parentDiv.querySelectorAll("input"), optionSeries = "#" + PREFIX2 + "select-series > option:checked", optionVolume = "#" + PREFIX2 + "select-volume > option:checked", linkedTo = parentDiv.querySelectorAll(optionSeries)[0], volumeTo = parentDiv.querySelectorAll(optionVolume)[0], seriesId, param, fieldsOutput;
    fieldsOutput = {
      actionType: type,
      linkedTo: linkedTo && linkedTo.getAttribute("value"),
      fields: {}
    };
    [].forEach.call(inputList, function(input) {
      param = input.getAttribute(PREFIX2 + "data-name");
      seriesId = input.getAttribute(PREFIX2 + "data-series-id");
      if (seriesId) {
        fieldsOutput.seriesId = input.value;
      } else if (param) {
        fieldsOutput.fields[param] = input.value;
      } else {
        fieldsOutput.type = input.value;
      }
    });
    if (volumeTo) {
      fieldsOutput.fields["params.volumeSeriesID"] = volumeTo.getAttribute("value");
    }
    return fieldsOutput;
  },
  /**
   * Reset content of the current popup and show.
   * @private
   */
  showPopup: function() {
    var popupDiv = this.container, toolbarClass = PREFIX2 + "annotation-toolbar", popupCloseBtn = popupDiv.querySelectorAll("." + PREFIX2 + "popup-close")[0];
    this.formType = void 0;
    popupDiv.innerHTML = "";
    if (popupDiv.className.indexOf(toolbarClass) >= 0) {
      popupDiv.classList.remove(toolbarClass);
      popupDiv.removeAttribute("style");
    }
    popupDiv.appendChild(popupCloseBtn);
    popupDiv.style.display = "block";
    popupDiv.style.height = "";
  },
  /**
   * Hide popup.
   * @private
   */
  closePopup: function() {
    var container = pick58(this.popup && this.popup.container, this.container);
    container.style.display = "none";
  },
  /**
   * Create content and show popup.
   * @private
   * @param {string} - type of popup i.e indicators
   * @param {Highcharts.Chart} - chart
   * @param {Highcharts.AnnotationsOptions} - options
   * @param {Function} - on click callback
   */
  showForm: function(type, chart, options, callback) {
    if (!chart) {
      return;
    }
    this.popup = chart.navigationBindings.popup;
    this.showPopup();
    if (type === "indicators") {
      this.indicators.addForm.call(this, chart, options, callback);
    }
    if (type === "annotation-toolbar") {
      this.annotations.addToolbar.call(this, chart, options, callback);
    }
    if (type === "annotation-edit") {
      this.annotations.addForm.call(this, chart, options, callback);
    }
    if (type === "flag") {
      this.annotations.addForm.call(this, chart, options, callback, true);
    }
    this.formType = type;
    this.container.style.height = this.container.offsetHeight + "px";
  },
  /**
   * Return lang definitions for popup.
   * @private
   * @return {Highcharts.Dictionary<string>} - elements translations.
   */
  getLangpack: function() {
    return getOptions3().lang.navigation.popup;
  },
  annotations: {
    /**
     * Create annotation simple form. It contains two buttons
     * (edit / remove) and text label.
     * @private
     * @param {Highcharts.Chart} - chart
     * @param {Highcharts.AnnotationsOptions} - options
     * @param {Function} - on click callback
     */
    addToolbar: function(chart, options, callback) {
      var _self = this, lang2 = this.lang, popupDiv = this.popup.container, showForm = this.showForm, toolbarClass = PREFIX2 + "annotation-toolbar", button;
      if (popupDiv.className.indexOf(toolbarClass) === -1) {
        popupDiv.className += " " + toolbarClass;
      }
      if (chart) {
        popupDiv.style.top = chart.plotTop + 10 + "px";
      }
      createElement10(SPAN, void 0, void 0, popupDiv).appendChild(doc20.createTextNode(pick58(
        // Advanced annotations:
        lang2[options.langKey] || options.langKey,
        // Basic shapes:
        options.shapes && options.shapes[0].type
      )));
      button = this.addButton(popupDiv, lang2.removeButton || "remove", "remove", callback, popupDiv);
      button.className += " " + PREFIX2 + "annotation-remove-button";
      button.style["background-image"] = "url(" + this.iconsURL + "destroy.svg)";
      button = this.addButton(popupDiv, lang2.editButton || "edit", "edit", function() {
        showForm.call(_self, "annotation-edit", chart, options, callback);
      }, popupDiv);
      button.className += " " + PREFIX2 + "annotation-edit-button";
      button.style["background-image"] = "url(" + this.iconsURL + "edit.svg)";
    },
    /**
     * Create annotation simple form.
     * It contains fields with param names.
     * @private
     * @param {Highcharts.Chart} chart
     * Chart
     * @param {Object} options
     * Options
     * @param {Function} callback
     * On click callback
     * @param {boolean} [isInit]
     * If it is a form declared for init annotation
     */
    addForm: function(chart, options, callback, isInit) {
      var popupDiv = this.popup.container, lang2 = this.lang, bottomRow, lhsCol;
      if (!chart) {
        return;
      }
      lhsCol = createElement10("h2", {
        className: PREFIX2 + "popup-main-title"
      }, void 0, popupDiv);
      lhsCol.appendChild(doc20.createTextNode(lang2[options.langKey] || options.langKey || ""));
      lhsCol = createElement10(DIV, {
        className: PREFIX2 + "popup-lhs-col " + PREFIX2 + "popup-lhs-full"
      }, null, popupDiv);
      bottomRow = createElement10(DIV, {
        className: PREFIX2 + "popup-bottom-row"
      }, null, popupDiv);
      this.annotations.addFormFields.call(this, lhsCol, chart, "", options, [], true);
      this.addButton(bottomRow, isInit ? lang2.addButton || "add" : lang2.saveButton || "save", isInit ? "add" : "save", callback, popupDiv);
    },
    /**
     * Create annotation's form fields.
     * @private
     * @param {Highcharts.HTMLDOMElement} parentDiv
     * Div where inputs are placed
     * @param {Highcharts.Chart} chart
     * Chart
     * @param {string} parentNode
     * Name of parent to create chain of names
     * @param {Highcharts.AnnotationsOptions} options
     * Options
     * @param {Array<unknown>} storage
     * Array where all items are stored
     * @param {boolean} [isRoot]
     * Recursive flag for root
     */
    addFormFields: function(parentDiv, chart, parentNode, options, storage, isRoot) {
      var _self = this, addFormFields = this.annotations.addFormFields, addInput = this.addInput, lang2 = this.lang, parentFullName, titleName;
      if (!chart) {
        return;
      }
      objectEach28(options, function(value, option) {
        parentFullName = parentNode !== "" ? parentNode + "." + option : option;
        if (isObject11(value)) {
          if (
            // value is object of options
            !isArray18(value) || // array of objects with params. i.e labels in Fibonacci
            isArray18(value) && isObject11(value[0])
          ) {
            titleName = lang2[option] || option;
            if (!titleName.match(indexFilter)) {
              storage.push([
                true,
                titleName,
                parentDiv
              ]);
            }
            addFormFields.call(_self, parentDiv, chart, parentFullName, value, storage, false);
          } else {
            storage.push([
              _self,
              parentFullName,
              "annotation",
              parentDiv,
              value
            ]);
          }
        }
      });
      if (isRoot) {
        stableSort5(storage, function(a) {
          return a[1].match(/format/g) ? -1 : 1;
        });
        if (isFirefox4) {
          storage.reverse();
        }
        storage.forEach(function(genInput) {
          if (genInput[0] === true) {
            createElement10(SPAN, {
              className: PREFIX2 + "annotation-title"
            }, void 0, genInput[2]).appendChild(doc20.createTextNode(genInput[1]));
          } else {
            addInput.apply(genInput[0], genInput.splice(1));
          }
        });
      }
    }
  },
  indicators: {
    /**
     * Create indicator's form. It contains two tabs (ADD and EDIT) with
     * content.
     * @private
     */
    addForm: function(chart, _options, callback) {
      var tabsContainers, indicators = this.indicators, lang2 = this.lang, buttonParentDiv;
      if (!chart) {
        return;
      }
      this.tabs.init.call(this, chart);
      tabsContainers = this.popup.container.querySelectorAll("." + PREFIX2 + "tab-item-content");
      this.addColsContainer(tabsContainers[0]);
      indicators.addIndicatorList.call(this, chart, tabsContainers[0], "add");
      buttonParentDiv = tabsContainers[0].querySelectorAll("." + PREFIX2 + "popup-rhs-col")[0];
      this.addButton(buttonParentDiv, lang2.addButton || "add", "add", callback, buttonParentDiv);
      this.addColsContainer(tabsContainers[1]);
      indicators.addIndicatorList.call(this, chart, tabsContainers[1], "edit");
      buttonParentDiv = tabsContainers[1].querySelectorAll("." + PREFIX2 + "popup-rhs-col")[0];
      this.addButton(buttonParentDiv, lang2.saveButton || "save", "edit", callback, buttonParentDiv);
      this.addButton(buttonParentDiv, lang2.removeButton || "remove", "remove", callback, buttonParentDiv);
    },
    /**
     * Create HTML list of all indicators (ADD mode) or added indicators
     * (EDIT mode).
     * @private
     */
    addIndicatorList: function(chart, parentDiv, listType) {
      var _self = this, lhsCol = parentDiv.querySelectorAll("." + PREFIX2 + "popup-lhs-col")[0], rhsCol = parentDiv.querySelectorAll("." + PREFIX2 + "popup-rhs-col")[0], isEdit = listType === "edit", series = isEdit ? chart.series : (
        // EDIT mode
        chart.options.plotOptions
      ), addFormFields = this.indicators.addFormFields, rhsColWrapper, indicatorList, item;
      if (!chart) {
        return;
      }
      indicatorList = createElement10(UL, {
        className: PREFIX2 + "indicator-list"
      }, null, lhsCol);
      rhsColWrapper = rhsCol.querySelectorAll("." + PREFIX2 + "popup-rhs-col-wrapper")[0];
      objectEach28(series, function(serie, value) {
        var seriesOptions = serie.options;
        if (serie.params || seriesOptions && seriesOptions.params) {
          var indicatorNameType_1 = _self.indicators.getNameType(serie, value), indicatorType_1 = indicatorNameType_1.type;
          item = createElement10(LI, {
            className: PREFIX2 + "indicator-list"
          }, void 0, indicatorList);
          item.appendChild(doc20.createTextNode(indicatorNameType_1.name));
          ["click", "touchstart"].forEach(function(eventName) {
            addEvent40(item, eventName, function() {
              addFormFields.call(_self, chart, isEdit ? serie : series[indicatorType_1], indicatorNameType_1.type, rhsColWrapper);
              if (isEdit && serie.options) {
                createElement10(INPUT, {
                  type: "hidden",
                  name: PREFIX2 + "id-" + indicatorType_1,
                  value: serie.options.id
                }, null, rhsColWrapper).setAttribute(PREFIX2 + "data-series-id", serie.options.id);
              }
            });
          });
        }
      });
      if (indicatorList.childNodes.length > 0) {
        indicatorList.childNodes[0].click();
      }
    },
    /**
     * Extract full name and type of requested indicator.
     * @private
     * @param {Highcharts.Series} series
     * Series which name is needed. (EDIT mode - defaultOptions.series, ADD
     * mode - indicator series).
     * @param {string} - indicator type like: sma, ema, etc.
     * @return {Object} - series name and type like: sma, ema, etc.
     */
    getNameType: function(series, type) {
      var options = series.options, seriesTypes9 = Globals_default.seriesTypes, seriesName = seriesTypes9[type] && seriesTypes9[type].prototype.nameBase || type.toUpperCase(), seriesType = type;
      if (options && options.type) {
        seriesType = series.options.type;
        seriesName = series.name;
      }
      return {
        name: seriesName,
        type: seriesType
      };
    },
    /**
     * List all series with unique ID. Its mandatory for indicators to set
     * correct linking.
     * @private
     * @param {string} type
     * Indicator type like: sma, ema, etc.
     * @param {string} optionName
     * Type of select i.e series or volume.
     * @param {Highcharts.Chart} chart
     * Chart
     * @param {Highcharts.HTMLDOMElement} parentDiv
     * Element where created HTML list is added
     * @param {string} selectedOption
     *         optional param for default value in dropdown
     */
    listAllSeries: function(type, optionName, chart, parentDiv, selectedOption) {
      var selectName = PREFIX2 + optionName + "-type-" + type, lang2 = this.lang, selectBox, seriesOptions;
      if (!chart) {
        return;
      }
      createElement10(LABEL, {
        htmlFor: selectName
      }, null, parentDiv).appendChild(doc20.createTextNode(lang2[optionName] || optionName));
      selectBox = createElement10(SELECT, {
        name: selectName,
        className: PREFIX2 + "popup-field"
      }, null, parentDiv);
      selectBox.setAttribute("id", PREFIX2 + "select-" + optionName);
      chart.series.forEach(function(serie) {
        seriesOptions = serie.options;
        if (!seriesOptions.params && seriesOptions.id && seriesOptions.id !== PREFIX2 + "navigator-series") {
          createElement10(OPTION, {
            value: seriesOptions.id
          }, null, selectBox).appendChild(doc20.createTextNode(seriesOptions.name || seriesOptions.id));
        }
      });
      if (defined41(selectedOption)) {
        selectBox.value = selectedOption;
      }
    },
    /**
     * Create typical inputs for chosen indicator. Fields are extracted from
     * defaultOptions (ADD mode) or current indicator (ADD mode). Two extra
     * fields are added:
     * - hidden input - contains indicator type (required for callback)
     * - select - list of series which can be linked with indicator
     * @private
     * @param {Highcharts.Chart} chart
     * Chart
     * @param {Highcharts.Series} series
     * Indicator
     * @param {string} seriesType
     * Indicator type like: sma, ema, etc.
     * @param {Highcharts.HTMLDOMElement} rhsColWrapper
     * Element where created HTML list is added
     */
    addFormFields: function(chart, series, seriesType, rhsColWrapper) {
      var fields = series.params || series.options.params, getNameType = this.indicators.getNameType;
      rhsColWrapper.innerHTML = "";
      createElement10(H3, {
        className: PREFIX2 + "indicator-title"
      }, void 0, rhsColWrapper).appendChild(doc20.createTextNode(getNameType(series, seriesType).name));
      createElement10(INPUT, {
        type: "hidden",
        name: PREFIX2 + "type-" + seriesType,
        value: seriesType
      }, null, rhsColWrapper);
      this.indicators.listAllSeries.call(this, seriesType, "series", chart, rhsColWrapper, series.linkedParent && fields.volumeSeriesID);
      if (fields.volumeSeriesID) {
        this.indicators.listAllSeries.call(this, seriesType, "volume", chart, rhsColWrapper, series.linkedParent && series.linkedParent.options.id);
      }
      this.indicators.addParamInputs.call(this, chart, "params", fields, seriesType, rhsColWrapper);
    },
    /**
     * Recurent function which lists all fields, from params object and
     * create them as inputs. Each input has unique `data-name` attribute,
     * which keeps chain of fields i.e params.styles.fontSize.
     * @private
     * @param {Highcharts.Chart} chart
     * Chart
     * @param {string} parentNode
     * Name of parent to create chain of names
     * @param {Highcharts.PopupFieldsDictionary<string>} fields
     * Params which are based for input create
     * @param {string} type
     * Indicator type like: sma, ema, etc.
     * @param {Highcharts.HTMLDOMElement} parentDiv
     * Element where created HTML list is added
     */
    addParamInputs: function(chart, parentNode, fields, type, parentDiv) {
      var _self = this, addParamInputs = this.indicators.addParamInputs, addInput = this.addInput, parentFullName;
      if (!chart) {
        return;
      }
      objectEach28(fields, function(value, fieldName) {
        parentFullName = parentNode + "." + fieldName;
        if (value !== void 0) {
          if (isObject11(value)) {
            addInput.call(
              // (15733) 'Periods' has an arrayed value. Label must be created here.
              _self,
              parentFullName,
              type,
              parentDiv,
              ""
            );
            addParamInputs.call(_self, chart, parentFullName, value, type, parentDiv);
          } else if (
            // skip volume field which is created by addFormFields
            parentFullName !== "params.volumeSeriesID"
          ) {
            addInput.call(
              _self,
              parentFullName,
              type,
              parentDiv,
              [value, "text"]
              // all inputs are text type
            );
          }
        }
      });
    },
    /**
     * Get amount of indicators added to chart.
     * @private
     * @return {number} - Amount of indicators
     */
    getAmount: function() {
      var series = this.series, counter = 0;
      series.forEach(function(serie) {
        var seriesOptions = serie.options;
        if (serie.params || seriesOptions && seriesOptions.params) {
          counter++;
        }
      });
      return counter;
    }
  },
  tabs: {
    /**
     * Init tabs. Create tab menu items, tabs containers
     * @private
     * @param {Highcharts.Chart} chart
     * Reference to current chart
     */
    init: function(chart) {
      var tabs = this.tabs, indicatorsCount = this.indicators.getAmount.call(chart), firstTab;
      if (!chart) {
        return;
      }
      firstTab = tabs.addMenuItem.call(this, "add");
      tabs.addMenuItem.call(this, "edit", indicatorsCount);
      tabs.addContentItem.call(this, "add");
      tabs.addContentItem.call(this, "edit");
      tabs.switchTabs.call(this, indicatorsCount);
      tabs.selectTab.call(this, firstTab, 0);
    },
    /**
     * Create tab menu item
     * @private
     * @param {string} tabName
     * `add` or `edit`
     * @param {number} [disableTab]
     * Disable tab when 0
     * @return {Highcharts.HTMLDOMElement}
     * Created HTML tab-menu element
     */
    addMenuItem: function(tabName, disableTab) {
      var popupDiv = this.popup.container, className = PREFIX2 + "tab-item", lang2 = this.lang, menuItem;
      if (disableTab === 0) {
        className += " " + PREFIX2 + "tab-disabled";
      }
      menuItem = createElement10(SPAN, {
        className
      }, void 0, popupDiv);
      menuItem.appendChild(doc20.createTextNode(lang2[tabName + "Button"] || tabName));
      menuItem.setAttribute(PREFIX2 + "data-tab-type", tabName);
      return menuItem;
    },
    /**
     * Create tab content
     * @private
     * @return {HTMLDOMElement} - created HTML tab-content element
     */
    addContentItem: function() {
      var popupDiv = this.popup.container;
      return createElement10(DIV, {
        className: PREFIX2 + "tab-item-content " + PREFIX2 + "no-mousewheel"
        // #12100
      }, null, popupDiv);
    },
    /**
     * Add click event to each tab
     * @private
     * @param {number} disableTab
     * Disable tab when 0
     */
    switchTabs: function(disableTab) {
      var _self = this, popupDiv = this.popup.container, tabs = popupDiv.querySelectorAll("." + PREFIX2 + "tab-item"), dataParam;
      tabs.forEach(function(tab, i) {
        dataParam = tab.getAttribute(PREFIX2 + "data-tab-type");
        if (dataParam === "edit" && disableTab === 0) {
          return;
        }
        ["click", "touchstart"].forEach(function(eventName) {
          addEvent40(tab, eventName, function() {
            _self.tabs.deselectAll.call(_self);
            _self.tabs.selectTab.call(_self, this, i);
          });
        });
      });
    },
    /**
     * Set tab as visible
     * @private
     * @param {globals.Element} - current tab
     * @param {number} - Index of tab in menu
     */
    selectTab: function(tab, index) {
      var allTabs = this.popup.container.querySelectorAll("." + PREFIX2 + "tab-item-content");
      tab.className += " " + PREFIX2 + "tab-item-active";
      allTabs[index].className += " " + PREFIX2 + "tab-item-show";
    },
    /**
     * Set all tabs as invisible.
     * @private
     */
    deselectAll: function() {
      var popupDiv = this.popup.container, tabs = popupDiv.querySelectorAll("." + PREFIX2 + "tab-item"), tabsContent = popupDiv.querySelectorAll("." + PREFIX2 + "tab-item-content"), i;
      for (i = 0; i < tabs.length; i++) {
        tabs[i].classList.remove(PREFIX2 + "tab-item-active");
        tabsContent[i].classList.remove(PREFIX2 + "tab-item-show");
      }
    }
  }
};
addEvent40(NavigationBindings_default, "showPopup", function(config2) {
  if (!this.popup) {
    this.popup = new Globals_default.Popup(this.chart.container, this.chart.options.navigation.iconsURL || this.chart.options.stockTools && this.chart.options.stockTools.gui.iconsURL || "https://code.highcharts.com/9.2.2/gfx/stock-icons/", this.chart);
  }
  this.popup.showForm(config2.formType, this.chart, config2.options, config2.onSubmit);
});
addEvent40(NavigationBindings_default, "closePopup", function() {
  if (this.popup) {
    this.popup.closePopup();
  }
});
var Popup_default = Globals_default.Popup;

// node_modules/highcharts/es-modules/Extensions/Pane.js
var addEvent41 = Utilities_default.addEvent;
var extend50 = Utilities_default.extend;
var merge51 = Utilities_default.merge;
var pick59 = Utilities_default.pick;
var splat16 = Utilities_default.splat;
Chart_default.prototype.collectionsWithUpdate.push("pane");
var Pane = (
  /** @class */
  function() {
    function Pane2(options, chart) {
      this.background = void 0;
      this.center = void 0;
      this.chart = void 0;
      this.options = void 0;
      this.coll = "pane";
      this.defaultOptions = {
        /**
         * The end angle of the polar X axis or gauge value axis, given in
         * degrees where 0 is north. Defaults to [startAngle](#pane.startAngle)
         * + 360.
         *
         * @sample {highcharts} highcharts/demo/gauge-vu-meter/
         *         VU-meter with custom start and end angle
         *
         * @type      {number}
         * @since     2.3.0
         * @product   highcharts
         * @apioption pane.endAngle
         */
        /**
         * The center of a polar chart or angular gauge, given as an array
         * of [x, y] positions. Positions can be given as integers that
         * transform to pixels, or as percentages of the plot area size.
         *
         * @sample {highcharts} highcharts/demo/gauge-vu-meter/
         *         Two gauges with different center
         *
         * @type    {Array<string|number>}
         * @default ["50%", "50%"]
         * @since   2.3.0
         * @product highcharts
         */
        center: ["50%", "50%"],
        /**
         * The size of the pane, either as a number defining pixels, or a
         * percentage defining a percentage of the available plot area (the
         * smallest of the plot height or plot width).
         *
         * @sample {highcharts} highcharts/demo/gauge-vu-meter/
         *         Smaller size
         *
         * @type    {number|string}
         * @product highcharts
         */
        size: "85%",
        /**
         * The inner size of the pane, either as a number defining pixels, or a
         * percentage defining a percentage of the pane's size.
         *
         * @sample {highcharts} highcharts/series-polar/column-inverted-inner
         *         The inner size set to 20%
         *
         * @type    {number|string}
         * @product highcharts
         */
        innerSize: "0%",
        /**
         * The start angle of the polar X axis or gauge axis, given in degrees
         * where 0 is north. Defaults to 0.
         *
         * @sample {highcharts} highcharts/demo/gauge-vu-meter/
         *         VU-meter with custom start and end angle
         *
         * @since   2.3.0
         * @product highcharts
         */
        startAngle: 0
      };
      this.defaultBackgroundOptions = {
        /**
         * The class name for this background.
         *
         * @sample {highcharts} highcharts/css/pane/
         *         Panes styled by CSS
         * @sample {highstock} highcharts/css/pane/
         *         Panes styled by CSS
         * @sample {highmaps} highcharts/css/pane/
         *         Panes styled by CSS
         *
         * @type      {string}
         * @default   highcharts-pane
         * @since     5.0.0
         * @apioption pane.background.className
         */
        /**
         * The shape of the pane background. When `solid`, the background
         * is circular. When `arc`, the background extends only from the min
         * to the max of the value axis.
         *
         * @type    {Highcharts.PaneBackgroundShapeValue}
         * @since   2.3.0
         * @product highcharts
         */
        shape: "circle",
        /**
         * The pixel border width of the pane background.
         *
         * @since 2.3.0
         * @product highcharts
         */
        borderWidth: 1,
        /**
         * The pane background border color.
         *
         * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since   2.3.0
         * @product highcharts
         */
        borderColor: Palette_default.neutralColor20,
        /**
         * The background color or gradient for the pane.
         *
         * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @default { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, #ffffff], [1, #e6e6e6]] }
         * @since   2.3.0
         * @product highcharts
         */
        backgroundColor: {
          /** @ignore-option */
          linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
          /** @ignore-option */
          stops: [
            [0, Palette_default.backgroundColor],
            [1, Palette_default.neutralColor10]
          ]
        },
        /** @ignore-option */
        from: -Number.MAX_VALUE,
        /**
         * The inner radius of the pane background. Can be either numeric
         * (pixels) or a percentage string.
         *
         * @type    {number|string}
         * @since   2.3.0
         * @product highcharts
         */
        innerRadius: 0,
        /** @ignore-option */
        to: Number.MAX_VALUE,
        /**
         * The outer radius of the circular pane background. Can be either
         * numeric (pixels) or a percentage string.
         *
         * @type     {number|string}
         * @since    2.3.0
         * @product  highcharts
         */
        outerRadius: "105%"
      };
      this.init(options, chart);
    }
    Pane2.prototype.init = function(options, chart) {
      this.chart = chart;
      this.background = [];
      chart.pane.push(this);
      this.setOptions(options);
    };
    Pane2.prototype.setOptions = function(options) {
      this.options = options = merge51(this.defaultOptions, this.chart.angular ? { background: {} } : void 0, options);
    };
    Pane2.prototype.render = function() {
      var options = this.options, backgroundOption = this.options.background, renderer = this.chart.renderer, len, i;
      if (!this.group) {
        this.group = renderer.g("pane-group").attr({ zIndex: options.zIndex || 0 }).add();
      }
      this.updateCenter();
      if (backgroundOption) {
        backgroundOption = splat16(backgroundOption);
        len = Math.max(backgroundOption.length, this.background.length || 0);
        for (i = 0; i < len; i++) {
          if (backgroundOption[i] && this.axis) {
            this.renderBackground(merge51(this.defaultBackgroundOptions, backgroundOption[i]), i);
          } else if (this.background[i]) {
            this.background[i] = this.background[i].destroy();
            this.background.splice(i, 1);
          }
        }
      }
    };
    Pane2.prototype.renderBackground = function(backgroundOptions, i) {
      var method = "animate", attribs = {
        "class": "highcharts-pane " + (backgroundOptions.className || "")
      };
      if (!this.chart.styledMode) {
        extend50(attribs, {
          "fill": backgroundOptions.backgroundColor,
          "stroke": backgroundOptions.borderColor,
          "stroke-width": backgroundOptions.borderWidth
        });
      }
      if (!this.background[i]) {
        this.background[i] = this.chart.renderer.path().add(this.group);
        method = "attr";
      }
      this.background[i][method]({
        "d": this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)
      }).attr(attribs);
    };
    Pane2.prototype.updateCenter = function(axis) {
      this.center = (axis || this.axis || {}).center = CenteredSeries_default.getCenter.call(this);
    };
    Pane2.prototype.update = function(options, redraw) {
      merge51(true, this.options, options);
      this.setOptions(this.options);
      this.render();
      this.chart.axes.forEach(function(axis) {
        if (axis.pane === this) {
          axis.pane = null;
          axis.update({}, redraw);
        }
      }, this);
    };
    return Pane2;
  }()
);
function isInsidePane(x, y, center) {
  return Math.sqrt(Math.pow(x - center[0], 2) + Math.pow(y - center[1], 2)) <= center[2] / 2;
}
Chart_default.prototype.getHoverPane = function(eventArgs) {
  var chart = this;
  var hoverPane;
  if (eventArgs) {
    chart.pane.forEach(function(pane) {
      var plotX = eventArgs.chartX - chart.plotLeft, plotY = eventArgs.chartY - chart.plotTop, x = chart.inverted ? plotY : plotX, y = chart.inverted ? plotX : plotY;
      if (isInsidePane(x, y, pane.center)) {
        hoverPane = pane;
      }
    });
  }
  return hoverPane;
};
addEvent41(Chart_default, "afterIsInsidePlot", function(e2) {
  var chart = this;
  if (chart.polar) {
    e2.isInsidePlot = chart.pane.some(function(pane) {
      return isInsidePane(e2.x, e2.y, pane.center);
    });
  }
});
addEvent41(Pointer_default, "beforeGetHoverData", function(eventArgs) {
  var chart = this.chart;
  if (chart.polar) {
    chart.hoverPane = chart.getHoverPane(eventArgs);
    eventArgs.filter = function(s) {
      return s.visible && !(!eventArgs.shared && s.directTouch) && // #3821
      pick59(s.options.enableMouseTracking, true) && (!chart.hoverPane || s.xAxis.pane === chart.hoverPane);
    };
  } else {
    chart.hoverPane = void 0;
  }
});
addEvent41(Pointer_default, "afterGetHoverData", function(eventArgs) {
  var chart = this.chart;
  if (eventArgs.hoverPoint && eventArgs.hoverPoint.plotX && eventArgs.hoverPoint.plotY && chart.hoverPane && !isInsidePane(eventArgs.hoverPoint.plotX, eventArgs.hoverPoint.plotY, chart.hoverPane.center)) {
    eventArgs.hoverPoint = void 0;
  }
});
Globals_default.Pane = Pane;
var Pane_default = Globals_default.Pane;

// node_modules/highcharts/es-modules/Core/Axis/RadialAxis.js
var defaultOptions13 = DefaultOptions_default.defaultOptions;
var noop10 = Globals_default.noop;
var addEvent42 = Utilities_default.addEvent;
var correctFloat11 = Utilities_default.correctFloat;
var defined42 = Utilities_default.defined;
var extend51 = Utilities_default.extend;
var fireEvent31 = Utilities_default.fireEvent;
var merge52 = Utilities_default.merge;
var pick60 = Utilities_default.pick;
var relativeLength9 = Utilities_default.relativeLength;
var wrap6 = Utilities_default.wrap;
var RadialAxis;
(function(RadialAxis2) {
  var composedClasses2 = [];
  var defaultCircularOptions = {
    gridLineWidth: 1,
    labels: {
      align: void 0,
      distance: 15,
      x: 0,
      y: void 0,
      style: {
        textOverflow: "none"
        // wrap lines by default (#7248)
      }
    },
    maxPadding: 0,
    minPadding: 0,
    showLastLabel: false,
    tickLength: 0
  };
  var defaultRadialGaugeOptions = {
    labels: {
      align: "center",
      x: 0,
      y: void 0
      // auto
    },
    minorGridLineWidth: 0,
    minorTickInterval: "auto",
    minorTickLength: 10,
    minorTickPosition: "inside",
    minorTickWidth: 1,
    tickLength: 10,
    tickPosition: "inside",
    tickWidth: 2,
    title: {
      rotation: 0
    },
    zIndex: 2
    // behind dials, points in the series group
  };
  var defaultRadialOptions = {
    /**
     * In a polar chart, this is the angle of the Y axis in degrees, where
     * 0 is up and 90 is right. The angle determines the position of the
     * axis line and the labels, though the coordinate system is unaffected.
     * Since v8.0.0 this option is also applicable for X axis (inverted
     * polar).
     *
     * @sample {highcharts} highcharts/xaxis/angle/
     *         Custom X axis' angle on inverted polar chart
     * @sample {highcharts} highcharts/yaxis/angle/
     *         Dual axis polar chart
     *
     * @type      {number}
     * @default   0
     * @since     4.2.7
     * @product   highcharts
     * @apioption xAxis.angle
     */
    /**
     * Polar charts only. Whether the grid lines should draw as a polygon
     * with straight lines between categories, or as circles. Can be either
     * `circle` or `polygon`. Since v8.0.0 this option is also applicable
     * for X axis (inverted polar).
     *
     * @sample {highcharts} highcharts/demo/polar-spider/
     *         Polygon grid lines
     * @sample {highcharts} highcharts/xaxis/gridlineinterpolation/
     *         Circle and polygon on inverted polar
     * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/
     *         Circle and polygon
     *
     * @type       {string}
     * @product    highcharts
     * @validvalue ["circle", "polygon"]
     * @apioption  xAxis.gridLineInterpolation
     */
    gridLineInterpolation: "circle",
    gridLineWidth: 1,
    labels: {
      align: "right",
      x: -3,
      y: -2
    },
    showLastLabel: false,
    title: {
      x: 4,
      text: null,
      rotation: 90
    }
  };
  function beforeSetTickPositions() {
    this.autoConnect = this.isCircular && typeof pick60(this.userMax, this.options.max) === "undefined" && correctFloat11(this.endAngleRad - this.startAngleRad) === correctFloat11(2 * Math.PI);
    if (!this.isCircular && this.chart.inverted) {
      this.max++;
    }
    if (this.autoConnect) {
      this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0;
    }
  }
  function compose(AxisClass, TickClass) {
    if (composedClasses2.indexOf(AxisClass) === -1) {
      composedClasses2.push(AxisClass);
      addEvent42(AxisClass, "afterInit", onAxisAfterInit);
      addEvent42(AxisClass, "autoLabelAlign", onAxisAutoLabelAlign);
      addEvent42(AxisClass, "destroy", onAxisDestroy);
      addEvent42(AxisClass, "init", onAxisInit);
      addEvent42(AxisClass, "initialAxisTranslation", onAxisInitialAxisTranslation);
    }
    if (composedClasses2.indexOf(TickClass) === -1) {
      composedClasses2.push(TickClass);
      addEvent42(TickClass, "afterGetLabelPosition", onTickAfterGetLabelPosition);
      addEvent42(TickClass, "afterGetPosition", onTickAfterGetPosition);
      wrap6(TickClass.prototype, "getMarkPath", wrapTickGetMarkPath);
    }
    return AxisClass;
  }
  RadialAxis2.compose = compose;
  function createLabelCollector() {
    var _this = this;
    return function() {
      if (_this.isRadial && _this.tickPositions && // undocumented option for now, but working
      _this.options.labels && _this.options.labels.allowOverlap !== true) {
        return _this.tickPositions.map(function(pos) {
          return _this.ticks[pos] && _this.ticks[pos].label;
        }).filter(function(label) {
          return Boolean(label);
        });
      }
    };
  }
  function createLabelCollectorHidden() {
    return noop10;
  }
  function getCrosshairPosition(options, x1, y1) {
    var center = this.pane.center;
    var value = options.value, shapeArgs, end, x2, y2;
    if (this.isCircular) {
      if (!defined42(value)) {
        x2 = options.chartX || 0;
        y2 = options.chartY || 0;
        value = this.translate(Math.atan2(y2 - y1, x2 - x1) - this.startAngleRad, true);
      } else if (options.point) {
        shapeArgs = options.point.shapeArgs || {};
        if (shapeArgs.start) {
          value = this.chart.inverted ? this.translate(options.point.rectPlotY, true) : options.point.x;
        }
      }
      end = this.getPosition(value);
      x2 = end.x;
      y2 = end.y;
    } else {
      if (!defined42(value)) {
        x2 = options.chartX;
        y2 = options.chartY;
      }
      if (defined42(x2) && defined42(y2)) {
        y1 = center[1] + this.chart.plotTop;
        value = this.translate(Math.min(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), center[2] / 2) - center[3] / 2, true);
      }
    }
    return [value, x2 || 0, y2 || 0];
  }
  function getLinePath(_lineWidth, radius, innerRadius) {
    var center = this.pane.center, chart = this.chart, left = this.left || 0, top = this.top || 0;
    var end, r = pick60(radius, center[2] / 2 - this.offset), path;
    if (typeof innerRadius === "undefined") {
      innerRadius = this.horiz ? 0 : this.center && -this.center[3] / 2;
    }
    if (innerRadius) {
      r += innerRadius;
    }
    if (this.isCircular || typeof radius !== "undefined") {
      path = this.chart.renderer.symbols.arc(left + center[0], top + center[1], r, r, {
        start: this.startAngleRad,
        end: this.endAngleRad,
        open: true,
        innerR: 0
      });
      path.xBounds = [left + center[0]];
      path.yBounds = [top + center[1] - r];
    } else {
      end = this.postTranslate(this.angleRad, r);
      path = [
        ["M", this.center[0] + chart.plotLeft, this.center[1] + chart.plotTop],
        ["L", end.x, end.y]
      ];
    }
    return path;
  }
  function getOffset() {
    var axisProto = this.constructor.prototype;
    axisProto.getOffset.call(this);
    this.chart.axisOffset[this.side] = 0;
  }
  function getPlotBandPath(from, to, options) {
    var chart = this.chart, radiusToPixels = function(radius) {
      if (typeof radius === "string") {
        var r = parseInt(radius, 10);
        if (percentRegex.test(radius)) {
          r = r * fullRadius / 100;
        }
        return r;
      }
      return radius;
    }, center = this.center, startAngleRad = this.startAngleRad, fullRadius = center[2] / 2, offset3 = Math.min(this.offset, 0), left = this.left || 0, top = this.top || 0, percentRegex = /%$/, isCircular = this.isCircular;
    var start, end, angle, xOnPerimeter, open, path, outerRadius = pick60(radiusToPixels(options.outerRadius), fullRadius), innerRadius = radiusToPixels(options.innerRadius), thickness = pick60(radiusToPixels(options.thickness), 10);
    if (this.options.gridLineInterpolation === "polygon") {
      path = this.getPlotLinePath({ value: from }).concat(this.getPlotLinePath({ value: to, reverse: true }));
    } else {
      from = Math.max(from, this.min);
      to = Math.min(to, this.max);
      var transFrom = this.translate(from), transTo = this.translate(to);
      if (!isCircular) {
        outerRadius = transFrom || 0;
        innerRadius = transTo || 0;
      }
      if (options.shape === "circle" || !isCircular) {
        start = -Math.PI / 2;
        end = Math.PI * 1.5;
        open = true;
      } else {
        start = startAngleRad + (transFrom || 0);
        end = startAngleRad + (transTo || 0);
      }
      outerRadius -= offset3;
      thickness -= offset3;
      path = chart.renderer.symbols.arc(left + center[0], top + center[1], outerRadius, outerRadius, {
        // Math is for reversed yAxis (#3606)
        start: Math.min(start, end),
        end: Math.max(start, end),
        innerR: pick60(innerRadius, outerRadius - thickness),
        open
      });
      if (isCircular) {
        angle = (end + start) / 2;
        xOnPerimeter = left + center[0] + center[2] / 2 * Math.cos(angle);
        path.xBounds = angle > -Math.PI / 2 && angle < Math.PI / 2 ? (
          // Right hemisphere
          [xOnPerimeter, chart.plotWidth]
        ) : (
          // Left hemisphere
          [0, xOnPerimeter]
        );
        path.yBounds = [
          top + center[1] + center[2] / 2 * Math.sin(angle)
        ];
        path.yBounds[0] += angle > -Math.PI && angle < 0 || angle > Math.PI ? -10 : 10;
      }
    }
    return path;
  }
  function getPlotLinePath(options) {
    var _this = this;
    var center = this.pane.center, chart = this.chart, inverted = chart.inverted, reverse = options.reverse, background = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {}, innerRadius = background.innerRadius || "0%", outerRadius = background.outerRadius || "100%", x1 = center[0] + chart.plotLeft, y1 = center[1] + chart.plotTop, height = this.height, isCrosshair = options.isCrosshair, paneInnerR = center[3] / 2;
    var value = options.value, innerRatio, distance, a, b, otherAxis, xy, tickPositions, crossPos, path;
    var end = this.getPosition(value);
    var x2 = end.x, y2 = end.y;
    if (isCrosshair) {
      crossPos = this.getCrosshairPosition(options, x1, y1);
      value = crossPos[0];
      x2 = crossPos[1];
      y2 = crossPos[2];
    }
    if (this.isCircular) {
      distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      a = typeof innerRadius === "string" ? relativeLength9(innerRadius, 1) : innerRadius / distance;
      b = typeof outerRadius === "string" ? relativeLength9(outerRadius, 1) : outerRadius / distance;
      if (center && paneInnerR) {
        innerRatio = paneInnerR / distance;
        if (a < innerRatio) {
          a = innerRatio;
        }
        if (b < innerRatio) {
          b = innerRatio;
        }
      }
      path = [
        ["M", x1 + a * (x2 - x1), y1 - a * (y1 - y2)],
        ["L", x2 - (1 - b) * (x2 - x1), y2 + (1 - b) * (y1 - y2)]
      ];
    } else {
      value = this.translate(value);
      if (value) {
        if (value < 0 || value > height) {
          value = 0;
        }
      }
      if (this.options.gridLineInterpolation === "circle") {
        path = this.getLinePath(0, value, paneInnerR);
      } else {
        path = [];
        chart[inverted ? "yAxis" : "xAxis"].forEach(function(a2) {
          if (a2.pane === _this.pane) {
            otherAxis = a2;
          }
        });
        if (otherAxis) {
          tickPositions = otherAxis.tickPositions;
          if (otherAxis.autoConnect) {
            tickPositions = tickPositions.concat([tickPositions[0]]);
          }
          if (reverse) {
            tickPositions = tickPositions.slice().reverse();
          }
          if (value) {
            value += paneInnerR;
          }
          for (var i = 0; i < tickPositions.length; i++) {
            xy = otherAxis.getPosition(tickPositions[i], value);
            path.push(i ? ["L", xy.x, xy.y] : ["M", xy.x, xy.y]);
          }
        }
      }
    }
    return path;
  }
  function getPosition(value, length) {
    var translatedVal = this.translate(value);
    return this.postTranslate(
      this.isCircular ? translatedVal : this.angleRad,
      // #2848
      // In case when translatedVal is negative, the 0 value must be
      // used instead, in order to deal with lines and labels that
      // fall out of the visible range near the center of a pane
      pick60(this.isCircular ? length : translatedVal < 0 ? 0 : translatedVal, this.center[2] / 2) - this.offset
    );
  }
  function getTitlePosition() {
    var center = this.center, chart = this.chart, titleOptions = this.options.title;
    return {
      x: chart.plotLeft + center[0] + (titleOptions.x || 0),
      y: chart.plotTop + center[1] - {
        high: 0.5,
        middle: 0.25,
        low: 0
      }[titleOptions.align] * center[2] + (titleOptions.y || 0)
    };
  }
  function modify(axis) {
    axis.beforeSetTickPositions = beforeSetTickPositions;
    axis.createLabelCollector = createLabelCollector;
    axis.getCrosshairPosition = getCrosshairPosition;
    axis.getLinePath = getLinePath;
    axis.getOffset = getOffset;
    axis.getPlotBandPath = getPlotBandPath;
    axis.getPlotLinePath = getPlotLinePath;
    axis.getPosition = getPosition;
    axis.getTitlePosition = getTitlePosition;
    axis.postTranslate = postTranslate;
    axis.setAxisSize = setAxisSize;
    axis.setAxisTranslation = setAxisTranslation;
    axis.setOptions = setOptions4;
  }
  function modifyAsHidden(radialAxis) {
    radialAxis.isHidden = true;
    radialAxis.createLabelCollector = createLabelCollectorHidden;
    radialAxis.getOffset = noop10;
    radialAxis.redraw = renderHidden;
    radialAxis.render = renderHidden;
    radialAxis.setScale = noop10;
    radialAxis.setCategories = noop10;
    radialAxis.setTitle = noop10;
  }
  function onAxisAfterInit() {
    var chart = this.chart, options = this.options, isHidden = chart.angular && this.isXAxis, pane = this.pane, paneOptions = pane && pane.options;
    if (!isHidden && pane && (chart.angular || chart.polar)) {
      this.angleRad = (options.angle || 0) * Math.PI / 180;
      this.startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;
      this.endAngleRad = (pick60(paneOptions.endAngle, paneOptions.startAngle + 360) - 90) * Math.PI / 180;
      this.offset = options.offset || 0;
    }
  }
  function onAxisAutoLabelAlign(e2) {
    if (this.isRadial) {
      e2.align = void 0;
      e2.preventDefault();
    }
  }
  function onAxisDestroy() {
    if (this.chart && this.chart.labelCollectors) {
      var index = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;
      if (index >= 0) {
        this.chart.labelCollectors.splice(index, 1);
      }
    }
  }
  function onAxisInit(e2) {
    var chart = this.chart, inverted = chart.inverted, angular = chart.angular, polar = chart.polar, isX = this.isXAxis, coll = this.coll, isHidden = angular && isX, chartOptions = chart.options, paneIndex = e2.userOptions.pane || 0, pane = this.pane = chart.pane && chart.pane[paneIndex];
    var isCircular;
    if (coll === "colorAxis") {
      this.isRadial = false;
      return;
    }
    if (angular) {
      if (isHidden) {
        modifyAsHidden(this);
      } else {
        modify(this);
      }
      isCircular = !isX;
      if (isCircular) {
        this.defaultPolarOptions = defaultRadialGaugeOptions;
      }
    } else if (polar) {
      modify(this);
      isCircular = this.horiz;
      this.defaultPolarOptions = isCircular ? defaultCircularOptions : merge52(coll === "xAxis" ? AxisDefaults_default.defaultXAxisOptions : AxisDefaults_default.defaultYAxisOptions, defaultRadialOptions);
      if (inverted && coll === "yAxis") {
        this.defaultPolarOptions.stackLabels = AxisDefaults_default.defaultYAxisOptions.stackLabels;
        this.defaultPolarOptions.reversedStacks = true;
      }
    }
    if (angular || polar) {
      this.isRadial = true;
      chartOptions.chart.zoomType = null;
      if (!this.labelCollector) {
        this.labelCollector = this.createLabelCollector();
      }
      if (this.labelCollector) {
        chart.labelCollectors.push(this.labelCollector);
      }
    } else {
      this.isRadial = false;
    }
    if (pane && isCircular) {
      pane.axis = this;
    }
    this.isCircular = isCircular;
  }
  function onAxisInitialAxisTranslation() {
    if (this.isRadial) {
      this.beforeSetTickPositions();
    }
  }
  function onTickAfterGetLabelPosition(e2) {
    var label = this.label;
    if (!label) {
      return;
    }
    var axis = this.axis, labelBBox = label.getBBox(), labelOptions = axis.options.labels, angle = (axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360, correctAngle = Math.round(angle), labelYPosCorrection = !defined42(labelOptions.y) ? -labelBBox.height * 0.3 : 0;
    var optionsY = labelOptions.y, ret, centerSlot = 20, align = labelOptions.align, labelDir = "end", reducedAngle1 = correctAngle < 0 ? correctAngle + 360 : correctAngle, reducedAngle2 = reducedAngle1, translateY = 0, translateX = 0;
    if (axis.isRadial) {
      ret = axis.getPosition(this.pos, axis.center[2] / 2 + relativeLength9(pick60(labelOptions.distance, -25), axis.center[2] / 2, -axis.center[2] / 2));
      if (labelOptions.rotation === "auto") {
        label.attr({
          rotation: angle
        });
      } else if (!defined42(optionsY)) {
        optionsY = axis.chart.renderer.fontMetrics(label.styles && label.styles.fontSize).b - labelBBox.height / 2;
      }
      if (!defined42(align)) {
        if (axis.isCircular) {
          if (labelBBox.width > axis.len * axis.tickInterval / (axis.max - axis.min)) {
            centerSlot = 0;
          }
          if (angle > centerSlot && angle < 180 - centerSlot) {
            align = "left";
          } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {
            align = "right";
          } else {
            align = "center";
          }
        } else {
          align = "center";
        }
        label.attr({
          align
        });
      }
      if (align === "auto" && axis.tickPositions.length === 2 && axis.isCircular) {
        if (reducedAngle1 > 90 && reducedAngle1 < 180) {
          reducedAngle1 = 180 - reducedAngle1;
        } else if (reducedAngle1 > 270 && reducedAngle1 <= 360) {
          reducedAngle1 = 540 - reducedAngle1;
        }
        if (reducedAngle2 > 180 && reducedAngle2 <= 360) {
          reducedAngle2 = 360 - reducedAngle2;
        }
        if (axis.pane.options.startAngle === correctAngle || axis.pane.options.startAngle === correctAngle + 360 || axis.pane.options.startAngle === correctAngle - 360) {
          labelDir = "start";
        }
        if (correctAngle >= -90 && correctAngle <= 90 || correctAngle >= -360 && correctAngle <= -270 || correctAngle >= 270 && correctAngle <= 360) {
          align = labelDir === "start" ? "right" : "left";
        } else {
          align = labelDir === "start" ? "left" : "right";
        }
        if (reducedAngle2 > 70 && reducedAngle2 < 110) {
          align = "center";
        }
        if (reducedAngle1 < 15 || reducedAngle1 >= 180 && reducedAngle1 < 195) {
          translateY = labelBBox.height * 0.3;
        } else if (reducedAngle1 >= 15 && reducedAngle1 <= 35) {
          translateY = labelDir === "start" ? 0 : labelBBox.height * 0.75;
        } else if (reducedAngle1 >= 195 && reducedAngle1 <= 215) {
          translateY = labelDir === "start" ? labelBBox.height * 0.75 : 0;
        } else if (reducedAngle1 > 35 && reducedAngle1 <= 90) {
          translateY = labelDir === "start" ? -labelBBox.height * 0.25 : labelBBox.height;
        } else if (reducedAngle1 > 215 && reducedAngle1 <= 270) {
          translateY = labelDir === "start" ? labelBBox.height : -labelBBox.height * 0.25;
        }
        if (reducedAngle2 < 15) {
          translateX = labelDir === "start" ? -labelBBox.height * 0.15 : labelBBox.height * 0.15;
        } else if (reducedAngle2 > 165 && reducedAngle2 <= 180) {
          translateX = labelDir === "start" ? labelBBox.height * 0.15 : -labelBBox.height * 0.15;
        }
        label.attr({ align });
        label.translate(translateX, translateY + labelYPosCorrection);
      }
      e2.pos.x = ret.x + (labelOptions.x || 0);
      e2.pos.y = ret.y + (optionsY || 0);
    }
  }
  function onTickAfterGetPosition(e2) {
    if (this.axis.getPosition) {
      extend51(e2.pos, this.axis.getPosition(this.pos));
    }
  }
  function postTranslate(angle, radius) {
    var chart = this.chart, center = this.center;
    angle = this.startAngleRad + angle;
    return {
      x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
      y: chart.plotTop + center[1] + Math.sin(angle) * radius
    };
  }
  function renderHidden() {
    this.isDirty = false;
  }
  function setAxisSize() {
    var axisProto = this.constructor.prototype;
    var center, start;
    axisProto.setAxisSize.call(this);
    if (this.isRadial) {
      this.pane.updateCenter(this);
      center = this.center = this.pane.center.slice();
      if (this.isCircular) {
        this.sector = this.endAngleRad - this.startAngleRad;
      } else {
        start = this.postTranslate(this.angleRad, center[3] / 2);
        center[0] = start.x - this.chart.plotLeft;
        center[1] = start.y - this.chart.plotTop;
      }
      this.len = this.width = this.height = (center[2] - center[3]) * pick60(this.sector, 1) / 2;
    }
  }
  function setAxisTranslation() {
    var axisProto = this.constructor.prototype;
    axisProto.setAxisTranslation.call(this);
    if (this.center) {
      if (this.isCircular) {
        this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1);
      } else {
        this.transA = (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1);
      }
      if (this.isXAxis) {
        this.minPixelPadding = this.transA * this.minPointOffset;
      } else {
        this.minPixelPadding = 0;
      }
    }
  }
  function setOptions4(userOptions) {
    var options = this.options = merge52(
      this.constructor.defaultOptions,
      this.defaultPolarOptions,
      defaultOptions13[this.coll],
      // #16112
      userOptions
    );
    if (!options.plotBands) {
      options.plotBands = [];
    }
    fireEvent31(this, "afterSetOptions");
  }
  function wrapTickGetMarkPath(proceed, x, y, tickLength, tickWidth, horiz, renderer) {
    var axis = this.axis;
    var endPoint, ret;
    if (axis.isRadial) {
      endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);
      ret = [
        "M",
        x,
        y,
        "L",
        endPoint.x,
        endPoint.y
      ];
    } else {
      ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);
    }
    return ret;
  }
})(RadialAxis || (RadialAxis = {}));
var RadialAxis_default = RadialAxis;

// node_modules/highcharts/es-modules/Series/AreaRange/AreaRangePoint.js
var __extends20 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var pointProto = Point_default.prototype;
var defined43 = Utilities_default.defined;
var isNumber36 = Utilities_default.isNumber;
var AreaRangePoint = (
  /** @class */
  function(_super) {
    __extends20(AreaRangePoint3, _super);
    function AreaRangePoint3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.high = void 0;
      _this.low = void 0;
      _this.options = void 0;
      _this.plotHigh = void 0;
      _this.plotLow = void 0;
      _this.plotHighX = void 0;
      _this.plotLowX = void 0;
      _this.plotX = void 0;
      _this.series = void 0;
      return _this;
    }
    AreaRangePoint3.prototype.setState = function() {
      var prevState = this.state, series = this.series, isPolar = series.chart.polar;
      if (!defined43(this.plotHigh)) {
        this.plotHigh = series.yAxis.toPixels(this.high, true);
      }
      if (!defined43(this.plotLow)) {
        this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);
      }
      if (series.stateMarkerGraphic) {
        series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
        series.stateMarkerGraphic = series.upperStateMarkerGraphic;
      }
      this.graphic = this.upperGraphic;
      this.plotY = this.plotHigh;
      if (isPolar) {
        this.plotX = this.plotHighX;
      }
      pointProto.setState.apply(this, arguments);
      this.state = prevState;
      this.plotY = this.plotLow;
      this.graphic = this.lowerGraphic;
      if (isPolar) {
        this.plotX = this.plotLowX;
      }
      if (series.stateMarkerGraphic) {
        series.upperStateMarkerGraphic = series.stateMarkerGraphic;
        series.stateMarkerGraphic = series.lowerStateMarkerGraphic;
        series.lowerStateMarkerGraphic = void 0;
      }
      pointProto.setState.apply(this, arguments);
    };
    AreaRangePoint3.prototype.haloPath = function() {
      var isPolar = this.series.chart.polar, path = [];
      this.plotY = this.plotLow;
      if (isPolar) {
        this.plotX = this.plotLowX;
      }
      if (this.isInside) {
        path = pointProto.haloPath.apply(this, arguments);
      }
      this.plotY = this.plotHigh;
      if (isPolar) {
        this.plotX = this.plotHighX;
      }
      if (this.isTopInside) {
        path = path.concat(pointProto.haloPath.apply(this, arguments));
      }
      return path;
    };
    AreaRangePoint3.prototype.isValid = function() {
      return isNumber36(this.low) && isNumber36(this.high);
    };
    return AreaRangePoint3;
  }(AreaSeries_default.prototype.pointClass)
);
var AreaRangePoint_default = AreaRangePoint;

// node_modules/highcharts/es-modules/Series/AreaRange/AreaRangeSeries.js
var __extends21 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var areaProto2 = AreaSeries_default.prototype;
var columnProto2 = ColumnSeries_default.prototype;
var noop11 = Globals_default.noop;
var seriesProto3 = Series_default.prototype;
var defined44 = Utilities_default.defined;
var extend52 = Utilities_default.extend;
var isArray19 = Utilities_default.isArray;
var pick61 = Utilities_default.pick;
var merge53 = Utilities_default.merge;
var AreaRangeSeries = (
  /** @class */
  function(_super) {
    __extends21(AreaRangeSeries4, _super);
    function AreaRangeSeries4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.lowerStateMarkerGraphic = void 0;
      _this.xAxis = void 0;
      return _this;
    }
    AreaRangeSeries4.prototype.toYData = function(point) {
      return [point.low, point.high];
    };
    AreaRangeSeries4.prototype.highToXY = function(point) {
      var chart = this.chart, xy = this.xAxis.postTranslate(point.rectPlotX || 0, this.yAxis.len - point.plotHigh);
      point.plotHighX = xy.x - chart.plotLeft;
      point.plotHigh = xy.y - chart.plotTop;
      point.plotLowX = point.plotX;
    };
    AreaRangeSeries4.prototype.translate = function() {
      var series = this, yAxis = series.yAxis, hasModifyValue = !!series.modifyValue;
      areaProto2.translate.apply(series);
      series.points.forEach(function(point) {
        var high = point.high, plotY = point.plotY;
        if (point.isNull) {
          point.plotY = null;
        } else {
          point.plotLow = plotY;
          point.plotHigh = yAxis.translate(hasModifyValue ? series.modifyValue(high, point) : high, 0, 1, 0, 1);
          if (hasModifyValue) {
            point.yBottom = point.plotHigh;
          }
        }
      });
      if (this.chart.polar) {
        this.points.forEach(function(point) {
          series.highToXY(point);
          point.tooltipPos = [
            (point.plotHighX + point.plotLowX) / 2,
            (point.plotHigh + point.plotLow) / 2
          ];
        });
      }
    };
    AreaRangeSeries4.prototype.getGraphPath = function(points) {
      var highPoints = [], highAreaPoints = [], i, getGraphPath = areaProto2.getGraphPath, point, pointShim, linePath, lowerPath, options = this.options, polar = this.chart.polar, connectEnds = polar && options.connectEnds !== false, connectNulls = options.connectNulls, step = options.step, higherPath, higherAreaPath;
      points = points || this.points;
      i = points.length;
      while (i--) {
        point = points[i];
        var highAreaPoint = polar ? {
          plotX: point.rectPlotX,
          plotY: point.yBottom,
          doCurve: false
          // #5186, gaps in areasplinerange fill
        } : {
          plotX: point.plotX,
          plotY: point.plotY,
          doCurve: false
          // #5186, gaps in areasplinerange fill
        };
        if (!point.isNull && !connectEnds && !connectNulls && (!points[i + 1] || points[i + 1].isNull)) {
          highAreaPoints.push(highAreaPoint);
        }
        pointShim = {
          polarPlotY: point.polarPlotY,
          rectPlotX: point.rectPlotX,
          yBottom: point.yBottom,
          // plotHighX is for polar charts
          plotX: pick61(point.plotHighX, point.plotX),
          plotY: point.plotHigh,
          isNull: point.isNull
        };
        highAreaPoints.push(pointShim);
        highPoints.push(pointShim);
        if (!point.isNull && !connectEnds && !connectNulls && (!points[i - 1] || points[i - 1].isNull)) {
          highAreaPoints.push(highAreaPoint);
        }
      }
      lowerPath = getGraphPath.call(this, points);
      if (step) {
        if (step === true) {
          step = "left";
        }
        options.step = {
          left: "right",
          center: "center",
          right: "left"
        }[step];
      }
      higherPath = getGraphPath.call(this, highPoints);
      higherAreaPath = getGraphPath.call(this, highAreaPoints);
      options.step = step;
      linePath = [].concat(lowerPath, higherPath);
      if (!this.chart.polar && higherAreaPath[0] && higherAreaPath[0][0] === "M") {
        higherAreaPath[0] = ["L", higherAreaPath[0][1], higherAreaPath[0][2]];
      }
      this.graphPath = linePath;
      this.areaPath = lowerPath.concat(higherAreaPath);
      linePath.isArea = true;
      linePath.xMap = lowerPath.xMap;
      this.areaPath.xMap = lowerPath.xMap;
      return linePath;
    };
    AreaRangeSeries4.prototype.drawDataLabels = function() {
      var data = this.points, length = data.length, i, originalDataLabels = [], dataLabelOptions = this.options.dataLabels, point, up, inverted = this.chart.inverted, upperDataLabelOptions, lowerDataLabelOptions;
      if (dataLabelOptions) {
        if (isArray19(dataLabelOptions)) {
          upperDataLabelOptions = dataLabelOptions[0] || { enabled: false };
          lowerDataLabelOptions = dataLabelOptions[1] || { enabled: false };
        } else {
          upperDataLabelOptions = extend52({}, dataLabelOptions);
          upperDataLabelOptions.x = dataLabelOptions.xHigh;
          upperDataLabelOptions.y = dataLabelOptions.yHigh;
          lowerDataLabelOptions = extend52({}, dataLabelOptions);
          lowerDataLabelOptions.x = dataLabelOptions.xLow;
          lowerDataLabelOptions.y = dataLabelOptions.yLow;
        }
        if (upperDataLabelOptions.enabled || this._hasPointLabels) {
          i = length;
          while (i--) {
            point = data[i];
            if (point) {
              up = upperDataLabelOptions.inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;
              point.y = point.high;
              point._plotY = point.plotY;
              point.plotY = point.plotHigh;
              originalDataLabels[i] = point.dataLabel;
              point.dataLabel = point.dataLabelUpper;
              point.below = up;
              if (inverted) {
                if (!upperDataLabelOptions.align) {
                  upperDataLabelOptions.align = up ? "right" : "left";
                }
              } else {
                if (!upperDataLabelOptions.verticalAlign) {
                  upperDataLabelOptions.verticalAlign = up ? "top" : "bottom";
                }
              }
            }
          }
          this.options.dataLabels = upperDataLabelOptions;
          if (seriesProto3.drawDataLabels) {
            seriesProto3.drawDataLabels.apply(this, arguments);
          }
          i = length;
          while (i--) {
            point = data[i];
            if (point) {
              point.dataLabelUpper = point.dataLabel;
              point.dataLabel = originalDataLabels[i];
              delete point.dataLabels;
              point.y = point.low;
              point.plotY = point._plotY;
            }
          }
        }
        if (lowerDataLabelOptions.enabled || this._hasPointLabels) {
          i = length;
          while (i--) {
            point = data[i];
            if (point) {
              up = lowerDataLabelOptions.inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;
              point.below = !up;
              if (inverted) {
                if (!lowerDataLabelOptions.align) {
                  lowerDataLabelOptions.align = up ? "left" : "right";
                }
              } else {
                if (!lowerDataLabelOptions.verticalAlign) {
                  lowerDataLabelOptions.verticalAlign = up ? "bottom" : "top";
                }
              }
            }
          }
          this.options.dataLabels = lowerDataLabelOptions;
          if (seriesProto3.drawDataLabels) {
            seriesProto3.drawDataLabels.apply(this, arguments);
          }
        }
        if (upperDataLabelOptions.enabled) {
          i = length;
          while (i--) {
            point = data[i];
            if (point) {
              point.dataLabels = [
                point.dataLabelUpper,
                point.dataLabel
              ].filter(function(label) {
                return !!label;
              });
            }
          }
        }
        this.options.dataLabels = dataLabelOptions;
      }
    };
    AreaRangeSeries4.prototype.alignDataLabel = function() {
      columnProto2.alignDataLabel.apply(this, arguments);
    };
    AreaRangeSeries4.prototype.drawPoints = function() {
      var series = this, pointLength = series.points.length, point, i;
      seriesProto3.drawPoints.apply(series, arguments);
      i = 0;
      while (i < pointLength) {
        point = series.points[i];
        point.origProps = {
          plotY: point.plotY,
          plotX: point.plotX,
          isInside: point.isInside,
          negative: point.negative,
          zone: point.zone,
          y: point.y
        };
        point.lowerGraphic = point.graphic;
        point.graphic = point.upperGraphic;
        point.plotY = point.plotHigh;
        if (defined44(point.plotHighX)) {
          point.plotX = point.plotHighX;
        }
        point.y = pick61(point.high, point.origProps.y);
        point.negative = point.y < (series.options.threshold || 0);
        if (series.zones.length) {
          point.zone = point.getZone();
        }
        if (!series.chart.polar) {
          point.isInside = point.isTopInside = typeof point.plotY !== "undefined" && point.plotY >= 0 && point.plotY <= series.yAxis.len && // #3519
          point.plotX >= 0 && point.plotX <= series.xAxis.len;
        }
        i++;
      }
      seriesProto3.drawPoints.apply(series, arguments);
      i = 0;
      while (i < pointLength) {
        point = series.points[i];
        point.upperGraphic = point.graphic;
        point.graphic = point.lowerGraphic;
        if (point.origProps) {
          extend52(point, point.origProps);
          delete point.origProps;
        }
        i++;
      }
    };
    AreaRangeSeries4.defaultOptions = merge53(AreaSeries_default.defaultOptions, {
      /**
       * @see [fillColor](#plotOptions.arearange.fillColor)
       * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
       *
       * @apioption plotOptions.arearange.color
       */
      /**
       * @default   low
       * @apioption plotOptions.arearange.colorKey
       */
      /**
       * @see [color](#plotOptions.arearange.color)
       * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
       *
       * @apioption plotOptions.arearange.fillColor
       */
      /**
       * @see [color](#plotOptions.arearange.color)
       * @see [fillColor](#plotOptions.arearange.fillColor)
       *
       * @default   {highcharts} 0.75
       * @default   {highstock} 0.75
       * @apioption plotOptions.arearange.fillOpacity
       */
      /**
       * Whether to apply a drop shadow to the graph line. Since 2.3 the
       * shadow can be an object configuration containing `color`, `offsetX`,
       * `offsetY`, `opacity` and `width`.
       *
       * @type      {boolean|Highcharts.ShadowOptionsObject}
       * @product   highcharts
       * @apioption plotOptions.arearange.shadow
       */
      /**
       * Pixel width of the arearange graph line.
       *
       * @since 2.3.0
       *
       * @private
       */
      lineWidth: 1,
      threshold: null,
      tooltip: {
        pointFormat: '<span style="color:{series.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
      },
      /**
       * Whether the whole area or just the line should respond to mouseover
       * tooltips and other mouse or touch events.
       *
       * @since 2.3.0
       *
       * @private
       */
      trackByArea: true,
      /**
       * Extended data labels for range series types. Range series data
       * labels use no `x` and `y` options. Instead, they have `xLow`,
       * `xHigh`, `yLow` and `yHigh` options to allow the higher and lower
       * data label sets individually.
       *
       * @declare Highcharts.SeriesAreaRangeDataLabelsOptionsObject
       * @exclude x, y
       * @since   2.3.0
       * @product highcharts highstock
       *
       * @private
       */
      dataLabels: {
        align: void 0,
        verticalAlign: void 0,
        /**
         * X offset of the lower data labels relative to the point value.
         *
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         */
        xLow: 0,
        /**
         * X offset of the higher data labels relative to the point value.
         *
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         */
        xHigh: 0,
        /**
         * Y offset of the lower data labels relative to the point value.
         *
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         */
        yLow: 0,
        /**
         * Y offset of the higher data labels relative to the point value.
         *
         * @sample highcharts/plotoptions/arearange-datalabels/
         *         Data labels on range series
         */
        yHigh: 0
      }
    });
    return AreaRangeSeries4;
  }(AreaSeries_default)
);
extend52(AreaRangeSeries.prototype, {
  pointArrayMap: ["low", "high"],
  pointValKey: "low",
  deferTranslatePolar: true,
  pointClass: AreaRangePoint_default,
  setStackedPoints: noop11
});
SeriesRegistry_default.registerSeriesType("arearange", AreaRangeSeries);
var AreaRangeSeries_default = AreaRangeSeries;

// node_modules/highcharts/es-modules/Series/AreaSplineRange/AreaSplineRangeSeries.js
var __extends22 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SplineSeries2 = SeriesRegistry_default.seriesTypes.spline;
var merge54 = Utilities_default.merge;
var extend53 = Utilities_default.extend;
var AreaSplineRangeSeries = (
  /** @class */
  function(_super) {
    __extends22(AreaSplineRangeSeries2, _super);
    function AreaSplineRangeSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.data = void 0;
      _this.points = void 0;
      return _this;
    }
    AreaSplineRangeSeries2.defaultOptions = merge54(AreaRangeSeries_default.defaultOptions);
    return AreaSplineRangeSeries2;
  }(AreaRangeSeries_default)
);
extend53(AreaSplineRangeSeries.prototype, {
  getPointSpline: SplineSeries2.prototype.getPointSpline
});
SeriesRegistry_default.registerSeriesType("areasplinerange", AreaSplineRangeSeries);

// node_modules/highcharts/es-modules/Series/BoxPlot/BoxPlotSeries.js
var __extends23 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop12 = Globals_default.noop;
var extend54 = Utilities_default.extend;
var merge55 = Utilities_default.merge;
var pick62 = Utilities_default.pick;
var BoxPlotSeries = (
  /** @class */
  function(_super) {
    __extends23(BoxPlotSeries2, _super);
    function BoxPlotSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    BoxPlotSeries2.prototype.pointAttribs = function() {
      return {};
    };
    BoxPlotSeries2.prototype.translate = function() {
      var series = this, yAxis = series.yAxis, pointArrayMap = series.pointArrayMap;
      _super.prototype.translate.apply(series);
      series.points.forEach(function(point) {
        pointArrayMap.forEach(function(key) {
          if (point[key] !== null) {
            point[key + "Plot"] = yAxis.translate(point[key], 0, 1, 0, 1);
          }
        });
        point.plotHigh = point.highPlot;
      });
    };
    BoxPlotSeries2.prototype.drawPoints = function() {
      var series = this, points = series.points, options = series.options, chart = series.chart, renderer = chart.renderer, q1Plot, q3Plot, highPlot, lowPlot, medianPlot, medianPath, crispCorr, crispX = 0, boxPath, width, left, right, halfWidth, doQuartiles = series.doQuartiles !== false, pointWiskerLength, whiskerLength = series.options.whiskerLength;
      points.forEach(function(point) {
        var graphic = point.graphic, verb = graphic ? "animate" : "attr", shapeArgs = point.shapeArgs, boxAttr = {}, stemAttr = {}, whiskersAttr = {}, medianAttr = {}, color18 = point.color || series.color;
        if (typeof point.plotY !== "undefined") {
          width = Math.round(shapeArgs.width);
          left = Math.floor(shapeArgs.x);
          right = left + width;
          halfWidth = Math.round(width / 2);
          q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);
          q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);
          highPlot = Math.floor(point.highPlot);
          lowPlot = Math.floor(point.lowPlot);
          if (!graphic) {
            point.graphic = graphic = renderer.g("point").add(series.group);
            point.stem = renderer.path().addClass("highcharts-boxplot-stem").add(graphic);
            if (whiskerLength) {
              point.whiskers = renderer.path().addClass("highcharts-boxplot-whisker").add(graphic);
            }
            if (doQuartiles) {
              point.box = renderer.path(boxPath).addClass("highcharts-boxplot-box").add(graphic);
            }
            point.medianShape = renderer.path(medianPath).addClass("highcharts-boxplot-median").add(graphic);
          }
          if (!chart.styledMode) {
            stemAttr.stroke = point.stemColor || options.stemColor || color18;
            stemAttr["stroke-width"] = pick62(point.stemWidth, options.stemWidth, options.lineWidth);
            stemAttr.dashstyle = point.stemDashStyle || options.stemDashStyle || options.dashStyle;
            point.stem.attr(stemAttr);
            if (whiskerLength) {
              whiskersAttr.stroke = point.whiskerColor || options.whiskerColor || color18;
              whiskersAttr["stroke-width"] = pick62(point.whiskerWidth, options.whiskerWidth, options.lineWidth);
              whiskersAttr.dashstyle = point.whiskerDashStyle || options.whiskerDashStyle || options.dashStyle;
              point.whiskers.attr(whiskersAttr);
            }
            if (doQuartiles) {
              boxAttr.fill = point.fillColor || options.fillColor || color18;
              boxAttr.stroke = options.lineColor || color18;
              boxAttr["stroke-width"] = options.lineWidth || 0;
              boxAttr.dashstyle = point.boxDashStyle || options.boxDashStyle || options.dashStyle;
              point.box.attr(boxAttr);
            }
            medianAttr.stroke = point.medianColor || options.medianColor || color18;
            medianAttr["stroke-width"] = pick62(point.medianWidth, options.medianWidth, options.lineWidth);
            medianAttr.dashstyle = point.medianDashStyle || options.medianDashStyle || options.dashStyle;
            point.medianShape.attr(medianAttr);
          }
          var d = void 0;
          crispCorr = point.stem.strokeWidth() % 2 / 2;
          crispX = left + halfWidth + crispCorr;
          d = [
            // stem up
            ["M", crispX, q3Plot],
            ["L", crispX, highPlot],
            // stem down
            ["M", crispX, q1Plot],
            ["L", crispX, lowPlot]
          ];
          point.stem[verb]({ d });
          if (doQuartiles) {
            crispCorr = point.box.strokeWidth() % 2 / 2;
            q1Plot = Math.floor(q1Plot) + crispCorr;
            q3Plot = Math.floor(q3Plot) + crispCorr;
            left += crispCorr;
            right += crispCorr;
            d = [
              ["M", left, q3Plot],
              ["L", left, q1Plot],
              ["L", right, q1Plot],
              ["L", right, q3Plot],
              ["L", left, q3Plot],
              ["Z"]
            ];
            point.box[verb]({ d });
          }
          if (whiskerLength) {
            crispCorr = point.whiskers.strokeWidth() % 2 / 2;
            highPlot = highPlot + crispCorr;
            lowPlot = lowPlot + crispCorr;
            pointWiskerLength = /%$/.test(whiskerLength) ? halfWidth * parseFloat(whiskerLength) / 100 : whiskerLength / 2;
            d = [
              // High whisker
              ["M", crispX - pointWiskerLength, highPlot],
              ["L", crispX + pointWiskerLength, highPlot],
              // Low whisker
              ["M", crispX - pointWiskerLength, lowPlot],
              ["L", crispX + pointWiskerLength, lowPlot]
            ];
            point.whiskers[verb]({ d });
          }
          medianPlot = Math.round(point.medianPlot);
          crispCorr = point.medianShape.strokeWidth() % 2 / 2;
          medianPlot = medianPlot + crispCorr;
          d = [
            ["M", left, medianPlot],
            ["L", right, medianPlot]
          ];
          point.medianShape[verb]({ d });
        }
      });
    };
    BoxPlotSeries2.prototype.toYData = function(point) {
      return [point.low, point.q1, point.median, point.q3, point.high];
    };
    BoxPlotSeries2.defaultOptions = merge55(ColumnSeries_default.defaultOptions, {
      threshold: null,
      tooltip: {
        pointFormat: '<span style="color:{point.color}"></span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'
      },
      /**
       * The length of the whiskers, the horizontal lines marking low and
       * high values. It can be a numerical pixel value, or a percentage
       * value of the box width. Set `0` to disable whiskers.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         True by default
       *
       * @type    {number|string}
       * @since   3.0
       * @product highcharts
       */
      whiskerLength: "50%",
      /**
       * The fill color of the box.
       *
       * In styled mode, the fill color can be set with the
       * `.highcharts-boxplot-box` class.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default #ffffff
       * @since   3.0
       * @product highcharts
       */
      fillColor: Palette_default.backgroundColor,
      /**
       * The width of the line surrounding the box. If any of
       * [stemWidth](#plotOptions.boxplot.stemWidth),
       * [medianWidth](#plotOptions.boxplot.medianWidth)
       * or [whiskerWidth](#plotOptions.boxplot.whiskerWidth) are `null`,
       * the lineWidth also applies to these lines.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
       *         Error bar styling
       *
       * @since   3.0
       * @product highcharts
       */
      lineWidth: 1,
      /**
       * The color of the median line. If `undefined`, the general series
       * color applies.
       *
       * In styled mode, the median stroke width can be set with the
       * `.highcharts-boxplot-median` class.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/css/boxplot/
       *         Box plot in styled mode
       * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
       *         Error bar styling
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject}
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.boxplot.medianColor
       */
      /**
       * The pixel width of the median line. If `null`, the
       * [lineWidth](#plotOptions.boxplot.lineWidth) is used.
       *
       * In styled mode, the median stroke width can be set with the
       * `.highcharts-boxplot-median` class.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/css/boxplot/
       *         Box plot in styled mode
       *
       * @type    {number|null}
       * @since   3.0
       * @product highcharts
       */
      medianWidth: 2,
      /*
              // States are not working and are removed from docs.
              // Refer to: #2340
              states: {
                  hover: {
                      brightness: -0.3
                  }
              },
      
              /**
               * The color of the stem, the vertical line extending from the box to
               * the whiskers. If `undefined`, the series color is used.
               *
               * In styled mode, the stem stroke can be set with the
               * `.highcharts-boxplot-stem` class.
               *
               * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
               *         Box plot styling
               * @sample {highcharts} highcharts/css/boxplot/
               *         Box plot in styled mode
               * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
               *         Error bar styling
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @since     3.0
               * @product   highcharts
               * @apioption plotOptions.boxplot.stemColor
               */
      /**
       * The dash style of the box.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/css/boxplot/
       *         Box plot in styled mode
       *
       * @type      {Highcharts.DashStyleValue}
       * @default   Solid
       * @since 8.1.0
       * @product   highcharts
       * @apioption plotOptions.boxplot.boxDashStyle
       */
      /**
       * The dash style of the median.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/css/boxplot/
       *         Box plot in styled mode
       *
       * @type      {Highcharts.DashStyleValue}
       * @default   Solid
       * @since 8.1.0
       * @product   highcharts
       * @apioption plotOptions.boxplot.medianDashStyle
       */
      /**
       * The dash style of the stem, the vertical line extending from the
       * box to the whiskers.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/css/boxplot/
       *         Box plot in styled mode
       * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
       *         Error bar styling
       *
       * @type      {Highcharts.DashStyleValue}
       * @default   Solid
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.boxplot.stemDashStyle
       */
      /**
       * The dash style of the whiskers.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/css/boxplot/
       *         Box plot in styled mode
       *
       * @type      {Highcharts.DashStyleValue}
       * @default   Solid
       * @since 8.1.0
       * @product   highcharts
       * @apioption plotOptions.boxplot.whiskerDashStyle
       */
      /**
       * The width of the stem, the vertical line extending from the box to
       * the whiskers. If `undefined`, the width is inherited from the
       * [lineWidth](#plotOptions.boxplot.lineWidth) option.
       *
       * In styled mode, the stem stroke width can be set with the
       * `.highcharts-boxplot-stem` class.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/css/boxplot/
       *         Box plot in styled mode
       * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
       *         Error bar styling
       *
       * @type      {number}
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.boxplot.stemWidth
       */
      /**
       * @default   high
       * @apioption plotOptions.boxplot.colorKey
       */
      /**
       * The color of the whiskers, the horizontal lines marking low and high
       * values. When `undefined`, the general series color is used.
       *
       * In styled mode, the whisker stroke can be set with the
       * `.highcharts-boxplot-whisker` class .
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/css/boxplot/
       *         Box plot in styled mode
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.boxplot.whiskerColor
       */
      /**
       * The line width of the whiskers, the horizontal lines marking low and
       * high values. When `undefined`, the general
       * [lineWidth](#plotOptions.boxplot.lineWidth) applies.
       *
       * In styled mode, the whisker stroke width can be set with the
       * `.highcharts-boxplot-whisker` class.
       *
       * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
       *         Box plot styling
       * @sample {highcharts} highcharts/css/boxplot/
       *         Box plot in styled mode
       *
       * @since   3.0
       * @product highcharts
       */
      whiskerWidth: 2
    });
    return BoxPlotSeries2;
  }(ColumnSeries_default)
);
extend54(BoxPlotSeries.prototype, {
  // array point configs are mapped to this
  pointArrayMap: ["low", "q1", "median", "q3", "high"],
  // defines the top of the tracker
  pointValKey: "high",
  // Disable data labels for box plot
  drawDataLabels: noop12,
  setStackedPoints: noop12
  // #3890
});
SeriesRegistry_default.registerSeriesType("boxplot", BoxPlotSeries);
var BoxPlotSeries_default = BoxPlotSeries;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendDefaults.js
var BubbleLegendDefaults = {
  /**
   * The color of the ranges borders, can be also defined for an
   * individual range.
   *
   * @sample highcharts/bubble-legend/similartoseries/
   *         Similar look to the bubble series
   * @sample highcharts/bubble-legend/bordercolor/
   *         Individual bubble border color
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  borderColor: void 0,
  /**
   * The width of the ranges borders in pixels, can be also
   * defined for an individual range.
   */
  borderWidth: 2,
  /**
   * An additional class name to apply to the bubble legend'
   * circle graphical elements. This option does not replace
   * default class names of the graphical element.
   *
   * @sample {highcharts} highcharts/css/bubble-legend/
   *         Styling by CSS
   *
   * @type {string}
   */
  className: void 0,
  /**
   * The main color of the bubble legend. Applies to ranges, if
   * individual color is not defined.
   *
   * @sample highcharts/bubble-legend/similartoseries/
   *         Similar look to the bubble series
   * @sample highcharts/bubble-legend/color/
   *         Individual bubble color
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  color: void 0,
  /**
   * An additional class name to apply to the bubble legend's
   * connector graphical elements. This option does not replace
   * default class names of the graphical element.
   *
   * @sample {highcharts} highcharts/css/bubble-legend/
   *         Styling by CSS
   *
   * @type {string}
   */
  connectorClassName: void 0,
  /**
   * The color of the connector, can be also defined
   * for an individual range.
   *
   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   */
  connectorColor: void 0,
  /**
   * The length of the connectors in pixels. If labels are
   * centered, the distance is reduced to 0.
   *
   * @sample highcharts/bubble-legend/connectorandlabels/
   *         Increased connector length
   */
  connectorDistance: 60,
  /**
   * The width of the connectors in pixels.
   *
   * @sample highcharts/bubble-legend/connectorandlabels/
   *         Increased connector width
   */
  connectorWidth: 1,
  /**
   * Enable or disable the bubble legend.
   */
  enabled: false,
  /**
   * Options for the bubble legend labels.
   */
  labels: {
    /**
     * An additional class name to apply to the bubble legend
     * label graphical elements. This option does not replace
     * default class names of the graphical element.
     *
     * @sample {highcharts} highcharts/css/bubble-legend/
     *         Styling by CSS
     *
     * @type {string}
     */
    className: void 0,
    /**
     * Whether to allow data labels to overlap.
     */
    allowOverlap: false,
    /**
     * A format string for the bubble legend labels. Available
     * variables are the same as for `formatter`.
     *
     * @sample highcharts/bubble-legend/format/
     *         Add a unit
     *
     * @type {string}
     */
    format: "",
    /**
     * Available `this` properties are:
     *
     * - `this.value`: The bubble value.
     *
     * - `this.radius`: The radius of the bubble range.
     *
     * - `this.center`: The center y position of the range.
     *
     * @type {Highcharts.FormatterCallbackFunction<Highcharts.BubbleLegendFormatterContextObject>}
     */
    formatter: void 0,
    /**
     * The alignment of the labels compared to the bubble
     * legend. Can be one of `left`, `center` or `right`.
     *
     * @sample highcharts/bubble-legend/connectorandlabels/
     *         Labels on left
     *
     * @type {Highcharts.AlignValue}
     */
    align: "right",
    /**
     * CSS styles for the labels.
     *
     * @type {Highcharts.CSSObject}
     */
    style: {
      /** @ignore-option */
      fontSize: "10px",
      /** @ignore-option */
      color: Palette_default.neutralColor100
    },
    /**
     * The x position offset of the label relative to the
     * connector.
     */
    x: 0,
    /**
     * The y position offset of the label relative to the
     * connector.
     */
    y: 0
  },
  /**
   * Miximum bubble legend range size. If values for ranges are
   * not specified, the `minSize` and the `maxSize` are calculated
   * from bubble series.
   */
  maxSize: 60,
  /**
   * Minimum bubble legend range size. If values for ranges are
   * not specified, the `minSize` and the `maxSize` are calculated
   * from bubble series.
   */
  minSize: 10,
  /**
   * The position of the bubble legend in the legend.
   * @sample highcharts/bubble-legend/connectorandlabels/
   *         Bubble legend as last item in legend
   */
  legendIndex: 0,
  /**
   * Options for specific range. One range consists of bubble,
   * label and connector.
   *
   * @sample highcharts/bubble-legend/ranges/
   *         Manually defined ranges
   * @sample highcharts/bubble-legend/autoranges/
   *         Auto calculated ranges
   *
   * @type {Array<*>}
   */
  ranges: {
    /**
     * Range size value, similar to bubble Z data.
     * @type {number}
     */
    value: void 0,
    /**
     * The color of the border for individual range.
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    borderColor: void 0,
    /**
     * The color of the bubble for individual range.
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    color: void 0,
    /**
     * The color of the connector for individual range.
     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     */
    connectorColor: void 0
  },
  /**
   * Whether the bubble legend range value should be represented
   * by the area or the width of the bubble. The default, area,
   * corresponds best to the human perception of the size of each
   * bubble.
   *
   * @sample highcharts/bubble-legend/ranges/
   *         Size by width
   *
   * @type {Highcharts.BubbleSizeByValue}
   */
  sizeBy: "area",
  /**
   * When this is true, the absolute value of z determines the
   * size of the bubble. This means that with the default
   * zThreshold of 0, a bubble of value -1 will have the same size
   * as a bubble of value 1, while a bubble of value 0 will have a
   * smaller size according to minSize.
   */
  sizeByAbsoluteValue: false,
  /**
   * Define the visual z index of the bubble legend.
   */
  zIndex: 1,
  /**
   * Ranges with with lower value than zThreshold, are skipped.
   */
  zThreshold: 0
};
var BubbleLegendDefaults_default = BubbleLegendDefaults;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendItem.js
var color7 = Color_default.parse;
var noop13 = Globals_default.noop;
var arrayMax8 = Utilities_default.arrayMax;
var arrayMin7 = Utilities_default.arrayMin;
var isNumber37 = Utilities_default.isNumber;
var merge56 = Utilities_default.merge;
var pick63 = Utilities_default.pick;
var stableSort6 = Utilities_default.stableSort;
var BubbleLegendItem = (
  /** @class */
  function() {
    function BubbleLegendItem2(options, legend) {
      this.chart = void 0;
      this.fontMetrics = void 0;
      this.legend = void 0;
      this.legendGroup = void 0;
      this.legendItem = void 0;
      this.legendItemHeight = void 0;
      this.legendItemWidth = void 0;
      this.legendSymbol = void 0;
      this.maxLabel = void 0;
      this.movementX = void 0;
      this.ranges = void 0;
      this.selected = void 0;
      this.visible = void 0;
      this.symbols = void 0;
      this.options = void 0;
      this.setState = noop13;
      this.init(options, legend);
    }
    BubbleLegendItem2.prototype.init = function(options, legend) {
      this.options = options;
      this.visible = true;
      this.chart = legend.chart;
      this.legend = legend;
    };
    BubbleLegendItem2.prototype.addToLegend = function(items) {
      items.splice(this.options.legendIndex, 0, this);
    };
    BubbleLegendItem2.prototype.drawLegendSymbol = function(legend) {
      var chart = this.chart, options = this.options, itemDistance = pick63(legend.options.itemDistance, 20), ranges = options.ranges, connectorDistance = options.connectorDistance;
      var connectorSpace;
      this.fontMetrics = chart.renderer.fontMetrics(options.labels.style.fontSize);
      if (!ranges || !ranges.length || !isNumber37(ranges[0].value)) {
        legend.options.bubbleLegend.autoRanges = true;
        return;
      }
      stableSort6(ranges, function(a, b) {
        return b.value - a.value;
      });
      this.ranges = ranges;
      this.setOptions();
      this.render();
      var maxLabel = this.getMaxLabelSize(), radius = this.ranges[0].radius, size = radius * 2;
      connectorSpace = connectorDistance - radius + maxLabel.width;
      connectorSpace = connectorSpace > 0 ? connectorSpace : 0;
      this.maxLabel = maxLabel;
      this.movementX = options.labels.align === "left" ? connectorSpace : 0;
      this.legendItemWidth = size + connectorSpace + itemDistance;
      this.legendItemHeight = size + this.fontMetrics.h / 2;
    };
    BubbleLegendItem2.prototype.setOptions = function() {
      var ranges = this.ranges, options = this.options, series = this.chart.series[options.seriesIndex], baseline = this.legend.baseline, bubbleAttribs = {
        zIndex: options.zIndex,
        "stroke-width": options.borderWidth
      }, connectorAttribs = {
        zIndex: options.zIndex,
        "stroke-width": options.connectorWidth
      }, labelAttribs = {
        align: this.legend.options.rtl || options.labels.align === "left" ? "right" : "left",
        zIndex: options.zIndex
      }, fillOpacity = series.options.marker.fillOpacity, styledMode = this.chart.styledMode;
      ranges.forEach(function(range, i) {
        if (!styledMode) {
          bubbleAttribs.stroke = pick63(range.borderColor, options.borderColor, series.color);
          bubbleAttribs.fill = pick63(range.color, options.color, fillOpacity !== 1 ? color7(series.color).setOpacity(fillOpacity).get("rgba") : series.color);
          connectorAttribs.stroke = pick63(range.connectorColor, options.connectorColor, series.color);
        }
        ranges[i].radius = this.getRangeRadius(range.value);
        ranges[i] = merge56(ranges[i], {
          center: ranges[0].radius - ranges[i].radius + baseline
        });
        if (!styledMode) {
          merge56(true, ranges[i], {
            bubbleAttribs: merge56(bubbleAttribs),
            connectorAttribs: merge56(connectorAttribs),
            labelAttribs
          });
        }
      }, this);
    };
    BubbleLegendItem2.prototype.getRangeRadius = function(value) {
      var options = this.options, seriesIndex = this.options.seriesIndex, bubbleSeries = this.chart.series[seriesIndex], zMax = options.ranges[0].value, zMin = options.ranges[options.ranges.length - 1].value, minSize = options.minSize, maxSize = options.maxSize;
      return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value);
    };
    BubbleLegendItem2.prototype.render = function() {
      var renderer = this.chart.renderer, zThreshold = this.options.zThreshold;
      if (!this.symbols) {
        this.symbols = {
          connectors: [],
          bubbleItems: [],
          labels: []
        };
      }
      this.legendSymbol = renderer.g("bubble-legend");
      this.legendItem = renderer.g("bubble-legend-item");
      this.legendSymbol.translateX = 0;
      this.legendSymbol.translateY = 0;
      this.ranges.forEach(function(range) {
        if (range.value >= zThreshold) {
          this.renderRange(range);
        }
      }, this);
      this.legendSymbol.add(this.legendItem);
      this.legendItem.add(this.legendGroup);
      this.hideOverlappingLabels();
    };
    BubbleLegendItem2.prototype.renderRange = function(range) {
      var mainRange = this.ranges[0], legend = this.legend, options = this.options, labelsOptions = options.labels, chart = this.chart, bubbleSeries = chart.series[options.seriesIndex], renderer = chart.renderer, symbols5 = this.symbols, labels = symbols5.labels, elementCenter = range.center, absoluteRadius = Math.abs(range.radius), connectorDistance = options.connectorDistance || 0, labelsAlign = labelsOptions.align, rtl = legend.options.rtl, borderWidth = options.borderWidth, connectorWidth = options.connectorWidth, posX = mainRange.radius || 0, posY = elementCenter - absoluteRadius - borderWidth / 2 + connectorWidth / 2, fontMetrics = this.fontMetrics, labelMovement = fontMetrics.f / 2 - (fontMetrics.h - fontMetrics.f) / 2, crispMovement = (posY % 1 ? 1 : 0.5) - (connectorWidth % 2 ? 0 : 0.5), styledMode = renderer.styledMode;
      var connectorLength = rtl || labelsAlign === "left" ? -connectorDistance : connectorDistance;
      if (labelsAlign === "center") {
        connectorLength = 0;
        options.connectorDistance = 0;
        range.labelAttribs.align = "center";
      }
      var labelY = posY + options.labels.y, labelX = posX + connectorLength + options.labels.x;
      symbols5.bubbleItems.push(renderer.circle(posX, elementCenter + crispMovement, absoluteRadius).attr(styledMode ? {} : range.bubbleAttribs).addClass((styledMode ? "highcharts-color-" + bubbleSeries.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (options.className || "")).add(this.legendSymbol));
      symbols5.connectors.push(renderer.path(renderer.crispLine([
        ["M", posX, posY],
        ["L", posX + connectorLength, posY]
      ], options.connectorWidth)).attr(styledMode ? {} : range.connectorAttribs).addClass((styledMode ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (options.connectorClassName || "")).add(this.legendSymbol));
      var label = renderer.text(this.formatLabel(range), labelX, labelY + labelMovement).attr(styledMode ? {} : range.labelAttribs).css(styledMode ? {} : labelsOptions.style).addClass("highcharts-bubble-legend-labels " + (options.labels.className || "")).add(this.legendSymbol);
      labels.push(label);
      label.placed = true;
      label.alignAttr = {
        x: labelX,
        y: labelY + labelMovement
      };
    };
    BubbleLegendItem2.prototype.getMaxLabelSize = function() {
      var labels = this.symbols.labels;
      var maxLabel, labelSize;
      labels.forEach(function(label) {
        labelSize = label.getBBox(true);
        if (maxLabel) {
          maxLabel = labelSize.width > maxLabel.width ? labelSize : maxLabel;
        } else {
          maxLabel = labelSize;
        }
      });
      return maxLabel || {};
    };
    BubbleLegendItem2.prototype.formatLabel = function(range) {
      var options = this.options, formatter = options.labels.formatter, format15 = options.labels.format;
      var numberFormatter = this.chart.numberFormatter;
      return format15 ? FormatUtilities_default.format(format15, range) : formatter ? formatter.call(range) : numberFormatter(range.value, 1);
    };
    BubbleLegendItem2.prototype.hideOverlappingLabels = function() {
      var chart = this.chart, allowOverlap = this.options.labels.allowOverlap, symbols5 = this.symbols;
      if (!allowOverlap && symbols5) {
        chart.hideOverlappingLabels(symbols5.labels);
        symbols5.labels.forEach(function(label, index) {
          if (!label.newOpacity) {
            symbols5.connectors[index].hide();
          } else if (label.newOpacity !== label.oldOpacity) {
            symbols5.connectors[index].show();
          }
        });
      }
    };
    BubbleLegendItem2.prototype.getRanges = function() {
      var bubbleLegend = this.legend.bubbleLegend, series = bubbleLegend.chart.series, rangesOptions = bubbleLegend.options.ranges;
      var ranges, zData, minZ = Number.MAX_VALUE, maxZ = -Number.MAX_VALUE;
      series.forEach(function(s) {
        if (s.isBubble && !s.ignoreSeries) {
          zData = s.zData.filter(isNumber37);
          if (zData.length) {
            minZ = pick63(s.options.zMin, Math.min(minZ, Math.max(arrayMin7(zData), s.options.displayNegative === false ? s.options.zThreshold : -Number.MAX_VALUE)));
            maxZ = pick63(s.options.zMax, Math.max(maxZ, arrayMax8(zData)));
          }
        }
      });
      if (minZ === maxZ) {
        ranges = [{ value: maxZ }];
      } else {
        ranges = [
          { value: minZ },
          { value: (minZ + maxZ) / 2 },
          { value: maxZ, autoRanges: true }
        ];
      }
      if (rangesOptions.length && rangesOptions[0].radius) {
        ranges.reverse();
      }
      ranges.forEach(function(range, i) {
        if (rangesOptions && rangesOptions[i]) {
          ranges[i] = merge56(rangesOptions[i], range);
        }
      });
      return ranges;
    };
    BubbleLegendItem2.prototype.predictBubbleSizes = function() {
      var chart = this.chart, fontMetrics = this.fontMetrics, legendOptions = chart.legend.options, floating = legendOptions.floating, horizontal = legendOptions.layout === "horizontal", lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0, plotSizeX = chart.plotSizeX, plotSizeY = chart.plotSizeY, bubbleSeries = chart.series[this.options.seriesIndex], minSize = Math.ceil(bubbleSeries.minPxSize), maxPxSize = Math.ceil(bubbleSeries.maxPxSize), plotSize = Math.min(plotSizeY, plotSizeX);
      var calculatedSize, maxSize = bubbleSeries.options.maxSize;
      if (floating || !/%$/.test(maxSize)) {
        calculatedSize = maxPxSize;
      } else {
        maxSize = parseFloat(maxSize);
        calculatedSize = (plotSize + lastLineHeight - fontMetrics.h / 2) * maxSize / 100 / (maxSize / 100 + 1);
        if (horizontal && plotSizeY - calculatedSize >= plotSizeX || !horizontal && plotSizeX - calculatedSize >= plotSizeY) {
          calculatedSize = maxPxSize;
        }
      }
      return [minSize, Math.ceil(calculatedSize)];
    };
    BubbleLegendItem2.prototype.updateRanges = function(min, max) {
      var bubbleLegendOptions = this.legend.options.bubbleLegend;
      bubbleLegendOptions.minSize = min;
      bubbleLegendOptions.maxSize = max;
      bubbleLegendOptions.ranges = this.getRanges();
    };
    BubbleLegendItem2.prototype.correctSizes = function() {
      var legend = this.legend, chart = this.chart, bubbleSeries = chart.series[this.options.seriesIndex], bubbleSeriesSize = bubbleSeries.maxPxSize, bubbleLegendSize = this.options.maxSize;
      if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) > 1) {
        this.updateRanges(this.options.minSize, bubbleSeries.maxPxSize);
        legend.render();
      }
    };
    return BubbleLegendItem2;
  }()
);
var BubbleLegendItem_default = BubbleLegendItem;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleLegendComposition.js
var setOptions3 = DefaultOptions_default.setOptions;
var addEvent43 = Utilities_default.addEvent;
var objectEach29 = Utilities_default.objectEach;
var wrap7 = Utilities_default.wrap;
var BubbleLegendComposition;
(function(BubbleLegendComposition2) {
  var composedClasses2 = [];
  function chartDrawChartBox(proceed, options, callback) {
    var chart = this, legend = chart.legend, bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;
    var bubbleLegendOptions, bubbleSizes;
    if (legend && legend.options.enabled && legend.bubbleLegend && legend.options.bubbleLegend.autoRanges && bubbleSeries) {
      bubbleLegendOptions = legend.bubbleLegend.options;
      bubbleSizes = legend.bubbleLegend.predictBubbleSizes();
      legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);
      if (!bubbleLegendOptions.placed) {
        legend.group.placed = false;
        legend.allItems.forEach(function(item) {
          item.legendGroup.translateY = null;
        });
      }
      legend.render();
      chart.getMargins();
      chart.axes.forEach(function(axis) {
        if (axis.visible) {
          axis.render();
        }
        if (!bubbleLegendOptions.placed) {
          axis.setScale();
          axis.updateNames();
          objectEach29(axis.ticks, function(tick) {
            tick.isNew = true;
            tick.isNewLabel = true;
          });
        }
      });
      bubbleLegendOptions.placed = true;
      chart.getMargins();
      proceed.call(chart, options, callback);
      legend.bubbleLegend.correctSizes();
      retranslateItems(legend, getLinesHeights(legend));
    } else {
      proceed.call(chart, options, callback);
      if (legend && legend.options.enabled && legend.bubbleLegend) {
        legend.render();
        retranslateItems(legend, getLinesHeights(legend));
      }
    }
  }
  function compose(ChartClass, LegendClass, SeriesClass) {
    if (composedClasses2.indexOf(ChartClass) === -1) {
      composedClasses2.push(ChartClass);
      setOptions3({
        // Set default bubble legend options
        legend: {
          bubbleLegend: BubbleLegendDefaults_default
        }
      });
      wrap7(ChartClass.prototype, "drawChartBox", chartDrawChartBox);
    }
    if (composedClasses2.indexOf(LegendClass) === -1) {
      composedClasses2.push(LegendClass);
      addEvent43(LegendClass, "afterGetAllItems", onLegendAfterGetAllItems);
    }
    if (composedClasses2.indexOf(SeriesClass) === -1) {
      composedClasses2.push(SeriesClass);
      addEvent43(SeriesClass, "legendItemClick", onSeriesLegendItemClick);
    }
  }
  BubbleLegendComposition2.compose = compose;
  function getVisibleBubbleSeriesIndex(chart) {
    var series = chart.series;
    var i = 0;
    while (i < series.length) {
      if (series[i] && series[i].isBubble && series[i].visible && series[i].zData.length) {
        return i;
      }
      i++;
    }
    return -1;
  }
  function getLinesHeights(legend) {
    var items = legend.allItems, lines = [], length = items.length;
    var lastLine, i = 0, j = 0;
    for (i = 0; i < length; i++) {
      if (items[i].legendItemHeight) {
        items[i].itemHeight = items[i].legendItemHeight;
      }
      if (
        // Line break
        items[i] === items[length - 1] || items[i + 1] && items[i]._legendItemPos[1] !== items[i + 1]._legendItemPos[1]
      ) {
        lines.push({ height: 0 });
        lastLine = lines[lines.length - 1];
        for (j; j <= i; j++) {
          if (items[j].itemHeight > lastLine.height) {
            lastLine.height = items[j].itemHeight;
          }
        }
        lastLine.step = i;
      }
    }
    return lines;
  }
  function onLegendAfterGetAllItems(e2) {
    var legend = this, bubbleLegend = legend.bubbleLegend, legendOptions = legend.options, options = legendOptions.bubbleLegend, bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);
    if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {
      if (options.ranges.length) {
        options.autoRanges = !!options.ranges[0].autoRanges;
      }
      legend.destroyItem(bubbleLegend);
    }
    if (bubbleSeriesIndex >= 0 && legendOptions.enabled && options.enabled) {
      options.seriesIndex = bubbleSeriesIndex;
      legend.bubbleLegend = new BubbleLegendItem_default(options, legend);
      legend.bubbleLegend.addToLegend(e2.allItems);
    }
  }
  function onSeriesLegendItemClick() {
    var series = this, chart = series.chart, visible = series.visible, legend = series.chart.legend;
    var status;
    if (legend && legend.bubbleLegend) {
      series.visible = !visible;
      series.ignoreSeries = visible;
      status = getVisibleBubbleSeriesIndex(chart) >= 0;
      if (legend.bubbleLegend.visible !== status) {
        legend.update({
          bubbleLegend: { enabled: status }
        });
        legend.bubbleLegend.visible = status;
      }
      series.visible = visible;
    }
  }
  function retranslateItems(legend, lines) {
    var items = legend.allItems, rtl = legend.options.rtl;
    var orgTranslateX, orgTranslateY, movementX, actualLine = 0;
    items.forEach(function(item, index) {
      orgTranslateX = item.legendGroup.translateX;
      orgTranslateY = item._legendItemPos[1];
      movementX = item.movementX;
      if (movementX || rtl && item.ranges) {
        movementX = rtl ? orgTranslateX - item.options.maxSize / 2 : orgTranslateX + movementX;
        item.legendGroup.attr({ translateX: movementX });
      }
      if (index > lines[actualLine].step) {
        actualLine++;
      }
      item.legendGroup.attr({
        translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)
      });
      item._legendItemPos[1] = orgTranslateY + lines[actualLine].height / 2;
    });
  }
})(BubbleLegendComposition || (BubbleLegendComposition = {}));
var BubbleLegendComposition_default = BubbleLegendComposition;

// node_modules/highcharts/es-modules/Series/Bubble/BubblePoint.js
var __extends24 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ScatterPoint = SeriesRegistry_default.seriesTypes.scatter.prototype.pointClass;
var extend55 = Utilities_default.extend;
var BubblePoint = (
  /** @class */
  function(_super) {
    __extends24(BubblePoint2, _super);
    function BubblePoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.series = void 0;
      return _this;
    }
    BubblePoint2.prototype.haloPath = function(size) {
      return Point_default.prototype.haloPath.call(
        this,
        // #6067
        size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size
      );
    };
    return BubblePoint2;
  }(ScatterPoint)
);
extend55(BubblePoint.prototype, {
  ttBelow: false
});
var BubblePoint_default = BubblePoint;

// node_modules/highcharts/es-modules/Series/Bubble/BubbleSeries.js
var __extends25 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color8 = Color_default.parse;
var noop14 = Globals_default.noop;
var _a3 = SeriesRegistry_default.seriesTypes;
var ColumnSeries7 = _a3.column;
var ScatterSeries2 = _a3.scatter;
var arrayMax9 = Utilities_default.arrayMax;
var arrayMin8 = Utilities_default.arrayMin;
var clamp12 = Utilities_default.clamp;
var extend56 = Utilities_default.extend;
var isNumber38 = Utilities_default.isNumber;
var merge57 = Utilities_default.merge;
var pick64 = Utilities_default.pick;
var pInt9 = Utilities_default.pInt;
var BubbleSeries = (
  /** @class */
  function(_super) {
    __extends25(BubbleSeries4, _super);
    function BubbleSeries4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.maxPxSize = void 0;
      _this.minPxSize = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.radii = void 0;
      _this.yData = void 0;
      _this.zData = void 0;
      return _this;
    }
    BubbleSeries4.prototype.animate = function(init) {
      if (!init && this.points.length < this.options.animationLimit) {
        this.points.forEach(function(point) {
          var graphic = point.graphic;
          if (graphic && graphic.width) {
            if (!this.hasRendered) {
              graphic.attr({
                x: point.plotX,
                y: point.plotY,
                width: 1,
                height: 1
              });
            }
            graphic.animate(this.markerAttribs(point), this.options.animation);
          }
        }, this);
      }
    };
    BubbleSeries4.prototype.getRadii = function(zMin, zMax, series) {
      var len, i, zData = this.zData, yData = this.yData, minSize = series.minPxSize, maxSize = series.maxPxSize, radii = [], value;
      for (i = 0, len = zData.length; i < len; i++) {
        value = zData[i];
        radii.push(this.getRadius(zMin, zMax, minSize, maxSize, value, yData[i]));
      }
      this.radii = radii;
    };
    BubbleSeries4.prototype.getRadius = function(zMin, zMax, minSize, maxSize, value, yValue) {
      var options = this.options, sizeByArea = options.sizeBy !== "width", zThreshold = options.zThreshold, zRange = zMax - zMin, pos = 0.5;
      if (yValue === null || value === null) {
        return null;
      }
      if (isNumber38(value)) {
        if (options.sizeByAbsoluteValue) {
          value = Math.abs(value - zThreshold);
          zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));
          zMin = 0;
        }
        if (value < zMin) {
          return minSize / 2 - 1;
        }
        if (zRange > 0) {
          pos = (value - zMin) / zRange;
        }
      }
      if (sizeByArea && pos >= 0) {
        pos = Math.sqrt(pos);
      }
      return Math.ceil(minSize + pos * (maxSize - minSize)) / 2;
    };
    BubbleSeries4.prototype.hasData = function() {
      return !!this.processedXData.length;
    };
    BubbleSeries4.prototype.pointAttribs = function(point, state) {
      var markerOptions = this.options.marker, fillOpacity = markerOptions.fillOpacity, attr11 = Series_default.prototype.pointAttribs.call(this, point, state);
      if (fillOpacity !== 1) {
        attr11.fill = color8(attr11.fill).setOpacity(fillOpacity).get("rgba");
      }
      return attr11;
    };
    BubbleSeries4.prototype.translate = function() {
      var i, data = this.data, point, radius, radii = this.radii;
      _super.prototype.translate.call(this);
      i = data.length;
      while (i--) {
        point = data[i];
        radius = radii ? radii[i] : 0;
        if (isNumber38(radius) && radius >= this.minPxSize / 2) {
          point.marker = extend56(point.marker, {
            radius,
            width: 2 * radius,
            height: 2 * radius
          });
          point.dlBox = {
            x: point.plotX - radius,
            y: point.plotY - radius,
            width: 2 * radius,
            height: 2 * radius
          };
        } else {
          point.shapeArgs = point.plotY = point.dlBox = void 0;
        }
      }
    };
    BubbleSeries4.compose = BubbleLegendComposition_default.compose;
    BubbleSeries4.defaultOptions = merge57(ScatterSeries2.defaultOptions, {
      dataLabels: {
        formatter: function() {
          var numberFormatter = this.series.chart.numberFormatter;
          var z = this.point.z;
          return isNumber38(z) ? numberFormatter(z, -1) : "";
        },
        inside: true,
        verticalAlign: "middle"
      },
      /**
       * If there are more points in the series than the `animationLimit`, the
       * animation won't run. Animation affects overall performance and
       * doesn't work well with heavy data series.
       *
       * @since 6.1.0
       */
      animationLimit: 250,
      /**
       * Whether to display negative sized bubbles. The threshold is given
       * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative
       * bubbles can be visualized by setting
       * [negativeColor](#plotOptions.bubble.negativeColor).
       *
       * @sample {highcharts} highcharts/plotoptions/bubble-negative/
       *         Negative bubbles
       *
       * @type      {boolean}
       * @default   true
       * @since     3.0
       * @apioption plotOptions.bubble.displayNegative
       */
      /**
       * @extends   plotOptions.series.marker
       * @excluding enabled, enabledThreshold, height, radius, width
       */
      marker: {
        lineColor: null,
        lineWidth: 1,
        /**
         * The fill opacity of the bubble markers.
         */
        fillOpacity: 0.5,
        /**
         * In bubble charts, the radius is overridden and determined based
         * on the point's data value.
         *
         * @ignore-option
         */
        radius: null,
        states: {
          hover: {
            radiusPlus: 0
          }
        },
        /**
         * A predefined shape or symbol for the marker. Possible values are
         * "circle", "square", "diamond", "triangle" and "triangle-down".
         *
         * Additionally, the URL to a graphic can be given on the form
         * `url(graphic.png)`. Note that for the image to be applied to
         * exported charts, its URL needs to be accessible by the export
         * server.
         *
         * Custom callbacks for symbol path generation can also be added to
         * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
         * used by its method name, as shown in the demo.
         *
         * @sample {highcharts} highcharts/plotoptions/bubble-symbol/
         *         Bubble chart with various symbols
         * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
         *         General chart with predefined, graphic and custom markers
         *
         * @type  {Highcharts.SymbolKeyValue|string}
         * @since 5.0.11
         */
        symbol: "circle"
      },
      /**
       * Minimum bubble size. Bubbles will automatically size between the
       * `minSize` and `maxSize` to reflect the `z` value of each bubble.
       * Can be either pixels (when no unit is given), or a percentage of
       * the smallest one of the plot width and height.
       *
       * @sample {highcharts} highcharts/plotoptions/bubble-size/
       *         Bubble size
       *
       * @type    {number|string}
       * @since   3.0
       * @product highcharts highstock
       */
      minSize: 8,
      /**
       * Maximum bubble size. Bubbles will automatically size between the
       * `minSize` and `maxSize` to reflect the `z` value of each bubble.
       * Can be either pixels (when no unit is given), or a percentage of
       * the smallest one of the plot width and height.
       *
       * @sample {highcharts} highcharts/plotoptions/bubble-size/
       *         Bubble size
       *
       * @type    {number|string}
       * @since   3.0
       * @product highcharts highstock
       */
      maxSize: "20%",
      /**
       * When a point's Z value is below the
       * [zThreshold](#plotOptions.bubble.zThreshold)
       * setting, this color is used.
       *
       * @sample {highcharts} highcharts/plotoptions/bubble-negative/
       *         Negative bubbles
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.bubble.negativeColor
       */
      /**
       * Whether the bubble's value should be represented by the area or the
       * width of the bubble. The default, `area`, corresponds best to the
       * human perception of the size of each bubble.
       *
       * @sample {highcharts} highcharts/plotoptions/bubble-sizeby/
       *         Comparison of area and size
       *
       * @type       {Highcharts.BubbleSizeByValue}
       * @default    area
       * @since      3.0.7
       * @apioption  plotOptions.bubble.sizeBy
       */
      /**
       * When this is true, the absolute value of z determines the size of
       * the bubble. This means that with the default `zThreshold` of 0, a
       * bubble of value -1 will have the same size as a bubble of value 1,
       * while a bubble of value 0 will have a smaller size according to
       * `minSize`.
       *
       * @sample    {highcharts} highcharts/plotoptions/bubble-sizebyabsolutevalue/
       *            Size by absolute value, various thresholds
       *
       * @type      {boolean}
       * @default   false
       * @since     4.1.9
       * @product   highcharts
       * @apioption plotOptions.bubble.sizeByAbsoluteValue
       */
      /**
       * When this is true, the series will not cause the Y axis to cross
       * the zero plane (or [threshold](#plotOptions.series.threshold) option)
       * unless the data actually crosses the plane.
       *
       * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
       * 3 will make the Y axis show negative values according to the
       * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
       * at 0.
       *
       * @since   4.1.9
       * @product highcharts
       */
      softThreshold: false,
      states: {
        hover: {
          halo: {
            size: 5
          }
        }
      },
      tooltip: {
        pointFormat: "({point.x}, {point.y}), Size: {point.z}"
      },
      turboThreshold: 0,
      /**
       * The minimum for the Z value range. Defaults to the highest Z value
       * in the data.
       *
       * @see [zMin](#plotOptions.bubble.zMin)
       *
       * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
       *         Z has a possible range of 0-100
       *
       * @type      {number}
       * @since     4.0.3
       * @product   highcharts
       * @apioption plotOptions.bubble.zMax
       */
      /**
       * @default   z
       * @apioption plotOptions.bubble.colorKey
       */
      /**
       * The minimum for the Z value range. Defaults to the lowest Z value
       * in the data.
       *
       * @see [zMax](#plotOptions.bubble.zMax)
       *
       * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
       *         Z has a possible range of 0-100
       *
       * @type      {number}
       * @since     4.0.3
       * @product   highcharts
       * @apioption plotOptions.bubble.zMin
       */
      /**
       * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,
       * bubbles with lower Z values are skipped. When `displayNegative`
       * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)
       * is given, points with lower Z is colored.
       *
       * @sample {highcharts} highcharts/plotoptions/bubble-negative/
       *         Negative bubbles
       *
       * @since   3.0
       * @product highcharts
       */
      zThreshold: 0,
      zoneAxis: "z"
    });
    return BubbleSeries4;
  }(ScatterSeries2)
);
extend56(BubbleSeries.prototype, {
  alignDataLabel: ColumnSeries7.prototype.alignDataLabel,
  applyZones: noop14,
  bubblePadding: true,
  buildKDTree: noop14,
  directTouch: true,
  isBubble: true,
  pointArrayMap: ["y", "z"],
  pointClass: BubblePoint_default,
  parallelArrays: ["x", "y", "z"],
  trackerGroups: ["group", "dataLabelsGroup"],
  specialGroup: "group",
  zoneAxis: "z"
});
Axis_default.prototype.beforePadding = function() {
  var axis = this, axisLength = this.len, chart = this.chart, pxMin = 0, pxMax = axisLength, isXAxis = this.isXAxis, dataKey = isXAxis ? "xData" : "yData", min = this.min, extremes = {}, smallestSize = Math.min(chart.plotWidth, chart.plotHeight), zMin = Number.MAX_VALUE, zMax = -Number.MAX_VALUE, range = this.max - min, transA = axisLength / range, activeSeries = [];
  this.series.forEach(function(series) {
    var seriesOptions = series.options, zData;
    if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {
      axis.allowZoomOutside = true;
      activeSeries.push(series);
      if (isXAxis) {
        ["minSize", "maxSize"].forEach(function(prop) {
          var length = seriesOptions[prop], isPercent = /%$/.test(length);
          length = pInt9(length);
          extremes[prop] = isPercent ? smallestSize * length / 100 : length;
        });
        series.minPxSize = extremes.minSize;
        series.maxPxSize = Math.max(extremes.maxSize, extremes.minSize);
        zData = series.zData.filter(isNumber38);
        if (zData.length) {
          zMin = pick64(seriesOptions.zMin, clamp12(arrayMin8(zData), seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE, zMin));
          zMax = pick64(seriesOptions.zMax, Math.max(zMax, arrayMax9(zData)));
        }
      }
    }
  });
  activeSeries.forEach(function(series) {
    var data = series[dataKey], i = data.length, radius;
    if (isXAxis) {
      series.getRadii(zMin, zMax, series);
    }
    if (range > 0) {
      while (i--) {
        if (isNumber38(data[i]) && axis.dataMin <= data[i] && data[i] <= axis.max) {
          radius = series.radii ? series.radii[i] : 0;
          pxMin = Math.min((data[i] - min) * transA - radius, pxMin);
          pxMax = Math.max((data[i] - min) * transA + radius, pxMax);
        }
      }
    }
  });
  if (activeSeries.length && range > 0 && !this.logarithmic) {
    pxMax -= axisLength;
    transA *= (axisLength + Math.max(0, pxMin) - // #8901
    Math.min(pxMax, axisLength)) / axisLength;
    [
      ["min", "userMin", pxMin],
      ["max", "userMax", pxMax]
    ].forEach(function(keys2) {
      if (typeof pick64(axis.options[keys2[0]], axis[keys2[1]]) === "undefined") {
        axis[keys2[0]] += keys2[2] / transA;
      }
    });
  }
};
SeriesRegistry_default.registerSeriesType("bubble", BubbleSeries);
var BubbleSeries_default = BubbleSeries;

// node_modules/highcharts/es-modules/Series/ColumnRange/ColumnRangePoint.js
var __extends26 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a4 = SeriesRegistry_default.seriesTypes;
var ColumnPoint = _a4.column.prototype.pointClass;
var AreaRangePoint2 = _a4.arearange.prototype.pointClass;
var extend57 = Utilities_default.extend;
var isNumber39 = Utilities_default.isNumber;
var ColumnRangePoint = (
  /** @class */
  function(_super) {
    __extends26(ColumnRangePoint2, _super);
    function ColumnRangePoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.series = void 0;
      _this.options = void 0;
      _this.barX = void 0;
      _this.pointWidth = void 0;
      _this.shapeType = void 0;
      return _this;
    }
    ColumnRangePoint2.prototype.isValid = function() {
      return isNumber39(this.low);
    };
    return ColumnRangePoint2;
  }(AreaRangePoint2)
);
extend57(ColumnRangePoint.prototype, {
  setState: ColumnPoint.prototype.setState
});
var ColumnRangePoint_default = ColumnRangePoint;

// node_modules/highcharts/es-modules/Series/ColumnRange/ColumnRangeSeries.js
var __extends27 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop15 = Globals_default.noop;
var _a5 = SeriesRegistry_default.seriesTypes;
var AreaRangeSeries2 = _a5.arearange;
var ColumnSeries8 = _a5.column;
var columnProto3 = ColumnSeries8.prototype;
var arearangeProto = AreaRangeSeries2.prototype;
var clamp13 = Utilities_default.clamp;
var merge58 = Utilities_default.merge;
var pick65 = Utilities_default.pick;
var extend58 = Utilities_default.extend;
var columnRangeOptions = {
  /**
   * Extended data labels for range series types. Range series data labels
   * have no `x` and `y` options. Instead, they have `xLow`, `xHigh`,
   * `yLow` and `yHigh` options to allow the higher and lower data label
   * sets individually.
   *
   * @declare   Highcharts.SeriesAreaRangeDataLabelsOptionsObject
   * @extends   plotOptions.arearange.dataLabels
   * @since     2.3.0
   * @product   highcharts highstock
   * @apioption plotOptions.columnrange.dataLabels
   */
  pointRange: null,
  /** @ignore-option */
  marker: null,
  states: {
    hover: {
      /** @ignore-option */
      halo: false
    }
  }
};
var ColumnRangeSeries = (
  /** @class */
  function(_super) {
    __extends27(ColumnRangeSeries2, _super);
    function ColumnRangeSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.points = void 0;
      _this.options = void 0;
      return _this;
    }
    ColumnRangeSeries2.prototype.setOptions = function() {
      merge58(true, arguments[0], { stacking: void 0 });
      return arearangeProto.setOptions.apply(this, arguments);
    };
    ColumnRangeSeries2.prototype.translate = function() {
      var series = this, yAxis = series.yAxis, xAxis = series.xAxis, startAngleRad = xAxis.startAngleRad, start, chart = series.chart, isRadial = series.xAxis.isRadial, safeDistance = Math.max(chart.chartWidth, chart.chartHeight) + 999, plotHigh;
      function safeBounds(pixelPos) {
        return clamp13(pixelPos, -safeDistance, safeDistance);
      }
      columnProto3.translate.apply(series);
      series.points.forEach(function(point) {
        var shapeArgs = point.shapeArgs || {}, minPointLength = series.options.minPointLength, heightDifference, height, y;
        point.plotHigh = plotHigh = safeBounds(yAxis.translate(point.high, 0, 1, 0, 1));
        point.plotLow = safeBounds(point.plotY);
        y = plotHigh;
        height = pick65(point.rectPlotY, point.plotY) - plotHigh;
        if (Math.abs(height) < minPointLength) {
          heightDifference = minPointLength - height;
          height += heightDifference;
          y -= heightDifference / 2;
        } else if (height < 0) {
          height *= -1;
          y -= height;
        }
        if (isRadial) {
          start = point.barX + startAngleRad;
          point.shapeType = "arc";
          point.shapeArgs = series.polarArc(y + height, y, start, start + point.pointWidth);
        } else {
          shapeArgs.height = height;
          shapeArgs.y = y;
          var _a15 = shapeArgs.x, x = _a15 === void 0 ? 0 : _a15, _b = shapeArgs.width, width = _b === void 0 ? 0 : _b;
          point.tooltipPos = chart.inverted ? [
            yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2,
            xAxis.len + xAxis.pos - chart.plotTop - x - width / 2,
            height
          ] : [
            xAxis.left - chart.plotLeft + x + width / 2,
            yAxis.pos - chart.plotTop + y + height / 2,
            height
          ];
        }
      });
    };
    ColumnRangeSeries2.prototype.crispCol = function() {
      return columnProto3.crispCol.apply(this, arguments);
    };
    ColumnRangeSeries2.prototype.drawPoints = function() {
      return columnProto3.drawPoints.apply(this, arguments);
    };
    ColumnRangeSeries2.prototype.drawTracker = function() {
      return columnProto3.drawTracker.apply(this, arguments);
    };
    ColumnRangeSeries2.prototype.getColumnMetrics = function() {
      return columnProto3.getColumnMetrics.apply(this, arguments);
    };
    ColumnRangeSeries2.prototype.pointAttribs = function() {
      return columnProto3.pointAttribs.apply(this, arguments);
    };
    ColumnRangeSeries2.prototype.adjustForMissingColumns = function() {
      return columnProto3.adjustForMissingColumns.apply(this, arguments);
    };
    ColumnRangeSeries2.prototype.animate = function() {
      return columnProto3.animate.apply(this, arguments);
    };
    ColumnRangeSeries2.prototype.translate3dPoints = function() {
      return columnProto3.translate3dPoints.apply(this, arguments);
    };
    ColumnRangeSeries2.prototype.translate3dShapes = function() {
      return columnProto3.translate3dShapes.apply(this, arguments);
    };
    ColumnRangeSeries2.defaultOptions = merge58(ColumnSeries8.defaultOptions, AreaRangeSeries2.defaultOptions, columnRangeOptions);
    return ColumnRangeSeries2;
  }(AreaRangeSeries2)
);
extend58(ColumnRangeSeries.prototype, {
  directTouch: true,
  trackerGroups: ["group", "dataLabelsGroup"],
  drawGraph: noop15,
  getSymbol: noop15,
  polarArc: function() {
    return columnProto3.polarArc.apply(this, arguments);
  },
  pointClass: ColumnRangePoint_default
});
SeriesRegistry_default.registerSeriesType("columnrange", ColumnRangeSeries);

// node_modules/highcharts/es-modules/Series/ColumnPyramid/ColumnPyramidSeries.js
var __extends28 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var colProto = ColumnSeries_default.prototype;
var clamp14 = Utilities_default.clamp;
var extend59 = Utilities_default.extend;
var merge59 = Utilities_default.merge;
var pick66 = Utilities_default.pick;
var ColumnPyramidSeries = (
  /** @class */
  function(_super) {
    __extends28(ColumnPyramidSeries2, _super);
    function ColumnPyramidSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    ColumnPyramidSeries2.prototype.translate = function() {
      var series = this, chart = series.chart, options = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick66(
        options.borderWidth,
        dense ? 0 : 1
        // #3635
      ), yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick66(options.minPointLength, 5), metrics = series.getColumnMetrics(), pointWidth = metrics.width, seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), pointXOffset = series.pointXOffset = metrics.offset;
      if (chart.inverted) {
        translatedThreshold -= 0.5;
      }
      if (options.pointPadding) {
        seriesBarW = Math.ceil(seriesBarW);
      }
      colProto.translate.apply(series);
      series.points.forEach(function(point) {
        var yBottom = pick66(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotY = clamp14(point.plotY, -safeDistance, yAxis.len + safeDistance), barX = point.plotX + pointXOffset, barW = seriesBarW / 2, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, stackTotal, stackHeight, topPointY, topXwidth, bottomXwidth, invBarPos, x1, x2, x3, x4, y1, y2;
        point.barX = barX;
        point.pointWidth = pointWidth;
        point.tooltipPos = chart.inverted ? [
          yAxis.len + yAxis.pos - chart.plotLeft - plotY,
          series.xAxis.len - barX - barW,
          barH
        ] : [
          barX + barW,
          plotY + yAxis.pos - chart.plotTop,
          barH
        ];
        stackTotal = threshold + (point.total || point.y);
        if (options.stacking === "percent") {
          stackTotal = threshold + (point.y < 0) ? -100 : 100;
        }
        topPointY = yAxis.toPixels(stackTotal, true);
        stackHeight = chart.plotHeight - topPointY - (chart.plotHeight - translatedThreshold);
        topXwidth = stackHeight ? barW * (barY - topPointY) / stackHeight : 0;
        bottomXwidth = stackHeight ? barW * (barY + barH - topPointY) / stackHeight : 0;
        x1 = barX - topXwidth + barW;
        x2 = barX + topXwidth + barW;
        x3 = barX + bottomXwidth + barW;
        x4 = barX - bottomXwidth + barW;
        y1 = barY - minPointLength;
        y2 = barY + barH;
        if (point.y < 0) {
          y1 = barY;
          y2 = barY + barH + minPointLength;
        }
        if (chart.inverted) {
          invBarPos = chart.plotWidth - barY;
          stackHeight = topPointY - (chart.plotWidth - translatedThreshold);
          topXwidth = barW * (topPointY - invBarPos) / stackHeight;
          bottomXwidth = barW * (topPointY - (invBarPos - barH)) / stackHeight;
          x1 = barX + barW + topXwidth;
          x2 = x1 - 2 * topXwidth;
          x3 = barX - bottomXwidth + barW;
          x4 = barX + bottomXwidth + barW;
          y1 = barY;
          y2 = barY + barH - minPointLength;
          if (point.y < 0) {
            y2 = barY + barH + minPointLength;
          }
        }
        point.shapeType = "path";
        point.shapeArgs = {
          // args for datalabels positioning
          x: x1,
          y: y1,
          width: x2 - x1,
          height: barH,
          // path of pyramid
          d: [
            ["M", x1, y1],
            ["L", x2, y1],
            ["L", x3, y2],
            ["L", x4, y2],
            ["Z"]
          ]
        };
      });
    };
    ColumnPyramidSeries2.defaultOptions = merge59(ColumnSeries_default.defaultOptions, {
      // Nothing here
    });
    return ColumnPyramidSeries2;
  }(ColumnSeries_default)
);
SeriesRegistry_default.registerSeriesType("columnpyramid", ColumnPyramidSeries);

// node_modules/highcharts/es-modules/Series/ErrorBar/ErrorBarSeries.js
var __extends29 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AreaRangeSeries3 = SeriesRegistry_default.seriesTypes.arearange;
var merge60 = Utilities_default.merge;
var extend60 = Utilities_default.extend;
var ErrorBarSeries = (
  /** @class */
  function(_super) {
    __extends29(ErrorBarSeries2, _super);
    function ErrorBarSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    ErrorBarSeries2.prototype.getColumnMetrics = function() {
      return this.linkedParent && this.linkedParent.columnMetrics || ColumnSeries_default.prototype.getColumnMetrics.call(this);
    };
    ErrorBarSeries2.prototype.drawDataLabels = function() {
      var valKey = this.pointValKey;
      if (AreaRangeSeries3) {
        AreaRangeSeries3.prototype.drawDataLabels.call(this);
        this.data.forEach(function(point) {
          point.y = point[valKey];
        });
      }
    };
    ErrorBarSeries2.prototype.toYData = function(point) {
      return [point.low, point.high];
    };
    ErrorBarSeries2.defaultOptions = merge60(BoxPlotSeries_default.defaultOptions, {
      /**
       * The main color of the bars. This can be overridden by
       * [stemColor](#plotOptions.errorbar.stemColor) and
       * [whiskerColor](#plotOptions.errorbar.whiskerColor) individually.
       *
       * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
       *         Error bar styling
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default #000000
       * @since   3.0
       * @product highcharts
       */
      color: Palette_default.neutralColor100,
      grouping: false,
      /**
       * The parent series of the error bar. The default value links it to
       * the previous series. Otherwise, use the id of the parent series.
       *
       * @since   3.0
       * @product highcharts
       */
      linkedTo: ":previous",
      tooltip: {
        pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
      },
      /**
       * The line width of the whiskers, the horizontal lines marking
       * low and high values. When `null`, the general
       * [lineWidth](#plotOptions.errorbar.lineWidth) applies.
       *
       * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
       *         Error bar styling
       *
       * @type    {number}
       * @since   3.0
       * @product highcharts
       */
      whiskerWidth: null
    });
    return ErrorBarSeries2;
  }(BoxPlotSeries_default)
);
extend60(ErrorBarSeries.prototype, {
  // array point configs are mapped to this
  pointArrayMap: ["low", "high"],
  pointValKey: "high",
  doQuartiles: false
});
SeriesRegistry_default.registerSeriesType("errorbar", ErrorBarSeries);

// node_modules/highcharts/es-modules/Series/Gauge/GaugePoint.js
var __extends30 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Point2 = SeriesRegistry_default.series.prototype.pointClass;
var GaugePoint = (
  /** @class */
  function(_super) {
    __extends30(GaugePoint2, _super);
    function GaugePoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.series = void 0;
      _this.shapeArgs = void 0;
      return _this;
    }
    GaugePoint2.prototype.setState = function(state) {
      this.state = state;
    };
    return GaugePoint2;
  }(Point2)
);
var GaugePoint_default = GaugePoint;

// node_modules/highcharts/es-modules/Series/Gauge/GaugeSeries.js
var __extends31 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop16 = Globals_default.noop;
var Series5 = SeriesRegistry_default.series;
var ColumnSeries9 = SeriesRegistry_default.seriesTypes.column;
var clamp15 = Utilities_default.clamp;
var isNumber40 = Utilities_default.isNumber;
var extend61 = Utilities_default.extend;
var merge61 = Utilities_default.merge;
var pick67 = Utilities_default.pick;
var pInt10 = Utilities_default.pInt;
var GaugeSeries = (
  /** @class */
  function(_super) {
    __extends31(GaugeSeries3, _super);
    function GaugeSeries3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.points = void 0;
      _this.options = void 0;
      _this.yAxis = void 0;
      return _this;
    }
    GaugeSeries3.prototype.translate = function() {
      var series = this, yAxis = series.yAxis, options = series.options, center = yAxis.center;
      series.generatePoints();
      series.points.forEach(function(point) {
        var dialOptions = merge61(options.dial, point.dial), radius = pInt10(pick67(dialOptions.radius, "80%")) * center[2] / 200, baseLength = pInt10(pick67(dialOptions.baseLength, "70%")) * radius / 100, rearLength = pInt10(pick67(dialOptions.rearLength, "10%")) * radius / 100, baseWidth = dialOptions.baseWidth || 3, topWidth = dialOptions.topWidth || 1, overshoot = options.overshoot, rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true);
        if (isNumber40(overshoot) || options.wrap === false) {
          overshoot = isNumber40(overshoot) ? overshoot / 180 * Math.PI : 0;
          rotation = clamp15(rotation, yAxis.startAngleRad - overshoot, yAxis.endAngleRad + overshoot);
        }
        rotation = rotation * 180 / Math.PI;
        point.shapeType = "path";
        var d = dialOptions.path || [
          ["M", -rearLength, -baseWidth / 2],
          ["L", baseLength, -baseWidth / 2],
          ["L", radius, -topWidth / 2],
          ["L", radius, topWidth / 2],
          ["L", baseLength, baseWidth / 2],
          ["L", -rearLength, baseWidth / 2],
          ["Z"]
        ];
        point.shapeArgs = {
          d,
          translateX: center[0],
          translateY: center[1],
          rotation
        };
        point.plotX = center[0];
        point.plotY = center[1];
      });
    };
    GaugeSeries3.prototype.drawPoints = function() {
      var series = this, chart = series.chart, center = series.yAxis.center, pivot = series.pivot, options = series.options, pivotOptions = options.pivot, renderer = chart.renderer;
      series.points.forEach(function(point) {
        var graphic = point.graphic, shapeArgs = point.shapeArgs, d = shapeArgs.d, dialOptions = merge61(options.dial, point.dial);
        if (graphic) {
          graphic.animate(shapeArgs);
          shapeArgs.d = d;
        } else {
          point.graphic = renderer[point.shapeType](shapeArgs).attr({
            // required by VML when animation is false
            rotation: shapeArgs.rotation,
            zIndex: 1
          }).addClass("highcharts-dial").add(series.group);
        }
        if (!chart.styledMode) {
          point.graphic[graphic ? "animate" : "attr"]({
            stroke: dialOptions.borderColor || "none",
            "stroke-width": dialOptions.borderWidth || 0,
            fill: dialOptions.backgroundColor || Palette_default.neutralColor100
          });
        }
      });
      if (pivot) {
        pivot.animate({
          translateX: center[0],
          translateY: center[1]
        });
      } else {
        series.pivot = renderer.circle(0, 0, pick67(pivotOptions.radius, 5)).attr({
          zIndex: 2
        }).addClass("highcharts-pivot").translate(center[0], center[1]).add(series.group);
        if (!chart.styledMode) {
          series.pivot.attr({
            "stroke-width": pivotOptions.borderWidth || 0,
            stroke: pivotOptions.borderColor || Palette_default.neutralColor20,
            fill: pivotOptions.backgroundColor || Palette_default.neutralColor100
          });
        }
      }
    };
    GaugeSeries3.prototype.animate = function(init) {
      var series = this;
      if (!init) {
        series.points.forEach(function(point) {
          var graphic = point.graphic;
          if (graphic) {
            graphic.attr({
              rotation: series.yAxis.startAngleRad * 180 / Math.PI
            });
            graphic.animate({
              rotation: point.shapeArgs.rotation
            }, series.options.animation);
          }
        });
      }
    };
    GaugeSeries3.prototype.render = function() {
      this.group = this.plotGroup("group", "series", this.visible ? "visible" : "hidden", this.options.zIndex, this.chart.seriesGroup);
      Series5.prototype.render.call(this);
      this.group.clip(this.chart.clipRect);
    };
    GaugeSeries3.prototype.setData = function(data, redraw) {
      Series5.prototype.setData.call(this, data, false);
      this.processData();
      this.generatePoints();
      if (pick67(redraw, true)) {
        this.chart.redraw();
      }
    };
    GaugeSeries3.prototype.hasData = function() {
      return !!this.points.length;
    };
    GaugeSeries3.defaultOptions = merge61(Series5.defaultOptions, {
      /**
       * When this option is `true`, the dial will wrap around the axes.
       * For instance, in a full-range gauge going from 0 to 360, a value
       * of 400 will point to 40\. When `wrap` is `false`, the dial stops
       * at 360.
       *
       * @see [overshoot](#plotOptions.gauge.overshoot)
       *
       * @type      {boolean}
       * @default   true
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.wrap
       */
      /**
       * Data labels for the gauge. For gauges, the data labels are
       * enabled by default and shown in a bordered box below the point.
       *
       * @since   2.3.0
       * @product highcharts
       */
      dataLabels: {
        borderColor: Palette_default.neutralColor20,
        borderRadius: 3,
        borderWidth: 1,
        crop: false,
        defer: false,
        enabled: true,
        verticalAlign: "top",
        y: 15,
        zIndex: 2
      },
      /**
       * Options for the dial or arrow pointer of the gauge.
       *
       * In styled mode, the dial is styled with the
       * `.highcharts-gauge-series .highcharts-dial` rule.
       *
       * @sample {highcharts} highcharts/css/gauge/
       *         Styled mode
       *
       * @type    {*}
       * @since   2.3.0
       * @product highcharts
       */
      dial: {},
      /**
       * The length of the dial's base part, relative to the total radius
       * or length of the dial.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-dial/
       *         Dial options demonstrated
       *
       * @type      {string}
       * @default   70%
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.dial.baseLength
       */
      /**
       * The pixel width of the base of the gauge dial. The base is the
       * part closest to the pivot, defined by baseLength.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-dial/
       *         Dial options demonstrated
       *
       * @type      {number}
       * @default   3
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.dial.baseWidth
       */
      /**
       * The radius or length of the dial, in percentages relative to the
       * radius of the gauge itself.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-dial/
       *         Dial options demonstrated
       *
       * @type      {string}
       * @default   80%
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.dial.radius
       */
      /**
       * The length of the dial's rear end, the part that extends out on
       * the other side of the pivot. Relative to the dial's length.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-dial/
       *         Dial options demonstrated
       *
       * @type      {string}
       * @default   10%
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.dial.rearLength
       */
      /**
       * The width of the top of the dial, closest to the perimeter. The
       * pivot narrows in from the base to the top.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-dial/
       *         Dial options demonstrated
       *
       * @type      {number}
       * @default   1
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.dial.topWidth
       */
      /**
       * The background or fill color of the gauge's dial.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-dial/
       *         Dial options demonstrated
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   #000000
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.dial.backgroundColor
       */
      /**
       * The border color or stroke of the gauge's dial. By default, the
       * borderWidth is 0, so this must be set in addition to a custom
       * border color.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-dial/
       *         Dial options demonstrated
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   #cccccc
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.dial.borderColor
       */
      /**
       * The width of the gauge dial border in pixels.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-dial/
       *         Dial options demonstrated
       *
       * @type      {number}
       * @default   0
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.dial.borderWidth
       */
      /**
       * Allow the dial to overshoot the end of the perimeter axis by
       * this many degrees. Say if the gauge axis goes from 0 to 60, a
       * value of 100, or 1000, will show 5 degrees beyond the end of the
       * axis when this option is set to 5.
       *
       * @see [wrap](#plotOptions.gauge.wrap)
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-overshoot/
       *         Allow 5 degrees overshoot
       *
       * @type      {number}
       * @since     3.0.10
       * @product   highcharts
       * @apioption plotOptions.gauge.overshoot
       */
      /**
       * Options for the pivot or the center point of the gauge.
       *
       * In styled mode, the pivot is styled with the
       * `.highcharts-gauge-series .highcharts-pivot` rule.
       *
       * @sample {highcharts} highcharts/css/gauge/
       *         Styled mode
       *
       * @type    {*}
       * @since   2.3.0
       * @product highcharts
       */
      pivot: {},
      /**
       * The pixel radius of the pivot.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
       *         Pivot options demonstrated
       *
       * @type      {number}
       * @default   5
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.pivot.radius
       */
      /**
       * The border or stroke width of the pivot.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
       *         Pivot options demonstrated
       *
       * @type      {number}
       * @default   0
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.pivot.borderWidth
       */
      /**
       * The border or stroke color of the pivot. In able to change this,
       * the borderWidth must also be set to something other than the
       * default 0.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
       *         Pivot options demonstrated
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   #cccccc
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.pivot.borderColor
       */
      /**
       * The background color or fill of the pivot.
       *
       * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
       *         Pivot options demonstrated
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   #000000
       * @since     2.3.0
       * @product   highcharts
       * @apioption plotOptions.gauge.pivot.backgroundColor
       */
      tooltip: {
        headerFormat: ""
      },
      /**
       * Whether to display this particular series or series type in the
       * legend. Defaults to false for gauge series.
       *
       * @since   2.3.0
       * @product highcharts
       */
      showInLegend: false
      // Prototype members
    });
    return GaugeSeries3;
  }(Series5)
);
extend61(GaugeSeries.prototype, {
  // chart.angular will be set to true when a gauge series is present,
  // and this will be used on the axes
  angular: true,
  directTouch: true,
  drawGraph: noop16,
  drawTracker: ColumnSeries9.prototype.drawTracker,
  fixedBox: true,
  forceDL: true,
  noSharedTooltip: true,
  pointClass: GaugePoint_default,
  trackerGroups: ["group", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("gauge", GaugeSeries);

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubblePoint.js
var __extends32 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BubbleSeries2 = SeriesRegistry_default.seriesTypes.bubble;
var PackedBubblePoint = (
  /** @class */
  function(_super) {
    __extends32(PackedBubblePoint2, _super);
    function PackedBubblePoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.degree = NaN;
      _this.mass = NaN;
      _this.radius = NaN;
      _this.options = void 0;
      _this.series = void 0;
      _this.value = null;
      return _this;
    }
    PackedBubblePoint2.prototype.destroy = function() {
      if (this.series.layout) {
        this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);
      }
      return Point_default.prototype.destroy.apply(this, arguments);
    };
    PackedBubblePoint2.prototype.firePointEvent = function() {
      var point = this, series = this.series, seriesOptions = series.options;
      if (this.isParentNode && seriesOptions.parentNode) {
        var temp = seriesOptions.allowPointSelect;
        seriesOptions.allowPointSelect = seriesOptions.parentNode.allowPointSelect;
        Point_default.prototype.firePointEvent.apply(this, arguments);
        seriesOptions.allowPointSelect = temp;
      } else {
        Point_default.prototype.firePointEvent.apply(this, arguments);
      }
    };
    PackedBubblePoint2.prototype.select = function() {
      var point = this, series = this.series, chart = series.chart;
      if (point.isParentNode) {
        chart.getSelectedPoints = chart.getSelectedParentNodes;
        Point_default.prototype.select.apply(this, arguments);
        chart.getSelectedPoints = Chart_default.prototype.getSelectedPoints;
      } else {
        Point_default.prototype.select.apply(this, arguments);
      }
    };
    return PackedBubblePoint2;
  }(BubbleSeries2.prototype.pointClass)
);
var PackedBubblePoint_default = PackedBubblePoint;

// node_modules/highcharts/es-modules/Series/Networkgraph/DraggableNodes.js
var addEvent44 = Utilities_default.addEvent;
Globals_default.dragNodesMixin = {
  /**
   * Mouse down action, initializing drag&drop mode.
   *
   * @private
   * @param {Highcharts.Point} point The point that event occured.
   * @param {Highcharts.PointerEventObject} event Browser event, before normalization.
   * @return {void}
   */
  onMouseDown: function(point, event) {
    var normalizedEvent = this.chart.pointer.normalize(event);
    point.fixedPosition = {
      chartX: normalizedEvent.chartX,
      chartY: normalizedEvent.chartY,
      plotX: point.plotX,
      plotY: point.plotY
    };
    point.inDragMode = true;
  },
  /**
   * Mouse move action during drag&drop.
   *
   * @private
   *
   * @param {global.Event} event Browser event, before normalization.
   * @param {Highcharts.Point} point The point that event occured.
   *
   * @return {void}
   */
  onMouseMove: function(point, event) {
    if (point.fixedPosition && point.inDragMode) {
      var series = this, chart = series.chart, normalizedEvent = chart.pointer.normalize(event), diffX = point.fixedPosition.chartX - normalizedEvent.chartX, diffY = point.fixedPosition.chartY - normalizedEvent.chartY, newPlotX = void 0, newPlotY = void 0, graphLayoutsLookup = chart.graphLayoutsLookup;
      if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
        newPlotX = point.fixedPosition.plotX - diffX;
        newPlotY = point.fixedPosition.plotY - diffY;
        if (chart.isInsidePlot(newPlotX, newPlotY)) {
          point.plotX = newPlotX;
          point.plotY = newPlotY;
          point.hasDragged = true;
          this.redrawHalo(point);
          graphLayoutsLookup.forEach(function(layout) {
            layout.restartSimulation();
          });
        }
      }
    }
  },
  /**
   * Mouse up action, finalizing drag&drop.
   *
   * @private
   * @param {Highcharts.Point} point The point that event occured.
   * @return {void}
   */
  onMouseUp: function(point, event) {
    if (point.fixedPosition) {
      if (point.hasDragged) {
        if (this.layout.enableSimulation) {
          this.layout.start();
        } else {
          this.chart.redraw();
        }
      }
      point.inDragMode = point.hasDragged = false;
      if (!this.options.fixedDraggable) {
        delete point.fixedPosition;
      }
    }
  },
  // Draggable mode:
  /**
   * Redraw halo on mousemove during the drag&drop action.
   *
   * @private
   * @param {Highcharts.Point} point The point that should show halo.
   * @return {void}
   */
  redrawHalo: function(point) {
    if (point && this.halo) {
      this.halo.attr({
        d: point.haloPath(this.options.states.hover.halo.size)
      });
    }
  }
};
addEvent44(Chart_default, "load", function() {
  var chart = this, mousedownUnbinder, mousemoveUnbinder, mouseupUnbinder;
  if (chart.container) {
    mousedownUnbinder = addEvent44(chart.container, "mousedown", function(event) {
      var point = chart.hoverPoint;
      if (point && point.series && point.series.hasDraggableNodes && point.series.options.draggable) {
        point.series.onMouseDown(point, event);
        mousemoveUnbinder = addEvent44(chart.container, "mousemove", function(e2) {
          return point && point.series && point.series.onMouseMove(point, e2);
        });
        mouseupUnbinder = addEvent44(chart.container.ownerDocument, "mouseup", function(e2) {
          mousemoveUnbinder();
          mouseupUnbinder();
          return point && point.series && point.series.onMouseUp(point, e2);
        });
      }
    });
  }
  addEvent44(chart, "destroy", function() {
    mousedownUnbinder();
  });
});

// node_modules/highcharts/es-modules/Series/Networkgraph/Integrations.js
Globals_default.networkgraphIntegrations = {
  verlet: {
    /**
     * Attractive force funtion. Can be replaced by API's
     * `layoutAlgorithm.attractiveForce`
     *
     * @private
     * @param {number} d current distance between two nodes
     * @param {number} k expected distance between two nodes
     * @return {number} force
     */
    attractiveForceFunction: function(d, k) {
      return (k - d) / d;
    },
    /**
     * Repulsive force funtion. Can be replaced by API's
     * `layoutAlgorithm.repulsiveForce`
     *
     * @private
     * @param {number} d current distance between two nodes
     * @param {number} k expected distance between two nodes
     * @return {number} force
     */
    repulsiveForceFunction: function(d, k) {
      return (k - d) / d * (k > d ? 1 : 0);
    },
    /**
     * Barycenter force. Calculate and applys barycenter forces on the
     * nodes. Making them closer to the center of their barycenter point.
     *
     * In Verlet integration, force is applied on a node immidatelly to it's
     * `plotX` and `plotY` position.
     *
     * @private
     * @return {void}
     */
    barycenter: function() {
      var gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;
      xFactor = (xFactor - (this.box.left + this.box.width) / 2) * gravitationalConstant;
      yFactor = (yFactor - (this.box.top + this.box.height) / 2) * gravitationalConstant;
      this.nodes.forEach(function(node) {
        if (!node.fixedPosition) {
          node.plotX -= xFactor / node.mass / node.degree;
          node.plotY -= yFactor / node.mass / node.degree;
        }
      });
    },
    /**
     * Repulsive force.
     *
     * In Verlet integration, force is applied on a node immidatelly to it's
     * `plotX` and `plotY` position.
     *
     * @private
     * @param {Highcharts.Point} node
     *        Node that should be translated by force.
     * @param {number} force
     *        Force calcualated in `repulsiveForceFunction`
     * @param {Highcharts.PositionObject} distance
     *        Distance between two nodes e.g. `{x, y}`
     * @return {void}
     */
    repulsive: function(node, force, distanceXY) {
      var factor = force * this.diffTemperature / node.mass / node.degree;
      if (!node.fixedPosition) {
        node.plotX += distanceXY.x * factor;
        node.plotY += distanceXY.y * factor;
      }
    },
    /**
     * Attractive force.
     *
     * In Verlet integration, force is applied on a node immidatelly to it's
     * `plotX` and `plotY` position.
     *
     * @private
     * @param {Highcharts.Point} link
     *        Link that connects two nodes
     * @param {number} force
     *        Force calcualated in `repulsiveForceFunction`
     * @param {Highcharts.PositionObject} distance
     *        Distance between two nodes e.g. `{x, y}`
     * @return {void}
     */
    attractive: function(link, force, distanceXY) {
      var massFactor = link.getMass(), translatedX = -distanceXY.x * force * this.diffTemperature, translatedY = -distanceXY.y * force * this.diffTemperature;
      if (!link.fromNode.fixedPosition) {
        link.fromNode.plotX -= translatedX * massFactor.fromNode / link.fromNode.degree;
        link.fromNode.plotY -= translatedY * massFactor.fromNode / link.fromNode.degree;
      }
      if (!link.toNode.fixedPosition) {
        link.toNode.plotX += translatedX * massFactor.toNode / link.toNode.degree;
        link.toNode.plotY += translatedY * massFactor.toNode / link.toNode.degree;
      }
    },
    /**
     * Integration method.
     *
     * In Verlet integration, forces are applied on node immidatelly to it's
     * `plotX` and `plotY` position.
     *
     * Verlet without velocity:
     *
     *    x(n+1) = 2 * x(n) - x(n-1) + A(T) * deltaT ^ 2
     *
     * where:
     *     - x(n+1) - new position
     *     - x(n) - current position
     *     - x(n-1) - previous position
     *
     * Assuming A(t) = 0 (no acceleration) and (deltaT = 1) we get:
     *
     *     x(n+1) = x(n) + (x(n) - x(n-1))
     *
     * where:
     *     - (x(n) - x(n-1)) - position change
     *
     * TO DO:
     * Consider Verlet with velocity to support additional
     * forces. Or even Time-Corrected Verlet by Jonathan
     * "lonesock" Dummer
     *
     * @private
     * @param {Highcharts.NetworkgraphLayout} layout layout object
     * @param {Highcharts.Point} node node that should be translated
     * @return {void}
     */
    integrate: function(layout, node) {
      var friction = -layout.options.friction, maxSpeed = layout.options.maxSpeed, prevX = node.prevX, prevY = node.prevY, diffX = (node.plotX + node.dispX - prevX) * friction, diffY = (node.plotY + node.dispY - prevY) * friction, abs = Math.abs, signX = abs(diffX) / (diffX || 1), signY = abs(diffY) / (diffY || 1);
      diffX = signX * Math.min(maxSpeed, Math.abs(diffX));
      diffY = signY * Math.min(maxSpeed, Math.abs(diffY));
      node.prevX = node.plotX + node.dispX;
      node.prevY = node.plotY + node.dispY;
      node.plotX += diffX;
      node.plotY += diffY;
      node.temperature = layout.vectorLength({
        x: diffX,
        y: diffY
      });
    },
    /**
     * Estiamte the best possible distance between two nodes, making graph
     * readable.
     *
     * @private
     * @param {Highcharts.NetworkgraphLayout} layout layout object
     * @return {number}
     */
    getK: function(layout) {
      return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.5);
    }
  },
  euler: {
    /**
     * Attractive force funtion. Can be replaced by API's
     * `layoutAlgorithm.attractiveForce`
     *
     * Other forces that can be used:
     *
     * basic, not recommended:
     *    `function (d, k) { return d / k }`
     *
     * @private
     * @param {number} d current distance between two nodes
     * @param {number} k expected distance between two nodes
     * @return {number} force
     */
    attractiveForceFunction: function(d, k) {
      return d * d / k;
    },
    /**
     * Repulsive force funtion. Can be replaced by API's
     * `layoutAlgorithm.repulsiveForce`.
     *
     * Other forces that can be used:
     *
     * basic, not recommended:
     *    `function (d, k) { return k / d }`
     *
     * standard:
     *    `function (d, k) { return k * k / d }`
     *
     * grid-variant:
     *    `function (d, k) { return k * k / d * (2 * k - d > 0 ? 1 : 0) }`
     *
     * @private
     * @param {number} d current distance between two nodes
     * @param {number} k expected distance between two nodes
     * @return {number} force
     */
    repulsiveForceFunction: function(d, k) {
      return k * k / d;
    },
    /**
     * Barycenter force. Calculate and applys barycenter forces on the
     * nodes. Making them closer to the center of their barycenter point.
     *
     * In Euler integration, force is stored in a node, not changing it's
     * position. Later, in `integrate()` forces are applied on nodes.
     *
     * @private
     * @return {void}
     */
    barycenter: function() {
      var gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;
      this.nodes.forEach(function(node) {
        if (!node.fixedPosition) {
          var degree = node.getDegree(), phi = degree * (1 + degree / 2);
          node.dispX += (xFactor - node.plotX) * gravitationalConstant * phi / node.degree;
          node.dispY += (yFactor - node.plotY) * gravitationalConstant * phi / node.degree;
        }
      });
    },
    /**
     * Repulsive force.
     *
     * @private
     * @param {Highcharts.Point} node
     *        Node that should be translated by force.
     * @param {number} force
     *        Force calcualated in `repulsiveForceFunction`
     * @param {Highcharts.PositionObject} distanceXY
     *        Distance between two nodes e.g. `{x, y}`
     * @return {void}
     */
    repulsive: function(node, force, distanceXY, distanceR) {
      node.dispX += distanceXY.x / distanceR * force / node.degree;
      node.dispY += distanceXY.y / distanceR * force / node.degree;
    },
    /**
     * Attractive force.
     *
     * In Euler integration, force is stored in a node, not changing it's
     * position. Later, in `integrate()` forces are applied on nodes.
     *
     * @private
     * @param {Highcharts.Point} link
     *        Link that connects two nodes
     * @param {number} force
     *        Force calcualated in `repulsiveForceFunction`
     * @param {Highcharts.PositionObject} distanceXY
     *        Distance between two nodes e.g. `{x, y}`
     * @param {number} distanceR
     * @return {void}
     */
    attractive: function(link, force, distanceXY, distanceR) {
      var massFactor = link.getMass(), translatedX = distanceXY.x / distanceR * force, translatedY = distanceXY.y / distanceR * force;
      if (!link.fromNode.fixedPosition) {
        link.fromNode.dispX -= translatedX * massFactor.fromNode / link.fromNode.degree;
        link.fromNode.dispY -= translatedY * massFactor.fromNode / link.fromNode.degree;
      }
      if (!link.toNode.fixedPosition) {
        link.toNode.dispX += translatedX * massFactor.toNode / link.toNode.degree;
        link.toNode.dispY += translatedY * massFactor.toNode / link.toNode.degree;
      }
    },
    /**
     * Integration method.
     *
     * In Euler integration, force were stored in a node, not changing it's
     * position. Now, in the integrator method, we apply changes.
     *
     * Euler:
     *
     * Basic form: `x(n+1) = x(n) + v(n)`
     *
     * With Rengoild-Fruchterman we get:
     * `x(n+1) = x(n) + v(n) / length(v(n)) * min(v(n), temperature(n))`
     * where:
     * - `x(n+1)`: next position
     * - `x(n)`: current position
     * - `v(n)`: velocity (comes from net force)
     * - `temperature(n)`: current temperature
     *
     * Known issues:
     * Oscillations when force vector has the same magnitude but opposite
     * direction in the next step. Potentially solved by decreasing force by
     * `v * (1 / node.degree)`
     *
     * Note:
     * Actually `min(v(n), temperature(n))` replaces simulated annealing.
     *
     * @private
     * @param {Highcharts.NetworkgraphLayout} layout
     *        Layout object
     * @param {Highcharts.Point} node
     *        Node that should be translated
     * @return {void}
     */
    integrate: function(layout, node) {
      var distanceR;
      node.dispX += node.dispX * layout.options.friction;
      node.dispY += node.dispY * layout.options.friction;
      distanceR = node.temperature = layout.vectorLength({
        x: node.dispX,
        y: node.dispY
      });
      if (distanceR !== 0) {
        node.plotX += node.dispX / distanceR * Math.min(Math.abs(node.dispX), layout.temperature);
        node.plotY += node.dispY / distanceR * Math.min(Math.abs(node.dispY), layout.temperature);
      }
    },
    /**
     * Estiamte the best possible distance between two nodes, making graph
     * readable.
     *
     * @private
     * @param {object} layout layout object
     * @return {number}
     */
    getK: function(layout) {
      return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.3);
    }
  }
};

// node_modules/highcharts/es-modules/Series/Networkgraph/QuadTree.js
var extend62 = Utilities_default.extend;
var QuadTreeNode = Globals_default.QuadTreeNode = function(box) {
  this.box = box;
  this.boxSize = Math.min(box.width, box.height);
  this.nodes = [];
  this.isInternal = false;
  this.body = false;
  this.isEmpty = true;
};
extend62(
  QuadTreeNode.prototype,
  /** @lends Highcharts.QuadTreeNode.prototype */
  {
    /**
     * Insert recursively point(node) into the QuadTree. If the given
     * quadrant is already occupied, divide it into smaller quadrants.
     *
     * @param {Highcharts.Point} point
     *        Point/node to be inserted
     * @param {number} depth
     *        Max depth of the QuadTree
     */
    insert: function(point, depth) {
      var newQuadTreeNode;
      if (this.isInternal) {
        this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
      } else {
        this.isEmpty = false;
        if (!this.body) {
          this.isInternal = false;
          this.body = point;
        } else {
          if (depth) {
            this.isInternal = true;
            this.divideBox();
            if (this.body !== true) {
              this.nodes[this.getBoxPosition(this.body)].insert(this.body, depth - 1);
              this.body = true;
            }
            this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
          } else {
            newQuadTreeNode = new QuadTreeNode({
              top: point.plotX,
              left: point.plotY,
              // Width/height below 1px
              width: 0.1,
              height: 0.1
            });
            newQuadTreeNode.body = point;
            newQuadTreeNode.isInternal = false;
            this.nodes.push(newQuadTreeNode);
          }
        }
      }
    },
    /**
     * Each quad node requires it's mass and center position. That mass and
     * position is used to imitate real node in the layout by approximation.
     */
    updateMassAndCenter: function() {
      var mass = 0, plotX = 0, plotY = 0;
      if (this.isInternal) {
        this.nodes.forEach(function(pointMass) {
          if (!pointMass.isEmpty) {
            mass += pointMass.mass;
            plotX += pointMass.plotX * pointMass.mass;
            plotY += pointMass.plotY * pointMass.mass;
          }
        });
        plotX /= mass;
        plotY /= mass;
      } else if (this.body) {
        mass = this.body.mass;
        plotX = this.body.plotX;
        plotY = this.body.plotY;
      }
      this.mass = mass;
      this.plotX = plotX;
      this.plotY = plotY;
    },
    /**
     * When inserting another node into the box, that already hove one node,
     * divide the available space into another four quadrants.
     *
     * Indexes of quadrants are:
     * ```
     * -------------               -------------
     * |           |               |     |     |
     * |           |               |  0  |  1  |
     * |           |   divide()    |     |     |
     * |     1     | ----------->  -------------
     * |           |               |     |     |
     * |           |               |  3  |  2  |
     * |           |               |     |     |
     * -------------               -------------
     * ```
     */
    divideBox: function() {
      var halfWidth = this.box.width / 2, halfHeight = this.box.height / 2;
      this.nodes[0] = new QuadTreeNode({
        left: this.box.left,
        top: this.box.top,
        width: halfWidth,
        height: halfHeight
      });
      this.nodes[1] = new QuadTreeNode({
        left: this.box.left + halfWidth,
        top: this.box.top,
        width: halfWidth,
        height: halfHeight
      });
      this.nodes[2] = new QuadTreeNode({
        left: this.box.left + halfWidth,
        top: this.box.top + halfHeight,
        width: halfWidth,
        height: halfHeight
      });
      this.nodes[3] = new QuadTreeNode({
        left: this.box.left,
        top: this.box.top + halfHeight,
        width: halfWidth,
        height: halfHeight
      });
    },
    /**
     * Determine which of the quadrants should be used when placing node in
     * the QuadTree. Returned index is always in range `< 0 , 3 >`.
     *
     * @param {Highcharts.Point} point
     * @return {number}
     */
    getBoxPosition: function(point) {
      var left = point.plotX < this.box.left + this.box.width / 2, top = point.plotY < this.box.top + this.box.height / 2, index;
      if (left) {
        if (top) {
          index = 0;
        } else {
          index = 3;
        }
      } else {
        if (top) {
          index = 1;
        } else {
          index = 2;
        }
      }
      return index;
    }
  }
);
var QuadTree = Globals_default.QuadTree = function(x, y, width, height) {
  this.box = {
    left: x,
    top: y,
    width,
    height
  };
  this.maxDepth = 25;
  this.root = new QuadTreeNode(this.box, "0");
  this.root.isInternal = true;
  this.root.isRoot = true;
  this.root.divideBox();
};
extend62(
  QuadTree.prototype,
  /** @lends Highcharts.QuadTree.prototype */
  {
    /**
     * Insert nodes into the QuadTree
     *
     * @param {Array<Highcharts.Point>} points
     */
    insertNodes: function(points) {
      points.forEach(function(point) {
        this.root.insert(point, this.maxDepth);
      }, this);
    },
    /**
     * Depfth first treversal (DFS). Using `before` and `after` callbacks,
     * we can get two results: preorder and postorder traversals, reminder:
     *
     * ```
     *     (a)
     *     / \
     *   (b) (c)
     *   / \
     * (d) (e)
     * ```
     *
     * DFS (preorder): `a -> b -> d -> e -> c`
     *
     * DFS (postorder): `d -> e -> b -> c -> a`
     *
     * @param {Highcharts.QuadTreeNode|null} node
     * @param {Function} [beforeCallback] function to be called before
     *                      visiting children nodes
     * @param {Function} [afterCallback] function to be called after
     *                      visiting children nodes
     */
    visitNodeRecursive: function(node, beforeCallback, afterCallback) {
      var goFurther;
      if (!node) {
        node = this.root;
      }
      if (node === this.root && beforeCallback) {
        goFurther = beforeCallback(node);
      }
      if (goFurther === false) {
        return;
      }
      node.nodes.forEach(function(qtNode) {
        if (qtNode.isInternal) {
          if (beforeCallback) {
            goFurther = beforeCallback(qtNode);
          }
          if (goFurther === false) {
            return;
          }
          this.visitNodeRecursive(qtNode, beforeCallback, afterCallback);
        } else if (qtNode.body) {
          if (beforeCallback) {
            beforeCallback(qtNode.body);
          }
        }
        if (afterCallback) {
          afterCallback(qtNode);
        }
      }, this);
      if (node === this.root && afterCallback) {
        afterCallback(node);
      }
    },
    /**
     * Calculate mass of the each QuadNode in the tree.
     */
    calculateMassAndCenter: function() {
      this.visitNodeRecursive(null, null, function(node) {
        node.updateMassAndCenter();
      });
    }
  }
);

// node_modules/highcharts/es-modules/Series/Networkgraph/Layouts.js
var setAnimation6 = AnimationUtilities_default.setAnimation;
var addEvent45 = Utilities_default.addEvent;
var clamp16 = Utilities_default.clamp;
var defined45 = Utilities_default.defined;
var extend63 = Utilities_default.extend;
var isFunction7 = Utilities_default.isFunction;
var pick68 = Utilities_default.pick;
Globals_default.layouts = {
  "reingold-fruchterman": function() {
  }
};
extend63(
  /**
   * Reingold-Fruchterman algorithm from
   * "Graph Drawing by Force-directed Placement" paper.
   * @private
   */
  Globals_default.layouts["reingold-fruchterman"].prototype,
  {
    init: function(options) {
      this.options = options;
      this.nodes = [];
      this.links = [];
      this.series = [];
      this.box = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      this.setInitialRendering(true);
      this.integration = Globals_default.networkgraphIntegrations[options.integration];
      this.enableSimulation = options.enableSimulation;
      this.attractiveForce = pick68(options.attractiveForce, this.integration.attractiveForceFunction);
      this.repulsiveForce = pick68(options.repulsiveForce, this.integration.repulsiveForceFunction);
      this.approximation = options.approximation;
    },
    updateSimulation: function(enable) {
      this.enableSimulation = pick68(enable, this.options.enableSimulation);
    },
    start: function() {
      var layout = this, series = this.series, options = this.options;
      layout.currentStep = 0;
      layout.forces = series[0] && series[0].forces || [];
      layout.chart = series[0] && series[0].chart;
      if (layout.initialRendering) {
        layout.initPositions();
        series.forEach(function(s) {
          s.finishedAnimating = true;
          s.render();
        });
      }
      layout.setK();
      layout.resetSimulation(options);
      if (layout.enableSimulation) {
        layout.step();
      }
    },
    step: function() {
      var layout = this, series = this.series, options = this.options;
      layout.currentStep++;
      if (layout.approximation === "barnes-hut") {
        layout.createQuadTree();
        layout.quadTree.calculateMassAndCenter();
      }
      layout.forces.forEach(function(forceName) {
        layout[forceName + "Forces"](layout.temperature);
      });
      layout.applyLimits(layout.temperature);
      layout.temperature = layout.coolDown(layout.startTemperature, layout.diffTemperature, layout.currentStep);
      layout.prevSystemTemperature = layout.systemTemperature;
      layout.systemTemperature = layout.getSystemTemperature();
      if (layout.enableSimulation) {
        series.forEach(function(s) {
          if (s.chart) {
            s.render();
          }
        });
        if (layout.maxIterations-- && isFinite(layout.temperature) && !layout.isStable()) {
          if (layout.simulation) {
            Globals_default.win.cancelAnimationFrame(layout.simulation);
          }
          layout.simulation = Globals_default.win.requestAnimationFrame(function() {
            layout.step();
          });
        } else {
          layout.simulation = false;
        }
      }
    },
    stop: function() {
      if (this.simulation) {
        Globals_default.win.cancelAnimationFrame(this.simulation);
      }
    },
    setArea: function(x, y, w2, h) {
      this.box = {
        left: x,
        top: y,
        width: w2,
        height: h
      };
    },
    setK: function() {
      this.k = this.options.linkLength || this.integration.getK(this);
    },
    addElementsToCollection: function(elements, collection) {
      elements.forEach(function(elem) {
        if (collection.indexOf(elem) === -1) {
          collection.push(elem);
        }
      });
    },
    removeElementFromCollection: function(element, collection) {
      var index = collection.indexOf(element);
      if (index !== -1) {
        collection.splice(index, 1);
      }
    },
    clear: function() {
      this.nodes.length = 0;
      this.links.length = 0;
      this.series.length = 0;
      this.resetSimulation();
    },
    resetSimulation: function() {
      this.forcedStop = false;
      this.systemTemperature = 0;
      this.setMaxIterations();
      this.setTemperature();
      this.setDiffTemperature();
    },
    restartSimulation: function() {
      if (!this.simulation) {
        this.setInitialRendering(false);
        if (!this.enableSimulation) {
          this.setMaxIterations(1);
        } else {
          this.start();
        }
        if (this.chart) {
          this.chart.redraw();
        }
        this.setInitialRendering(true);
      } else {
        this.resetSimulation();
      }
    },
    setMaxIterations: function(maxIterations) {
      this.maxIterations = pick68(maxIterations, this.options.maxIterations);
    },
    setTemperature: function() {
      this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);
    },
    setDiffTemperature: function() {
      this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);
    },
    setInitialRendering: function(enable) {
      this.initialRendering = enable;
    },
    createQuadTree: function() {
      this.quadTree = new Globals_default.QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);
      this.quadTree.insertNodes(this.nodes);
    },
    initPositions: function() {
      var initialPositions = this.options.initialPositions;
      if (isFunction7(initialPositions)) {
        initialPositions.call(this);
        this.nodes.forEach(function(node) {
          if (!defined45(node.prevX)) {
            node.prevX = node.plotX;
          }
          if (!defined45(node.prevY)) {
            node.prevY = node.plotY;
          }
          node.dispX = 0;
          node.dispY = 0;
        });
      } else if (initialPositions === "circle") {
        this.setCircularPositions();
      } else {
        this.setRandomPositions();
      }
    },
    setCircularPositions: function() {
      var box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, rootNodes = nodes.filter(function(node) {
        return node.linksTo.length === 0;
      }), sortedNodes = [], visitedNodes = {}, radius = this.options.initialPositionRadius;
      function addToNodes(node) {
        node.linksFrom.forEach(function(link) {
          if (!visitedNodes[link.toNode.id]) {
            visitedNodes[link.toNode.id] = true;
            sortedNodes.push(link.toNode);
            addToNodes(link.toNode);
          }
        });
      }
      rootNodes.forEach(function(rootNode) {
        sortedNodes.push(rootNode);
        addToNodes(rootNode);
      });
      if (!sortedNodes.length) {
        sortedNodes = nodes;
      } else {
        nodes.forEach(function(node) {
          if (sortedNodes.indexOf(node) === -1) {
            sortedNodes.push(node);
          }
        });
      }
      sortedNodes.forEach(function(node, index) {
        node.plotX = node.prevX = pick68(node.plotX, box.width / 2 + radius * Math.cos(index * angle));
        node.plotY = node.prevY = pick68(node.plotY, box.height / 2 + radius * Math.sin(index * angle));
        node.dispX = 0;
        node.dispY = 0;
      });
    },
    setRandomPositions: function() {
      var box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1;
      function unrandom(n) {
        var rand = n * n / Math.PI;
        rand = rand - Math.floor(rand);
        return rand;
      }
      nodes.forEach(function(node, index) {
        node.plotX = node.prevX = pick68(node.plotX, box.width * unrandom(index));
        node.plotY = node.prevY = pick68(node.plotY, box.height * unrandom(nodesLength + index));
        node.dispX = 0;
        node.dispY = 0;
      });
    },
    force: function(name) {
      this.integration[name].apply(this, Array.prototype.slice.call(arguments, 1));
    },
    barycenterForces: function() {
      this.getBarycenter();
      this.force("barycenter");
    },
    getBarycenter: function() {
      var systemMass = 0, cx = 0, cy = 0;
      this.nodes.forEach(function(node) {
        cx += node.plotX * node.mass;
        cy += node.plotY * node.mass;
        systemMass += node.mass;
      });
      this.barycenter = {
        x: cx,
        y: cy,
        xFactor: cx / systemMass,
        yFactor: cy / systemMass
      };
      return this.barycenter;
    },
    barnesHutApproximation: function(node, quadNode) {
      var layout = this, distanceXY = layout.getDistXY(node, quadNode), distanceR = layout.vectorLength(distanceXY), goDeeper, force;
      if (node !== quadNode && distanceR !== 0) {
        if (quadNode.isInternal) {
          if (quadNode.boxSize / distanceR < layout.options.theta && distanceR !== 0) {
            force = layout.repulsiveForce(distanceR, layout.k);
            layout.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
            goDeeper = false;
          } else {
            goDeeper = true;
          }
        } else {
          force = layout.repulsiveForce(distanceR, layout.k);
          layout.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
        }
      }
      return goDeeper;
    },
    repulsiveForces: function() {
      var layout = this;
      if (layout.approximation === "barnes-hut") {
        layout.nodes.forEach(function(node) {
          layout.quadTree.visitNodeRecursive(null, function(quadNode) {
            return layout.barnesHutApproximation(node, quadNode);
          });
        });
      } else {
        layout.nodes.forEach(function(node) {
          layout.nodes.forEach(function(repNode) {
            var force, distanceR, distanceXY;
            if (
              // Node can not repulse itself:
              node !== repNode && // Only close nodes affect each other:
              // layout.getDistR(node, repNode) < 2 * k &&
              // Not dragged:
              !node.fixedPosition
            ) {
              distanceXY = layout.getDistXY(node, repNode);
              distanceR = layout.vectorLength(distanceXY);
              if (distanceR !== 0) {
                force = layout.repulsiveForce(distanceR, layout.k);
                layout.force("repulsive", node, force * repNode.mass, distanceXY, distanceR);
              }
            }
          });
        });
      }
    },
    attractiveForces: function() {
      var layout = this, distanceXY, distanceR, force;
      layout.links.forEach(function(link) {
        if (link.fromNode && link.toNode) {
          distanceXY = layout.getDistXY(link.fromNode, link.toNode);
          distanceR = layout.vectorLength(distanceXY);
          if (distanceR !== 0) {
            force = layout.attractiveForce(distanceR, layout.k);
            layout.force("attractive", link, force, distanceXY, distanceR);
          }
        }
      });
    },
    applyLimits: function() {
      var layout = this, nodes = layout.nodes;
      nodes.forEach(function(node) {
        if (node.fixedPosition) {
          return;
        }
        layout.integration.integrate(layout, node);
        layout.applyLimitBox(node, layout.box);
        node.dispX = 0;
        node.dispY = 0;
      });
    },
    /**
     * External box that nodes should fall. When hitting an edge, node
     * should stop or bounce.
     * @private
     */
    applyLimitBox: function(node, box) {
      var radius = node.radius;
      node.plotX = clamp16(node.plotX, box.left + radius, box.width - radius);
      node.plotY = clamp16(node.plotY, box.top + radius, box.height - radius);
    },
    /**
     * From "A comparison of simulated annealing cooling strategies" by
     * Nourani and Andresen work.
     * @private
     */
    coolDown: function(temperature, temperatureStep, currentStep) {
      return temperature - temperatureStep * currentStep;
    },
    isStable: function() {
      return Math.abs(this.systemTemperature - this.prevSystemTemperature) < 1e-5 || this.temperature <= 0;
    },
    getSystemTemperature: function() {
      return this.nodes.reduce(function(value, node) {
        return value + node.temperature;
      }, 0);
    },
    vectorLength: function(vector) {
      return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
    },
    getDistR: function(nodeA, nodeB) {
      var distance = this.getDistXY(nodeA, nodeB);
      return this.vectorLength(distance);
    },
    getDistXY: function(nodeA, nodeB) {
      var xDist = nodeA.plotX - nodeB.plotX, yDist = nodeA.plotY - nodeB.plotY;
      return {
        x: xDist,
        y: yDist,
        absX: Math.abs(xDist),
        absY: Math.abs(yDist)
      };
    }
  }
);
addEvent45(Chart_default, "predraw", function() {
  if (this.graphLayoutsLookup) {
    this.graphLayoutsLookup.forEach(function(layout) {
      layout.stop();
    });
  }
});
addEvent45(Chart_default, "render", function() {
  var systemsStable, afterRender = false;
  function layoutStep(layout) {
    if (layout.maxIterations-- && isFinite(layout.temperature) && !layout.isStable() && !layout.enableSimulation) {
      if (layout.beforeStep) {
        layout.beforeStep();
      }
      layout.step();
      systemsStable = false;
      afterRender = true;
    }
  }
  if (this.graphLayoutsLookup) {
    setAnimation6(false, this);
    this.graphLayoutsLookup.forEach(function(layout) {
      layout.start();
    });
    while (!systemsStable) {
      systemsStable = true;
      this.graphLayoutsLookup.forEach(layoutStep);
    }
    if (afterRender) {
      this.series.forEach(function(s) {
        if (s && s.layout) {
          s.render();
        }
      });
    }
  }
});
addEvent45(Chart_default, "beforePrint", function() {
  if (this.graphLayoutsLookup) {
    this.graphLayoutsLookup.forEach(function(layout) {
      layout.updateSimulation(false);
    });
    this.redraw();
  }
});
addEvent45(Chart_default, "afterPrint", function() {
  if (this.graphLayoutsLookup) {
    this.graphLayoutsLookup.forEach(function(layout) {
      layout.updateSimulation();
    });
  }
  this.redraw();
});

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleComposition.js
var Reingold = Globals_default.layouts["reingold-fruchterman"];
var addEvent46 = Utilities_default.addEvent;
var extendClass3 = Utilities_default.extendClass;
var pick69 = Utilities_default.pick;
Chart_default.prototype.getSelectedParentNodes = function() {
  var chart = this, series = chart.series, selectedParentsNodes = [];
  series.forEach(function(series2) {
    if (series2.parentNode && series2.parentNode.selected) {
      selectedParentsNodes.push(series2.parentNode);
    }
  });
  return selectedParentsNodes;
};
Globals_default.networkgraphIntegrations.packedbubble = {
  repulsiveForceFunction: function(d, k, node, repNode) {
    return Math.min(d, (node.marker.radius + repNode.marker.radius) / 2);
  },
  barycenter: function() {
    var layout = this, gravitationalConstant = layout.options.gravitationalConstant, box = layout.box, nodes = layout.nodes, centerX, centerY;
    nodes.forEach(function(node) {
      if (layout.options.splitSeries && !node.isParentNode) {
        centerX = node.series.parentNode.plotX;
        centerY = node.series.parentNode.plotY;
      } else {
        centerX = box.width / 2;
        centerY = box.height / 2;
      }
      if (!node.fixedPosition) {
        node.plotX -= (node.plotX - centerX) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length));
        node.plotY -= (node.plotY - centerY) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length));
      }
    });
  },
  repulsive: function(node, force, distanceXY, repNode) {
    var factor = force * this.diffTemperature / node.mass / node.degree, x = distanceXY.x * factor, y = distanceXY.y * factor;
    if (!node.fixedPosition) {
      node.plotX += x;
      node.plotY += y;
    }
    if (!repNode.fixedPosition) {
      repNode.plotX -= x;
      repNode.plotY -= y;
    }
  },
  integrate: Globals_default.networkgraphIntegrations.verlet.integrate,
  getK: Globals_default.noop
};
Globals_default.layouts.packedbubble = extendClass3(Reingold, {
  beforeStep: function() {
    if (this.options.marker) {
      this.series.forEach(function(series) {
        if (series) {
          series.calculateParentRadius();
        }
      });
    }
  },
  isStable: function() {
    var tempDiff = Math.abs(this.prevSystemTemperature - this.systemTemperature);
    var upScaledTemperature = 10 * this.systemTemperature / Math.sqrt(this.nodes.length);
    return Math.abs(upScaledTemperature) < 1 && tempDiff < 1e-5 || this.temperature <= 0;
  },
  setCircularPositions: function() {
    var layout = this, box = layout.box, nodes = layout.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, centerX, centerY, radius = layout.options.initialPositionRadius;
    nodes.forEach(function(node, index) {
      if (layout.options.splitSeries && !node.isParentNode) {
        centerX = node.series.parentNode.plotX;
        centerY = node.series.parentNode.plotY;
      } else {
        centerX = box.width / 2;
        centerY = box.height / 2;
      }
      node.plotX = node.prevX = pick69(node.plotX, centerX + radius * Math.cos(node.index || index * angle));
      node.plotY = node.prevY = pick69(node.plotY, centerY + radius * Math.sin(node.index || index * angle));
      node.dispX = 0;
      node.dispY = 0;
    });
  },
  repulsiveForces: function() {
    var layout = this, force, distanceR, distanceXY, bubblePadding = layout.options.bubblePadding;
    layout.nodes.forEach(function(node) {
      node.degree = node.mass;
      node.neighbours = 0;
      layout.nodes.forEach(function(repNode) {
        force = 0;
        if (
          // Node can not repulse itself:
          node !== repNode && // Only close nodes affect each other:
          // Not dragged:
          !node.fixedPosition && (layout.options.seriesInteraction || node.series === repNode.series)
        ) {
          distanceXY = layout.getDistXY(node, repNode);
          distanceR = layout.vectorLength(distanceXY) - (node.marker.radius + repNode.marker.radius + bubblePadding);
          if (distanceR < 0) {
            node.degree += 0.01;
            node.neighbours++;
            force = layout.repulsiveForce(-distanceR / Math.sqrt(node.neighbours), layout.k, node, repNode);
          }
          layout.force("repulsive", node, force * repNode.mass, distanceXY, repNode, distanceR);
        }
      });
    });
  },
  applyLimitBox: function(node) {
    var layout = this, distanceXY, distanceR, factor = 0.01;
    if (layout.options.splitSeries && !node.isParentNode && layout.options.parentNodeLimit) {
      distanceXY = layout.getDistXY(node, node.series.parentNode);
      distanceR = node.series.parentNodeRadius - node.marker.radius - layout.vectorLength(distanceXY);
      if (distanceR < 0 && distanceR > -2 * node.marker.radius) {
        node.plotX -= distanceXY.x * factor;
        node.plotY -= distanceXY.y * factor;
      }
    }
    Reingold.prototype.applyLimitBox.apply(this, arguments);
  }
});
addEvent46(Chart_default, "beforeRedraw", function() {
  if (this.allDataPoints) {
    delete this.allDataPoints;
  }
});

// node_modules/highcharts/es-modules/Series/PackedBubble/PackedBubbleSeries.js
var __extends33 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color9 = Color_default.parse;
var Series6 = SeriesRegistry_default.series;
var BubbleSeries3 = SeriesRegistry_default.seriesTypes.bubble;
var addEvent47 = Utilities_default.addEvent;
var clamp17 = Utilities_default.clamp;
var defined46 = Utilities_default.defined;
var extend64 = Utilities_default.extend;
var fireEvent32 = Utilities_default.fireEvent;
var isArray20 = Utilities_default.isArray;
var isNumber41 = Utilities_default.isNumber;
var merge62 = Utilities_default.merge;
var pick70 = Utilities_default.pick;
var dragNodesMixin = Globals_default.dragNodesMixin;
var PackedBubbleSeries = (
  /** @class */
  function(_super) {
    __extends33(PackedBubbleSeries2, _super);
    function PackedBubbleSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.chart = void 0;
      _this.data = void 0;
      _this.layout = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.xData = void 0;
      return _this;
    }
    PackedBubbleSeries2.prototype.accumulateAllPoints = function(series) {
      var chart = series.chart, allDataPoints = [], i, j;
      for (i = 0; i < chart.series.length; i++) {
        series = chart.series[i];
        if (series.is("packedbubble") && // #13574
        series.visible || !chart.options.chart.ignoreHiddenSeries) {
          for (j = 0; j < series.yData.length; j++) {
            allDataPoints.push([
              null,
              null,
              series.yData[j],
              series.index,
              j,
              {
                id: j,
                marker: {
                  radius: 0
                }
              }
            ]);
          }
        }
      }
      return allDataPoints;
    };
    PackedBubbleSeries2.prototype.addLayout = function() {
      var series = this, layoutOptions = series.options.layoutAlgorithm, graphLayoutsStorage = series.chart.graphLayoutsStorage, graphLayoutsLookup = series.chart.graphLayoutsLookup, chartOptions = series.chart.options.chart, layout;
      if (!graphLayoutsStorage) {
        series.chart.graphLayoutsStorage = graphLayoutsStorage = {};
        series.chart.graphLayoutsLookup = graphLayoutsLookup = [];
      }
      layout = graphLayoutsStorage[layoutOptions.type];
      if (!layout) {
        layoutOptions.enableSimulation = !defined46(chartOptions.forExport) ? layoutOptions.enableSimulation : !chartOptions.forExport;
        graphLayoutsStorage[layoutOptions.type] = layout = new Globals_default.layouts[layoutOptions.type]();
        layout.init(layoutOptions);
        graphLayoutsLookup.splice(layout.index, 0, layout);
      }
      series.layout = layout;
      series.points.forEach(function(node) {
        node.mass = 2;
        node.degree = 1;
        node.collisionNmb = 1;
      });
      layout.setArea(0, 0, series.chart.plotWidth, series.chart.plotHeight);
      layout.addElementsToCollection([series], layout.series);
      layout.addElementsToCollection(series.points, layout.nodes);
    };
    PackedBubbleSeries2.prototype.addSeriesLayout = function() {
      var series = this, layoutOptions = series.options.layoutAlgorithm, graphLayoutsStorage = series.chart.graphLayoutsStorage, graphLayoutsLookup = series.chart.graphLayoutsLookup, parentNodeOptions = merge62(layoutOptions, layoutOptions.parentNodeOptions, {
        enableSimulation: series.layout.options.enableSimulation
      }), parentNodeLayout;
      parentNodeLayout = graphLayoutsStorage[layoutOptions.type + "-series"];
      if (!parentNodeLayout) {
        graphLayoutsStorage[layoutOptions.type + "-series"] = parentNodeLayout = new Globals_default.layouts[layoutOptions.type]();
        parentNodeLayout.init(parentNodeOptions);
        graphLayoutsLookup.splice(parentNodeLayout.index, 0, parentNodeLayout);
      }
      series.parentNodeLayout = parentNodeLayout;
      this.createParentNodes();
    };
    PackedBubbleSeries2.prototype.calculateParentRadius = function() {
      var series = this, bBox, parentPadding = 20, minParentRadius = 20;
      bBox = series.seriesBox();
      series.parentNodeRadius = clamp17(Math.sqrt(2 * series.parentNodeMass / Math.PI) + parentPadding, minParentRadius, bBox ? Math.max(Math.sqrt(Math.pow(bBox.width, 2) + Math.pow(bBox.height, 2)) / 2 + parentPadding, minParentRadius) : Math.sqrt(2 * series.parentNodeMass / Math.PI) + parentPadding);
      if (series.parentNode) {
        series.parentNode.marker.radius = series.parentNode.radius = series.parentNodeRadius;
      }
    };
    PackedBubbleSeries2.prototype.calculateZExtremes = function() {
      var chart = this.chart, zMin = this.options.zMin, zMax = this.options.zMax, valMin = Infinity, valMax = -Infinity;
      if (zMin && zMax) {
        return [zMin, zMax];
      }
      chart.series.forEach(function(s) {
        s.yData.forEach(function(p) {
          if (defined46(p)) {
            if (p > valMax) {
              valMax = p;
            }
            if (p < valMin) {
              valMin = p;
            }
          }
        });
      });
      zMin = pick70(zMin, valMin);
      zMax = pick70(zMax, valMax);
      return [zMin, zMax];
    };
    PackedBubbleSeries2.prototype.checkOverlap = function(bubble1, bubble2) {
      var diffX = bubble1[0] - bubble2[0], diffY = bubble1[1] - bubble2[1], sumRad = bubble1[2] + bubble2[2];
      return Math.sqrt(diffX * diffX + diffY * diffY) - Math.abs(sumRad) < -1e-3;
    };
    PackedBubbleSeries2.prototype.createParentNodes = function() {
      var series = this, chart = series.chart, parentNodeLayout = series.parentNodeLayout, nodeAdded, parentNode = series.parentNode, PackedBubblePoint2 = series.pointClass;
      series.parentNodeMass = 0;
      series.points.forEach(function(p) {
        series.parentNodeMass += Math.PI * Math.pow(p.marker.radius, 2);
      });
      series.calculateParentRadius();
      parentNodeLayout.nodes.forEach(function(node) {
        if (node.seriesIndex === series.index) {
          nodeAdded = true;
        }
      });
      parentNodeLayout.setArea(0, 0, chart.plotWidth, chart.plotHeight);
      if (!nodeAdded) {
        if (!parentNode) {
          parentNode = new PackedBubblePoint2().init(this, {
            mass: series.parentNodeRadius / 2,
            marker: {
              radius: series.parentNodeRadius
            },
            dataLabels: {
              inside: false
            },
            dataLabelOnNull: true,
            degree: series.parentNodeRadius,
            isParentNode: true,
            seriesIndex: series.index
          });
        }
        if (series.parentNode) {
          parentNode.plotX = series.parentNode.plotX;
          parentNode.plotY = series.parentNode.plotY;
        }
        series.parentNode = parentNode;
        parentNodeLayout.addElementsToCollection([series], parentNodeLayout.series);
        parentNodeLayout.addElementsToCollection([parentNode], parentNodeLayout.nodes);
      }
    };
    PackedBubbleSeries2.prototype.deferLayout = function() {
      var series = this, layoutOptions = series.options.layoutAlgorithm;
      if (!series.visible) {
        return;
      }
      series.addLayout();
      if (layoutOptions.splitSeries) {
        series.addSeriesLayout();
      }
    };
    PackedBubbleSeries2.prototype.destroy = function() {
      if (this.chart.graphLayoutsLookup) {
        this.chart.graphLayoutsLookup.forEach(function(layout) {
          layout.removeElementFromCollection(this, layout.series);
        }, this);
      }
      if (this.parentNode && this.parentNodeLayout) {
        this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes);
        if (this.parentNode.dataLabel) {
          this.parentNode.dataLabel = this.parentNode.dataLabel.destroy();
        }
      }
      Series6.prototype.destroy.apply(this, arguments);
    };
    PackedBubbleSeries2.prototype.drawDataLabels = function() {
      var textPath = this.options.dataLabels.textPath, points = this.points;
      Series6.prototype.drawDataLabels.apply(this, arguments);
      if (this.parentNode) {
        this.parentNode.formatPrefix = "parentNode";
        this.points = [this.parentNode];
        this.options.dataLabels.textPath = this.options.dataLabels.parentNodeTextPath;
        Series6.prototype.drawDataLabels.apply(this, arguments);
        this.points = points;
        this.options.dataLabels.textPath = textPath;
      }
    };
    PackedBubbleSeries2.prototype.drawGraph = function() {
      if (!this.layout || !this.layout.options.splitSeries) {
        return;
      }
      var series = this, chart = series.chart, parentAttribs = {}, nodeMarker = this.layout.options.parentNodeOptions.marker, parentOptions = {
        fill: nodeMarker.fillColor || color9(series.color).brighten(0.4).get(),
        opacity: nodeMarker.fillOpacity,
        stroke: nodeMarker.lineColor || series.color,
        "stroke-width": nodeMarker.lineWidth
      };
      if (!this.parentNodesGroup) {
        series.parentNodesGroup = series.plotGroup("parentNodesGroup", "parentNode", series.visible ? "inherit" : "hidden", 0.1, chart.seriesGroup);
        series.group.attr({
          zIndex: 2
        });
      }
      this.calculateParentRadius();
      parentAttribs = merge62({
        x: series.parentNode.plotX - series.parentNodeRadius,
        y: series.parentNode.plotY - series.parentNodeRadius,
        width: series.parentNodeRadius * 2,
        height: series.parentNodeRadius * 2
      }, parentOptions);
      if (!series.parentNode.graphic) {
        series.graph = series.parentNode.graphic = chart.renderer.symbol(parentOptions.symbol).add(series.parentNodesGroup);
      }
      series.parentNode.graphic.attr(parentAttribs);
    };
    PackedBubbleSeries2.prototype.drawTracker = function() {
      var series = this, parentNode = series.parentNode;
      var dataLabels;
      _super.prototype.drawTracker.call(this);
      if (parentNode) {
        dataLabels = isArray20(parentNode.dataLabels) ? parentNode.dataLabels : parentNode.dataLabel ? [parentNode.dataLabel] : [];
        if (parentNode.graphic) {
          parentNode.graphic.element.point = parentNode;
        }
        dataLabels.forEach(function(dataLabel) {
          if (dataLabel.div) {
            dataLabel.div.point = parentNode;
          } else {
            dataLabel.element.point = parentNode;
          }
        });
      }
    };
    PackedBubbleSeries2.prototype.getPointRadius = function() {
      var series = this, chart = series.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, seriesOptions = series.options, useSimulation = seriesOptions.useSimulation, smallestSize = Math.min(plotWidth, plotHeight), extremes = {}, radii = [], allDataPoints = chart.allDataPoints, minSize, maxSize, value, radius, zExtremes;
      ["minSize", "maxSize"].forEach(function(prop) {
        var length = parseInt(seriesOptions[prop], 10), isPercent = /%$/.test(seriesOptions[prop]);
        extremes[prop] = isPercent ? smallestSize * length / 100 : length * Math.sqrt(allDataPoints.length);
      });
      chart.minRadius = minSize = extremes.minSize / Math.sqrt(allDataPoints.length);
      chart.maxRadius = maxSize = extremes.maxSize / Math.sqrt(allDataPoints.length);
      zExtremes = useSimulation ? series.calculateZExtremes() : [minSize, maxSize];
      (allDataPoints || []).forEach(function(point, i) {
        value = useSimulation ? clamp17(point[2], zExtremes[0], zExtremes[1]) : point[2];
        radius = series.getRadius(zExtremes[0], zExtremes[1], minSize, maxSize, value);
        if (radius === 0) {
          radius = null;
        }
        allDataPoints[i][2] = radius;
        radii.push(radius);
      });
      series.radii = radii;
    };
    PackedBubbleSeries2.prototype.init = function() {
      Series6.prototype.init.apply(this, arguments);
      this.eventsToUnbind.push(addEvent47(this, "updatedData", function() {
        this.chart.series.forEach(function(s) {
          if (s.type === this.type) {
            s.isDirty = true;
          }
        }, this);
      }));
      return this;
    };
    PackedBubbleSeries2.prototype.onMouseUp = function(point) {
      if (point.fixedPosition && !point.removed) {
        var distanceXY_1, distanceR_1, layout_1 = this.layout, parentNodeLayout = this.parentNodeLayout;
        if (parentNodeLayout && layout_1.options.dragBetweenSeries) {
          parentNodeLayout.nodes.forEach(function(node) {
            if (point && point.marker && node !== point.series.parentNode) {
              distanceXY_1 = layout_1.getDistXY(point, node);
              distanceR_1 = layout_1.vectorLength(distanceXY_1) - node.marker.radius - point.marker.radius;
              if (distanceR_1 < 0) {
                node.series.addPoint(merge62(point.options, {
                  plotX: point.plotX,
                  plotY: point.plotY
                }), false);
                layout_1.removeElementFromCollection(point, layout_1.nodes);
                point.remove();
              }
            }
          });
        }
        dragNodesMixin.onMouseUp.apply(this, arguments);
      }
    };
    PackedBubbleSeries2.prototype.placeBubbles = function(allDataPoints) {
      var series = this, checkOverlap = series.checkOverlap, positionBubble = series.positionBubble, bubblePos = [], stage = 1, j = 0, k = 0, calculatedBubble, sortedArr, arr = [], i;
      sortedArr = allDataPoints.sort(function(a, b) {
        return b[2] - a[2];
      });
      if (sortedArr.length) {
        bubblePos.push([
          [
            0,
            0,
            sortedArr[0][2],
            sortedArr[0][3],
            sortedArr[0][4]
          ]
          // point index
        ]);
        if (sortedArr.length > 1) {
          bubblePos.push([
            [
              0,
              0 - sortedArr[1][2] - sortedArr[0][2],
              // move bubble above first one
              sortedArr[1][2],
              sortedArr[1][3],
              sortedArr[1][4]
            ]
          ]);
          for (i = 2; i < sortedArr.length; i++) {
            sortedArr[i][2] = sortedArr[i][2] || 1;
            calculatedBubble = positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]);
            if (checkOverlap(calculatedBubble, bubblePos[stage][0])) {
              bubblePos.push([]);
              k = 0;
              bubblePos[stage + 1].push(positionBubble(bubblePos[stage][j], bubblePos[stage][0], sortedArr[i]));
              stage++;
              j = 0;
            } else if (stage > 1 && bubblePos[stage - 1][k + 1] && checkOverlap(calculatedBubble, bubblePos[stage - 1][k + 1])) {
              k++;
              bubblePos[stage].push(positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]));
              j++;
            } else {
              j++;
              bubblePos[stage].push(calculatedBubble);
            }
          }
        }
        series.chart.stages = bubblePos;
        series.chart.rawPositions = [].concat.apply([], bubblePos);
        series.resizeRadius();
        arr = series.chart.rawPositions;
      }
      return arr;
    };
    PackedBubbleSeries2.prototype.positionBubble = function(lastBubble, newOrigin, nextBubble) {
      var sqrt = Math.sqrt, asin = Math.asin, acos = Math.acos, pow = Math.pow, abs = Math.abs, distance = sqrt(
        // dist between lastBubble and newOrigin
        pow(lastBubble[0] - newOrigin[0], 2) + pow(lastBubble[1] - newOrigin[1], 2)
      ), alfa = acos(
        // from cosinus theorem: alfa is an angle used for
        // calculating correct position
        (pow(distance, 2) + pow(nextBubble[2] + newOrigin[2], 2) - pow(nextBubble[2] + lastBubble[2], 2)) / (2 * (nextBubble[2] + newOrigin[2]) * distance)
      ), beta = asin(
        // from sinus theorem.
        abs(lastBubble[0] - newOrigin[0]) / distance
      ), gamma = lastBubble[1] - newOrigin[1] < 0 ? 0 : Math.PI, delta = (lastBubble[0] - newOrigin[0]) * (lastBubble[1] - newOrigin[1]) < 0 ? 1 : -1, finalAngle = gamma + alfa + beta * delta, cosA = Math.cos(finalAngle), sinA = Math.sin(finalAngle), posX = newOrigin[0] + (newOrigin[2] + nextBubble[2]) * sinA, posY = newOrigin[1] - (newOrigin[2] + nextBubble[2]) * cosA;
      return [
        posX,
        posY,
        nextBubble[2],
        nextBubble[3],
        nextBubble[4]
      ];
    };
    PackedBubbleSeries2.prototype.render = function() {
      var series = this, dataLabels = [];
      Series6.prototype.render.apply(this, arguments);
      if (!series.options.dataLabels.allowOverlap) {
        series.data.forEach(function(point) {
          if (isArray20(point.dataLabels)) {
            point.dataLabels.forEach(function(dataLabel) {
              dataLabels.push(dataLabel);
            });
          }
        });
        if (series.options.useSimulation) {
          series.chart.hideOverlappingLabels(dataLabels);
        }
      }
    };
    PackedBubbleSeries2.prototype.resizeRadius = function() {
      var chart = this.chart, positions = chart.rawPositions, min = Math.min, max = Math.max, plotLeft = chart.plotLeft, plotTop = chart.plotTop, chartHeight = chart.plotHeight, chartWidth = chart.plotWidth, minX, maxX, minY, maxY, radius, bBox, spaceRatio, smallerDimension, i;
      minX = minY = Number.POSITIVE_INFINITY;
      maxX = maxY = Number.NEGATIVE_INFINITY;
      for (i = 0; i < positions.length; i++) {
        radius = positions[i][2];
        minX = min(minX, positions[i][0] - radius);
        maxX = max(maxX, positions[i][0] + radius);
        minY = min(minY, positions[i][1] - radius);
        maxY = max(maxY, positions[i][1] + radius);
      }
      bBox = [maxX - minX, maxY - minY];
      spaceRatio = [
        (chartWidth - plotLeft) / bBox[0],
        (chartHeight - plotTop) / bBox[1]
      ];
      smallerDimension = min.apply([], spaceRatio);
      if (Math.abs(smallerDimension - 1) > 1e-10) {
        for (i = 0; i < positions.length; i++) {
          positions[i][2] *= smallerDimension;
        }
        this.placeBubbles(positions);
      } else {
        chart.diffY = chartHeight / 2 + plotTop - minY - (maxY - minY) / 2;
        chart.diffX = chartWidth / 2 + plotLeft - minX - (maxX - minX) / 2;
      }
    };
    PackedBubbleSeries2.prototype.seriesBox = function() {
      var series = this, chart = series.chart, data = series.data, max = Math.max, min = Math.min, radius, bBox = [
        chart.plotLeft,
        chart.plotLeft + chart.plotWidth,
        chart.plotTop,
        chart.plotTop + chart.plotHeight
      ];
      data.forEach(function(p) {
        if (defined46(p.plotX) && defined46(p.plotY) && p.marker.radius) {
          radius = p.marker.radius;
          bBox[0] = min(bBox[0], p.plotX - radius);
          bBox[1] = max(bBox[1], p.plotX + radius);
          bBox[2] = min(bBox[2], p.plotY - radius);
          bBox[3] = max(bBox[3], p.plotY + radius);
        }
      });
      return isNumber41(bBox.width / bBox.height) ? bBox : null;
    };
    PackedBubbleSeries2.prototype.setVisible = function() {
      var series = this;
      Series6.prototype.setVisible.apply(series, arguments);
      if (series.parentNodeLayout && series.graph) {
        if (series.visible) {
          series.graph.show();
          if (series.parentNode.dataLabel) {
            series.parentNode.dataLabel.show();
          }
        } else {
          series.graph.hide();
          series.parentNodeLayout.removeElementFromCollection(series.parentNode, series.parentNodeLayout.nodes);
          if (series.parentNode.dataLabel) {
            series.parentNode.dataLabel.hide();
          }
        }
      } else if (series.layout) {
        if (series.visible) {
          series.layout.addElementsToCollection(series.points, series.layout.nodes);
        } else {
          series.points.forEach(function(node) {
            series.layout.removeElementFromCollection(node, series.layout.nodes);
          });
        }
      }
    };
    PackedBubbleSeries2.prototype.translate = function() {
      var series = this, chart = series.chart, data = series.data, index = series.index, point, radius, positions, i, useSimulation = series.options.useSimulation;
      series.processedXData = series.xData;
      series.generatePoints();
      if (!defined46(chart.allDataPoints)) {
        chart.allDataPoints = series.accumulateAllPoints(series);
        series.getPointRadius();
      }
      if (useSimulation) {
        positions = chart.allDataPoints;
      } else {
        positions = series.placeBubbles(chart.allDataPoints);
        series.options.draggable = false;
      }
      for (i = 0; i < positions.length; i++) {
        if (positions[i][3] === index) {
          point = data[positions[i][4]];
          radius = pick70(positions[i][2], void 0);
          if (!useSimulation) {
            point.plotX = positions[i][0] - chart.plotLeft + chart.diffX;
            point.plotY = positions[i][1] - chart.plotTop + chart.diffY;
          }
          if (isNumber41(radius)) {
            point.marker = extend64(point.marker, {
              radius,
              width: 2 * radius,
              height: 2 * radius
            });
            point.radius = radius;
          }
        }
      }
      if (useSimulation) {
        series.deferLayout();
      }
      fireEvent32(series, "afterTranslate");
    };
    PackedBubbleSeries2.defaultOptions = merge62(BubbleSeries3.defaultOptions, {
      /**
       * Minimum bubble size. Bubbles will automatically size between the
       * `minSize` and `maxSize` to reflect the value of each bubble.
       * Can be either pixels (when no unit is given), or a percentage of
       * the smallest one of the plot width and height, divided by the square
       * root of total number of points.
       *
       * @sample highcharts/plotoptions/bubble-size/
       *         Bubble size
       *
       * @type {number|string}
       *
       * @private
       */
      minSize: "10%",
      /**
       * Maximum bubble size. Bubbles will automatically size between the
       * `minSize` and `maxSize` to reflect the value of each bubble.
       * Can be either pixels (when no unit is given), or a percentage of
       * the smallest one of the plot width and height, divided by the square
       * root of total number of points.
       *
       * @sample highcharts/plotoptions/bubble-size/
       *         Bubble size
       *
       * @type {number|string}
       *
       * @private
       */
      maxSize: "50%",
      sizeBy: "area",
      zoneAxis: "y",
      crisp: false,
      tooltip: {
        pointFormat: "Value: {point.value}"
      },
      /**
       * Flag to determine if nodes are draggable or not. Available for
       * graph with useSimulation set to true only.
       *
       * @since 7.1.0
       *
       * @private
       */
      draggable: true,
      /**
       * An option is giving a possibility to choose between using simulation
       * for calculating bubble positions. These reflects in both animation
       * and final position of bubbles. Simulation is also adding options to
       * the series graph based on used layout. In case of big data sets, with
       * any performance issues, it is possible to disable animation and pack
       * bubble in a simple circular way.
       *
       * @sample highcharts/series-packedbubble/spiral/
       *         useSimulation set to false
       *
       * @since 7.1.0
       *
       * @private
       */
      useSimulation: true,
      /**
       * Series options for parent nodes.
       *
       * @since 8.1.1
       *
       * @private
       */
      parentNode: {
        /**
         * Allow this series' parent nodes to be selected
         * by clicking on the graph.
         *
         * @since 8.1.1
         */
        allowPointSelect: false
      },
      /**
      /**
       *
       * @declare Highcharts.SeriesPackedBubbleDataLabelsOptionsObject
       *
       * @private
       */
      dataLabels: {
        /**
         * The
         * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
         * specifying what to show for _node_ in the networkgraph. In v7.0
         * defaults to `{key}`, since v7.1 defaults to `undefined` and
         * `formatter` is used instead.
         *
         * @type      {string}
         * @since     7.0.0
         * @apioption plotOptions.packedbubble.dataLabels.format
         */
        // eslint-disable-next-line valid-jsdoc
        /**
         * Callback JavaScript function to format the data label for a node.
         * Note that if a `format` is defined, the format takes precedence
         * and the formatter is ignored.
         *
         * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}
         * @since 7.0.0
         */
        formatter: function() {
          var numberFormatter = this.series.chart.numberFormatter;
          var value = this.point.value;
          return isNumber41(value) ? numberFormatter(value, -1) : "";
        },
        /**
         * @type      {string}
         * @since     7.1.0
         * @apioption plotOptions.packedbubble.dataLabels.parentNodeFormat
         */
        // eslint-disable-next-line valid-jsdoc
        /**
         * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}
         * @since 7.1.0
         */
        parentNodeFormatter: function() {
          return this.name;
        },
        /**
         * @sample {highcharts} highcharts/series-packedbubble/packed-dashboard
         *         Dashboard with dataLabels on parentNodes
         *
         * @declare Highcharts.SeriesPackedBubbleDataLabelsTextPathOptionsObject
         * @since   7.1.0
         */
        parentNodeTextPath: {
          /**
           * Presentation attributes for the text path.
           *
           * @type      {Highcharts.SVGAttributes}
           * @since     7.1.0
           * @apioption plotOptions.packedbubble.dataLabels.attributes
           */
          /**
           * Enable or disable `textPath` option for link's or marker's
           * data labels.
           *
           * @since 7.1.0
           */
          enabled: true
        },
        /**
         * Options for a _node_ label text which should follow marker's
         * shape.
         *
         * **Note:** Only SVG-based renderer supports this option.
         *
         * @extends   plotOptions.series.dataLabels.textPath
         * @apioption plotOptions.packedbubble.dataLabels.textPath
         */
        padding: 0,
        style: {
          transition: "opacity 2000ms"
        }
      },
      /**
       * Options for layout algorithm when simulation is enabled. Inside there
       * are options to change the speed, padding, initial bubbles positions
       * and more.
       *
       * @extends   plotOptions.networkgraph.layoutAlgorithm
       * @excluding approximation, attractiveForce, repulsiveForce, theta
       * @since     7.1.0
       *
       * @private
       */
      layoutAlgorithm: {
        /**
         * Initial layout algorithm for positioning nodes. Can be one of
         * the built-in options ("circle", "random") or a function where
         * positions should be set on each node (`this.nodes`) as
         * `node.plotX` and `node.plotY`.
         *
         * @sample highcharts/series-networkgraph/initial-positions/
         *         Initial positions with callback
         *
         * @type {"circle"|"random"|Function}
         */
        initialPositions: "circle",
        /**
         * @sample highcharts/series-packedbubble/initial-radius/
         *         Initial radius set to 200
         *
         * @extends   plotOptions.networkgraph.layoutAlgorithm.initialPositionRadius
         * @excluding states
         */
        initialPositionRadius: 20,
        /**
         * The distance between two bubbles, when the algorithm starts to
         * treat two bubbles as overlapping. The `bubblePadding` is also the
         * expected distance between all the bubbles on simulation end.
         */
        bubblePadding: 5,
        /**
         * Whether bubbles should interact with their parentNode to keep
         * them inside.
         */
        parentNodeLimit: false,
        /**
         * Whether series should interact with each other or not. When
         * `parentNodeLimit` is set to true, thi option should be set to
         * false to avoid sticking points in wrong series parentNode.
         */
        seriesInteraction: true,
        /**
         * In case of split series, this option allows user to drag and
         * drop points between series, for changing point related series.
         *
         * @sample highcharts/series-packedbubble/packed-dashboard/
         *         Example of drag'n drop bubbles for bubble kanban
         */
        dragBetweenSeries: false,
        /**
         * Layout algorithm options for parent nodes.
         *
         * @extends   plotOptions.networkgraph.layoutAlgorithm
         * @excluding approximation, attractiveForce, enableSimulation,
         *            repulsiveForce, theta
         */
        parentNodeOptions: {
          maxIterations: 400,
          gravitationalConstant: 0.03,
          maxSpeed: 50,
          initialPositionRadius: 100,
          seriesInteraction: true,
          /**
           * Styling options for parentNodes markers. Similar to
           * line.marker options.
           *
           * @sample highcharts/series-packedbubble/parentnode-style/
           *         Bubble size
           *
           * @extends   plotOptions.series.marker
           * @excluding states
           */
          marker: {
            fillColor: null,
            fillOpacity: 1,
            lineWidth: 1,
            lineColor: null,
            symbol: "circle"
          }
        },
        enableSimulation: true,
        /**
         * Type of the algorithm used when positioning bubbles.
         * @ignore-option
         */
        type: "packedbubble",
        /**
         * Integration type. Integration determines how forces are applied
         * on particles. The `packedbubble` integration is based on
         * the networkgraph `verlet` integration, where the new position
         * is based on a previous position without velocity:
         * `newPosition += previousPosition - newPosition`.
         *
         * @sample highcharts/series-networkgraph/forces/
         *
         * @ignore-option
         */
        integration: "packedbubble",
        maxIterations: 1e3,
        /**
         * Whether to split series into individual groups or to mix all
         * series together.
         *
         * @since   7.1.0
         * @default false
         */
        splitSeries: false,
        /**
         * Max speed that node can get in one iteration. In terms of
         * simulation, it's a maximum translation (in pixels) that a node
         * can move (in both, x and y, dimensions). While `friction` is
         * applied on all nodes, max speed is applied only for nodes that
         * move very fast, for example small or disconnected ones.
         *
         * @see [layoutAlgorithm.integration](#series.networkgraph.layoutAlgorithm.integration)
         *
         * @see [layoutAlgorithm.friction](#series.networkgraph.layoutAlgorithm.friction)
         */
        maxSpeed: 5,
        gravitationalConstant: 0.01,
        friction: -0.981
      }
    });
    return PackedBubbleSeries2;
  }(BubbleSeries3)
);
extend64(PackedBubbleSeries.prototype, {
  alignDataLabel: Series6.prototype.alignDataLabel,
  axisTypes: [],
  directTouch: true,
  /**
   * Array of internal forces. Each force should be later defined in
   * integrations.js.
   * @private
   */
  forces: ["barycenter", "repulsive"],
  /**
   * An internal option used for allowing nodes dragging.
   * @private
   */
  hasDraggableNodes: true,
  isCartesian: false,
  noSharedTooltip: true,
  /**
   * Mouse down action, initializing drag&drop mode.
   * @private
   * @param {global.Event} event Browser event, before normalization.
   * @param {Highcharts.Point} point The point that event occured.
   */
  onMouseDown: dragNodesMixin.onMouseDown,
  /**
   * Mouse move action during drag&drop.
   * @private
   * @param {global.Event} event Browser event, before normalization.
   * @param {Highcharts.Point} point The point that event occured.
   */
  onMouseMove: dragNodesMixin.onMouseMove,
  pointArrayMap: ["value"],
  pointClass: PackedBubblePoint_default,
  pointValKey: "value",
  /**
   * Redraw halo on mousemove during the drag&drop action.
   * @private
   * @param {Highcharts.Point} point The point that should show halo.
   */
  redrawHalo: dragNodesMixin.redrawHalo,
  requireSorting: false,
  // solving #12287
  searchPoint: Globals_default.noop,
  trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"]
});
SeriesRegistry_default.registerSeriesType("packedbubble", PackedBubbleSeries);

// node_modules/highcharts/es-modules/Series/Polygon/PolygonSeries.js
var __extends34 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop17 = Globals_default.noop;
var Series7 = SeriesRegistry_default.series;
var _a6 = SeriesRegistry_default.seriesTypes;
var AreaSeries2 = _a6.area;
var LineSeries4 = _a6.line;
var ScatterSeries3 = _a6.scatter;
var extend65 = Utilities_default.extend;
var merge63 = Utilities_default.merge;
var PolygonSeries = (
  /** @class */
  function(_super) {
    __extends34(PolygonSeries2, _super);
    function PolygonSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    PolygonSeries2.prototype.getGraphPath = function() {
      var graphPath = LineSeries4.prototype.getGraphPath.call(this), i = graphPath.length + 1;
      while (i--) {
        if ((i === graphPath.length || graphPath[i][0] === "M") && i > 0) {
          graphPath.splice(i, 0, ["Z"]);
        }
      }
      this.areaPath = graphPath;
      return graphPath;
    };
    PolygonSeries2.prototype.drawGraph = function() {
      this.options.fillColor = this.color;
      AreaSeries2.prototype.drawGraph.call(this);
    };
    PolygonSeries2.defaultOptions = merge63(ScatterSeries3.defaultOptions, {
      marker: {
        enabled: false,
        states: {
          hover: {
            enabled: false
          }
        }
      },
      stickyTracking: false,
      tooltip: {
        followPointer: true,
        pointFormat: ""
      },
      trackByArea: true
    });
    return PolygonSeries2;
  }(ScatterSeries3)
);
extend65(PolygonSeries.prototype, {
  type: "polygon",
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  drawTracker: Series7.prototype.drawTracker,
  setStackedPoints: noop17
  // No stacking points on polygons (#5310)
});
SeriesRegistry_default.registerSeriesType("polygon", PolygonSeries);

// node_modules/highcharts/es-modules/Core/Axis/WaterfallAxis.js
var addEvent48 = Utilities_default.addEvent;
var objectEach30 = Utilities_default.objectEach;
var WaterfallAxis;
(function(WaterfallAxis2) {
  var Composition = (
    /** @class */
    function() {
      function Composition2(axis) {
        this.axis = axis;
        this.stacks = {
          changed: false
        };
      }
      Composition2.prototype.renderStackTotals = function() {
        var yAxis = this.axis, waterfallStacks = yAxis.waterfall.stacks, stackTotalGroup = yAxis.stacking && yAxis.stacking.stackTotalGroup, dummyStackItem = new Stacking_default(yAxis, yAxis.options.stackLabels, false, 0, void 0);
        this.dummyStackItem = dummyStackItem;
        objectEach30(waterfallStacks, function(type) {
          objectEach30(type, function(stackItem) {
            dummyStackItem.total = stackItem.stackTotal;
            if (stackItem.label) {
              dummyStackItem.label = stackItem.label;
            }
            Stacking_default.prototype.render.call(dummyStackItem, stackTotalGroup);
            stackItem.label = dummyStackItem.label;
            delete dummyStackItem.label;
          });
        });
        dummyStackItem.total = null;
      };
      return Composition2;
    }()
  );
  WaterfallAxis2.Composition = Composition;
  function compose(AxisClass, ChartClass) {
    addEvent48(AxisClass, "init", onInit);
    addEvent48(AxisClass, "afterBuildStacks", onAfterBuildStacks);
    addEvent48(AxisClass, "afterRender", onAfterRender);
    addEvent48(ChartClass, "beforeRedraw", onBeforeRedraw);
  }
  WaterfallAxis2.compose = compose;
  function onAfterBuildStacks() {
    var axis = this;
    var stacks = axis.waterfall.stacks;
    if (stacks) {
      stacks.changed = false;
      delete stacks.alreadyChanged;
    }
  }
  function onAfterRender() {
    var axis = this;
    var stackLabelOptions = axis.options.stackLabels;
    if (stackLabelOptions && stackLabelOptions.enabled && axis.waterfall.stacks) {
      axis.waterfall.renderStackTotals();
    }
  }
  function onBeforeRedraw() {
    var axes = this.axes, series = this.series, i = series.length;
    while (i--) {
      if (series[i].options.stacking) {
        axes.forEach(function(axis) {
          if (!axis.isXAxis) {
            axis.waterfall.stacks.changed = true;
          }
        });
        i = 0;
      }
    }
  }
  function onInit() {
    var axis = this;
    if (!axis.waterfall) {
      axis.waterfall = new Composition(axis);
    }
  }
})(WaterfallAxis || (WaterfallAxis = {}));
var WaterfallAxis_default = WaterfallAxis;

// node_modules/highcharts/es-modules/Series/Waterfall/WaterfallPoint.js
var __extends35 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var isNumber42 = Utilities_default.isNumber;
var WaterfallPoint = (
  /** @class */
  function(_super) {
    __extends35(WaterfallPoint2, _super);
    function WaterfallPoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.series = void 0;
      return _this;
    }
    WaterfallPoint2.prototype.getClassName = function() {
      var className = Point_default.prototype.getClassName.call(this);
      if (this.isSum) {
        className += " highcharts-sum";
      } else if (this.isIntermediateSum) {
        className += " highcharts-intermediate-sum";
      }
      return className;
    };
    WaterfallPoint2.prototype.isValid = function() {
      return isNumber42(this.y) || this.isSum || Boolean(this.isIntermediateSum);
    };
    return WaterfallPoint2;
  }(ColumnSeries_default.prototype.pointClass)
);
var WaterfallPoint_default = WaterfallPoint;

// node_modules/highcharts/es-modules/Series/Waterfall/WaterfallSeries.js
var __extends36 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a7 = SeriesRegistry_default.seriesTypes;
var ColumnSeries10 = _a7.column;
var LineSeries5 = _a7.line;
var arrayMax10 = Utilities_default.arrayMax;
var arrayMin9 = Utilities_default.arrayMin;
var correctFloat12 = Utilities_default.correctFloat;
var extend66 = Utilities_default.extend;
var isNumber43 = Utilities_default.isNumber;
var merge64 = Utilities_default.merge;
var objectEach31 = Utilities_default.objectEach;
var pick71 = Utilities_default.pick;
function ownProp(obj, key) {
  return Object.hasOwnProperty.call(obj, key);
}
var WaterfallSeries = (
  /** @class */
  function(_super) {
    __extends36(WaterfallSeries2, _super);
    function WaterfallSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.chart = void 0;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.stackedYNeg = void 0;
      _this.stackedYPos = void 0;
      _this.stackKey = void 0;
      _this.xData = void 0;
      _this.yAxis = void 0;
      _this.yData = void 0;
      return _this;
    }
    WaterfallSeries2.prototype.generatePoints = function() {
      var point, len, i, y;
      ColumnSeries10.prototype.generatePoints.apply(this);
      for (i = 0, len = this.points.length; i < len; i++) {
        point = this.points[i];
        y = this.processedYData[i];
        if (point.isIntermediateSum || point.isSum) {
          point.y = correctFloat12(y);
        }
      }
    };
    WaterfallSeries2.prototype.translate = function() {
      var series = this, options = series.options, yAxis = series.yAxis, y, minPointLength = pick71(options.minPointLength, 5), halfMinPointLength = minPointLength / 2, threshold = options.threshold || 0, previousY = threshold, previousIntermediate = threshold, stacking = options.stacking, actualStack = yAxis.waterfall.stacks[series.stackKey], total, yPos, hPos;
      ColumnSeries10.prototype.translate.apply(series);
      var points = series.points;
      for (var i = 0; i < points.length; i++) {
        var point = points[i];
        var yValue = series.processedYData[i];
        var shapeArgs = point.shapeArgs;
        if (!shapeArgs || !isNumber43(yValue)) {
          continue;
        }
        var range = [0, yValue];
        var pointY = point.y;
        if (stacking) {
          if (actualStack) {
            var actualStackX = actualStack[i];
            if (stacking === "overlap") {
              total = actualStackX.stackState[actualStackX.stateIndex--];
              y = pointY >= 0 ? total : total - pointY;
              if (ownProp(actualStackX, "absolutePos")) {
                delete actualStackX.absolutePos;
              }
              if (ownProp(actualStackX, "absoluteNeg")) {
                delete actualStackX.absoluteNeg;
              }
            } else {
              if (pointY >= 0) {
                total = actualStackX.threshold + actualStackX.posTotal;
                actualStackX.posTotal -= pointY;
                y = total;
              } else {
                total = actualStackX.threshold + actualStackX.negTotal;
                actualStackX.negTotal -= pointY;
                y = total - pointY;
              }
              if (!actualStackX.posTotal) {
                if (ownProp(actualStackX, "absolutePos")) {
                  actualStackX.posTotal = actualStackX.absolutePos;
                  delete actualStackX.absolutePos;
                }
              }
              if (!actualStackX.negTotal) {
                if (ownProp(actualStackX, "absoluteNeg")) {
                  actualStackX.negTotal = actualStackX.absoluteNeg;
                  delete actualStackX.absoluteNeg;
                }
              }
            }
            if (!point.isSum) {
              actualStackX.connectorThreshold = actualStackX.threshold + actualStackX.stackTotal;
            }
            if (yAxis.reversed) {
              yPos = pointY >= 0 ? y - pointY : y + pointY;
              hPos = y;
            } else {
              yPos = y;
              hPos = y - pointY;
            }
            point.below = yPos <= threshold;
            shapeArgs.y = yAxis.translate(yPos, false, true, false, true) || 0;
            shapeArgs.height = Math.abs(shapeArgs.y - (yAxis.translate(hPos, false, true, false, true) || 0));
            var dummyStackItem = yAxis.waterfall.dummyStackItem;
            if (dummyStackItem) {
              dummyStackItem.x = i;
              dummyStackItem.label = actualStack[i].label;
              dummyStackItem.setOffset(series.pointXOffset || 0, series.barW || 0, series.stackedYNeg[i], series.stackedYPos[i]);
            }
          }
        } else {
          y = Math.max(previousY, previousY + pointY) + range[0];
          shapeArgs.y = yAxis.translate(y, false, true, false, true) || 0;
          if (point.isSum) {
            shapeArgs.y = yAxis.translate(range[1], false, true, false, true) || 0;
            shapeArgs.height = Math.min(yAxis.translate(range[0], false, true, false, true) || 0, yAxis.len) - shapeArgs.y;
            point.below = range[1] <= threshold;
          } else if (point.isIntermediateSum) {
            if (pointY >= 0) {
              yPos = range[1] + previousIntermediate;
              hPos = previousIntermediate;
            } else {
              yPos = previousIntermediate;
              hPos = range[1] + previousIntermediate;
            }
            if (yAxis.reversed) {
              yPos ^= hPos;
              hPos ^= yPos;
              yPos ^= hPos;
            }
            shapeArgs.y = yAxis.translate(yPos, false, true, false, true) || 0;
            shapeArgs.height = Math.abs(shapeArgs.y - Math.min(yAxis.translate(hPos, false, true, false, true) || 0, yAxis.len));
            previousIntermediate += range[1];
            point.below = yPos <= threshold;
          } else {
            shapeArgs.height = yValue > 0 ? (yAxis.translate(previousY, false, true, false, true) || 0) - shapeArgs.y : (yAxis.translate(previousY, false, true, false, true) || 0) - (yAxis.translate(previousY - yValue, false, true, false, true) || 0);
            previousY += yValue;
            point.below = previousY < threshold;
          }
          if (shapeArgs.height < 0) {
            shapeArgs.y += shapeArgs.height;
            shapeArgs.height *= -1;
          }
        }
        point.plotY = shapeArgs.y = Math.round(shapeArgs.y || 0) - series.borderWidth % 2 / 2;
        shapeArgs.height = Math.max(Math.round(shapeArgs.height || 0), 1e-3);
        point.yBottom = shapeArgs.y + shapeArgs.height;
        if (shapeArgs.height <= minPointLength && !point.isNull) {
          shapeArgs.height = minPointLength;
          shapeArgs.y -= halfMinPointLength;
          point.plotY = shapeArgs.y;
          if (point.y < 0) {
            point.minPointLengthOffset = -halfMinPointLength;
          } else {
            point.minPointLengthOffset = halfMinPointLength;
          }
        } else {
          if (point.isNull) {
            shapeArgs.width = 0;
          }
          point.minPointLengthOffset = 0;
        }
        var tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);
        if (point.below) {
          point.plotY += shapeArgs.height;
        }
        if (point.tooltipPos) {
          if (series.chart.inverted) {
            point.tooltipPos[0] = yAxis.len - tooltipY;
          } else {
            point.tooltipPos[1] = tooltipY;
          }
        }
      }
    };
    WaterfallSeries2.prototype.processData = function(force) {
      var series = this, options = series.options, yData = series.yData, points = options.data, point, dataLength = yData.length, threshold = options.threshold || 0, subSum, sum, dataMin, dataMax, y, i;
      sum = subSum = dataMin = dataMax = 0;
      for (i = 0; i < dataLength; i++) {
        y = yData[i];
        point = points && points[i] ? points[i] : {};
        if (y === "sum" || point.isSum) {
          yData[i] = correctFloat12(sum);
        } else if (y === "intermediateSum" || point.isIntermediateSum) {
          yData[i] = correctFloat12(subSum);
          subSum = 0;
        } else {
          sum += y;
          subSum += y;
        }
        dataMin = Math.min(sum, dataMin);
        dataMax = Math.max(sum, dataMax);
      }
      _super.prototype.processData.call(this, force);
      if (!options.stacking) {
        series.dataMin = dataMin + threshold;
        series.dataMax = dataMax;
      }
      return;
    };
    WaterfallSeries2.prototype.toYData = function(pt) {
      if (pt.isSum) {
        return "sum";
      }
      if (pt.isIntermediateSum) {
        return "intermediateSum";
      }
      return pt.y;
    };
    WaterfallSeries2.prototype.updateParallelArrays = function(point, i) {
      _super.prototype.updateParallelArrays.call(this, point, i);
      if (this.yData[0] === "sum" || this.yData[0] === "intermediateSum") {
        this.yData[0] = null;
      }
    };
    WaterfallSeries2.prototype.pointAttribs = function(point, state) {
      var upColor = this.options.upColor, attr11;
      if (upColor && !point.options.color) {
        point.color = point.y > 0 ? upColor : null;
      }
      attr11 = ColumnSeries10.prototype.pointAttribs.call(this, point, state);
      delete attr11.dashstyle;
      return attr11;
    };
    WaterfallSeries2.prototype.getGraphPath = function() {
      return [["M", 0, 0]];
    };
    WaterfallSeries2.prototype.getCrispPath = function() {
      var data = this.data, yAxis = this.yAxis, length = data.length, graphNormalizer = Math.round(this.graph.strokeWidth()) % 2 / 2, borderNormalizer = Math.round(this.borderWidth) % 2 / 2, reversedXAxis = this.xAxis.reversed, reversedYAxis = this.yAxis.reversed, stacking = this.options.stacking, path = [], connectorThreshold, prevStack, prevStackX, prevPoint, yPos, isPos, prevArgs, pointArgs, i;
      for (i = 1; i < length; i++) {
        pointArgs = data[i].shapeArgs;
        prevPoint = data[i - 1];
        prevArgs = data[i - 1].shapeArgs;
        prevStack = yAxis.waterfall.stacks[this.stackKey];
        isPos = prevPoint.y > 0 ? -prevArgs.height : 0;
        if (prevStack && prevArgs && pointArgs) {
          prevStackX = prevStack[i - 1];
          if (stacking) {
            connectorThreshold = prevStackX.connectorThreshold;
            yPos = Math.round(yAxis.translate(connectorThreshold, 0, 1, 0, 1) + (reversedYAxis ? isPos : 0)) - graphNormalizer;
          } else {
            yPos = prevArgs.y + prevPoint.minPointLengthOffset + borderNormalizer - graphNormalizer;
          }
          path.push([
            "M",
            (prevArgs.x || 0) + (reversedXAxis ? 0 : prevArgs.width || 0),
            yPos
          ], [
            "L",
            (pointArgs.x || 0) + (reversedXAxis ? pointArgs.width || 0 : 0),
            yPos
          ]);
        }
        if (prevArgs && path.length && (!stacking && prevPoint.y < 0 && !reversedYAxis || prevPoint.y > 0 && reversedYAxis)) {
          var nextLast = path[path.length - 2];
          if (nextLast && typeof nextLast[2] === "number") {
            nextLast[2] += prevArgs.height || 0;
          }
          var last = path[path.length - 1];
          if (last && typeof last[2] === "number") {
            last[2] += prevArgs.height || 0;
          }
        }
      }
      return path;
    };
    WaterfallSeries2.prototype.drawGraph = function() {
      LineSeries5.prototype.drawGraph.call(this);
      this.graph.attr({
        d: this.getCrispPath()
      });
    };
    WaterfallSeries2.prototype.setStackedPoints = function() {
      var series = this, options = series.options, waterfallStacks = series.yAxis.waterfall.stacks, seriesThreshold = options.threshold, stackThreshold = seriesThreshold || 0, interSum = stackThreshold, stackKey = series.stackKey, xData = series.xData, xLength = xData.length, actualStack, actualStackX, totalYVal, actualSum, prevSum, statesLen, posTotal, negTotal, xPoint, yVal, x, alreadyChanged, changed;
      function calculateStackState(firstS, nextS, sInx, sOff) {
        if (!statesLen) {
          actualStackX.stackState[0] = firstS;
          statesLen = actualStackX.stackState.length;
        } else {
          for (sInx; sInx < statesLen; sInx++) {
            actualStackX.stackState[sInx] += sOff;
          }
        }
        actualStackX.stackState.push(actualStackX.stackState[statesLen - 1] + nextS);
      }
      series.yAxis.stacking.usePercentage = false;
      totalYVal = actualSum = prevSum = stackThreshold;
      if (series.visible || !series.chart.options.chart.ignoreHiddenSeries) {
        changed = waterfallStacks.changed;
        alreadyChanged = waterfallStacks.alreadyChanged;
        if (alreadyChanged && alreadyChanged.indexOf(stackKey) < 0) {
          changed = true;
        }
        if (!waterfallStacks[stackKey]) {
          waterfallStacks[stackKey] = {};
        }
        actualStack = waterfallStacks[stackKey];
        for (var i = 0; i < xLength; i++) {
          x = xData[i];
          if (!actualStack[x] || changed) {
            actualStack[x] = {
              negTotal: 0,
              posTotal: 0,
              stackTotal: 0,
              threshold: 0,
              stateIndex: 0,
              stackState: [],
              label: changed && actualStack[x] ? actualStack[x].label : void 0
            };
          }
          actualStackX = actualStack[x];
          yVal = series.yData[i];
          if (yVal >= 0) {
            actualStackX.posTotal += yVal;
          } else {
            actualStackX.negTotal += yVal;
          }
          xPoint = options.data[i];
          posTotal = actualStackX.absolutePos = actualStackX.posTotal;
          negTotal = actualStackX.absoluteNeg = actualStackX.negTotal;
          actualStackX.stackTotal = posTotal + negTotal;
          statesLen = actualStackX.stackState.length;
          if (xPoint && xPoint.isIntermediateSum) {
            calculateStackState(prevSum, actualSum, 0, prevSum);
            prevSum = actualSum;
            actualSum = seriesThreshold;
            stackThreshold ^= interSum;
            interSum ^= stackThreshold;
            stackThreshold ^= interSum;
          } else if (xPoint && xPoint.isSum) {
            calculateStackState(seriesThreshold, totalYVal, statesLen);
            stackThreshold = seriesThreshold;
          } else {
            calculateStackState(stackThreshold, yVal, 0, totalYVal);
            if (xPoint) {
              totalYVal += yVal;
              actualSum += yVal;
            }
          }
          actualStackX.stateIndex++;
          actualStackX.threshold = stackThreshold;
          stackThreshold += actualStackX.stackTotal;
        }
        waterfallStacks.changed = false;
        if (!waterfallStacks.alreadyChanged) {
          waterfallStacks.alreadyChanged = [];
        }
        waterfallStacks.alreadyChanged.push(stackKey);
      }
    };
    WaterfallSeries2.prototype.getExtremes = function() {
      var stacking = this.options.stacking, yAxis, waterfallStacks, stackedYNeg, stackedYPos;
      if (stacking) {
        yAxis = this.yAxis;
        waterfallStacks = yAxis.waterfall.stacks;
        stackedYNeg = this.stackedYNeg = [];
        stackedYPos = this.stackedYPos = [];
        if (stacking === "overlap") {
          objectEach31(waterfallStacks[this.stackKey], function(stackX) {
            stackedYNeg.push(arrayMin9(stackX.stackState));
            stackedYPos.push(arrayMax10(stackX.stackState));
          });
        } else {
          objectEach31(waterfallStacks[this.stackKey], function(stackX) {
            stackedYNeg.push(stackX.negTotal + stackX.threshold);
            stackedYPos.push(stackX.posTotal + stackX.threshold);
          });
        }
        return {
          dataMin: arrayMin9(stackedYNeg),
          dataMax: arrayMax10(stackedYPos)
        };
      }
      return {
        dataMin: this.dataMin,
        dataMax: this.dataMax
      };
    };
    WaterfallSeries2.defaultOptions = merge64(ColumnSeries10.defaultOptions, {
      /**
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @apioption plotOptions.waterfall.color
       */
      /**
       * The color used specifically for positive point columns. When not
       * specified, the general series color is used.
       *
       * In styled mode, the waterfall colors can be set with the
       * `.highcharts-point-negative`, `.highcharts-sum` and
       * `.highcharts-intermediate-sum` classes.
       *
       * @sample {highcharts} highcharts/demo/waterfall/
       *         Waterfall
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product   highcharts
       * @apioption plotOptions.waterfall.upColor
       */
      dataLabels: {
        inside: true
      },
      /**
       * The width of the line connecting waterfall columns.
       *
       * @product highcharts
       */
      lineWidth: 1,
      /**
       * The color of the line that connects columns in a waterfall series.
       *
       * In styled mode, the stroke can be set with the `.highcharts-graph`
       * class.
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since   3.0
       * @product highcharts
       */
      lineColor: Palette_default.neutralColor80,
      /**
       * A name for the dash style to use for the line connecting the columns
       * of the waterfall series. Possible values: Dash, DashDot, Dot,
       * LongDash, LongDashDot, LongDashDotDot, ShortDash, ShortDashDot,
       * ShortDashDotDot, ShortDot, Solid
       *
       * In styled mode, the stroke dash-array can be set with the
       * `.highcharts-graph` class.
       *
       * @type    {Highcharts.DashStyleValue}
       * @since   3.0
       * @product highcharts
       */
      dashStyle: "Dot",
      /**
       * The color of the border of each waterfall column.
       *
       * In styled mode, the border stroke can be set with the
       * `.highcharts-point` class.
       *
       * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since   3.0
       * @product highcharts
       */
      borderColor: Palette_default.neutralColor80,
      states: {
        hover: {
          lineWidthPlus: 0
          // #3126
        }
      }
    });
    return WaterfallSeries2;
  }(ColumnSeries10)
);
extend66(WaterfallSeries.prototype, {
  getZonesGraphs: LineSeries5.prototype.getZonesGraphs,
  pointValKey: "y",
  // Property needed to prevent lines between the columns from disappearing
  // when negativeColor is used.
  showLine: true,
  pointClass: WaterfallPoint_default
});
SeriesRegistry_default.registerSeriesType("waterfall", WaterfallSeries);
WaterfallAxis_default.compose(Axis_default, Chart_default);

// node_modules/highcharts/es-modules/Extensions/Polar.js
var animObject11 = AnimationUtilities_default.animObject;
var seriesTypes5 = SeriesRegistry_default.seriesTypes;
var addEvent49 = Utilities_default.addEvent;
var defined47 = Utilities_default.defined;
var find16 = Utilities_default.find;
var isNumber44 = Utilities_default.isNumber;
var pick72 = Utilities_default.pick;
var splat17 = Utilities_default.splat;
var uniqueKey8 = Utilities_default.uniqueKey;
var wrap8 = Utilities_default.wrap;
var seriesProto4 = Series_default.prototype;
var pointerProto = Pointer_default.prototype;
var columnProto4;
var arearangeProto2;
seriesProto4.searchPointByAngle = function(e2) {
  var series = this, chart = series.chart, xAxis = series.xAxis, center = xAxis.pane.center, plotX = e2.chartX - center[0] - chart.plotLeft, plotY = e2.chartY - center[1] - chart.plotTop;
  return this.searchKDTree({
    clientX: 180 + Math.atan2(plotX, plotY) * (-180 / Math.PI)
  });
};
seriesProto4.getConnectors = function(segment, index, calculateNeighbours, connectEnds) {
  var i, prevPointInd, nextPointInd, previousPoint, nextPoint, previousX, previousY, nextX, nextY, plotX, plotY, ret, smoothing = 1.5, denom = smoothing + 1, leftContX, leftContY, rightContX, rightContY, dLControlPoint, dRControlPoint, leftContAngle, rightContAngle, jointAngle, addedNumber = connectEnds ? 1 : 0;
  if (index >= 0 && index <= segment.length - 1) {
    i = index;
  } else if (index < 0) {
    i = segment.length - 1 + index;
  } else {
    i = 0;
  }
  prevPointInd = i - 1 < 0 ? segment.length - (1 + addedNumber) : i - 1;
  nextPointInd = i + 1 > segment.length - 1 ? addedNumber : i + 1;
  previousPoint = segment[prevPointInd];
  nextPoint = segment[nextPointInd];
  previousX = previousPoint.plotX;
  previousY = previousPoint.plotY;
  nextX = nextPoint.plotX;
  nextY = nextPoint.plotY;
  plotX = segment[i].plotX;
  plotY = segment[i].plotY;
  leftContX = (smoothing * plotX + previousX) / denom;
  leftContY = (smoothing * plotY + previousY) / denom;
  rightContX = (smoothing * plotX + nextX) / denom;
  rightContY = (smoothing * plotY + nextY) / denom;
  dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2));
  dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2));
  leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);
  rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);
  jointAngle = Math.PI / 2 + (leftContAngle + rightContAngle) / 2;
  if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {
    jointAngle -= Math.PI;
  }
  leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;
  leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;
  rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;
  rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;
  ret = {
    rightContX,
    rightContY,
    leftContX,
    leftContY,
    plotX,
    plotY
  };
  if (calculateNeighbours) {
    ret.prevPointCont = this.getConnectors(segment, prevPointInd, false, connectEnds);
  }
  return ret;
};
seriesProto4.toXY = function(point) {
  var chart = this.chart, xAxis = this.xAxis, yAxis = this.yAxis, plotX = point.plotX, plotY = point.plotY, series = point.series, inverted = chart.inverted, pointY = point.y, radius = inverted ? plotX : yAxis.len - plotY, clientX;
  if (inverted && series && !series.isRadialBar) {
    point.plotY = plotY = typeof pointY === "number" ? yAxis.translate(pointY) || 0 : 0;
  }
  point.rectPlotX = plotX;
  point.rectPlotY = plotY;
  if (yAxis.center) {
    radius += yAxis.center[3] / 2;
  }
  if (isNumber44(plotY)) {
    var xy = inverted ? yAxis.postTranslate(plotY, radius) : xAxis.postTranslate(plotX, radius);
    point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
    point.plotY = point.polarPlotY = xy.y - chart.plotTop;
  }
  if (this.kdByAngle) {
    clientX = (plotX / Math.PI * 180 + xAxis.pane.options.startAngle) % 360;
    if (clientX < 0) {
      clientX += 360;
    }
    point.clientX = clientX;
  } else {
    point.clientX = point.plotX;
  }
};
if (seriesTypes5.spline) {
  wrap8(seriesTypes5.spline.prototype, "getPointSpline", function(proceed, segment, point, i) {
    var ret, connectors;
    if (this.chart.polar) {
      if (!i) {
        ret = ["M", point.plotX, point.plotY];
      } else {
        connectors = this.getConnectors(segment, i, true, this.connectEnds);
        var rightContX = connectors.prevPointCont && connectors.prevPointCont.rightContX;
        var rightContY = connectors.prevPointCont && connectors.prevPointCont.rightContY;
        ret = [
          "C",
          isNumber44(rightContX) ? rightContX : connectors.plotX,
          isNumber44(rightContY) ? rightContY : connectors.plotY,
          isNumber44(connectors.leftContX) ? connectors.leftContX : connectors.plotX,
          isNumber44(connectors.leftContY) ? connectors.leftContY : connectors.plotY,
          connectors.plotX,
          connectors.plotY
        ];
      }
    } else {
      ret = proceed.call(this, segment, point, i);
    }
    return ret;
  });
  if (seriesTypes5.areasplinerange) {
    seriesTypes5.areasplinerange.prototype.getPointSpline = seriesTypes5.spline.prototype.getPointSpline;
  }
}
addEvent49(Series_default, "afterTranslate", function() {
  var series = this;
  var chart = series.chart;
  if (chart.polar && series.xAxis) {
    series.kdByAngle = chart.tooltip && chart.tooltip.shared;
    if (series.kdByAngle) {
      series.searchPoint = series.searchPointByAngle;
    } else {
      series.options.findNearestPointBy = "xy";
    }
    if (!series.preventPostTranslate) {
      var points = series.points;
      var i = points.length;
      while (i--) {
        series.toXY(points[i]);
        if (!chart.hasParallelCoordinates && !series.yAxis.reversed && points[i].y < series.yAxis.min) {
          points[i].isNull = true;
        }
      }
    }
    if (!this.hasClipCircleSetter) {
      this.hasClipCircleSetter = !!series.eventsToUnbind.push(addEvent49(series, "afterRender", function() {
        var circ;
        if (chart.polar) {
          circ = this.yAxis.pane.center;
          if (!this.clipCircle) {
            this.clipCircle = chart.renderer.clipCircle(circ[0], circ[1], circ[2] / 2, circ[3] / 2);
          } else {
            this.clipCircle.animate({
              x: circ[0],
              y: circ[1],
              r: circ[2] / 2,
              innerR: circ[3] / 2
            });
          }
          this.group.clip(this.clipCircle);
          this.setClip = Globals_default.noop;
        }
      }));
    }
  }
}, { order: 2 });
wrap8(seriesTypes5.line.prototype, "getGraphPath", function(proceed, points) {
  var series = this, i, firstValid, popLastPoint;
  if (this.chart.polar) {
    points = points || this.points;
    for (i = 0; i < points.length; i++) {
      if (!points[i].isNull) {
        firstValid = i;
        break;
      }
    }
    if (this.options.connectEnds !== false && typeof firstValid !== "undefined") {
      this.connectEnds = true;
      points.splice(points.length, 0, points[firstValid]);
      popLastPoint = true;
    }
    points.forEach(function(point) {
      if (typeof point.polarPlotY === "undefined") {
        series.toXY(point);
      }
    });
  }
  var ret = proceed.apply(this, [].slice.call(arguments, 1));
  if (popLastPoint) {
    points.pop();
  }
  return ret;
});
var polarAnimate = function(proceed, init) {
  var series = this, chart = this.chart, animation = this.options.animation, group = this.group, markerGroup = this.markerGroup, center = this.xAxis.center, plotLeft = chart.plotLeft, plotTop = chart.plotTop, attribs, paneInnerR, graphic, shapeArgs, r, innerR;
  if (chart.polar) {
    if (series.isRadialBar) {
      if (!init) {
        series.startAngleRad = pick72(series.translatedThreshold, series.xAxis.startAngleRad);
        Globals_default.seriesTypes.pie.prototype.animate.call(series, init);
      }
    } else {
      if (chart.renderer.isSVG) {
        animation = animObject11(animation);
        if (series.is("column")) {
          if (!init) {
            paneInnerR = center[3] / 2;
            series.points.forEach(function(point) {
              graphic = point.graphic;
              shapeArgs = point.shapeArgs;
              r = shapeArgs && shapeArgs.r;
              innerR = shapeArgs && shapeArgs.innerR;
              if (graphic && shapeArgs) {
                graphic.attr({
                  r: paneInnerR,
                  innerR: paneInnerR
                });
                graphic.animate({
                  r,
                  innerR
                }, series.options.animation);
              }
            });
          }
        } else {
          if (init) {
            attribs = {
              translateX: center[0] + plotLeft,
              translateY: center[1] + plotTop,
              scaleX: 1e-3,
              scaleY: 1e-3
            };
            group.attr(attribs);
            if (markerGroup) {
              markerGroup.attr(attribs);
            }
          } else {
            attribs = {
              translateX: plotLeft,
              translateY: plotTop,
              scaleX: 1,
              scaleY: 1
            };
            group.animate(attribs, animation);
            if (markerGroup) {
              markerGroup.animate(attribs, animation);
            }
          }
        }
      }
    }
  } else {
    proceed.call(this, init);
  }
};
wrap8(seriesProto4, "animate", polarAnimate);
if (seriesTypes5.column) {
  arearangeProto2 = seriesTypes5.arearange.prototype;
  columnProto4 = seriesTypes5.column.prototype;
  columnProto4.polarArc = function(low, high, start, end) {
    var center = this.xAxis.center, len = this.yAxis.len, paneInnerR = center[3] / 2, r = len - high + paneInnerR, innerR = len - pick72(low, len) + paneInnerR;
    if (this.yAxis.reversed) {
      if (r < 0) {
        r = paneInnerR;
      }
      if (innerR < 0) {
        innerR = paneInnerR;
      }
    }
    return {
      x: center[0],
      y: center[1],
      r,
      innerR,
      start,
      end
    };
  };
  wrap8(columnProto4, "animate", polarAnimate);
  wrap8(columnProto4, "translate", function(proceed) {
    var series = this, options = series.options, threshold = options.threshold, stacking = options.stacking, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis, reversed = yAxis.reversed, center = yAxis.center, startAngleRad = xAxis.startAngleRad, endAngleRad = xAxis.endAngleRad, visibleRange = endAngleRad - startAngleRad, thresholdAngleRad, points, point, i, yMin, yMax, start, end, tooltipPos, pointX, pointY, stackValues, stack, barX, innerR, r;
    series.preventPostTranslate = true;
    proceed.call(series);
    if (xAxis.isRadial) {
      points = series.points;
      i = points.length;
      yMin = yAxis.translate(yAxis.min);
      yMax = yAxis.translate(yAxis.max);
      threshold = options.threshold || 0;
      if (chart.inverted) {
        if (isNumber44(threshold)) {
          thresholdAngleRad = yAxis.translate(threshold);
          if (defined47(thresholdAngleRad)) {
            if (thresholdAngleRad < 0) {
              thresholdAngleRad = 0;
            } else if (thresholdAngleRad > visibleRange) {
              thresholdAngleRad = visibleRange;
            }
            series.translatedThreshold = thresholdAngleRad + startAngleRad;
          }
        }
      }
      while (i--) {
        point = points[i];
        barX = point.barX;
        pointX = point.x;
        pointY = point.y;
        point.shapeType = "arc";
        if (chart.inverted) {
          point.plotY = yAxis.translate(pointY);
          if (stacking && yAxis.stacking) {
            stack = yAxis.stacking.stacks[(pointY < 0 ? "-" : "") + series.stackKey];
            if (series.visible && stack && stack[pointX]) {
              if (!point.isNull) {
                stackValues = stack[pointX].points[series.getStackIndicator(void 0, pointX, series.index).key];
                start = yAxis.translate(stackValues[0]);
                end = yAxis.translate(stackValues[1]);
                if (defined47(start)) {
                  start = Utilities_default.clamp(start, 0, visibleRange);
                }
              }
            }
          } else {
            start = thresholdAngleRad;
            end = point.plotY;
          }
          if (start > end) {
            end = [start, start = end][0];
          }
          if (!reversed) {
            if (start < yMin) {
              start = yMin;
            } else if (end > yMax) {
              end = yMax;
            } else if (end < yMin || start > yMax) {
              start = end = 0;
            }
          } else {
            if (end > yMin) {
              end = yMin;
            } else if (start < yMax) {
              start = yMax;
            } else if (start > yMin || end < yMax) {
              start = end = visibleRange;
            }
          }
          if (yAxis.min > yAxis.max) {
            start = end = reversed ? visibleRange : 0;
          }
          start += startAngleRad;
          end += startAngleRad;
          if (center) {
            point.barX = barX += center[3] / 2;
          }
          innerR = Math.max(barX, 0);
          r = Math.max(barX + point.pointWidth, 0);
          point.shapeArgs = {
            x: center && center[0],
            y: center && center[1],
            r,
            innerR,
            start,
            end
          };
          point.opacity = start === end ? 0 : void 0;
          point.plotY = (defined47(series.translatedThreshold) && (start < series.translatedThreshold ? start : end)) - startAngleRad;
        } else {
          start = barX + startAngleRad;
          point.shapeArgs = series.polarArc(point.yBottom, point.plotY, start, start + point.pointWidth);
        }
        series.toXY(point);
        if (chart.inverted) {
          tooltipPos = yAxis.postTranslate(point.rectPlotY, barX + point.pointWidth / 2);
          point.tooltipPos = [
            tooltipPos.x - chart.plotLeft,
            tooltipPos.y - chart.plotTop
          ];
        } else {
          point.tooltipPos = [point.plotX, point.plotY];
        }
        if (center) {
          point.ttBelow = point.plotY > center[1];
        }
      }
    }
  });
  columnProto4.findAlignments = function(angle, options) {
    var align, verticalAlign;
    if (options.align === null) {
      if (angle > 20 && angle < 160) {
        align = "left";
      } else if (angle > 200 && angle < 340) {
        align = "right";
      } else {
        align = "center";
      }
      options.align = align;
    }
    if (options.verticalAlign === null) {
      if (angle < 45 || angle > 315) {
        verticalAlign = "bottom";
      } else if (angle > 135 && angle < 225) {
        verticalAlign = "top";
      } else {
        verticalAlign = "middle";
      }
      options.verticalAlign = verticalAlign;
    }
    return options;
  };
  if (arearangeProto2) {
    arearangeProto2.findAlignments = columnProto4.findAlignments;
  }
  wrap8(columnProto4, "alignDataLabel", function(proceed, point, dataLabel, options, alignTo, isNew) {
    var chart = this.chart, inside = pick72(options.inside, !!this.options.stacking), angle, shapeArgs, labelPos;
    if (chart.polar) {
      angle = point.rectPlotX / Math.PI * 180;
      if (!chart.inverted) {
        if (this.findAlignments) {
          options = this.findAlignments(angle, options);
        }
      } else {
        this.forceDL = chart.isInsidePlot(point.plotX, Math.round(point.plotY));
        if (inside && point.shapeArgs) {
          shapeArgs = point.shapeArgs;
          labelPos = this.yAxis.postTranslate(
            // angle
            ((shapeArgs.start || 0) + (shapeArgs.end || 0)) / 2 - this.xAxis.startAngleRad,
            // radius
            point.barX + point.pointWidth / 2
          );
          alignTo = {
            x: labelPos.x - chart.plotLeft,
            y: labelPos.y - chart.plotTop
          };
        } else if (point.tooltipPos) {
          alignTo = {
            x: point.tooltipPos[0],
            y: point.tooltipPos[1]
          };
        }
        options.align = pick72(options.align, "center");
        options.verticalAlign = pick72(options.verticalAlign, "middle");
      }
      seriesProto4.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
      if (this.isRadialBar && point.shapeArgs && point.shapeArgs.start === point.shapeArgs.end) {
        dataLabel.hide(true);
      }
    } else {
      proceed.call(this, point, dataLabel, options, alignTo, isNew);
    }
  });
}
wrap8(pointerProto, "getCoordinates", function(proceed, e2) {
  var chart = this.chart, ret = {
    xAxis: [],
    yAxis: []
  };
  if (chart.polar) {
    chart.axes.forEach(function(axis) {
      var isXAxis = axis.isXAxis, center = axis.center, x, y;
      if (axis.coll === "colorAxis") {
        return;
      }
      x = e2.chartX - center[0] - chart.plotLeft;
      y = e2.chartY - center[1] - chart.plotTop;
      ret[isXAxis ? "xAxis" : "yAxis"].push({
        axis,
        value: axis.translate(isXAxis ? Math.PI - Math.atan2(x, y) : (
          // angle
          // distance from center
          Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))
        ), true)
      });
    });
  } else {
    ret = proceed.call(this, e2);
  }
  return ret;
});
SVGRenderer_default.prototype.clipCircle = function(x, y, r, innerR) {
  var wrapper, id = uniqueKey8(), clipPath = this.createElement("clipPath").attr({
    id
  }).add(this.defs);
  wrapper = innerR ? this.arc(x, y, r, innerR, 0, 2 * Math.PI).add(clipPath) : this.circle(x, y, r).add(clipPath);
  wrapper.id = id;
  wrapper.clipPath = clipPath;
  return wrapper;
};
addEvent49(Chart_default, "getAxes", function() {
  if (!this.pane) {
    this.pane = [];
  }
  this.options.pane = splat17(this.options.pane);
  this.options.pane.forEach(function(paneOptions) {
    new Pane_default(
      // eslint-disable-line no-new
      paneOptions,
      this
    );
  }, this);
});
addEvent49(Chart_default, "afterDrawChartBox", function() {
  this.pane.forEach(function(pane) {
    pane.render();
  });
});
addEvent49(Series_default, "afterInit", function() {
  var chart = this.chart;
  if (chart.inverted && chart.polar) {
    this.isRadialSeries = true;
    if (this.is("column")) {
      this.isRadialBar = true;
    }
  }
});
wrap8(Chart_default.prototype, "get", function(proceed, id) {
  return find16(this.pane || [], function(pane) {
    return pane.options.id === id;
  }) || proceed.call(this, id);
});

// node_modules/highcharts/es-modules/masters/highcharts-more.src.js
var G4 = Globals_default;
RadialAxis_default.compose(G4.Axis, G4.Tick);
BubbleSeries_default.compose(G4.Chart, G4.Legend, G4.Series);

// node_modules/highcharts/es-modules/Extensions/Math3D.js
var pick73 = Utilities_default.pick;
var deg2rad6 = Globals_default.deg2rad;
function rotate3D(x, y, z, angles) {
  return {
    x: angles.cosB * x - angles.sinB * z,
    y: -angles.sinA * angles.sinB * x + angles.cosA * y - angles.cosB * angles.sinA * z,
    z: angles.cosA * angles.sinB * x + angles.sinA * y + angles.cosA * angles.cosB * z
  };
}
function perspective3D(coordinate, origin, distance) {
  var projection = distance > 0 && distance < Number.POSITIVE_INFINITY ? distance / (coordinate.z + origin.z + distance) : 1;
  return {
    x: coordinate.x * projection,
    y: coordinate.y * projection
  };
}
Globals_default.perspective3D = perspective3D;
function perspective(points, chart, insidePlotArea, useInvertedPersp) {
  var options3d = chart.options.chart.options3d, inverted = pick73(useInvertedPersp, insidePlotArea ? chart.inverted : false), origin = {
    x: chart.plotWidth / 2,
    y: chart.plotHeight / 2,
    z: options3d.depth / 2,
    vd: pick73(options3d.depth, 1) * pick73(options3d.viewDistance, 0)
  }, scale = chart.scale3d || 1, beta = deg2rad6 * options3d.beta * (inverted ? -1 : 1), alpha = deg2rad6 * options3d.alpha * (inverted ? -1 : 1), angles = {
    cosA: Math.cos(alpha),
    cosB: Math.cos(-beta),
    sinA: Math.sin(alpha),
    sinB: Math.sin(-beta)
  };
  if (!insidePlotArea) {
    origin.x += chart.plotLeft;
    origin.y += chart.plotTop;
  }
  return points.map(function(point) {
    var rotated = rotate3D((inverted ? point.y : point.x) - origin.x, (inverted ? point.x : point.y) - origin.y, (point.z || 0) - origin.z, angles), coordinate = perspective3D(rotated, origin, origin.vd);
    coordinate.x = coordinate.x * scale + origin.x;
    coordinate.y = coordinate.y * scale + origin.y;
    coordinate.z = rotated.z * scale + origin.z;
    return {
      x: inverted ? coordinate.y : coordinate.x,
      y: inverted ? coordinate.x : coordinate.y,
      z: coordinate.z
    };
  });
}
Globals_default.perspective = perspective;
function pointCameraDistance(coordinates, chart) {
  var options3d = chart.options.chart.options3d, cameraPosition = {
    x: chart.plotWidth / 2,
    y: chart.plotHeight / 2,
    z: pick73(options3d.depth, 1) * pick73(options3d.viewDistance, 0) + options3d.depth
  }, distance = Math.sqrt(Math.pow(cameraPosition.x - pick73(coordinates.plotX, coordinates.x), 2) + Math.pow(cameraPosition.y - pick73(coordinates.plotY, coordinates.y), 2) + Math.pow(cameraPosition.z - pick73(coordinates.plotZ, coordinates.z), 2));
  return distance;
}
Globals_default.pointCameraDistance = pointCameraDistance;
function shapeArea(vertexes) {
  var area = 0, i, j;
  for (i = 0; i < vertexes.length; i++) {
    j = (i + 1) % vertexes.length;
    area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y;
  }
  return area / 2;
}
Globals_default.shapeArea = shapeArea;
function shapeArea3D(vertexes, chart, insidePlotArea) {
  return shapeArea(perspective(vertexes, chart, insidePlotArea));
}
Globals_default.shapeArea3d = shapeArea3D;
var mathModule = {
  perspective,
  perspective3D,
  pointCameraDistance,
  shapeArea,
  shapeArea3D
};
var Math3D_default = mathModule;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGElement3D.js
var color10 = Color_default.parse;
var defined48 = Utilities_default.defined;
var merge65 = Utilities_default.merge;
var objectEach32 = Utilities_default.objectEach;
var pick74 = Utilities_default.pick;
var SVGElement3D = {};
SVGElement3D.base = {
  /* eslint-disable valid-jsdoc */
  /**
   * The init is used by base - renderer.Element
   * @private
   */
  initArgs: function(args) {
    var elem3d = this, renderer = elem3d.renderer, paths = renderer[elem3d.pathType + "Path"](args), zIndexes = paths.zIndexes;
    elem3d.parts.forEach(function(part) {
      elem3d[part] = renderer.path(paths[part]).attr({
        "class": "highcharts-3d-" + part,
        zIndex: zIndexes[part] || 0
      }).add(elem3d);
    });
    elem3d.attr({
      "stroke-linejoin": "round",
      zIndex: zIndexes.group
    });
    elem3d.originalDestroy = elem3d.destroy;
    elem3d.destroy = elem3d.destroyParts;
    elem3d.forcedSides = paths.forcedSides;
  },
  /**
   * Single property setter that applies options to each part
   * @private
   */
  singleSetterForParts: function(prop, val, values, verb, duration, complete) {
    var elem3d = this, newAttr = {}, optionsToApply = [null, null, verb || "attr", duration, complete], hasZIndexes = values && values.zIndexes;
    if (!values) {
      newAttr[prop] = val;
      optionsToApply[0] = newAttr;
    } else {
      if (hasZIndexes && hasZIndexes.group) {
        this.attr({
          zIndex: hasZIndexes.group
        });
      }
      objectEach32(values, function(partVal, part) {
        newAttr[part] = {};
        newAttr[part][prop] = partVal;
        if (hasZIndexes) {
          newAttr[part].zIndex = values.zIndexes[part] || 0;
        }
      });
      optionsToApply[1] = newAttr;
    }
    return elem3d.processParts.apply(elem3d, optionsToApply);
  },
  /**
   * Calls function for each part. Used for attr, animate and destroy.
   * @private
   */
  processParts: function(props, partsProps, verb, duration, complete) {
    var elem3d = this;
    elem3d.parts.forEach(function(part) {
      if (partsProps) {
        props = pick74(partsProps[part], false);
      }
      if (props !== false) {
        elem3d[part][verb](props, duration, complete);
      }
    });
    return elem3d;
  },
  /**
   * Destroy all parts
   * @private
   */
  destroyParts: function() {
    this.processParts(null, null, "destroy");
    return this.originalDestroy();
  }
  /* eslint-enable valid-jsdoc */
};
SVGElement3D.cuboid = merge65(SVGElement3D.base, {
  parts: ["front", "top", "side"],
  pathType: "cuboid",
  attr: function(args, val, complete, continueAnimation) {
    if (typeof args === "string" && typeof val !== "undefined") {
      var key = args;
      args = {};
      args[key] = val;
    }
    if (args.shapeArgs || defined48(args.x)) {
      return this.singleSetterForParts("d", null, this.renderer[this.pathType + "Path"](args.shapeArgs || args));
    }
    return SVGElement_default.prototype.attr.call(this, args, void 0, complete, continueAnimation);
  },
  animate: function(args, duration, complete) {
    if (defined48(args.x) && defined48(args.y)) {
      var paths = this.renderer[this.pathType + "Path"](args), forcedSides = paths.forcedSides;
      this.singleSetterForParts("d", null, paths, "animate", duration, complete);
      this.attr({
        zIndex: paths.zIndexes.group
      });
      if (forcedSides !== this.forcedSides) {
        this.forcedSides = forcedSides;
        SVGElement3D.cuboid.fillSetter.call(this, this.fill);
      }
    } else {
      SVGElement_default.prototype.animate.call(this, args, duration, complete);
    }
    return this;
  },
  fillSetter: function(fill) {
    var elem3d = this;
    elem3d.forcedSides = elem3d.forcedSides || [];
    elem3d.singleSetterForParts("fill", null, {
      front: fill,
      // Do not change color if side was forced to render.
      top: color10(fill).brighten(elem3d.forcedSides.indexOf("top") >= 0 ? 0 : 0.1).get(),
      side: color10(fill).brighten(elem3d.forcedSides.indexOf("side") >= 0 ? 0 : -0.1).get()
    });
    elem3d.color = elem3d.fill = fill;
    return elem3d;
  }
});
var SVGElement3D_default = SVGElement3D;

// node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGRenderer3D.js
var __extends37 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var animObject12 = AnimationUtilities_default.animObject;
var color11 = Color_default.parse;
var charts6 = Globals_default.charts;
var deg2rad7 = Globals_default.deg2rad;
var perspective2 = Math3D_default.perspective;
var shapeArea2 = Math3D_default.shapeArea;
var defined49 = Utilities_default.defined;
var extend67 = Utilities_default.extend;
var merge66 = Utilities_default.merge;
var pick75 = Utilities_default.pick;
var cos = Math.cos;
var sin = Math.sin;
var PI = Math.PI;
var dFactor = 4 * (Math.sqrt(2) - 1) / 3 / (PI / 2);
var SVGRenderer3D = (
  /** @class */
  function(_super) {
    __extends37(SVGRenderer3D2, _super);
    function SVGRenderer3D2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SVGRenderer3D2.compose = function(SVGRendererClass) {
      var svgRendererProto = SVGRendererClass.prototype, svgRenderer3dProto = SVGRenderer3D2.prototype;
      svgRendererProto.elements3d = SVGElement3D_default;
      svgRendererProto.arc3d = svgRenderer3dProto.arc3d;
      svgRendererProto.arc3dPath = svgRenderer3dProto.arc3dPath;
      svgRendererProto.cuboid = svgRenderer3dProto.cuboid;
      svgRendererProto.cuboidPath = svgRenderer3dProto.cuboidPath;
      svgRendererProto.element3d = svgRenderer3dProto.element3d;
      svgRendererProto.face3d = svgRenderer3dProto.face3d;
      svgRendererProto.polyhedron = svgRenderer3dProto.polyhedron;
      svgRendererProto.toLinePath = svgRenderer3dProto.toLinePath;
      svgRendererProto.toLineSegments = svgRenderer3dProto.toLineSegments;
    };
    SVGRenderer3D2.curveTo = function(cx, cy, rx, ry, start, end, dx, dy) {
      var result2 = [], arcAngle = end - start;
      if (end > start && end - start > Math.PI / 2 + 1e-4) {
        result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start, start + Math.PI / 2, dx, dy));
        result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start + Math.PI / 2, end, dx, dy));
        return result2;
      }
      if (end < start && start - end > Math.PI / 2 + 1e-4) {
        result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start, start - Math.PI / 2, dx, dy));
        result2 = result2.concat(this.curveTo(cx, cy, rx, ry, start - Math.PI / 2, end, dx, dy));
        return result2;
      }
      return [[
        "C",
        cx + rx * Math.cos(start) - rx * dFactor * arcAngle * Math.sin(start) + dx,
        cy + ry * Math.sin(start) + ry * dFactor * arcAngle * Math.cos(start) + dy,
        cx + rx * Math.cos(end) + rx * dFactor * arcAngle * Math.sin(end) + dx,
        cy + ry * Math.sin(end) - ry * dFactor * arcAngle * Math.cos(end) + dy,
        cx + rx * Math.cos(end) + dx,
        cy + ry * Math.sin(end) + dy
      ]];
    };
    SVGRenderer3D2.prototype.toLinePath = function(points, closed) {
      var result2 = [];
      points.forEach(function(point) {
        result2.push(["L", point.x, point.y]);
      });
      if (points.length) {
        result2[0][0] = "M";
        if (closed) {
          result2.push(["Z"]);
        }
      }
      return result2;
    };
    SVGRenderer3D2.prototype.toLineSegments = function(points) {
      var result2 = [], m = true;
      points.forEach(function(point) {
        result2.push(m ? ["M", point.x, point.y] : ["L", point.x, point.y]);
        m = !m;
      });
      return result2;
    };
    SVGRenderer3D2.prototype.face3d = function(args) {
      var renderer = this, ret = this.createElement("path");
      ret.vertexes = [];
      ret.insidePlotArea = false;
      ret.enabled = true;
      ret.attr = function(hash) {
        if (typeof hash === "object" && (defined49(hash.enabled) || defined49(hash.vertexes) || defined49(hash.insidePlotArea))) {
          this.enabled = pick75(hash.enabled, this.enabled);
          this.vertexes = pick75(hash.vertexes, this.vertexes);
          this.insidePlotArea = pick75(hash.insidePlotArea, this.insidePlotArea);
          delete hash.enabled;
          delete hash.vertexes;
          delete hash.insidePlotArea;
          var chart = charts6[renderer.chartIndex], vertexes2d = perspective2(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea2(vertexes2d);
          hash.d = path;
          hash.visibility = this.enabled && area > 0 ? "visible" : "hidden";
        }
        return SVGElement_default.prototype.attr.apply(this, arguments);
      };
      ret.animate = function(params) {
        if (typeof params === "object" && (defined49(params.enabled) || defined49(params.vertexes) || defined49(params.insidePlotArea))) {
          this.enabled = pick75(params.enabled, this.enabled);
          this.vertexes = pick75(params.vertexes, this.vertexes);
          this.insidePlotArea = pick75(params.insidePlotArea, this.insidePlotArea);
          delete params.enabled;
          delete params.vertexes;
          delete params.insidePlotArea;
          var chart = charts6[renderer.chartIndex], vertexes2d = perspective2(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea2(vertexes2d), visibility = this.enabled && area > 0 ? "visible" : "hidden";
          params.d = path;
          this.attr("visibility", visibility);
        }
        return SVGElement_default.prototype.animate.apply(this, arguments);
      };
      return ret.attr(args);
    };
    SVGRenderer3D2.prototype.polyhedron = function(args) {
      var renderer = this, result2 = this.g(), destroy = result2.destroy;
      if (!this.styledMode) {
        result2.attr({
          "stroke-linejoin": "round"
        });
      }
      result2.faces = [];
      result2.destroy = function() {
        for (var i = 0; i < result2.faces.length; i++) {
          result2.faces[i].destroy();
        }
        return destroy.call(this);
      };
      result2.attr = function(hash, val, complete, continueAnimation) {
        if (typeof hash === "object" && defined49(hash.faces)) {
          while (result2.faces.length > hash.faces.length) {
            result2.faces.pop().destroy();
          }
          while (result2.faces.length < hash.faces.length) {
            result2.faces.push(renderer.face3d().add(result2));
          }
          for (var i = 0; i < hash.faces.length; i++) {
            if (renderer.styledMode) {
              delete hash.faces[i].fill;
            }
            result2.faces[i].attr(hash.faces[i], null, complete, continueAnimation);
          }
          delete hash.faces;
        }
        return SVGElement_default.prototype.attr.apply(this, arguments);
      };
      result2.animate = function(params, duration, complete) {
        if (params && params.faces) {
          while (result2.faces.length > params.faces.length) {
            result2.faces.pop().destroy();
          }
          while (result2.faces.length < params.faces.length) {
            result2.faces.push(renderer.face3d().add(result2));
          }
          for (var i = 0; i < params.faces.length; i++) {
            result2.faces[i].animate(params.faces[i], duration, complete);
          }
          delete params.faces;
        }
        return SVGElement_default.prototype.animate.apply(this, arguments);
      };
      return result2.attr(args);
    };
    SVGRenderer3D2.prototype.element3d = function(type, shapeArgs) {
      var ret = this.g();
      extend67(ret, this.elements3d[type]);
      ret.initArgs(shapeArgs);
      return ret;
    };
    SVGRenderer3D2.prototype.cuboid = function(shapeArgs) {
      return this.element3d("cuboid", shapeArgs);
    };
    SVGRenderer3D2.prototype.cuboidPath = function(shapeArgs) {
      var x = shapeArgs.x || 0, y = shapeArgs.y || 0, z = shapeArgs.z || 0, h = shapeArgs.height || 0, w2 = shapeArgs.width || 0, d = shapeArgs.depth || 0, chart = charts6[this.chartIndex], front, back, top, bottom, left, right, shape, path1, path2, path3, isFront, isTop, isRight, options3d = chart.options.chart.options3d, alpha = options3d.alpha, incrementX = 1e6, incrementY = 10, incrementZ = 100, zIndex = 0, pArr = [{
        x,
        y,
        z
      }, {
        x: x + w2,
        y,
        z
      }, {
        x: x + w2,
        y: y + h,
        z
      }, {
        x,
        y: y + h,
        z
      }, {
        x,
        y: y + h,
        z: z + d
      }, {
        x: x + w2,
        y: y + h,
        z: z + d
      }, {
        x: x + w2,
        y,
        z: z + d
      }, {
        x,
        y,
        z: z + d
      }], forcedSides = [], pickShape;
      pArr = perspective2(pArr, chart, shapeArgs.insidePlotArea);
      function mapSidePath(i) {
        if (h === 0 && i > 1 && i < 6) {
          return {
            x: pArr[i].x,
            // when height is 0 instead of cuboid we render plane
            // so it is needed to add fake 10 height to imitate cuboid
            // for side calculation
            y: pArr[i].y + 10,
            z: pArr[i].z
          };
        }
        if (pArr[0].x === pArr[7].x && i >= 4) {
          return {
            x: pArr[i].x + 10,
            // when height is 0 instead of cuboid we render plane
            // so it is needed to add fake 10 height to imitate cuboid
            // for side calculation
            y: pArr[i].y,
            z: pArr[i].z
          };
        }
        if (d === 0 && i < 2 || i > 5) {
          return {
            x: pArr[i].x,
            // when height is 0 instead of cuboid we render plane
            // so it is needed to add fake 10 height to imitate cuboid
            // for side calculation
            y: pArr[i].y,
            z: pArr[i].z + 10
          };
        }
        return pArr[i];
      }
      function mapPath(i) {
        return pArr[i];
      }
      pickShape = function(verticesIndex1, verticesIndex2, side) {
        var ret = [[], -1], face1 = verticesIndex1.map(mapPath), face2 = verticesIndex2.map(mapPath), dummyFace1 = verticesIndex1.map(mapSidePath), dummyFace2 = verticesIndex2.map(mapSidePath);
        if (shapeArea2(face1) < 0) {
          ret = [face1, 0];
        } else if (shapeArea2(face2) < 0) {
          ret = [face2, 1];
        } else if (side) {
          forcedSides.push(side);
          if (shapeArea2(dummyFace1) < 0) {
            ret = [face1, 0];
          } else if (shapeArea2(dummyFace2) < 0) {
            ret = [face2, 1];
          } else {
            ret = [face1, 0];
          }
        }
        return ret;
      };
      front = [3, 2, 1, 0];
      back = [7, 6, 5, 4];
      shape = pickShape(front, back, "front");
      path1 = shape[0];
      isFront = shape[1];
      top = [1, 6, 7, 0];
      bottom = [4, 5, 2, 3];
      shape = pickShape(top, bottom, "top");
      path2 = shape[0];
      isTop = shape[1];
      right = [1, 2, 5, 6];
      left = [0, 7, 4, 3];
      shape = pickShape(right, left, "side");
      path3 = shape[0];
      isRight = shape[1];
      if (isRight === 1) {
        zIndex += incrementX * (chart.plotWidth - x);
      } else if (!isRight) {
        zIndex += incrementX * x;
      }
      zIndex += incrementY * (!isTop || // Numbers checked empirically
      (alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5) ? chart.plotHeight - y : 10 + y);
      if (isFront === 1) {
        zIndex += incrementZ * z;
      } else if (!isFront) {
        zIndex += incrementZ * (1e3 - z);
      }
      return {
        front: this.toLinePath(path1, true),
        top: this.toLinePath(path2, true),
        side: this.toLinePath(path3, true),
        zIndexes: {
          group: Math.round(zIndex)
        },
        forcedSides,
        // additional info about zIndexes
        isFront,
        isTop
      };
    };
    SVGRenderer3D2.prototype.arc3d = function(attribs) {
      var wrapper = this.g(), renderer = wrapper.renderer, customAttribs = ["x", "y", "r", "innerR", "start", "end", "depth"];
      function suckOutCustom(params) {
        var hasCA = false, ca = {}, key;
        params = merge66(params);
        for (key in params) {
          if (customAttribs.indexOf(key) !== -1) {
            ca[key] = params[key];
            delete params[key];
            hasCA = true;
          }
        }
        return hasCA ? [ca, params] : false;
      }
      attribs = merge66(attribs);
      attribs.alpha = (attribs.alpha || 0) * deg2rad7;
      attribs.beta = (attribs.beta || 0) * deg2rad7;
      wrapper.top = renderer.path();
      wrapper.side1 = renderer.path();
      wrapper.side2 = renderer.path();
      wrapper.inn = renderer.path();
      wrapper.out = renderer.path();
      wrapper.onAdd = function() {
        var parent = wrapper.parentGroup, className = wrapper.attr("class");
        wrapper.top.add(wrapper);
        ["out", "inn", "side1", "side2"].forEach(function(face) {
          wrapper[face].attr({
            "class": className + " highcharts-3d-side"
          }).add(parent);
        });
      };
      ["addClass", "removeClass"].forEach(function(fn) {
        wrapper[fn] = function() {
          var args = arguments;
          ["top", "out", "inn", "side1", "side2"].forEach(function(face) {
            wrapper[face][fn].apply(wrapper[face], args);
          });
        };
      });
      wrapper.setPaths = function(attribs2) {
        var paths = wrapper.renderer.arc3dPath(attribs2), zIndex = paths.zTop * 100;
        wrapper.attribs = attribs2;
        wrapper.top.attr({ d: paths.top, zIndex: paths.zTop });
        wrapper.inn.attr({ d: paths.inn, zIndex: paths.zInn });
        wrapper.out.attr({ d: paths.out, zIndex: paths.zOut });
        wrapper.side1.attr({ d: paths.side1, zIndex: paths.zSide1 });
        wrapper.side2.attr({ d: paths.side2, zIndex: paths.zSide2 });
        wrapper.zIndex = zIndex;
        wrapper.attr({ zIndex });
        if (attribs2.center) {
          wrapper.top.setRadialReference(attribs2.center);
          delete attribs2.center;
        }
      };
      wrapper.setPaths(attribs);
      wrapper.fillSetter = function(value) {
        var darker = color11(value).brighten(-0.1).get();
        this.fill = value;
        this.side1.attr({ fill: darker });
        this.side2.attr({ fill: darker });
        this.inn.attr({ fill: darker });
        this.out.attr({ fill: darker });
        this.top.attr({ fill: value });
        return this;
      };
      ["opacity", "translateX", "translateY", "visibility"].forEach(function(setter) {
        wrapper[setter + "Setter"] = function(value, key) {
          wrapper[key] = value;
          ["out", "inn", "side1", "side2", "top"].forEach(function(el) {
            wrapper[el].attr(key, value);
          });
        };
      });
      wrapper.attr = function(params) {
        var ca, paramArr;
        if (typeof params === "object") {
          paramArr = suckOutCustom(params);
          if (paramArr) {
            ca = paramArr[0];
            arguments[0] = paramArr[1];
            extend67(wrapper.attribs, ca);
            wrapper.setPaths(wrapper.attribs);
          }
        }
        return SVGElement_default.prototype.attr.apply(wrapper, arguments);
      };
      wrapper.animate = function(params, animation, complete) {
        var paramArr, from = this.attribs, to, anim, randomProp = "data-" + Math.random().toString(26).substring(2, 9);
        delete params.center;
        delete params.z;
        delete params.alpha;
        delete params.beta;
        anim = animObject12(pick75(animation, this.renderer.globalAnimation));
        if (anim.duration) {
          paramArr = suckOutCustom(params);
          wrapper[randomProp] = 0;
          params[randomProp] = 1;
          wrapper[randomProp + "Setter"] = Globals_default.noop;
          if (paramArr) {
            to = paramArr[0];
            anim.step = function(a, fx) {
              function interpolate(key) {
                return from[key] + (pick75(to[key], from[key]) - from[key]) * fx.pos;
              }
              if (fx.prop === randomProp) {
                fx.elem.setPaths(merge66(from, {
                  x: interpolate("x"),
                  y: interpolate("y"),
                  r: interpolate("r"),
                  innerR: interpolate("innerR"),
                  start: interpolate("start"),
                  end: interpolate("end"),
                  depth: interpolate("depth")
                }));
              }
            };
          }
          animation = anim;
        }
        return SVGElement_default.prototype.animate.call(this, params, animation, complete);
      };
      wrapper.destroy = function() {
        this.top.destroy();
        this.out.destroy();
        this.inn.destroy();
        this.side1.destroy();
        this.side2.destroy();
        return SVGElement_default.prototype.destroy.call(this);
      };
      wrapper.hide = function() {
        this.top.hide();
        this.out.hide();
        this.inn.hide();
        this.side1.hide();
        this.side2.hide();
      };
      wrapper.show = function(inherit) {
        this.top.show(inherit);
        this.out.show(inherit);
        this.inn.show(inherit);
        this.side1.show(inherit);
        this.side2.show(inherit);
      };
      return wrapper;
    };
    SVGRenderer3D2.prototype.arc3dPath = function(shapeArgs) {
      var cx = shapeArgs.x || 0, cy = shapeArgs.y || 0, start = shapeArgs.start || 0, end = (shapeArgs.end || 0) - 1e-5, r = shapeArgs.r || 0, ir = shapeArgs.innerR || 0, d = shapeArgs.depth || 0, alpha = shapeArgs.alpha || 0, beta = shapeArgs.beta || 0;
      var cs = Math.cos(start), ss = Math.sin(start), ce = Math.cos(end), se = Math.sin(end), rx = r * Math.cos(beta), ry = r * Math.cos(alpha), irx = ir * Math.cos(beta), iry = ir * Math.cos(alpha), dx = d * Math.sin(beta), dy = d * Math.sin(alpha);
      var top = [
        ["M", cx + rx * cs, cy + ry * ss]
      ];
      top = top.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, start, end, 0, 0));
      top.push([
        "L",
        cx + irx * ce,
        cy + iry * se
      ]);
      top = top.concat(SVGRenderer3D2.curveTo(cx, cy, irx, iry, end, start, 0, 0));
      top.push(["Z"]);
      var b = beta > 0 ? Math.PI / 2 : 0, a = alpha > 0 ? 0 : Math.PI / 2;
      var start2 = start > -b ? start : end > -b ? -b : start, end2 = end < PI - a ? end : start < PI - a ? PI - a : end, midEnd = 2 * PI - a;
      var out = [
        ["M", cx + rx * cos(start2), cy + ry * sin(start2)]
      ];
      out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, start2, end2, 0, 0));
      if (end > midEnd && start < midEnd) {
        out.push([
          "L",
          cx + rx * cos(end2) + dx,
          cy + ry * sin(end2) + dy
        ]);
        out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy));
        out.push([
          "L",
          cx + rx * cos(midEnd),
          cy + ry * sin(midEnd)
        ]);
        out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, midEnd, end, 0, 0));
        out.push([
          "L",
          cx + rx * cos(end) + dx,
          cy + ry * sin(end) + dy
        ]);
        out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));
        out.push([
          "L",
          cx + rx * cos(midEnd),
          cy + ry * sin(midEnd)
        ]);
        out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0));
      } else if (end > PI - a && start < PI - a) {
        out.push([
          "L",
          cx + rx * Math.cos(end2) + dx,
          cy + ry * Math.sin(end2) + dy
        ]);
        out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end2, end, dx, dy));
        out.push([
          "L",
          cx + rx * Math.cos(end),
          cy + ry * Math.sin(end)
        ]);
        out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end, end2, 0, 0));
      }
      out.push([
        "L",
        cx + rx * Math.cos(end2) + dx,
        cy + ry * Math.sin(end2) + dy
      ]);
      out = out.concat(SVGRenderer3D2.curveTo(cx, cy, rx, ry, end2, start2, dx, dy));
      out.push(["Z"]);
      var inn = [
        ["M", cx + irx * cs, cy + iry * ss]
      ];
      inn = inn.concat(SVGRenderer3D2.curveTo(cx, cy, irx, iry, start, end, 0, 0));
      inn.push([
        "L",
        cx + irx * Math.cos(end) + dx,
        cy + iry * Math.sin(end) + dy
      ]);
      inn = inn.concat(SVGRenderer3D2.curveTo(cx, cy, irx, iry, end, start, dx, dy));
      inn.push(["Z"]);
      var side1 = [
        ["M", cx + rx * cs, cy + ry * ss],
        ["L", cx + rx * cs + dx, cy + ry * ss + dy],
        ["L", cx + irx * cs + dx, cy + iry * ss + dy],
        ["L", cx + irx * cs, cy + iry * ss],
        ["Z"]
      ];
      var side2 = [
        ["M", cx + rx * ce, cy + ry * se],
        ["L", cx + rx * ce + dx, cy + ry * se + dy],
        ["L", cx + irx * ce + dx, cy + iry * se + dy],
        ["L", cx + irx * ce, cy + iry * se],
        ["Z"]
      ];
      var angleCorr = Math.atan2(dy, -dx), angleEnd = Math.abs(end + angleCorr), angleStart = Math.abs(start + angleCorr), angleMid = Math.abs((start + end) / 2 + angleCorr);
      function toZeroPIRange(angle) {
        angle = angle % (2 * Math.PI);
        if (angle > Math.PI) {
          angle = 2 * Math.PI - angle;
        }
        return angle;
      }
      angleEnd = toZeroPIRange(angleEnd);
      angleStart = toZeroPIRange(angleStart);
      angleMid = toZeroPIRange(angleMid);
      var incPrecision = 1e5, a1 = angleMid * incPrecision, a2 = angleStart * incPrecision, a3 = angleEnd * incPrecision;
      return {
        top,
        // max angle is PI, so this is always higher
        zTop: Math.PI * incPrecision + 1,
        out,
        zOut: Math.max(a1, a2, a3),
        inn,
        zInn: Math.max(a1, a2, a3),
        side1,
        zSide1: a3 * 0.99,
        side2,
        zSide2: a2 * 0.99
      };
    };
    return SVGRenderer3D2;
  }(SVGRenderer_default)
);
var SVGRenderer3D_default = SVGRenderer3D;

// node_modules/highcharts/es-modules/Core/Chart/Chart3D.js
var color12 = Color_default.parse;
var perspective3 = Math3D_default.perspective;
var shapeArea3D2 = Math3D_default.shapeArea3D;
var genericDefaultOptions = DefaultOptions_default.defaultOptions;
var addEvent50 = Utilities_default.addEvent;
var isArray21 = Utilities_default.isArray;
var merge67 = Utilities_default.merge;
var pick76 = Utilities_default.pick;
var wrap9 = Utilities_default.wrap;
var Chart3D;
(function(Chart3D2) {
  var Composition = (
    /** @class */
    function() {
      function Composition2(chart) {
        this.frame3d = void 0;
        this.chart = chart;
      }
      Composition2.prototype.get3dFrame = function() {
        var chart = this.chart, options3d = chart.options.chart.options3d, frameOptions = options3d.frame, xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, faceOrientation = function(vertexes) {
          var area = shapeArea3D2(vertexes, chart);
          if (area > 0.5) {
            return 1;
          }
          if (area < -0.5) {
            return -1;
          }
          return 0;
        }, bottomOrientation = faceOrientation([
          { x: xm, y: yp, z: zp },
          { x: xp, y: yp, z: zp },
          { x: xp, y: yp, z: zm },
          { x: xm, y: yp, z: zm }
        ]), topOrientation = faceOrientation([
          { x: xm, y: ym, z: zm },
          { x: xp, y: ym, z: zm },
          { x: xp, y: ym, z: zp },
          { x: xm, y: ym, z: zp }
        ]), leftOrientation = faceOrientation([
          { x: xm, y: ym, z: zm },
          { x: xm, y: ym, z: zp },
          { x: xm, y: yp, z: zp },
          { x: xm, y: yp, z: zm }
        ]), rightOrientation = faceOrientation([
          { x: xp, y: ym, z: zp },
          { x: xp, y: ym, z: zm },
          { x: xp, y: yp, z: zm },
          { x: xp, y: yp, z: zp }
        ]), frontOrientation = faceOrientation([
          { x: xm, y: yp, z: zm },
          { x: xp, y: yp, z: zm },
          { x: xp, y: ym, z: zm },
          { x: xm, y: ym, z: zm }
        ]), backOrientation = faceOrientation([
          { x: xm, y: ym, z: zp },
          { x: xp, y: ym, z: zp },
          { x: xp, y: yp, z: zp },
          { x: xm, y: yp, z: zp }
        ]), defaultShowFront = false, defaultShowBack = true;
        var defaultShowBottom = false, defaultShowTop = false, defaultShowLeft = false, defaultShowRight = false;
        [].concat(chart.xAxis, chart.yAxis, chart.zAxis).forEach(function(axis) {
          if (axis) {
            if (axis.horiz) {
              if (axis.opposite) {
                defaultShowTop = true;
              } else {
                defaultShowBottom = true;
              }
            } else {
              if (axis.opposite) {
                defaultShowRight = true;
              } else {
                defaultShowLeft = true;
              }
            }
          }
        });
        var getFaceOptions = function(sources, faceOrientation2, defaultVisible) {
          var faceAttrs = ["size", "color", "visible"], options = {};
          for (var i = 0; i < faceAttrs.length; i++) {
            var attr11 = faceAttrs[i];
            for (var j = 0; j < sources.length; j++) {
              if (typeof sources[j] === "object") {
                var val = sources[j][attr11];
                if (typeof val !== "undefined" && val !== null) {
                  options[attr11] = val;
                  break;
                }
              }
            }
          }
          var isVisible = defaultVisible;
          if (options.visible === true || options.visible === false) {
            isVisible = options.visible;
          } else if (options.visible === "auto") {
            isVisible = faceOrientation2 > 0;
          }
          return {
            size: pick76(options.size, 1),
            color: pick76(options.color, "none"),
            frontFacing: faceOrientation2 > 0,
            visible: isVisible
          };
        };
        var ret = {
          axes: {},
          // FIXME: Previously, left/right, top/bottom and front/back
          // pairs shared size and color.
          // For compatibility and consistency sake, when one face have
          // size/color/visibility set, the opposite face will default to
          // the same values. Also, left/right used to be called 'side',
          // so that's also added as a fallback.
          bottom: getFaceOptions([frameOptions.bottom, frameOptions.top, frameOptions], bottomOrientation, defaultShowBottom),
          top: getFaceOptions([frameOptions.top, frameOptions.bottom, frameOptions], topOrientation, defaultShowTop),
          left: getFaceOptions([
            frameOptions.left,
            frameOptions.right,
            frameOptions.side,
            frameOptions
          ], leftOrientation, defaultShowLeft),
          right: getFaceOptions([
            frameOptions.right,
            frameOptions.left,
            frameOptions.side,
            frameOptions
          ], rightOrientation, defaultShowRight),
          back: getFaceOptions([frameOptions.back, frameOptions.front, frameOptions], backOrientation, defaultShowBack),
          front: getFaceOptions([frameOptions.front, frameOptions.back, frameOptions], frontOrientation, defaultShowFront)
        };
        if (options3d.axisLabelPosition === "auto") {
          var isValidEdge = function(face1, face2) {
            return face1.visible !== face2.visible || face1.visible && face2.visible && face1.frontFacing !== face2.frontFacing;
          };
          var yEdges = [];
          if (isValidEdge(ret.left, ret.front)) {
            yEdges.push({
              y: (ym + yp) / 2,
              x: xm,
              z: zm,
              xDir: { x: 1, y: 0, z: 0 }
            });
          }
          if (isValidEdge(ret.left, ret.back)) {
            yEdges.push({
              y: (ym + yp) / 2,
              x: xm,
              z: zp,
              xDir: { x: 0, y: 0, z: -1 }
            });
          }
          if (isValidEdge(ret.right, ret.front)) {
            yEdges.push({
              y: (ym + yp) / 2,
              x: xp,
              z: zm,
              xDir: { x: 0, y: 0, z: 1 }
            });
          }
          if (isValidEdge(ret.right, ret.back)) {
            yEdges.push({
              y: (ym + yp) / 2,
              x: xp,
              z: zp,
              xDir: { x: -1, y: 0, z: 0 }
            });
          }
          var xBottomEdges = [];
          if (isValidEdge(ret.bottom, ret.front)) {
            xBottomEdges.push({
              x: (xm + xp) / 2,
              y: yp,
              z: zm,
              xDir: { x: 1, y: 0, z: 0 }
            });
          }
          if (isValidEdge(ret.bottom, ret.back)) {
            xBottomEdges.push({
              x: (xm + xp) / 2,
              y: yp,
              z: zp,
              xDir: { x: -1, y: 0, z: 0 }
            });
          }
          var xTopEdges = [];
          if (isValidEdge(ret.top, ret.front)) {
            xTopEdges.push({
              x: (xm + xp) / 2,
              y: ym,
              z: zm,
              xDir: { x: 1, y: 0, z: 0 }
            });
          }
          if (isValidEdge(ret.top, ret.back)) {
            xTopEdges.push({
              x: (xm + xp) / 2,
              y: ym,
              z: zp,
              xDir: { x: -1, y: 0, z: 0 }
            });
          }
          var zBottomEdges = [];
          if (isValidEdge(ret.bottom, ret.left)) {
            zBottomEdges.push({
              z: (zm + zp) / 2,
              y: yp,
              x: xm,
              xDir: { x: 0, y: 0, z: -1 }
            });
          }
          if (isValidEdge(ret.bottom, ret.right)) {
            zBottomEdges.push({
              z: (zm + zp) / 2,
              y: yp,
              x: xp,
              xDir: { x: 0, y: 0, z: 1 }
            });
          }
          var zTopEdges = [];
          if (isValidEdge(ret.top, ret.left)) {
            zTopEdges.push({
              z: (zm + zp) / 2,
              y: ym,
              x: xm,
              xDir: { x: 0, y: 0, z: -1 }
            });
          }
          if (isValidEdge(ret.top, ret.right)) {
            zTopEdges.push({
              z: (zm + zp) / 2,
              y: ym,
              x: xp,
              xDir: { x: 0, y: 0, z: 1 }
            });
          }
          var pickEdge = function(edges, axis, mult) {
            if (edges.length === 0) {
              return null;
            }
            if (edges.length === 1) {
              return edges[0];
            }
            var projections = perspective3(edges, chart, false);
            var best = 0;
            for (var i = 1; i < projections.length; i++) {
              if (mult * projections[i][axis] > mult * projections[best][axis]) {
                best = i;
              } else if (mult * projections[i][axis] === mult * projections[best][axis] && projections[i].z < projections[best].z) {
                best = i;
              }
            }
            return edges[best];
          };
          ret.axes = {
            y: {
              "left": pickEdge(yEdges, "x", -1),
              "right": pickEdge(yEdges, "x", 1)
            },
            x: {
              "top": pickEdge(xTopEdges, "y", -1),
              "bottom": pickEdge(xBottomEdges, "y", 1)
            },
            z: {
              "top": pickEdge(zTopEdges, "y", -1),
              "bottom": pickEdge(zBottomEdges, "y", 1)
            }
          };
        } else {
          ret.axes = {
            y: {
              "left": { x: xm, z: zm, xDir: { x: 1, y: 0, z: 0 } },
              "right": { x: xp, z: zm, xDir: { x: 0, y: 0, z: 1 } }
            },
            x: {
              "top": { y: ym, z: zm, xDir: { x: 1, y: 0, z: 0 } },
              "bottom": { y: yp, z: zm, xDir: { x: 1, y: 0, z: 0 } }
            },
            z: {
              "top": {
                x: defaultShowLeft ? xp : xm,
                y: ym,
                xDir: defaultShowLeft ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 }
              },
              "bottom": {
                x: defaultShowLeft ? xp : xm,
                y: yp,
                xDir: defaultShowLeft ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 }
              }
            }
          };
        }
        return ret;
      };
      Composition2.prototype.getScale = function(depth) {
        var chart = this.chart, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop, originX = plotLeft + chart.plotWidth / 2, originY = plotTop + chart.plotHeight / 2, bbox3d = {
          minX: Number.MAX_VALUE,
          maxX: -Number.MAX_VALUE,
          minY: Number.MAX_VALUE,
          maxY: -Number.MAX_VALUE
        };
        var corners, scale = 1;
        corners = [{
          x: plotLeft,
          y: plotTop,
          z: 0
        }, {
          x: plotLeft,
          y: plotTop,
          z: depth
        }];
        [0, 1].forEach(function(i) {
          corners.push({
            x: plotRight,
            y: corners[i].y,
            z: corners[i].z
          });
        });
        [0, 1, 2, 3].forEach(function(i) {
          corners.push({
            x: corners[i].x,
            y: plotBottom,
            z: corners[i].z
          });
        });
        corners = perspective3(corners, chart, false);
        corners.forEach(function(corner) {
          bbox3d.minX = Math.min(bbox3d.minX, corner.x);
          bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);
          bbox3d.minY = Math.min(bbox3d.minY, corner.y);
          bbox3d.maxY = Math.max(bbox3d.maxY, corner.y);
        });
        if (plotLeft > bbox3d.minX) {
          scale = Math.min(scale, 1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1);
        }
        if (plotRight < bbox3d.maxX) {
          scale = Math.min(scale, (plotRight - originX) / (bbox3d.maxX - originX));
        }
        if (plotTop > bbox3d.minY) {
          if (bbox3d.minY < 0) {
            scale = Math.min(scale, (plotTop + originY) / (-bbox3d.minY + plotTop + originY));
          } else {
            scale = Math.min(scale, 1 - (plotTop + originY) / (bbox3d.minY + originY) % 1);
          }
        }
        if (plotBottom < bbox3d.maxY) {
          scale = Math.min(scale, Math.abs((plotBottom - originY) / (bbox3d.maxY - originY)));
        }
        return scale;
      };
      return Composition2;
    }()
  );
  Chart3D2.Composition = Composition;
  Chart3D2.defaultOptions = {
    chart: {
      /**
       * Options to render charts in 3 dimensions. This feature requires
       * `highcharts-3d.js`, found in the download package or online at
       * [code.highcharts.com/highcharts-3d.js](https://code.highcharts.com/highcharts-3d.js).
       *
       * @since    4.0
       * @product  highcharts
       * @requires highcharts-3d
       */
      options3d: {
        /**
         * Wether to render the chart using the 3D functionality.
         *
         * @since   4.0
         * @product highcharts
         */
        enabled: false,
        /**
         * One of the two rotation angles for the chart.
         *
         * @since   4.0
         * @product highcharts
         */
        alpha: 0,
        /**
         * One of the two rotation angles for the chart.
         *
         * @since   4.0
         * @product highcharts
         */
        beta: 0,
        /**
         * The total depth of the chart.
         *
         * @since   4.0
         * @product highcharts
         */
        depth: 100,
        /**
         * Whether the 3d box should automatically adjust to the chart
         * plot area.
         *
         * @since   4.2.4
         * @product highcharts
         */
        fitToPlot: true,
        /**
         * Defines the distance the viewer is standing in front of the
         * chart, this setting is important to calculate the perspective
         * effect in column and scatter charts. It is not used for 3D
         * pie charts.
         *
         * @since   4.0
         * @product highcharts
         */
        viewDistance: 25,
        /**
         * Set it to `"auto"` to automatically move the labels to the
         * best edge.
         *
         * @type    {"auto"|null}
         * @since   5.0.12
         * @product highcharts
         */
        axisLabelPosition: null,
        /**
         * Provides the option to draw a frame around the charts by
         * defining a bottom, front and back panel.
         *
         * @since    4.0
         * @product  highcharts
         * @requires highcharts-3d
         */
        frame: {
          /**
           * Whether the frames are visible.
           */
          visible: "default",
          /**
           * General pixel thickness for the frame faces.
           */
          size: 1,
          /**
           * The bottom of the frame around a 3D chart.
           *
           * @since    4.0
           * @product  highcharts
           * @requires highcharts-3d
           */
          /**
           * The color of the panel.
           *
           * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           * @default   transparent
           * @since     4.0
           * @product   highcharts
           * @apioption chart.options3d.frame.bottom.color
           */
          /**
           * The thickness of the panel.
           *
           * @type      {number}
           * @default   1
           * @since     4.0
           * @product   highcharts
           * @apioption chart.options3d.frame.bottom.size
           */
          /**
           * Whether to display the frame. Possible values are `true`,
           * `false`, `"auto"` to display only the frames behind the
           * data, and `"default"` to display faces behind the data
           * based on the axis layout, ignoring the point of view.
           *
           * @sample {highcharts} highcharts/3d/scatter-frame/
           *         Auto frames
           *
           * @type      {boolean|"default"|"auto"}
           * @default   default
           * @since     5.0.12
           * @product   highcharts
           * @apioption chart.options3d.frame.bottom.visible
           */
          /**
           * The bottom of the frame around a 3D chart.
           */
          bottom: {},
          /**
           * The top of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          top: {},
          /**
           * The left side of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          left: {},
          /**
           * The right of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          right: {},
          /**
           * The back side of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          back: {},
          /**
           * The front of the frame around a 3D chart.
           *
           * @extends chart.options3d.frame.bottom
           */
          front: {}
        }
      }
    }
  };
  function compose(ChartClass, FxClass) {
    var chartProto2 = ChartClass.prototype;
    var fxProto = FxClass.prototype;
    chartProto2.is3d = function() {
      return Boolean(this.options.chart.options3d && this.options.chart.options3d.enabled);
    };
    chartProto2.propsRequireDirtyBox.push("chart.options3d");
    chartProto2.propsRequireUpdateSeries.push("chart.options3d");
    fxProto.matrixSetter = function() {
      var interpolated;
      if (this.pos < 1 && (isArray21(this.start) || isArray21(this.end))) {
        var start = this.start || [1, 0, 0, 1, 0, 0], end = this.end || [1, 0, 0, 1, 0, 0];
        interpolated = [];
        for (var i = 0; i < 6; i++) {
          interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i]);
        }
      } else {
        interpolated = this.end;
      }
      this.elem.attr(this.prop, interpolated, null, true);
    };
    merge67(true, genericDefaultOptions, Chart3D2.defaultOptions);
    addEvent50(ChartClass, "init", onInit);
    addEvent50(ChartClass, "addSeries", onAddSeries);
    addEvent50(ChartClass, "afterDrawChartBox", onAfterDrawChartBox);
    addEvent50(ChartClass, "afterGetContainer", onAfterGetContainer);
    addEvent50(ChartClass, "afterInit", onAfterInit);
    addEvent50(ChartClass, "afterSetChartSize", onAfterSetChartSize);
    addEvent50(ChartClass, "beforeRedraw", onBeforeRedraw);
    addEvent50(ChartClass, "beforeRender", onBeforeRender);
    wrap9(chartProto2, "isInsidePlot", wrapIsInsidePlot);
    wrap9(ChartClass, "renderSeries", wrapRenderSeries);
    wrap9(ChartClass, "setClassName", wrapSetClassName);
  }
  Chart3D2.compose = compose;
  function onAddSeries(e2) {
    if (this.is3d()) {
      if (e2.options.type === "scatter") {
        e2.options.type = "scatter3d";
      }
    }
  }
  function onAfterDrawChartBox() {
    if (this.chart3d && this.is3d()) {
      var chart = this, renderer = chart.renderer, options3d = chart.options.chart.options3d, frame = chart.chart3d.get3dFrame(), xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, xmm = xm - (frame.left.visible ? frame.left.size : 0), xpp = xp + (frame.right.visible ? frame.right.size : 0), ymm = ym - (frame.top.visible ? frame.top.size : 0), ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0), zmm = zm - (frame.front.visible ? frame.front.size : 0), zpp = zp + (frame.back.visible ? frame.back.size : 0), verb = chart.hasRendered ? "animate" : "attr";
      chart.chart3d.frame3d = frame;
      if (!chart.frameShapes) {
        chart.frameShapes = {
          bottom: renderer.polyhedron().add(),
          top: renderer.polyhedron().add(),
          left: renderer.polyhedron().add(),
          right: renderer.polyhedron().add(),
          back: renderer.polyhedron().add(),
          front: renderer.polyhedron().add()
        };
      }
      chart.frameShapes.bottom[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-bottom",
        zIndex: frame.bottom.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.bottom.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }],
            enabled: frame.bottom.visible
          },
          {
            fill: color12(frame.bottom.color).brighten(0.1).get(),
            vertexes: [{
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.bottom.visible
          },
          {
            fill: color12(frame.bottom.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.bottom.visible && !frame.left.visible
          },
          {
            fill: color12(frame.bottom.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zp
            }],
            enabled: frame.bottom.visible && !frame.right.visible
          },
          {
            fill: color12(frame.bottom.color).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }],
            enabled: frame.bottom.visible && !frame.front.visible
          },
          {
            fill: color12(frame.bottom.color).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }],
            enabled: frame.bottom.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.top[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-top",
        zIndex: frame.top.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.top.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }],
            enabled: frame.top.visible
          },
          {
            fill: color12(frame.top.color).brighten(0.1).get(),
            vertexes: [{
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.top.visible
          },
          {
            fill: color12(frame.top.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.top.visible && !frame.left.visible
          },
          {
            fill: color12(frame.top.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zm
            }],
            enabled: frame.top.visible && !frame.right.visible
          },
          {
            fill: color12(frame.top.color).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }],
            enabled: frame.top.visible && !frame.front.visible
          },
          {
            fill: color12(frame.top.color).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }],
            enabled: frame.top.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.left[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-left",
        zIndex: frame.left.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.left.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }],
            enabled: frame.left.visible && !frame.bottom.visible
          },
          {
            fill: color12(frame.left.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }],
            enabled: frame.left.visible && !frame.top.visible
          },
          {
            fill: color12(frame.left.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }],
            enabled: frame.left.visible
          },
          {
            fill: color12(frame.left.color).brighten(-0.1).get(),
            vertexes: [{
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }],
            enabled: frame.left.visible
          },
          {
            fill: color12(frame.left.color).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.left.visible && !frame.front.visible
          },
          {
            fill: color12(frame.left.color).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.left.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.right[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-right",
        zIndex: frame.right.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.right.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }],
            enabled: frame.right.visible && !frame.bottom.visible
          },
          {
            fill: color12(frame.right.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }],
            enabled: frame.right.visible && !frame.top.visible
          },
          {
            fill: color12(frame.right.color).brighten(-0.1).get(),
            vertexes: [{
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }],
            enabled: frame.right.visible
          },
          {
            fill: color12(frame.right.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }],
            enabled: frame.right.visible
          },
          {
            fill: color12(frame.right.color).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zm
            }],
            enabled: frame.right.visible && !frame.front.visible
          },
          {
            fill: color12(frame.right.color).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }],
            enabled: frame.right.visible && !frame.back.visible
          }
        ]
      });
      chart.frameShapes.back[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-back",
        zIndex: frame.back.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.back.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xm,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }],
            enabled: frame.back.visible && !frame.bottom.visible
          },
          {
            fill: color12(frame.back.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: ym,
              z: zp
            }],
            enabled: frame.back.visible && !frame.top.visible
          },
          {
            fill: color12(frame.back.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }, {
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }],
            enabled: frame.back.visible && !frame.left.visible
          },
          {
            fill: color12(frame.back.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }],
            enabled: frame.back.visible && !frame.right.visible
          },
          {
            fill: color12(frame.back.color).get(),
            vertexes: [{
              x: xm,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: ym,
              z: zp
            }, {
              x: xp,
              y: yp,
              z: zp
            }, {
              x: xm,
              y: yp,
              z: zp
            }],
            enabled: frame.back.visible
          },
          {
            fill: color12(frame.back.color).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ypp,
              z: zpp
            }, {
              x: xpp,
              y: ymm,
              z: zpp
            }, {
              x: xmm,
              y: ymm,
              z: zpp
            }],
            enabled: frame.back.visible
          }
        ]
      });
      chart.frameShapes.front[verb]({
        "class": "highcharts-3d-frame highcharts-3d-frame-front",
        zIndex: frame.front.frontFacing ? -1e3 : 1e3,
        faces: [
          {
            fill: color12(frame.front.color).brighten(0.1).get(),
            vertexes: [{
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xp,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }],
            enabled: frame.front.visible && !frame.bottom.visible
          },
          {
            fill: color12(frame.front.color).brighten(0.1).get(),
            vertexes: [{
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: ym,
              z: zm
            }],
            enabled: frame.front.visible && !frame.top.visible
          },
          {
            fill: color12(frame.front.color).brighten(-0.1).get(),
            vertexes: [{
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }],
            enabled: frame.front.visible && !frame.left.visible
          },
          {
            fill: color12(frame.front.color).brighten(-0.1).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }, {
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }],
            enabled: frame.front.visible && !frame.right.visible
          },
          {
            fill: color12(frame.front.color).get(),
            vertexes: [{
              x: xp,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: ym,
              z: zm
            }, {
              x: xm,
              y: yp,
              z: zm
            }, {
              x: xp,
              y: yp,
              z: zm
            }],
            enabled: frame.front.visible
          },
          {
            fill: color12(frame.front.color).get(),
            vertexes: [{
              x: xpp,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ypp,
              z: zmm
            }, {
              x: xmm,
              y: ymm,
              z: zmm
            }, {
              x: xpp,
              y: ymm,
              z: zmm
            }],
            enabled: frame.front.visible
          }
        ]
      });
    }
  }
  function onAfterGetContainer() {
    if (this.styledMode) {
      this.renderer.definition({
        tagName: "style",
        textContent: ".highcharts-3d-top{filter: url(#highcharts-brighter)}\n.highcharts-3d-side{filter: url(#highcharts-darker)}\n"
      });
      [{
        name: "darker",
        slope: 0.6
      }, {
        name: "brighter",
        slope: 1.4
      }].forEach(function(cfg) {
        this.renderer.definition({
          tagName: "filter",
          attributes: {
            id: "highcharts-" + cfg.name
          },
          children: [{
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncR",
              attributes: {
                type: "linear",
                slope: cfg.slope
              }
            }, {
              tagName: "feFuncG",
              attributes: {
                type: "linear",
                slope: cfg.slope
              }
            }, {
              tagName: "feFuncB",
              attributes: {
                type: "linear",
                slope: cfg.slope
              }
            }]
          }]
        });
      }, this);
    }
  }
  function onAfterInit() {
    var options = this.options;
    if (this.is3d()) {
      (options.series || []).forEach(function(s) {
        var type = s.type || options.chart.type || options.chart.defaultSeriesType;
        if (type === "scatter") {
          s.type = "scatter3d";
        }
      });
    }
  }
  function onAfterSetChartSize() {
    var chart = this, options3d = chart.options.chart.options3d;
    if (chart.chart3d && chart.is3d()) {
      if (options3d) {
        options3d.alpha = options3d.alpha % 360 + (options3d.alpha >= 0 ? 0 : 360);
        options3d.beta = options3d.beta % 360 + (options3d.beta >= 0 ? 0 : 360);
      }
      var inverted = chart.inverted, clipBox = chart.clipBox, margin = chart.margin, x = inverted ? "y" : "x", y = inverted ? "x" : "y", w2 = inverted ? "height" : "width", h = inverted ? "width" : "height";
      clipBox[x] = -(margin[3] || 0);
      clipBox[y] = -(margin[0] || 0);
      clipBox[w2] = chart.chartWidth + (margin[3] || 0) + (margin[1] || 0);
      clipBox[h] = chart.chartHeight + (margin[0] || 0) + (margin[2] || 0);
      chart.scale3d = 1;
      if (options3d.fitToPlot === true) {
        chart.scale3d = chart.chart3d.getScale(options3d.depth);
      }
      chart.chart3d.frame3d = chart.chart3d.get3dFrame();
    }
  }
  function onBeforeRedraw() {
    if (this.is3d()) {
      this.isDirtyBox = true;
    }
  }
  function onBeforeRender() {
    if (this.chart3d && this.is3d()) {
      this.chart3d.frame3d = this.chart3d.get3dFrame();
    }
  }
  function onInit() {
    if (!this.chart3d) {
      this.chart3d = new Composition(this);
    }
  }
  function wrapIsInsidePlot(proceed) {
    return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1));
  }
  function wrapRenderSeries(proceed) {
    var series, i = this.series.length;
    if (this.is3d()) {
      while (i--) {
        series = this.series[i];
        series.translate();
        series.render();
      }
    } else {
      proceed.call(this);
    }
  }
  function wrapSetClassName(proceed) {
    proceed.apply(this, [].slice.call(arguments, 1));
    if (this.is3d()) {
      this.container.className += " highcharts-3d-chart";
    }
  }
})(Chart3D || (Chart3D = {}));
var Chart3D_default = Chart3D;

// node_modules/highcharts/es-modules/Core/Axis/ZAxis.js
var __extends38 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var addEvent51 = Utilities_default.addEvent;
var merge68 = Utilities_default.merge;
var pick77 = Utilities_default.pick;
var splat18 = Utilities_default.splat;
var ZChart = (
  /** @class */
  function() {
    function ZChart2() {
    }
    ZChart2.compose = function(ChartClass) {
      addEvent51(ChartClass, "afterGetAxes", ZChart2.onAfterGetAxes);
      var chartProto2 = ChartClass.prototype;
      chartProto2.addZAxis = ZChart2.wrapAddZAxis;
      chartProto2.collectionsWithInit.zAxis = [chartProto2.addZAxis];
      chartProto2.collectionsWithUpdate.push("zAxis");
    };
    ZChart2.onAfterGetAxes = function() {
      var chart = this;
      var options = this.options;
      var zAxisOptions = options.zAxis = splat18(options.zAxis || {});
      if (!chart.is3d()) {
        return;
      }
      chart.zAxis = [];
      zAxisOptions.forEach(function(axisOptions, i) {
        axisOptions.index = i;
        axisOptions.isX = true;
        chart.addZAxis(axisOptions).setScale();
      });
    };
    ZChart2.wrapAddZAxis = function(options) {
      return new ZAxis(this, options);
    };
    return ZChart2;
  }()
);
var ZAxis = (
  /** @class */
  function(_super) {
    __extends38(ZAxis2, _super);
    function ZAxis2(chart, userOptions) {
      var _this = _super.call(this, chart, userOptions) || this;
      _this.isZAxis = true;
      return _this;
    }
    ZAxis2.prototype.getSeriesExtremes = function() {
      var axis = this;
      var chart = axis.chart;
      axis.hasVisibleSeries = false;
      axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = void 0;
      if (axis.stacking) {
        axis.stacking.buildStacks();
      }
      axis.series.forEach(function(series) {
        if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
          var seriesOptions = series.options, zData = void 0, threshold = seriesOptions.threshold;
          axis.hasVisibleSeries = true;
          if (axis.positiveValuesOnly && threshold <= 0) {
            threshold = void 0;
          }
          zData = series.zData;
          if (zData.length) {
            axis.dataMin = Math.min(pick77(axis.dataMin, zData[0]), Math.min.apply(null, zData));
            axis.dataMax = Math.max(pick77(axis.dataMax, zData[0]), Math.max.apply(null, zData));
          }
        }
      });
    };
    ZAxis2.prototype.setAxisSize = function() {
      var axis = this;
      var chart = axis.chart;
      _super.prototype.setAxisSize.call(this);
      axis.width = axis.len = chart.options.chart.options3d && chart.options.chart.options3d.depth || 0;
      axis.right = chart.chartWidth - axis.width - axis.left;
    };
    ZAxis2.prototype.setOptions = function(userOptions) {
      userOptions = merge68({
        offset: 0,
        lineWidth: 0
      }, userOptions);
      this.isZAxis = true;
      _super.prototype.setOptions.call(this, userOptions);
      this.coll = "zAxis";
    };
    ZAxis2.ZChartComposition = ZChart;
    return ZAxis2;
  }(Axis_default)
);
var ZAxis_default = ZAxis;

// node_modules/highcharts/es-modules/Core/Axis/Tick3D.js
var addEvent52 = Utilities_default.addEvent;
var extend68 = Utilities_default.extend;
var wrap10 = Utilities_default.wrap;
var Tick3D = (
  /** @class */
  function() {
    function Tick3D2() {
    }
    Tick3D2.compose = function(TickClass) {
      addEvent52(TickClass, "afterGetLabelPosition", Tick3D2.onAfterGetLabelPosition);
      var tickProto = TickClass.prototype;
      wrap10(tickProto, "getMarkPath", Tick3D2.wrapGetMarkPath);
    };
    Tick3D2.onAfterGetLabelPosition = function(e2) {
      var axis3D = this.axis.axis3D;
      if (axis3D) {
        extend68(e2.pos, axis3D.fix3dPosition(e2.pos));
      }
    };
    Tick3D2.wrapGetMarkPath = function(proceed) {
      var chart = this.axis.chart;
      var axis3D = this.axis.axis3D;
      var path = proceed.apply(this, [].slice.call(arguments, 1));
      if (axis3D) {
        var start = path[0];
        var end = path[1];
        if (start[0] === "M" && end[0] === "L") {
          var pArr = [
            axis3D.fix3dPosition({ x: start[1], y: start[2], z: 0 }),
            axis3D.fix3dPosition({ x: end[1], y: end[2], z: 0 })
          ];
          return this.axis.chart.renderer.toLineSegments(pArr);
        }
      }
      return path;
    };
    return Tick3D2;
  }()
);
var Tick3D_default = Tick3D;

// node_modules/highcharts/es-modules/Core/Axis/Axis3D.js
var deg2rad8 = Globals_default.deg2rad;
var perspective4 = Math3D_default.perspective;
var perspective3D2 = Math3D_default.perspective3D;
var shapeArea3 = Math3D_default.shapeArea;
var addEvent53 = Utilities_default.addEvent;
var merge69 = Utilities_default.merge;
var pick78 = Utilities_default.pick;
var wrap11 = Utilities_default.wrap;
var Axis3DAdditions = (
  /** @class */
  function() {
    function Axis3DAdditions2(axis) {
      this.axis = axis;
    }
    Axis3DAdditions2.prototype.fix3dPosition = function(pos, isTitle) {
      var axis3D = this;
      var axis = axis3D.axis;
      var chart = axis.chart;
      if (axis.coll === "colorAxis" || !chart.chart3d || !chart.is3d()) {
        return pos;
      }
      var alpha = deg2rad8 * chart.options.chart.options3d.alpha, beta = deg2rad8 * chart.options.chart.options3d.beta, positionMode = pick78(isTitle && axis.options.title.position3d, axis.options.labels.position3d), skew = pick78(isTitle && axis.options.title.skew3d, axis.options.labels.skew3d), frame = chart.chart3d.frame3d, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop;
      var offsetX = 0, offsetY = 0, vecX, vecY = { x: 0, y: 1, z: 0 }, reverseFlap = false;
      pos = axis.axis3D.swapZ({ x: pos.x, y: pos.y, z: 0 });
      if (axis.isZAxis) {
        if (axis.opposite) {
          if (frame.axes.z.top === null) {
            return {};
          }
          offsetY = pos.y - plotTop;
          pos.x = frame.axes.z.top.x;
          pos.y = frame.axes.z.top.y;
          vecX = frame.axes.z.top.xDir;
          reverseFlap = !frame.top.frontFacing;
        } else {
          if (frame.axes.z.bottom === null) {
            return {};
          }
          offsetY = pos.y - plotBottom;
          pos.x = frame.axes.z.bottom.x;
          pos.y = frame.axes.z.bottom.y;
          vecX = frame.axes.z.bottom.xDir;
          reverseFlap = !frame.bottom.frontFacing;
        }
      } else if (axis.horiz) {
        if (axis.opposite) {
          if (frame.axes.x.top === null) {
            return {};
          }
          offsetY = pos.y - plotTop;
          pos.y = frame.axes.x.top.y;
          pos.z = frame.axes.x.top.z;
          vecX = frame.axes.x.top.xDir;
          reverseFlap = !frame.top.frontFacing;
        } else {
          if (frame.axes.x.bottom === null) {
            return {};
          }
          offsetY = pos.y - plotBottom;
          pos.y = frame.axes.x.bottom.y;
          pos.z = frame.axes.x.bottom.z;
          vecX = frame.axes.x.bottom.xDir;
          reverseFlap = !frame.bottom.frontFacing;
        }
      } else {
        if (axis.opposite) {
          if (frame.axes.y.right === null) {
            return {};
          }
          offsetX = pos.x - plotRight;
          pos.x = frame.axes.y.right.x;
          pos.z = frame.axes.y.right.z;
          vecX = frame.axes.y.right.xDir;
          vecX = { x: vecX.z, y: vecX.y, z: -vecX.x };
        } else {
          if (frame.axes.y.left === null) {
            return {};
          }
          offsetX = pos.x - plotLeft;
          pos.x = frame.axes.y.left.x;
          pos.z = frame.axes.y.left.z;
          vecX = frame.axes.y.left.xDir;
        }
      }
      if (positionMode === "chart") {
      } else if (positionMode === "flap") {
        if (!axis.horiz) {
          vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
        } else {
          var sin2 = Math.sin(alpha);
          var cos2 = Math.cos(alpha);
          if (axis.opposite) {
            sin2 = -sin2;
          }
          if (reverseFlap) {
            sin2 = -sin2;
          }
          vecY = { x: vecX.z * sin2, y: cos2, z: -vecX.x * sin2 };
        }
      } else if (positionMode === "ortho") {
        if (!axis.horiz) {
          vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
        } else {
          var sina = Math.sin(alpha);
          var cosa = Math.cos(alpha);
          var sinb = Math.sin(beta);
          var cosb = Math.cos(beta);
          var vecZ = { x: sinb * cosa, y: -sina, z: -cosa * cosb };
          vecY = {
            x: vecX.y * vecZ.z - vecX.z * vecZ.y,
            y: vecX.z * vecZ.x - vecX.x * vecZ.z,
            z: vecX.x * vecZ.y - vecX.y * vecZ.x
          };
          var scale = 1 / Math.sqrt(vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z);
          if (reverseFlap) {
            scale = -scale;
          }
          vecY = { x: scale * vecY.x, y: scale * vecY.y, z: scale * vecY.z };
        }
      } else {
        if (!axis.horiz) {
          vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };
        } else {
          vecY = {
            x: Math.sin(beta) * Math.sin(alpha),
            y: Math.cos(alpha),
            z: -Math.cos(beta) * Math.sin(alpha)
          };
        }
      }
      pos.x += offsetX * vecX.x + offsetY * vecY.x;
      pos.y += offsetX * vecX.y + offsetY * vecY.y;
      pos.z += offsetX * vecX.z + offsetY * vecY.z;
      var projected = perspective4([pos], axis.chart)[0];
      if (skew) {
        var isMirrored = shapeArea3(perspective4([
          pos,
          { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },
          { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }
        ], axis.chart)) < 0;
        if (isMirrored) {
          vecX = { x: -vecX.x, y: -vecX.y, z: -vecX.z };
        }
        var pointsProjected = perspective4([
          { x: pos.x, y: pos.y, z: pos.z },
          { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },
          { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }
        ], axis.chart);
        projected.matrix = [
          pointsProjected[1].x - pointsProjected[0].x,
          pointsProjected[1].y - pointsProjected[0].y,
          pointsProjected[2].x - pointsProjected[0].x,
          pointsProjected[2].y - pointsProjected[0].y,
          projected.x,
          projected.y
        ];
        projected.matrix[4] -= projected.x * projected.matrix[0] + projected.y * projected.matrix[2];
        projected.matrix[5] -= projected.x * projected.matrix[1] + projected.y * projected.matrix[3];
      }
      return projected;
    };
    Axis3DAdditions2.prototype.swapZ = function(p, insidePlotArea) {
      var axis = this.axis;
      if (axis.isZAxis) {
        var plotLeft = insidePlotArea ? 0 : axis.chart.plotLeft;
        return {
          x: plotLeft + p.z,
          y: p.y,
          z: p.x - plotLeft
        };
      }
      return p;
    };
    return Axis3DAdditions2;
  }()
);
var Axis3D = (
  /** @class */
  function() {
    function Axis3D2() {
    }
    Axis3D2.compose = function(AxisClass) {
      merge69(true, AxisClass.defaultOptions, Axis3D2.defaultOptions);
      AxisClass.keepProps.push("axis3D");
      addEvent53(AxisClass, "init", Axis3D2.onInit);
      addEvent53(AxisClass, "afterSetOptions", Axis3D2.onAfterSetOptions);
      addEvent53(AxisClass, "drawCrosshair", Axis3D2.onDrawCrosshair);
      var axisProto = AxisClass.prototype;
      wrap11(axisProto, "getLinePath", Axis3D2.wrapGetLinePath);
      wrap11(axisProto, "getPlotBandPath", Axis3D2.wrapGetPlotBandPath);
      wrap11(axisProto, "getPlotLinePath", Axis3D2.wrapGetPlotLinePath);
      wrap11(axisProto, "getSlotWidth", Axis3D2.wrapGetSlotWidth);
      wrap11(axisProto, "getTitlePosition", Axis3D2.wrapGetTitlePosition);
      Tick3D_default.compose(Tick_default);
    };
    Axis3D2.onAfterSetOptions = function() {
      var axis = this;
      var chart = axis.chart;
      var options = axis.options;
      if (chart.is3d && chart.is3d() && axis.coll !== "colorAxis") {
        options.tickWidth = pick78(options.tickWidth, 0);
        options.gridLineWidth = pick78(options.gridLineWidth, 1);
      }
    };
    Axis3D2.onDrawCrosshair = function(e2) {
      var axis = this;
      if (axis.chart.is3d() && axis.coll !== "colorAxis") {
        if (e2.point) {
          e2.point.crosshairPos = axis.isXAxis ? e2.point.axisXpos : axis.len - e2.point.axisYpos;
        }
      }
    };
    Axis3D2.onInit = function() {
      var axis = this;
      if (!axis.axis3D) {
        axis.axis3D = new Axis3DAdditions(axis);
      }
    };
    Axis3D2.wrapGetLinePath = function(proceed) {
      var axis = this;
      if (!axis.chart.is3d() || axis.coll === "colorAxis") {
        return proceed.apply(axis, [].slice.call(arguments, 1));
      }
      return [];
    };
    Axis3D2.wrapGetPlotBandPath = function(proceed) {
      if (!this.chart.is3d() || this.coll === "colorAxis") {
        return proceed.apply(this, [].slice.call(arguments, 1));
      }
      var args = arguments, from = args[1], to = args[2], path = [], fromPath = this.getPlotLinePath({ value: from }), toPath = this.getPlotLinePath({ value: to });
      if (fromPath && toPath) {
        for (var i = 0; i < fromPath.length; i += 2) {
          var fromStartSeg = fromPath[i], fromEndSeg = fromPath[i + 1], toStartSeg = toPath[i], toEndSeg = toPath[i + 1];
          if (fromStartSeg[0] === "M" && fromEndSeg[0] === "L" && toStartSeg[0] === "M" && toEndSeg[0] === "L") {
            path.push(
              fromStartSeg,
              fromEndSeg,
              toEndSeg,
              // lineTo instead of moveTo
              ["L", toStartSeg[1], toStartSeg[2]],
              ["Z"]
            );
          }
        }
      }
      return path;
    };
    Axis3D2.wrapGetPlotLinePath = function(proceed) {
      var axis = this, axis3D = axis.axis3D, chart = axis.chart, path = proceed.apply(axis, [].slice.call(arguments, 1));
      if (axis.coll === "colorAxis" || !chart.chart3d || !chart.is3d()) {
        return path;
      }
      if (path === null) {
        return path;
      }
      var options3d = chart.options.chart.options3d, d = axis.isZAxis ? chart.plotWidth : options3d.depth, frame = chart.chart3d.frame3d, startSegment = path[0], endSegment = path[1];
      var pArr, pathSegments = [];
      if (startSegment[0] === "M" && endSegment[0] === "L") {
        pArr = [
          axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: 0 }),
          axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: d }),
          axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: 0 }),
          axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: d })
        ];
        if (!this.horiz) {
          if (frame.front.visible) {
            pathSegments.push(pArr[0], pArr[2]);
          }
          if (frame.back.visible) {
            pathSegments.push(pArr[1], pArr[3]);
          }
          if (frame.left.visible) {
            pathSegments.push(pArr[0], pArr[1]);
          }
          if (frame.right.visible) {
            pathSegments.push(pArr[2], pArr[3]);
          }
        } else if (this.isZAxis) {
          if (frame.left.visible) {
            pathSegments.push(pArr[0], pArr[2]);
          }
          if (frame.right.visible) {
            pathSegments.push(pArr[1], pArr[3]);
          }
          if (frame.top.visible) {
            pathSegments.push(pArr[0], pArr[1]);
          }
          if (frame.bottom.visible) {
            pathSegments.push(pArr[2], pArr[3]);
          }
        } else {
          if (frame.front.visible) {
            pathSegments.push(pArr[0], pArr[2]);
          }
          if (frame.back.visible) {
            pathSegments.push(pArr[1], pArr[3]);
          }
          if (frame.top.visible) {
            pathSegments.push(pArr[0], pArr[1]);
          }
          if (frame.bottom.visible) {
            pathSegments.push(pArr[2], pArr[3]);
          }
        }
        pathSegments = perspective4(pathSegments, this.chart, false);
      }
      return chart.renderer.toLineSegments(pathSegments);
    };
    Axis3D2.wrapGetSlotWidth = function(proceed, tick) {
      var axis = this, chart = axis.chart, ticks = axis.ticks, gridGroup = axis.gridGroup;
      if (axis.categories && chart.frameShapes && chart.is3d() && gridGroup && tick && tick.label) {
        var firstGridLine = gridGroup.element.childNodes[0].getBBox(), frame3DLeft = chart.frameShapes.left.getBBox(), options3d = chart.options.chart.options3d, origin_1 = {
          x: chart.plotWidth / 2,
          y: chart.plotHeight / 2,
          z: options3d.depth / 2,
          vd: pick78(options3d.depth, 1) * pick78(options3d.viewDistance, 0)
        }, tickId = tick.pos, prevTick = ticks[tickId - 1], nextTick = ticks[tickId + 1];
        var labelPos = void 0, prevLabelPos = void 0, nextLabelPos = void 0;
        if (tickId !== 0 && prevTick && prevTick.label && prevTick.label.xy) {
          prevLabelPos = perspective3D2({
            x: prevTick.label.xy.x,
            y: prevTick.label.xy.y,
            z: null
          }, origin_1, origin_1.vd);
        }
        if (nextTick && nextTick.label && nextTick.label.xy) {
          nextLabelPos = perspective3D2({
            x: nextTick.label.xy.x,
            y: nextTick.label.xy.y,
            z: null
          }, origin_1, origin_1.vd);
        }
        labelPos = {
          x: tick.label.xy.x,
          y: tick.label.xy.y,
          z: null
        };
        labelPos = perspective3D2(labelPos, origin_1, origin_1.vd);
        return Math.abs(prevLabelPos ? labelPos.x - prevLabelPos.x : nextLabelPos ? nextLabelPos.x - labelPos.x : firstGridLine.x - frame3DLeft.x);
      }
      return proceed.apply(axis, [].slice.call(arguments, 1));
    };
    Axis3D2.wrapGetTitlePosition = function(proceed) {
      var pos = proceed.apply(this, [].slice.call(arguments, 1));
      return this.axis3D ? this.axis3D.fix3dPosition(pos, true) : pos;
    };
    Axis3D2.defaultOptions = {
      labels: {
        /**
         * Defines how the labels are be repositioned according to the 3D
         * chart orientation.
         *
         * - `'offset'`: Maintain a fixed horizontal/vertical distance from
         *   the tick marks, despite the chart orientation. This is the
         *   backwards compatible behavior, and causes skewing of X and Z
         *   axes.
         *
         * - `'chart'`: Preserve 3D position relative to the chart. This
         *   looks nice, but hard to read if the text isn't forward-facing.
         *
         * - `'flap'`: Rotated text along the axis to compensate for the
         *   chart orientation. This tries to maintain text as legible as
         *   possible on all orientations.
         *
         * - `'ortho'`: Rotated text along the axis direction so that the
         *   labels are orthogonal to the axis. This is very similar to
         *   `'flap'`, but prevents skewing the labels (X and Y scaling are
         *   still present).
         *
         * @sample highcharts/3d/skewed-labels/
         *         Skewed labels
         *
         * @since      5.0.15
         * @validvalue ['offset', 'chart', 'flap', 'ortho']
         * @product    highcharts
         * @requires   highcharts-3d
         */
        position3d: "offset",
        /**
         * If enabled, the axis labels will skewed to follow the
         * perspective.
         *
         * This will fix overlapping labels and titles, but texts become
         * less legible due to the distortion.
         *
         * The final appearance depends heavily on `labels.position3d`.
         *
         * @sample highcharts/3d/skewed-labels/
         *         Skewed labels
         *
         * @since    5.0.15
         * @product  highcharts
         * @requires highcharts-3d
         */
        skew3d: false
      },
      title: {
        /**
         * Defines how the title is repositioned according to the 3D chart
         * orientation.
         *
         * - `'offset'`: Maintain a fixed horizontal/vertical distance from
         *   the tick marks, despite the chart orientation. This is the
         *   backwards compatible behavior, and causes skewing of X and Z
         *   axes.
         *
         * - `'chart'`: Preserve 3D position relative to the chart. This
         *   looks nice, but hard to read if the text isn't forward-facing.
         *
         * - `'flap'`: Rotated text along the axis to compensate for the
         *   chart orientation. This tries to maintain text as legible as
         *   possible on all orientations.
         *
         * - `'ortho'`: Rotated text along the axis direction so that the
         *   labels are orthogonal to the axis. This is very similar to
         *   `'flap'`, but prevents skewing the labels (X and Y scaling are
         *   still present).
         *
         * - `undefined`: Will use the config from `labels.position3d`
         *
         * @sample highcharts/3d/skewed-labels/
         *         Skewed labels
         *
         * @type     {"offset"|"chart"|"flap"|"ortho"|null}
         * @since    5.0.15
         * @product  highcharts
         * @requires highcharts-3d
         */
        position3d: null,
        /**
         * If enabled, the axis title will skewed to follow the perspective.
         *
         * This will fix overlapping labels and titles, but texts become
         * less legible due to the distortion.
         *
         * The final appearance depends heavily on `title.position3d`.
         *
         * A `null` value will use the config from `labels.skew3d`.
         *
         * @sample highcharts/3d/skewed-labels/
         *         Skewed labels
         *
         * @type     {boolean|null}
         * @since    5.0.15
         * @product  highcharts
         * @requires highcharts-3d
         */
        skew3d: null
      }
    };
    return Axis3D2;
  }()
);
var Axis3D_default = Axis3D;

// node_modules/highcharts/es-modules/Core/Series/Series3D.js
var __extends39 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var perspective5 = Math3D_default.perspective;
var addEvent54 = Utilities_default.addEvent;
var extend69 = Utilities_default.extend;
var merge70 = Utilities_default.merge;
var pick79 = Utilities_default.pick;
var isNumber45 = Utilities_default.isNumber;
var Series3D = (
  /** @class */
  function(_super) {
    __extends39(Series3D2, _super);
    function Series3D2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Series3D2.prototype.translate = function() {
      _super.prototype.translate.apply(this, arguments);
      if (this.chart.is3d()) {
        this.translate3dPoints();
      }
    };
    Series3D2.prototype.translate3dPoints = function() {
      var series = this, seriesOptions = series.options, chart = series.chart, zAxis = pick79(series.zAxis, chart.options.zAxis[0]), rawPoints = [], rawPoint, projectedPoints, projectedPoint, zValue, i, rawPointsX = [], stack = seriesOptions.stacking ? isNumber45(seriesOptions.stack) ? seriesOptions.stack : 0 : series.index || 0;
      series.zPadding = stack * (seriesOptions.depth || 0 + (seriesOptions.groupZPadding || 1));
      for (i = 0; i < series.data.length; i++) {
        rawPoint = series.data[i];
        if (zAxis && zAxis.translate) {
          zValue = zAxis.logarithmic && zAxis.val2lin ? zAxis.val2lin(rawPoint.z) : rawPoint.z;
          rawPoint.plotZ = zAxis.translate(zValue);
          rawPoint.isInside = rawPoint.isInside ? zValue >= zAxis.min && zValue <= zAxis.max : false;
        } else {
          rawPoint.plotZ = series.zPadding;
        }
        rawPoint.axisXpos = rawPoint.plotX;
        rawPoint.axisYpos = rawPoint.plotY;
        rawPoint.axisZpos = rawPoint.plotZ;
        rawPoints.push({
          x: rawPoint.plotX,
          y: rawPoint.plotY,
          z: rawPoint.plotZ
        });
        rawPointsX.push(rawPoint.plotX || 0);
      }
      series.rawPointsX = rawPointsX;
      projectedPoints = perspective5(rawPoints, chart, true);
      for (i = 0; i < series.data.length; i++) {
        rawPoint = series.data[i];
        projectedPoint = projectedPoints[i];
        rawPoint.plotX = projectedPoint.x;
        rawPoint.plotY = projectedPoint.y;
        rawPoint.plotZ = projectedPoint.z;
      }
    };
    Series3D2.defaultOptions = merge70(Series_default.defaultOptions);
    return Series3D2;
  }(Series_default)
);
addEvent54(Series_default, "afterTranslate", function() {
  if (this.chart.is3d()) {
    this.translate3dPoints();
  }
});
extend69(Series_default.prototype, {
  translate3dPoints: Series3D.prototype.translate3dPoints
});

// node_modules/highcharts/es-modules/Series/Column3D/Column3DComposition.js
var columnProto5 = ColumnSeries_default.prototype;
var svg5 = Globals_default.svg;
var perspective6 = Math3D_default.perspective;
var addEvent55 = Utilities_default.addEvent;
var pick80 = Utilities_default.pick;
var wrap12 = Utilities_default.wrap;
function retrieveStacks(chart, stacking) {
  var series = chart.series, stacks = { totalStacks: 0 };
  var stackNumber, i = 1;
  series.forEach(function(s) {
    stackNumber = pick80(s.options.stack, stacking ? 0 : series.length - 1 - s.index);
    if (!stacks[stackNumber]) {
      stacks[stackNumber] = { series: [s], position: i };
      i++;
    } else {
      stacks[stackNumber].series.push(s);
    }
  });
  stacks.totalStacks = i + 1;
  return stacks;
}
wrap12(columnProto5, "translate", function(proceed) {
  proceed.apply(this, [].slice.call(arguments, 1));
  if (this.chart.is3d()) {
    this.translate3dShapes();
  }
});
wrap12(Series_default.prototype, "justifyDataLabel", function(proceed) {
  return !arguments[2].outside3dPlot ? proceed.apply(this, [].slice.call(arguments, 1)) : false;
});
columnProto5.translate3dPoints = function() {
};
columnProto5.translate3dShapes = function() {
  var series = this, chart = series.chart, seriesOptions = series.options, depth = seriesOptions.depth, stack = seriesOptions.stacking ? seriesOptions.stack || 0 : series.index, z = stack * (depth + (seriesOptions.groupZPadding || 1)), borderCrisp = series.borderWidth % 2 ? 0.5 : 0, point2dPos;
  if (chart.inverted && !series.yAxis.reversed) {
    borderCrisp *= -1;
  }
  if (seriesOptions.grouping !== false) {
    z = 0;
  }
  z += seriesOptions.groupZPadding || 1;
  series.data.forEach(function(point) {
    point.outside3dPlot = null;
    if (point.y !== null) {
      var shapeArgs_1 = point.shapeArgs, tooltipPos = point.tooltipPos, dimensions = [["x", "width"], ["y", "height"]], borderlessBase_1;
      dimensions.forEach(function(d) {
        borderlessBase_1 = shapeArgs_1[d[0]] - borderCrisp;
        if (borderlessBase_1 < 0) {
          shapeArgs_1[d[1]] += shapeArgs_1[d[0]] + borderCrisp;
          shapeArgs_1[d[0]] = -borderCrisp;
          borderlessBase_1 = 0;
        }
        if (borderlessBase_1 + shapeArgs_1[d[1]] > series[d[0] + "Axis"].len && // Do not change height/width of column if 0 (#6708)
        shapeArgs_1[d[1]] !== 0) {
          shapeArgs_1[d[1]] = series[d[0] + "Axis"].len - shapeArgs_1[d[0]];
        }
        if (
          // Do not remove columns with zero height/width.
          shapeArgs_1[d[1]] !== 0 && (shapeArgs_1[d[0]] >= series[d[0] + "Axis"].len || shapeArgs_1[d[0]] + shapeArgs_1[d[1]] <= borderCrisp)
        ) {
          for (var key in shapeArgs_1) {
            shapeArgs_1[key] = key === "y" ? -9999 : 0;
          }
          point.outside3dPlot = true;
        }
      });
      if (point.shapeType === "rect") {
        point.shapeType = "cuboid";
      }
      shapeArgs_1.z = z;
      shapeArgs_1.depth = depth;
      shapeArgs_1.insidePlotArea = true;
      point2dPos = {
        x: shapeArgs_1.x + shapeArgs_1.width / 2,
        y: shapeArgs_1.y,
        z: z + depth / 2
        // The center of column in Z dimension
      };
      if (chart.inverted) {
        point2dPos.x = shapeArgs_1.height;
        point2dPos.y = point.clientX;
      }
      point.plot3d = perspective6([point2dPos], chart, true, false)[0];
      tooltipPos = perspective6([{
        x: tooltipPos[0],
        y: tooltipPos[1],
        z: z + depth / 2
        // The center of column in Z dimension
      }], chart, true, false)[0];
      point.tooltipPos = [tooltipPos.x, tooltipPos.y];
    }
  });
  series.z = z;
};
wrap12(columnProto5, "animate", function(proceed) {
  if (!this.chart.is3d()) {
    proceed.apply(this, [].slice.call(arguments, 1));
  } else {
    var args = arguments, init = args[1], yAxis_1 = this.yAxis, series_1 = this, reversed_1 = this.yAxis.reversed;
    if (svg5) {
      if (init) {
        series_1.data.forEach(function(point) {
          if (point.y !== null) {
            point.height = point.shapeArgs.height;
            point.shapey = point.shapeArgs.y;
            point.shapeArgs.height = 1;
            if (!reversed_1) {
              if (point.stackY) {
                point.shapeArgs.y = point.plotY + yAxis_1.translate(point.stackY);
              } else {
                point.shapeArgs.y = point.plotY + (point.negative ? -point.height : point.height);
              }
            }
          }
        });
      } else {
        series_1.data.forEach(function(point) {
          if (point.y !== null) {
            point.shapeArgs.height = point.height;
            point.shapeArgs.y = point.shapey;
            if (point.graphic) {
              point.graphic[point.outside3dPlot ? "attr" : "animate"](point.shapeArgs, series_1.options.animation);
            }
          }
        });
        this.drawDataLabels();
      }
    }
  }
});
wrap12(columnProto5, "plotGroup", function(proceed, prop, _name, _visibility, _zIndex, parent) {
  if (prop !== "dataLabelsGroup") {
    if (this.chart.is3d()) {
      if (this[prop]) {
        delete this[prop];
      }
      if (parent) {
        if (!this.chart.columnGroup) {
          this.chart.columnGroup = this.chart.renderer.g("columnGroup").add(parent);
        }
        this[prop] = this.chart.columnGroup;
        this.chart.columnGroup.attr(this.getPlotBox());
        this[prop].survive = true;
        if (prop === "group" || prop === "markerGroup") {
          arguments[3] = "visible";
        }
      }
    }
  }
  return proceed.apply(this, Array.prototype.slice.call(arguments, 1));
});
wrap12(columnProto5, "setVisible", function(proceed, vis) {
  var series = this;
  if (series.chart.is3d()) {
    series.data.forEach(function(point) {
      point.visible = point.options.visible = vis = typeof vis === "undefined" ? !pick80(series.visible, point.visible) : vis;
      series.options.data[series.data.indexOf(point)] = point.options;
      if (point.graphic) {
        point.graphic.attr({
          visibility: vis ? "visible" : "hidden"
        });
      }
    });
  }
  proceed.apply(this, Array.prototype.slice.call(arguments, 1));
});
addEvent55(ColumnSeries_default, "afterInit", function() {
  if (this.chart.is3d()) {
    var series = this, seriesOptions = this.options, grouping = seriesOptions.grouping, stacking = seriesOptions.stacking, reversedStacks = this.yAxis.options.reversedStacks, z = 0;
    if (!(typeof grouping !== "undefined" && !grouping)) {
      var stacks = retrieveStacks(this.chart, stacking), stack = seriesOptions.stack || 0, i = (
        // position within the stack
        void 0
      );
      for (i = 0; i < stacks[stack].series.length; i++) {
        if (stacks[stack].series[i] === this) {
          break;
        }
      }
      z = 10 * (stacks.totalStacks - stacks[stack].position) + (reversedStacks ? i : -i);
      if (!this.xAxis.reversed) {
        z = stacks.totalStacks * 10 - z;
      }
    }
    seriesOptions.depth = seriesOptions.depth || 25;
    series.z = series.z || 0;
    seriesOptions.zIndex = z;
  }
});
function pointAttribs(proceed) {
  var attr11 = proceed.apply(this, [].slice.call(arguments, 1));
  if (this.chart.is3d && this.chart.is3d()) {
    attr11.stroke = this.options.edgeColor || attr11.fill;
    attr11["stroke-width"] = pick80(this.options.edgeWidth, 1);
  }
  return attr11;
}
function setState(proceed, state, inherit) {
  var is3d = this.chart.is3d && this.chart.is3d();
  if (is3d) {
    this.options.inactiveOtherPoints = true;
  }
  proceed.call(this, state, inherit);
  if (is3d) {
    this.options.inactiveOtherPoints = false;
  }
}
function hasNewShapeType(proceed) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return this.series.chart.is3d() ? this.graphic && this.graphic.element.nodeName !== "g" : proceed.apply(this, args);
}
wrap12(columnProto5, "pointAttribs", pointAttribs);
wrap12(columnProto5, "setState", setState);
wrap12(columnProto5.pointClass.prototype, "hasNewShapeType", hasNewShapeType);
if (SeriesRegistry_default.seriesTypes.columnRange) {
  columnRangeProto = SeriesRegistry_default.seriesTypes.columnrange.prototype;
  wrap12(columnRangeProto, "pointAttribs", pointAttribs);
  wrap12(columnRangeProto, "setState", setState);
  wrap12(columnRangeProto.pointClass.prototype, "hasNewShapeType", hasNewShapeType);
  columnRangeProto.plotGroup = columnProto5.plotGroup;
  columnRangeProto.setVisible = columnProto5.setVisible;
}
var columnRangeProto;
wrap12(Series_default.prototype, "alignDataLabel", function(proceed, point, dataLabel, options, alignTo) {
  var chart = this.chart;
  options.outside3dPlot = point.outside3dPlot;
  if (chart.is3d() && this.is("column")) {
    var series = this, seriesOptions = series.options, inside = pick80(options.inside, !!series.options.stacking), options3d = chart.options.chart.options3d, xOffset = point.pointWidth / 2 || 0;
    var dLPosition = {
      x: alignTo.x + xOffset,
      y: alignTo.y,
      z: series.z + seriesOptions.depth / 2
    };
    if (chart.inverted) {
      if (inside) {
        alignTo.width = 0;
        dLPosition.x += point.shapeArgs.height / 2;
      }
      if (options3d.alpha >= 90 && options3d.alpha <= 270) {
        dLPosition.y += point.shapeArgs.width;
      }
    }
    dLPosition = perspective6([dLPosition], chart, true, false)[0];
    alignTo.x = dLPosition.x - xOffset;
    alignTo.y = point.outside3dPlot ? -9e9 : dLPosition.y;
  }
  proceed.apply(this, [].slice.call(arguments, 1));
});
wrap12(Stacking_default.prototype, "getStackBox", function(proceed, chart, stackItem, x, y, xWidth, h, axis) {
  var stackBox = proceed.apply(this, [].slice.call(arguments, 1));
  if (chart.is3d() && stackItem.base) {
    var baseSeriesInd = +stackItem.base.split(",")[0];
    var columnSeries = chart.series[baseSeriesInd];
    var options3d = chart.options.chart.options3d;
    if (columnSeries && columnSeries instanceof SeriesRegistry_default.seriesTypes.column) {
      var dLPosition = {
        x: stackBox.x + (chart.inverted ? h : xWidth / 2),
        y: stackBox.y,
        z: columnSeries.options.depth / 2
      };
      if (chart.inverted) {
        stackBox.width = 0;
        if (options3d.alpha >= 90 && options3d.alpha <= 270) {
          dLPosition.y += xWidth;
        }
      }
      dLPosition = perspective6([dLPosition], chart, true, false)[0];
      stackBox.x = dLPosition.x - xWidth / 2;
      stackBox.y = dLPosition.y;
    }
  }
  return stackBox;
});

// node_modules/highcharts/es-modules/Series/Pie3D/Pie3DPoint.js
var __extends40 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PiePoint2 = SeriesRegistry_default.seriesTypes.pie.prototype.pointClass;
var superHaloPath = PiePoint2.prototype.haloPath;
var Pie3DPoint = (
  /** @class */
  function(_super) {
    __extends40(Pie3DPoint2, _super);
    function Pie3DPoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.series = void 0;
      return _this;
    }
    Pie3DPoint2.prototype.haloPath = function() {
      return this.series.chart.is3d() ? [] : superHaloPath.apply(this, arguments);
    };
    return Pie3DPoint2;
  }(PiePoint2)
);
var Pie3DPoint_default = Pie3DPoint;

// node_modules/highcharts/es-modules/Series/Pie3D/Pie3DSeries.js
var __extends41 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var deg2rad9 = Globals_default.deg2rad;
var svg6 = Globals_default.svg;
var PieSeries2 = SeriesRegistry_default.seriesTypes.pie;
var extend70 = Utilities_default.extend;
var pick81 = Utilities_default.pick;
var Pie3DSeries = (
  /** @class */
  function(_super) {
    __extends41(Pie3DSeries2, _super);
    function Pie3DSeries2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Pie3DSeries2.prototype.addPoint = function() {
      _super.prototype.addPoint.apply(this, arguments);
      if (this.chart.is3d()) {
        this.update(this.userOptions, true);
      }
    };
    Pie3DSeries2.prototype.animate = function(init) {
      if (!this.chart.is3d()) {
        _super.prototype.animate.apply(this, arguments);
      } else {
        var animation = this.options.animation, attribs = void 0, center = this.center, group = this.group, markerGroup = this.markerGroup;
        if (svg6) {
          if (animation === true) {
            animation = {};
          }
          if (init) {
            group.oldtranslateX = pick81(group.oldtranslateX, group.translateX);
            group.oldtranslateY = pick81(group.oldtranslateY, group.translateY);
            attribs = {
              translateX: center[0],
              translateY: center[1],
              scaleX: 1e-3,
              scaleY: 1e-3
            };
            group.attr(attribs);
            if (markerGroup) {
              markerGroup.attrSetters = group.attrSetters;
              markerGroup.attr(attribs);
            }
          } else {
            attribs = {
              translateX: group.oldtranslateX,
              translateY: group.oldtranslateY,
              scaleX: 1,
              scaleY: 1
            };
            group.animate(attribs, animation);
            if (markerGroup) {
              markerGroup.animate(attribs, animation);
            }
          }
        }
      }
    };
    Pie3DSeries2.prototype.drawDataLabels = function() {
      if (this.chart.is3d()) {
        var series = this, chart = series.chart, options3d_1 = chart.options.chart.options3d;
        series.data.forEach(function(point) {
          var shapeArgs = point.shapeArgs, r = shapeArgs.r, a1 = (shapeArgs.alpha || options3d_1.alpha) * deg2rad9, b1 = (shapeArgs.beta || options3d_1.beta) * deg2rad9, a2 = (shapeArgs.start + shapeArgs.end) / 2, labelPosition = point.labelPosition, connectorPosition = labelPosition.connectorPosition, yOffset = -r * (1 - Math.cos(a1)) * Math.sin(a2), xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2);
          [
            labelPosition.natural,
            connectorPosition.breakAt,
            connectorPosition.touchingSliceAt
          ].forEach(function(coordinates) {
            coordinates.x += xOffset;
            coordinates.y += yOffset;
          });
        });
      }
      _super.prototype.drawDataLabels.apply(this, arguments);
    };
    Pie3DSeries2.prototype.pointAttribs = function(point) {
      var attr11 = _super.prototype.pointAttribs.apply(this, arguments), options = this.options;
      if (this.chart.is3d() && !this.chart.styledMode) {
        attr11.stroke = options.edgeColor || point.color || this.color;
        attr11["stroke-width"] = pick81(options.edgeWidth, 1);
      }
      return attr11;
    };
    Pie3DSeries2.prototype.translate = function() {
      _super.prototype.translate.apply(this, arguments);
      if (!this.chart.is3d()) {
        return;
      }
      var series = this, seriesOptions = series.options, depth = seriesOptions.depth || 0, options3d = series.chart.options.chart.options3d, alpha = options3d.alpha, beta = options3d.beta, z = seriesOptions.stacking ? (seriesOptions.stack || 0) * depth : series._i * depth;
      z += depth / 2;
      if (seriesOptions.grouping !== false) {
        z = 0;
      }
      series.data.forEach(function(point) {
        var shapeArgs = point.shapeArgs, angle;
        point.shapeType = "arc3d";
        shapeArgs.z = z;
        shapeArgs.depth = depth * 0.75;
        shapeArgs.alpha = alpha;
        shapeArgs.beta = beta;
        shapeArgs.center = series.center;
        angle = (shapeArgs.end + shapeArgs.start) / 2;
        point.slicedTranslation = {
          translateX: Math.round(Math.cos(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad9)),
          translateY: Math.round(Math.sin(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad9))
        };
      });
    };
    return Pie3DSeries2;
  }(PieSeries2)
);
extend70(Pie3DSeries.prototype, {
  pointClass: Pie3DPoint_default
});
var Pie3DSeries_default = Pie3DSeries;

// node_modules/highcharts/es-modules/Series/Pie3D/Pie3DComposition.js
SeriesRegistry_default.seriesTypes.pie.prototype.pointClass.prototype.haloPath = Pie3DPoint_default.prototype.haloPath;
SeriesRegistry_default.seriesTypes.pie = Pie3DSeries_default;

// node_modules/highcharts/es-modules/Series/Scatter3D/Scatter3DPoint.js
var __extends42 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var defined50 = Utilities_default.defined;
var Scatter3DPoint = (
  /** @class */
  function(_super) {
    __extends42(Scatter3DPoint2, _super);
    function Scatter3DPoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.series = void 0;
      return _this;
    }
    Scatter3DPoint2.prototype.applyOptions = function() {
      _super.prototype.applyOptions.apply(this, arguments);
      if (!defined50(this.z)) {
        this.z = 0;
      }
      return this;
    };
    return Scatter3DPoint2;
  }(ScatterSeries_default.prototype.pointClass)
);
var Scatter3DPoint_default = Scatter3DPoint;

// node_modules/highcharts/es-modules/Series/Scatter3D/Scatter3DSeries.js
var __extends43 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var pointCameraDistance2 = Math3D_default.pointCameraDistance;
var extend71 = Utilities_default.extend;
var merge71 = Utilities_default.merge;
var Scatter3DSeries = (
  /** @class */
  function(_super) {
    __extends43(Scatter3DSeries2, _super);
    function Scatter3DSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    Scatter3DSeries2.prototype.pointAttribs = function(point) {
      var attribs = _super.prototype.pointAttribs.apply(this, arguments);
      if (this.chart.is3d() && point) {
        attribs.zIndex = pointCameraDistance2(point, this.chart);
      }
      return attribs;
    };
    Scatter3DSeries2.defaultOptions = merge71(ScatterSeries_default.defaultOptions, {
      tooltip: {
        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>"
      }
    });
    return Scatter3DSeries2;
  }(ScatterSeries_default)
);
extend71(Scatter3DSeries.prototype, {
  axisTypes: ["xAxis", "yAxis", "zAxis"],
  // Require direct touch rather than using the k-d-tree, because the
  // k-d-tree currently doesn't take the xyz coordinate system into
  // account (#4552)
  directTouch: true,
  parallelArrays: ["x", "y", "z"],
  pointArrayMap: ["x", "y", "z"],
  pointClass: Scatter3DPoint_default
});
SeriesRegistry_default.registerSeriesType("scatter3d", Scatter3DSeries);

// node_modules/highcharts/es-modules/Series/Area3DSeries.js
var perspective7 = Math3D_default.perspective;
var _a8 = SeriesRegistry_default.seriesTypes;
var AreaSeriesClass = _a8.area;
var LineSeriesClass = _a8.line;
var pick82 = Utilities_default.pick;
var wrap13 = Utilities_default.wrap;
wrap13(AreaSeriesClass.prototype, "getGraphPath", function(proceed) {
  var series = this, svgPath = proceed.apply(series, [].slice.call(arguments, 1));
  if (!series.chart.is3d()) {
    return svgPath;
  }
  var getGraphPath = LineSeriesClass.prototype.getGraphPath, graphPath = [], options = series.options, stacking = options.stacking, bottomPath, bottomPoints = [], graphPoints = [], i, areaPath, connectNulls = pick82(
    // #10574
    options.connectNulls,
    stacking === "percent"
  ), translatedThreshold = Math.round(
    // #10909
    series.yAxis.getThreshold(options.threshold)
  ), options3d;
  if (series.rawPointsX) {
    for (var i_1 = 0; i_1 < series.points.length; i_1++) {
      bottomPoints.push({
        x: series.rawPointsX[i_1],
        y: options.stacking ? series.points[i_1].yBottom : translatedThreshold,
        z: series.zPadding
      });
    }
  }
  options3d = series.chart.options.chart.options3d;
  bottomPoints = perspective7(bottomPoints, series.chart, true).map(function(point) {
    return { plotX: point.x, plotY: point.y, plotZ: point.z };
  });
  if (series.group && options3d && options3d.depth && options3d.beta) {
    if (series.markerGroup) {
      series.markerGroup.add(series.group);
      series.markerGroup.attr({
        translateX: 0,
        translateY: 0
      });
    }
    series.group.attr({
      zIndex: Math.max(1, options3d.beta > 270 || options3d.beta < 90 ? options3d.depth - Math.round(series.zPadding || 0) : Math.round(series.zPadding || 0))
    });
  }
  bottomPoints.reversed = true;
  bottomPath = getGraphPath.call(series, bottomPoints, true, true);
  if (bottomPath[0] && bottomPath[0][0] === "M") {
    bottomPath[0] = ["L", bottomPath[0][1], bottomPath[0][2]];
  }
  if (series.areaPath) {
    areaPath = series.areaPath.splice(0, series.areaPath.length / 2).concat(bottomPath);
    areaPath.xMap = series.areaPath.xMap;
    series.areaPath = areaPath;
    graphPath = getGraphPath.call(series, graphPoints, false, connectNulls);
  }
  return svgPath;
});

// node_modules/highcharts/es-modules/masters/highcharts-3d.src.js
var G5 = Globals_default;
SVGRenderer3D_default.compose(G5.SVGRenderer);
Chart3D_default.compose(G5.Chart, G5.Fx);
ZAxis_default.ZChartComposition.compose(G5.Chart);
Axis3D_default.compose(G5.Axis);

// node_modules/highcharts/es-modules/Core/HttpUtilities.js
var doc21 = Globals_default.doc;
var createElement11 = Utilities_default.createElement;
var discardElement7 = Utilities_default.discardElement;
var merge72 = Utilities_default.merge;
var objectEach33 = Utilities_default.objectEach;
function ajax(attr11) {
  var options = merge72(true, {
    url: false,
    type: "get",
    dataType: "json",
    success: false,
    error: false,
    data: false,
    headers: {}
  }, attr11), headers = {
    json: "application/json",
    xml: "application/xml",
    text: "text/plain",
    octet: "application/octet-stream"
  }, r = new XMLHttpRequest();
  function handleError(xhr, err) {
    if (options.error) {
      options.error(xhr, err);
    } else {
    }
  }
  if (!options.url) {
    return false;
  }
  r.open(options.type.toUpperCase(), options.url, true);
  if (!options.headers["Content-Type"]) {
    r.setRequestHeader("Content-Type", headers[options.dataType] || headers.text);
  }
  objectEach33(options.headers, function(val, key) {
    r.setRequestHeader(key, val);
  });
  r.onreadystatechange = function() {
    var res;
    if (r.readyState === 4) {
      if (r.status === 200) {
        res = r.responseText;
        if (options.dataType === "json") {
          try {
            res = JSON.parse(res);
          } catch (e2) {
            return handleError(r, e2);
          }
        }
        return options.success && options.success(res);
      }
      handleError(r, r.responseText);
    }
  };
  try {
    options.data = JSON.stringify(options.data);
  } catch (e2) {
  }
  r.send(options.data || true);
}
function getJSON(url, success) {
  exports2.ajax({
    url,
    success,
    dataType: "json",
    headers: {
      // Override the Content-Type to avoid preflight problems with CORS
      // in the Highcharts demos
      "Content-Type": "text/plain"
    }
  });
}
function post(url, data, formAttributes) {
  var form = createElement11("form", merge72({
    method: "post",
    action: url,
    enctype: "multipart/form-data"
  }, formAttributes), {
    display: "none"
  }, doc21.body);
  objectEach33(data, function(val, name) {
    createElement11("input", {
      type: "hidden",
      name,
      value: val
    }, null, form);
  });
  form.submit();
  discardElement7(form);
}
var exports2 = {
  ajax,
  getJSON,
  post
};
var HttpUtilities_default = exports2;

// node_modules/highcharts/es-modules/Extensions/Data.js
var doc22 = Globals_default.doc;
var ajax2 = HttpUtilities_default.ajax;
var seriesTypes6 = SeriesRegistry_default.seriesTypes;
var addEvent56 = Utilities_default.addEvent;
var defined51 = Utilities_default.defined;
var extend72 = Utilities_default.extend;
var fireEvent33 = Utilities_default.fireEvent;
var isNumber46 = Utilities_default.isNumber;
var merge73 = Utilities_default.merge;
var objectEach34 = Utilities_default.objectEach;
var pick83 = Utilities_default.pick;
var splat19 = Utilities_default.splat;
var Data = (
  /** @class */
  function() {
    function Data2(dataOptions, chartOptions, chart) {
      this.chart = void 0;
      this.chartOptions = void 0;
      this.firstRowAsNames = void 0;
      this.rawColumns = void 0;
      this.options = void 0;
      this.dateFormats = {
        "YYYY/mm/dd": {
          regex: /^([0-9]{4})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{1,2})$/,
          parser: function(match) {
            return match ? Date.UTC(+match[1], match[2] - 1, +match[3]) : NaN;
          }
        },
        "dd/mm/YYYY": {
          regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
          parser: function(match) {
            return match ? Date.UTC(+match[3], match[2] - 1, +match[1]) : NaN;
          },
          alternative: "mm/dd/YYYY"
          // different format with the same regex
        },
        "mm/dd/YYYY": {
          regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
          parser: function(match) {
            return match ? Date.UTC(+match[3], match[1] - 1, +match[2]) : NaN;
          }
        },
        "dd/mm/YY": {
          regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
          parser: function(match) {
            if (!match) {
              return NaN;
            }
            var year = +match[3], d = /* @__PURE__ */ new Date();
            if (year > d.getFullYear() - 2e3) {
              year += 1900;
            } else {
              year += 2e3;
            }
            return Date.UTC(year, match[2] - 1, +match[1]);
          },
          alternative: "mm/dd/YY"
          // different format with the same regex
        },
        "mm/dd/YY": {
          regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
          parser: function(match) {
            return match ? Date.UTC(+match[3] + 2e3, match[1] - 1, +match[2]) : NaN;
          }
        }
      };
      this.init(dataOptions, chartOptions, chart);
    }
    Data2.prototype.init = function(options, chartOptions, chart) {
      var decimalPoint = options.decimalPoint, hasData;
      if (chartOptions) {
        this.chartOptions = chartOptions;
      }
      if (chart) {
        this.chart = chart;
      }
      if (decimalPoint !== "." && decimalPoint !== ",") {
        decimalPoint = void 0;
      }
      this.options = options;
      this.columns = options.columns || this.rowsToColumns(options.rows) || [];
      this.firstRowAsNames = pick83(options.firstRowAsNames, this.firstRowAsNames, true);
      this.decimalRegex = decimalPoint && new RegExp("^(-?[0-9]+)" + decimalPoint + "([0-9]+)$");
      this.rawColumns = [];
      if (this.columns.length) {
        this.dataFound();
        hasData = true;
      }
      if (this.hasURLOption(options)) {
        clearTimeout(this.liveDataTimeout);
        hasData = false;
      }
      if (!hasData) {
        hasData = this.fetchLiveData();
      }
      if (!hasData) {
        hasData = Boolean(this.parseCSV().length);
      }
      if (!hasData) {
        hasData = Boolean(this.parseTable().length);
      }
      if (!hasData) {
        hasData = this.parseGoogleSpreadsheet();
      }
      if (!hasData && options.afterComplete) {
        options.afterComplete();
      }
    };
    Data2.prototype.hasURLOption = function(options) {
      return Boolean(options && (options.rowsURL || options.csvURL || options.columnsURL));
    };
    Data2.prototype.getColumnDistribution = function() {
      var chartOptions = this.chartOptions, options = this.options, xColumns = [], getValueCount = function(type) {
        return (seriesTypes6[type || "line"].prototype.pointArrayMap || [0]).length;
      }, getPointArrayMap = function(type) {
        return seriesTypes6[type || "line"].prototype.pointArrayMap;
      }, globalType = chartOptions && chartOptions.chart && chartOptions.chart.type, individualCounts = [], seriesBuilders = [], seriesIndex = 0, seriesMapping = options && options.seriesMapping || chartOptions && chartOptions.series && chartOptions.series.map(function() {
        return { x: 0 };
      }) || [], i;
      (chartOptions && chartOptions.series || []).forEach(function(series) {
        individualCounts.push(getValueCount(series.type || globalType));
      });
      seriesMapping.forEach(function(mapping) {
        xColumns.push(mapping.x || 0);
      });
      if (xColumns.length === 0) {
        xColumns.push(0);
      }
      seriesMapping.forEach(function(mapping) {
        var builder = new SeriesBuilder(), numberOfValueColumnsNeeded = individualCounts[seriesIndex] || getValueCount(globalType), seriesArr = chartOptions && chartOptions.series || [], series = seriesArr[seriesIndex] || {}, defaultPointArrayMap = getPointArrayMap(series.type || globalType), pointArrayMap = defaultPointArrayMap || ["y"];
        if (
          // User-defined x.mapping
          defined51(mapping.x) || // All non cartesian don't need 'x'
          series.isCartesian || // Except pie series:
          !defaultPointArrayMap
        ) {
          builder.addColumnReader(mapping.x, "x");
        }
        objectEach34(mapping, function(val, name) {
          if (name !== "x") {
            builder.addColumnReader(val, name);
          }
        });
        for (i = 0; i < numberOfValueColumnsNeeded; i++) {
          if (!builder.hasReader(pointArrayMap[i])) {
            builder.addColumnReader(void 0, pointArrayMap[i]);
          }
        }
        seriesBuilders.push(builder);
        seriesIndex++;
      });
      var globalPointArrayMap = getPointArrayMap(globalType);
      if (typeof globalPointArrayMap === "undefined") {
        globalPointArrayMap = ["y"];
      }
      this.valueCount = {
        global: getValueCount(globalType),
        xColumns,
        individual: individualCounts,
        seriesBuilders,
        globalPointArrayMap
      };
    };
    Data2.prototype.dataFound = function() {
      if (this.options.switchRowsAndColumns) {
        this.columns = this.rowsToColumns(this.columns);
      }
      this.getColumnDistribution();
      this.parseTypes();
      if (this.parsed() !== false) {
        this.complete();
      }
    };
    Data2.prototype.parseCSV = function(inOptions) {
      var self = this, options = inOptions || this.options, csv = options.csv, columns, startRow = typeof options.startRow !== "undefined" && options.startRow ? options.startRow : 0, endRow = options.endRow || Number.MAX_VALUE, startColumn = typeof options.startColumn !== "undefined" && options.startColumn ? options.startColumn : 0, endColumn = options.endColumn || Number.MAX_VALUE, itemDelimiter, lines, rowIt = 0, dataTypes = [], potDelimiters = {
        ",": 0,
        ";": 0,
        "	": 0
      };
      columns = this.columns = [];
      function parseRow(columnStr, rowNumber, noAdd, callbacks) {
        var i = 0, c = "", cl = "", cn = "", token = "", actualColumn = 0, column = 0;
        function read(j) {
          c = columnStr[j];
          cl = columnStr[j - 1];
          cn = columnStr[j + 1];
        }
        function pushType(type) {
          if (dataTypes.length < column + 1) {
            dataTypes.push([type]);
          }
          if (dataTypes[column][dataTypes[column].length - 1] !== type) {
            dataTypes[column].push(type);
          }
        }
        function push() {
          if (startColumn > actualColumn || actualColumn > endColumn) {
            ++actualColumn;
            token = "";
            return;
          }
          if (!isNaN(parseFloat(token)) && isFinite(token)) {
            token = parseFloat(token);
            pushType("number");
          } else if (!isNaN(Date.parse(token))) {
            token = token.replace(/\//g, "-");
            pushType("date");
          } else {
            pushType("string");
          }
          if (columns.length < column + 1) {
            columns.push([]);
          }
          if (!noAdd) {
            columns[column][rowNumber] = token;
          }
          token = "";
          ++column;
          ++actualColumn;
        }
        if (!columnStr.trim().length) {
          return;
        }
        if (columnStr.trim()[0] === "#") {
          return;
        }
        for (; i < columnStr.length; i++) {
          read(i);
          if (c === '"') {
            read(++i);
            while (i < columnStr.length) {
              if (c === '"' && cl !== '"' && cn !== '"') {
                break;
              }
              if (c !== '"' || c === '"' && cl !== '"') {
                token += c;
              }
              read(++i);
            }
          } else if (callbacks && callbacks[c]) {
            if (callbacks[c](c, token)) {
              push();
            }
          } else if (c === itemDelimiter) {
            push();
          } else {
            token += c;
          }
        }
        push();
      }
      function guessDelimiter(lines2) {
        var points = 0, commas = 0, guessed = false;
        lines2.some(function(columnStr, i) {
          var inStr = false, c, cn, cl, token = "";
          if (i > 13) {
            return true;
          }
          for (var j = 0; j < columnStr.length; j++) {
            c = columnStr[j];
            cn = columnStr[j + 1];
            cl = columnStr[j - 1];
            if (c === "#") {
              return;
            }
            if (c === '"') {
              if (inStr) {
                if (cl !== '"' && cn !== '"') {
                  while (cn === " " && j < columnStr.length) {
                    cn = columnStr[++j];
                  }
                  if (typeof potDelimiters[cn] !== "undefined") {
                    potDelimiters[cn]++;
                  }
                  inStr = false;
                }
              } else {
                inStr = true;
              }
            } else if (typeof potDelimiters[c] !== "undefined") {
              token = token.trim();
              if (!isNaN(Date.parse(token))) {
                potDelimiters[c]++;
              } else if (isNaN(token) || !isFinite(token)) {
                potDelimiters[c]++;
              }
              token = "";
            } else {
              token += c;
            }
            if (c === ",") {
              commas++;
            }
            if (c === ".") {
              points++;
            }
          }
        });
        if (potDelimiters[";"] > potDelimiters[","]) {
          guessed = ";";
        } else if (potDelimiters[","] > potDelimiters[";"]) {
          guessed = ",";
        } else {
          guessed = ",";
        }
        if (!options.decimalPoint) {
          if (points > commas) {
            options.decimalPoint = ".";
          } else {
            options.decimalPoint = ",";
          }
          self.decimalRegex = new RegExp("^(-?[0-9]+)" + options.decimalPoint + "([0-9]+)$");
        }
        return guessed;
      }
      function deduceDateFormat(data, limit) {
        var format15 = "YYYY/mm/dd", thing, guessedFormat = [], calculatedFormat, i = 0, madeDeduction = false, stable = [], max = [], j;
        if (!limit || limit > data.length) {
          limit = data.length;
        }
        for (; i < limit; i++) {
          if (typeof data[i] !== "undefined" && data[i] && data[i].length) {
            thing = data[i].trim().replace(/\//g, " ").replace(/\-/g, " ").replace(/\./g, " ").split(" ");
            guessedFormat = [
              "",
              "",
              ""
            ];
            for (j = 0; j < thing.length; j++) {
              if (j < guessedFormat.length) {
                thing[j] = parseInt(thing[j], 10);
                if (thing[j]) {
                  max[j] = !max[j] || max[j] < thing[j] ? thing[j] : max[j];
                  if (typeof stable[j] !== "undefined") {
                    if (stable[j] !== thing[j]) {
                      stable[j] = false;
                    }
                  } else {
                    stable[j] = thing[j];
                  }
                  if (thing[j] > 31) {
                    if (thing[j] < 100) {
                      guessedFormat[j] = "YY";
                    } else {
                      guessedFormat[j] = "YYYY";
                    }
                  } else if (thing[j] > 12 && thing[j] <= 31) {
                    guessedFormat[j] = "dd";
                    madeDeduction = true;
                  } else if (!guessedFormat[j].length) {
                    guessedFormat[j] = "mm";
                  }
                }
              }
            }
          }
        }
        if (madeDeduction) {
          for (j = 0; j < stable.length; j++) {
            if (stable[j] !== false) {
              if (max[j] > 12 && guessedFormat[j] !== "YY" && guessedFormat[j] !== "YYYY") {
                guessedFormat[j] = "YY";
              }
            } else if (max[j] > 12 && guessedFormat[j] === "mm") {
              guessedFormat[j] = "dd";
            }
          }
          if (guessedFormat.length === 3 && guessedFormat[1] === "dd" && guessedFormat[2] === "dd") {
            guessedFormat[2] = "YY";
          }
          calculatedFormat = guessedFormat.join("/");
          if (!(options.dateFormats || self.dateFormats)[calculatedFormat]) {
            fireEvent33("deduceDateFailed");
            return format15;
          }
          return calculatedFormat;
        }
        return format15;
      }
      function deduceAxisTypes() {
      }
      if (csv && options.beforeParse) {
        csv = options.beforeParse.call(this, csv);
      }
      if (csv) {
        lines = csv.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split(options.lineDelimiter || "\n");
        if (!startRow || startRow < 0) {
          startRow = 0;
        }
        if (!endRow || endRow >= lines.length) {
          endRow = lines.length - 1;
        }
        if (options.itemDelimiter) {
          itemDelimiter = options.itemDelimiter;
        } else {
          itemDelimiter = null;
          itemDelimiter = guessDelimiter(lines);
        }
        var offset3 = 0;
        for (rowIt = startRow; rowIt <= endRow; rowIt++) {
          if (lines[rowIt][0] === "#") {
            offset3++;
          } else {
            parseRow(lines[rowIt], rowIt - startRow - offset3);
          }
        }
        deduceAxisTypes();
        if ((!options.columnTypes || options.columnTypes.length === 0) && dataTypes.length && dataTypes[0].length && dataTypes[0][1] === "date" && !options.dateFormat) {
          options.dateFormat = deduceDateFormat(columns[0]);
        }
        this.dataFound();
      }
      return columns;
    };
    Data2.prototype.parseTable = function() {
      var options = this.options, table = options.table, columns = this.columns || [], startRow = options.startRow || 0, endRow = options.endRow || Number.MAX_VALUE, startColumn = options.startColumn || 0, endColumn = options.endColumn || Number.MAX_VALUE;
      if (table) {
        if (typeof table === "string") {
          table = doc22.getElementById(table);
        }
        [].forEach.call(table.getElementsByTagName("tr"), function(tr, rowNo) {
          if (rowNo >= startRow && rowNo <= endRow) {
            [].forEach.call(tr.children, function(item, colNo) {
              var row = columns[colNo - startColumn];
              var i = 1;
              if ((item.tagName === "TD" || item.tagName === "TH") && colNo >= startColumn && colNo <= endColumn) {
                if (!columns[colNo - startColumn]) {
                  columns[colNo - startColumn] = [];
                }
                columns[colNo - startColumn][rowNo - startRow] = item.innerHTML;
                while (rowNo - startRow >= i && row[rowNo - startRow - i] === void 0) {
                  row[rowNo - startRow - i] = null;
                  i++;
                }
              }
            });
          }
        });
        this.dataFound();
      }
      return columns;
    };
    Data2.prototype.fetchLiveData = function() {
      var data = this, chart = this.chart, options = this.options, maxRetries = 3, currentRetries = 0, pollingEnabled = options.enablePolling, updateIntervalMs = (options.dataRefreshRate || 2) * 1e3, originalOptions = merge73(options);
      if (!this.hasURLOption(options)) {
        return false;
      }
      if (updateIntervalMs < 1e3) {
        updateIntervalMs = 1e3;
      }
      delete options.csvURL;
      delete options.rowsURL;
      delete options.columnsURL;
      function performFetch(initialFetch) {
        function request(url, done, tp) {
          if (!url || !/^(http|\/|\.\/|\.\.\/)/.test(url)) {
            if (url && options.error) {
              options.error("Invalid URL");
            }
            return false;
          }
          if (initialFetch) {
            clearTimeout(data.liveDataTimeout);
            chart.liveDataURL = url;
          }
          function poll() {
            if (pollingEnabled && chart.liveDataURL === url) {
              data.liveDataTimeout = setTimeout(performFetch, updateIntervalMs);
            }
          }
          ajax2({
            url,
            dataType: tp || "json",
            success: function(res) {
              if (chart && chart.series) {
                done(res);
              }
              poll();
            },
            error: function(xhr, text) {
              if (++currentRetries < maxRetries) {
                poll();
              }
              return options.error && options.error(text, xhr);
            }
          });
          return true;
        }
        if (!request(originalOptions.csvURL, function(res) {
          chart.update({
            data: {
              csv: res
            }
          });
        }, "text")) {
          if (!request(originalOptions.rowsURL, function(res) {
            chart.update({
              data: {
                rows: res
              }
            });
          })) {
            request(originalOptions.columnsURL, function(res) {
              chart.update({
                data: {
                  columns: res
                }
              });
            });
          }
        }
      }
      performFetch(true);
      return this.hasURLOption(options);
    };
    Data2.prototype.parseGoogleSpreadsheet = function() {
      var data = this, options = this.options, googleSpreadsheetKey = options.googleSpreadsheetKey, chart = this.chart, refreshRate = Math.max((options.dataRefreshRate || 2) * 1e3, 4e3);
      var getRange = function() {
        if (options.googleSpreadsheetRange) {
          return options.googleSpreadsheetRange;
        }
        var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var start = (alphabet.charAt(options.startColumn || 0) || "A") + ((options.startRow || 0) + 1);
        var end = alphabet.charAt(pick83(options.endColumn, -1)) || "ZZ";
        if (defined51(options.endRow)) {
          end += options.endRow + 1;
        }
        return start + ":" + end;
      };
      function fetchSheet(fn) {
        var url = [
          "https://sheets.googleapis.com/v4/spreadsheets",
          googleSpreadsheetKey,
          "values",
          getRange(),
          "?alt=json&majorDimension=COLUMNS&valueRenderOption=UNFORMATTED_VALUE&dateTimeRenderOption=FORMATTED_STRING&key=" + options.googleAPIKey
        ].join("/");
        ajax2({
          url,
          dataType: "json",
          success: function(json) {
            fn(json);
            if (options.enablePolling) {
              setTimeout(function() {
                fetchSheet(fn);
              }, refreshRate);
            }
          },
          error: function(xhr, text) {
            return options.error && options.error(text, xhr);
          }
        });
      }
      if (googleSpreadsheetKey) {
        delete options.googleSpreadsheetKey;
        fetchSheet(function(json) {
          var columns = json.values;
          if (!columns || columns.length === 0) {
            return false;
          }
          var rowCount = columns.reduce(function(rowCount2, column) {
            return Math.max(rowCount2, column.length);
          }, 0);
          columns.forEach(function(column) {
            for (var i = 0; i < rowCount; i++) {
              if (typeof column[i] === "undefined") {
                column[i] = null;
              }
            }
          });
          if (chart && chart.series) {
            chart.update({
              data: {
                columns
              }
            });
          } else {
            data.columns = columns;
            data.dataFound();
          }
        });
      }
      return false;
    };
    Data2.prototype.trim = function(str, inside) {
      if (typeof str === "string") {
        str = str.replace(/^\s+|\s+$/g, "");
        if (inside && /^[0-9\s]+$/.test(str)) {
          str = str.replace(/\s/g, "");
        }
        if (this.decimalRegex) {
          str = str.replace(this.decimalRegex, "$1.$2");
        }
      }
      return str;
    };
    Data2.prototype.parseTypes = function() {
      var columns = this.columns, col = columns.length;
      while (col--) {
        this.parseColumn(columns[col], col);
      }
    };
    Data2.prototype.parseColumn = function(column, col) {
      var rawColumns = this.rawColumns, columns = this.columns, row = column.length, val, floatVal, trimVal, trimInsideVal, firstRowAsNames = this.firstRowAsNames, isXColumn = this.valueCount.xColumns.indexOf(col) !== -1, dateVal, backup = [], diff, chartOptions = this.chartOptions, descending, columnTypes = this.options.columnTypes || [], columnType = columnTypes[col], forceCategory = isXColumn && (chartOptions && chartOptions.xAxis && splat19(chartOptions.xAxis)[0].type === "category" || columnType === "string");
      if (!rawColumns[col]) {
        rawColumns[col] = [];
      }
      while (row--) {
        val = backup[row] || column[row];
        trimVal = this.trim(val);
        trimInsideVal = this.trim(val, true);
        floatVal = parseFloat(trimInsideVal);
        if (typeof rawColumns[col][row] === "undefined") {
          rawColumns[col][row] = trimVal;
        }
        if (forceCategory || row === 0 && firstRowAsNames) {
          column[row] = "" + trimVal;
        } else if (+trimInsideVal === floatVal) {
          column[row] = floatVal;
          if (floatVal > 365 * 24 * 3600 * 1e3 && columnType !== "float") {
            column.isDatetime = true;
          } else {
            column.isNumeric = true;
          }
          if (typeof column[row + 1] !== "undefined") {
            descending = floatVal > column[row + 1];
          }
        } else {
          if (trimVal && trimVal.length) {
            dateVal = this.parseDate(val);
          }
          if (isXColumn && isNumber46(dateVal) && columnType !== "float") {
            backup[row] = val;
            column[row] = dateVal;
            column.isDatetime = true;
            if (typeof column[row + 1] !== "undefined") {
              diff = dateVal > column[row + 1];
              if (diff !== descending && typeof descending !== "undefined") {
                if (this.alternativeFormat) {
                  this.dateFormat = this.alternativeFormat;
                  row = column.length;
                  this.alternativeFormat = this.dateFormats[this.dateFormat].alternative;
                } else {
                  column.unsorted = true;
                }
              }
              descending = diff;
            }
          } else {
            column[row] = trimVal === "" ? null : trimVal;
            if (row !== 0 && (column.isDatetime || column.isNumeric)) {
              column.mixed = true;
            }
          }
        }
      }
      if (isXColumn && column.mixed) {
        columns[col] = rawColumns[col];
      }
      if (isXColumn && descending && this.options.sort) {
        for (col = 0; col < columns.length; col++) {
          columns[col].reverse();
          if (firstRowAsNames) {
            columns[col].unshift(columns[col].pop());
          }
        }
      }
    };
    Data2.prototype.parseDate = function(val) {
      var parseDate = this.options.parseDate;
      var ret, key, format15, dateFormat2 = this.options.dateFormat || this.dateFormat, match;
      if (parseDate) {
        ret = parseDate(val);
      } else if (typeof val === "string") {
        if (!dateFormat2) {
          for (key in this.dateFormats) {
            format15 = this.dateFormats[key];
            match = val.match(format15.regex);
            if (match) {
              this.dateFormat = dateFormat2 = key;
              this.alternativeFormat = format15.alternative;
              ret = format15.parser(match);
              break;
            }
          }
        } else {
          format15 = this.dateFormats[dateFormat2];
          if (!format15) {
            format15 = this.dateFormats["YYYY/mm/dd"];
          }
          match = val.match(format15.regex);
          if (match) {
            ret = format15.parser(match);
          }
        }
        if (!match) {
          if (val.match(/:.+(GMT|UTC|[Z+-])/)) {
            val = val.replace(/\s*(?:GMT|UTC)?([+-])(\d\d)(\d\d)$/, "$1$2:$3").replace(/(?:\s+|GMT|UTC)([+-])/, "$1").replace(/(\d)\s*(?:GMT|UTC|Z)$/, "$1+00:00");
          }
          match = Date.parse(val);
          if (typeof match === "object" && match !== null && match.getTime) {
            ret = match.getTime() - match.getTimezoneOffset() * 6e4;
          } else if (isNumber46(match)) {
            ret = match - new Date(match).getTimezoneOffset() * 6e4;
          }
        }
      }
      return ret;
    };
    Data2.prototype.rowsToColumns = function(rows) {
      var row, rowsLength, col, colsLength, columns;
      if (rows) {
        columns = [];
        rowsLength = rows.length;
        for (row = 0; row < rowsLength; row++) {
          colsLength = rows[row].length;
          for (col = 0; col < colsLength; col++) {
            if (!columns[col]) {
              columns[col] = [];
            }
            columns[col][row] = rows[row][col];
          }
        }
      }
      return columns;
    };
    Data2.prototype.getData = function() {
      if (this.columns) {
        return this.rowsToColumns(this.columns).slice(1);
      }
    };
    Data2.prototype.parsed = function() {
      if (this.options.parsed) {
        return this.options.parsed.call(this, this.columns);
      }
    };
    Data2.prototype.getFreeIndexes = function(numberOfColumns, seriesBuilders) {
      var s, i, freeIndexes = [], freeIndexValues = [], referencedIndexes;
      for (i = 0; i < numberOfColumns; i = i + 1) {
        freeIndexes.push(true);
      }
      for (s = 0; s < seriesBuilders.length; s = s + 1) {
        referencedIndexes = seriesBuilders[s].getReferencedColumnIndexes();
        for (i = 0; i < referencedIndexes.length; i = i + 1) {
          freeIndexes[referencedIndexes[i]] = false;
        }
      }
      for (i = 0; i < freeIndexes.length; i = i + 1) {
        if (freeIndexes[i]) {
          freeIndexValues.push(i);
        }
      }
      return freeIndexValues;
    };
    Data2.prototype.complete = function() {
      var columns = this.columns, xColumns = [], type, options = this.options, series, data, i, j, r, seriesIndex, chartOptions, allSeriesBuilders = [], builder, freeIndexes, typeCol, index;
      xColumns.length = columns.length;
      if (options.complete || options.afterComplete) {
        if (this.firstRowAsNames) {
          for (i = 0; i < columns.length; i++) {
            columns[i].name = columns[i].shift();
          }
        }
        series = [];
        freeIndexes = this.getFreeIndexes(columns.length, this.valueCount.seriesBuilders);
        for (seriesIndex = 0; seriesIndex < this.valueCount.seriesBuilders.length; seriesIndex++) {
          builder = this.valueCount.seriesBuilders[seriesIndex];
          if (builder.populateColumns(freeIndexes)) {
            allSeriesBuilders.push(builder);
          }
        }
        while (freeIndexes.length > 0) {
          builder = new SeriesBuilder();
          builder.addColumnReader(0, "x");
          index = freeIndexes.indexOf(0);
          if (index !== -1) {
            freeIndexes.splice(index, 1);
          }
          for (i = 0; i < this.valueCount.global; i++) {
            builder.addColumnReader(void 0, this.valueCount.globalPointArrayMap[i]);
          }
          if (builder.populateColumns(freeIndexes)) {
            allSeriesBuilders.push(builder);
          }
        }
        if (allSeriesBuilders.length > 0 && allSeriesBuilders[0].readers.length > 0) {
          typeCol = columns[allSeriesBuilders[0].readers[0].columnIndex];
          if (typeof typeCol !== "undefined") {
            if (typeCol.isDatetime) {
              type = "datetime";
            } else if (!typeCol.isNumeric) {
              type = "category";
            }
          }
        }
        if (type === "category") {
          for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
            builder = allSeriesBuilders[seriesIndex];
            for (r = 0; r < builder.readers.length; r++) {
              if (builder.readers[r].configName === "x") {
                builder.readers[r].configName = "name";
              }
            }
          }
        }
        for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
          builder = allSeriesBuilders[seriesIndex];
          data = [];
          for (j = 0; j < columns[0].length; j++) {
            data[j] = builder.read(columns, j);
          }
          series[seriesIndex] = {
            data
          };
          if (builder.name) {
            series[seriesIndex].name = builder.name;
          }
          if (type === "category") {
            series[seriesIndex].turboThreshold = 0;
          }
        }
        chartOptions = {
          series
        };
        if (type) {
          chartOptions.xAxis = {
            type
          };
          if (type === "category") {
            chartOptions.xAxis.uniqueNames = false;
          }
        }
        if (options.complete) {
          options.complete(chartOptions);
        }
        if (options.afterComplete) {
          options.afterComplete(chartOptions);
        }
      }
    };
    Data2.prototype.update = function(options, redraw) {
      var chart = this.chart;
      if (options) {
        options.afterComplete = function(dataOptions) {
          if (dataOptions) {
            if (dataOptions.xAxis && chart.xAxis[0] && dataOptions.xAxis.type === chart.xAxis[0].options.type) {
              delete dataOptions.xAxis;
            }
            chart.update(dataOptions, redraw, true);
          }
        };
        merge73(true, chart.options.data, options);
        this.init(chart.options.data);
      }
    };
    return Data2;
  }()
);
Globals_default.data = function(dataOptions, chartOptions, chart) {
  return new Globals_default.Data(dataOptions, chartOptions, chart);
};
addEvent56(Chart_default, "init", function(e2) {
  var chart = this, userOptions = e2.args[0] || {}, callback = e2.args[1];
  if (userOptions && userOptions.data && !chart.hasDataDef) {
    chart.hasDataDef = true;
    chart.data = new Globals_default.Data(extend72(userOptions.data, {
      afterComplete: function(dataOptions) {
        var i, series;
        if (Object.hasOwnProperty.call(userOptions, "series")) {
          if (typeof userOptions.series === "object") {
            i = Math.max(userOptions.series.length, dataOptions && dataOptions.series ? dataOptions.series.length : 0);
            while (i--) {
              series = userOptions.series[i] || {};
              userOptions.series[i] = merge73(series, dataOptions && dataOptions.series ? dataOptions.series[i] : {});
            }
          } else {
            delete userOptions.series;
          }
        }
        userOptions = merge73(dataOptions, userOptions);
        chart.init(userOptions, callback);
      }
    }), userOptions, chart);
    e2.preventDefault();
  }
});
var SeriesBuilder = (
  /** @class */
  function() {
    function SeriesBuilder2() {
      this.readers = [];
      this.pointIsArray = true;
      this.name = void 0;
    }
    SeriesBuilder2.prototype.populateColumns = function(freeIndexes) {
      var builder = this, enoughColumns = true;
      builder.readers.forEach(function(reader) {
        if (typeof reader.columnIndex === "undefined") {
          reader.columnIndex = freeIndexes.shift();
        }
      });
      builder.readers.forEach(function(reader) {
        if (typeof reader.columnIndex === "undefined") {
          enoughColumns = false;
        }
      });
      return enoughColumns;
    };
    SeriesBuilder2.prototype.read = function(columns, rowIndex) {
      var builder = this, pointIsArray = builder.pointIsArray, point = pointIsArray ? [] : {}, columnIndexes;
      builder.readers.forEach(function(reader) {
        var value = columns[reader.columnIndex][rowIndex];
        if (pointIsArray) {
          point.push(value);
        } else {
          if (reader.configName.indexOf(".") > 0) {
            Point_default.prototype.setNestedProperty(point, value, reader.configName);
          } else {
            point[reader.configName] = value;
          }
        }
      });
      if (typeof this.name === "undefined" && builder.readers.length >= 2) {
        columnIndexes = builder.getReferencedColumnIndexes();
        if (columnIndexes.length >= 2) {
          columnIndexes.shift();
          columnIndexes.sort(function(a, b) {
            return a - b;
          });
          this.name = columns[columnIndexes.shift()].name;
        }
      }
      return point;
    };
    SeriesBuilder2.prototype.addColumnReader = function(columnIndex, configName) {
      this.readers.push({
        columnIndex,
        configName
      });
      if (!(configName === "x" || configName === "y" || typeof configName === "undefined")) {
        this.pointIsArray = false;
      }
    };
    SeriesBuilder2.prototype.getReferencedColumnIndexes = function() {
      var i, referencedColumnIndexes = [], columnReader;
      for (i = 0; i < this.readers.length; i = i + 1) {
        columnReader = this.readers[i];
        if (typeof columnReader.columnIndex !== "undefined") {
          referencedColumnIndexes.push(columnReader.columnIndex);
        }
      }
      return referencedColumnIndexes;
    };
    SeriesBuilder2.prototype.hasReader = function(configName) {
      var i, columnReader;
      for (i = 0; i < this.readers.length; i = i + 1) {
        columnReader = this.readers[i];
        if (columnReader.configName === configName) {
          return true;
        }
      }
    };
    return SeriesBuilder2;
  }()
);
Globals_default.Data = Data;
var Data_default = Globals_default.Data;

// node_modules/highcharts/es-modules/masters/modules/data.src.js
var G6 = Globals_default;
G6.HttpUtilities = HttpUtilities_default;
G6.ajax = HttpUtilities_default.ajax;
G6.getJSON = HttpUtilities_default.getJSON;
G6.post = HttpUtilities_default.post;

// node_modules/highcharts/es-modules/Extensions/Drilldown.js
var animObject13 = AnimationUtilities_default.animObject;
var format14 = FormatUtilities_default.format;
var noop18 = Globals_default.noop;
var defaultOptions14 = DefaultOptions_default.defaultOptions;
var seriesTypes7 = SeriesRegistry_default.seriesTypes;
var addEvent57 = Utilities_default.addEvent;
var removeEvent12 = Utilities_default.removeEvent;
var extend73 = Utilities_default.extend;
var fireEvent34 = Utilities_default.fireEvent;
var merge74 = Utilities_default.merge;
var objectEach35 = Utilities_default.objectEach;
var pick84 = Utilities_default.pick;
var syncTimeout10 = Utilities_default.syncTimeout;
var PieSeries3 = seriesTypes7.pie;
var ddSeriesId = 1;
extend73(
  defaultOptions14.lang,
  /**
   * @optionparent lang
   */
  {
    /**
     * The text for the button that appears when drilling down, linking back
     * to the parent series. The parent series' name is inserted for
     * `{series.name}`.
     *
     * @since    3.0.8
     * @product  highcharts highmaps
     * @requires modules/drilldown
     *
     * @private
     */
    drillUpText: " Back to {series.name}"
  }
);
defaultOptions14.drilldown = {
  /**
   * When this option is false, clicking a single point will drill down
   * all points in the same category, equivalent to clicking the X axis
   * label.
   *
   * @sample {highcharts} highcharts/drilldown/allowpointdrilldown-false/
   *         Don't allow point drilldown
   *
   * @type      {boolean}
   * @default   true
   * @since     4.1.7
   * @product   highcharts
   * @apioption drilldown.allowPointDrilldown
   */
  /**
   * An array of series configurations for the drill down. Each series
   * configuration uses the same syntax as the [series](#series) option set.
   * These drilldown series are hidden by default. The drilldown series is
   * linked to the parent series' point by its `id`.
   *
   * @type      {Array<Highcharts.SeriesOptionsType>}
   * @since     3.0.8
   * @product   highcharts highmaps
   * @apioption drilldown.series
   */
  /**
   * Additional styles to apply to the X axis label for a point that
   * has drilldown data. By default it is underlined and blue to invite
   * to interaction.
   *
   * In styled mode, active label styles can be set with the
   * `.highcharts-drilldown-axis-label` class.
   *
   * @sample {highcharts} highcharts/drilldown/labels/
   *         Label styles
   *
   * @type    {Highcharts.CSSObject}
   * @default { "cursor": "pointer", "color": "#003399", "fontWeight": "bold", "textDecoration": "underline" }
   * @since   3.0.8
   * @product highcharts highmaps
   */
  activeAxisLabelStyle: {
    /** @ignore-option */
    cursor: "pointer",
    /** @ignore-option */
    color: Palette_default.highlightColor100,
    /** @ignore-option */
    fontWeight: "bold",
    /** @ignore-option */
    textDecoration: "underline"
  },
  /**
   * Additional styles to apply to the data label of a point that has
   * drilldown data. By default it is underlined and blue to invite to
   * interaction.
   *
   * In styled mode, active data label styles can be applied with the
   * `.highcharts-drilldown-data-label` class.
   *
   * @sample {highcharts} highcharts/drilldown/labels/
   *         Label styles
   *
   * @type    {Highcharts.CSSObject}
   * @default { "cursor": "pointer", "color": "#003399", "fontWeight": "bold", "textDecoration": "underline" }
   * @since   3.0.8
   * @product highcharts highmaps
   */
  activeDataLabelStyle: {
    cursor: "pointer",
    color: Palette_default.highlightColor100,
    fontWeight: "bold",
    textDecoration: "underline"
  },
  /**
   * Set the animation for all drilldown animations. Animation of a drilldown
   * occurs when drilling between a column point and a column series,
   * or a pie slice and a full pie series. Drilldown can still be used
   * between series and points of different types, but animation will
   * not occur.
   *
   * The animation can either be set as a boolean or a configuration
   * object. If `true`, it will use the 'swing' jQuery easing and a duration
   * of 500 ms. If used as a configuration object, the following properties
   * are supported:
   *
   * - `duration`: The duration of the animation in milliseconds.
   *
   * - `easing`: A string reference to an easing function set on the `Math`
   *   object. See
   *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
   *
   * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}
   * @since   3.0.8
   * @product highcharts highmaps
   */
  animation: {
    /** @internal */
    duration: 500
  },
  /**
   * Options for the drill up button that appears when drilling down on a
   * series. The text for the button is defined in
   * [lang.drillUpText](#lang.drillUpText).
   *
   * @sample {highcharts} highcharts/drilldown/drillupbutton/
   *         Drill up button
   * @sample {highmaps} highcharts/drilldown/drillupbutton/
   *         Drill up button
   *
   * @since   3.0.8
   * @product highcharts highmaps
   */
  drillUpButton: {
    /**
     * What box to align the button to. Can be either `plotBox` or
     * `spacingBox`.
     *
     * @type       {Highcharts.ButtonRelativeToValue}
     * @default    plotBox
     * @since      3.0.8
     * @product    highcharts highmaps
     * @apioption  drilldown.drillUpButton.relativeTo
     */
    /**
     * A collection of attributes for the button. The object takes SVG
     * attributes like `fill`, `stroke`, `stroke-width` or `r`, the border
     * radius. The theme also supports `style`, a collection of CSS
     * properties for the text. Equivalent attributes for the hover state
     * are given in `theme.states.hover`.
     *
     * In styled mode, drill-up button styles can be applied with the
     * `.highcharts-drillup-button` class.
     *
     * @sample {highcharts} highcharts/drilldown/drillupbutton/
     *         Button theming
     * @sample {highmaps} highcharts/drilldown/drillupbutton/
     *         Button theming
     *
     * @type      {object}
     * @since     3.0.8
     * @product   highcharts highmaps
     * @apioption drilldown.drillUpButton.theme
     */
    /**
     * Positioning options for the button within the `relativeTo` box.
     * Available properties are `x`, `y`, `align` and `verticalAlign`.
     *
     * @type    {Highcharts.AlignObject}
     * @since   3.0.8
     * @product highcharts highmaps
     */
    position: {
      /**
       * Vertical alignment of the button.
       *
       * @type      {Highcharts.VerticalAlignValue}
       * @default   top
       * @product   highcharts highmaps
       * @apioption drilldown.drillUpButton.position.verticalAlign
       */
      /**
       * Horizontal alignment.
       *
       * @type {Highcharts.AlignValue}
       */
      align: "right",
      /**
       * The X offset of the button.
       */
      x: -10,
      /**
       * The Y offset of the button.
       */
      y: 10
    }
  }
};
SVGRenderer_default.prototype.Element.prototype.fadeIn = function(animation) {
  this.attr({
    opacity: 0.1,
    visibility: "inherit"
  }).animate({
    opacity: pick84(this.newOpacity, 1)
    // newOpacity used in maps
  }, animation || {
    duration: 250
  });
};
Chart_default.prototype.addSeriesAsDrilldown = function(point, options) {
  this.addSingleSeriesAsDrilldown(point, options);
  this.applyDrilldown();
};
Chart_default.prototype.addSingleSeriesAsDrilldown = function(point, ddOptions) {
  var oldSeries = point.series, xAxis = oldSeries.xAxis, yAxis = oldSeries.yAxis, newSeries, pointIndex, levelSeries = [], levelSeriesOptions = [], level, levelNumber, last, colorProp;
  colorProp = this.styledMode ? { colorIndex: pick84(point.colorIndex, oldSeries.colorIndex) } : { color: point.color || oldSeries.color };
  if (!this.drilldownLevels) {
    this.drilldownLevels = [];
  }
  levelNumber = oldSeries.options._levelNumber || 0;
  last = this.drilldownLevels[this.drilldownLevels.length - 1];
  if (last && last.levelNumber !== levelNumber) {
    last = void 0;
  }
  ddOptions = extend73(extend73({
    _ddSeriesId: ddSeriesId++
  }, colorProp), ddOptions);
  pointIndex = oldSeries.points.indexOf(point);
  oldSeries.chart.series.forEach(function(series) {
    if (series.xAxis === xAxis && !series.isDrilling) {
      series.options._ddSeriesId = series.options._ddSeriesId || ddSeriesId++;
      series.options._colorIndex = series.userOptions._colorIndex;
      series.options._levelNumber = series.options._levelNumber || levelNumber;
      if (last) {
        levelSeries = last.levelSeries;
        levelSeriesOptions = last.levelSeriesOptions;
      } else {
        levelSeries.push(series);
        series.purgedOptions = merge74({
          _ddSeriesId: series.options._ddSeriesId,
          _levelNumber: series.options._levelNumber,
          selected: series.options.selected
        }, series.userOptions);
        levelSeriesOptions.push(series.purgedOptions);
      }
    }
  });
  level = extend73({
    levelNumber,
    seriesOptions: oldSeries.options,
    seriesPurgedOptions: oldSeries.purgedOptions,
    levelSeriesOptions,
    levelSeries,
    shapeArgs: point.shapeArgs,
    // no graphic in line series with markers disabled
    bBox: point.graphic ? point.graphic.getBBox() : {},
    color: point.isNull ? Color_default.parse(colorProp.color).setOpacity(0).get() : colorProp.color,
    lowerSeriesOptions: ddOptions,
    pointOptions: oldSeries.options.data[pointIndex],
    pointIndex,
    oldExtremes: {
      xMin: xAxis && xAxis.userMin,
      xMax: xAxis && xAxis.userMax,
      yMin: yAxis && yAxis.userMin,
      yMax: yAxis && yAxis.userMax
    },
    resetZoomButton: this.resetZoomButton
  }, colorProp);
  this.drilldownLevels.push(level);
  if (xAxis && xAxis.names) {
    xAxis.names.length = 0;
  }
  newSeries = level.lowerSeries = this.addSeries(ddOptions, false);
  newSeries.options._levelNumber = levelNumber + 1;
  if (xAxis) {
    xAxis.oldPos = xAxis.pos;
    xAxis.userMin = xAxis.userMax = null;
    yAxis.userMin = yAxis.userMax = null;
  }
  if (oldSeries.type === newSeries.type) {
    newSeries.animate = newSeries.animateDrilldown || noop18;
    newSeries.options.animation = true;
  }
};
Chart_default.prototype.applyDrilldown = function() {
  var drilldownLevels = this.drilldownLevels, levelToRemove;
  if (drilldownLevels && drilldownLevels.length > 0) {
    levelToRemove = drilldownLevels[drilldownLevels.length - 1].levelNumber;
    this.drilldownLevels.forEach(function(level) {
      if (level.levelNumber === levelToRemove) {
        level.levelSeries.forEach(function(series) {
          if (series.options && series.options._levelNumber === levelToRemove) {
            series.remove(false);
          }
        });
      }
    });
  }
  if (this.resetZoomButton) {
    this.resetZoomButton.hide();
    delete this.resetZoomButton;
  }
  this.pointer.reset();
  this.redraw();
  this.showDrillUpButton();
  fireEvent34(this, "afterDrilldown");
};
Chart_default.prototype.getDrilldownBackText = function() {
  var drilldownLevels = this.drilldownLevels, lastLevel;
  if (drilldownLevels && drilldownLevels.length > 0) {
    lastLevel = drilldownLevels[drilldownLevels.length - 1];
    lastLevel.series = lastLevel.seriesOptions;
    return format14(this.options.lang.drillUpText || "", lastLevel);
  }
};
Chart_default.prototype.showDrillUpButton = function() {
  var chart = this, backText = this.getDrilldownBackText(), buttonOptions = chart.options.drilldown.drillUpButton, attr11, states, alignTo = buttonOptions.relativeTo === "chart" || buttonOptions.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
  if (!this.drillUpButton) {
    attr11 = buttonOptions.theme;
    states = attr11 && attr11.states;
    this.drillUpButton = this.renderer.button(backText, null, null, function() {
      chart.drillUp();
    }, attr11, states && states.hover, states && states.select).addClass("highcharts-drillup-button").attr({
      align: buttonOptions.position.align,
      zIndex: 7
    }).add().align(buttonOptions.position, false, alignTo);
  } else {
    this.drillUpButton.attr({
      text: backText
    }).align();
  }
};
Chart_default.prototype.drillUp = function() {
  if (!this.drilldownLevels || this.drilldownLevels.length === 0) {
    return;
  }
  var chart = this, drilldownLevels = chart.drilldownLevels, levelNumber = drilldownLevels[drilldownLevels.length - 1].levelNumber, i = drilldownLevels.length, chartSeries = chart.series, seriesI, level, oldSeries, newSeries, oldExtremes, addSeries = function(seriesOptions) {
    var addedSeries;
    chartSeries.forEach(function(series) {
      if (series.options._ddSeriesId === seriesOptions._ddSeriesId) {
        addedSeries = series;
      }
    });
    addedSeries = addedSeries || chart.addSeries(seriesOptions, false);
    if (addedSeries.type === oldSeries.type && addedSeries.animateDrillupTo) {
      addedSeries.animate = addedSeries.animateDrillupTo;
    }
    if (seriesOptions === level.seriesPurgedOptions) {
      newSeries = addedSeries;
    }
  };
  while (i--) {
    level = drilldownLevels[i];
    if (level.levelNumber === levelNumber) {
      drilldownLevels.pop();
      oldSeries = level.lowerSeries;
      if (!oldSeries.chart) {
        seriesI = chartSeries.length;
        while (seriesI--) {
          if (chartSeries[seriesI].options.id === level.lowerSeriesOptions.id && chartSeries[seriesI].options._levelNumber === levelNumber + 1) {
            oldSeries = chartSeries[seriesI];
            break;
          }
        }
      }
      oldSeries.xData = [];
      level.levelSeriesOptions.forEach(addSeries);
      fireEvent34(chart, "drillup", {
        seriesOptions: level.seriesPurgedOptions || level.seriesOptions
      });
      this.resetZoomButton && this.resetZoomButton.destroy();
      if (newSeries.type === oldSeries.type) {
        newSeries.drilldownLevel = level;
        newSeries.options.animation = chart.options.drilldown.animation;
        if (oldSeries.animateDrillupFrom && oldSeries.chart) {
          oldSeries.animateDrillupFrom(level);
        }
      }
      newSeries.options._levelNumber = levelNumber;
      oldSeries.remove(false);
      if (newSeries.xAxis) {
        oldExtremes = level.oldExtremes;
        newSeries.xAxis.setExtremes(oldExtremes.xMin, oldExtremes.xMax, false);
        newSeries.yAxis.setExtremes(oldExtremes.yMin, oldExtremes.yMax, false);
      }
      if (level.resetZoomButton) {
        chart.resetZoomButton = level.resetZoomButton;
        chart.resetZoomButton.show();
      }
    }
  }
  this.redraw();
  if (this.drilldownLevels.length === 0) {
    this.drillUpButton = this.drillUpButton.destroy();
  } else {
    this.drillUpButton.attr({
      text: this.getDrilldownBackText()
    }).align();
  }
  this.ddDupes.length = [];
  fireEvent34(chart, "drillupall");
};
addEvent57(Chart_default, "afterInit", function() {
  var chart = this;
  chart.drilldown = {
    update: function(options, redraw) {
      merge74(true, chart.options.drilldown, options);
      if (pick84(redraw, true)) {
        chart.redraw();
      }
    }
  };
});
addEvent57(Chart_default, "afterShowResetZoom", function() {
  var chart = this, bbox = chart.resetZoomButton && chart.resetZoomButton.getBBox(), buttonOptions = chart.options.drilldown && chart.options.drilldown.drillUpButton;
  if (this.drillUpButton && bbox && buttonOptions && buttonOptions.position && buttonOptions.position.x) {
    this.drillUpButton.align({
      x: buttonOptions.position.x - bbox.width - 10,
      y: buttonOptions.position.y,
      align: buttonOptions.position.align
    }, false, buttonOptions.relativeTo || "plotBox");
  }
});
addEvent57(Chart_default, "render", function() {
  (this.xAxis || []).forEach(function(axis) {
    axis.ddPoints = {};
    axis.series.forEach(function(series) {
      var i, xData = series.xData || [], points = series.points, p;
      for (i = 0; i < xData.length; i++) {
        p = series.options.data[i];
        if (typeof p !== "number") {
          p = series.pointClass.prototype.optionsToObject.call({ series }, p);
          if (p.drilldown) {
            if (!axis.ddPoints[xData[i]]) {
              axis.ddPoints[xData[i]] = [];
            }
            var index = i - (series.cropStart || 0);
            axis.ddPoints[xData[i]].push(points && index >= 0 && index < points.length ? points[index] : true);
          }
        }
      }
    });
    objectEach35(axis.ticks, Tick_default.prototype.drillable);
  });
});
ColumnSeries_default.prototype.animateDrillupTo = function(init) {
  if (!init) {
    var newSeries_1 = this, level_1 = newSeries_1.drilldownLevel;
    this.points.forEach(function(point) {
      var dataLabel = point.dataLabel;
      if (point.graphic) {
        point.graphic.hide();
      }
      if (dataLabel) {
        dataLabel.hidden = dataLabel.attr("visibility") === "hidden";
        if (!dataLabel.hidden) {
          dataLabel.hide();
          if (point.connector) {
            point.connector.hide();
          }
        }
      }
    });
    syncTimeout10(function() {
      if (newSeries_1.points) {
        var pointsWithNodes_1 = [];
        newSeries_1.data.forEach(function(el) {
          pointsWithNodes_1.push(el);
        });
        if (newSeries_1.nodes) {
          pointsWithNodes_1 = pointsWithNodes_1.concat(newSeries_1.nodes);
        }
        pointsWithNodes_1.forEach(function(point, i) {
          var verb = i === (level_1 && level_1.pointIndex) ? "show" : "fadeIn", inherit = verb === "show" ? true : void 0, dataLabel = point.dataLabel;
          if (point.graphic) {
            point.graphic[verb](inherit);
          }
          if (dataLabel && !dataLabel.hidden) {
            dataLabel.fadeIn();
            if (point.connector) {
              point.connector.fadeIn();
            }
          }
        });
      }
    }, Math.max(this.chart.options.drilldown.animation.duration - 50, 0));
    delete this.animate;
  }
};
ColumnSeries_default.prototype.animateDrilldown = function(init) {
  var series = this, chart = this.chart, drilldownLevels = chart.drilldownLevels, animateFrom, animationOptions = animObject13(chart.options.drilldown.animation), xAxis = this.xAxis, styledMode = chart.styledMode;
  if (!init) {
    drilldownLevels.forEach(function(level) {
      if (series.options._ddSeriesId === level.lowerSeriesOptions._ddSeriesId) {
        animateFrom = level.shapeArgs;
        if (!styledMode) {
          animateFrom.fill = level.color;
        }
      }
    });
    animateFrom.x += pick84(xAxis.oldPos, xAxis.pos) - xAxis.pos;
    this.points.forEach(function(point) {
      var animateTo = point.shapeArgs;
      if (!styledMode) {
        animateTo.fill = point.color;
      }
      if (point.graphic) {
        point.graphic.attr(animateFrom).animate(extend73(point.shapeArgs, { fill: point.color || series.color }), animationOptions);
      }
      if (point.dataLabel) {
        point.dataLabel.fadeIn(animationOptions);
      }
    });
    delete this.animate;
  }
};
ColumnSeries_default.prototype.animateDrillupFrom = function(level) {
  var animationOptions = animObject13(this.chart.options.drilldown.animation), group = this.group, removeGroup = group !== this.chart.columnGroup, series = this;
  series.trackerGroups.forEach(function(key) {
    if (series[key]) {
      series[key].on("mouseover");
    }
  });
  if (removeGroup) {
    delete this.group;
  }
  this.points.forEach(function(point) {
    var graphic = point.graphic, animateTo = level.shapeArgs, complete = function() {
      graphic.destroy();
      if (group && removeGroup) {
        group = group.destroy();
      }
    };
    if (graphic && animateTo) {
      delete point.graphic;
      if (!series.chart.styledMode) {
        animateTo.fill = level.color;
      }
      if (animationOptions.duration) {
        graphic.animate(animateTo, merge74(animationOptions, { complete }));
      } else {
        graphic.attr(animateTo);
        complete();
      }
    }
  });
};
if (PieSeries3) {
  extend73(PieSeries3.prototype, {
    animateDrillupTo: ColumnSeries_default.prototype.animateDrillupTo,
    animateDrillupFrom: ColumnSeries_default.prototype.animateDrillupFrom,
    animateDrilldown: function(init) {
      var level = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1], animationOptions = this.chart.options.drilldown.animation;
      if (this.is("item")) {
        animationOptions.duration = 0;
      }
      if (this.center) {
        var animateFrom_1 = level.shapeArgs, start_1 = animateFrom_1.start, angle = animateFrom_1.end - start_1, startAngle_1 = angle / this.points.length, styledMode_1 = this.chart.styledMode;
        if (!init) {
          this.points.forEach(function(point, i) {
            var animateTo = point.shapeArgs;
            if (!styledMode_1) {
              animateFrom_1.fill = level.color;
              animateTo.fill = point.color;
            }
            if (point.graphic) {
              point.graphic.attr(merge74(animateFrom_1, {
                start: start_1 + i * startAngle_1,
                end: start_1 + (i + 1) * startAngle_1
              }))[animationOptions ? "animate" : "attr"](animateTo, animationOptions);
            }
          });
          delete this.animate;
        }
      }
    }
  });
}
Point_default.prototype.doDrilldown = function() {
  this.runDrilldown();
};
Point_default.prototype.runDrilldown = function(holdRedraw, category, originalEvent) {
  var series = this.series, chart = series.chart, drilldown = chart.options.drilldown;
  var i = (drilldown.series || []).length, seriesOptions;
  if (!chart.ddDupes) {
    chart.ddDupes = [];
  }
  while (i-- && !seriesOptions) {
    if (drilldown.series[i].id === this.drilldown && chart.ddDupes.indexOf(this.drilldown) === -1) {
      seriesOptions = drilldown.series[i];
      chart.ddDupes.push(this.drilldown);
    }
  }
  fireEvent34(chart, "drilldown", {
    point: this,
    seriesOptions,
    category,
    originalEvent,
    points: typeof category !== "undefined" && this.series.xAxis.getDDPoints(category).slice(0)
  }, function(e2) {
    var chart2 = e2.point.series && e2.point.series.chart, seriesOptions2 = e2.seriesOptions;
    if (chart2 && seriesOptions2) {
      if (holdRedraw) {
        chart2.addSingleSeriesAsDrilldown(e2.point, seriesOptions2);
      } else {
        chart2.addSeriesAsDrilldown(e2.point, seriesOptions2);
      }
    }
  });
};
Axis_default.prototype.drilldownCategory = function(x, originalEvent) {
  this.getDDPoints(x).forEach(function(point) {
    if (point && point.series && point.series.visible && point.runDrilldown) {
      point.runDrilldown(true, x, originalEvent);
    }
  });
  this.chart.applyDrilldown();
};
Axis_default.prototype.getDDPoints = function(x) {
  return this.ddPoints && this.ddPoints[x] || [];
};
Tick_default.prototype.drillable = function() {
  var pos = this.pos, label = this.label, axis = this.axis, isDrillable = axis.coll === "xAxis" && axis.getDDPoints, ddPointsX = isDrillable && axis.getDDPoints(pos), styledMode = axis.chart.styledMode;
  if (isDrillable) {
    if (label && ddPointsX && ddPointsX.length) {
      label.drillable = true;
      if (!label.basicStyles && !styledMode) {
        label.basicStyles = merge74(label.styles);
      }
      label.addClass("highcharts-drilldown-axis-label");
      if (label.removeOnDrillableClick) {
        removeEvent12(label.element, "click");
      }
      label.removeOnDrillableClick = addEvent57(label.element, "click", function(e2) {
        e2.preventDefault();
        axis.drilldownCategory(pos, e2);
      });
      if (!styledMode) {
        label.css(axis.chart.options.drilldown.activeAxisLabelStyle);
      }
    } else if (label && label.drillable && label.removeOnDrillableClick) {
      if (!styledMode) {
        label.styles = {};
        label.css(label.basicStyles);
      }
      label.removeOnDrillableClick();
      label.removeClass("highcharts-drilldown-axis-label");
    }
  }
};
addEvent57(Point_default, "afterInit", function() {
  var point = this;
  if (point.drilldown && !point.unbindDrilldownClick) {
    point.unbindDrilldownClick = addEvent57(point, "click", handlePointClick);
  }
  return point;
});
addEvent57(Point_default, "update", function(e2) {
  var point = this, options = e2.options || {};
  if (options.drilldown && !point.unbindDrilldownClick) {
    point.unbindDrilldownClick = addEvent57(point, "click", handlePointClick);
  } else if (!options.drilldown && options.drilldown !== void 0 && point.unbindDrilldownClick) {
    point.unbindDrilldownClick = point.unbindDrilldownClick();
  }
});
var handlePointClick = function(e2) {
  var point = this, series = point.series;
  if (series.xAxis && series.chart.options.drilldown.allowPointDrilldown === false) {
    series.xAxis.drilldownCategory(point.x, e2);
  } else {
    point.runDrilldown(void 0, void 0, e2);
  }
};
addEvent57(Series_default, "afterDrawDataLabels", function() {
  var css16 = this.chart.options.drilldown.activeDataLabelStyle, renderer = this.chart.renderer, styledMode = this.chart.styledMode;
  this.points.forEach(function(point) {
    var dataLabelsOptions = point.options.dataLabels, pointCSS = pick84(point.dlOptions, dataLabelsOptions && dataLabelsOptions.style, {});
    if (point.drilldown && point.dataLabel) {
      if (css16.color === "contrast" && !styledMode) {
        pointCSS.color = renderer.getContrast(point.color || this.color);
      }
      if (dataLabelsOptions && dataLabelsOptions.color) {
        pointCSS.color = dataLabelsOptions.color;
      }
      point.dataLabel.addClass("highcharts-drilldown-data-label");
      if (!styledMode) {
        point.dataLabel.css(css16).css(pointCSS);
      }
    }
  }, this);
});
var applyCursorCSS = function(element, cursor, addClass3, styledMode) {
  element[addClass3 ? "addClass" : "removeClass"]("highcharts-drilldown-point");
  if (!styledMode) {
    element.css({ cursor });
  }
};
addEvent57(Series_default, "afterDrawTracker", function() {
  var styledMode = this.chart.styledMode;
  this.points.forEach(function(point) {
    if (point.drilldown && point.graphic) {
      applyCursorCSS(point.graphic, "pointer", true, styledMode);
    }
  });
});
addEvent57(Point_default, "afterSetState", function() {
  var styledMode = this.series.chart.styledMode;
  if (this.drilldown && this.series.halo && this.state === "hover") {
    applyCursorCSS(this.series.halo, "pointer", true, styledMode);
  } else if (this.series.halo) {
    applyCursorCSS(this.series.halo, "auto", false, styledMode);
  }
});
addEvent57(Chart_default, "selection", function(event) {
  if (event.resetSelection === true && this.drillUpButton) {
    var buttonOptions = this.options.drilldown && this.options.drilldown.drillUpButton;
    if (buttonOptions && buttonOptions.position) {
      this.drillUpButton.align({
        x: buttonOptions.position.x,
        y: buttonOptions.position.y,
        align: buttonOptions.position.align
      }, false, buttonOptions.relativeTo || "plotBox");
    }
  }
});
addEvent57(Chart_default, "drillup", function() {
  if (this.resetZoomButton) {
    this.resetZoomButton = this.resetZoomButton.destroy();
  }
});

// node_modules/highcharts/es-modules/Extensions/FullScreen.js
var doc23 = Globals_default.doc;
var addEvent58 = Utilities_default.addEvent;
var Fullscreen = (
  /** @class */
  function() {
    function Fullscreen2(chart) {
      this.chart = chart;
      this.isOpen = false;
      var container = chart.renderTo;
      if (!this.browserProps) {
        if (typeof container.requestFullscreen === "function") {
          this.browserProps = {
            fullscreenChange: "fullscreenchange",
            requestFullscreen: "requestFullscreen",
            exitFullscreen: "exitFullscreen"
          };
        } else if (container.mozRequestFullScreen) {
          this.browserProps = {
            fullscreenChange: "mozfullscreenchange",
            requestFullscreen: "mozRequestFullScreen",
            exitFullscreen: "mozCancelFullScreen"
          };
        } else if (container.webkitRequestFullScreen) {
          this.browserProps = {
            fullscreenChange: "webkitfullscreenchange",
            requestFullscreen: "webkitRequestFullScreen",
            exitFullscreen: "webkitExitFullscreen"
          };
        } else if (container.msRequestFullscreen) {
          this.browserProps = {
            fullscreenChange: "MSFullscreenChange",
            requestFullscreen: "msRequestFullscreen",
            exitFullscreen: "msExitFullscreen"
          };
        }
      }
    }
    Fullscreen2.prototype.close = function() {
      var fullscreen = this, chart = fullscreen.chart, optionsChart = chart.options.chart;
      if (fullscreen.isOpen && fullscreen.browserProps && chart.container.ownerDocument instanceof Document) {
        chart.container.ownerDocument[fullscreen.browserProps.exitFullscreen]();
      }
      if (fullscreen.unbindFullscreenEvent) {
        fullscreen.unbindFullscreenEvent = fullscreen.unbindFullscreenEvent();
      }
      chart.setSize(fullscreen.origWidth, fullscreen.origHeight, false);
      fullscreen.origWidth = void 0;
      fullscreen.origHeight = void 0;
      optionsChart.width = fullscreen.origWidthOption;
      optionsChart.height = fullscreen.origHeightOption;
      fullscreen.origWidthOption = void 0;
      fullscreen.origHeightOption = void 0;
      fullscreen.isOpen = false;
      fullscreen.setButtonText();
    };
    Fullscreen2.prototype.open = function() {
      var fullscreen = this, chart = fullscreen.chart, optionsChart = chart.options.chart;
      if (optionsChart) {
        fullscreen.origWidthOption = optionsChart.width;
        fullscreen.origHeightOption = optionsChart.height;
      }
      fullscreen.origWidth = chart.chartWidth;
      fullscreen.origHeight = chart.chartHeight;
      if (fullscreen.browserProps) {
        var unbindChange_1 = addEvent58(
          chart.container.ownerDocument,
          // chart's document
          fullscreen.browserProps.fullscreenChange,
          function() {
            if (fullscreen.isOpen) {
              fullscreen.isOpen = false;
              fullscreen.close();
            } else {
              chart.setSize(null, null, false);
              fullscreen.isOpen = true;
              fullscreen.setButtonText();
            }
          }
        );
        var unbindDestroy_1 = addEvent58(chart, "destroy", unbindChange_1);
        fullscreen.unbindFullscreenEvent = function() {
          unbindChange_1();
          unbindDestroy_1();
        };
        var promise = chart.renderTo[fullscreen.browserProps.requestFullscreen]();
        if (promise) {
          promise["catch"](function() {
            alert(
              // eslint-disable-line no-alert
              "Full screen is not supported inside a frame."
            );
          });
        }
      }
    };
    Fullscreen2.prototype.setButtonText = function() {
      var chart = this.chart, exportDivElements = chart.exportDivElements, exportingOptions = chart.options.exporting, menuItems = exportingOptions && exportingOptions.buttons && exportingOptions.buttons.contextButton.menuItems, lang2 = chart.options.lang;
      if (exportingOptions && exportingOptions.menuItemDefinitions && lang2 && lang2.exitFullscreen && lang2.viewFullscreen && menuItems && exportDivElements) {
        var exportDivElement = exportDivElements[menuItems.indexOf("viewFullscreen")];
        if (exportDivElement) {
          AST_default.setElementHTML(exportDivElement, !this.isOpen ? exportingOptions.menuItemDefinitions.viewFullscreen.text || lang2.viewFullscreen : lang2.exitFullscreen);
        }
      }
    };
    Fullscreen2.prototype.toggle = function() {
      var fullscreen = this;
      if (!fullscreen.isOpen) {
        fullscreen.open();
      } else {
        fullscreen.close();
      }
    };
    return Fullscreen2;
  }()
);
Globals_default.Fullscreen = Fullscreen;
var FullScreen_default = Globals_default.Fullscreen;
addEvent58(Chart_default, "beforeRender", function() {
  this.fullscreen = new Globals_default.Fullscreen(this);
});

// node_modules/highcharts/es-modules/Extensions/Exporting/ExportingDefaults.js
var isTouchDevice5 = Globals_default.isTouchDevice;
var exporting = {
  /**
   * Experimental setting to allow HTML inside the chart (added through
   * the `useHTML` options), directly in the exported image. This allows
   * you to preserve complicated HTML structures like tables or bi-directional
   * text in exported charts.
   *
   * Disclaimer: The HTML is rendered in a `foreignObject` tag in the
   * generated SVG. The official export server is based on PhantomJS,
   * which supports this, but other SVG clients, like Batik, does not
   * support it. This also applies to downloaded SVG that you want to
   * open in a desktop client.
   *
   * @type      {boolean}
   * @default   false
   * @since     4.1.8
   * @apioption exporting.allowHTML
   */
  /**
   * Additional chart options to be merged into the chart before exporting to
   * an image format. This does not apply to printing the chart via the export
   * menu.
   *
   * For example, a common use case is to add data labels to improve
   * readability of the exported chart, or to add a printer-friendly color
   * scheme to exported PDFs.
   *
   * @sample {highcharts} highcharts/exporting/chartoptions-data-labels/
   *         Added data labels
   * @sample {highstock} highcharts/exporting/chartoptions-data-labels/
   *         Added data labels
   *
   * @type      {Highcharts.Options}
   * @apioption exporting.chartOptions
   */
  /**
   * Whether to enable the exporting module. Disabling the module will
   * hide the context button, but API methods will still be available.
   *
   * @sample {highcharts} highcharts/exporting/enabled-false/
   *         Exporting module is loaded but disabled
   * @sample {highstock} highcharts/exporting/enabled-false/
   *         Exporting module is loaded but disabled
   *
   * @type      {boolean}
   * @default   true
   * @since     2.0
   * @apioption exporting.enabled
   */
  /**
   * Function to call if the offline-exporting module fails to export
   * a chart on the client side, and [fallbackToExportServer](
   * #exporting.fallbackToExportServer) is disabled. If left undefined, an
   * exception is thrown instead. Receives two parameters, the exporting
   * options, and the error from the module.
   *
   * @see [fallbackToExportServer](#exporting.fallbackToExportServer)
   *
   * @type      {Highcharts.ExportingErrorCallbackFunction}
   * @since     5.0.0
   * @requires  modules/exporting
   * @requires  modules/offline-exporting
   * @apioption exporting.error
   */
  /**
   * Whether or not to fall back to the export server if the offline-exporting
   * module is unable to export the chart on the client side. This happens for
   * certain browsers, and certain features (e.g.
   * [allowHTML](#exporting.allowHTML)), depending on the image type exporting
   * to. For very complex charts, it is possible that export can fail in
   * browsers that don't support Blob objects, due to data URL length limits.
   * It is recommended to define the [exporting.error](#exporting.error)
   * handler if disabling fallback, in order to notify users in case export
   * fails.
   *
   * @type      {boolean}
   * @default   true
   * @since     4.1.8
   * @requires  modules/exporting
   * @requires  modules/offline-exporting
   * @apioption exporting.fallbackToExportServer
   */
  /**
   * The filename, without extension, to use for the exported chart.
   *
   * @sample {highcharts} highcharts/exporting/filename/
   *         Custom file name
   * @sample {highstock} highcharts/exporting/filename/
   *         Custom file name
   *
   * @type      {string}
   * @default   chart
   * @since     2.0
   * @apioption exporting.filename
   */
  /**
   * An object containing additional key value data for the POST form that
   * sends the SVG to the export server. For example, a `target` can be set to
   * make sure the generated image is received in another frame, or a custom
   * `enctype` or `encoding` can be set.
   *
   * @type      {Highcharts.HTMLAttributes}
   * @since     3.0.8
   * @apioption exporting.formAttributes
   */
  /**
   * Path where Highcharts will look for export module dependencies to
   * load on demand if they don't already exist on `window`. Should currently
   * point to location of [CanVG](https://github.com/canvg/canvg) library,
   * [jsPDF](https://github.com/yWorks/jsPDF) and
   * [svg2pdf.js](https://github.com/yWorks/svg2pdf.js), required for client
   * side export in certain browsers.
   *
   * @type      {string}
   * @default   https://code.highcharts.com/{version}/lib
   * @since     5.0.0
   * @apioption exporting.libURL
   */
  /**
   * Analogous to [sourceWidth](#exporting.sourceWidth).
   *
   * @type      {number}
   * @since     3.0
   * @apioption exporting.sourceHeight
   */
  /**
   * The width of the original chart when exported, unless an explicit
   * [chart.width](#chart.width) is set, or a pixel width is set on the
   * container. The width exported raster image is then multiplied by
   * [scale](#exporting.scale).
   *
   * @sample {highcharts} highcharts/exporting/sourcewidth/
   *         Source size demo
   * @sample {highstock} highcharts/exporting/sourcewidth/
   *         Source size demo
   * @sample {highmaps} maps/exporting/sourcewidth/
   *         Source size demo
   *
   * @type      {number}
   * @since     3.0
   * @apioption exporting.sourceWidth
   */
  /**
   * The pixel width of charts exported to PNG or JPG. As of Highcharts
   * 3.0, the default pixel width is a function of the [chart.width](
   * #chart.width) or [exporting.sourceWidth](#exporting.sourceWidth) and the
   * [exporting.scale](#exporting.scale).
   *
   * @sample {highcharts} highcharts/exporting/width/
   *         Export to 200px wide images
   * @sample {highstock} highcharts/exporting/width/
   *         Export to 200px wide images
   *
   * @type      {number}
   * @since     2.0
   * @apioption exporting.width
   */
  /**
   * Default MIME type for exporting if `chart.exportChart()` is called
   * without specifying a `type` option. Possible values are `image/png`,
   *  `image/jpeg`, `application/pdf` and `image/svg+xml`.
   *
   * @type  {Highcharts.ExportingMimeTypeValue}
   * @since 2.0
   */
  type: "image/png",
  /**
   * The URL for the server module converting the SVG string to an image
   * format. By default this points to Highchart's free web service.
   *
   * @since 2.0
   */
  url: "https://export.highcharts.com/",
  /**
   * When printing the chart from the menu item in the burger menu, if
   * the on-screen chart exceeds this width, it is resized. After printing
   * or cancelled, it is restored. The default width makes the chart
   * fit into typical paper format. Note that this does not affect the
   * chart when printing the web page as a whole.
   *
   * @since 4.2.5
   */
  printMaxWidth: 780,
  /**
   * Defines the scale or zoom factor for the exported image compared
   * to the on-screen display. While for instance a 600px wide chart
   * may look good on a website, it will look bad in print. The default
   * scale of 2 makes this chart export to a 1200px PNG or JPG.
   *
   * @see [chart.width](#chart.width)
   * @see [exporting.sourceWidth](#exporting.sourceWidth)
   *
   * @sample {highcharts} highcharts/exporting/scale/
   *         Scale demonstrated
   * @sample {highstock} highcharts/exporting/scale/
   *         Scale demonstrated
   * @sample {highmaps} maps/exporting/scale/
   *         Scale demonstrated
   *
   * @since 3.0
   */
  scale: 2,
  /**
   * Options for the export related buttons, print and export. In addition
   * to the default buttons listed here, custom buttons can be added.
   * See [navigation.buttonOptions](#navigation.buttonOptions) for general
   * options.
   *
   * @type     {Highcharts.Dictionary<*>}
   * @requires modules/exporting
   */
  buttons: {
    /**
     * Options for the export button.
     *
     * In styled mode, export button styles can be applied with the
     * `.highcharts-contextbutton` class.
     *
     * @declare  Highcharts.ExportingButtonsOptionsObject
     * @extends  navigation.buttonOptions
     * @requires modules/exporting
     */
    contextButton: {
      /**
       * A click handler callback to use on the button directly instead of
       * the popup menu.
       *
       * @sample highcharts/exporting/buttons-contextbutton-onclick/
       *         Skip the menu and export the chart directly
       *
       * @type      {Function}
       * @since     2.0
       * @apioption exporting.buttons.contextButton.onclick
       */
      /**
       * See [navigation.buttonOptions.symbolFill](
       * #navigation.buttonOptions.symbolFill).
       *
       * @type      {Highcharts.ColorString}
       * @default   #666666
       * @since     2.0
       * @apioption exporting.buttons.contextButton.symbolFill
       */
      /**
       * The horizontal position of the button relative to the `align`
       * option.
       *
       * @type      {number}
       * @default   -10
       * @since     2.0
       * @apioption exporting.buttons.contextButton.x
       */
      /**
       * The class name of the context button.
       */
      className: "highcharts-contextbutton",
      /**
       * The class name of the menu appearing from the button.
       */
      menuClassName: "highcharts-contextmenu",
      /**
       * The symbol for the button. Points to a definition function in
       * the `Highcharts.Renderer.symbols` collection. The default
       * `menu` function is part of the exporting module. Possible
       * values are "circle", "square", "diamond", "triangle",
       * "triangle-down", "menu", "menuball" or custom shape.
       *
       * @sample highcharts/exporting/buttons-contextbutton-symbol/
       *         Use a circle for symbol
       * @sample highcharts/exporting/buttons-contextbutton-symbol-custom/
       *         Custom shape as symbol
       *
       * @type  {Highcharts.SymbolKeyValue|"menu"|"menuball"|string}
       * @since 2.0
       */
      symbol: "menu",
      /**
       * The key to a [lang](#lang) option setting that is used for the
       * button's title tooltip. When the key is `contextButtonTitle`, it
       * refers to [lang.contextButtonTitle](#lang.contextButtonTitle)
       * that defaults to "Chart context menu".
       *
       * @since 6.1.4
       */
      titleKey: "contextButtonTitle",
      /**
       * This option is deprecated, use
       * [titleKey](#exporting.buttons.contextButton.titleKey) instead.
       *
       * @deprecated
       * @type      {string}
       * @apioption exporting.buttons.contextButton._titleKey
       */
      /**
       * A collection of strings pointing to config options for the menu
       * items. The config options are defined in the
       * `menuItemDefinitions` option.
       *
       * By default, there is the "View in full screen" and "Print" menu
       * items, plus one menu item for each of the available export types.
       *
       * @sample {highcharts} highcharts/exporting/menuitemdefinitions/
       *         Menu item definitions
       * @sample {highstock} highcharts/exporting/menuitemdefinitions/
       *         Menu item definitions
       * @sample {highmaps} highcharts/exporting/menuitemdefinitions/
       *         Menu item definitions
       *
       * @type    {Array<string>}
       * @default ["viewFullscreen", "printChart", "separator", "downloadPNG", "downloadJPEG", "downloadPDF", "downloadSVG"]
       * @since   2.0
       */
      menuItems: [
        "viewFullscreen",
        "printChart",
        "separator",
        "downloadPNG",
        "downloadJPEG",
        "downloadPDF",
        "downloadSVG"
      ]
    }
  },
  /**
   * An object consisting of definitions for the menu items in the context
   * menu. Each key value pair has a `key` that is referenced in the
   * [menuItems](#exporting.buttons.contextButton.menuItems) setting,
   * and a `value`, which is an object with the following properties:
   *
   * - **onclick:** The click handler for the menu item
   *
   * - **text:** The text for the menu item
   *
   * - **textKey:** If internationalization is required, the key to a language
   *   string
   *
   * Custom text for the "exitFullScreen" can be set only in lang options
   * (it is not a separate button).
   *
   * @sample {highcharts} highcharts/exporting/menuitemdefinitions/
   *         Menu item definitions
   * @sample {highstock} highcharts/exporting/menuitemdefinitions/
   *         Menu item definitions
   * @sample {highmaps} highcharts/exporting/menuitemdefinitions/
   *         Menu item definitions
   *
   *
   * @type    {Highcharts.Dictionary<Highcharts.ExportingMenuObject>}
   * @default {"viewFullscreen": {}, "printChart": {}, "separator": {}, "downloadPNG": {}, "downloadJPEG": {}, "downloadPDF": {}, "downloadSVG": {}}
   * @since   5.0.13
   */
  menuItemDefinitions: {
    /**
     * @ignore
     */
    viewFullscreen: {
      textKey: "viewFullscreen",
      onclick: function() {
        this.fullscreen.toggle();
      }
    },
    /**
     * @ignore
     */
    printChart: {
      textKey: "printChart",
      onclick: function() {
        this.print();
      }
    },
    /**
     * @ignore
     */
    separator: {
      separator: true
    },
    /**
     * @ignore
     */
    downloadPNG: {
      textKey: "downloadPNG",
      onclick: function() {
        this.exportChart();
      }
    },
    /**
     * @ignore
     */
    downloadJPEG: {
      textKey: "downloadJPEG",
      onclick: function() {
        this.exportChart({
          type: "image/jpeg"
        });
      }
    },
    /**
     * @ignore
     */
    downloadPDF: {
      textKey: "downloadPDF",
      onclick: function() {
        this.exportChart({
          type: "application/pdf"
        });
      }
    },
    /**
     * @ignore
     */
    downloadSVG: {
      textKey: "downloadSVG",
      onclick: function() {
        this.exportChart({
          type: "image/svg+xml"
        });
      }
    }
  }
};
var lang = {
  /**
   * Exporting module only. The text for the menu item to view the chart
   * in full screen.
   *
   * @since 8.0.1
   *
   * @private
   */
  viewFullscreen: "View in full screen",
  /**
   * Exporting module only. The text for the menu item to exit the chart
   * from full screen.
   *
   * @since 8.0.1
   *
   * @private
   */
  exitFullscreen: "Exit from full screen",
  /**
   * Exporting module only. The text for the menu item to print the chart.
   *
   * @since    3.0.1
   * @requires modules/exporting
   *
   * @private
   */
  printChart: "Print chart",
  /**
   * Exporting module only. The text for the PNG download menu item.
   *
   * @since    2.0
   * @requires modules/exporting
   *
   * @private
   */
  downloadPNG: "Download PNG image",
  /**
   * Exporting module only. The text for the JPEG download menu item.
   *
   * @since    2.0
   * @requires modules/exporting
   *
   * @private
   */
  downloadJPEG: "Download JPEG image",
  /**
   * Exporting module only. The text for the PDF download menu item.
   *
   * @since    2.0
   * @requires modules/exporting
   *
   * @private
   */
  downloadPDF: "Download PDF document",
  /**
   * Exporting module only. The text for the SVG download menu item.
   *
   * @since    2.0
   * @requires modules/exporting
   *
   * @private
   */
  downloadSVG: "Download SVG vector image",
  /**
   * Exporting module menu. The tooltip title for the context menu holding
   * print and export menu items.
   *
   * @since    3.0
   * @requires modules/exporting
   *
   * @private
   */
  contextButtonTitle: "Chart context menu"
};
var navigation = {
  /**
   * A collection of options for buttons appearing in the exporting
   * module.
   *
   * In styled mode, the buttons are styled with the
   * `.highcharts-contextbutton` and `.highcharts-button-symbol` classes.
   *
   * @requires modules/exporting
   *
   * @private
   */
  buttonOptions: {
    /**
     * Whether to enable buttons.
     *
     * @sample highcharts/navigation/buttonoptions-enabled/
     *         Exporting module loaded but buttons disabled
     *
     * @type      {boolean}
     * @default   true
     * @since     2.0
     * @apioption navigation.buttonOptions.enabled
     */
    /**
     * The pixel size of the symbol on the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    symbolSize: 14,
    /**
     * The x position of the center of the symbol inside the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    symbolX: 12.5,
    /**
     * The y position of the center of the symbol inside the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    symbolY: 10.5,
    /**
     * Alignment for the buttons.
     *
     * @sample highcharts/navigation/buttonoptions-align/
     *         Center aligned
     *
     * @type  {Highcharts.AlignValue}
     * @since 2.0
     */
    align: "right",
    /**
     * The pixel spacing between buttons.
     *
     * @since 2.0
     */
    buttonSpacing: 3,
    /**
     * Pixel height of the buttons.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    height: 22,
    /**
     * A text string to add to the individual button.
     *
     * @sample highcharts/exporting/buttons-text/
     *         Full text button
     * @sample highcharts/exporting/buttons-text-symbol/
     *         Combined symbol and text
     *
     * @type      {string}
     * @default   null
     * @since     3.0
     * @apioption navigation.buttonOptions.text
     */
    /**
     * The vertical offset of the button's position relative to its
     * `verticalAlign`.
     *
     * @sample highcharts/navigation/buttonoptions-verticalalign/
     *         Buttons at lower right
     *
     * @type      {number}
     * @default   0
     * @since     2.0
     * @apioption navigation.buttonOptions.y
     */
    /**
     * The vertical alignment of the buttons. Can be one of `"top"`,
     * `"middle"` or `"bottom"`.
     *
     * @sample highcharts/navigation/buttonoptions-verticalalign/
     *         Buttons at lower right
     *
     * @type  {Highcharts.VerticalAlignValue}
     * @since 2.0
     */
    verticalAlign: "top",
    /**
     * The pixel width of the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    width: 24,
    /**
     * Fill color for the symbol within the button.
     *
     * @sample highcharts/navigation/buttonoptions-symbolfill/
     *         Blue symbol stroke for one of the buttons
     *
     * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @since 2.0
     */
    symbolFill: Palette_default.neutralColor60,
    /**
     * The color of the symbol's stroke or line.
     *
     * @sample highcharts/navigation/buttonoptions-symbolstroke/
     *         Blue symbol stroke
     *
     * @type  {Highcharts.ColorString}
     * @since 2.0
     */
    symbolStroke: Palette_default.neutralColor60,
    /**
     * The pixel stroke width of the symbol on the button.
     *
     * @sample highcharts/navigation/buttonoptions-height/
     *         Bigger buttons
     *
     * @since 2.0
     */
    symbolStrokeWidth: 3,
    /**
     * A configuration object for the button theme. The object accepts
     * SVG properties like `stroke-width`, `stroke` and `fill`.
     * Tri-state button styles are supported by the `states.hover` and
     * `states.select` objects.
     *
     * @sample highcharts/navigation/buttonoptions-theme/
     *         Theming the buttons
     *
     * @requires modules/exporting
     *
     * @since 3.0
     */
    theme: {
      /**
       * The default fill exists only to capture hover events.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @default   ${palette.backgroundColor}
       * @apioption navigation.buttonOptions.theme.fill
       */
      /**
       * Default stroke for the buttons.
       * @type      {Highcharts.ColorString}
       * @default   none
       * @apioption navigation.buttonOptions.theme.stroke
       */
      /**
       * Padding for the button.
       */
      padding: 5
    }
  },
  /**
   * CSS styles for the popup menu appearing by default when the export
   * icon is clicked. This menu is rendered in HTML.
   *
   * @see In styled mode, the menu is styled with the `.highcharts-menu`
   *      class.
   *
   * @sample highcharts/navigation/menustyle/
   *         Light gray menu background
   *
   * @type    {Highcharts.CSSObject}
   * @default {"border": "1px solid #999999", "background": "#ffffff", "padding": "5px 0"}
   * @since   2.0
   *
   * @private
   */
  menuStyle: {
    /** @ignore-option */
    border: "1px solid " + Palette_default.neutralColor40,
    /** @ignore-option */
    background: Palette_default.backgroundColor,
    /** @ignore-option */
    padding: "5px 0"
  },
  /**
   * CSS styles for the individual items within the popup menu appearing
   * by default when the export icon is clicked. The menu items are
   * rendered in HTML. Font size defaults to `11px` on desktop and `14px`
   * on touch devices.
   *
   * @see In styled mode, the menu items are styled with the
   *      `.highcharts-menu-item` class.
   *
   * @sample {highcharts} highcharts/navigation/menuitemstyle/
   *         Add a grey stripe to the left
   *
   * @type    {Highcharts.CSSObject}
   * @default {"padding": "0.5em 1em", "color": "#333333", "background": "none", "fontSize": "11px/14px", "transition": "background 250ms, color 250ms"}
   * @since   2.0
   *
   * @private
   */
  menuItemStyle: {
    /** @ignore-option */
    padding: "0.5em 1em",
    /** @ignore-option */
    color: Palette_default.neutralColor80,
    /** @ignore-option */
    background: "none",
    /** @ignore-option */
    fontSize: isTouchDevice5 ? "14px" : "11px",
    /** @ignore-option */
    transition: "background 250ms, color 250ms"
  },
  /**
   * CSS styles for the hover state of the individual items within the
   * popup menu appearing by default when the export icon is clicked. The
   * menu items are rendered in HTML.
   *
   * @see In styled mode, the menu items are styled with the
   *      `.highcharts-menu-item` class.
   *
   * @sample highcharts/navigation/menuitemhoverstyle/
   *         Bold text on hover
   *
   * @type    {Highcharts.CSSObject}
   * @default {"background": "#335cad", "color": "#ffffff"}
   * @since   2.0
   *
   * @private
   */
  menuItemHoverStyle: {
    /** @ignore-option */
    background: Palette_default.highlightColor80,
    /** @ignore-option */
    color: Palette_default.backgroundColor
  }
};
var ExportingDefaults = {
  exporting,
  lang,
  navigation
};
var ExportingDefaults_default = ExportingDefaults;

// node_modules/highcharts/es-modules/Extensions/Exporting/ExportingSymbols.js
var ExportingSymbols;
(function(ExportingSymbols2) {
  var modifiedClasses = [];
  function compose(SVGRendererClass) {
    if (modifiedClasses.indexOf(SVGRendererClass) === -1) {
      modifiedClasses.push(SVGRendererClass);
      var symbols5 = SVGRendererClass.prototype.symbols;
      symbols5.menu = menu;
      symbols5.menuball = menuball.bind(symbols5);
    }
  }
  ExportingSymbols2.compose = compose;
  function menu(x, y, width, height) {
    var arr = [
      ["M", x, y + 2.5],
      ["L", x + width, y + 2.5],
      ["M", x, y + height / 2 + 0.5],
      ["L", x + width, y + height / 2 + 0.5],
      ["M", x, y + height - 1.5],
      ["L", x + width, y + height - 1.5]
    ];
    return arr;
  }
  function menuball(x, y, width, height) {
    var h = height / 3 - 2;
    var path = [];
    path = path.concat(this.circle(width - h, y, h, h), this.circle(width - h, y + h + 4, h, h), this.circle(width - h, y + 2 * (h + 4), h, h));
    return path;
  }
})(ExportingSymbols || (ExportingSymbols = {}));
var ExportingSymbols_default = ExportingSymbols;

// node_modules/highcharts/es-modules/Extensions/Exporting/Exporting.js
var defaultOptions15 = DefaultOptions_default.defaultOptions;
var doc24 = Globals_default.doc;
var win17 = Globals_default.win;
var addEvent59 = Utilities_default.addEvent;
var css14 = Utilities_default.css;
var createElement12 = Utilities_default.createElement;
var discardElement8 = Utilities_default.discardElement;
var extend74 = Utilities_default.extend;
var find17 = Utilities_default.find;
var fireEvent35 = Utilities_default.fireEvent;
var isObject12 = Utilities_default.isObject;
var merge75 = Utilities_default.merge;
var objectEach36 = Utilities_default.objectEach;
var pick85 = Utilities_default.pick;
var removeEvent13 = Utilities_default.removeEvent;
var uniqueKey9 = Utilities_default.uniqueKey;
var Exporting;
(function(Exporting2) {
  var composedClasses2 = [];
  var inlineBlacklist = [
    /-/,
    /^(clipPath|cssText|d|height|width)$/,
    /^font$/,
    /[lL]ogical(Width|Height)$/,
    /perspective/,
    /TapHighlightColor/,
    /^transition/,
    /^length$/
    // #7700
    // /^text (border|color|cursor|height|webkitBorder)/
  ];
  var inlineToAttributes = [
    "fill",
    "stroke",
    "strokeLinecap",
    "strokeLinejoin",
    "strokeWidth",
    "textAnchor",
    "x",
    "y"
  ];
  Exporting2.inlineWhitelist = [];
  var unstyledElements = [
    "clipPath",
    "defs",
    "desc"
  ];
  var printingChart;
  function addButton(options) {
    var chart = this, renderer = chart.renderer, btnOptions = merge75(chart.options.navigation.buttonOptions, options), onclick = btnOptions.onclick, menuItems = btnOptions.menuItems, symbolSize = btnOptions.symbolSize || 12;
    var symbol;
    if (!chart.btnCount) {
      chart.btnCount = 0;
    }
    if (!chart.exportDivElements) {
      chart.exportDivElements = [];
      chart.exportSVGElements = [];
    }
    if (btnOptions.enabled === false || !btnOptions.theme) {
      return;
    }
    var attr11 = btnOptions.theme, states = attr11.states, hover = states && states.hover, select = states && states.select;
    var callback;
    if (!chart.styledMode) {
      attr11.fill = pick85(attr11.fill, Palette_default.backgroundColor);
      attr11.stroke = pick85(attr11.stroke, "none");
    }
    delete attr11.states;
    if (onclick) {
      callback = function(e2) {
        if (e2) {
          e2.stopPropagation();
        }
        onclick.call(chart, e2);
      };
    } else if (menuItems) {
      callback = function(e2) {
        if (e2) {
          e2.stopPropagation();
        }
        chart.contextMenu(button.menuClassName, menuItems, button.translateX, button.translateY, button.width, button.height, button);
        button.setState(2);
      };
    }
    if (btnOptions.text && btnOptions.symbol) {
      attr11.paddingLeft = pick85(attr11.paddingLeft, 30);
    } else if (!btnOptions.text) {
      extend74(attr11, {
        width: btnOptions.width,
        height: btnOptions.height,
        padding: 0
      });
    }
    if (!chart.styledMode) {
      attr11["stroke-linecap"] = "round";
      attr11.fill = pick85(attr11.fill, Palette_default.backgroundColor);
      attr11.stroke = pick85(attr11.stroke, "none");
    }
    var button = renderer.button(btnOptions.text, 0, 0, callback, attr11, hover, select).addClass(options.className).attr({
      title: pick85(chart.options.lang[btnOptions._titleKey || btnOptions.titleKey], "")
    });
    button.menuClassName = options.menuClassName || "highcharts-menu-" + chart.btnCount++;
    if (btnOptions.symbol) {
      symbol = renderer.symbol(
        btnOptions.symbol,
        btnOptions.symbolX - symbolSize / 2,
        btnOptions.symbolY - symbolSize / 2,
        symbolSize,
        symbolSize,
        {
          width: symbolSize,
          height: symbolSize
        }
      ).addClass("highcharts-button-symbol").attr({
        zIndex: 1
      }).add(button);
      if (!chart.styledMode) {
        symbol.attr({
          stroke: btnOptions.symbolStroke,
          fill: btnOptions.symbolFill,
          "stroke-width": btnOptions.symbolStrokeWidth || 1
        });
      }
    }
    button.add(chart.exportingGroup).align(extend74(btnOptions, {
      width: button.width,
      x: pick85(btnOptions.x, chart.buttonOffset)
      // #1654
    }), true, "spacingBox");
    chart.buttonOffset += (button.width + btnOptions.buttonSpacing) * (btnOptions.align === "right" ? -1 : 1);
    chart.exportSVGElements.push(button, symbol);
  }
  function afterPrint() {
    var chart = this;
    if (!chart.printReverseInfo) {
      return void 0;
    }
    var _a15 = chart.printReverseInfo, childNodes = _a15.childNodes, origDisplay = _a15.origDisplay, resetParams = _a15.resetParams;
    chart.moveContainers(chart.renderTo);
    [].forEach.call(childNodes, function(node, i) {
      if (node.nodeType === 1) {
        node.style.display = origDisplay[i] || "";
      }
    });
    chart.isPrinting = false;
    if (resetParams) {
      chart.setSize.apply(chart, resetParams);
    }
    delete chart.printReverseInfo;
    printingChart = void 0;
    fireEvent35(chart, "afterPrint");
  }
  function beforePrint() {
    var chart = this, body = doc24.body, printMaxWidth = chart.options.exporting.printMaxWidth, printReverseInfo = {
      childNodes: body.childNodes,
      origDisplay: [],
      resetParams: void 0
    };
    chart.isPrinting = true;
    chart.pointer.reset(null, 0);
    fireEvent35(chart, "beforePrint");
    var handleMaxWidth = printMaxWidth && chart.chartWidth > printMaxWidth;
    if (handleMaxWidth) {
      printReverseInfo.resetParams = [
        chart.options.chart.width,
        void 0,
        false
      ];
      chart.setSize(printMaxWidth, void 0, false);
    }
    [].forEach.call(printReverseInfo.childNodes, function(node, i) {
      if (node.nodeType === 1) {
        printReverseInfo.origDisplay[i] = node.style.display;
        node.style.display = "none";
      }
    });
    chart.moveContainers(body);
    chart.printReverseInfo = printReverseInfo;
  }
  function chartCallback(chart) {
    var composition = chart;
    composition.renderExporting();
    addEvent59(chart, "redraw", composition.renderExporting);
    addEvent59(chart, "destroy", composition.destroyExport);
  }
  function compose(ChartClass, SVGRendererClass) {
    ExportingSymbols_default.compose(SVGRendererClass);
    if (composedClasses2.indexOf(ChartClass) === -1) {
      composedClasses2.push(ChartClass);
      var chartProto2 = ChartClass.prototype;
      chartProto2.afterPrint = afterPrint;
      chartProto2.exportChart = exportChart;
      chartProto2.inlineStyles = inlineStyles;
      chartProto2.print = print;
      chartProto2.sanitizeSVG = sanitizeSVG;
      chartProto2.getChartHTML = getChartHTML;
      chartProto2.getSVG = getSVG;
      chartProto2.getSVGForExport = getSVGForExport;
      chartProto2.getFilename = getFilename;
      chartProto2.moveContainers = moveContainers;
      chartProto2.beforePrint = beforePrint;
      chartProto2.contextMenu = contextMenu;
      chartProto2.addButton = addButton;
      chartProto2.destroyExport = destroyExport;
      chartProto2.renderExporting = renderExporting;
      chartProto2.callbacks.push(chartCallback);
      addEvent59(ChartClass, "init", onChartInit);
      if (Globals_default.isSafari) {
        Globals_default.win.matchMedia("print").addListener(function(mqlEvent) {
          if (!printingChart) {
            return void 0;
          }
          if (mqlEvent.matches) {
            printingChart.beforePrint();
          } else {
            printingChart.afterPrint();
          }
        });
      }
    }
  }
  Exporting2.compose = compose;
  function contextMenu(className, items, x, y, width, height, button) {
    var chart = this, navOptions = chart.options.navigation, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, cacheName = "cache-" + className, menuPadding = Math.max(width, height);
    var innerMenu, menu = chart[cacheName];
    if (!menu) {
      chart.exportContextMenu = chart[cacheName] = menu = createElement12("div", {
        className
      }, {
        position: "absolute",
        zIndex: 1e3,
        padding: menuPadding + "px",
        pointerEvents: "auto"
      }, chart.fixedDiv || chart.container);
      innerMenu = createElement12("ul", { className: "highcharts-menu" }, {
        listStyle: "none",
        margin: 0,
        padding: 0
      }, menu);
      if (!chart.styledMode) {
        css14(innerMenu, extend74({
          MozBoxShadow: "3px 3px 10px #888",
          WebkitBoxShadow: "3px 3px 10px #888",
          boxShadow: "3px 3px 10px #888"
        }, navOptions.menuStyle));
      }
      menu.hideMenu = function() {
        css14(menu, { display: "none" });
        if (button) {
          button.setState(0);
        }
        chart.openMenu = false;
        css14(chart.renderTo, { overflow: "hidden" });
        css14(chart.container, { overflow: "hidden" });
        Utilities_default.clearTimeout(menu.hideTimer);
        fireEvent35(chart, "exportMenuHidden");
      };
      chart.exportEvents.push(
        addEvent59(menu, "mouseleave", function() {
          menu.hideTimer = win17.setTimeout(menu.hideMenu, 500);
        }),
        addEvent59(menu, "mouseenter", function() {
          Utilities_default.clearTimeout(menu.hideTimer);
        }),
        // Hide it on clicking or touching outside the menu (#2258,
        // #2335, #2407)
        addEvent59(doc24, "mouseup", function(e2) {
          if (!chart.pointer.inClass(e2.target, className)) {
            menu.hideMenu();
          }
        }),
        addEvent59(menu, "click", function() {
          if (chart.openMenu) {
            menu.hideMenu();
          }
        })
      );
      items.forEach(function(item) {
        if (typeof item === "string") {
          item = chart.options.exporting.menuItemDefinitions[item];
        }
        if (isObject12(item, true)) {
          var element = void 0;
          if (item.separator) {
            element = createElement12("hr", void 0, void 0, innerMenu);
          } else {
            if (item.textKey === "viewData" && chart.isDataTableVisible) {
              item.textKey = "hideData";
            }
            element = createElement12("li", {
              className: "highcharts-menu-item",
              onclick: function(e2) {
                if (e2) {
                  e2.stopPropagation();
                }
                menu.hideMenu();
                if (item.onclick) {
                  item.onclick.apply(chart, arguments);
                }
              }
            }, void 0, innerMenu);
            AST_default.setElementHTML(element, item.text || chart.options.lang[item.textKey]);
            if (!chart.styledMode) {
              element.onmouseover = function() {
                css14(this, navOptions.menuItemHoverStyle);
              };
              element.onmouseout = function() {
                css14(this, navOptions.menuItemStyle);
              };
              css14(element, extend74({
                cursor: "pointer"
              }, navOptions.menuItemStyle));
            }
          }
          chart.exportDivElements.push(element);
        }
      });
      chart.exportDivElements.push(innerMenu, menu);
      chart.exportMenuWidth = menu.offsetWidth;
      chart.exportMenuHeight = menu.offsetHeight;
    }
    var menuStyle = { display: "block" };
    if (x + chart.exportMenuWidth > chartWidth) {
      menuStyle.right = chartWidth - x - width - menuPadding + "px";
    } else {
      menuStyle.left = x - menuPadding + "px";
    }
    if (y + height + chart.exportMenuHeight > chartHeight && button.alignOptions.verticalAlign !== "top") {
      menuStyle.bottom = chartHeight - y - menuPadding + "px";
    } else {
      menuStyle.top = y + height - menuPadding + "px";
    }
    css14(menu, menuStyle);
    css14(chart.renderTo, { overflow: "" });
    css14(chart.container, { overflow: "" });
    chart.openMenu = true;
    fireEvent35(chart, "exportMenuShown");
  }
  function destroyExport(e2) {
    var chart = e2 ? e2.target : this, exportSVGElements = chart.exportSVGElements, exportDivElements = chart.exportDivElements, exportEvents = chart.exportEvents;
    var cacheName;
    if (exportSVGElements) {
      exportSVGElements.forEach(function(elem, i) {
        if (elem) {
          elem.onclick = elem.ontouchstart = null;
          cacheName = "cache-" + elem.menuClassName;
          if (chart[cacheName]) {
            delete chart[cacheName];
          }
          exportSVGElements[i] = elem.destroy();
        }
      });
      exportSVGElements.length = 0;
    }
    if (chart.exportingGroup) {
      chart.exportingGroup.destroy();
      delete chart.exportingGroup;
    }
    if (exportDivElements) {
      exportDivElements.forEach(function(elem, i) {
        if (elem) {
          Utilities_default.clearTimeout(elem.hideTimer);
          removeEvent13(elem, "mouseleave");
          exportDivElements[i] = elem.onmouseout = elem.onmouseover = elem.ontouchstart = elem.onclick = null;
          discardElement8(elem);
        }
      });
      exportDivElements.length = 0;
    }
    if (exportEvents) {
      exportEvents.forEach(function(unbind) {
        unbind();
      });
      exportEvents.length = 0;
    }
  }
  function exportChart(exportingOptions, chartOptions) {
    var svg7 = this.getSVGForExport(exportingOptions, chartOptions);
    exportingOptions = merge75(this.options.exporting, exportingOptions);
    HttpUtilities_default.post(exportingOptions.url, {
      filename: exportingOptions.filename ? exportingOptions.filename.replace(/\//g, "-") : this.getFilename(),
      type: exportingOptions.type,
      // IE8 fails to post undefined correctly, so use 0
      width: exportingOptions.width || 0,
      scale: exportingOptions.scale,
      svg: svg7
    }, exportingOptions.formAttributes);
  }
  function getChartHTML() {
    if (this.styledMode) {
      this.inlineStyles();
    }
    return this.container.innerHTML;
  }
  function getFilename() {
    var s = this.userOptions.title && this.userOptions.title.text;
    var filename = this.options.exporting.filename;
    if (filename) {
      return filename.replace(/\//g, "-");
    }
    if (typeof s === "string") {
      filename = s.toLowerCase().replace(/<\/?[^>]+(>|$)/g, "").replace(/[\s_]+/g, "-").replace(/[^a-z0-9\-]/g, "").replace(/^[\-]+/g, "").replace(/[\-]+/g, "-").substr(0, 24).replace(/[\-]+$/g, "");
    }
    if (!filename || filename.length < 5) {
      filename = "chart";
    }
    return filename;
  }
  function getSVG(chartOptions) {
    var chart = this;
    var svg7, seriesOptions, options = merge75(chart.options, chartOptions);
    options.plotOptions = merge75(chart.userOptions.plotOptions, chartOptions && chartOptions.plotOptions);
    options.time = merge75(chart.userOptions.time, chartOptions && chartOptions.time);
    var sandbox = createElement12("div", null, {
      position: "absolute",
      top: "-9999em",
      width: chart.chartWidth + "px",
      height: chart.chartHeight + "px"
    }, doc24.body);
    var cssWidth = chart.renderTo.style.width, cssHeight = chart.renderTo.style.height, sourceWidth = options.exporting.sourceWidth || options.chart.width || /px$/.test(cssWidth) && parseInt(cssWidth, 10) || (options.isGantt ? 800 : 600), sourceHeight = options.exporting.sourceHeight || options.chart.height || /px$/.test(cssHeight) && parseInt(cssHeight, 10) || 400;
    extend74(options.chart, {
      animation: false,
      renderTo: sandbox,
      forExport: true,
      renderer: "SVGRenderer",
      width: sourceWidth,
      height: sourceHeight
    });
    options.exporting.enabled = false;
    delete options.data;
    options.series = [];
    chart.series.forEach(function(serie) {
      seriesOptions = merge75(serie.userOptions, {
        animation: false,
        enableMouseTracking: false,
        showCheckbox: false,
        visible: serie.visible
      });
      if (!seriesOptions.isInternal) {
        options.series.push(seriesOptions);
      }
    });
    var colls = {};
    chart.axes.forEach(function(axis) {
      if (!axis.userOptions.internalKey) {
        axis.userOptions.internalKey = uniqueKey9();
      }
      if (!axis.options.isInternal) {
        if (!colls[axis.coll]) {
          colls[axis.coll] = true;
          options[axis.coll] = [];
        }
        options[axis.coll].push(merge75(axis.userOptions, {
          visible: axis.visible
        }));
      }
    });
    var chartCopy = new Chart_default(options, chart.callback);
    if (chartOptions) {
      ["xAxis", "yAxis", "series"].forEach(function(coll) {
        var collOptions = {};
        if (chartOptions[coll]) {
          collOptions[coll] = chartOptions[coll];
          chartCopy.update(collOptions);
        }
      });
    }
    chart.axes.forEach(function(axis) {
      var axisCopy = find17(chartCopy.axes, function(copy) {
        return copy.options.internalKey === axis.userOptions.internalKey;
      }), extremes = axis.getExtremes(), userMin = extremes.userMin, userMax = extremes.userMax;
      if (axisCopy && (typeof userMin !== "undefined" && userMin !== axisCopy.min || typeof userMax !== "undefined" && userMax !== axisCopy.max)) {
        axisCopy.setExtremes(userMin, userMax, true, false);
      }
    });
    svg7 = chartCopy.getChartHTML();
    fireEvent35(this, "getSVG", { chartCopy });
    svg7 = chart.sanitizeSVG(svg7, options);
    options = null;
    chartCopy.destroy();
    discardElement8(sandbox);
    return svg7;
  }
  function getSVGForExport(options, chartOptions) {
    var chartExportingOptions = this.options.exporting;
    return this.getSVG(merge75({ chart: { borderRadius: 0 } }, chartExportingOptions.chartOptions, chartOptions, {
      exporting: {
        sourceWidth: options && options.sourceWidth || chartExportingOptions.sourceWidth,
        sourceHeight: options && options.sourceHeight || chartExportingOptions.sourceHeight
      }
    }));
  }
  function hyphenate(prop) {
    return prop.replace(/([A-Z])/g, function(a, b) {
      return "-" + b.toLowerCase();
    });
  }
  function inlineStyles() {
    var blacklist = inlineBlacklist, whitelist = Exporting2.inlineWhitelist, defaultStyles = {};
    var dummySVG;
    var iframe = doc24.createElement("iframe");
    css14(iframe, {
      width: "1px",
      height: "1px",
      visibility: "hidden"
    });
    doc24.body.appendChild(iframe);
    var iframeDoc = iframe.contentWindow.document;
    iframeDoc.open();
    iframeDoc.write('<svg xmlns="http://www.w3.org/2000/svg"></svg>');
    iframeDoc.close();
    function recurse(node) {
      var styles, parentStyles, cssText = "", dummy, styleAttr, blacklisted, whitelisted, i;
      function filterStyles(val, prop) {
        blacklisted = whitelisted = false;
        if (whitelist.length) {
          i = whitelist.length;
          while (i-- && !whitelisted) {
            whitelisted = whitelist[i].test(prop);
          }
          blacklisted = !whitelisted;
        }
        if (prop === "transform" && val === "none") {
          blacklisted = true;
        }
        i = blacklist.length;
        while (i-- && !blacklisted) {
          blacklisted = blacklist[i].test(prop) || typeof val === "function";
        }
        if (!blacklisted) {
          if ((parentStyles[prop] !== val || node.nodeName === "svg") && defaultStyles[node.nodeName][prop] !== val) {
            if (!inlineToAttributes || inlineToAttributes.indexOf(prop) !== -1) {
              if (val) {
                node.setAttribute(hyphenate(prop), val);
              }
            } else {
              cssText += hyphenate(prop) + ":" + val + ";";
            }
          }
        }
      }
      if (node.nodeType === 1 && unstyledElements.indexOf(node.nodeName) === -1) {
        styles = win17.getComputedStyle(node, null);
        parentStyles = node.nodeName === "svg" ? {} : win17.getComputedStyle(node.parentNode, null);
        if (!defaultStyles[node.nodeName]) {
          dummySVG = iframeDoc.getElementsByTagName("svg")[0];
          dummy = iframeDoc.createElementNS(node.namespaceURI, node.nodeName);
          dummySVG.appendChild(dummy);
          defaultStyles[node.nodeName] = merge75(win17.getComputedStyle(dummy, null));
          if (node.nodeName === "text") {
            delete defaultStyles.text.fill;
          }
          dummySVG.removeChild(dummy);
        }
        if (Globals_default.isFirefox || Globals_default.isMS) {
          for (var p in styles) {
            filterStyles(styles[p], p);
          }
        } else {
          objectEach36(styles, filterStyles);
        }
        if (cssText) {
          styleAttr = node.getAttribute("style");
          node.setAttribute("style", (styleAttr ? styleAttr + ";" : "") + cssText);
        }
        if (node.nodeName === "svg") {
          node.setAttribute("stroke-width", "1px");
        }
        if (node.nodeName === "text") {
          return;
        }
        [].forEach.call(node.children || node.childNodes, recurse);
      }
    }
    function tearDown() {
      dummySVG.parentNode.removeChild(dummySVG);
      iframe.parentNode.removeChild(iframe);
    }
    recurse(this.container.querySelector("svg"));
    tearDown();
  }
  function moveContainers(moveTo) {
    var chart = this;
    (chart.fixedDiv ? (
      // When scrollablePlotArea is active (#9533)
      [chart.fixedDiv, chart.scrollingContainer]
    ) : [chart.container]).forEach(function(div) {
      moveTo.appendChild(div);
    });
  }
  function onChartInit() {
    var chart = this, update = function(prop, options, redraw) {
      chart.isDirtyExporting = true;
      merge75(true, chart.options[prop], options);
      if (pick85(redraw, true)) {
        chart.redraw();
      }
    };
    chart.exporting = {
      update: function(options, redraw) {
        update("exporting", options, redraw);
      }
    };
    Navigation_default.addUpdate(function(options, redraw) {
      update("navigation", options, redraw);
    }, chart);
  }
  function print() {
    var chart = this;
    if (chart.isPrinting) {
      return;
    }
    printingChart = chart;
    if (!Globals_default.isSafari) {
      chart.beforePrint();
    }
    setTimeout(function() {
      win17.focus();
      win17.print();
      if (!Globals_default.isSafari) {
        setTimeout(function() {
          chart.afterPrint();
        }, 1e3);
      }
    }, 1);
  }
  function renderExporting() {
    var chart = this, exportingOptions = chart.options.exporting, buttons = exportingOptions.buttons, isDirty = chart.isDirtyExporting || !chart.exportSVGElements;
    chart.buttonOffset = 0;
    if (chart.isDirtyExporting) {
      chart.destroyExport();
    }
    if (isDirty && exportingOptions.enabled !== false) {
      chart.exportEvents = [];
      chart.exportingGroup = chart.exportingGroup || chart.renderer.g("exporting-group").attr({
        zIndex: 3
        // #4955, // #8392
      }).add();
      objectEach36(buttons, function(button) {
        chart.addButton(button);
      });
      chart.isDirtyExporting = false;
    }
  }
  function sanitizeSVG(svg7, options) {
    var split = svg7.indexOf("</svg>") + 6;
    var html2 = svg7.substr(split);
    svg7 = svg7.substr(0, split);
    if (options && options.exporting && options.exporting.allowHTML) {
      if (html2) {
        html2 = '<foreignObject x="0" y="0" width="' + options.chart.width + '" height="' + options.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + // Some tags needs to be closed in xhtml (#13726)
        html2.replace(/(<(?:img|br).*?(?=\>))>/g, "$1 />") + "</body></foreignObject>";
        svg7 = svg7.replace("</svg>", html2 + "</svg>");
      }
    }
    svg7 = svg7.replace(/zIndex="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(.*?)("|&quot;)\;?\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+\:)href=/g, " xlink:href=").replace(/\n/, " ").replace(
      /(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g,
      // eslint-disable-line max-len
      '$1="rgb($2)" $1-opacity="$3"'
    ).replace(/&nbsp;/g, "").replace(/&shy;/g, "");
    if (this.ieSanitizeSVG) {
      svg7 = this.ieSanitizeSVG(svg7);
    }
    return svg7;
  }
})(Exporting || (Exporting = {}));
defaultOptions15.exporting = merge75(ExportingDefaults_default.exporting, defaultOptions15.exporting);
defaultOptions15.lang = merge75(ExportingDefaults_default.lang, defaultOptions15.lang);
defaultOptions15.navigation = merge75(ExportingDefaults_default.navigation, defaultOptions15.navigation);
var Exporting_default = Exporting;

// node_modules/highcharts/es-modules/masters/modules/exporting.src.js
var G7 = Globals_default;
G7.HttpUtilities = HttpUtilities_default;
G7.ajax = HttpUtilities_default.ajax;
G7.getJSON = HttpUtilities_default.getJSON;
G7.post = HttpUtilities_default.post;
Exporting_default.compose(G7.Chart, G7.Renderer);

// node_modules/highcharts/es-modules/Series/Funnel/FunnelSeries.js
var __extends44 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var noop19 = Globals_default.noop;
var Series8 = SeriesRegistry_default.series;
var PieSeries4 = SeriesRegistry_default.seriesTypes.pie;
var addEvent60 = Utilities_default.addEvent;
var extend75 = Utilities_default.extend;
var fireEvent36 = Utilities_default.fireEvent;
var isArray22 = Utilities_default.isArray;
var merge76 = Utilities_default.merge;
var pick86 = Utilities_default.pick;
var FunnelSeries = (
  /** @class */
  function(_super) {
    __extends44(FunnelSeries2, _super);
    function FunnelSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    FunnelSeries2.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {
      var series = point.series, reversed = series.options.reversed, dlBox = point.dlBox || point.shapeArgs, align = options.align, verticalAlign = options.verticalAlign, inside = ((series.options || {}).dataLabels || {}).inside, centerY = series.center[1], pointPlotY = reversed ? 2 * centerY - point.plotY : point.plotY, widthAtLabel = series.getWidthAt(pointPlotY - dlBox.height / 2 + dataLabel.height), offset3 = verticalAlign === "middle" ? (dlBox.topWidth - dlBox.bottomWidth) / 4 : (widthAtLabel - dlBox.bottomWidth) / 2, y = dlBox.y, x = dlBox.x;
      if (verticalAlign === "middle") {
        y = dlBox.y - dlBox.height / 2 + dataLabel.height / 2;
      } else if (verticalAlign === "top") {
        y = dlBox.y - dlBox.height + dataLabel.height + options.padding;
      }
      if (verticalAlign === "top" && !reversed || verticalAlign === "bottom" && reversed || verticalAlign === "middle") {
        if (align === "right") {
          x = dlBox.x - options.padding + offset3;
        } else if (align === "left") {
          x = dlBox.x + options.padding - offset3;
        }
      }
      alignTo = {
        x,
        y: reversed ? y - dlBox.height : y,
        width: dlBox.bottomWidth,
        height: dlBox.height
      };
      options.verticalAlign = "bottom";
      if (!inside || point.visible) {
        Series8.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
      }
      if (inside) {
        if (!point.visible && point.dataLabel) {
          point.dataLabel.placed = false;
        }
        if (point.contrastColor) {
          dataLabel.css({
            color: point.contrastColor
          });
        }
      }
    };
    FunnelSeries2.prototype.drawDataLabels = function() {
      var series = this, data = series.data, labelDistance = series.options.dataLabels.distance, leftSide, sign, point, i = data.length, x, y;
      series.center[2] -= 2 * labelDistance;
      while (i--) {
        point = data[i];
        leftSide = point.half;
        sign = leftSide ? 1 : -1;
        y = point.plotY;
        point.labelDistance = pick86(point.options.dataLabels && point.options.dataLabels.distance, labelDistance);
        series.maxLabelDistance = Math.max(point.labelDistance, series.maxLabelDistance || 0);
        x = series.getX(y, leftSide, point);
        point.labelPosition = {
          // initial position of the data label - it's utilized for
          // finding the final position for the label
          natural: {
            x: 0,
            y
          },
          "final": {
            // used for generating connector path -
            // initialized later in drawDataLabels function
            // x: undefined,
            // y: undefined
          },
          // left - funnel on the left side of the data label
          // right - funnel on the right side of the data label
          alignment: leftSide ? "right" : "left",
          connectorPosition: {
            breakAt: {
              x: x + (point.labelDistance - 5) * sign,
              y
            },
            touchingSliceAt: {
              x: x + point.labelDistance * sign,
              y
            }
          }
        };
      }
      SeriesRegistry_default.seriesTypes[series.options.dataLabels.inside ? "column" : "pie"].prototype.drawDataLabels.call(this);
    };
    FunnelSeries2.prototype.translate = function() {
      var sum = 0, series = this, chart = series.chart, options = series.options, reversed = options.reversed, ignoreHiddenPoint = options.ignoreHiddenPoint, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, cumulative = 0, center = options.center, centerX = getLength(center[0], plotWidth), centerY = getLength(center[1], plotHeight), width = getLength(options.width, plotWidth), tempWidth, height = getLength(options.height, plotHeight), neckWidth = getLength(options.neckWidth, plotWidth), neckHeight = getLength(options.neckHeight, plotHeight), neckY = centerY - height / 2 + height - neckHeight, data = series.data, path, fraction, half = options.dataLabels.position === "left" ? 1 : 0, x1, y1, x2, x3, y3, x4, y5;
      function getLength(length, relativeTo) {
        return /%$/.test(length) ? relativeTo * parseInt(length, 10) / 100 : parseInt(length, 10);
      }
      series.getWidthAt = function(y) {
        var top = centerY - height / 2;
        return y > neckY || height === neckHeight ? neckWidth : neckWidth + (width - neckWidth) * (1 - (y - top) / (height - neckHeight));
      };
      series.getX = function(y, half2, point) {
        return centerX + (half2 ? -1 : 1) * (series.getWidthAt(reversed ? 2 * centerY - y : y) / 2 + point.labelDistance);
      };
      series.center = [centerX, centerY, height];
      series.centerX = centerX;
      data.forEach(function(point) {
        if (!ignoreHiddenPoint || point.visible !== false) {
          sum += point.y;
        }
      });
      data.forEach(function(point) {
        y5 = null;
        fraction = sum ? point.y / sum : 0;
        y1 = centerY - height / 2 + cumulative * height;
        y3 = y1 + fraction * height;
        tempWidth = series.getWidthAt(y1);
        x1 = centerX - tempWidth / 2;
        x2 = x1 + tempWidth;
        tempWidth = series.getWidthAt(y3);
        x3 = centerX - tempWidth / 2;
        x4 = x3 + tempWidth;
        if (y1 > neckY) {
          x1 = x3 = centerX - neckWidth / 2;
          x2 = x4 = centerX + neckWidth / 2;
        } else if (y3 > neckY) {
          y5 = y3;
          tempWidth = series.getWidthAt(neckY);
          x3 = centerX - tempWidth / 2;
          x4 = x3 + tempWidth;
          y3 = neckY;
        }
        if (reversed) {
          y1 = 2 * centerY - y1;
          y3 = 2 * centerY - y3;
          if (y5 !== null) {
            y5 = 2 * centerY - y5;
          }
        }
        path = [
          ["M", x1, y1],
          ["L", x2, y1],
          ["L", x4, y3]
        ];
        if (y5 !== null) {
          path.push(["L", x4, y5], ["L", x3, y5]);
        }
        path.push(["L", x3, y3], ["Z"]);
        point.shapeType = "path";
        point.shapeArgs = { d: path };
        point.percentage = fraction * 100;
        point.plotX = centerX;
        point.plotY = (y1 + (y5 || y3)) / 2;
        point.tooltipPos = [
          centerX,
          point.plotY
        ];
        point.dlBox = {
          x: x3,
          y: y1,
          topWidth: x2 - x1,
          bottomWidth: x4 - x3,
          height: Math.abs(pick86(y5, y3) - y1),
          width: NaN
        };
        point.slice = noop19;
        point.half = half;
        if (!ignoreHiddenPoint || point.visible !== false) {
          cumulative += fraction;
        }
      });
      fireEvent36(series, "afterTranslate");
    };
    FunnelSeries2.prototype.sortByAngle = function(points) {
      points.sort(function(a, b) {
        return a.plotY - b.plotY;
      });
    };
    FunnelSeries2.defaultOptions = merge76(PieSeries4.defaultOptions, {
      /**
       * Initial animation is by default disabled for the funnel chart.
       */
      animation: false,
      /**
       * The center of the series. By default, it is centered in the middle
       * of the plot area, so it fills the plot area height.
       *
       * @type    {Array<number|string>}
       * @default ["50%", "50%"]
       * @since   3.0
       */
      center: ["50%", "50%"],
      /**
       * The width of the funnel compared to the width of the plot area,
       * or the pixel width if it is a number.
       *
       * @type  {number|string}
       * @since 3.0
       */
      width: "90%",
      /**
       * The width of the neck, the lower part of the funnel. A number defines
       * pixel width, a percentage string defines a percentage of the plot
       * area width.
       *
       * @sample {highcharts} highcharts/demo/funnel/
       *         Funnel demo
       *
       * @type  {number|string}
       * @since 3.0
       */
      neckWidth: "30%",
      /**
       * The height of the funnel or pyramid. If it is a number it defines
       * the pixel height, if it is a percentage string it is the percentage
       * of the plot area height.
       *
       * @sample {highcharts} highcharts/demo/funnel/
       *         Funnel demo
       *
       * @type  {number|string}
       * @since 3.0
       */
      height: "100%",
      /**
       * The height of the neck, the lower part of the funnel. A number
       * defines pixel width, a percentage string defines a percentage of the
       * plot area height.
       *
       * @type {number|string}
       */
      neckHeight: "25%",
      /**
       * A reversed funnel has the widest area down. A reversed funnel with
       * no neck width and neck height is a pyramid.
       *
       * @since 3.0.10
       */
      reversed: false,
      /**
       * To avoid adapting the data label size in Pie.drawDataLabels.
       * @ignore-option
       */
      size: true,
      dataLabels: {
        connectorWidth: 1,
        verticalAlign: "middle"
      },
      /**
       * Options for the series states.
       */
      states: {
        /**
         * @excluding halo, marker, lineWidth, lineWidthPlus
         * @apioption plotOptions.funnel.states.hover
         */
        /**
         * Options for a selected funnel item.
         *
         * @excluding halo, marker, lineWidth, lineWidthPlus
         */
        select: {
          /**
           * A specific color for the selected point.
           *
           * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
           */
          color: Palette_default.neutralColor20,
          /**
           * A specific border color for the selected point.
           *
           * @type {Highcharts.ColorString}
           */
          borderColor: Palette_default.neutralColor100
        }
      }
    });
    return FunnelSeries2;
  }(PieSeries4)
);
extend75(FunnelSeries.prototype, {
  animate: noop19
});
addEvent60(Chart_default, "afterHideAllOverlappingLabels", function() {
  this.series.forEach(function(series) {
    var dataLabelsOptions = series.options && series.options.dataLabels;
    if (isArray22(dataLabelsOptions)) {
      dataLabelsOptions = dataLabelsOptions[0];
    }
    if (series.is("pie") && series.placeDataLabels && dataLabelsOptions && !dataLabelsOptions.inside) {
      series.placeDataLabels();
    }
  });
});
SeriesRegistry_default.registerSeriesType("funnel", FunnelSeries);
var FunnelSeries_default = FunnelSeries;

// node_modules/highcharts/es-modules/Series/Pyramid/PyramidSeries.js
var __extends45 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var merge77 = Utilities_default.merge;
var PyramidSeries = (
  /** @class */
  function(_super) {
    __extends45(PyramidSeries2, _super);
    function PyramidSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    PyramidSeries2.defaultOptions = merge77(FunnelSeries_default.defaultOptions, {
      /**
       * The pyramid neck width is zero by default, as opposed to the funnel,
       * which shares the same layout logic.
       *
       * @since 3.0.10
       */
      neckWidth: "0%",
      /**
       * The pyramid neck width is zero by default, as opposed to the funnel,
       * which shares the same layout logic.
       *
       * @since 3.0.10
       */
      neckHeight: "0%",
      /**
       * The pyramid is reversed by default, as opposed to the funnel, which
       * shares the layout engine, and is not reversed.
       *
       * @since 3.0.10
       */
      reversed: true
    });
    return PyramidSeries2;
  }(FunnelSeries_default)
);
SeriesRegistry_default.registerSeriesType("pyramid", PyramidSeries);

// node_modules/highcharts/es-modules/Mixins/ColorSeries.js
var colorPointMixin = {
  /* eslint-disable valid-jsdoc */
  /**
   * Set the visibility of a single point
   * @private
   * @function Highcharts.colorPointMixin.setVisible
   * @param {boolean} visible
   * @return {void}
   */
  setVisible: function(vis) {
    var point = this, method = vis ? "show" : "hide";
    point.visible = point.options.visible = Boolean(vis);
    ["graphic", "dataLabel"].forEach(function(key) {
      if (point[key]) {
        point[key][method]();
      }
    });
    this.series.buildKDTree();
  }
  /* eslint-enable valid-jsdoc */
};
var colorSeriesMixin = {
  optionalAxis: "colorAxis",
  /* eslint-disable valid-jsdoc */
  /**
   * In choropleth maps, the color is a result of the value, so this needs
   * translation too
   * @private
   * @function Highcharts.colorSeriesMixin.translateColors
   * @return {void}
   */
  translateColors: function() {
    var series = this, points = this.data.length ? this.data : this.points, nullColor = this.options.nullColor, colorAxis = this.colorAxis, colorKey = this.colorKey;
    points.forEach(function(point) {
      var value = point.getNestedProperty(colorKey), color18;
      color18 = point.options.color || (point.isNull || point.value === null ? nullColor : colorAxis && typeof value !== "undefined" ? colorAxis.toColor(value, point) : point.color || series.color);
      if (color18 && point.color !== color18) {
        point.color = color18;
        if (series.options.legendType === "point" && point.legendItem) {
          series.chart.legend.colorizeItem(point, point.visible);
        }
      }
    });
  }
  /* eslint-enable valid-jsdoc */
};
var exports3 = {
  colorPointMixin,
  colorSeriesMixin
};
var ColorSeries_default = exports3;

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxisComposition.js
var color13 = Color_default.parse;
var colorPointMixin2 = ColorSeries_default.colorPointMixin;
var colorSeriesMixin2 = ColorSeries_default.colorSeriesMixin;
var addEvent61 = Utilities_default.addEvent;
var extend76 = Utilities_default.extend;
var merge78 = Utilities_default.merge;
var pick87 = Utilities_default.pick;
var splat20 = Utilities_default.splat;
var ColorAxisComposition;
(function(ColorAxisComposition2) {
  var composedClasses2 = [];
  var ColorAxisClass;
  function compose(ColorAxisType, ChartClass, FxClass, LegendClass, SeriesClass) {
    if (!ColorAxisClass) {
      ColorAxisClass = ColorAxisType;
    }
    if (composedClasses2.indexOf(ChartClass) === -1) {
      composedClasses2.push(ChartClass);
      var chartProto2 = ChartClass.prototype;
      chartProto2.collectionsWithUpdate.push("colorAxis");
      chartProto2.collectionsWithInit.colorAxis = [chartProto2.addColorAxis];
      addEvent61(ChartClass, "afterGetAxes", onChartAfterGetAxes);
      wrapChartCreateAxis(ChartClass);
    }
    if (composedClasses2.indexOf(FxClass) === -1) {
      composedClasses2.push(FxClass);
      var fxProto = FxClass.prototype;
      fxProto.fillSetter = wrapFxFillSetter;
      fxProto.strokeSetter = wrapFxStrokeSetter;
    }
    if (composedClasses2.indexOf(LegendClass) === -1) {
      composedClasses2.push(LegendClass);
      addEvent61(LegendClass, "afterGetAllItems", onLegendAfterGetAllItems);
      addEvent61(LegendClass, "afterColorizeItem", onLegendAfterColorizeItem);
      addEvent61(LegendClass, "afterUpdate", onLegendAfterUpdate);
    }
    if (composedClasses2.indexOf(SeriesClass) === -1) {
      composedClasses2.push(SeriesClass);
      extend76(SeriesClass.prototype, colorSeriesMixin2);
      extend76(SeriesClass.prototype.pointClass.prototype, colorPointMixin2);
      addEvent61(SeriesClass, "afterTranslate", onSeriesAfterTranslate);
      addEvent61(SeriesClass, "bindAxes", onSeriesBindAxes);
    }
  }
  ColorAxisComposition2.compose = compose;
  function onChartAfterGetAxes() {
    var _this = this;
    var options = this.options;
    this.colorAxis = [];
    if (options.colorAxis) {
      options.colorAxis = splat20(options.colorAxis);
      options.colorAxis.forEach(function(axisOptions, i) {
        axisOptions.index = i;
        new ColorAxisClass(_this, axisOptions);
      });
    }
  }
  function onLegendAfterGetAllItems(e2) {
    var _this = this;
    var colorAxes = this.chart.colorAxis || [], destroyItem = function(item) {
      var i2 = e2.allItems.indexOf(item);
      if (i2 !== -1) {
        _this.destroyItem(e2.allItems[i2]);
        e2.allItems.splice(i2, 1);
      }
    };
    var colorAxisItems = [], options, i;
    colorAxes.forEach(function(colorAxis) {
      options = colorAxis.options;
      if (options && options.showInLegend) {
        if (options.dataClasses && options.visible) {
          colorAxisItems = colorAxisItems.concat(colorAxis.getDataClassLegendSymbols());
        } else if (options.visible) {
          colorAxisItems.push(colorAxis);
        }
        colorAxis.series.forEach(function(series) {
          if (!series.options.showInLegend || options.dataClasses) {
            if (series.options.legendType === "point") {
              series.points.forEach(function(point) {
                destroyItem(point);
              });
            } else {
              destroyItem(series);
            }
          }
        });
      }
    });
    i = colorAxisItems.length;
    while (i--) {
      e2.allItems.unshift(colorAxisItems[i]);
    }
  }
  function onLegendAfterColorizeItem(e2) {
    if (e2.visible && e2.item.legendColor) {
      e2.item.legendSymbol.attr({
        fill: e2.item.legendColor
      });
    }
  }
  function onLegendAfterUpdate() {
    var colorAxes = this.chart.colorAxis;
    if (colorAxes) {
      colorAxes.forEach(function(colorAxis) {
        colorAxis.update({}, arguments[2]);
      });
    }
  }
  function onSeriesAfterTranslate() {
    if (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) {
      this.translateColors();
    }
  }
  function onSeriesBindAxes() {
    var axisTypes = this.axisTypes;
    if (!axisTypes) {
      this.axisTypes = ["colorAxis"];
    } else if (axisTypes.indexOf("colorAxis") === -1) {
      axisTypes.push("colorAxis");
    }
  }
  function wrapChartCreateAxis(ChartClass) {
    var superCreateAxis = ChartClass.prototype.createAxis;
    ChartClass.prototype.createAxis = function(type, options) {
      if (type !== "colorAxis") {
        return superCreateAxis.apply(this, arguments);
      }
      var axis = new ColorAxisClass(this, merge78(options.axis, {
        index: this[type].length,
        isX: false
      }));
      this.isDirtyLegend = true;
      this.axes.forEach(function(axis2) {
        axis2.series = [];
      });
      this.series.forEach(function(series) {
        series.bindAxes();
        series.isDirtyData = true;
      });
      if (pick87(options.redraw, true)) {
        this.redraw(options.animation);
      }
      return axis;
    };
  }
  function wrapFxFillSetter() {
    this.elem.attr("fill", color13(this.start).tweenTo(color13(this.end), this.pos), void 0, true);
  }
  function wrapFxStrokeSetter() {
    this.elem.attr("stroke", color13(this.start).tweenTo(color13(this.end), this.pos), void 0, true);
  }
})(ColorAxisComposition || (ColorAxisComposition = {}));
var ColorAxisComposition_default = ColorAxisComposition;

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxisDefaults.js
var colorAxisDefaults = {
  /**
   * Whether to allow decimals on the color axis.
   * @type      {boolean}
   * @default   true
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.allowDecimals
   */
  /**
   * Determines how to set each data class' color if no individual
   * color is set. The default value, `tween`, computes intermediate
   * colors between `minColor` and `maxColor`. The other possible
   * value, `category`, pulls colors from the global or chart specific
   * [colors](#colors) array.
   *
   * @sample {highmaps} maps/coloraxis/dataclasscolor/
   *         Category colors
   *
   * @type       {string}
   * @default    tween
   * @product    highcharts highstock highmaps
   * @validvalue ["tween", "category"]
   * @apioption  colorAxis.dataClassColor
   */
  /**
   * An array of data classes or ranges for the choropleth map. If
   * none given, the color axis is scalar and values are distributed
   * as a gradient between the minimum and maximum colors.
   *
   * @sample {highmaps} maps/demo/data-class-ranges/
   *         Multiple ranges
   *
   * @sample {highmaps} maps/demo/data-class-two-ranges/
   *         Two ranges
   *
   * @type      {Array<*>}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses
   */
  /**
   * The layout of the color axis. Can be `'horizontal'` or `'vertical'`.
   * If none given, the color axis has the same layout as the legend.
   *
   * @sample highcharts/coloraxis/horizontal-layout/
   *         Horizontal color axis layout with vertical legend
   *
   * @type      {string|undefined}
   * @since     7.2.0
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.layout
   */
  /**
   * The color of each data class. If not set, the color is pulled
   * from the global or chart-specific [colors](#colors) array. In
   * styled mode, this option is ignored. Instead, use colors defined
   * in CSS.
   *
   * @sample {highmaps} maps/demo/data-class-two-ranges/
   *         Explicit colors
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses.color
   */
  /**
   * The start of the value range that the data class represents,
   * relating to the point value.
   *
   * The range of each `dataClass` is closed in both ends, but can be
   * overridden by the next `dataClass`.
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses.from
   */
  /**
   * The name of the data class as it appears in the legend.
   * If no name is given, it is automatically created based on the
   * `from` and `to` values. For full programmatic control,
   * [legend.labelFormatter](#legend.labelFormatter) can be used.
   * In the formatter, `this.from` and `this.to` can be accessed.
   *
   * @sample {highmaps} maps/coloraxis/dataclasses-name/
   *         Named data classes
   *
   * @sample {highmaps} maps/coloraxis/dataclasses-labelformatter/
   *         Formatted data classes
   *
   * @type      {string}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses.name
   */
  /**
   * The end of the value range that the data class represents,
   * relating to the point value.
   *
   * The range of each `dataClass` is closed in both ends, but can be
   * overridden by the next `dataClass`.
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.dataClasses.to
   */
  /** @ignore-option */
  lineWidth: 0,
  /**
   * Padding of the min value relative to the length of the axis. A
   * padding of 0.05 will make a 100px axis 5px longer.
   *
   * @product highcharts highstock highmaps
   */
  minPadding: 0,
  /**
   * The maximum value of the axis in terms of map point values. If
   * `null`, the max value is automatically calculated. If the
   * `endOnTick` option is true, the max value might be rounded up.
   *
   * @sample {highmaps} maps/coloraxis/gridlines/
   *         Explicit min and max to reduce the effect of outliers
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.max
   */
  /**
   * The minimum value of the axis in terms of map point values. If
   * `null`, the min value is automatically calculated. If the
   * `startOnTick` option is true, the min value might be rounded
   * down.
   *
   * @sample {highmaps} maps/coloraxis/gridlines/
   *         Explicit min and max to reduce the effect of outliers
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.min
   */
  /**
   * Padding of the max value relative to the length of the axis. A
   * padding of 0.05 will make a 100px axis 5px longer.
   *
   * @product highcharts highstock highmaps
   */
  maxPadding: 0,
  /**
   * Color of the grid lines extending from the axis across the
   * gradient.
   *
   * @sample {highmaps} maps/coloraxis/gridlines/
   *         Grid lines demonstrated
   *
   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @default   #e6e6e6
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.gridLineColor
   */
  /**
   * The width of the grid lines extending from the axis across the
   * gradient of a scalar color axis.
   *
   * @sample {highmaps} maps/coloraxis/gridlines/
   *         Grid lines demonstrated
   *
   * @product highcharts highstock highmaps
   */
  gridLineWidth: 1,
  /**
   * The interval of the tick marks in axis units. When `null`, the
   * tick interval is computed to approximately follow the
   * `tickPixelInterval`.
   *
   * @type      {number}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.tickInterval
   */
  /**
   * If [tickInterval](#colorAxis.tickInterval) is `null` this option
   * sets the approximate pixel interval of the tick marks.
   *
   * @product highcharts highstock highmaps
   */
  tickPixelInterval: 72,
  /**
   * Whether to force the axis to start on a tick. Use this option
   * with the `maxPadding` option to control the axis start.
   *
   * @product highcharts highstock highmaps
   */
  startOnTick: true,
  /**
   * Whether to force the axis to end on a tick. Use this option with
   * the [maxPadding](#colorAxis.maxPadding) option to control the
   * axis end.
   *
   * @product highcharts highstock highmaps
   */
  endOnTick: true,
  /** @ignore */
  offset: 0,
  /**
   * The triangular marker on a scalar color axis that points to the
   * value of the hovered area. To disable the marker, set
   * `marker: null`.
   *
   * @sample {highmaps} maps/coloraxis/marker/
   *         Black marker
   *
   * @declare Highcharts.PointMarkerOptionsObject
   * @product highcharts highstock highmaps
   */
  marker: {
    /**
     * Animation for the marker as it moves between values. Set to
     * `false` to disable animation. Defaults to `{ duration: 50 }`.
     *
     * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}
     * @product highcharts highstock highmaps
     */
    animation: {
      /** @internal */
      duration: 50
    },
    /** @internal */
    width: 0.01,
    /**
     * The color of the marker.
     *
     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
     * @product highcharts highstock highmaps
     */
    color: Palette_default.neutralColor40
  },
  /**
   * The axis labels show the number for each tick.
   *
   * For more live examples on label options, see [xAxis.labels in the
   * Highcharts API.](/highcharts#xAxis.labels)
   *
   * @extends xAxis.labels
   * @product highcharts highstock highmaps
   */
  labels: {
    /**
     * How to handle overflowing labels on horizontal color axis. If set
     * to `"allow"`, it will not be aligned at all. By default it
     * `"justify"` labels inside the chart area. If there is room to
     * move it, it will be aligned to the edge, else it will be removed.
     *
     * @validvalue ["allow", "justify"]
     * @product    highcharts highstock highmaps
     */
    overflow: "justify",
    rotation: 0
  },
  /**
   * The color to represent the minimum of the color axis. Unless
   * [dataClasses](#colorAxis.dataClasses) or
   * [stops](#colorAxis.stops) are set, the gradient starts at this
   * value.
   *
   * If dataClasses are set, the color is based on minColor and
   * maxColor unless a color is set for each data class, or the
   * [dataClassColor](#colorAxis.dataClassColor) is set.
   *
   * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/
   *         Min and max colors on scalar (gradient) axis
   * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/
   *         On data classes
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product highcharts highstock highmaps
   */
  minColor: Palette_default.highlightColor10,
  /**
   * The color to represent the maximum of the color axis. Unless
   * [dataClasses](#colorAxis.dataClasses) or
   * [stops](#colorAxis.stops) are set, the gradient ends at this
   * value.
   *
   * If dataClasses are set, the color is based on minColor and
   * maxColor unless a color is set for each data class, or the
   * [dataClassColor](#colorAxis.dataClassColor) is set.
   *
   * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/
   *         Min and max colors on scalar (gradient) axis
   * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/
   *         On data classes
   *
   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
   * @product highcharts highstock highmaps
   */
  maxColor: Palette_default.highlightColor100,
  /**
   * Color stops for the gradient of a scalar color axis. Use this in
   * cases where a linear gradient between a `minColor` and `maxColor`
   * is not sufficient. The stops is an array of tuples, where the
   * first item is a float between 0 and 1 assigning the relative
   * position in the gradient, and the second item is the color.
   *
   * @sample {highmaps} maps/demo/heatmap/
   *         Heatmap with three color stops
   *
   * @type      {Array<Array<number,Highcharts.ColorString>>}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.stops
   */
  /**
   * The pixel length of the main tick marks on the color axis.
   */
  tickLength: 5,
  /**
   * The type of interpolation to use for the color axis. Can be
   * `linear` or `logarithmic`.
   *
   * @sample highcharts/coloraxis/logarithmic-with-emulate-negative-values/
   *         Logarithmic color axis with extension to emulate negative
   *         values
   *
   * @type      {Highcharts.ColorAxisTypeValue}
   * @default   linear
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.type
   */
  /**
   * Whether to reverse the axis so that the highest number is closest
   * to the origin. Defaults to `false` in a horizontal legend and
   * `true` in a vertical legend, where the smallest value starts on
   * top.
   *
   * @type      {boolean}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.reversed
   */
  /**
   * @product   highcharts highstock highmaps
   * @excluding afterBreaks, pointBreak, pointInBreak
   * @apioption colorAxis.events
   */
  /**
   * Fires when the legend item belonging to the colorAxis is clicked.
   * One parameter, `event`, is passed to the function.
   *
   * @type      {Function}
   * @product   highcharts highstock highmaps
   * @apioption colorAxis.events.legendItemClick
   */
  /**
   * Whether to display the colorAxis in the legend.
   *
   * @sample highcharts/coloraxis/hidden-coloraxis-with-3d-chart/
   *         Hidden color axis with 3d chart
   *
   * @see [heatmap.showInLegend](#series.heatmap.showInLegend)
   *
   * @since   4.2.7
   * @product highcharts highstock highmaps
   */
  showInLegend: true
};
var ColorAxisDefaults_default = colorAxisDefaults;

// node_modules/highcharts/es-modules/Core/Axis/Color/ColorAxis.js
var __extends46 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color14 = Color_default.parse;
var noop20 = Globals_default.noop;
var Series9 = SeriesRegistry_default.series;
var extend77 = Utilities_default.extend;
var isNumber47 = Utilities_default.isNumber;
var merge79 = Utilities_default.merge;
var pick88 = Utilities_default.pick;
var ColorAxis = (
  /** @class */
  function(_super) {
    __extends46(ColorAxis2, _super);
    function ColorAxis2(chart, userOptions) {
      var _this = _super.call(this, chart, userOptions) || this;
      _this.beforePadding = false;
      _this.chart = void 0;
      _this.coll = "colorAxis";
      _this.dataClasses = void 0;
      _this.legendItem = void 0;
      _this.legendItems = void 0;
      _this.name = "";
      _this.options = void 0;
      _this.stops = void 0;
      _this.visible = true;
      _this.init(chart, userOptions);
      return _this;
    }
    ColorAxis2.compose = function(ChartClass, FxClass, LegendClass, SeriesClass) {
      ColorAxisComposition_default.compose(ColorAxis2, ChartClass, FxClass, LegendClass, SeriesClass);
    };
    ColorAxis2.prototype.init = function(chart, userOptions) {
      var axis = this;
      var legend = chart.options.legend || {}, horiz = userOptions.layout ? userOptions.layout !== "vertical" : legend.layout !== "vertical", visible = userOptions.visible;
      var options = merge79(ColorAxis2.defaultColorAxisOptions, userOptions, {
        showEmpty: false,
        title: null,
        visible: legend.enabled && visible !== false
      });
      axis.coll = "colorAxis";
      axis.side = userOptions.side || horiz ? 2 : 1;
      axis.reversed = userOptions.reversed || !horiz;
      axis.opposite = !horiz;
      _super.prototype.init.call(this, chart, options);
      axis.userOptions.visible = visible;
      if (userOptions.dataClasses) {
        axis.initDataClasses(userOptions);
      }
      axis.initStops();
      axis.horiz = horiz;
      axis.zoomEnabled = false;
    };
    ColorAxis2.prototype.initDataClasses = function(userOptions) {
      var axis = this, chart = axis.chart, options = axis.options, len = userOptions.dataClasses.length;
      var dataClasses, colorCounter = 0, colorCount = chart.options.chart.colorCount;
      axis.dataClasses = dataClasses = [];
      axis.legendItems = [];
      (userOptions.dataClasses || []).forEach(function(dataClass, i) {
        var colors;
        dataClass = merge79(dataClass);
        dataClasses.push(dataClass);
        if (!chart.styledMode && dataClass.color) {
          return;
        }
        if (options.dataClassColor === "category") {
          if (!chart.styledMode) {
            colors = chart.options.colors;
            colorCount = colors.length;
            dataClass.color = colors[colorCounter];
          }
          dataClass.colorIndex = colorCounter;
          colorCounter++;
          if (colorCounter === colorCount) {
            colorCounter = 0;
          }
        } else {
          dataClass.color = color14(options.minColor).tweenTo(
            color14(options.maxColor),
            len < 2 ? 0.5 : i / (len - 1)
            // #3219
          );
        }
      });
    };
    ColorAxis2.prototype.hasData = function() {
      return !!(this.tickPositions || []).length;
    };
    ColorAxis2.prototype.setTickPositions = function() {
      if (!this.dataClasses) {
        return _super.prototype.setTickPositions.call(this);
      }
    };
    ColorAxis2.prototype.initStops = function() {
      var axis = this;
      axis.stops = axis.options.stops || [
        [0, axis.options.minColor],
        [1, axis.options.maxColor]
      ];
      axis.stops.forEach(function(stop4) {
        stop4.color = color14(stop4[1]);
      });
    };
    ColorAxis2.prototype.setOptions = function(userOptions) {
      var axis = this;
      _super.prototype.setOptions.call(this, userOptions);
      axis.options.crosshair = axis.options.marker;
    };
    ColorAxis2.prototype.setAxisSize = function() {
      var axis = this;
      var symbol = axis.legendSymbol;
      var chart = axis.chart;
      var legendOptions = chart.options.legend || {};
      var x, y, width, height;
      if (symbol) {
        this.left = x = symbol.attr("x");
        this.top = y = symbol.attr("y");
        this.width = width = symbol.attr("width");
        this.height = height = symbol.attr("height");
        this.right = chart.chartWidth - x - width;
        this.bottom = chart.chartHeight - y - height;
        this.len = this.horiz ? width : height;
        this.pos = this.horiz ? x : y;
      } else {
        this.len = (this.horiz ? legendOptions.symbolWidth : legendOptions.symbolHeight) || ColorAxis2.defaultLegendLength;
      }
    };
    ColorAxis2.prototype.normalizedValue = function(value) {
      var axis = this;
      if (axis.logarithmic) {
        value = axis.logarithmic.log2lin(value);
      }
      return 1 - (axis.max - value) / (axis.max - axis.min || 1);
    };
    ColorAxis2.prototype.toColor = function(value, point) {
      var axis = this;
      var dataClasses = axis.dataClasses;
      var stops = axis.stops;
      var pos, from, to, color18, dataClass, i;
      if (dataClasses) {
        i = dataClasses.length;
        while (i--) {
          dataClass = dataClasses[i];
          from = dataClass.from;
          to = dataClass.to;
          if ((typeof from === "undefined" || value >= from) && (typeof to === "undefined" || value <= to)) {
            color18 = dataClass.color;
            if (point) {
              point.dataClass = i;
              point.colorIndex = dataClass.colorIndex;
            }
            break;
          }
        }
      } else {
        pos = axis.normalizedValue(value);
        i = stops.length;
        while (i--) {
          if (pos > stops[i][0]) {
            break;
          }
        }
        from = stops[i] || stops[i + 1];
        to = stops[i + 1] || from;
        pos = 1 - (to[0] - pos) / (to[0] - from[0] || 1);
        color18 = from.color.tweenTo(to.color, pos);
      }
      return color18;
    };
    ColorAxis2.prototype.getOffset = function() {
      var axis = this;
      var group = axis.legendGroup;
      var sideOffset = axis.chart.axisOffset[axis.side];
      if (group) {
        axis.axisParent = group;
        _super.prototype.getOffset.call(this);
        if (!axis.added) {
          axis.added = true;
          axis.labelLeft = 0;
          axis.labelRight = axis.width;
        }
        axis.chart.axisOffset[axis.side] = sideOffset;
      }
    };
    ColorAxis2.prototype.setLegendColor = function() {
      var axis = this;
      var horiz = axis.horiz;
      var reversed = axis.reversed;
      var one = reversed ? 1 : 0;
      var zero = reversed ? 0 : 1;
      var grad = horiz ? [one, 0, zero, 0] : [0, zero, 0, one];
      axis.legendColor = {
        linearGradient: {
          x1: grad[0],
          y1: grad[1],
          x2: grad[2],
          y2: grad[3]
        },
        stops: axis.stops
      };
    };
    ColorAxis2.prototype.drawLegendSymbol = function(legend, item) {
      var axis = this;
      var padding = legend.padding;
      var legendOptions = legend.options;
      var horiz = axis.horiz;
      var width = pick88(legendOptions.symbolWidth, horiz ? ColorAxis2.defaultLegendLength : 12);
      var height = pick88(legendOptions.symbolHeight, horiz ? 12 : ColorAxis2.defaultLegendLength);
      var labelPadding = pick88(legendOptions.labelPadding, horiz ? 16 : 30);
      var itemDistance = pick88(legendOptions.itemDistance, 10);
      this.setLegendColor();
      item.legendSymbol = this.chart.renderer.rect(0, legend.baseline - 11, width, height).attr({
        zIndex: 1
      }).add(item.legendGroup);
      axis.legendItemWidth = width + padding + (horiz ? itemDistance : labelPadding);
      axis.legendItemHeight = height + padding + (horiz ? labelPadding : 0);
    };
    ColorAxis2.prototype.setState = function(state) {
      this.series.forEach(function(series) {
        series.setState(state);
      });
    };
    ColorAxis2.prototype.setVisible = function() {
    };
    ColorAxis2.prototype.getSeriesExtremes = function() {
      var axis = this;
      var series = axis.series;
      var colorValArray, colorKey, colorValIndex, pointArrayMap, calculatedExtremes, cSeries, i = series.length, yData, j;
      this.dataMin = Infinity;
      this.dataMax = -Infinity;
      while (i--) {
        cSeries = series[i];
        colorKey = cSeries.colorKey = pick88(cSeries.options.colorKey, cSeries.colorKey, cSeries.pointValKey, cSeries.zoneAxis, "y");
        pointArrayMap = cSeries.pointArrayMap;
        calculatedExtremes = cSeries[colorKey + "Min"] && cSeries[colorKey + "Max"];
        if (cSeries[colorKey + "Data"]) {
          colorValArray = cSeries[colorKey + "Data"];
        } else {
          if (!pointArrayMap) {
            colorValArray = cSeries.yData;
          } else {
            colorValArray = [];
            colorValIndex = pointArrayMap.indexOf(colorKey);
            yData = cSeries.yData;
            if (colorValIndex >= 0 && yData) {
              for (j = 0; j < yData.length; j++) {
                colorValArray.push(pick88(yData[j][colorValIndex], yData[j]));
              }
            }
          }
        }
        if (calculatedExtremes) {
          cSeries.minColorValue = cSeries[colorKey + "Min"];
          cSeries.maxColorValue = cSeries[colorKey + "Max"];
        } else {
          var cExtremes = Series9.prototype.getExtremes.call(cSeries, colorValArray);
          cSeries.minColorValue = cExtremes.dataMin;
          cSeries.maxColorValue = cExtremes.dataMax;
        }
        if (typeof cSeries.minColorValue !== "undefined") {
          this.dataMin = Math.min(this.dataMin, cSeries.minColorValue);
          this.dataMax = Math.max(this.dataMax, cSeries.maxColorValue);
        }
        if (!calculatedExtremes) {
          Series9.prototype.applyExtremes.call(cSeries);
        }
      }
    };
    ColorAxis2.prototype.drawCrosshair = function(e2, point) {
      var axis = this;
      var plotX = point && point.plotX;
      var plotY = point && point.plotY;
      var axisPos = axis.pos;
      var axisLen = axis.len;
      var crossPos;
      if (point) {
        crossPos = axis.toPixels(point.getNestedProperty(point.series.colorKey));
        if (crossPos < axisPos) {
          crossPos = axisPos - 2;
        } else if (crossPos > axisPos + axisLen) {
          crossPos = axisPos + axisLen + 2;
        }
        point.plotX = crossPos;
        point.plotY = axis.len - crossPos;
        _super.prototype.drawCrosshair.call(this, e2, point);
        point.plotX = plotX;
        point.plotY = plotY;
        if (axis.cross && !axis.cross.addedToColorAxis && axis.legendGroup) {
          axis.cross.addClass("highcharts-coloraxis-marker").add(axis.legendGroup);
          axis.cross.addedToColorAxis = true;
          if (!axis.chart.styledMode && typeof axis.crosshair === "object") {
            axis.cross.attr({
              fill: axis.crosshair.color
            });
          }
        }
      }
    };
    ColorAxis2.prototype.getPlotLinePath = function(options) {
      var axis = this, left = axis.left, pos = options.translatedValue, top = axis.top;
      return isNumber47(pos) ? (
        // pos can be 0 (#3969)
        axis.horiz ? [
          ["M", pos - 4, top - 6],
          ["L", pos + 4, top - 6],
          ["L", pos, top],
          ["Z"]
        ] : [
          ["M", left, pos],
          ["L", left - 6, pos + 6],
          ["L", left - 6, pos - 6],
          ["Z"]
        ]
      ) : _super.prototype.getPlotLinePath.call(this, options);
    };
    ColorAxis2.prototype.update = function(newOptions, redraw) {
      var axis = this, chart = axis.chart, legend = chart.legend;
      this.series.forEach(function(series) {
        series.isDirtyData = true;
      });
      if (newOptions.dataClasses && legend.allItems || axis.dataClasses) {
        axis.destroyItems();
      }
      _super.prototype.update.call(this, newOptions, redraw);
      if (axis.legendItem) {
        axis.setLegendColor();
        legend.colorizeItem(this, true);
      }
    };
    ColorAxis2.prototype.destroyItems = function() {
      var axis = this;
      var chart = axis.chart;
      if (axis.legendItem) {
        chart.legend.destroyItem(axis);
      } else if (axis.legendItems) {
        axis.legendItems.forEach(function(item) {
          chart.legend.destroyItem(item);
        });
      }
      chart.isDirtyLegend = true;
    };
    ColorAxis2.prototype.destroy = function() {
      this.chart.isDirtyLegend = true;
      this.destroyItems();
      _super.prototype.destroy.apply(this, [].slice.call(arguments));
    };
    ColorAxis2.prototype.remove = function(redraw) {
      this.destroyItems();
      _super.prototype.remove.call(this, redraw);
    };
    ColorAxis2.prototype.getDataClassLegendSymbols = function() {
      var axis = this;
      var chart = axis.chart;
      var legendItems = axis.legendItems;
      var legendOptions = chart.options.legend;
      var valueDecimals = legendOptions.valueDecimals;
      var valueSuffix = legendOptions.valueSuffix || "";
      var name;
      if (!legendItems.length) {
        axis.dataClasses.forEach(function(dataClass, i) {
          var from = dataClass.from, to = dataClass.to, numberFormatter = chart.numberFormatter;
          var vis = true;
          name = "";
          if (typeof from === "undefined") {
            name = "< ";
          } else if (typeof to === "undefined") {
            name = "> ";
          }
          if (typeof from !== "undefined") {
            name += numberFormatter(from, valueDecimals) + valueSuffix;
          }
          if (typeof from !== "undefined" && typeof to !== "undefined") {
            name += " - ";
          }
          if (typeof to !== "undefined") {
            name += numberFormatter(to, valueDecimals) + valueSuffix;
          }
          legendItems.push(extend77({
            chart,
            name,
            options: {},
            drawLegendSymbol: LegendSymbol_default.drawRectangle,
            visible: true,
            setState: noop20,
            isDataClass: true,
            setVisible: function() {
              vis = axis.visible = !vis;
              axis.series.forEach(function(series) {
                series.points.forEach(function(point) {
                  if (point.dataClass === i) {
                    point.setVisible(vis);
                  }
                });
              });
              chart.legend.colorizeItem(this, vis);
            }
          }, dataClass));
        });
      }
      return legendItems;
    };
    ColorAxis2.defaultColorAxisOptions = ColorAxisDefaults_default;
    ColorAxis2.defaultLegendLength = 200;
    ColorAxis2.keepProps = [
      "legendGroup",
      "legendItemHeight",
      "legendItemWidth",
      "legendItem",
      "legendSymbol"
    ];
    return ColorAxis2;
  }(Axis_default)
);
Array.prototype.push.apply(Axis_default.keepProps, ColorAxis.keepProps);
var ColorAxis_default = ColorAxis;

// node_modules/highcharts/es-modules/Mixins/ColorMapSeries.js
var defined52 = Utilities_default.defined;
var addEvent62 = Utilities_default.addEvent;
var noop21 = Globals_default.noop;
var seriesTypes8 = Globals_default.seriesTypes;
addEvent62(Point_default, "afterSetState", function(e2) {
  var point = this;
  if (point.moveToTopOnHover && point.graphic) {
    point.graphic.attr({
      zIndex: e2 && e2.state === "hover" ? 1 : 0
    });
  }
});
var colorMapPointMixin = {
  dataLabelOnNull: true,
  moveToTopOnHover: true,
  /* eslint-disable valid-jsdoc */
  /**
   * Color points have a value option that determines whether or not it is
   * a null point
   * @private
   */
  isValid: function() {
    return this.value !== null && this.value !== Infinity && this.value !== -Infinity;
  }
  /* eslint-enable valid-jsdoc */
};
var colorMapSeriesMixin = {
  pointArrayMap: ["value"],
  axisTypes: ["xAxis", "yAxis", "colorAxis"],
  trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
  getSymbol: noop21,
  parallelArrays: ["x", "y", "value"],
  colorKey: "value",
  pointAttribs: seriesTypes8.column.prototype.pointAttribs,
  /* eslint-disable valid-jsdoc */
  /**
   * Get the color attibutes to apply on the graphic
   * @private
   * @function Highcharts.colorMapSeriesMixin.colorAttribs
   * @param {Highcharts.Point} point
   * @return {Highcharts.SVGAttributes}
   */
  colorAttribs: function(point) {
    var ret = {};
    if (defined52(point.color) && (!point.state || point.state === "normal")) {
      ret[this.colorProp || "fill"] = point.color;
    }
    return ret;
  }
};
var exports4 = {
  colorMapPointMixin,
  colorMapSeriesMixin
};
var ColorMapSeries_default = exports4;

// node_modules/highcharts/es-modules/Series/Heatmap/HeatmapPoint.js
var __extends47 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var colorMapPointMixin2 = ColorMapSeries_default.colorMapPointMixin;
var ScatterPoint2 = SeriesRegistry_default.seriesTypes.scatter.prototype.pointClass;
var clamp18 = Utilities_default.clamp;
var extend78 = Utilities_default.extend;
var pick89 = Utilities_default.pick;
var HeatmapPoint = (
  /** @class */
  function(_super) {
    __extends47(HeatmapPoint2, _super);
    function HeatmapPoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.series = void 0;
      _this.value = void 0;
      _this.x = void 0;
      _this.y = void 0;
      return _this;
    }
    HeatmapPoint2.prototype.applyOptions = function(options, x) {
      var point = _super.prototype.applyOptions.call(this, options, x);
      point.formatPrefix = point.isNull || point.value === null ? "null" : "point";
      return point;
    };
    HeatmapPoint2.prototype.getCellAttributes = function() {
      var point = this, series = point.series, seriesOptions = series.options, xPad = (seriesOptions.colsize || 1) / 2, yPad = (seriesOptions.rowsize || 1) / 2, xAxis = series.xAxis, yAxis = series.yAxis, markerOptions = point.options.marker || series.options.marker, pointPlacement = series.pointPlacementToXValue(), pointPadding = pick89(point.pointPadding, seriesOptions.pointPadding, 0), cellAttr = {
        x1: clamp18(Math.round(xAxis.len - (xAxis.translate(point.x - xPad, false, true, false, true, -pointPlacement) || 0)), -xAxis.len, 2 * xAxis.len),
        x2: clamp18(Math.round(xAxis.len - (xAxis.translate(point.x + xPad, false, true, false, true, -pointPlacement) || 0)), -xAxis.len, 2 * xAxis.len),
        y1: clamp18(Math.round(yAxis.translate(point.y - yPad, false, true, false, true) || 0), -yAxis.len, 2 * yAxis.len),
        y2: clamp18(Math.round(yAxis.translate(point.y + yPad, false, true, false, true) || 0), -yAxis.len, 2 * yAxis.len)
      };
      [["width", "x"], ["height", "y"]].forEach(function(dimension) {
        var prop = dimension[0], direction = dimension[1];
        var start = direction + "1", end = direction + "2";
        var side = Math.abs(cellAttr[start] - cellAttr[end]), borderWidth = markerOptions && markerOptions.lineWidth || 0, plotPos = Math.abs(cellAttr[start] + cellAttr[end]) / 2;
        if (markerOptions[prop] && markerOptions[prop] < side) {
          cellAttr[start] = plotPos - markerOptions[prop] / 2 - borderWidth / 2;
          cellAttr[end] = plotPos + markerOptions[prop] / 2 + borderWidth / 2;
        }
        if (pointPadding) {
          if (direction === "y") {
            start = end;
            end = direction + "1";
          }
          cellAttr[start] += pointPadding;
          cellAttr[end] -= pointPadding;
        }
      });
      return cellAttr;
    };
    HeatmapPoint2.prototype.haloPath = function(size) {
      if (!size) {
        return [];
      }
      var rect2 = this.shapeArgs;
      return [
        "M",
        rect2.x - size,
        rect2.y - size,
        "L",
        rect2.x - size,
        rect2.y + rect2.height + size,
        rect2.x + rect2.width + size,
        rect2.y + rect2.height + size,
        rect2.x + rect2.width + size,
        rect2.y - size,
        "Z"
      ];
    };
    HeatmapPoint2.prototype.isValid = function() {
      return this.value !== Infinity && this.value !== -Infinity;
    };
    return HeatmapPoint2;
  }(ScatterPoint2)
);
extend78(HeatmapPoint.prototype, {
  dataLabelOnNull: colorMapPointMixin2.dataLabelOnNull,
  moveToTopOnHover: colorMapPointMixin2.moveToTopOnHover
});
var HeatmapPoint_default = HeatmapPoint;

// node_modules/highcharts/es-modules/Series/Heatmap/HeatmapSeries.js
var __extends48 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var colorMapSeriesMixin2 = ColorMapSeries_default.colorMapSeriesMixin;
var Series10 = SeriesRegistry_default.series;
var _a9 = SeriesRegistry_default.seriesTypes;
var ColumnSeries11 = _a9.column;
var ScatterSeries4 = _a9.scatter;
var symbols3 = SVGRenderer_default.prototype.symbols;
var extend79 = Utilities_default.extend;
var fireEvent37 = Utilities_default.fireEvent;
var isNumber48 = Utilities_default.isNumber;
var merge80 = Utilities_default.merge;
var pick90 = Utilities_default.pick;
var HeatmapSeries = (
  /** @class */
  function(_super) {
    __extends48(HeatmapSeries3, _super);
    function HeatmapSeries3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.colorAxis = void 0;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.valueMax = NaN;
      _this.valueMin = NaN;
      return _this;
    }
    HeatmapSeries3.prototype.drawPoints = function() {
      var _this = this;
      var seriesMarkerOptions = this.options.marker || {};
      if (seriesMarkerOptions.enabled || this._hasPointMarkers) {
        Series10.prototype.drawPoints.call(this);
        this.points.forEach(function(point) {
          if (point.graphic) {
            point.graphic[_this.chart.styledMode ? "css" : "animate"](_this.colorAttribs(point));
            if (_this.options.borderRadius) {
              point.graphic.attr({
                r: _this.options.borderRadius
              });
            }
            if (point.value === null) {
              point.graphic.addClass("highcharts-null-point");
            }
          }
        });
      }
    };
    HeatmapSeries3.prototype.getExtremes = function() {
      var _a15 = Series10.prototype.getExtremes.call(this, this.valueData), dataMin = _a15.dataMin, dataMax = _a15.dataMax;
      if (isNumber48(dataMin)) {
        this.valueMin = dataMin;
      }
      if (isNumber48(dataMax)) {
        this.valueMax = dataMax;
      }
      return Series10.prototype.getExtremes.call(this);
    };
    HeatmapSeries3.prototype.getValidPoints = function(points, insideOnly) {
      return Series10.prototype.getValidPoints.call(this, points, insideOnly, true);
    };
    HeatmapSeries3.prototype.hasData = function() {
      return !!this.processedXData.length;
    };
    HeatmapSeries3.prototype.init = function() {
      var options;
      Series10.prototype.init.apply(this, arguments);
      options = this.options;
      options.pointRange = pick90(options.pointRange, options.colsize || 1);
      this.yAxis.axisPointRange = options.rowsize || 1;
      symbols3.ellipse = symbols3.circle;
    };
    HeatmapSeries3.prototype.markerAttribs = function(point, state) {
      var pointMarkerOptions = point.marker || {}, seriesMarkerOptions = this.options.marker || {}, seriesStateOptions, pointStateOptions, shapeArgs = point.shapeArgs || {}, hasImage = point.hasImage, attribs = {};
      if (hasImage) {
        return {
          x: point.plotX,
          y: point.plotY
        };
      }
      if (state) {
        seriesStateOptions = seriesMarkerOptions.states[state] || {};
        pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
        [["width", "x"], ["height", "y"]].forEach(function(dimension) {
          attribs[dimension[0]] = (pointStateOptions[dimension[0]] || seriesStateOptions[dimension[0]] || shapeArgs[dimension[0]]) + (pointStateOptions[dimension[0] + "Plus"] || seriesStateOptions[dimension[0] + "Plus"] || 0);
          attribs[dimension[1]] = shapeArgs[dimension[1]] + (shapeArgs[dimension[0]] - attribs[dimension[0]]) / 2;
        });
      }
      return state ? attribs : shapeArgs;
    };
    HeatmapSeries3.prototype.pointAttribs = function(point, state) {
      var series = this, attr11 = Series10.prototype.pointAttribs.call(series, point, state), seriesOptions = series.options || {}, plotOptions = series.chart.options.plotOptions || {}, seriesPlotOptions = plotOptions.series || {}, heatmapPlotOptions = plotOptions.heatmap || {}, stateOptions, brightness, borderColor = point && point.options.borderColor || seriesOptions.borderColor || heatmapPlotOptions.borderColor || seriesPlotOptions.borderColor, borderWidth = point && point.options.borderWidth || seriesOptions.borderWidth || heatmapPlotOptions.borderWidth || seriesPlotOptions.borderWidth || attr11["stroke-width"];
      attr11.stroke = point && point.marker && point.marker.lineColor || seriesOptions.marker && seriesOptions.marker.lineColor || borderColor || this.color;
      attr11["stroke-width"] = borderWidth;
      if (state) {
        stateOptions = merge80(seriesOptions.states[state], seriesOptions.marker && seriesOptions.marker.states[state], point && point.options.states && point.options.states[state] || {});
        brightness = stateOptions.brightness;
        attr11.fill = stateOptions.color || Color_default.parse(attr11.fill).brighten(brightness || 0).get();
        attr11.stroke = stateOptions.lineColor;
      }
      return attr11;
    };
    HeatmapSeries3.prototype.setClip = function(animation) {
      var series = this, chart = series.chart;
      Series10.prototype.setClip.apply(series, arguments);
      if (series.options.clip !== false || animation) {
        series.markerGroup.clip((animation || series.clipBox) && series.sharedClipKey ? chart.sharedClips[series.sharedClipKey] : chart.clipRect);
      }
    };
    HeatmapSeries3.prototype.translate = function() {
      var series = this, options = series.options, symbol = options.marker && options.marker.symbol || "rect", shape = symbols3[symbol] ? symbol : "rect", hasRegularShape = ["circle", "square"].indexOf(shape) !== -1;
      series.generatePoints();
      series.points.forEach(function(point) {
        var pointAttr, sizeDiff, hasImage, cellAttr = point.getCellAttributes(), shapeArgs = {};
        shapeArgs.x = Math.min(cellAttr.x1, cellAttr.x2);
        shapeArgs.y = Math.min(cellAttr.y1, cellAttr.y2);
        shapeArgs.width = Math.max(Math.abs(cellAttr.x2 - cellAttr.x1), 0);
        shapeArgs.height = Math.max(Math.abs(cellAttr.y2 - cellAttr.y1), 0);
        hasImage = point.hasImage = (point.marker && point.marker.symbol || symbol || "").indexOf("url") === 0;
        if (hasRegularShape) {
          sizeDiff = Math.abs(shapeArgs.width - shapeArgs.height);
          shapeArgs.x = Math.min(cellAttr.x1, cellAttr.x2) + (shapeArgs.width < shapeArgs.height ? 0 : sizeDiff / 2);
          shapeArgs.y = Math.min(cellAttr.y1, cellAttr.y2) + (shapeArgs.width < shapeArgs.height ? sizeDiff / 2 : 0);
          shapeArgs.width = shapeArgs.height = Math.min(shapeArgs.width, shapeArgs.height);
        }
        pointAttr = {
          plotX: (cellAttr.x1 + cellAttr.x2) / 2,
          plotY: (cellAttr.y1 + cellAttr.y2) / 2,
          clientX: (cellAttr.x1 + cellAttr.x2) / 2,
          shapeType: "path",
          shapeArgs: merge80(true, shapeArgs, {
            d: symbols3[shape](shapeArgs.x, shapeArgs.y, shapeArgs.width, shapeArgs.height)
          })
        };
        if (hasImage) {
          point.marker = {
            width: shapeArgs.width,
            height: shapeArgs.height
          };
        }
        extend79(point, pointAttr);
      });
      fireEvent37(series, "afterTranslate");
    };
    HeatmapSeries3.defaultOptions = merge80(ScatterSeries4.defaultOptions, {
      /**
       * Animation is disabled by default on the heatmap series.
       */
      animation: false,
      /**
       * The border radius for each heatmap item.
       */
      borderRadius: 0,
      /**
       * The border width for each heatmap item.
       */
      borderWidth: 0,
      /**
       * Padding between the points in the heatmap.
       *
       * @type      {number}
       * @default   0
       * @since     6.0
       * @apioption plotOptions.heatmap.pointPadding
       */
      /**
       * @default   value
       * @apioption plotOptions.heatmap.colorKey
       */
      /**
       * The main color of the series. In heat maps this color is rarely used,
       * as we mostly use the color to denote the value of each point. Unless
       * options are set in the [colorAxis](#colorAxis), the default value
       * is pulled from the [options.colors](#colors) array.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     4.0
       * @product   highcharts
       * @apioption plotOptions.heatmap.color
       */
      /**
       * The column size - how many X axis units each column in the heatmap
       * should span.
       *
       * @sample {highcharts} maps/demo/heatmap/
       *         One day
       * @sample {highmaps} maps/demo/heatmap/
       *         One day
       *
       * @type      {number}
       * @default   1
       * @since     4.0
       * @product   highcharts highmaps
       * @apioption plotOptions.heatmap.colsize
       */
      /**
       * The row size - how many Y axis units each heatmap row should span.
       *
       * @sample {highcharts} maps/demo/heatmap/
       *         1 by default
       * @sample {highmaps} maps/demo/heatmap/
       *         1 by default
       *
       * @type      {number}
       * @default   1
       * @since     4.0
       * @product   highcharts highmaps
       * @apioption plotOptions.heatmap.rowsize
       */
      /**
       * The color applied to null points. In styled mode, a general CSS class
       * is applied instead.
       *
       * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       */
      nullColor: Palette_default.neutralColor3,
      dataLabels: {
        formatter: function() {
          var numberFormatter = this.series.chart.numberFormatter;
          var value = this.point.value;
          return isNumber48(value) ? numberFormatter(value, -1) : "";
        },
        inside: true,
        verticalAlign: "middle",
        crop: false,
        overflow: false,
        padding: 0
        // #3837
      },
      /**
       * @excluding radius, enabledThreshold
       * @since     8.1
       */
      marker: {
        /**
         * A predefined shape or symbol for the marker. When undefined, the
         * symbol is pulled from options.symbols. Other possible values are
         * `'circle'`, `'square'`,`'diamond'`, `'triangle'`,
         * `'triangle-down'`, `'rect'`, and `'ellipse'`.
         *
         * Additionally, the URL to a graphic can be given on this form:
         * `'url(graphic.png)'`. Note that for the image to be applied to
         * exported charts, its URL needs to be accessible by the export
         * server.
         *
         * Custom callbacks for symbol path generation can also be added to
         * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
         * used by its method name, as shown in the demo.
         *
         * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
         *         Predefined, graphic and custom markers
         * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
         *         Predefined, graphic and custom markers
         */
        symbol: "rect",
        /** @ignore-option */
        radius: 0,
        lineColor: void 0,
        states: {
          /**
           * @excluding radius, radiusPlus
           */
          hover: {
            /**
             * Set the marker's fixed width on hover state.
             *
             * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
             *         70px fixed marker's width and height on hover
             *
             * @type      {number|undefined}
             * @default   undefined
             * @product   highcharts highmaps
             * @apioption plotOptions.heatmap.marker.states.hover.width
             */
            /**
             * Set the marker's fixed height on hover state.
             *
             * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
             *         70px fixed marker's width and height on hover
             *
             * @type      {number|undefined}
             * @default   undefined
             * @product   highcharts highmaps
             * @apioption plotOptions.heatmap.marker.states.hover.height
             */
            /**
             * The number of pixels to increase the width of the
             * selected point.
             *
             * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
             *         20px greater width and height on hover
             *
             * @type      {number|undefined}
             * @default   undefined
             * @product   highcharts highmaps
             * @apioption plotOptions.heatmap.marker.states.hover.widthPlus
             */
            /**
             * The number of pixels to increase the height of the
             * selected point.
             *
             * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
            *          20px greater width and height on hover
             *
             * @type      {number|undefined}
             * @default   undefined
             * @product   highcharts highmaps
             * @apioption plotOptions.heatmap.marker.states.hover.heightPlus
             */
            /**
             * The additional line width for a hovered point.
             *
             * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-linewidthplus
             *         5 pixels wider lineWidth on hover
             * @sample {highmaps} maps/plotoptions/heatmap-marker-states-hover-linewidthplus
             *         5 pixels wider lineWidth on hover
             */
            lineWidthPlus: 0
          },
          /**
           * @excluding radius
           */
          select: {
            /**
             * Set the marker's fixed width on select state.
             *
             * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
             *         70px fixed marker's width and height on hover
             *
             * @type      {number|undefined}
             * @default   undefined
             * @product   highcharts highmaps
             * @apioption plotOptions.heatmap.marker.states.select.width
             */
            /**
             * Set the marker's fixed height on select state.
             *
             * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-width
             *         70px fixed marker's width and height on hover
             *
             * @type      {number|undefined}
             * @default   undefined
             * @product   highcharts highmaps
             * @apioption plotOptions.heatmap.marker.states.select.height
             */
            /**
             * The number of pixels to increase the width of the
             * selected point.
             *
             * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
             *         20px greater width and height on hover
             *
             * @type      {number|undefined}
             * @default   undefined
             * @product   highcharts highmaps
             * @apioption plotOptions.heatmap.marker.states.select.widthPlus
             */
            /**
             * The number of pixels to increase the height of the
             * selected point.
             *
             * @sample {highcharts} maps/plotoptions/heatmap-marker-states-hover-widthplus
             *         20px greater width and height on hover
             *
             * @type      {number|undefined}
             * @default   undefined
             * @product   highcharts highmaps
             * @apioption plotOptions.heatmap.marker.states.select.heightPlus
             */
          }
        }
      },
      clip: true,
      /** @ignore-option */
      pointRange: null,
      tooltip: {
        pointFormat: "{point.x}, {point.y}: {point.value}<br/>"
      },
      states: {
        hover: {
          /** @ignore-option */
          halo: false,
          /**
           * How much to brighten the point on interaction. Requires the
           * main color to be defined in hex or rgb(a) format.
           *
           * In styled mode, the hover brightening is by default replaced
           * with a fill-opacity set in the `.highcharts-point:hover`
           * rule.
           */
          brightness: 0.2
        }
      }
    });
    return HeatmapSeries3;
  }(ScatterSeries4)
);
extend79(HeatmapSeries.prototype, {
  /**
   * @private
   */
  alignDataLabel: ColumnSeries11.prototype.alignDataLabel,
  axisTypes: colorMapSeriesMixin2.axisTypes,
  colorAttribs: colorMapSeriesMixin2.colorAttribs,
  colorKey: colorMapSeriesMixin2.colorKey,
  directTouch: true,
  /**
   * @private
   */
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  getExtremesFromAll: true,
  getSymbol: Series10.prototype.getSymbol,
  parallelArrays: colorMapSeriesMixin2.parallelArrays,
  pointArrayMap: ["y", "value"],
  pointClass: HeatmapPoint_default,
  trackerGroups: colorMapSeriesMixin2.trackerGroups
});
SeriesRegistry_default.registerSeriesType("heatmap", HeatmapSeries);

// node_modules/highcharts/es-modules/masters/modules/heatmap.src.js
var G8 = Globals_default;
G8.ColorAxis = ColorAxis_default;
ColorAxis_default.compose(G8.Chart, G8.Fx, G8.Legend, G8.Series);

// node_modules/highcharts/es-modules/Core/Axis/SolidGaugeAxis.js
var color15 = Color_default.parse;
var extend80 = Utilities_default.extend;
var merge81 = Utilities_default.merge;
var SolidGaugeAxis;
(function(SolidGaugeAxis2) {
  var methods = {
    initDataClasses: function(userOptions) {
      var chart = this.chart, dataClasses, colorCounter = 0, options = this.options;
      this.dataClasses = dataClasses = [];
      userOptions.dataClasses.forEach(function(dataClass, i) {
        var colors;
        dataClass = merge81(dataClass);
        dataClasses.push(dataClass);
        if (!dataClass.color) {
          if (options.dataClassColor === "category") {
            colors = chart.options.colors;
            dataClass.color = colors[colorCounter++];
            if (colorCounter === colors.length) {
              colorCounter = 0;
            }
          } else {
            dataClass.color = color15(options.minColor).tweenTo(color15(options.maxColor), i / (userOptions.dataClasses.length - 1));
          }
        }
      });
    },
    initStops: function(userOptions) {
      this.stops = userOptions.stops || [
        [0, this.options.minColor],
        [1, this.options.maxColor]
      ];
      this.stops.forEach(function(stop4) {
        stop4.color = color15(stop4[1]);
      });
    },
    // Translate from a value to a color
    toColor: function(value, point) {
      var pos, stops = this.stops, from, to, color18, dataClasses = this.dataClasses, dataClass, i;
      if (dataClasses) {
        i = dataClasses.length;
        while (i--) {
          dataClass = dataClasses[i];
          from = dataClass.from;
          to = dataClass.to;
          if ((typeof from === "undefined" || value >= from) && (typeof to === "undefined" || value <= to)) {
            color18 = dataClass.color;
            if (point) {
              point.dataClass = i;
            }
            break;
          }
        }
      } else {
        if (this.logarithmic) {
          value = this.val2lin(value);
        }
        pos = 1 - (this.max - value) / (this.max - this.min);
        i = stops.length;
        while (i--) {
          if (pos > stops[i][0]) {
            break;
          }
        }
        from = stops[i] || stops[i + 1];
        to = stops[i + 1] || from;
        pos = 1 - (to[0] - pos) / (to[0] - from[0] || 1);
        color18 = from.color.tweenTo(to.color, pos);
      }
      return color18;
    }
  };
  function init(axis) {
    extend80(axis, methods);
  }
  SolidGaugeAxis2.init = init;
})(SolidGaugeAxis || (SolidGaugeAxis = {}));
var SolidGaugeAxis_default = SolidGaugeAxis;

// node_modules/highcharts/es-modules/Series/SolidGauge/SolidGaugeComposition.js
var _a10 = SVGRenderer_default.prototype;
var symbols4 = _a10.symbols;
var arc2 = _a10.symbols.arc;
symbols4.arc = function(x, y, w2, h, options) {
  var path = arc2(x, y, w2, h, options);
  if (options && options.rounded) {
    var r = options.r || w2, smallR = (r - (options.innerR || 0)) / 2, outerArcStart = path[0], innerArcStart = path[2];
    if (outerArcStart[0] === "M" && innerArcStart[0] === "L") {
      var x1 = outerArcStart[1], y1 = outerArcStart[2], x2 = innerArcStart[1], y2 = innerArcStart[2], roundStart = ["A", smallR, smallR, 0, 1, 1, x1, y1], roundEnd = ["A", smallR, smallR, 0, 1, 1, x2, y2];
      path[2] = roundEnd;
      path[4] = roundStart;
    }
  }
  return path;
};

// node_modules/highcharts/es-modules/Series/SolidGauge/SolidGaugeSeries.js
var __extends49 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a11 = SeriesRegistry_default.seriesTypes;
var GaugeSeries2 = _a11.gauge;
var pieProto = _a11.pie.prototype;
var clamp19 = Utilities_default.clamp;
var extend81 = Utilities_default.extend;
var isNumber49 = Utilities_default.isNumber;
var merge82 = Utilities_default.merge;
var pick91 = Utilities_default.pick;
var pInt11 = Utilities_default.pInt;
var solidGaugeOptions = {
  /**
   * The inner radius for points in a solid gauge. Can be given as a number
   * (pixels) or percentage string.
   *
   * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/
   *         Individual radius and innerRadius
   *
   * @type      {number|string}
   * @default   60
   * @since     4.1.6
   * @product   highcharts
   * @apioption plotOptions.solidgauge.innerRadius
   */
  /**
   * Whether the strokes of the solid gauge should be `round` or `square`.
   *
   * @sample {highcharts} highcharts/demo/gauge-activity/
   *         Rounded gauge
   *
   * @type       {string}
   * @default    round
   * @since      4.2.2
   * @product    highcharts
   * @validvalue ["square", "round"]
   * @apioption  plotOptions.solidgauge.linecap
   */
  /**
   * Allow the gauge to overshoot the end of the perimeter axis by this
   * many degrees. Say if the gauge axis goes from 0 to 60, a value of
   * 100, or 1000, will show 5 degrees beyond the end of the axis when this
   * option is set to 5.
   *
   * @type      {number}
   * @default   0
   * @since     3.0.10
   * @product   highcharts
   * @apioption plotOptions.solidgauge.overshoot
   */
  /**
   * The outer radius for points in a solid gauge. Can be given as a number
   * (pixels) or percentage string.
   *
   * @sample {highcharts} highcharts/plotoptions/solidgauge-radius/
   *         Individual radius and innerRadius
   *
   * @type      {number|string}
   * @default   100
   * @since     4.1.6
   * @product   highcharts
   * @apioption plotOptions.solidgauge.radius
   */
  /**
   * Wether to draw rounded edges on the gauge.
   *
   * @sample {highcharts} highcharts/demo/gauge-activity/
   *         Activity Gauge
   *
   * @type      {boolean}
   * @default   false
   * @since     5.0.8
   * @product   highcharts
   * @apioption plotOptions.solidgauge.rounded
   */
  /**
   * The threshold or base level for the gauge.
   *
   * @sample {highcharts} highcharts/plotoptions/solidgauge-threshold/
   *         Zero threshold with negative and positive values
   *
   * @type      {number|null}
   * @since     5.0.3
   * @product   highcharts
   * @apioption plotOptions.solidgauge.threshold
   */
  /**
   * Whether to give each point an individual color.
   */
  colorByPoint: true,
  dataLabels: {
    y: 0
  }
};
var SolidGaugeSeries = (
  /** @class */
  function(_super) {
    __extends49(SolidGaugeSeries2, _super);
    function SolidGaugeSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.points = void 0;
      _this.options = void 0;
      _this.axis = void 0;
      _this.yAxis = void 0;
      _this.startAngleRad = void 0;
      _this.thresholdAngleRad = void 0;
      return _this;
    }
    SolidGaugeSeries2.prototype.translate = function() {
      var axis = this.yAxis;
      SolidGaugeAxis_default.init(axis);
      if (!axis.dataClasses && axis.options.dataClasses) {
        axis.initDataClasses(axis.options);
      }
      axis.initStops(axis.options);
      GaugeSeries2.prototype.translate.call(this);
    };
    SolidGaugeSeries2.prototype.drawPoints = function() {
      var series = this, yAxis = series.yAxis, center = yAxis.center, options = series.options, renderer = series.chart.renderer, overshoot = options.overshoot, overshootVal = isNumber49(overshoot) ? overshoot / 180 * Math.PI : 0, thresholdAngleRad;
      if (isNumber49(options.threshold)) {
        thresholdAngleRad = yAxis.startAngleRad + yAxis.translate(options.threshold, null, null, null, true);
      }
      this.thresholdAngleRad = pick91(thresholdAngleRad, yAxis.startAngleRad);
      series.points.forEach(function(point) {
        if (!point.isNull) {
          var graphic = point.graphic, rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true), radius = pInt11(pick91(point.options.radius, options.radius, 100)) * center[2] / 200, innerRadius = pInt11(pick91(point.options.innerRadius, options.innerRadius, 60)) * center[2] / 200, shapeArgs = void 0, d = void 0, toColor = yAxis.toColor(point.y, point), axisMinAngle = Math.min(yAxis.startAngleRad, yAxis.endAngleRad), axisMaxAngle = Math.max(yAxis.startAngleRad, yAxis.endAngleRad), minAngle = void 0, maxAngle = void 0;
          if (toColor === "none") {
            toColor = point.color || series.color || "none";
          }
          if (toColor !== "none") {
            point.color = toColor;
          }
          rotation = clamp19(rotation, axisMinAngle - overshootVal, axisMaxAngle + overshootVal);
          if (options.wrap === false) {
            rotation = clamp19(rotation, axisMinAngle, axisMaxAngle);
          }
          minAngle = Math.min(rotation, series.thresholdAngleRad);
          maxAngle = Math.max(rotation, series.thresholdAngleRad);
          if (maxAngle - minAngle > 2 * Math.PI) {
            maxAngle = minAngle + 2 * Math.PI;
          }
          point.shapeArgs = shapeArgs = {
            x: center[0],
            y: center[1],
            r: radius,
            innerR: innerRadius,
            start: minAngle,
            end: maxAngle,
            rounded: options.rounded
          };
          point.startR = radius;
          if (graphic) {
            d = shapeArgs.d;
            graphic.animate(extend81({ fill: toColor }, shapeArgs));
            if (d) {
              shapeArgs.d = d;
            }
          } else {
            point.graphic = graphic = renderer.arc(shapeArgs).attr({
              fill: toColor,
              "sweep-flag": 0
            }).add(series.group);
          }
          if (!series.chart.styledMode) {
            if (options.linecap !== "square") {
              graphic.attr({
                "stroke-linecap": "round",
                "stroke-linejoin": "round"
              });
            }
            graphic.attr({
              stroke: options.borderColor || "none",
              "stroke-width": options.borderWidth || 0
            });
          }
          if (graphic) {
            graphic.addClass(point.getClassName(), true);
          }
        }
      });
    };
    SolidGaugeSeries2.prototype.animate = function(init) {
      if (!init) {
        this.startAngleRad = this.thresholdAngleRad;
        pieProto.animate.call(this, init);
      }
    };
    SolidGaugeSeries2.defaultOptions = merge82(GaugeSeries2.defaultOptions, solidGaugeOptions);
    return SolidGaugeSeries2;
  }(GaugeSeries2)
);
extend81(SolidGaugeSeries.prototype, {
  drawLegendSymbol: LegendSymbol_default.drawRectangle
});
SeriesRegistry_default.registerSeriesType("solidgauge", SolidGaugeSeries);

// node_modules/highcharts/es-modules/Series/Treemap/TreemapAlgorithmGroup.js
var TreemapAlgorithmGroup = (
  /** @class */
  function() {
    function TreemapAlgorithmGroup2(h, w2, d, p) {
      this.height = h;
      this.width = w2;
      this.plot = p;
      this.direction = d;
      this.startDirection = d;
      this.total = 0;
      this.nW = 0;
      this.lW = 0;
      this.nH = 0;
      this.lH = 0;
      this.elArr = [];
      this.lP = {
        total: 0,
        lH: 0,
        nH: 0,
        lW: 0,
        nW: 0,
        nR: 0,
        lR: 0,
        aspectRatio: function(w3, h2) {
          return Math.max(w3 / h2, h2 / w3);
        }
      };
    }
    TreemapAlgorithmGroup2.prototype.addElement = function(el) {
      this.lP.total = this.elArr[this.elArr.length - 1];
      this.total = this.total + el;
      if (this.direction === 0) {
        this.lW = this.nW;
        this.lP.lH = this.lP.total / this.lW;
        this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH);
        this.nW = this.total / this.height;
        this.lP.nH = this.lP.total / this.nW;
        this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH);
      } else {
        this.lH = this.nH;
        this.lP.lW = this.lP.total / this.lH;
        this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH);
        this.nH = this.total / this.width;
        this.lP.nW = this.lP.total / this.nH;
        this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH);
      }
      this.elArr.push(el);
    };
    TreemapAlgorithmGroup2.prototype.reset = function() {
      this.nW = 0;
      this.lW = 0;
      this.elArr = [];
      this.total = 0;
    };
    return TreemapAlgorithmGroup2;
  }()
);
var TreemapAlgorithmGroup_default = TreemapAlgorithmGroup;

// node_modules/highcharts/es-modules/Mixins/DrawPoint.js
var isFn = function(x) {
  return typeof x === "function";
};
var draw = function draw2(params) {
  var _this = this;
  var animatableAttribs = params.animatableAttribs, onComplete = params.onComplete, css16 = params.css, renderer = params.renderer;
  var animation = this.series && this.series.chart.hasRendered ? (
    // Chart-level animation on updates
    void 0
  ) : (
    // Series-level animation on new points
    this.series && this.series.options.animation
  );
  var graphic = this.graphic;
  if (this.shouldDraw()) {
    if (!graphic) {
      this.graphic = graphic = renderer[params.shapeType](params.shapeArgs).add(params.group);
    }
    graphic.css(css16).attr(params.attribs).animate(animatableAttribs, params.isNew ? false : animation, onComplete);
  } else if (graphic) {
    var destroy_1 = function() {
      _this.graphic = graphic = graphic && graphic.destroy();
      if (isFn(onComplete)) {
        onComplete();
      }
    };
    if (Object.keys(animatableAttribs).length) {
      graphic.animate(animatableAttribs, void 0, function() {
        destroy_1();
      });
    } else {
      destroy_1();
    }
  }
};
var drawPoint = function drawPoint2(params) {
  var point = this, attribs = params.attribs = params.attribs || {};
  attribs["class"] = point.getClassName();
  draw.call(point, params);
};
var drawPointModule = {
  draw,
  drawPoint,
  isFn
};
var DrawPoint_default = drawPointModule;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapPoint.js
var __extends50 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Point3 = SeriesRegistry_default.series.prototype.pointClass;
var _a12 = SeriesRegistry_default.seriesTypes;
var PiePoint3 = _a12.pie.prototype.pointClass;
var ScatterPoint3 = _a12.scatter.prototype.pointClass;
var extend82 = Utilities_default.extend;
var isNumber50 = Utilities_default.isNumber;
var pick92 = Utilities_default.pick;
var TreemapPoint = (
  /** @class */
  function(_super) {
    __extends50(TreemapPoint2, _super);
    function TreemapPoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.name = void 0;
      _this.node = void 0;
      _this.options = void 0;
      _this.series = void 0;
      _this.value = void 0;
      return _this;
    }
    TreemapPoint2.prototype.getClassName = function() {
      var className = Point3.prototype.getClassName.call(this), series = this.series, options = series.options;
      if (this.node.level <= series.nodeMap[series.rootNode].level) {
        className += " highcharts-above-level";
      } else if (!this.node.isLeaf && !pick92(options.interactByLeaf, !options.allowTraversingTree)) {
        className += " highcharts-internal-node-interactive";
      } else if (!this.node.isLeaf) {
        className += " highcharts-internal-node";
      }
      return className;
    };
    TreemapPoint2.prototype.isValid = function() {
      return Boolean(this.id || isNumber50(this.value));
    };
    TreemapPoint2.prototype.setState = function(state) {
      Point3.prototype.setState.call(this, state);
      if (this.graphic) {
        this.graphic.attr({
          zIndex: state === "hover" ? 1 : 0
        });
      }
    };
    TreemapPoint2.prototype.shouldDraw = function() {
      return isNumber50(this.plotY) && this.y !== null;
    };
    return TreemapPoint2;
  }(ScatterPoint3)
);
extend82(TreemapPoint.prototype, {
  draw: DrawPoint_default.drawPoint,
  setVisible: PiePoint3.prototype.setVisible
});
var TreemapPoint_default = TreemapPoint;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapUtilities.js
var objectEach37 = Utilities_default.objectEach;
var TreemapUtilities;
(function(TreemapUtilities2) {
  TreemapUtilities2.AXIS_MAX = 100;
  function isBoolean2(x) {
    return typeof x === "boolean";
  }
  TreemapUtilities2.isBoolean = isBoolean2;
  function eachObject(list, func, context) {
    context = context || this;
    objectEach37(list, function(val, key) {
      func.call(context, val, key, list);
    });
  }
  TreemapUtilities2.eachObject = eachObject;
  function recursive(item, func, context) {
    if (context === void 0) {
      context = this;
    }
    var next;
    next = func.call(context, item);
    if (next !== false) {
      recursive(next, func, context);
    }
  }
  TreemapUtilities2.recursive = recursive;
})(TreemapUtilities || (TreemapUtilities = {}));
var TreemapUtilities_default = TreemapUtilities;

// node_modules/highcharts/es-modules/Mixins/TreeSeries.js
var extend83 = Utilities_default.extend;
var isArray23 = Utilities_default.isArray;
var isNumber51 = Utilities_default.isNumber;
var isObject13 = Utilities_default.isObject;
var merge83 = Utilities_default.merge;
var pick93 = Utilities_default.pick;
var isBoolean = function(x) {
  return typeof x === "boolean";
};
var isFn2 = function(x) {
  return typeof x === "function";
};
var setTreeValues = function setTreeValues2(tree, options) {
  var before = options.before, idRoot = options.idRoot, mapIdToNode = options.mapIdToNode, nodeRoot = mapIdToNode[idRoot], levelIsConstant = isBoolean(options.levelIsConstant) ? options.levelIsConstant : true, points = options.points, point = points[tree.i], optionsPoint = point && point.options || {}, childrenTotal = 0, children = [], value;
  tree.levelDynamic = tree.level - (levelIsConstant ? 0 : nodeRoot.level);
  tree.name = pick93(point && point.name, "");
  tree.visible = idRoot === tree.id || (isBoolean(options.visible) ? options.visible : false);
  if (isFn2(before)) {
    tree = before(tree, options);
  }
  tree.children.forEach(function(child, i) {
    var newOptions = extend83({}, options);
    extend83(newOptions, {
      index: i,
      siblings: tree.children.length,
      visible: tree.visible
    });
    child = setTreeValues2(child, newOptions);
    children.push(child);
    if (child.visible) {
      childrenTotal += child.val;
    }
  });
  value = pick93(optionsPoint.value, childrenTotal);
  tree.visible = value >= 0 && (childrenTotal > 0 || tree.visible);
  tree.children = children;
  tree.childrenTotal = childrenTotal;
  tree.isLeaf = tree.visible && !childrenTotal;
  tree.val = value;
  return tree;
};
var getColor = function getColor2(node, options) {
  var index = options.index, mapOptionsToLevel = options.mapOptionsToLevel, parentColor = options.parentColor, parentColorIndex = options.parentColorIndex, series = options.series, colors = options.colors, siblings = options.siblings, points = series.points, getColorByPoint, chartOptionsChart = series.chart.options.chart, point, level, colorByPoint, colorIndexByPoint, color18, colorIndex;
  function variation(color19) {
    var colorVariation = level && level.colorVariation;
    if (colorVariation) {
      if (colorVariation.key === "brightness") {
        return Color_default.parse(color19).brighten(colorVariation.to * (index / siblings)).get();
      }
    }
    return color19;
  }
  if (node) {
    point = points[node.i];
    level = mapOptionsToLevel[node.level] || {};
    getColorByPoint = point && level.colorByPoint;
    if (getColorByPoint) {
      colorIndexByPoint = point.index % (colors ? colors.length : chartOptionsChart.colorCount);
      colorByPoint = colors && colors[colorIndexByPoint];
    }
    if (!series.chart.styledMode) {
      color18 = pick93(point && point.options.color, level && level.color, colorByPoint, parentColor && variation(parentColor), series.color);
    }
    colorIndex = pick93(point && point.options.colorIndex, level && level.colorIndex, colorIndexByPoint, parentColorIndex, options.colorIndex);
  }
  return {
    color: color18,
    colorIndex
  };
};
var getLevelOptions = function getLevelOptions2(params) {
  var result2 = null, defaults, converted, i, from, to, levels;
  if (isObject13(params)) {
    result2 = {};
    from = isNumber51(params.from) ? params.from : 1;
    levels = params.levels;
    converted = {};
    defaults = isObject13(params.defaults) ? params.defaults : {};
    if (isArray23(levels)) {
      converted = levels.reduce(function(obj, item) {
        var level, levelIsConstant, options;
        if (isObject13(item) && isNumber51(item.level)) {
          options = merge83({}, item);
          levelIsConstant = isBoolean(options.levelIsConstant) ? options.levelIsConstant : defaults.levelIsConstant;
          delete options.levelIsConstant;
          delete options.level;
          level = item.level + (levelIsConstant ? 0 : from - 1);
          if (isObject13(obj[level])) {
            extend83(obj[level], options);
          } else {
            obj[level] = options;
          }
        }
        return obj;
      }, {});
    }
    to = isNumber51(params.to) ? params.to : 1;
    for (i = 0; i <= to; i++) {
      result2[i] = merge83({}, defaults, isObject13(converted[i]) ? converted[i] : {});
    }
  }
  return result2;
};
var updateRootId = function(series) {
  var rootId, options;
  if (isObject13(series)) {
    options = isObject13(series.options) ? series.options : {};
    rootId = pick93(series.rootNode, options.rootId, "");
    if (isObject13(series.userOptions)) {
      series.userOptions.rootId = rootId;
    }
    series.rootNode = rootId;
  }
  return rootId;
};
var result = {
  getColor,
  getLevelOptions,
  setTreeValues,
  updateRootId
};
var TreeSeries_default = result;

// node_modules/highcharts/es-modules/Series/Treemap/TreemapComposition.js
var Series11 = SeriesRegistry_default.series;
var addEvent63 = Utilities_default.addEvent;
var extend84 = Utilities_default.extend;
var treemapAxisDefaultValues = false;
addEvent63(Series11, "afterBindAxes", function() {
  var series = this, xAxis = series.xAxis, yAxis = series.yAxis, treeAxis;
  if (xAxis && yAxis) {
    if (series.is("treemap")) {
      treeAxis = {
        endOnTick: false,
        gridLineWidth: 0,
        lineWidth: 0,
        min: 0,
        // dataMin: 0,
        minPadding: 0,
        max: TreemapUtilities_default.AXIS_MAX,
        // dataMax: TreemapUtilities.AXIS_MAX,
        maxPadding: 0,
        startOnTick: false,
        title: void 0,
        tickPositions: []
      };
      extend84(yAxis.options, treeAxis);
      extend84(xAxis.options, treeAxis);
      treemapAxisDefaultValues = true;
    } else if (treemapAxisDefaultValues) {
      yAxis.setOptions(yAxis.userOptions);
      xAxis.setOptions(xAxis.userOptions);
      treemapAxisDefaultValues = false;
    }
  }
});

// node_modules/highcharts/es-modules/Series/Treemap/TreemapSeries.js
var __extends51 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color16 = Color_default.parse;
var colorMapSeriesMixin3 = ColorMapSeries_default.colorMapSeriesMixin;
var noop22 = Globals_default.noop;
var Series12 = SeriesRegistry_default.series;
var _a13 = SeriesRegistry_default.seriesTypes;
var ColumnSeries12 = _a13.column;
var HeatmapSeries2 = _a13.heatmap;
var ScatterSeries5 = _a13.scatter;
var getColor3 = TreeSeries_default.getColor;
var getLevelOptions3 = TreeSeries_default.getLevelOptions;
var updateRootId2 = TreeSeries_default.updateRootId;
var addEvent64 = Utilities_default.addEvent;
var correctFloat13 = Utilities_default.correctFloat;
var defined53 = Utilities_default.defined;
var error11 = Utilities_default.error;
var extend85 = Utilities_default.extend;
var fireEvent38 = Utilities_default.fireEvent;
var isArray24 = Utilities_default.isArray;
var isObject14 = Utilities_default.isObject;
var isString13 = Utilities_default.isString;
var merge84 = Utilities_default.merge;
var pick94 = Utilities_default.pick;
var stableSort7 = Utilities_default.stableSort;
var TreemapSeries = (
  /** @class */
  function(_super) {
    __extends51(TreemapSeries2, _super);
    function TreemapSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.axisRatio = void 0;
      _this.data = void 0;
      _this.mapOptionsToLevel = void 0;
      _this.nodeMap = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.rootNode = void 0;
      _this.tree = void 0;
      return _this;
    }
    TreemapSeries2.prototype.algorithmCalcPoints = function(directionChange, last, group, childrenArea) {
      var pX, pY, pW, pH, gW = group.lW, gH = group.lH, plot = group.plot, keep, i = 0, end = group.elArr.length - 1;
      if (last) {
        gW = group.nW;
        gH = group.nH;
      } else {
        keep = group.elArr[group.elArr.length - 1];
      }
      group.elArr.forEach(function(p) {
        if (last || i < end) {
          if (group.direction === 0) {
            pX = plot.x;
            pY = plot.y;
            pW = gW;
            pH = p / pW;
          } else {
            pX = plot.x;
            pY = plot.y;
            pH = gH;
            pW = p / pH;
          }
          childrenArea.push({
            x: pX,
            y: pY,
            width: pW,
            height: correctFloat13(pH)
          });
          if (group.direction === 0) {
            plot.y = plot.y + pH;
          } else {
            plot.x = plot.x + pW;
          }
        }
        i = i + 1;
      });
      group.reset();
      if (group.direction === 0) {
        group.width = group.width - gW;
      } else {
        group.height = group.height - gH;
      }
      plot.y = plot.parent.y + (plot.parent.height - group.height);
      plot.x = plot.parent.x + (plot.parent.width - group.width);
      if (directionChange) {
        group.direction = 1 - group.direction;
      }
      if (!last) {
        group.addElement(keep);
      }
    };
    TreemapSeries2.prototype.algorithmFill = function(directionChange, parent, children) {
      var childrenArea = [], pTot, direction = parent.direction, x = parent.x, y = parent.y, width = parent.width, height = parent.height, pX, pY, pW, pH;
      children.forEach(function(child) {
        pTot = parent.width * parent.height * (child.val / parent.val);
        pX = x;
        pY = y;
        if (direction === 0) {
          pH = height;
          pW = pTot / pH;
          width = width - pW;
          x = x + pW;
        } else {
          pW = width;
          pH = pTot / pW;
          height = height - pH;
          y = y + pH;
        }
        childrenArea.push({
          x: pX,
          y: pY,
          width: pW,
          height: pH
        });
        if (directionChange) {
          direction = 1 - direction;
        }
      });
      return childrenArea;
    };
    TreemapSeries2.prototype.algorithmLowAspectRatio = function(directionChange, parent, children) {
      var childrenArea = [], series = this, pTot, plot = {
        x: parent.x,
        y: parent.y,
        parent
      }, direction = parent.direction, i = 0, end = children.length - 1, group = new TreemapAlgorithmGroup_default(parent.height, parent.width, direction, plot);
      children.forEach(function(child) {
        pTot = parent.width * parent.height * (child.val / parent.val);
        group.addElement(pTot);
        if (group.lP.nR > group.lP.lR) {
          series.algorithmCalcPoints(
            directionChange,
            false,
            group,
            childrenArea,
            plot
            // @todo no supported
          );
        }
        if (i === end) {
          series.algorithmCalcPoints(
            directionChange,
            true,
            group,
            childrenArea,
            plot
            // @todo not supported
          );
        }
        i = i + 1;
      });
      return childrenArea;
    };
    TreemapSeries2.prototype.alignDataLabel = function(point, dataLabel, labelOptions) {
      var style = labelOptions.style;
      if (style && !defined53(style.textOverflow) && dataLabel.text && dataLabel.getBBox().width > dataLabel.text.textWidth) {
        dataLabel.css({
          textOverflow: "ellipsis",
          // unit (px) is required when useHTML is true
          width: style.width += "px"
        });
      }
      ColumnSeries12.prototype.alignDataLabel.apply(this, arguments);
      if (point.dataLabel) {
        point.dataLabel.attr({ zIndex: (point.node.zIndex || 0) + 1 });
      }
    };
    TreemapSeries2.prototype.buildNode = function(id, i, level, list, parent) {
      var series = this, children = [], point = series.points[i], height = 0, node, child;
      (list[id] || []).forEach(function(i2) {
        child = series.buildNode(series.points[i2].id, i2, level + 1, list, id);
        height = Math.max(child.height + 1, height);
        children.push(child);
      });
      node = {
        id,
        i,
        children,
        height,
        level,
        parent,
        visible: false
        // @todo move this to better location
      };
      series.nodeMap[node.id] = node;
      if (point) {
        point.node = node;
      }
      return node;
    };
    TreemapSeries2.prototype.calculateChildrenAreas = function(parent, area) {
      var series = this, options = series.options, mapOptionsToLevel = series.mapOptionsToLevel, level = mapOptionsToLevel[parent.level + 1], algorithm = pick94(series[level && level.layoutAlgorithm] && level.layoutAlgorithm, options.layoutAlgorithm), alternate = options.alternateStartingDirection, childrenValues = [], children;
      children = parent.children.filter(function(n) {
        return !n.ignore;
      });
      if (level && level.layoutStartingDirection) {
        area.direction = level.layoutStartingDirection === "vertical" ? 0 : 1;
      }
      childrenValues = series[algorithm](area, children);
      children.forEach(function(child, index) {
        var values = childrenValues[index];
        child.values = merge84(values, {
          val: child.childrenTotal,
          direction: alternate ? 1 - area.direction : area.direction
        });
        child.pointValues = merge84(values, {
          x: values.x / series.axisRatio,
          // Flip y-values to avoid visual regression with csvCoord in
          // Axis.translate at setPointValues. #12488
          y: TreemapUtilities_default.AXIS_MAX - values.y - values.height,
          width: values.width / series.axisRatio
        });
        if (child.children.length) {
          series.calculateChildrenAreas(child, child.values);
        }
      });
    };
    TreemapSeries2.prototype.drawDataLabels = function() {
      var series = this, mapOptionsToLevel = series.mapOptionsToLevel, points = series.points.filter(function(n) {
        return n.node.visible;
      }), options, level;
      points.forEach(function(point) {
        level = mapOptionsToLevel[point.node.level];
        options = { style: {} };
        if (!point.node.isLeaf) {
          options.enabled = false;
        }
        if (level && level.dataLabels) {
          options = merge84(options, level.dataLabels);
          series._hasPointLabels = true;
        }
        if (point.shapeArgs) {
          options.style.width = point.shapeArgs.width;
          if (point.dataLabel) {
            point.dataLabel.css({
              width: point.shapeArgs.width + "px"
            });
          }
        }
        point.dlOptions = merge84(options, point.options.dataLabels);
      });
      Series12.prototype.drawDataLabels.call(this);
    };
    TreemapSeries2.prototype.drawPoints = function() {
      var series = this, chart = series.chart, renderer = chart.renderer, points = series.points, styledMode = chart.styledMode, options = series.options, shadow = styledMode ? {} : options.shadow, borderRadius = options.borderRadius, withinAnimationLimit = chart.pointCount < options.animationLimit, allowTraversingTree = options.allowTraversingTree;
      points.forEach(function(point) {
        var levelDynamic = point.node.levelDynamic, animatableAttribs = {}, attribs = {}, css16 = {}, groupKey = "level-group-" + point.node.level, hasGraphic = !!point.graphic, shouldAnimate = withinAnimationLimit && hasGraphic, shapeArgs = point.shapeArgs;
        if (point.shouldDraw()) {
          point.isInside = true;
          if (borderRadius) {
            attribs.r = borderRadius;
          }
          merge84(
            true,
            // Extend object
            // Which object to extend
            shouldAnimate ? animatableAttribs : attribs,
            // Add shapeArgs to animate/attr if graphic exists
            hasGraphic ? shapeArgs : {},
            // Add style attribs if !styleMode
            styledMode ? {} : series.pointAttribs(point, point.selected ? "select" : void 0)
          );
          if (series.colorAttribs && styledMode) {
            extend85(css16, series.colorAttribs(point));
          }
          if (!series[groupKey]) {
            series[groupKey] = renderer.g(groupKey).attr({
              // @todo Set the zIndex based upon the number of
              // levels, instead of using 1000
              zIndex: 1e3 - (levelDynamic || 0)
            }).add(series.group);
            series[groupKey].survive = true;
          }
        }
        point.draw({
          animatableAttribs,
          attribs,
          css: css16,
          group: series[groupKey],
          renderer,
          shadow,
          shapeArgs,
          shapeType: "rect"
        });
        if (allowTraversingTree && point.graphic) {
          point.drillId = options.interactByLeaf ? series.drillToByLeaf(point) : series.drillToByGroup(point);
        }
      });
    };
    TreemapSeries2.prototype.drillToByGroup = function(point) {
      var series = this, drillId = false;
      if (point.node.level - series.nodeMap[series.rootNode].level === 1 && !point.node.isLeaf) {
        drillId = point.id;
      }
      return drillId;
    };
    TreemapSeries2.prototype.drillToByLeaf = function(point) {
      var series = this, drillId = false, nodeParent;
      if (point.node.parent !== series.rootNode && point.node.isLeaf) {
        nodeParent = point.node;
        while (!drillId) {
          nodeParent = series.nodeMap[nodeParent.parent];
          if (nodeParent.parent === series.rootNode) {
            drillId = nodeParent.id;
          }
        }
      }
      return drillId;
    };
    TreemapSeries2.prototype.drillToNode = function(id, redraw) {
      error11(32, false, void 0, { "treemap.drillToNode": "use treemap.setRootNode" });
      this.setRootNode(id, redraw);
    };
    TreemapSeries2.prototype.drillUp = function() {
      var series = this, node = series.nodeMap[series.rootNode];
      if (node && isString13(node.parent)) {
        series.setRootNode(node.parent, true, { trigger: "traverseUpButton" });
      }
    };
    TreemapSeries2.prototype.getExtremes = function() {
      var _a15 = Series12.prototype.getExtremes.call(this, this.colorValueData), dataMin = _a15.dataMin, dataMax = _a15.dataMax;
      this.valueMin = dataMin;
      this.valueMax = dataMax;
      return Series12.prototype.getExtremes.call(this);
    };
    TreemapSeries2.prototype.getListOfParents = function(data, existingIds) {
      var arr = isArray24(data) ? data : [], ids = isArray24(existingIds) ? existingIds : [], listOfParents = arr.reduce(function(prev, curr, i) {
        var parent = pick94(curr.parent, "");
        if (typeof prev[parent] === "undefined") {
          prev[parent] = [];
        }
        prev[parent].push(i);
        return prev;
      }, {
        "": []
        // Root of tree
      });
      TreemapUtilities_default.eachObject(listOfParents, function(children, parent, list) {
        if (parent !== "" && ids.indexOf(parent) === -1) {
          children.forEach(function(child) {
            list[""].push(child);
          });
          delete list[parent];
        }
      });
      return listOfParents;
    };
    TreemapSeries2.prototype.getTree = function() {
      var series = this, allIds = this.data.map(function(d) {
        return d.id;
      }), parentList = series.getListOfParents(this.data, allIds);
      series.nodeMap = {};
      return series.buildNode("", -1, 0, parentList);
    };
    TreemapSeries2.prototype.hasData = function() {
      return !!this.processedXData.length;
    };
    TreemapSeries2.prototype.init = function(chart, options) {
      var series = this, setOptionsEvent;
      if (colorMapSeriesMixin3) {
        this.colorAttribs = colorMapSeriesMixin3.colorAttribs;
      }
      setOptionsEvent = addEvent64(series, "setOptions", function(event) {
        var options2 = event.userOptions;
        if (defined53(options2.allowDrillToNode) && !defined53(options2.allowTraversingTree)) {
          options2.allowTraversingTree = options2.allowDrillToNode;
          delete options2.allowDrillToNode;
        }
        if (defined53(options2.drillUpButton) && !defined53(options2.traverseUpButton)) {
          options2.traverseUpButton = options2.drillUpButton;
          delete options2.drillUpButton;
        }
      });
      Series12.prototype.init.call(series, chart, options);
      delete series.opacity;
      series.eventsToUnbind.push(setOptionsEvent);
      if (series.options.allowTraversingTree) {
        series.eventsToUnbind.push(addEvent64(series, "click", series.onClickDrillToNode));
      }
    };
    TreemapSeries2.prototype.onClickDrillToNode = function(event) {
      var series = this, point = event.point, drillId = point && point.drillId;
      if (isString13(drillId)) {
        point.setState("");
        series.setRootNode(drillId, true, { trigger: "click" });
      }
    };
    TreemapSeries2.prototype.pointAttribs = function(point, state) {
      var series = this, mapOptionsToLevel = isObject14(series.mapOptionsToLevel) ? series.mapOptionsToLevel : {}, level = point && mapOptionsToLevel[point.node.level] || {}, options = this.options, attr11, stateOptions = state && options.states[state] || {}, className = point && point.getClassName() || "", opacity;
      attr11 = {
        "stroke": point && point.borderColor || level.borderColor || stateOptions.borderColor || options.borderColor,
        "stroke-width": pick94(point && point.borderWidth, level.borderWidth, stateOptions.borderWidth, options.borderWidth),
        "dashstyle": point && point.borderDashStyle || level.borderDashStyle || stateOptions.borderDashStyle || options.borderDashStyle,
        "fill": point && point.color || this.color
      };
      if (className.indexOf("highcharts-above-level") !== -1) {
        attr11.fill = "none";
        attr11["stroke-width"] = 0;
      } else if (className.indexOf("highcharts-internal-node-interactive") !== -1) {
        opacity = pick94(stateOptions.opacity, options.opacity);
        attr11.fill = color16(attr11.fill).setOpacity(opacity).get();
        attr11.cursor = "pointer";
      } else if (className.indexOf("highcharts-internal-node") !== -1) {
        attr11.fill = "none";
      } else if (state) {
        attr11.fill = color16(attr11.fill).brighten(stateOptions.brightness).get();
      }
      return attr11;
    };
    TreemapSeries2.prototype.renderTraverseUpButton = function(rootId) {
      var series = this, nodeMap = series.nodeMap, node = nodeMap[rootId], name = node.name, buttonOptions = series.options.traverseUpButton, backText = pick94(buttonOptions.text, name, " Back"), attr11, states;
      if (rootId === "" || series.is("sunburst") && series.tree.children.length === 1 && rootId === series.tree.children[0].id) {
        if (series.drillUpButton) {
          series.drillUpButton = series.drillUpButton.destroy();
        }
      } else if (!this.drillUpButton) {
        attr11 = buttonOptions.theme;
        states = attr11 && attr11.states;
        this.drillUpButton = this.chart.renderer.button(backText, 0, 0, function() {
          series.drillUp();
        }, attr11, states && states.hover, states && states.select).addClass("highcharts-drillup-button").attr({
          align: buttonOptions.position.align,
          zIndex: 7
        }).add().align(buttonOptions.position, false, buttonOptions.relativeTo || "plotBox");
      } else {
        this.drillUpButton.placed = false;
        this.drillUpButton.attr({
          text: backText
        }).align();
      }
    };
    TreemapSeries2.prototype.setColorRecursive = function(node, parentColor, colorIndex, index, siblings) {
      var series = this, chart = series && series.chart, colors = chart && chart.options && chart.options.colors, colorInfo, point;
      if (node) {
        colorInfo = getColor3(node, {
          colors,
          index,
          mapOptionsToLevel: series.mapOptionsToLevel,
          parentColor,
          parentColorIndex: colorIndex,
          series,
          siblings
        });
        point = series.points[node.i];
        if (point) {
          point.color = colorInfo.color;
          point.colorIndex = colorInfo.colorIndex;
        }
        (node.children || []).forEach(function(child, i) {
          series.setColorRecursive(child, colorInfo.color, colorInfo.colorIndex, i, node.children.length);
        });
      }
    };
    TreemapSeries2.prototype.setPointValues = function() {
      var series = this;
      var points = series.points, xAxis = series.xAxis, yAxis = series.yAxis;
      var styledMode = series.chart.styledMode;
      var getCrispCorrection = function(point) {
        return styledMode ? 0 : (series.pointAttribs(point)["stroke-width"] || 0) % 2 / 2;
      };
      points.forEach(function(point) {
        var _a15 = point.node, values = _a15.pointValues, visible = _a15.visible;
        if (values && visible) {
          var height = values.height, width = values.width, x = values.x, y = values.y;
          var crispCorr = getCrispCorrection(point);
          var x1 = Math.round(xAxis.toPixels(x, true)) - crispCorr;
          var x2 = Math.round(xAxis.toPixels(x + width, true)) - crispCorr;
          var y1 = Math.round(yAxis.toPixels(y, true)) - crispCorr;
          var y2 = Math.round(yAxis.toPixels(y + height, true)) - crispCorr;
          var shapeArgs = {
            x: Math.min(x1, x2),
            y: Math.min(y1, y2),
            width: Math.abs(x2 - x1),
            height: Math.abs(y2 - y1)
          };
          point.plotX = shapeArgs.x + shapeArgs.width / 2;
          point.plotY = shapeArgs.y + shapeArgs.height / 2;
          point.shapeArgs = shapeArgs;
        } else {
          delete point.plotX;
          delete point.plotY;
        }
      });
    };
    TreemapSeries2.prototype.setRootNode = function(id, redraw, eventArguments) {
      var series = this, eventArgs = extend85({
        newRootId: id,
        previousRootId: series.rootNode,
        redraw: pick94(redraw, true),
        series
      }, eventArguments);
      var defaultFn = function(args) {
        var series2 = args.series;
        series2.idPreviousRoot = args.previousRootId;
        series2.rootNode = args.newRootId;
        series2.isDirty = true;
        if (args.redraw) {
          series2.chart.redraw();
        }
      };
      fireEvent38(series, "setRootNode", eventArgs, defaultFn);
    };
    TreemapSeries2.prototype.setState = function(state) {
      this.options.inactiveOtherPoints = true;
      Series12.prototype.setState.call(this, state, false);
      this.options.inactiveOtherPoints = false;
    };
    TreemapSeries2.prototype.setTreeValues = function(tree) {
      var series = this, options = series.options, idRoot = series.rootNode, mapIdToNode = series.nodeMap, nodeRoot = mapIdToNode[idRoot], levelIsConstant = TreemapUtilities_default.isBoolean(options.levelIsConstant) ? options.levelIsConstant : true, childrenTotal = 0, children = [], val, point = series.points[tree.i];
      tree.children.forEach(function(child) {
        child = series.setTreeValues(child);
        children.push(child);
        if (!child.ignore) {
          childrenTotal += child.val;
        }
      });
      stableSort7(children, function(a, b) {
        return (a.sortIndex || 0) - (b.sortIndex || 0);
      });
      val = pick94(point && point.options.value, childrenTotal);
      if (point) {
        point.value = val;
      }
      extend85(tree, {
        children,
        childrenTotal,
        // Ignore this node if point is not visible
        ignore: !(pick94(point && point.visible, true) && val > 0),
        isLeaf: tree.visible && !childrenTotal,
        levelDynamic: tree.level - (levelIsConstant ? 0 : nodeRoot.level),
        name: pick94(point && point.name, ""),
        sortIndex: pick94(point && point.sortIndex, -val),
        val
      });
      return tree;
    };
    TreemapSeries2.prototype.sliceAndDice = function(parent, children) {
      return this.algorithmFill(true, parent, children);
    };
    TreemapSeries2.prototype.squarified = function(parent, children) {
      return this.algorithmLowAspectRatio(true, parent, children);
    };
    TreemapSeries2.prototype.strip = function(parent, children) {
      return this.algorithmLowAspectRatio(false, parent, children);
    };
    TreemapSeries2.prototype.stripes = function(parent, children) {
      return this.algorithmFill(false, parent, children);
    };
    TreemapSeries2.prototype.translate = function() {
      var series = this, options = series.options, rootId = updateRootId2(series), rootNode, pointValues, seriesArea, tree, val;
      Series12.prototype.translate.call(series);
      tree = series.tree = series.getTree();
      rootNode = series.nodeMap[rootId];
      if (rootId !== "" && (!rootNode || !rootNode.children.length)) {
        series.setRootNode("", false);
        rootId = series.rootNode;
        rootNode = series.nodeMap[rootId];
      }
      series.renderTraverseUpButton(rootId);
      series.mapOptionsToLevel = getLevelOptions3({
        from: rootNode.level + 1,
        levels: options.levels,
        to: tree.height,
        defaults: {
          levelIsConstant: series.options.levelIsConstant,
          colorByPoint: options.colorByPoint
        }
      });
      TreemapUtilities_default.recursive(series.nodeMap[series.rootNode], function(node) {
        var next = false, p = node.parent;
        node.visible = true;
        if (p || p === "") {
          next = series.nodeMap[p];
        }
        return next;
      });
      TreemapUtilities_default.recursive(series.nodeMap[series.rootNode].children, function(children) {
        var next = false;
        children.forEach(function(child) {
          child.visible = true;
          if (child.children.length) {
            next = (next || []).concat(child.children);
          }
        });
        return next;
      });
      series.setTreeValues(tree);
      series.axisRatio = series.xAxis.len / series.yAxis.len;
      series.nodeMap[""].pointValues = pointValues = {
        x: 0,
        y: 0,
        width: TreemapUtilities_default.AXIS_MAX,
        height: TreemapUtilities_default.AXIS_MAX
      };
      series.nodeMap[""].values = seriesArea = merge84(pointValues, {
        width: pointValues.width * series.axisRatio,
        direction: options.layoutStartingDirection === "vertical" ? 0 : 1,
        val: tree.val
      });
      series.calculateChildrenAreas(tree, seriesArea);
      if (!series.colorAxis && !options.colorByPoint) {
        series.setColorRecursive(series.tree);
      }
      if (options.allowTraversingTree) {
        val = rootNode.pointValues;
        series.xAxis.setExtremes(val.x, val.x + val.width, false);
        series.yAxis.setExtremes(val.y, val.y + val.height, false);
        series.xAxis.setScale();
        series.yAxis.setScale();
      }
      series.setPointValues();
    };
    TreemapSeries2.defaultOptions = merge84(ScatterSeries5.defaultOptions, {
      /**
       * When enabled the user can click on a point which is a parent and
       * zoom in on its children. Deprecated and replaced by
       * [allowTraversingTree](#plotOptions.treemap.allowTraversingTree).
       *
       * @sample {highcharts} highcharts/plotoptions/treemap-allowdrilltonode/
       *         Enabled
       *
       * @deprecated
       * @type      {boolean}
       * @default   false
       * @since     4.1.0
       * @product   highcharts
       * @apioption plotOptions.treemap.allowDrillToNode
       */
      /**
       * When enabled the user can click on a point which is a parent and
       * zoom in on its children.
       *
       * @sample {highcharts} highcharts/plotoptions/treemap-allowtraversingtree/
       *         Enabled
       *
       * @since     7.0.3
       * @product   highcharts
       */
      allowTraversingTree: false,
      animationLimit: 250,
      /**
       * The border radius for each treemap item.
       */
      borderRadius: 0,
      /**
       * When the series contains less points than the crop threshold, all
       * points are drawn, event if the points fall outside the visible plot
       * area at the current zoom. The advantage of drawing all points
       * (including markers and columns), is that animation is performed on
       * updates. On the other hand, when the series contains more points than
       * the crop threshold, the series data is cropped to only contain points
       * that fall within the plot area. The advantage of cropping away
       * invisible points is to increase performance on large series.
       *
       * @type      {number}
       * @default   300
       * @since     4.1.0
       * @product   highcharts
       * @apioption plotOptions.treemap.cropThreshold
       */
      /**
       * Fires on a request for change of root node for the tree, before the
       * update is made. An event object is passed to the function, containing
       * additional properties `newRootId`, `previousRootId`, `redraw` and
       * `trigger`.
       *
       * @type {function}
       * @default undefined
       * @sample {highcharts} highcharts/plotoptions/treemap-events-setrootnode/
       *         Alert update information on setRootNode event.
       * @since 7.0.3
       * @product highcharts
       * @apioption plotOptions.treemap.events.setRootNode
       */
      /**
       * This option decides if the user can interact with the parent nodes
       * or just the leaf nodes. When this option is undefined, it will be
       * true by default. However when allowTraversingTree is true, then it
       * will be false by default.
       *
       * @sample {highcharts} highcharts/plotoptions/treemap-interactbyleaf-false/
       *         False
       * @sample {highcharts} highcharts/plotoptions/treemap-interactbyleaf-true-and-allowtraversingtree/
       *         InteractByLeaf and allowTraversingTree is true
       *
       * @type      {boolean}
       * @since     4.1.2
       * @product   highcharts
       * @apioption plotOptions.treemap.interactByLeaf
       */
      /**
       * The sort index of the point inside the treemap level.
       *
       * @sample {highcharts} highcharts/plotoptions/treemap-sortindex/
       *         Sort by years
       *
       * @type      {number}
       * @since     4.1.10
       * @product   highcharts
       * @apioption plotOptions.treemap.sortIndex
       */
      /**
       * A series specific or series type specific color set to apply instead
       * of the global [colors](#colors) when
       * [colorByPoint](#plotOptions.treemap.colorByPoint) is true.
       *
       * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
       * @since     3.0
       * @product   highcharts
       * @apioption plotOptions.treemap.colors
       */
      /**
       * Whether to display this series type or specific series item in the
       * legend.
       */
      showInLegend: false,
      /**
       * @ignore-option
       */
      marker: void 0,
      /**
       * When using automatic point colors pulled from the `options.colors`
       * collection, this option determines whether the chart should receive
       * one color per series or one color per point.
       *
       * @see [series colors](#plotOptions.treemap.colors)
       *
       * @since     2.0
       * @product   highcharts
       * @apioption plotOptions.treemap.colorByPoint
       */
      colorByPoint: false,
      /**
       * @since 4.1.0
       */
      dataLabels: {
        defer: false,
        enabled: true,
        formatter: function() {
          var point = this && this.point ? this.point : {}, name = isString13(point.name) ? point.name : "";
          return name;
        },
        inside: true,
        verticalAlign: "middle"
      },
      tooltip: {
        headerFormat: "",
        pointFormat: "<b>{point.name}</b>: {point.value}<br/>"
      },
      /**
       * Whether to ignore hidden points when the layout algorithm runs.
       * If `false`, hidden points will leave open spaces.
       *
       * @since 5.0.8
       */
      ignoreHiddenPoint: true,
      /**
       * This option decides which algorithm is used for setting position
       * and dimensions of the points.
       *
       * @see [How to write your own algorithm](https://www.highcharts.com/docs/chart-and-series-types/treemap)
       *
       * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-sliceanddice/
       *         SliceAndDice by default
       * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-stripes/
       *         Stripes
       * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-squarified/
       *         Squarified
       * @sample {highcharts} highcharts/plotoptions/treemap-layoutalgorithm-strip/
       *         Strip
       *
       * @since      4.1.0
       * @validvalue ["sliceAndDice", "stripes", "squarified", "strip"]
       */
      layoutAlgorithm: "sliceAndDice",
      /**
       * Defines which direction the layout algorithm will start drawing.
       *
       * @since       4.1.0
       * @validvalue ["vertical", "horizontal"]
       */
      layoutStartingDirection: "vertical",
      /**
       * Enabling this option will make the treemap alternate the drawing
       * direction between vertical and horizontal. The next levels starting
       * direction will always be the opposite of the previous.
       *
       * @sample {highcharts} highcharts/plotoptions/treemap-alternatestartingdirection-true/
       *         Enabled
       *
       * @since 4.1.0
       */
      alternateStartingDirection: false,
      /**
       * Used together with the levels and allowTraversingTree options. When
       * set to false the first level visible to be level one, which is
       * dynamic when traversing the tree. Otherwise the level will be the
       * same as the tree structure.
       *
       * @since 4.1.0
       */
      levelIsConstant: true,
      /**
       * Options for the button appearing when drilling down in a treemap.
       * Deprecated and replaced by
       * [traverseUpButton](#plotOptions.treemap.traverseUpButton).
       *
       * @deprecated
       */
      drillUpButton: {
        /**
         * The position of the button.
         *
         * @deprecated
         */
        position: {
          /**
           * Vertical alignment of the button.
           *
           * @deprecated
           * @type      {Highcharts.VerticalAlignValue}
           * @default   top
           * @product   highcharts
           * @apioption plotOptions.treemap.drillUpButton.position.verticalAlign
           */
          /**
           * Horizontal alignment of the button.
           *
           * @deprecated
           * @type {Highcharts.AlignValue}
           */
          align: "right",
          /**
           * Horizontal offset of the button.
           *
           * @deprecated
           */
          x: -10,
          /**
           * Vertical offset of the button.
           *
           * @deprecated
           */
          y: 10
        }
      },
      /**
       * Options for the button appearing when traversing down in a treemap.
       */
      traverseUpButton: {
        /**
         * The position of the button.
         */
        position: {
          /**
           * Vertical alignment of the button.
           *
           * @type      {Highcharts.VerticalAlignValue}
           * @default   top
           * @product   highcharts
           * @apioption plotOptions.treemap.traverseUpButton.position.verticalAlign
           */
          /**
           * Horizontal alignment of the button.
           *
           * @type {Highcharts.AlignValue}
           */
          align: "right",
          /**
           * Horizontal offset of the button.
           */
          x: -10,
          /**
           * Vertical offset of the button.
           */
          y: 10
        }
      },
      /**
       * Set options on specific levels. Takes precedence over series options,
       * but not point options.
       *
       * @sample {highcharts} highcharts/plotoptions/treemap-levels/
       *         Styling dataLabels and borders
       * @sample {highcharts} highcharts/demo/treemap-with-levels/
       *         Different layoutAlgorithm
       *
       * @type      {Array<*>}
       * @since     4.1.0
       * @product   highcharts
       * @apioption plotOptions.treemap.levels
       */
      /**
       * Can set a `borderColor` on all points which lies on the same level.
       *
       * @type      {Highcharts.ColorString}
       * @since     4.1.0
       * @product   highcharts
       * @apioption plotOptions.treemap.levels.borderColor
       */
      /**
       * Set the dash style of the border of all the point which lies on the
       * level. See
       * [plotOptions.scatter.dashStyle](#plotoptions.scatter.dashstyle)
       * for possible options.
       *
       * @type      {Highcharts.DashStyleValue}
       * @since     4.1.0
       * @product   highcharts
       * @apioption plotOptions.treemap.levels.borderDashStyle
       */
      /**
       * Can set the borderWidth on all points which lies on the same level.
       *
       * @type      {number}
       * @since     4.1.0
       * @product   highcharts
       * @apioption plotOptions.treemap.levels.borderWidth
       */
      /**
       * Can set a color on all points which lies on the same level.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @since     4.1.0
       * @product   highcharts
       * @apioption plotOptions.treemap.levels.color
       */
      /**
       * A configuration object to define how the color of a child varies from
       * the parent's color. The variation is distributed among the children
       * of node. For example when setting brightness, the brightness change
       * will range from the parent's original brightness on the first child,
       * to the amount set in the `to` setting on the last node. This allows a
       * gradient-like color scheme that sets children out from each other
       * while highlighting the grouping on treemaps and sectors on sunburst
       * charts.
       *
       * @sample highcharts/demo/sunburst/
       *         Sunburst with color variation
       *
       * @since     6.0.0
       * @product   highcharts
       * @apioption plotOptions.treemap.levels.colorVariation
       */
      /**
       * The key of a color variation. Currently supports `brightness` only.
       *
       * @type       {string}
       * @since      6.0.0
       * @product    highcharts
       * @validvalue ["brightness"]
       * @apioption  plotOptions.treemap.levels.colorVariation.key
       */
      /**
       * The ending value of a color variation. The last sibling will receive
       * this value.
       *
       * @type      {number}
       * @since     6.0.0
       * @product   highcharts
       * @apioption plotOptions.treemap.levels.colorVariation.to
       */
      /**
       * Can set the options of dataLabels on each point which lies on the
       * level.
       * [plotOptions.treemap.dataLabels](#plotOptions.treemap.dataLabels) for
       * possible values.
       *
       * @extends   plotOptions.treemap.dataLabels
       * @since     4.1.0
       * @product   highcharts
       * @apioption plotOptions.treemap.levels.dataLabels
       */
      /**
       * Can set the layoutAlgorithm option on a specific level.
       *
       * @type       {string}
       * @since      4.1.0
       * @product    highcharts
       * @validvalue ["sliceAndDice", "stripes", "squarified", "strip"]
       * @apioption  plotOptions.treemap.levels.layoutAlgorithm
       */
      /**
       * Can set the layoutStartingDirection option on a specific level.
       *
       * @type       {string}
       * @since      4.1.0
       * @product    highcharts
       * @validvalue ["vertical", "horizontal"]
       * @apioption  plotOptions.treemap.levels.layoutStartingDirection
       */
      /**
       * Decides which level takes effect from the options set in the levels
       * object.
       *
       * @sample {highcharts} highcharts/plotoptions/treemap-levels/
       *         Styling of both levels
       *
       * @type      {number}
       * @since     4.1.0
       * @product   highcharts
       * @apioption plotOptions.treemap.levels.level
       */
      // Presentational options
      /**
       * The color of the border surrounding each tree map item.
       *
       * @type {Highcharts.ColorString}
       */
      borderColor: Palette_default.neutralColor10,
      /**
       * The width of the border surrounding each tree map item.
       */
      borderWidth: 1,
      colorKey: "colorValue",
      /**
       * The opacity of a point in treemap. When a point has children, the
       * visibility of the children is determined by the opacity.
       *
       * @since 4.2.4
       */
      opacity: 0.15,
      /**
       * A wrapper object for all the series options in specific states.
       *
       * @extends plotOptions.heatmap.states
       */
      states: {
        /**
         * Options for the hovered series
         *
         * @extends   plotOptions.heatmap.states.hover
         * @excluding halo
         */
        hover: {
          /**
           * The border color for the hovered state.
           */
          borderColor: Palette_default.neutralColor40,
          /**
           * Brightness for the hovered point. Defaults to 0 if the
           * heatmap series is loaded first, otherwise 0.1.
           *
           * @type    {number}
           * @default undefined
           */
          brightness: HeatmapSeries2 ? 0 : 0.1,
          /**
           * @extends plotOptions.heatmap.states.hover.halo
           */
          halo: false,
          /**
           * The opacity of a point in treemap. When a point has children,
           * the visibility of the children is determined by the opacity.
           *
           * @since 4.2.4
           */
          opacity: 0.75,
          /**
           * The shadow option for hovered state.
           */
          shadow: false
        }
      }
    });
    return TreemapSeries2;
  }(ScatterSeries5)
);
extend85(TreemapSeries.prototype, {
  buildKDTree: noop22,
  colorKey: "colorValue",
  directTouch: true,
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  getExtremesFromAll: true,
  getSymbol: noop22,
  optionalAxis: "colorAxis",
  parallelArrays: ["x", "y", "value", "colorValue"],
  pointArrayMap: ["value"],
  pointClass: TreemapPoint_default,
  trackerGroups: ["group", "dataLabelsGroup"],
  utils: {
    recursive: TreemapUtilities_default.recursive
  }
});
SeriesRegistry_default.registerSeriesType("treemap", TreemapSeries);

// node_modules/highcharts/es-modules/Extensions/NoDataToDisplay.js
var getOptions4 = DefaultOptions_default.getOptions;
var addEvent65 = Utilities_default.addEvent;
var extend86 = Utilities_default.extend;
var chartPrototype = Chart_default.prototype;
var defaultOptions16 = getOptions4();
extend86(
  defaultOptions16.lang,
  /**
   * @optionparent lang
   */
  {
    /**
     * The text to display when the chart contains no data.
     *
     * @see [noData](#noData)
     *
     * @sample highcharts/no-data-to-display/no-data-line
     *         No-data text
     *
     * @since    3.0.8
     * @product  highcharts highstock
     * @requires modules/no-data-to-display
     */
    noData: "No data to display"
  }
);
defaultOptions16.noData = {
  /**
   * An object of additional SVG attributes for the no-data label.
   *
   * @type      {Highcharts.SVGAttributes}
   * @since     3.0.8
   * @product   highcharts highstock gantt
   * @apioption noData.attr
   */
  attr: {
    zIndex: 1
  },
  /**
   * Whether to insert the label as HTML, or as pseudo-HTML rendered with
   * SVG.
   *
   * @type      {boolean}
   * @default   false
   * @since     4.1.10
   * @product   highcharts highstock gantt
   * @apioption noData.useHTML
   */
  /**
   * The position of the no-data label, relative to the plot area.
   *
   * @type  {Highcharts.AlignObject}
   * @since 3.0.8
   */
  position: {
    /**
     * Horizontal offset of the label, in pixels.
     */
    x: 0,
    /**
     * Vertical offset of the label, in pixels.
     */
    y: 0,
    /**
     * Horizontal alignment of the label.
     *
     * @type {Highcharts.AlignValue}
     */
    align: "center",
    /**
     * Vertical alignment of the label.
     *
     * @type {Highcharts.VerticalAlignValue}
     */
    verticalAlign: "middle"
  },
  /**
   * CSS styles for the no-data label.
   *
   * @sample highcharts/no-data-to-display/no-data-line
   *         Styled no-data text
   *
   * @type {Highcharts.CSSObject}
   */
  style: {
    /** @ignore */
    fontWeight: "bold",
    /** @ignore */
    fontSize: "12px",
    /** @ignore */
    color: Palette_default.neutralColor60
  }
};
chartPrototype.showNoData = function(str) {
  var chart = this, options = chart.options, text = str || options && options.lang.noData || "", noDataOptions = options && (options.noData || {});
  if (chart.renderer) {
    if (!chart.noDataLabel) {
      chart.noDataLabel = chart.renderer.label(text, 0, 0, void 0, void 0, void 0, noDataOptions.useHTML, void 0, "no-data").add();
    }
    if (!chart.styledMode) {
      chart.noDataLabel.attr(AST_default.filterUserAttributes(noDataOptions.attr || {})).css(noDataOptions.style || {});
    }
    chart.noDataLabel.align(extend86(chart.noDataLabel.getBBox(), noDataOptions.position || {}), false, "plotBox");
  }
};
chartPrototype.hideNoData = function() {
  var chart = this;
  if (chart.noDataLabel) {
    chart.noDataLabel = chart.noDataLabel.destroy();
  }
};
chartPrototype.hasData = function() {
  var chart = this, series = chart.series || [], i = series.length;
  while (i--) {
    if (series[i].hasData() && !series[i].options.isInternal) {
      return true;
    }
  }
  return chart.loadingShown;
};
addEvent65(Chart_default, "render", function handleNoData() {
  if (this.hasData()) {
    this.hideNoData();
  } else {
    this.showNoData();
  }
});

// node_modules/highcharts/es-modules/Mixins/Nodes.js
var defined54 = Utilities_default.defined;
var extend87 = Utilities_default.extend;
var find18 = Utilities_default.find;
var pick95 = Utilities_default.pick;
var NodesMixin = Globals_default.NodesMixin = {
  /* eslint-disable valid-jsdoc */
  /**
   * Create a single node that holds information on incoming and outgoing
   * links.
   * @private
   */
  createNode: function(id) {
    function findById(nodes, id2) {
      return find18(nodes, function(node2) {
        return node2.id === id2;
      });
    }
    var node = findById(this.nodes, id), PointClass = this.pointClass, options;
    if (!node) {
      options = this.options.nodes && findById(this.options.nodes, id);
      node = new PointClass().init(this, extend87({
        className: "highcharts-node",
        isNode: true,
        id,
        y: 1
        // Pass isNull test
      }, options));
      node.linksTo = [];
      node.linksFrom = [];
      node.formatPrefix = "node";
      node.name = node.name || node.options.id || "";
      node.mass = pick95(
        // Node:
        node.options.mass,
        node.options.marker && node.options.marker.radius,
        // Series:
        this.options.marker && this.options.marker.radius,
        // Default:
        4
      );
      node.getSum = function() {
        var sumTo = 0, sumFrom = 0;
        node.linksTo.forEach(function(link) {
          sumTo += link.weight;
        });
        node.linksFrom.forEach(function(link) {
          sumFrom += link.weight;
        });
        return Math.max(sumTo, sumFrom);
      };
      node.offset = function(point, coll) {
        var offset3 = 0;
        for (var i = 0; i < node[coll].length; i++) {
          if (node[coll][i] === point) {
            return offset3;
          }
          offset3 += node[coll][i].weight;
        }
      };
      node.hasShape = function() {
        var outgoing = 0;
        node.linksTo.forEach(function(link) {
          if (link.outgoing) {
            outgoing++;
          }
        });
        return !node.linksTo.length || outgoing !== node.linksTo.length;
      };
      this.nodes.push(node);
    }
    return node;
  },
  /**
   * Extend generatePoints by adding the nodes, which are Point objects
   * but pushed to the this.nodes array.
   */
  generatePoints: function() {
    var chart = this.chart, nodeLookup = {};
    Series_default.prototype.generatePoints.call(this);
    if (!this.nodes) {
      this.nodes = [];
    }
    this.colorCounter = 0;
    this.nodes.forEach(function(node) {
      node.linksFrom.length = 0;
      node.linksTo.length = 0;
      node.level = node.options.level;
    });
    this.points.forEach(function(point) {
      if (defined54(point.from)) {
        if (!nodeLookup[point.from]) {
          nodeLookup[point.from] = this.createNode(point.from);
        }
        nodeLookup[point.from].linksFrom.push(point);
        point.fromNode = nodeLookup[point.from];
        if (chart.styledMode) {
          point.colorIndex = pick95(point.options.colorIndex, nodeLookup[point.from].colorIndex);
        } else {
          point.color = point.options.color || nodeLookup[point.from].color;
        }
      }
      if (defined54(point.to)) {
        if (!nodeLookup[point.to]) {
          nodeLookup[point.to] = this.createNode(point.to);
        }
        nodeLookup[point.to].linksTo.push(point);
        point.toNode = nodeLookup[point.to];
      }
      point.name = point.name || point.id;
    }, this);
    this.nodeLookup = nodeLookup;
  },
  // Destroy all nodes on setting new data
  setData: function() {
    if (this.nodes) {
      this.nodes.forEach(function(node) {
        node.destroy();
      });
      this.nodes.length = 0;
    }
    Series_default.prototype.setData.apply(this, arguments);
  },
  // Destroy alll nodes and links
  destroy: function() {
    this.data = [].concat(this.points || [], this.nodes);
    return Series_default.prototype.destroy.apply(this, arguments);
  },
  /**
   * When hovering node, highlight all connected links. When hovering a link,
   * highlight all connected nodes.
   */
  setNodeState: function(state) {
    var args = arguments, others = this.isNode ? this.linksTo.concat(this.linksFrom) : [this.fromNode, this.toNode];
    if (state !== "select") {
      others.forEach(function(linkOrNode) {
        if (linkOrNode && linkOrNode.series) {
          Point_default.prototype.setState.apply(linkOrNode, args);
          if (!linkOrNode.isNode) {
            if (linkOrNode.fromNode.graphic) {
              Point_default.prototype.setState.apply(linkOrNode.fromNode, args);
            }
            if (linkOrNode.toNode && linkOrNode.toNode.graphic) {
              Point_default.prototype.setState.apply(linkOrNode.toNode, args);
            }
          }
        }
      });
    }
    Point_default.prototype.setState.apply(this, args);
  }
  /* eslint-enable valid-jsdoc */
};
var Nodes_default = NodesMixin;

// node_modules/highcharts/es-modules/Series/Sankey/SankeyPoint.js
var __extends52 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries13 = SeriesRegistry_default.seriesTypes.column;
var defined55 = Utilities_default.defined;
var extend88 = Utilities_default.extend;
var SankeyPoint = (
  /** @class */
  function(_super) {
    __extends52(SankeyPoint3, _super);
    function SankeyPoint3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.className = void 0;
      _this.fromNode = void 0;
      _this.level = void 0;
      _this.linkBase = void 0;
      _this.linksFrom = void 0;
      _this.linksTo = void 0;
      _this.mass = void 0;
      _this.nodeX = void 0;
      _this.nodeY = void 0;
      _this.options = void 0;
      _this.series = void 0;
      _this.toNode = void 0;
      return _this;
    }
    SankeyPoint3.prototype.applyOptions = function(options, x) {
      Point_default.prototype.applyOptions.call(this, options, x);
      if (defined55(this.options.level)) {
        this.options.column = this.column = this.options.level;
      }
      return this;
    };
    SankeyPoint3.prototype.getClassName = function() {
      return (this.isNode ? "highcharts-node " : "highcharts-link ") + Point_default.prototype.getClassName.call(this);
    };
    SankeyPoint3.prototype.isValid = function() {
      return this.isNode || typeof this.weight === "number";
    };
    return SankeyPoint3;
  }(ColumnSeries13.prototype.pointClass)
);
extend88(SankeyPoint.prototype, {
  setState: Nodes_default.setNodeState
});
var SankeyPoint_default = SankeyPoint;

// node_modules/highcharts/es-modules/Series/Sankey/SankeySeries.js
var __extends53 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Series13 = SeriesRegistry_default.series;
var ColumnSeries14 = SeriesRegistry_default.seriesTypes.column;
var getLevelOptions4 = TreeSeries_default.getLevelOptions;
var defined56 = Utilities_default.defined;
var extend89 = Utilities_default.extend;
var find19 = Utilities_default.find;
var isObject15 = Utilities_default.isObject;
var merge85 = Utilities_default.merge;
var pick96 = Utilities_default.pick;
var relativeLength10 = Utilities_default.relativeLength;
var stableSort8 = Utilities_default.stableSort;
var SankeySeries = (
  /** @class */
  function(_super) {
    __extends53(SankeySeries3, _super);
    function SankeySeries3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.colDistance = void 0;
      _this.data = void 0;
      _this.group = void 0;
      _this.nodeLookup = void 0;
      _this.nodePadding = void 0;
      _this.nodes = void 0;
      _this.nodeWidth = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.translationFactor = void 0;
      return _this;
    }
    SankeySeries3.getDLOptions = function(params) {
      var optionsPoint = isObject15(params.optionsPoint) ? params.optionsPoint.dataLabels : {}, optionsLevel = isObject15(params.level) ? params.level.dataLabels : {}, options = merge85({
        style: {}
      }, optionsLevel, optionsPoint);
      return options;
    };
    SankeySeries3.prototype.createNodeColumn = function() {
      var series = this, chart = this.chart, column = [];
      column.sum = function() {
        return this.reduce(function(sum, node) {
          return sum + node.getSum();
        }, 0);
      };
      column.offset = function(node, factor) {
        var offset3 = 0, totalNodeOffset, nodePadding = series.nodePadding;
        for (var i = 0; i < column.length; i++) {
          var sum = column[i].getSum();
          var height = Math.max(sum * factor, series.options.minLinkWidth);
          if (sum) {
            totalNodeOffset = height + nodePadding;
          } else {
            totalNodeOffset = 0;
          }
          if (column[i] === node) {
            return {
              relativeTop: offset3 + relativeLength10(node.options.offset || 0, totalNodeOffset)
            };
          }
          offset3 += totalNodeOffset;
        }
      };
      column.top = function(factor) {
        var nodePadding = series.nodePadding;
        var height = this.reduce(function(height2, node) {
          if (height2 > 0) {
            height2 += nodePadding;
          }
          var nodeHeight = Math.max(node.getSum() * factor, series.options.minLinkWidth);
          height2 += nodeHeight;
          return height2;
        }, 0);
        return (chart.plotSizeY - height) / 2;
      };
      return column;
    };
    SankeySeries3.prototype.createNodeColumns = function() {
      var columns = [];
      this.nodes.forEach(function(node) {
        var fromColumn = -1, fromNode;
        if (!defined56(node.options.column)) {
          if (node.linksTo.length === 0) {
            node.column = 0;
          } else {
            for (var i2 = 0; i2 < node.linksTo.length; i2++) {
              var point = node.linksTo[i2];
              if (point.fromNode.column > fromColumn && point.fromNode !== node) {
                fromNode = point.fromNode;
                fromColumn = fromNode.column;
              }
            }
            node.column = fromColumn + 1;
            if (fromNode && fromNode.options.layout === "hanging") {
              node.hangsFrom = fromNode;
              var i_1 = -1;
              find19(fromNode.linksFrom, function(link, index) {
                var found = link.toNode === node;
                if (found) {
                  i_1 = index;
                }
                return found;
              });
              node.column += i_1;
            }
          }
        }
        if (!columns[node.column]) {
          columns[node.column] = this.createNodeColumn();
        }
        columns[node.column].push(node);
      }, this);
      for (var i = 0; i < columns.length; i++) {
        if (typeof columns[i] === "undefined") {
          columns[i] = this.createNodeColumn();
        }
      }
      return columns;
    };
    SankeySeries3.prototype.generatePoints = function() {
      Nodes_default.generatePoints.apply(this, arguments);
      function order(node, level) {
        if (typeof node.level === "undefined") {
          node.level = level;
          node.linksFrom.forEach(function(link) {
            if (link.toNode) {
              order(link.toNode, level + 1);
            }
          });
        }
      }
      if (this.orderNodes) {
        this.nodes.filter(function(node) {
          return node.linksTo.length === 0;
        }).forEach(function(node) {
          order(node, 0);
        });
        stableSort8(this.nodes, function(a, b) {
          return a.level - b.level;
        });
      }
    };
    SankeySeries3.prototype.getNodePadding = function() {
      var nodePadding = this.options.nodePadding || 0;
      if (this.nodeColumns) {
        var maxLength = this.nodeColumns.reduce(function(acc, col) {
          return Math.max(acc, col.length);
        }, 0);
        if (maxLength * nodePadding > this.chart.plotSizeY) {
          nodePadding = this.chart.plotSizeY / maxLength;
        }
      }
      return nodePadding;
    };
    SankeySeries3.prototype.hasData = function() {
      return !!this.processedXData.length;
    };
    SankeySeries3.prototype.pointAttribs = function(point, state) {
      if (!point) {
        return {};
      }
      var series = this, level = point.isNode ? point.level : point.fromNode.level, levelOptions = series.mapOptionsToLevel[level || 0] || {}, options = point.options, stateOptions = levelOptions.states && levelOptions.states[state || ""] || {}, values = [
        "colorByPoint",
        "borderColor",
        "borderWidth",
        "linkOpacity"
      ].reduce(function(obj, key) {
        obj[key] = pick96(stateOptions[key], options[key], levelOptions[key], series.options[key]);
        return obj;
      }, {}), color18 = pick96(stateOptions.color, options.color, values.colorByPoint ? point.color : levelOptions.color);
      if (point.isNode) {
        return {
          fill: color18,
          stroke: values.borderColor,
          "stroke-width": values.borderWidth
        };
      }
      return {
        fill: Color_default.parse(color18).setOpacity(values.linkOpacity).get()
      };
    };
    SankeySeries3.prototype.render = function() {
      var points = this.points;
      this.points = this.points.concat(this.nodes || []);
      ColumnSeries14.prototype.render.call(this);
      this.points = points;
    };
    SankeySeries3.prototype.translate = function() {
      var _this = this;
      var getColumnTranslationFactor = function(column) {
        var nodes = column.slice();
        var minLinkWidth = _this.options.minLinkWidth || 0;
        var exceedsMinLinkWidth;
        var factor = 0;
        var i;
        var remainingHeight = chart.plotSizeY - options.borderWidth - (column.length - 1) * series.nodePadding;
        while (column.length) {
          factor = remainingHeight / column.sum();
          exceedsMinLinkWidth = false;
          i = column.length;
          while (i--) {
            if (column[i].getSum() * factor < minLinkWidth) {
              column.splice(i, 1);
              remainingHeight -= minLinkWidth;
              exceedsMinLinkWidth = true;
            }
          }
          if (!exceedsMinLinkWidth) {
            break;
          }
        }
        column.length = 0;
        nodes.forEach(function(node) {
          return column.push(node);
        });
        return factor;
      };
      if (!this.processedXData) {
        this.processData();
      }
      this.generatePoints();
      this.nodeColumns = this.createNodeColumns();
      this.nodeWidth = relativeLength10(this.options.nodeWidth, this.chart.plotSizeX);
      var series = this, chart = this.chart, options = this.options, nodeWidth = this.nodeWidth, nodeColumns = this.nodeColumns;
      this.nodePadding = this.getNodePadding();
      this.translationFactor = nodeColumns.reduce(function(translationFactor, column) {
        return Math.min(translationFactor, getColumnTranslationFactor(column));
      }, Infinity);
      this.colDistance = (chart.plotSizeX - nodeWidth - options.borderWidth) / Math.max(1, nodeColumns.length - 1);
      series.mapOptionsToLevel = getLevelOptions4({
        // NOTE: if support for allowTraversingTree is added, then from
        // should be the level of the root node.
        from: 1,
        levels: options.levels,
        to: nodeColumns.length - 1,
        defaults: {
          borderColor: options.borderColor,
          borderRadius: options.borderRadius,
          borderWidth: options.borderWidth,
          color: series.color,
          colorByPoint: options.colorByPoint,
          // NOTE: if support for allowTraversingTree is added, then
          // levelIsConstant should be optional.
          levelIsConstant: true,
          linkColor: options.linkColor,
          linkLineWidth: options.linkLineWidth,
          linkOpacity: options.linkOpacity,
          states: options.states
        }
      });
      nodeColumns.forEach(function(column) {
        column.forEach(function(node) {
          series.translateNode(node, column);
        });
      }, this);
      this.nodes.forEach(function(node) {
        node.linksFrom.forEach(function(linkPoint) {
          if ((linkPoint.weight || linkPoint.isNull) && linkPoint.to) {
            series.translateLink(linkPoint);
            linkPoint.allowShadow = false;
          }
        });
      });
    };
    SankeySeries3.prototype.translateLink = function(point) {
      var getY = function(node, fromOrTo) {
        var linkTop = node.offset(point, fromOrTo) * translationFactor;
        var y = Math.min(
          node.nodeY + linkTop,
          // Prevent links from spilling below the node (#12014)
          node.nodeY + (node.shapeArgs && node.shapeArgs.height || 0) - linkHeight
        );
        return y;
      };
      var fromNode = point.fromNode, toNode = point.toNode, chart = this.chart, translationFactor = this.translationFactor, linkHeight = Math.max(point.weight * translationFactor, this.options.minLinkWidth), options = this.options, curvy = (chart.inverted ? -this.colDistance : this.colDistance) * options.curveFactor, fromY = getY(fromNode, "linksFrom"), toY = getY(toNode, "linksTo"), nodeLeft = fromNode.nodeX, nodeW = this.nodeWidth, right = toNode.column * this.colDistance, outgoing = point.outgoing, straight = right > nodeLeft + nodeW;
      if (chart.inverted) {
        fromY = chart.plotSizeY - fromY;
        toY = (chart.plotSizeY || 0) - toY;
        right = chart.plotSizeX - right;
        nodeW = -nodeW;
        linkHeight = -linkHeight;
        straight = nodeLeft > right;
      }
      point.shapeType = "path";
      point.linkBase = [
        fromY,
        fromY + linkHeight,
        toY,
        toY + linkHeight
      ];
      if (straight && typeof toY === "number") {
        point.shapeArgs = {
          d: [
            ["M", nodeLeft + nodeW, fromY],
            [
              "C",
              nodeLeft + nodeW + curvy,
              fromY,
              right - curvy,
              toY,
              right,
              toY
            ],
            ["L", right + (outgoing ? nodeW : 0), toY + linkHeight / 2],
            ["L", right, toY + linkHeight],
            [
              "C",
              right - curvy,
              toY + linkHeight,
              nodeLeft + nodeW + curvy,
              fromY + linkHeight,
              nodeLeft + nodeW,
              fromY + linkHeight
            ],
            ["Z"]
          ]
        };
      } else if (typeof toY === "number") {
        var bend = 20, vDist = chart.plotHeight - fromY - linkHeight, x1 = right - bend - linkHeight, x2 = right - bend, x3 = right, x4 = nodeLeft + nodeW, x5 = x4 + bend, x6 = x5 + linkHeight, fy1 = fromY, fy2 = fromY + linkHeight, fy3 = fy2 + bend, y4 = fy3 + vDist, y5 = y4 + bend, y6 = y5 + linkHeight, ty1 = toY, ty2 = ty1 + linkHeight, ty3 = ty2 + bend, cfy1 = fy2 - linkHeight * 0.7, cy2 = y5 + linkHeight * 0.7, cty1 = ty2 - linkHeight * 0.7, cx1 = x3 - linkHeight * 0.7, cx2 = x4 + linkHeight * 0.7;
        point.shapeArgs = {
          d: [
            ["M", x4, fy1],
            ["C", cx2, fy1, x6, cfy1, x6, fy3],
            ["L", x6, y4],
            ["C", x6, cy2, cx2, y6, x4, y6],
            ["L", x3, y6],
            ["C", cx1, y6, x1, cy2, x1, y4],
            ["L", x1, ty3],
            ["C", x1, cty1, cx1, ty1, x3, ty1],
            ["L", x3, ty2],
            ["C", x2, ty2, x2, ty2, x2, ty3],
            ["L", x2, y4],
            ["C", x2, y5, x2, y5, x3, y5],
            ["L", x4, y5],
            ["C", x5, y5, x5, y5, x5, y4],
            ["L", x5, fy3],
            ["C", x5, fy2, x5, fy2, x4, fy2],
            ["Z"]
          ]
        };
      }
      point.dlBox = {
        x: nodeLeft + (right - nodeLeft + nodeW) / 2,
        y: fromY + (toY - fromY) / 2,
        height: linkHeight,
        width: 0
      };
      point.tooltipPos = chart.inverted ? [
        chart.plotSizeY - point.dlBox.y - linkHeight / 2,
        chart.plotSizeX - point.dlBox.x
      ] : [
        point.dlBox.x,
        point.dlBox.y + linkHeight / 2
      ];
      point.y = point.plotY = 1;
      if (!point.color) {
        point.color = fromNode.color;
      }
    };
    SankeySeries3.prototype.translateNode = function(node, column) {
      var translationFactor = this.translationFactor, chart = this.chart, options = this.options, sum = node.getSum(), nodeHeight = Math.max(Math.round(sum * translationFactor), this.options.minLinkWidth), crisp = Math.round(options.borderWidth) % 2 / 2, nodeOffset = column.offset(node, translationFactor), fromNodeTop = Math.floor(pick96(nodeOffset.absoluteTop, column.top(translationFactor) + nodeOffset.relativeTop)) + crisp, left = Math.floor(this.colDistance * node.column + options.borderWidth / 2) + crisp, nodeLeft = chart.inverted ? chart.plotSizeX - left : left, nodeWidth = Math.round(this.nodeWidth);
      node.sum = sum;
      if (sum) {
        node.shapeType = "rect";
        node.nodeX = nodeLeft;
        node.nodeY = fromNodeTop;
        var x = nodeLeft, y = fromNodeTop, width = node.options.width || options.width || nodeWidth, height = node.options.height || options.height || nodeHeight;
        if (chart.inverted) {
          x = nodeLeft - nodeWidth;
          y = chart.plotSizeY - fromNodeTop - nodeHeight;
          width = node.options.height || options.height || nodeWidth;
          height = node.options.width || options.width || nodeHeight;
        }
        node.dlOptions = SankeySeries3.getDLOptions({
          level: this.mapOptionsToLevel[node.level],
          optionsPoint: node.options
        });
        node.plotX = 1;
        node.plotY = 1;
        node.tooltipPos = chart.inverted ? [
          chart.plotSizeY - y - height / 2,
          chart.plotSizeX - x - width / 2
        ] : [
          x + width / 2,
          y + height / 2
        ];
        node.shapeArgs = {
          x,
          y,
          width,
          height,
          display: node.hasShape() ? "" : "none"
        };
      } else {
        node.dlOptions = {
          enabled: false
        };
      }
    };
    SankeySeries3.defaultOptions = merge85(ColumnSeries14.defaultOptions, {
      borderWidth: 0,
      colorByPoint: true,
      /**
       * Higher numbers makes the links in a sankey diagram or dependency
       * wheelrender more curved. A `curveFactor` of 0 makes the lines
       * straight.
       *
       * @private
       */
      curveFactor: 0.33,
      /**
       * Options for the data labels appearing on top of the nodes and links.
       * For sankey charts, data labels are visible for the nodes by default,
       * but hidden for links. This is controlled by modifying the
       * `nodeFormat`, and the `format` that applies to links and is an empty
       * string by default.
       *
       * @declare Highcharts.SeriesSankeyDataLabelsOptionsObject
       *
       * @private
       */
      dataLabels: {
        enabled: true,
        backgroundColor: "none",
        crop: false,
        /**
         * The
         * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
         * specifying what to show for _nodes_ in the sankey diagram. By
         * default the `nodeFormatter` returns `{point.name}`.
         *
         * @sample highcharts/plotoptions/sankey-link-datalabels/
         *         Node and link data labels
         *
         * @type {string}
         */
        nodeFormat: void 0,
        // eslint-disable-next-line valid-jsdoc
        /**
         * Callback to format data labels for _nodes_ in the sankey diagram.
         * The `nodeFormat` option takes precedence over the
         * `nodeFormatter`.
         *
         * @type  {Highcharts.SeriesSankeyDataLabelsFormatterCallbackFunction}
         * @since 6.0.2
         */
        nodeFormatter: function() {
          return this.point.name;
        },
        format: void 0,
        // eslint-disable-next-line valid-jsdoc
        /**
         * @type {Highcharts.SeriesSankeyDataLabelsFormatterCallbackFunction}
         */
        formatter: function() {
          return;
        },
        inside: true
      },
      /**
       * @ignore-option
       *
       * @private
       */
      inactiveOtherPoints: true,
      /**
       * Set options on specific levels. Takes precedence over series options,
       * but not node and link options.
       *
       * @sample highcharts/demo/sunburst
       *         Sunburst chart
       *
       * @type      {Array<*>}
       * @since     7.1.0
       * @apioption plotOptions.sankey.levels
       */
      /**
       * Can set `borderColor` on all nodes which lay on the same level.
       *
       * @type      {Highcharts.ColorString}
       * @apioption plotOptions.sankey.levels.borderColor
       */
      /**
       * Can set `borderWidth` on all nodes which lay on the same level.
       *
       * @type      {number}
       * @apioption plotOptions.sankey.levels.borderWidth
       */
      /**
       * Can set `color` on all nodes which lay on the same level.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @apioption plotOptions.sankey.levels.color
       */
      /**
       * Can set `colorByPoint` on all nodes which lay on the same level.
       *
       * @type      {boolean}
       * @default   true
       * @apioption plotOptions.sankey.levels.colorByPoint
       */
      /**
       * Can set `dataLabels` on all points which lay on the same level.
       *
       * @extends   plotOptions.sankey.dataLabels
       * @apioption plotOptions.sankey.levels.dataLabels
       */
      /**
       * Decides which level takes effect from the options set in the levels
       * object.
       *
       * @type      {number}
       * @apioption plotOptions.sankey.levels.level
       */
      /**
       * Can set `linkOpacity` on all points which lay on the same level.
       *
       * @type      {number}
       * @default   0.5
       * @apioption plotOptions.sankey.levels.linkOpacity
       */
      /**
       * Can set `states` on all nodes and points which lay on the same level.
       *
       * @extends   plotOptions.sankey.states
       * @apioption plotOptions.sankey.levels.states
       */
      /**
       * Opacity for the links between nodes in the sankey diagram.
       *
       * @private
       */
      linkOpacity: 0.5,
      /**
       * The minimal width for a line of a sankey. By default,
       * 0 values are not shown.
       *
       * @sample highcharts/plotoptions/sankey-minlinkwidth
       *         Sankey diagram with minimal link height
       *
       * @type      {number}
       * @since     7.1.3
       * @default   0
       * @apioption plotOptions.sankey.minLinkWidth
       *
       * @private
       */
      minLinkWidth: 0,
      /**
       * The pixel width of each node in a sankey diagram or dependency wheel,
       * or the height in case the chart is inverted.
       *
       * @private
       */
      nodeWidth: 20,
      /**
       * The padding between nodes in a sankey diagram or dependency wheel, in
       * pixels.
       *
       * If the number of nodes is so great that it is possible to lay them
       * out within the plot area with the given `nodePadding`, they will be
       * rendered with a smaller padding as a strategy to avoid overflow.
       *
       * @private
       */
      nodePadding: 10,
      showInLegend: false,
      states: {
        hover: {
          /**
           * Opacity for the links between nodes in the sankey diagram in
           * hover mode.
           */
          linkOpacity: 1
        },
        /**
         * The opposite state of a hover for a single point node/link.
         *
         * @declare Highcharts.SeriesStatesInactiveOptionsObject
         */
        inactive: {
          /**
           * Opacity for the links between nodes in the sankey diagram in
           * inactive mode.
           */
          linkOpacity: 0.1,
          /**
           * Opacity of inactive markers.
           *
           * @type      {number}
           * @apioption plotOptions.series.states.inactive.opacity
           */
          opacity: 0.1,
          /**
           * Animation when not hovering over the marker.
           *
           * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
           * @apioption plotOptions.series.states.inactive.animation
           */
          animation: {
            /** @internal */
            duration: 50
          }
        }
      },
      tooltip: {
        /**
         * A callback for defining the format for _nodes_ in the chart's
         * tooltip, as opposed to links.
         *
         * @type      {Highcharts.FormatterCallbackFunction<Highcharts.SankeyNodeObject>}
         * @since     6.0.2
         * @apioption plotOptions.sankey.tooltip.nodeFormatter
         */
        /**
         * Whether the tooltip should follow the pointer or stay fixed on
         * the item.
         */
        followPointer: true,
        headerFormat: '<span style="font-size: 10px">{series.name}</span><br/>',
        pointFormat: "{point.fromNode.name}  {point.toNode.name}: <b>{point.weight}</b><br/>",
        /**
         * The
         * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
         * specifying what to show for _nodes_ in tooltip of a diagram
         * series, as opposed to links.
         */
        nodeFormat: "{point.name}: <b>{point.sum}</b><br/>"
      }
    });
    return SankeySeries3;
  }(ColumnSeries14)
);
extend89(SankeySeries.prototype, {
  animate: Series13.prototype.animate,
  // Create a single node that holds information on incoming and outgoing
  // links.
  createNode: Nodes_default.createNode,
  destroy: Nodes_default.destroy,
  forceDL: true,
  invertible: true,
  isCartesian: false,
  orderNodes: true,
  pointArrayMap: ["from", "to"],
  pointClass: SankeyPoint_default,
  searchPoint: Globals_default.noop,
  setData: Nodes_default.setData
});
SeriesRegistry_default.registerSeriesType("sankey", SankeySeries);

// node_modules/highcharts/es-modules/Series/Timeline/TimelinePoint.js
var __extends54 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Series14 = SeriesRegistry_default.series;
var PiePoint4 = SeriesRegistry_default.seriesTypes.pie.prototype.pointClass;
var defined57 = Utilities_default.defined;
var isNumber52 = Utilities_default.isNumber;
var merge86 = Utilities_default.merge;
var objectEach38 = Utilities_default.objectEach;
var pick97 = Utilities_default.pick;
var TimelinePoint = (
  /** @class */
  function(_super) {
    __extends54(TimelinePoint2, _super);
    function TimelinePoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.series = void 0;
      return _this;
    }
    TimelinePoint2.prototype.alignConnector = function() {
      var point = this, series = point.series, connector = point.connector, dl = point.dataLabel, dlOptions = point.dataLabel.options = merge86(series.options.dataLabels, point.options.dataLabels), chart = point.series.chart, bBox = connector.getBBox(), plotPos = {
        x: bBox.x + dl.translateX,
        y: bBox.y + dl.translateY
      }, isVisible;
      if (chart.inverted) {
        plotPos.y -= dl.options.connectorWidth / 2;
      } else {
        plotPos.x += dl.options.connectorWidth / 2;
      }
      isVisible = chart.isInsidePlot(plotPos.x, plotPos.y);
      connector[isVisible ? "animate" : "attr"]({
        d: point.getConnectorPath()
      });
      if (!series.chart.styledMode) {
        connector.attr({
          stroke: dlOptions.connectorColor || point.color,
          "stroke-width": dlOptions.connectorWidth,
          opacity: dl[defined57(dl.newOpacity) ? "newOpacity" : "opacity"]
        });
      }
    };
    TimelinePoint2.prototype.drawConnector = function() {
      var point = this, series = point.series;
      if (!point.connector) {
        point.connector = series.chart.renderer.path(point.getConnectorPath()).attr({
          zIndex: -1
        }).add(point.dataLabel);
      }
      if (point.series.chart.isInsidePlot(
        // #10507
        point.dataLabel.x,
        point.dataLabel.y
      )) {
        point.alignConnector();
      }
    };
    TimelinePoint2.prototype.getConnectorPath = function() {
      var point = this, chart = point.series.chart, xAxisLen = point.series.xAxis.len, inverted = chart.inverted, direction = inverted ? "x2" : "y2", dl = point.dataLabel, targetDLPos = dl.targetPosition, coords = {
        x1: point.plotX,
        y1: point.plotY,
        x2: point.plotX,
        y2: isNumber52(targetDLPos.y) ? targetDLPos.y : dl.y
      }, negativeDistance = (dl.alignAttr || dl)[direction[0]] < point.series.yAxis.len / 2, path;
      if (inverted) {
        coords = {
          x1: point.plotY,
          y1: xAxisLen - point.plotX,
          x2: targetDLPos.x || dl.x,
          y2: xAxisLen - point.plotX
        };
      }
      if (negativeDistance) {
        coords[direction] += dl[inverted ? "width" : "height"];
      }
      objectEach38(coords, function(_coord, i) {
        coords[i] -= (dl.alignAttr || dl)[i[0]];
      });
      path = chart.renderer.crispLine([
        ["M", coords.x1, coords.y1],
        ["L", coords.x2, coords.y2]
      ], dl.options.connectorWidth);
      return path;
    };
    TimelinePoint2.prototype.init = function() {
      var point = _super.prototype.init.apply(this, arguments);
      point.name = pick97(point.name, "Event");
      point.y = 1;
      return point;
    };
    TimelinePoint2.prototype.isValid = function() {
      return this.options.y !== null;
    };
    TimelinePoint2.prototype.setState = function() {
      var proceed = _super.prototype.setState;
      if (!this.isNull) {
        proceed.apply(this, arguments);
      }
    };
    TimelinePoint2.prototype.setVisible = function(visible, redraw) {
      var point = this, series = point.series;
      redraw = pick97(redraw, series.options.ignoreHiddenPoint);
      PiePoint4.prototype.setVisible.call(point, visible, false);
      series.processData();
      if (redraw) {
        series.chart.redraw();
      }
    };
    TimelinePoint2.prototype.applyOptions = function(options, x) {
      options = Point_default.prototype.optionsToObject.call(this, options);
      this.userDLOptions = merge86(this.userDLOptions, options.dataLabels);
      return _super.prototype.applyOptions.call(this, options, x);
    };
    return TimelinePoint2;
  }(Series14.prototype.pointClass)
);
var TimelinePoint_default = TimelinePoint;

// node_modules/highcharts/es-modules/Series/Timeline/TimelineSeries.js
var __extends55 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a14 = SeriesRegistry_default.seriesTypes;
var ColumnSeries15 = _a14.column;
var LineSeries6 = _a14.line;
var addEvent66 = Utilities_default.addEvent;
var arrayMax11 = Utilities_default.arrayMax;
var arrayMin10 = Utilities_default.arrayMin;
var defined58 = Utilities_default.defined;
var extend90 = Utilities_default.extend;
var merge87 = Utilities_default.merge;
var pick98 = Utilities_default.pick;
var TimelineSeries = (
  /** @class */
  function(_super) {
    __extends55(TimelineSeries2, _super);
    function TimelineSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.userOptions = void 0;
      _this.visibilityMap = void 0;
      return _this;
    }
    TimelineSeries2.prototype.alignDataLabel = function(point, dataLabel, _options, _alignTo) {
      var series = this, isInverted = series.chart.inverted, visiblePoints = series.visibilityMap.filter(function(point2) {
        return point2;
      }), visiblePointsCount = series.visiblePointsCount, pointIndex = visiblePoints.indexOf(point), isFirstOrLast = !pointIndex || pointIndex === visiblePointsCount - 1, dataLabelsOptions = series.options.dataLabels, userDLOptions = point.userDLOptions || {}, multiplier = dataLabelsOptions.alternate ? isFirstOrLast ? 1.5 : 2 : 1, distance, availableSpace = Math.floor(series.xAxis.len / visiblePointsCount), pad4 = dataLabel.padding, targetDLWidth, styles;
      if (point.visible) {
        distance = Math.abs(userDLOptions.x || point.options.dataLabels.x);
        if (isInverted) {
          targetDLWidth = (distance - pad4) * 2 - point.itemHeight / 2;
          styles = {
            width: targetDLWidth + "px",
            // Apply ellipsis when data label height is exceeded.
            textOverflow: dataLabel.width / targetDLWidth * dataLabel.height / 2 > availableSpace * multiplier ? "ellipsis" : "none"
          };
        } else {
          styles = {
            width: (userDLOptions.width || dataLabelsOptions.width || availableSpace * multiplier - pad4 * 2) + "px"
          };
        }
        dataLabel.css(styles);
        if (!series.chart.styledMode) {
          dataLabel.shadow(dataLabelsOptions.shadow);
        }
      }
      _super.prototype.alignDataLabel.apply(series, arguments);
    };
    TimelineSeries2.prototype.bindAxes = function() {
      var series = this;
      _super.prototype.bindAxes.call(series);
      ["xAxis", "yAxis"].forEach(function(axis) {
        if (axis === "xAxis" && !series[axis].userOptions.type) {
          series[axis].categories = series[axis].hasNames = true;
        }
      });
    };
    TimelineSeries2.prototype.distributeDL = function() {
      var series = this, dataLabelsOptions = series.options.dataLabels;
      var visibilityIndex = 1;
      if (dataLabelsOptions) {
        var distance_1 = dataLabelsOptions.distance || 0;
        series.points.forEach(function(point) {
          var _a15;
          point.options.dataLabels = merge87((_a15 = {}, _a15[series.chart.inverted ? "x" : "y"] = dataLabelsOptions.alternate && visibilityIndex % 2 ? -distance_1 : distance_1, _a15), point.userDLOptions);
          visibilityIndex++;
        });
      }
    };
    TimelineSeries2.prototype.generatePoints = function() {
      var series = this;
      _super.prototype.generatePoints.apply(series);
      series.points.forEach(function(point, i) {
        point.applyOptions({
          x: series.xData[i]
        }, series.xData[i]);
      });
    };
    TimelineSeries2.prototype.getVisibilityMap = function() {
      var series = this, map = (series.data.length ? series.data : series.userOptions.data).map(function(point) {
        return point && point.visible !== false && !point.isNull ? point : false;
      });
      return map;
    };
    TimelineSeries2.prototype.getXExtremes = function(xData) {
      var series = this, filteredData = xData.filter(function(x, i) {
        return series.points[i].isValid() && series.points[i].visible;
      });
      return {
        min: arrayMin10(filteredData),
        max: arrayMax11(filteredData)
      };
    };
    TimelineSeries2.prototype.init = function() {
      var series = this;
      _super.prototype.init.apply(series, arguments);
      series.eventsToUnbind.push(addEvent66(series, "afterTranslate", function() {
        var lastPlotX, closestPointRangePx = Number.MAX_VALUE;
        series.points.forEach(function(point) {
          point.isInside = point.isInside && point.visible;
          if (point.visible && !point.isNull) {
            if (defined58(lastPlotX)) {
              closestPointRangePx = Math.min(closestPointRangePx, Math.abs(point.plotX - lastPlotX));
            }
            lastPlotX = point.plotX;
          }
        });
        series.closestPointRangePx = closestPointRangePx;
      }));
      series.eventsToUnbind.push(addEvent66(series, "drawDataLabels", function() {
        series.distributeDL();
      }));
      series.eventsToUnbind.push(addEvent66(series, "afterDrawDataLabels", function() {
        var dataLabel;
        series.points.forEach(function(point) {
          dataLabel = point.dataLabel;
          if (dataLabel) {
            dataLabel.animate = function(params) {
              if (this.targetPosition) {
                this.targetPosition = params;
              }
              return SVGElement_default.prototype.animate.apply(this, arguments);
            };
            if (!dataLabel.targetPosition) {
              dataLabel.targetPosition = {};
            }
            return point.drawConnector();
          }
        });
      }));
      series.eventsToUnbind.push(addEvent66(series.chart, "afterHideOverlappingLabel", function() {
        series.points.forEach(function(p) {
          if (p.connector && p.dataLabel && p.dataLabel.oldOpacity !== p.dataLabel.newOpacity) {
            p.alignConnector();
          }
        });
      }));
    };
    TimelineSeries2.prototype.markerAttribs = function(point, state) {
      var series = this, seriesMarkerOptions = series.options.marker, seriesStateOptions, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol, pointStateOptions, width = pick98(pointMarkerOptions.width, seriesMarkerOptions.width, series.closestPointRangePx), height = pick98(pointMarkerOptions.height, seriesMarkerOptions.height), radius = 0, attribs;
      if (series.xAxis.dateTime) {
        return _super.prototype.markerAttribs.call(this, point, state);
      }
      if (state) {
        seriesStateOptions = seriesMarkerOptions.states[state] || {};
        pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
        radius = pick98(pointStateOptions.radius, seriesStateOptions.radius, radius + (seriesStateOptions.radiusPlus || 0));
      }
      point.hasImage = symbol && symbol.indexOf("url") === 0;
      attribs = {
        x: Math.floor(point.plotX) - width / 2 - radius / 2,
        y: point.plotY - height / 2 - radius / 2,
        width: width + radius,
        height: height + radius
      };
      return attribs;
    };
    TimelineSeries2.prototype.processData = function() {
      var series = this, visiblePoints = 0, i;
      series.visibilityMap = series.getVisibilityMap();
      series.visibilityMap.forEach(function(point) {
        if (point) {
          visiblePoints++;
        }
      });
      series.visiblePointsCount = visiblePoints;
      for (i = 0; i < series.xData.length; i++) {
        series.yData[i] = 1;
      }
      _super.prototype.processData.call(this, arguments);
      return;
    };
    TimelineSeries2.defaultOptions = merge87(LineSeries6.defaultOptions, {
      colorByPoint: true,
      stickyTracking: false,
      ignoreHiddenPoint: true,
      /**
       * @ignore
       * @private
       */
      legendType: "point",
      lineWidth: 4,
      tooltip: {
        headerFormat: '<span style="color:{point.color}"></span> <span style="font-size: 10px"> {point.key}</span><br/>',
        pointFormat: "{point.description}"
      },
      states: {
        hover: {
          lineWidthPlus: 0
        }
      },
      /**
       * @declare Highcharts.TimelineDataLabelsOptionsObject
       *
       * @private
       */
      dataLabels: {
        enabled: true,
        allowOverlap: true,
        /**
         * Whether to position data labels alternately. For example, if
         * [distance](#plotOptions.timeline.dataLabels.distance)
         * is set equal to `100`, then data labels will be positioned
         * alternately (on both sides of the point) at a distance of 100px.
         *
         * @sample {highcharts} highcharts/series-timeline/alternate-disabled
         *         Alternate disabled
         */
        alternate: true,
        backgroundColor: Palette_default.backgroundColor,
        borderWidth: 1,
        borderColor: Palette_default.neutralColor40,
        borderRadius: 3,
        color: Palette_default.neutralColor80,
        /**
         * The color of the line connecting the data label to the point.
         * The default color is the same as the point's color.
         *
         * In styled mode, the connector stroke is given in the
         * `.highcharts-data-label-connector` class.
         *
         * @sample {highcharts} highcharts/series-timeline/connector-styles
         *         Custom connector width and color
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption plotOptions.timeline.dataLabels.connectorColor
         */
        /**
         * The width of the line connecting the data label to the point.
         *
         * In styled mode, the connector stroke width is given in the
         * `.highcharts-data-label-connector` class.
         *
         * @sample {highcharts} highcharts/series-timeline/connector-styles
         *         Custom connector width and color
         */
        connectorWidth: 1,
        /**
         * A pixel value defining the distance between the data label and
         * the point. Negative numbers puts the label on top of the point.
         */
        distance: 100,
        // eslint-disable-next-line valid-jsdoc
        /**
         * @type    {Highcharts.TimelineDataLabelsFormatterCallbackFunction}
         * @default function () {
         *   let format;
         *
         *   if (!this.series.chart.styledMode) {
         *       format = '<span style="color:' + this.point.color +
         *           '"> </span>';
         *   } else {
         *       format = '<span> </span>';
         *   }
         *   format += '<span>' + (this.key || '') + '</span><br/>' +
         *       (this.point.label || '');
         *   return format;
         * }
         */
        formatter: function() {
          var format15;
          if (!this.series.chart.styledMode) {
            format15 = '<span style="color:' + this.point.color + '"> </span>';
          } else {
            format15 = "<span> </span>";
          }
          format15 += '<span class="highcharts-strong">' + (this.key || "") + "</span><br/>" + (this.point.label || "");
          return format15;
        },
        style: {
          /** @internal */
          textOutline: "none",
          /** @internal */
          fontWeight: "normal",
          /** @internal */
          fontSize: "12px"
        },
        /**
         * Shadow options for the data label.
         *
         * @type {boolean|Highcharts.CSSObject}
         */
        shadow: false,
        /**
         * @type      {number}
         * @apioption plotOptions.timeline.dataLabels.width
         */
        verticalAlign: "middle"
      },
      marker: {
        enabledThreshold: 0,
        symbol: "square",
        radius: 6,
        lineWidth: 2,
        height: 15
      },
      showInLegend: false,
      colorKey: "x"
    });
    return TimelineSeries2;
  }(LineSeries6)
);
extend90(TimelineSeries.prototype, {
  // Use a simple symbol from LegendSymbolMixin
  drawLegendSymbol: LegendSymbol_default.drawRectangle,
  // Use a group of trackers from TrackerMixin
  drawTracker: ColumnSeries15.prototype.drawTracker,
  pointClass: TimelinePoint_default,
  trackerGroups: ["markerGroup", "dataLabelsGroup"]
});
SeriesRegistry_default.registerSeriesType("timeline", TimelineSeries);

// node_modules/highcharts/es-modules/Series/Organization/OrganizationPoint.js
var __extends56 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SankeyPoint2 = SeriesRegistry_default.seriesTypes.sankey.prototype.pointClass;
var OrganizationPoint = (
  /** @class */
  function(_super) {
    __extends56(OrganizationPoint2, _super);
    function OrganizationPoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.fromNode = void 0;
      _this.linksFrom = void 0;
      _this.linksTo = void 0;
      _this.options = void 0;
      _this.series = void 0;
      _this.toNode = void 0;
      return _this;
    }
    OrganizationPoint2.prototype.getSum = function() {
      return 1;
    };
    return OrganizationPoint2;
  }(SankeyPoint2)
);
var OrganizationPoint_default = OrganizationPoint;

// node_modules/highcharts/es-modules/Series/Organization/OrganizationSeries.js
var __extends57 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SankeySeries2 = SeriesRegistry_default.seriesTypes.sankey;
var css15 = Utilities_default.css;
var extend91 = Utilities_default.extend;
var merge88 = Utilities_default.merge;
var pick99 = Utilities_default.pick;
var wrap14 = Utilities_default.wrap;
var OrganizationSeries = (
  /** @class */
  function(_super) {
    __extends57(OrganizationSeries2, _super);
    function OrganizationSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    OrganizationSeries2.curvedPath = function(path, r) {
      var d = [];
      for (var i = 0; i < path.length; i++) {
        var x = path[i][1];
        var y = path[i][2];
        if (typeof x === "number" && typeof y === "number") {
          if (i === 0) {
            d.push(["M", x, y]);
          } else if (i === path.length - 1) {
            d.push(["L", x, y]);
          } else if (r) {
            var prevSeg = path[i - 1];
            var nextSeg = path[i + 1];
            if (prevSeg && nextSeg) {
              var x1 = prevSeg[1], y1 = prevSeg[2], x2 = nextSeg[1], y2 = nextSeg[2];
              if (typeof x1 === "number" && typeof x2 === "number" && typeof y1 === "number" && typeof y2 === "number" && x1 !== x2 && y1 !== y2) {
                var directionX = x1 < x2 ? 1 : -1, directionY = y1 < y2 ? 1 : -1;
                d.push([
                  "L",
                  x - directionX * Math.min(Math.abs(x - x1), r),
                  y - directionY * Math.min(Math.abs(y - y1), r)
                ], [
                  "C",
                  x,
                  y,
                  x,
                  y,
                  x + directionX * Math.min(Math.abs(x - x2), r),
                  y + directionY * Math.min(Math.abs(y - y2), r)
                ]);
              }
            }
          } else {
            d.push(["L", x, y]);
          }
        }
      }
      return d;
    };
    OrganizationSeries2.prototype.alignDataLabel = function(point, dataLabel, options) {
      if (options.useHTML) {
        var width_1 = point.shapeArgs.width, height_1 = point.shapeArgs.height, padjust = this.options.borderWidth + 2 * this.options.dataLabels.padding;
        if (this.chart.inverted) {
          width_1 = height_1;
          height_1 = point.shapeArgs.width;
        }
        height_1 -= padjust;
        width_1 -= padjust;
        var text = dataLabel.text;
        if (text) {
          css15(text.element.parentNode, {
            width: width_1 + "px",
            height: height_1 + "px"
          });
          css15(text.element, {
            left: 0,
            top: 0,
            width: "100%",
            height: "100%",
            overflow: "hidden"
          });
        }
        dataLabel.getBBox = function() {
          return {
            width: width_1,
            height: height_1
          };
        };
        dataLabel.width = width_1;
        dataLabel.height = height_1;
      }
      _super.prototype.alignDataLabel.apply(this, arguments);
    };
    OrganizationSeries2.prototype.createNode = function(id) {
      var node = _super.prototype.createNode.call(this, id);
      node.getSum = function() {
        return 1;
      };
      return node;
    };
    OrganizationSeries2.prototype.createNodeColumn = function() {
      var column = _super.prototype.createNodeColumn.call(this);
      wrap14(column, "offset", function(proceed, node, factor) {
        var offset3 = proceed.call(this, node, factor);
        if (node.hangsFrom) {
          return {
            absoluteTop: node.hangsFrom.nodeY
          };
        }
        return offset3;
      });
      return column;
    };
    OrganizationSeries2.prototype.pointAttribs = function(point, state) {
      var series = this, attribs = SankeySeries2.prototype.pointAttribs.call(series, point, state), level = point.isNode ? point.level : point.fromNode.level, levelOptions = series.mapOptionsToLevel[level || 0] || {}, options = point.options, stateOptions = levelOptions.states && levelOptions.states[state] || {}, values = ["borderRadius", "linkColor", "linkLineWidth"].reduce(function(obj, key) {
        obj[key] = pick99(stateOptions[key], options[key], levelOptions[key], series.options[key]);
        return obj;
      }, {});
      if (!point.isNode) {
        attribs.stroke = values.linkColor;
        attribs["stroke-width"] = values.linkLineWidth;
        delete attribs.fill;
      } else {
        if (values.borderRadius) {
          attribs.r = values.borderRadius;
        }
      }
      return attribs;
    };
    OrganizationSeries2.prototype.translateLink = function(point) {
      var fromNode = point.fromNode, toNode = point.toNode, crisp = Math.round(this.options.linkLineWidth) % 2 / 2, x1 = Math.floor(fromNode.shapeArgs.x + fromNode.shapeArgs.width) + crisp, y1 = Math.floor(fromNode.shapeArgs.y + fromNode.shapeArgs.height / 2) + crisp, x2 = Math.floor(toNode.shapeArgs.x) + crisp, y2 = Math.floor(toNode.shapeArgs.y + toNode.shapeArgs.height / 2) + crisp, xMiddle, hangingIndent = this.options.hangingIndent, toOffset = toNode.options.offset, percentOffset = /%$/.test(toOffset) && parseInt(toOffset, 10), inverted = this.chart.inverted;
      if (inverted) {
        x1 -= fromNode.shapeArgs.width;
        x2 += toNode.shapeArgs.width;
      }
      xMiddle = Math.floor(x2 + (inverted ? 1 : -1) * (this.colDistance - this.nodeWidth) / 2) + crisp;
      if (percentOffset && (percentOffset >= 50 || percentOffset <= -50)) {
        xMiddle = x2 = Math.floor(x2 + (inverted ? -0.5 : 0.5) * toNode.shapeArgs.width) + crisp;
        y2 = toNode.shapeArgs.y;
        if (percentOffset > 0) {
          y2 += toNode.shapeArgs.height;
        }
      }
      if (toNode.hangsFrom === fromNode) {
        if (this.chart.inverted) {
          y1 = Math.floor(fromNode.shapeArgs.y + fromNode.shapeArgs.height - hangingIndent / 2) + crisp;
          y2 = toNode.shapeArgs.y + toNode.shapeArgs.height;
        } else {
          y1 = Math.floor(fromNode.shapeArgs.y + hangingIndent / 2) + crisp;
        }
        xMiddle = x2 = Math.floor(toNode.shapeArgs.x + toNode.shapeArgs.width / 2) + crisp;
      }
      point.plotY = 1;
      point.shapeType = "path";
      point.shapeArgs = {
        d: OrganizationSeries2.curvedPath([
          ["M", x1, y1],
          ["L", xMiddle, y1],
          ["L", xMiddle, y2],
          ["L", x2, y2]
        ], this.options.linkRadius)
      };
    };
    OrganizationSeries2.prototype.translateNode = function(node, column) {
      SankeySeries2.prototype.translateNode.call(this, node, column);
      if (node.hangsFrom) {
        node.shapeArgs.height -= this.options.hangingIndent;
        if (!this.chart.inverted) {
          node.shapeArgs.y += this.options.hangingIndent;
        }
      }
      node.nodeHeight = this.chart.inverted ? node.shapeArgs.width : node.shapeArgs.height;
    };
    OrganizationSeries2.defaultOptions = merge88(SankeySeries2.defaultOptions, {
      /**
       * The border color of the node cards.
       *
       * @type {Highcharts.ColorString}
       * @private
       */
      borderColor: Palette_default.neutralColor60,
      /**
       * The border radius of the node cards.
       *
       * @private
       */
      borderRadius: 3,
      /**
       * Radius for the rounded corners of the links between nodes.
       *
       * @sample   highcharts/series-organization/link-options
       *           Square links
       *
       * @private
       */
      linkRadius: 10,
      borderWidth: 1,
      /**
       * @declare Highcharts.SeriesOrganizationDataLabelsOptionsObject
       *
       * @private
       */
      dataLabels: {
        /* eslint-disable valid-jsdoc */
        /**
         * A callback for defining the format for _nodes_ in the
         * organization chart. The `nodeFormat` option takes precedence
         * over `nodeFormatter`.
         *
         * In an organization chart, the `nodeFormatter` is a quite complex
         * function of the available options, striving for a good default
         * layout of cards with or without images. In organization chart,
         * the data labels come with `useHTML` set to true, meaning they
         * will be rendered as true HTML above the SVG.
         *
         * @sample highcharts/series-organization/datalabels-nodeformatter
         *         Modify the default label format output
         *
         * @type  {Highcharts.SeriesSankeyDataLabelsFormatterCallbackFunction}
         * @since 6.0.2
         */
        nodeFormatter: function() {
          var outerStyle = {
            width: "100%",
            height: "100%",
            display: "flex",
            "flex-direction": "row",
            "align-items": "center",
            "justify-content": "center"
          }, imageStyle = {
            "max-height": "100%",
            "border-radius": "50%"
          }, innerStyle = {
            width: "100%",
            padding: 0,
            "text-align": "center",
            "white-space": "normal"
          }, nameStyle = {
            margin: 0
          }, titleStyle = {
            margin: 0
          }, descriptionStyle = {
            opacity: 0.75,
            margin: "5px"
          };
          function styleAttr(style) {
            return Object.keys(style).reduce(function(str, key) {
              return str + key + ":" + style[key] + ";";
            }, 'style="') + '"';
          }
          if (this.point.image) {
            imageStyle["max-width"] = "30%";
            innerStyle.width = "70%";
          }
          if (this.series.chart.renderer.forExport) {
            outerStyle.display = "block";
            innerStyle.position = "absolute";
            innerStyle.left = this.point.image ? "30%" : 0;
            innerStyle.top = 0;
          }
          var html2 = "<div " + styleAttr(outerStyle) + ">";
          if (this.point.image) {
            html2 += '<img src="' + this.point.image + '" ' + styleAttr(imageStyle) + ">";
          }
          html2 += "<div " + styleAttr(innerStyle) + ">";
          if (this.point.name) {
            html2 += "<h4 " + styleAttr(nameStyle) + ">" + this.point.name + "</h4>";
          }
          if (this.point.title) {
            html2 += "<p " + styleAttr(titleStyle) + ">" + (this.point.title || "") + "</p>";
          }
          if (this.point.description) {
            html2 += "<p " + styleAttr(descriptionStyle) + ">" + this.point.description + "</p>";
          }
          html2 += "</div></div>";
          return html2;
        },
        /* eslint-enable valid-jsdoc */
        style: {
          /** @internal */
          fontWeight: "normal",
          /** @internal */
          fontSize: "13px"
        },
        useHTML: true
      },
      /**
       * The indentation in pixels of hanging nodes, nodes which parent has
       * [layout](#series.organization.nodes.layout) set to `hanging`.
       *
       * @private
       */
      hangingIndent: 20,
      /**
       * The color of the links between nodes.
       *
       * @type {Highcharts.ColorString}
       * @private
       */
      linkColor: Palette_default.neutralColor60,
      /**
       * The line width of the links connecting nodes, in pixels.
       *
       * @sample   highcharts/series-organization/link-options
       *           Square links
       *
       * @private
       */
      linkLineWidth: 1,
      /**
       * In a horizontal chart, the width of the nodes in pixels. Node that
       * most organization charts are vertical, so the name of this option
       * is counterintuitive.
       *
       * @private
       */
      nodeWidth: 50,
      tooltip: {
        nodeFormat: "{point.name}<br>{point.title}<br>{point.description}"
      }
    });
    return OrganizationSeries2;
  }(SankeySeries2)
);
extend91(OrganizationSeries.prototype, {
  pointClass: OrganizationPoint_default
});
SeriesRegistry_default.registerSeriesType("organization", OrganizationSeries);

// node_modules/highcharts/es-modules/Series/XRange/XRangePoint.js
var __extends58 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries16 = SeriesRegistry_default.seriesTypes.column;
var extend92 = Utilities_default.extend;
var XRangePoint = (
  /** @class */
  function(_super) {
    __extends58(XRangePoint2, _super);
    function XRangePoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.series = void 0;
      return _this;
    }
    XRangePoint2.getColorByCategory = function(series, point) {
      var colors = series.options.colors || series.chart.options.colors, colorCount = colors ? colors.length : series.chart.options.chart.colorCount, colorIndex = point.y % colorCount, color18 = colors && colors[colorIndex];
      return {
        colorIndex,
        color: color18
      };
    };
    XRangePoint2.prototype.resolveColor = function() {
      var series = this.series, colorByPoint;
      if (series.options.colorByPoint && !this.options.color) {
        colorByPoint = XRangePoint2.getColorByCategory(series, this);
        if (!series.chart.styledMode) {
          this.color = colorByPoint.color;
        }
        if (!this.options.colorIndex) {
          this.colorIndex = colorByPoint.colorIndex;
        }
      } else if (!this.color) {
        this.color = series.color;
      }
    };
    XRangePoint2.prototype.init = function() {
      Point_default.prototype.init.apply(this, arguments);
      if (!this.y) {
        this.y = 0;
      }
      return this;
    };
    XRangePoint2.prototype.setState = function() {
      Point_default.prototype.setState.apply(this, arguments);
      this.series.drawPoint(this, this.series.getAnimationVerb());
    };
    XRangePoint2.prototype.getLabelConfig = function() {
      var point = this, cfg = Point_default.prototype.getLabelConfig.call(point), yCats = point.series.yAxis.categories;
      cfg.x2 = point.x2;
      cfg.yCategory = point.yCategory = yCats && yCats[point.y];
      return cfg;
    };
    XRangePoint2.prototype.isValid = function() {
      return typeof this.x === "number" && typeof this.x2 === "number";
    };
    return XRangePoint2;
  }(ColumnSeries16.prototype.pointClass)
);
extend92(XRangePoint.prototype, {
  tooltipDateKeys: ["x", "x2"]
});
var XRangePoint_default = XRangePoint;

// node_modules/highcharts/es-modules/Series/XRange/XRangeComposition.js
var addEvent67 = Utilities_default.addEvent;
var pick100 = Utilities_default.pick;
addEvent67(Axis_default, "afterGetSeriesExtremes", function() {
  var axis = this, axisSeries = axis.series, dataMax, modMax;
  if (axis.isXAxis) {
    dataMax = pick100(axis.dataMax, -Number.MAX_VALUE);
    axisSeries.forEach(function(series) {
      if (series.x2Data) {
        series.x2Data.forEach(function(val) {
          if (val > dataMax) {
            dataMax = val;
            modMax = true;
          }
        });
      }
    });
    if (modMax) {
      axis.dataMax = dataMax;
    }
  }
});

// node_modules/highcharts/es-modules/Series/XRange/XRangeSeries.js
var __extends59 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var color17 = Color_default.parse;
var Series15 = SeriesRegistry_default.series;
var ColumnSeries17 = SeriesRegistry_default.seriesTypes.column;
var columnProto6 = ColumnSeries17.prototype;
var clamp20 = Utilities_default.clamp;
var correctFloat14 = Utilities_default.correctFloat;
var defined59 = Utilities_default.defined;
var extend93 = Utilities_default.extend;
var find20 = Utilities_default.find;
var isNumber53 = Utilities_default.isNumber;
var isObject16 = Utilities_default.isObject;
var merge89 = Utilities_default.merge;
var pick101 = Utilities_default.pick;
var XRangeSeries = (
  /** @class */
  function(_super) {
    __extends59(XRangeSeries2, _super);
    function XRangeSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      return _this;
    }
    XRangeSeries2.prototype.init = function() {
      ColumnSeries17.prototype.init.apply(this, arguments);
      this.options.stacking = void 0;
    };
    XRangeSeries2.prototype.getColumnMetrics = function() {
      var metrics, chart = this.chart;
      function swapAxes() {
        chart.series.forEach(function(s) {
          var xAxis = s.xAxis;
          s.xAxis = s.yAxis;
          s.yAxis = xAxis;
        });
      }
      swapAxes();
      metrics = columnProto6.getColumnMetrics.call(this);
      swapAxes();
      return metrics;
    };
    XRangeSeries2.prototype.cropData = function(xData, yData, min, max) {
      var cropData = Series15.prototype.cropData, crop = cropData.call(this, this.x2Data, yData, min, max);
      crop.xData = xData.slice(crop.start, crop.end);
      return crop;
    };
    XRangeSeries2.prototype.findPointIndex = function(options) {
      var _a15 = this, cropped = _a15.cropped, cropStart = _a15.cropStart, points = _a15.points;
      var id = options.id;
      var pointIndex;
      if (id) {
        var point = find20(points, function(point2) {
          return point2.id === id;
        });
        pointIndex = point ? point.index : void 0;
      }
      if (typeof pointIndex === "undefined") {
        var point = find20(points, function(point2) {
          return point2.x === options.x && point2.x2 === options.x2 && !point2.touched;
        });
        pointIndex = point ? point.index : void 0;
      }
      if (cropped && isNumber53(pointIndex) && isNumber53(cropStart) && pointIndex >= cropStart) {
        pointIndex -= cropStart;
      }
      return pointIndex;
    };
    XRangeSeries2.prototype.translatePoint = function(point) {
      var series = this, xAxis = series.xAxis, yAxis = series.yAxis, metrics = series.columnMetrics, options = series.options, minPointLength = options.minPointLength || 0, oldColWidth = (point.shapeArgs && point.shapeArgs.width || 0) / 2, seriesXOffset = series.pointXOffset = metrics.offset, plotX = point.plotX, posX = pick101(point.x2, point.x + (point.len || 0)), plotX2 = xAxis.translate(posX, 0, 0, 0, 1), length = Math.abs(plotX2 - plotX), widthDifference, partialFill, inverted = this.chart.inverted, borderWidth = pick101(options.borderWidth, 1), crisper = borderWidth % 2 / 2, yOffset = metrics.offset, pointHeight = Math.round(metrics.width), dlLeft, dlRight, dlWidth, clipRectWidth, tooltipYOffset;
      if (minPointLength) {
        widthDifference = minPointLength - length;
        if (widthDifference < 0) {
          widthDifference = 0;
        }
        plotX -= widthDifference / 2;
        plotX2 += widthDifference / 2;
      }
      plotX = Math.max(plotX, -10);
      plotX2 = clamp20(plotX2, -10, xAxis.len + 10);
      if (defined59(point.options.pointWidth)) {
        yOffset -= (Math.ceil(point.options.pointWidth) - pointHeight) / 2;
        pointHeight = Math.ceil(point.options.pointWidth);
      }
      if (options.pointPlacement && isNumber53(point.plotY) && yAxis.categories) {
        point.plotY = yAxis.translate(point.y, 0, 1, 0, 1, options.pointPlacement);
      }
      var x = Math.floor(Math.min(plotX, plotX2)) + crisper;
      var x2 = Math.floor(Math.max(plotX, plotX2)) + crisper;
      var shapeArgs = {
        x,
        y: Math.floor(point.plotY + yOffset) + crisper,
        width: x2 - x,
        height: pointHeight,
        r: series.options.borderRadius
      };
      point.shapeArgs = shapeArgs;
      if (!inverted) {
        point.tooltipPos[0] -= oldColWidth + seriesXOffset - shapeArgs.width / 2;
      } else {
        point.tooltipPos[1] += seriesXOffset + oldColWidth;
      }
      dlLeft = shapeArgs.x;
      dlRight = dlLeft + shapeArgs.width;
      if (dlLeft < 0 || dlRight > xAxis.len) {
        dlLeft = clamp20(dlLeft, 0, xAxis.len);
        dlRight = clamp20(dlRight, 0, xAxis.len);
        dlWidth = dlRight - dlLeft;
        point.dlBox = merge89(shapeArgs, {
          x: dlLeft,
          width: dlRight - dlLeft,
          centerX: dlWidth ? dlWidth / 2 : null
        });
      } else {
        point.dlBox = null;
      }
      var tooltipPos = point.tooltipPos;
      var xIndex = !inverted ? 0 : 1;
      var yIndex = !inverted ? 1 : 0;
      tooltipYOffset = series.columnMetrics ? series.columnMetrics.offset : -metrics.width / 2;
      if (!inverted) {
        tooltipPos[xIndex] += (xAxis.reversed ? -1 : 0) * shapeArgs.width;
      } else {
        tooltipPos[xIndex] += shapeArgs.width / 2;
      }
      tooltipPos[yIndex] = clamp20(tooltipPos[yIndex] + (inverted ? -1 : 1) * tooltipYOffset, 0, yAxis.len - 1);
      partialFill = point.partialFill;
      if (partialFill) {
        if (isObject16(partialFill)) {
          partialFill = partialFill.amount;
        }
        if (!isNumber53(partialFill)) {
          partialFill = 0;
        }
        point.partShapeArgs = merge89(shapeArgs, {
          r: series.options.borderRadius
        });
        clipRectWidth = Math.max(Math.round(length * partialFill + point.plotX - plotX), 0);
        point.clipRectArgs = {
          x: xAxis.reversed ? (
            // #10717
            shapeArgs.x + length - clipRectWidth
          ) : shapeArgs.x,
          y: shapeArgs.y,
          width: clipRectWidth,
          height: shapeArgs.height
        };
      }
    };
    XRangeSeries2.prototype.translate = function() {
      columnProto6.translate.apply(this, arguments);
      this.points.forEach(function(point) {
        this.translatePoint(point);
      }, this);
    };
    XRangeSeries2.prototype.drawPoint = function(point, verb) {
      var series = this, seriesOpts = series.options, renderer = series.chart.renderer, graphic = point.graphic, type = point.shapeType, shapeArgs = point.shapeArgs, partShapeArgs = point.partShapeArgs, clipRectArgs = point.clipRectArgs, pfOptions = point.partialFill, cutOff = seriesOpts.stacking && !seriesOpts.borderRadius, pointState = point.state, stateOpts = seriesOpts.states[pointState || "normal"] || {}, pointStateVerb = typeof pointState === "undefined" ? "attr" : verb, pointAttr = series.pointAttribs(point, pointState), animation = pick101(series.chart.options.chart.animation, stateOpts.animation), fill;
      if (!point.isNull && point.visible !== false) {
        if (graphic) {
          graphic.rect[verb](shapeArgs);
        } else {
          point.graphic = graphic = renderer.g("point").addClass(point.getClassName()).add(point.group || series.group);
          graphic.rect = renderer[type](merge89(shapeArgs)).addClass(point.getClassName()).addClass("highcharts-partfill-original").add(graphic);
        }
        if (partShapeArgs) {
          if (graphic.partRect) {
            graphic.partRect[verb](merge89(partShapeArgs));
            graphic.partialClipRect[verb](merge89(clipRectArgs));
          } else {
            graphic.partialClipRect = renderer.clipRect(clipRectArgs.x, clipRectArgs.y, clipRectArgs.width, clipRectArgs.height);
            graphic.partRect = renderer[type](partShapeArgs).addClass("highcharts-partfill-overlay").add(graphic).clip(graphic.partialClipRect);
          }
        }
        if (!series.chart.styledMode) {
          graphic.rect[verb](pointAttr, animation).shadow(seriesOpts.shadow, null, cutOff);
          if (partShapeArgs) {
            if (!isObject16(pfOptions)) {
              pfOptions = {};
            }
            if (isObject16(seriesOpts.partialFill)) {
              pfOptions = merge89(seriesOpts.partialFill, pfOptions);
            }
            fill = pfOptions.fill || color17(pointAttr.fill).brighten(-0.3).get() || color17(point.color || series.color).brighten(-0.3).get();
            pointAttr.fill = fill;
            graphic.partRect[pointStateVerb](pointAttr, animation).shadow(seriesOpts.shadow, null, cutOff);
          }
        }
      } else if (graphic) {
        point.graphic = graphic.destroy();
      }
    };
    XRangeSeries2.prototype.drawPoints = function() {
      var series = this, verb = series.getAnimationVerb();
      series.points.forEach(function(point) {
        series.drawPoint(point, verb);
      });
    };
    XRangeSeries2.prototype.getAnimationVerb = function() {
      return this.chart.pointCount < (this.options.animationLimit || 250) ? "animate" : "attr";
    };
    XRangeSeries2.prototype.isPointInside = function(point) {
      var shapeArgs = point.shapeArgs, plotX = point.plotX, plotY = point.plotY;
      if (!shapeArgs) {
        return _super.prototype.isPointInside.apply(this, arguments);
      }
      var isInside = typeof plotX !== "undefined" && typeof plotY !== "undefined" && plotY >= 0 && plotY <= this.yAxis.len && (shapeArgs.x || 0) + (shapeArgs.width || 0) >= 0 && plotX <= this.xAxis.len;
      return isInside;
    };
    XRangeSeries2.defaultOptions = merge89(ColumnSeries17.defaultOptions, {
      /**
       * A partial fill for each point, typically used to visualize how much
       * of a task is performed. The partial fill object can be set either on
       * series or point level.
       *
       * @sample {highcharts} highcharts/demo/x-range
       *         X-range with partial fill
       *
       * @product   highcharts highstock gantt
       * @apioption plotOptions.xrange.partialFill
       */
      /**
       * The fill color to be used for partial fills. Defaults to a darker
       * shade of the point color.
       *
       * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
       * @product   highcharts highstock gantt
       * @apioption plotOptions.xrange.partialFill.fill
       */
      /**
       * A partial fill for each point, typically used to visualize how much
       * of a task is performed. See [completed](series.gantt.data.completed).
       *
       * @sample gantt/demo/progress-indicator
       *         Gantt with progress indicator
       *
       * @product   gantt
       * @apioption plotOptions.gantt.partialFill
       */
      /**
       * In an X-range series, this option makes all points of the same Y-axis
       * category the same color.
       */
      colorByPoint: true,
      dataLabels: {
        formatter: function() {
          var point = this.point, amount = point.partialFill;
          if (isObject16(amount)) {
            amount = amount.amount;
          }
          if (isNumber53(amount) && amount > 0) {
            return correctFloat14(amount * 100) + "%";
          }
        },
        inside: true,
        verticalAlign: "middle"
      },
      tooltip: {
        headerFormat: '<span style="font-size: 10px">{point.x} - {point.x2}</span><br/>',
        pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.yCategory}</b><br/>'
      },
      borderRadius: 3,
      pointRange: 0
    });
    return XRangeSeries2;
  }(ColumnSeries17)
);
extend93(XRangeSeries.prototype, {
  type: "xrange",
  parallelArrays: ["x", "x2", "y"],
  requireSorting: false,
  animate: Series15.prototype.animate,
  cropShoulder: 1,
  getExtremesFromAll: true,
  autoIncrement: Globals_default.noop,
  buildKDTree: Globals_default.noop,
  pointClass: XRangePoint_default
});
SeriesRegistry_default.registerSeriesType("xrange", XRangeSeries);

// node_modules/highcharts/es-modules/Series/Bullet/BulletPoint.js
var __extends60 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BulletPoint = (
  /** @class */
  function(_super) {
    __extends60(BulletPoint2, _super);
    function BulletPoint2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.options = void 0;
      _this.series = void 0;
      return _this;
    }
    BulletPoint2.prototype.destroy = function() {
      if (this.targetGraphic) {
        this.targetGraphic = this.targetGraphic.destroy();
      }
      _super.prototype.destroy.apply(this, arguments);
      return;
    };
    return BulletPoint2;
  }(ColumnSeries_default.prototype.pointClass)
);
var BulletPoint_default = BulletPoint;

// node_modules/highcharts/es-modules/Series/Bullet/BulletSeries.js
var __extends61 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColumnSeries18 = SeriesRegistry_default.seriesTypes.column;
var extend94 = Utilities_default.extend;
var isNumber54 = Utilities_default.isNumber;
var merge90 = Utilities_default.merge;
var pick102 = Utilities_default.pick;
var relativeLength11 = Utilities_default.relativeLength;
var BulletSeries = (
  /** @class */
  function(_super) {
    __extends61(BulletSeries2, _super);
    function BulletSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.data = void 0;
      _this.options = void 0;
      _this.points = void 0;
      _this.targetData = void 0;
      return _this;
    }
    BulletSeries2.prototype.drawPoints = function() {
      var series = this, chart = series.chart, options = series.options, animationLimit = options.animationLimit || 250;
      _super.prototype.drawPoints.apply(this, arguments);
      series.points.forEach(function(point) {
        var pointOptions = point.options, targetVal = point.target, pointVal = point.y;
        var targetShapeArgs, targetGraphic = point.targetGraphic, width, height, targetOptions, y;
        if (isNumber54(targetVal) && targetVal !== null) {
          targetOptions = merge90(options.targetOptions, pointOptions.targetOptions);
          height = targetOptions.height;
          var shapeArgs = point.shapeArgs;
          if (point.dlBox && shapeArgs && !isNumber54(shapeArgs.width)) {
            shapeArgs = point.dlBox;
          }
          width = relativeLength11(targetOptions.width, shapeArgs.width);
          y = series.yAxis.translate(targetVal, false, true, false, true) - targetOptions.height / 2 - 0.5;
          targetShapeArgs = series.crispCol.apply({
            // Use fake series object to set borderWidth of target
            chart,
            borderWidth: targetOptions.borderWidth,
            options: {
              crisp: options.crisp
            }
          }, [
            shapeArgs.x + shapeArgs.width / 2 - width / 2,
            y,
            width,
            height
          ]);
          if (targetGraphic) {
            targetGraphic[chart.pointCount < animationLimit ? "animate" : "attr"](targetShapeArgs);
            if (isNumber54(pointVal) && pointVal !== null) {
              targetGraphic.element.point = point;
            } else {
              targetGraphic.element.point = void 0;
            }
          } else {
            point.targetGraphic = targetGraphic = chart.renderer.rect().attr(targetShapeArgs).add(series.group);
          }
          if (!chart.styledMode) {
            targetGraphic.attr({
              fill: pick102(targetOptions.color, pointOptions.color, series.zones.length && (point.getZone.call({
                series,
                x: point.x,
                y: targetVal,
                options: {}
              }).color || series.color) || void 0, point.color, series.color),
              stroke: pick102(targetOptions.borderColor, point.borderColor, series.options.borderColor),
              "stroke-width": targetOptions.borderWidth,
              r: targetOptions.borderRadius
            });
          }
          if (isNumber54(pointVal) && pointVal !== null) {
            targetGraphic.element.point = point;
          }
          targetGraphic.addClass(point.getClassName() + " highcharts-bullet-target", true);
        } else if (targetGraphic) {
          point.targetGraphic = targetGraphic.destroy();
        }
      });
    };
    BulletSeries2.prototype.getExtremes = function(yData) {
      var dataExtremes = _super.prototype.getExtremes.call(this, yData), series = this, targetData = series.targetData;
      var yMax, yMin;
      if (targetData && targetData.length) {
        var targetExtremes = _super.prototype.getExtremes.call(this, targetData);
        if (isNumber54(targetExtremes.dataMin)) {
          dataExtremes.dataMin = Math.min(pick102(dataExtremes.dataMin, Infinity), targetExtremes.dataMin);
        }
        if (isNumber54(targetExtremes.dataMax)) {
          dataExtremes.dataMax = Math.max(pick102(dataExtremes.dataMax, -Infinity), targetExtremes.dataMax);
        }
      }
      return dataExtremes;
    };
    BulletSeries2.defaultOptions = merge90(ColumnSeries18.defaultOptions, {
      /**
       * All options related with look and positiong of targets.
       *
       * @since 6.0.0
       */
      targetOptions: {
        /**
         * The width of the rectangle representing the target. Could be set
         * as a pixel value or as a percentage of a column width.
         *
         * @type  {number|string}
         * @since 6.0.0
         */
        width: "140%",
        /**
         * The height of the rectangle representing the target.
         *
         * @since 6.0.0
         */
        height: 3,
        /**
         * The border color of the rectangle representing the target. When
         * not set, the  point's border color is used.
         *
         * In styled mode, use class `highcharts-bullet-target` instead.
         *
         * @type      {Highcharts.ColorString}
         * @since     6.0.0
         * @product   highcharts
         * @apioption plotOptions.bullet.targetOptions.borderColor
         */
        /**
         * The color of the rectangle representing the target. When not set,
         * point's color (if set in point's options -
         * [`color`](#series.bullet.data.color)) or zone of the target value
         * (if [`zones`](#plotOptions.bullet.zones) or
         * [`negativeColor`](#plotOptions.bullet.negativeColor) are set)
         * or the same color as the point has is used.
         *
         * In styled mode, use class `highcharts-bullet-target` instead.
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     6.0.0
         * @product   highcharts
         * @apioption plotOptions.bullet.targetOptions.color
         */
        /**
         * The border width of the rectangle representing the target.
         *
         * In styled mode, use class `highcharts-bullet-target` instead.
         *
         * @since   6.0.0
         */
        borderWidth: 0,
        /**
         * The border radius of the rectangle representing the target.
         */
        borderRadius: 0
      },
      tooltip: {
        pointFormat: '<span style="color:{series.color}"></span> {series.name}: <b>{point.y}</b>. Target: <b>{point.target}</b><br/>'
      }
    });
    return BulletSeries2;
  }(ColumnSeries18)
);
extend94(BulletSeries.prototype, {
  parallelArrays: ["x", "y", "target"],
  pointArrayMap: ["y", "target"]
});
BulletSeries.prototype.pointClass = BulletPoint_default;
SeriesRegistry_default.registerSeriesType("bullet", BulletSeries);

// node_modules/@vaadin/charts/src/helpers.js
function inflateFunctions(config) {
  if (Array.isArray(config)) {
    config.forEach(inflateFunctions);
    return;
  }
  if (
    // Check if param is a primitive/null/undefined value
    !(config instanceof Object) || // Check if param is a plain object (not a HC object)
    config.constructor !== Object
  ) {
    return;
  }
  Object.entries(config).forEach(([attr, targetProperty]) => {
    if (attr.startsWith("_fn_") && (typeof targetProperty === "string" || targetProperty instanceof String)) {
      try {
        config[attr.substr(4)] = eval(`(${targetProperty})`);
      } catch (e) {
        config[attr.substr(4)] = eval(`(function(){${targetProperty}})`);
      }
      delete config[attr];
    } else if (targetProperty instanceof Object) {
      inflateFunctions(targetProperty);
    }
  });
}

// node_modules/@vaadin/charts/src/vaadin-chart-series.js
var ChartSeries = class extends PolymerElement {
  static get is() {
    return "vaadin-chart-series";
  }
  static get properties() {
    return {
      /**
       * An array of data used by the series.
       * Format depends on the chart type and can be:
       *   - An array of numerical values `[y0, y1, y2, y3,...]`
       *   - An array of arrays with 2 values (`x`, `y`) `[ [x0, y0], [x1, y1], [x2, y2], ... ]`
       *   - An array of objects, each one describing one point `[ {x: x0, y: y0, name: 'Point0', color: '#FF0000'}, {...}, ...]`
       *
       *  See more in [API Site](https://api.highcharts.com/highcharts/series)
       *
       * Note that you should always use [Polymer API](https://www.polymer-project.org/2.0/docs/devguide/model-data#array-mutation)
       * to mutate the values array in order to make the component aware of the
       * change and be able to synchronize it.
       * @type {ChartSeriesValues}
       */
      values: {
        type: Array,
        value: () => []
      },
      /**
       * Value-axis minimum-value.
       * Sets the value to a series bound by 'unit' property.
       * Otherwise sets the value to the first series.
       * Undefined by default (determined from data).
       * @attr {number} value-min
       */
      valueMin: {
        type: Number,
        reflectToAttribute: true
      },
      /**
       * Value-axis maximum-value.
       * See the 'valueMin'
       * @attr {number} value-max
       */
      valueMax: {
        type: Number,
        reflectToAttribute: true
      },
      /**
       * A string with the type of the series.
       * Defaults to `'line'` in case no type is set for the chart.
       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type on `<vaadin-chart>`.
       */
      type: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * The name of the series as shown in the legend, tooltip etc.
       * @type {string}
       */
      title: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Shows/hides data-point markers for line-like series.
       * Acceptable input are:
       *  - `shown`: markers are always visible
       *  - `hidden`: markers are always hidden
       *  - `auto`: markers are visible for widespread data and hidden, when data is dense *(default)*
       * @type {ChartSeriesMarkers | undefined}
       */
      markers: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Used to connect the series to an axis; if multiple series have the same `unit`, they will share axis.
       * Displayed as a title for the axis.
       * If no unit is defined, then series will be connected to the first axis.
       */
      unit: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Used to group series in a different stacks.
       * "stacking" property should be specified either for each series or in plotOptions.
       * It is recommended to place series in a single stack, when they belong to the same yAxis.
       * @type {number | string}
       */
      stack: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * The height of the neck, the lower part of the funnel.
       * A number defines pixel width, a percentage string defines a percentage of the plot area height. Defaults to 30%.
       * Note that this property only applies for "funnel" charts.
       * @attr {number | string} neck-position
       * @type {number | string}
       */
      neckPosition: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * The width of the neck, the lower part of the funnel.
       * A number defines pixel width, a percentage string defines a percentage of the plot area width. Defaults to 30%.
       * Note that this property only applies for "funnel" charts.
       * @attr {number | string} neck-width
       * @type {number | string}
       */
      neckWidth: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Object with the configured options defined and used to create a series.
       * @type {!ChartSeriesOptions}
       * @readonly
       */
      options: {
        type: Object
      },
      /**
       * Represents additional JSON configuration.
       * @type {SeriesOptionsType | undefined}
       */
      additionalOptions: {
        type: Object,
        reflectToAttribute: true
      },
      /**
       * @type {!Series | undefined}
       * @protected
       */
      _series: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "__additionalOptionsObserver(additionalOptions.*, _series)",
      "__markersObserver(markers, _series)",
      "__neckPositionObserver(neckPosition, _series)",
      "__neckWidthObserver(neckWidth, _series)",
      "__stackObserver(stack, _series)",
      "__titleObserver(title, _series)",
      "__typeObserver(type, _series)",
      "__unitObserver(unit, valueMin, valueMax, _series)",
      "__valueMinObserver(valueMin, _series)",
      "__valueMaxObserver(valueMax, _series)",
      "__valuesObserver(values.splices, _series)"
    ];
  }
  get options() {
    const options = deepMerge({}, this.additionalOptions);
    if (this.type) {
      options.type = this.type;
    }
    if (this.title) {
      options.name = this.title;
    }
    if (this.values) {
      options.data = this.values;
    }
    if (this.markers) {
      if (!this.__isMarkersValid()) {
        this.markers = "auto";
      }
      options.marker = this.__markersConfiguration;
    }
    if (this.unit) {
      options.yAxis = this.unit;
    }
    if (this.stack) {
      options.stack = this.stack;
    }
    if (isFinite(this.valueMin)) {
      options.yAxisValueMin = this.valueMin;
    }
    if (isFinite(this.valueMax)) {
      options.yAxisValueMax = this.valueMax;
    }
    if (this.neckWidth) {
      options.neckWidth = this.neckWidth;
    }
    if (this.neckPosition) {
      options.neckHeight = this.neckPosition;
    }
    return options;
  }
  /** @private */
  get __markersConfiguration() {
    const config2 = {};
    switch (this.markers) {
      case "shown":
        config2.enabled = true;
        break;
      case "hidden":
        config2.enabled = false;
        break;
      case "auto":
      default:
        config2.enabled = null;
        break;
    }
    return config2;
  }
  /**
   * Method to attach a series object of type `Highcharts.Series`.
   * @param {!Series} series Object of type `Highcharts.Series`
   */
  setSeries(series) {
    this._series = series;
  }
  /** @private */
  __valuesObserver(splices, series) {
    if (series) {
      series.setData(this.values);
    }
  }
  /** @private */
  __additionalOptionsObserver(additionalOptions, series) {
    if (series && additionalOptions.base) {
      series.update(additionalOptions.base);
    }
  }
  /** @private */
  __updateAxis(series, value, key) {
    if (!isFinite(value)) {
      this.__showWarn(`value-${key}`, "Numbers or null");
      return;
    }
    if (series && series.yAxis) {
      series.yAxis.update({ [key]: value });
    }
  }
  /** @private */
  __valueMinObserver(valueMin, series) {
    if (valueMin === void 0 || series === void 0) {
      return;
    }
    this.__updateAxis(series, valueMin, "min");
  }
  /** @private */
  __valueMaxObserver(valueMax, series) {
    if (valueMax === void 0 || series === void 0) {
      return;
    }
    this.__updateAxis(series, valueMax, "max");
  }
  /** @private */
  __typeObserver(type, series) {
    if (type && series) {
      series.update({ type });
    }
  }
  /** @private */
  __titleObserver(title, series) {
    if (title === void 0 || series === void 0) {
      return;
    }
    series.update({ name: title });
  }
  /** @private */
  __stackObserver(stack, series) {
    if (stack === void 0 || series === void 0) {
      return;
    }
    series.update({ stack });
  }
  /** @private */
  __neckPositionObserver(neckPosition, series) {
    if (neckPosition === void 0 || series === void 0) {
      return;
    }
    series.update({ neckHeight: neckPosition });
  }
  /** @private */
  __neckWidthObserver(neckWidth, series) {
    if (neckWidth === void 0 || series === void 0) {
      return;
    }
    series.update({ neckWidth });
  }
  /** @private */
  __unitObserver(unit, valueMin, valueMax, series) {
    if (series && unit !== this.__oldUnit) {
      this.__oldUnit = unit;
      const parent = this.parentNode instanceof Chart2 && this.parentNode;
      if (parent && parent instanceof Chart2) {
        if (unit && !parent.__getAxis(unit)) {
          const title = { title: { text: unit } };
          parent.__addAxis({ id: unit, axisGenerated: true, ...title });
        }
        series.update({ yAxis: unit || 0 });
        if (valueMin !== void 0) {
          this.__updateAxis(series, valueMin, "min");
        }
        if (valueMax !== void 0) {
          this.__updateAxis(series, valueMax, "max");
        }
        parent.__removeAxisIfEmpty();
      }
    }
  }
  /** @private */
  __isMarkersValid() {
    if (["shown", "hidden", "auto"].indexOf(this.markers) === -1) {
      this.__showWarn("markers", '"shown", "hidden" or "auto"');
      return false;
    }
    return true;
  }
  /** @private */
  __markersObserver(markers, series) {
    if (markers === void 0 || series === void 0) {
      return;
    }
    if (!this.__isMarkersValid()) {
      this.markers = "auto";
      return;
    }
    series.update({
      marker: this.__markersConfiguration
    });
  }
  /** @private */
  __showWarn(propertyName, acceptedValues) {
    console.warn(`<vaadin-chart-series> Acceptable values for "${propertyName}" are ${acceptedValues}`);
  }
};
defineCustomElement(ChartSeries);

// node_modules/@vaadin/charts/src/vaadin-chart.js
function deepMerge(target, source) {
  const isObject17 = (item) => item && typeof item === "object" && !Array.isArray(item);
  if (isObject17(source) && isObject17(target)) {
    Object.keys(source).forEach((key) => {
      if (isObject17(source[key])) {
        if (!target[key]) {
          Object.assign(target, { [key]: {} });
        }
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    });
  }
  return target;
}
["exportChart", "exportChartLocal", "getSVG"].forEach((methodName) => {
  highstock_src_default.wrap(highstock_src_default.Chart.prototype, methodName, function(proceed, ...args) {
    highstock_src_default.fireEvent(this, "beforeExport");
    const result2 = proceed.apply(this, args);
    highstock_src_default.fireEvent(this, "afterExport");
    return result2;
  });
});
Pointer_default.prototype.onDocumentMouseMove = function(e2) {
  const chart = this.chart;
  const chartPosition = this.chartPosition;
  const pEvt = this.normalize(e2, chartPosition);
  const tooltip = chart.tooltip;
  if (chartPosition && (!tooltip || !tooltip.isStickyOnContact()) && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
    visiblePlotOnly: true
  }) && // Use the first element from the composed path instead of the actual target
  !this.inClass(pEvt.composedPath()[0], "highcharts-tracker")) {
    this.reset();
  }
};
highstock_src_default.setOptions({ lang: { noData: "" } });
var Chart2 = class extends ResizeMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          width: 100%;
          overflow: hidden;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <div id="chart"></div>
      <slot id="slot"></slot>
    `;
  }
  static get is() {
    return "vaadin-chart";
  }
  static get cvdlName() {
    return "vaadin-chart";
  }
  static get properties() {
    return {
      /**
       * Configuration object that exposes the JS Api to configure the chart.
       *
       * Most important methods are:
       * - `addSeries (Object options, [Boolean redraw], [Mixed animation])`
       * - `addAxis (Object options, [Boolean isX], [Boolean redraw], [Mixed animation])`
       * - `setTitle (Object title, object subtitle, Boolean redraw)`
       *
       * Most important properties are:
       * - `configuration.series`: An array of the chart's series. Detailed API for Series object is
       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Series)
       * - `configuration.xAxis`: An array of the chart's x axes. Detailed API for Axis object is
       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
       * - `configuration.yAxis`: An array of the chart's y axes. Detailed API for Axis object is
       *     available in [API Site](http://api.highcharts.com/class-reference/Highcharts.Axis)
       * - `configuration.title`: The chart title.
       *
       * For detailed documentation of available API check the [API site](http://api.highcharts.com/class-reference/classes.list)
       * @type {!Highcharts.Chart | undefined}
       */
      configuration: Object,
      /**
       * If categories are present names are used instead of numbers for the category axis.
       * The format of categories can be an `Array` with a list of categories, such as `['2010', '2011', '2012']`
       * or a mapping `Object`, like `{0:'1',9:'Target (10)', 15: 'Max'}`.
       * @type {ChartCategories | undefined}
       */
      categories: {
        type: Object,
        reflectToAttribute: true
      },
      /**
       * Category-axis maximum value. Defaults to `undefined`.
       * @attr {number} category-max
       */
      categoryMax: {
        type: Number,
        reflectToAttribute: true
      },
      /**
       * Category-axis minimum value. Defaults to `undefined`.
       * @attr {number} category-min
       */
      categoryMin: {
        type: Number,
        reflectToAttribute: true
      },
      /**
       * The position of the category axis. Acceptable values are `left`, `right`, `top` and `bottom`
       * except for bar charts which only accept `left` and `right`.
       * With the default value, charts appear as though they have `category-position="bottom"`
       * except for bar charts that appear as though they have `category-position="left"`.
       *
       * Defaults to `undefined`
       *
       * @attr {left|right|top|bottom} category-position
       * @type {ChartCategoryPosition | undefined}
       */
      categoryPosition: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Specifies whether to hide legend or show.
       * Legend configuration can be set up via additionalOptions property
       * @attr {boolean} no-legend
       */
      noLegend: {
        type: Boolean,
        reflectToAttribute: true
      },
      /**
       * Specifies how series are stacked on top of each other.
       * Possible values are null, "normal" or "percent".
       * If "stack" property is not defined on the vaadin-chart-series elements, then series will be put into
       * the default stack.
       * @attr {normal|percent} stacking
       * @type {ChartStacking | undefined}
       */
      stacking: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Specifies whether the chart is a normal chart or a timeline chart.
       */
      timeline: {
        type: Boolean,
        reflectToAttribute: true
      },
      /**
       * Represents the title of the chart.
       * @type {string}
       */
      title: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Whether or not to show tooltip when hovering data points.
       */
      tooltip: {
        type: Boolean,
        reflectToAttribute: true
      },
      /**
       * Sets the default series type of the chart.
       * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type.
       */
      type: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Represents the subtitle of the chart.
       * @type {string | undefined}
       */
      subtitle: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Specifies whether to show chart in 3 or in 2 dimensions.
       * Some display angles are added by default to the "chart.options3d" (`{alpha: 15, beta: 15, depth: 50}`).
       * 3D display options can be modified via `additionalOptions`.
       * The thickness of a Pie chart can be set on `additionalOptions` through `plotOptions.pie.depth`.
       * 3D is supported by Bar, Column, Pie and Scatter3D charts.
       * More info available at [Highcharts](https://www.highcharts.com/docs/chart-concepts/3d-charts).
       */
      chart3d: {
        type: Boolean,
        reflectToAttribute: true
      },
      /**
       * Specifies the message displayed on a chart without displayable data.
       * @attr {string} empty-text
       * @type {string}
       */
      emptyText: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Represents additional JSON configuration.
       * @type {Options | undefined}
       */
      additionalOptions: {
        type: Object,
        reflectToAttribute: true
      },
      /**
       * When present, cartesian charts like line, spline, area and column are transformed
       * into the polar coordinate system.
       */
      polar: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return [
      "__chart3dObserver(chart3d, configuration)",
      "__emptyTextObserver(emptyText, configuration)",
      "__hideLegend(noLegend, configuration)",
      "__polarObserver(polar, configuration)",
      "__stackingObserver(stacking, configuration)",
      "__tooltipObserver(tooltip, configuration)",
      "__updateCategories(categories, configuration)",
      "__updateCategoryMax(categoryMax, configuration)",
      "__updateCategoryMin(categoryMin, configuration)",
      "__updateCategoryPosition(categoryPosition, configuration)",
      "__updateSubtitle(subtitle, configuration)",
      "__updateTitle(title, configuration)",
      "__updateType(type, configuration)",
      "__updateAdditionalOptions(additionalOptions.*)"
    ];
  }
  /** @private */
  static __callHighchartsFunction(functionName, redrawCharts, ...args) {
    const functionToCall = highstock_src_default[functionName];
    if (functionToCall && typeof functionToCall === "function") {
      args.forEach((arg) => inflateFunctions(arg));
      functionToCall.apply(this.configuration, args);
      if (redrawCharts) {
        highstock_src_default.charts.forEach((c) => c.redraw());
      }
    }
  }
  constructor() {
    super();
    this._baseConfig = {
      annotations: [],
      chart: {
        styledMode: true
      },
      credits: {
        enabled: false
      },
      exporting: {
        enabled: false
      },
      title: {
        text: null
      },
      series: [],
      xAxis: {},
      yAxis: {
        axisGenerated: true
      }
    };
    this._baseChart3d = {
      enabled: true,
      alpha: 15,
      beta: 15,
      depth: 50
    };
  }
  /**
   * @return {!Options}
   */
  get options() {
    const options = { ...this._baseConfig };
    deepMerge(options, this.additionalOptions);
    if (this.type) {
      options.chart.type = this.type;
    }
    if (this.polar) {
      options.chart.polar = true;
    }
    if (this.title) {
      options.title = {
        text: this.title
      };
    }
    if (!options.tooltip) {
      options.tooltip = {};
      if (!this.tooltip) {
        options.tooltip.enabled = false;
      }
    }
    if (this.subtitle) {
      options.subtitle = {
        text: this.subtitle
      };
    }
    if (this.categories) {
      if (Array.isArray(options.xAxis)) {
        options.xAxis[0].categories = this.categories;
      } else {
        options.xAxis.categories = this.categories;
      }
    }
    if (isFinite(this.categoryMin)) {
      if (Array.isArray(options.xAxis)) {
        options.xAxis[0].min = this.categoryMin;
      } else {
        options.xAxis.min = this.categoryMin;
      }
    }
    if (isFinite(this.categoryMax)) {
      if (Array.isArray(options.xAxis)) {
        options.xAxis[0].max = this.categoryMax;
      } else {
        options.xAxis.max = this.categoryMax;
      }
    }
    if (this.noLegend) {
      options.legend = {
        enabled: false
      };
    }
    if (this.emptyText) {
      if (!options.lang) {
        options.lang = {};
      }
      options.lang.noData = this.emptyText;
    }
    if (this.categoryPosition) {
      options.chart.inverted = this.__shouldInvert();
      if (Array.isArray(options.xAxis)) {
        options.xAxis.forEach((e2) => {
          e2.opposite = this.__shouldFlipOpposite();
        });
      } else if (options.xAxis) {
        options.xAxis.opposite = this.__shouldFlipOpposite();
      }
    }
    if (this.stacking) {
      if (!options.plotOptions) {
        options.plotOptions = {};
      }
      if (!options.plotOptions.series) {
        options.plotOptions.series = {};
      }
      options.plotOptions.series.stacking = this.stacking;
    }
    if (this.chart3d) {
      options.chart.options3d = { ...this._baseChart3d, ...options.chart.options3d };
    }
    return options;
  }
  /**
   * Name of the chart events to add to the configuration and its corresponding event for the chart element
   * @private
   */
  get __chartEventNames() {
    return {
      /**
       * Fired when a new series is added.
       * @event chart-add-series
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      addSeries: "chart-add-series",
      /**
       * Fired after a chart is exported.
       * @event chart-after-export
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      afterExport: "chart-after-export",
      /**
       * Fired after a chart is printed.
       * @event chart-after-print
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      afterPrint: "chart-after-print",
      /**
       * Fired before a chart is exported.
       * @event chart-before-export
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      beforeExport: "chart-before-export",
      /**
       * Fired before a chart is printed.
       * @event chart-before-print
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      beforePrint: "chart-before-print",
      /**
       * Fired when clicking on the plot background.
       * @event chart-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      click: "chart-click",
      /**
       * Fired when drilldown point is clicked.
       * @event chart-drilldown
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      drilldown: "chart-drilldown",
      /**
       * Fired when drilling up from a drilldown series.
       * @event chart-drillup
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      drillup: "chart-drillup",
      /**
       * Fired after all the series has been drilled up if chart has multiple drilldown series.
       * @event chart-drillupall
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      drillupall: "chart-drillupall",
      /**
       * Fired when the chart is finished loading.
       * @event chart-load
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      load: "chart-load",
      /**
       * Fired when the chart is redraw. Can be called after a `Chart.configuration.redraw()`
       * or after an axis, series or point is modified with the `redraw` option set to `true`.
       * @event chart-redraw
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      redraw: "chart-redraw",
      /**
       * Fired when an area of the chart has been selected.
       * @event chart-selection
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} chart Chart object where the event was sent from
       */
      selection: "chart-selection"
    };
  }
  /**
   * Name of the series events to add to the configuration and its corresponding event for the chart element
   * @private
   */
  get __seriesEventNames() {
    return {
      /**
       * Fired when the series has finished its initial animation.
       * @event series-after-animate
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      afterAnimate: "series-after-animate",
      /**
       * Fired when the checkbox next to the series' name in the legend is clicked.
       * @event series-checkbox-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      checkboxClick: "series-checkbox-click",
      /**
       * Fired when the series is clicked.
       * @event series-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      click: "series-click",
      /**
       * Fired when the series is hidden after chart generation time.
       * @event series-hide
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      hide: "series-hide",
      /**
       * Fired when the legend item belonging to the series is clicked.
       * @event series-legend-item-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      legendItemClick: "series-legend-item-click",
      /**
       * Fired when the mouses leave the graph.
       * @event series-mouse-out
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      mouseOut: "series-mouse-out",
      /**
       * Fired when the mouse enters the graph.
       * @event series-mouse-over
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      mouseOver: "series-mouse-over",
      /**
       * Fired when the series is show after chart generation time.
       * @event series-show
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} series Series object where the event was sent from
       */
      show: "series-show"
    };
  }
  /**
   * Name of the point events to add to the configuration and its corresponding event for the chart element
   * @private
   */
  get __pointEventNames() {
    return {
      /**
       * Fired when the point is clicked.
       * @event point-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      click: "point-click",
      /**
       * Fired when the legend item belonging to the point is clicked.
       * @event point-legend-item-click
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      legendItemClick: "point-legend-item-click",
      /**
       * Fired when the mouse leaves the area close to the point.
       * @event point-mouse-out
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      mouseOut: "point-mouse-out",
      /**
       * Fired when the mouse enters the area close to the point.
       * @event point-mouse-over
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      mouseOver: "point-mouse-over",
      /**
       * Fired when the point is removed from the series.
       * @event point-remove
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      remove: "point-remove",
      /**
       * Fired when the point is selected either programmatically or by clicking on the point.
       * @event point-select
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      select: "point-select",
      /**
       * Fired when the point is unselected either programmatically or by clicking on the point
       * @event point-unselect
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      unselect: "point-unselect",
      /**
       * Fired when the point is updated programmatically through `.updateConfiguration()` method.
       * @event point-update
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} point Point object where the event was sent from
       */
      update: "point-update"
    };
  }
  /** @private */
  get __xAxesEventNames() {
    return {
      /**
       * Fired when when the minimum and maximum is set for the x axis.
       * @event xaxes-extremes-set
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} axis Point object where the event was sent from
       */
      afterSetExtremes: "xaxes-extremes-set"
    };
  }
  /** @private */
  get __yAxesEventNames() {
    return {
      /**
       * Fired when when the minimum and maximum is set for the y axis.
       * @event yaxes-extremes-set
       * @param {Object} detail.originalEvent object with details about the event sent
       * @param {Object} axis Point object where the event was sent from
       */
      afterSetExtremes: "yaxes-extremes-set"
    };
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__updateStyles();
    beforeNextRender(this, () => {
      if (this.configuration) {
        this.__reflow();
        return;
      }
      const options = { ...this.options, ...this._jsonConfigurationBuffer };
      this._jsonConfigurationBuffer = null;
      this.__initChart(options);
      this.__addChildObserver();
      this.__checkTurboMode();
    });
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("chart-redraw", this.__onRedraw.bind(this));
  }
  /**
   * Implements resize callback from `ResizeMixin`
   * to reflow when the chart element is resized.
   * @protected
   * @override
   */
  _onResize(contentRect) {
    if (!this.configuration) {
      return;
    }
    const { height, width } = contentRect;
    const { chartHeight, chartWidth } = this.configuration;
    if (height !== chartHeight || width !== chartWidth) {
      this.__reflow();
    }
  }
  /** @private */
  __reflow() {
    if (!this.configuration) {
      return;
    }
    this.configuration.reflow();
  }
  /** @private */
  __addChildObserver() {
    this._childObserver = new FlattenedNodesObserver(this.$.slot, (info) => {
      this.__addSeries(info.addedNodes.filter(this.__filterSeriesNodes));
      this.__removeSeries(info.removedNodes.filter(this.__filterSeriesNodes));
      this.__cleanupAfterSeriesRemoved(info.removedNodes.filter(this.__filterSeriesNodes));
    });
  }
  /** @private */
  __filterSeriesNodes(node) {
    return node.nodeType === Node.ELEMENT_NODE && node instanceof ChartSeries;
  }
  /** @private */
  __addSeries(series) {
    if (this.__isSeriesEmpty(series)) {
      return;
    }
    const seriesNodes = Array.from(this.childNodes).filter(this.__filterSeriesNodes);
    const yAxes = this.configuration.yAxis.reduce((acc, axis, index) => {
      acc[axis.options.id || index] = axis;
      return acc;
    }, {});
    for (let i = 0, len = series.length; i < len; i++) {
      const seriesElement = series[i];
      const { yAxis: unit, yAxisValueMin: valueMin, yAxisValueMax: valueMax } = seriesElement.options;
      const idxOnChildList = seriesNodes.indexOf(seriesElement);
      if (!unit && !this.configuration.yAxis.some((e2) => e2.userOptions.id === void 0)) {
        yAxes[unit] = this.__addAxis({ axisGenerated: true });
      } else if (unit && !yAxes[unit]) {
        yAxes[unit] = this.__addAxis({ id: unit, title: { text: unit }, axisGenerated: true });
      }
      if (isFinite(valueMin)) {
        this.__setYAxisProps(yAxes, unit, { min: valueMin });
      }
      if (isFinite(valueMax)) {
        this.__setYAxisProps(yAxes, unit, { max: valueMax });
      }
      const seriesConfiguration = this.__updateOrAddSeriesInstance(seriesElement.options, idxOnChildList, false);
      seriesElement.setSeries(seriesConfiguration);
    }
    this.__removeAxisIfEmpty();
    this.configuration.redraw();
  }
  /** @private */
  __removeSeries(seriesNodes) {
    if (this.__isSeriesEmpty(seriesNodes)) {
      return;
    }
    seriesNodes.forEach((series) => {
      if (series instanceof ChartSeries) {
        series._series.remove();
      }
    });
  }
  /** @private */
  __setYAxisProps(yAxes, yAxisId, props) {
    if (yAxisId) {
      yAxes[yAxisId].update(props);
    } else {
      this.configuration.yAxis[0].update(props);
    }
  }
  /** @private */
  __isSeriesEmpty(series) {
    return series === null || series.length === 0;
  }
  /** @private */
  __cleanupAfterSeriesRemoved(series) {
    if (this.__isSeriesEmpty(series)) {
      return;
    }
    this.__removeAxisIfEmpty();
    this.__updateNoDataElement(this.configuration);
  }
  /** @private */
  __initChart(options) {
    this.__initEventsListeners(options);
    this.__updateStyledMode(options);
    if (this.timeline) {
      this.configuration = highstock_src_default.stockChart(this.$.chart, options);
    } else {
      this.configuration = highstock_src_default.chart(this.$.chart, options);
    }
  }
  /** @private */
  __updateStyledMode(options) {
    const styledMode = options.chart.styledMode;
    this.$.chart.toggleAttribute("styled-mode", !!styledMode);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._childObserver) {
      this._childObserver.disconnect();
    }
  }
  /**
   * Search for axis with given `id`.
   *
   * @param {string} id contains the id that will be searched
   * @param {boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.
   * @return {Axis}
   * @protected
   */
  __getAxis(id, isXAxis) {
    id = Number.parseInt(id) || id;
    if (this.configuration) {
      return (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).find((axis) => axis.options.id === id);
    }
  }
  /**
   * Add an axis with given options
   *
   * @param {Object} options axis options
   * @param {boolean} isXAxis indicates if axis is X (`true`) or Y (`false`). Defaults to `false`.
   * @return {!Axis}
   * @protected
   */
  __addAxis(options, isXAxis) {
    if (this.configuration) {
      this.__createEventListeners(isXAxis ? this.__xAxesEventNames : this.__yAxesEventNames, options, "events", "axis");
      return this.configuration.addAxis(options, isXAxis);
    }
  }
  /**
   * Iterates over axes (y or x) and removes whenever it doesn't contain any series and was created for unit
   *
   * @param {boolean} isXAxis indicates if it will remove x or y axes. Defaults to `false`.
   * @protected
   */
  __removeAxisIfEmpty(isXAxis) {
    if (this.configuration) {
      (isXAxis ? this.configuration.xAxis : this.configuration.yAxis).forEach((axis) => {
        if (axis.userOptions.axisGenerated && axis.series.length === 0) {
          axis.remove();
        }
      });
    }
  }
  /**
   * Update the chart configuration.
   * This JSON API provides a simple single-argument alternative to the configuration property.
   *
   * Styling properties specified in this configuration will be ignored. To learn about chart styling
   * please see the CSS Styling section above.
   *
   * @param {!Options} jsonConfiguration Object chart configuration. Most important properties are:
   *
   * - annotations `Object[]` custom labels or shapes that can be tied to points, axis coordinates or chart pixel coordinates.
   *    Detailed API for annotations object is available in [API Site](http://api.highcharts.com/highcharts/annotations)
   * - chart `Object` with options regarding the chart area and plot area as well as general chart options.
   *    Detailed API for chart object is available in [API Site](http://api.highcharts.com/highcharts/chart)
   * - credits `Object` with options regarding the chart area and plot area as well as general chart options.
   *    Detailed API for credits object is available in [API Site](http://api.highcharts.com/highcharts/credits)
   * - plotOptions `Object` wrapper for config objects for each series type.
   *    Detailed API for plotOptions object is available in [API Site](http://api.highcharts.com/highcharts/plotOptions)
   * - series `Object[]` the actual series to append to the chart.
   *    Detailed API for series object is available in [API Site](http://api.highcharts.com/highcharts/series)
   * - subtitle `Object` the chart's subtitle.
   *    Detailed API for subtitle object is available in [API Site](http://api.highcharts.com/highcharts/subtitle)
   * - title `Object` the chart's main title.
   *    Detailed API for title object is available in [API Site](http://api.highcharts.com/highcharts/title)
   * - tooltip `Object` Options for the tooltip that appears when the user hovers over a series or point.
   *    Detailed API for tooltip object is available in [API Site](http://api.highcharts.com/highcharts/tooltip)
   * - xAxis `Object[]` The X axis or category axis. Normally this is the horizontal axis.
   *    Detailed API for xAxis object is available in [API Site](http://api.highcharts.com/highcharts/xAxis)
   * - yAxis `Object[]` The Y axis or value axis. Normally this is the vertical axis.
   *    Detailed API for yAxis object is available in [API Site](http://api.highcharts.com/highcharts/yAxis)
   * - zAxis `Object[]` The Z axis or depth axis for 3D plots.
   *    Detailed API for zAxis object is available in [API Site](http://api.highcharts.com/highcharts/zAxis)
   *
   * @param {boolean=} resetConfiguration Optional boolean that should be set to true if no other chart configuration was set before or
   *    if existing configuration should be discarded.
   */
  updateConfiguration(jsonConfiguration, resetConfiguration) {
    if (resetConfiguration || !this._jsonConfigurationBuffer) {
      this._jsonConfigurationBuffer = {};
    }
    const configCopy = deepMerge({}, jsonConfiguration);
    inflateFunctions(configCopy);
    this._jsonConfigurationBuffer = this.__makeConfigurationBuffer(this._jsonConfigurationBuffer, configCopy);
    beforeNextRender(this, () => {
      if (!this.configuration || !this._jsonConfigurationBuffer) {
        return;
      }
      if (resetConfiguration) {
        const initialOptions = { ...this.options, ...this._jsonConfigurationBuffer };
        this.__initChart(initialOptions);
        this._jsonConfigurationBuffer = null;
        return;
      }
      this.configuration.update(this._jsonConfigurationBuffer, false);
      if (this._jsonConfigurationBuffer.credits) {
        this.__updateOrAddCredits(this._jsonConfigurationBuffer.credits);
      }
      if (this._jsonConfigurationBuffer.xAxis) {
        this.__updateOrAddAxes(this._jsonConfigurationBuffer.xAxis, true, false);
      }
      if (this._jsonConfigurationBuffer.yAxis) {
        this.__updateOrAddAxes(this._jsonConfigurationBuffer.yAxis, false, false);
      }
      if (this._jsonConfigurationBuffer.series) {
        this.__updateOrAddSeries(this._jsonConfigurationBuffer.series, false);
      }
      this._jsonConfigurationBuffer = null;
      this.configuration.redraw();
    });
  }
  /** @private */
  __makeConfigurationBuffer(target, source) {
    const _source = highstock_src_default.merge(source);
    const _target = highstock_src_default.merge(target);
    this.__mergeConfigurationArray(_target, _source, "series");
    this.__mergeConfigurationArray(_target, _source, "xAxis");
    this.__mergeConfigurationArray(_target, _source, "yAxis");
    return highstock_src_default.merge(_target, _source);
  }
  /** @private */
  __mergeConfigurationArray(target, configuration, entry) {
    if (!configuration || !configuration[entry] || !Array.isArray(configuration[entry])) {
      return;
    }
    if (!target[entry]) {
      target[entry] = Array.from(configuration[entry]);
      return;
    }
    const maxLength = Math.max(target[entry].length, configuration[entry].length);
    for (let i = 0; i < maxLength; i++) {
      target[entry][i] = highstock_src_default.merge(target[entry][i], configuration[entry][i]);
    }
    delete configuration[entry];
  }
  /** @private */
  __initEventsListeners(configuration) {
    this.__initChartEventsListeners(configuration);
    this.__initSeriesEventsListeners(configuration);
    this.__initPointsEventsListeners(configuration);
    this.__initAxisEventsListeners(configuration, true);
    this.__initAxisEventsListeners(configuration, false);
  }
  /** @private */
  __initChartEventsListeners(configuration) {
    this.__createEventListeners(this.__chartEventNames, configuration, "chart.events", "chart");
  }
  /** @private */
  __initSeriesEventsListeners(configuration) {
    this.__createEventListeners(this.__seriesEventNames, configuration, "plotOptions.series.events", "series");
  }
  /** @private */
  __initPointsEventsListeners(configuration) {
    this.__createEventListeners(this.__pointEventNames, configuration, "plotOptions.series.point.events", "point");
  }
  /** @private */
  __initAxisEventsListeners(configuration, isXAxis) {
    let eventNames, axes;
    if (isXAxis) {
      eventNames = this.__xAxesEventNames;
      axes = configuration.xAxis;
    } else {
      eventNames = this.__yAxesEventNames;
      axes = configuration.yAxis;
    }
    if (Array.isArray(axes)) {
      axes.forEach((axis) => this.__createEventListeners(eventNames, axis, "events", "axis"));
    } else {
      this.__createEventListeners(eventNames, axes, "events", "axis");
    }
  }
  /** @private */
  __createEventListeners(eventList, configuration, pathToAdd, eventType) {
    const eventObject = this.__ensureObjectPath(configuration, pathToAdd);
    for (let keys2 = Object.keys(eventList), i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      if (!eventObject[key]) {
        eventObject[key] = (event) => {
          const customEvent = {
            bubbles: false,
            composed: true,
            detail: {
              originalEvent: event,
              [eventType]: event.target
            }
          };
          if (event.type === "afterSetExtremes") {
            if (event.min == null || event.max == null) {
              return;
            }
          }
          if (event.type === "selection") {
            if (event.xAxis && event.xAxis[0]) {
              customEvent.detail.xAxisMin = event.xAxis[0].min;
              customEvent.detail.xAxisMax = event.xAxis[0].max;
            }
            if (event.yAxis && event.yAxis[0]) {
              customEvent.detail.yAxisMin = event.yAxis[0].min;
              customEvent.detail.yAxisMax = event.yAxis[0].max;
            }
          }
          if (event.type === "click") {
            if (event.xAxis && event.xAxis[0]) {
              customEvent.detail.xValue = event.xAxis[0].value;
            }
            if (event.yAxis && event.yAxis[0]) {
              customEvent.detail.yValue = event.yAxis[0].value;
            }
          }
          if (["beforePrint", "beforeExport"].indexOf(event.type) >= 0) {
            if (!this.tempBodyStyle) {
              let effectiveCss = "";
              [...this.shadowRoot.querySelectorAll("style")].forEach((style) => {
                effectiveCss += style.textContent;
              });
              effectiveCss = effectiveCss.replace(/:host\(.+?\)/gu, (match) => {
                const selector = match.substr(6, match.length - 7);
                return this.matches(selector) ? "" : match;
              });
              effectiveCss = `${effectiveCss}body {    -moz-transform: scale(0.9, 0.9);    zoom: 0.9;    zoom: 90%;}`;
              this.tempBodyStyle = document.createElement("style");
              this.tempBodyStyle.textContent = effectiveCss;
              document.body.appendChild(this.tempBodyStyle);
              if (this.options.chart.styledMode) {
                document.body.setAttribute("styled-mode", "");
              }
            }
          }
          if (["afterPrint", "afterExport"].indexOf(event.type) >= 0) {
            if (this.tempBodyStyle) {
              document.body.removeChild(this.tempBodyStyle);
              delete this.tempBodyStyle;
              if (this.options.chart.styledMode) {
                document.body.removeAttribute("styled-mode");
              }
            }
          }
          this.dispatchEvent(new CustomEvent(eventList[key], customEvent));
          if (event.type === "legendItemClick" && this._visibilityTogglingDisabled) {
            return false;
          }
        };
      }
    }
  }
  /** @private */
  __ensureObjectPath(object, path) {
    if (typeof path !== "string") {
      return;
    }
    path = path.split(".");
    return path.reduce((obj, key) => {
      if (!obj[key]) {
        obj[key] = {};
      }
      return obj[key];
    }, object);
  }
  /** @private */
  __updateOrAddCredits(credits) {
    if (this.configuration.credits) {
      this.configuration.credits.update(credits);
    } else {
      this.configuration.addCredits(credits);
    }
  }
  /** @private */
  __updateOrAddAxes(axes, isX, redraw) {
    if (!Array.isArray(axes)) {
      axes = [axes];
    }
    const confAxes = isX ? this.configuration.xAxis : this.configuration.yAxis;
    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];
      if (confAxes[i]) {
        confAxes[i].update(axis, redraw);
      } else {
        this.configuration.addAxis(axis, isX, redraw);
      }
    }
  }
  /** @private */
  __updateOrAddSeries(series, redraw) {
    if (!Array.isArray(series)) {
      throw new Error("The type of jsonConfiguration.series should be Object[]");
    }
    for (let i = 0; i < series.length; i++) {
      const currentSeries = series[i];
      this.__updateOrAddSeriesInstance(currentSeries, i, redraw);
    }
  }
  /** @private */
  __updateOrAddSeriesInstance(seriesOptions, position, redraw) {
    if (this.configuration.series[position]) {
      this.configuration.series[position].update(seriesOptions, redraw);
    } else {
      this.configuration.addSeries(seriesOptions, redraw);
    }
    return this.configuration.series[position];
  }
  /** @private */
  __updateCategories(categories, config2) {
    if (categories === void 0 || !config2) {
      return;
    }
    this.__updateOrAddAxes([{ categories }], true);
  }
  /** @private */
  __updateCategoryMax(max, config2) {
    if (max === void 0 || !config2) {
      return;
    }
    if (!isFinite(max)) {
      console.warn('<vaadin-chart> Acceptable value for "category-max" are Numbers or null');
      return;
    }
    this.__updateOrAddAxes([{ max }], true);
  }
  /** @private */
  __updateCategoryMin(min, config2) {
    if (min === void 0 || !config2) {
      return;
    }
    if (!isFinite(min)) {
      console.warn('<vaadin-chart> Acceptable value for "category-min" are Numbers or null');
      return;
    }
    this.__updateOrAddAxes([{ min }], true);
  }
  /** @private */
  __shouldInvert() {
    if (this.type === "bar" && ["top", "bottom"].indexOf(this.categoryPosition) >= 0) {
      console.warn(`<vaadin-chart> Acceptable "category-position" values for bar charts are
          "left" and "right". For "top" and "bottom" positions please consider using a column chart.`);
      return;
    }
    const inverted = ["left", "right"];
    return inverted.indexOf(this.categoryPosition) >= 0;
  }
  /** @private */
  __shouldFlipOpposite() {
    const opposite = ["top", "right"];
    const oppositeBar = ["right"];
    return (this.type === "bar" ? oppositeBar : opposite).indexOf(this.categoryPosition) >= 0;
  }
  /** @private */
  __updateCategoryPosition(categoryPosition, config2) {
    if (categoryPosition === void 0 || !config2) {
      return;
    }
    const validPositions = ["left", "right", "top", "bottom"];
    if (validPositions.indexOf(categoryPosition) < 0) {
      console.warn(`<vaadin-chart> Acceptable "category-position" values are ${validPositions}`);
      return;
    }
    config2.update({
      chart: {
        inverted: this.__shouldInvert()
      }
    });
    config2.xAxis.forEach(
      (e2) => e2.update({
        opposite: this.__shouldFlipOpposite()
      })
    );
  }
  /** @private */
  __hideLegend(noLegend, config2) {
    if (noLegend === void 0 || !config2) {
      return;
    }
    if (config2.legend) {
      config2.legend.update({ enabled: !noLegend });
    } else {
      config2.legend = { enabled: !noLegend };
    }
  }
  /** @private */
  __updateTitle(title, config2) {
    if (title === void 0 || !config2) {
      return;
    }
    if (title && title.length > 0) {
      config2.title.update({ text: title });
    }
  }
  /** @private */
  __tooltipObserver(tooltip, config2) {
    if (tooltip === void 0 || !config2) {
      return;
    }
    config2.tooltip.update({ enabled: tooltip });
  }
  /** @private */
  __updateType(type, config2) {
    if (type === void 0 || !config2) {
      return;
    }
    if (type && type.length > 0) {
      config2.update({
        chart: { type }
      });
    }
  }
  /** @private */
  __updateSubtitle(subtitle, config2) {
    if (subtitle === void 0 || !config2) {
      return;
    }
    if (subtitle && subtitle.length > 0) {
      if (!config2.subtitle) {
        config2.setSubtitle({ text: subtitle });
      } else {
        config2.subtitle.update({ text: subtitle });
      }
    }
  }
  /** @private */
  __updateAdditionalOptions(options) {
    if (this.configuration && options.base) {
      this.updateConfiguration(options.base);
    }
  }
  /** @private */
  __isStackingValid() {
    if (["normal", "percent", null].indexOf(this.stacking) === -1) {
      this.__showWarn("stacking", '"normal", "percent" or null');
      return false;
    }
    return true;
  }
  /** @private */
  __stackingObserver(stacking, config2) {
    if (stacking === void 0 || !config2) {
      return;
    }
    if (!this.__isStackingValid()) {
      this.stacking = null;
      return;
    }
    config2.update({
      plotOptions: {
        series: { stacking }
      }
    });
  }
  /** @private */
  __chart3dObserver(chart3d, config2) {
    if (chart3d === void 0 || !config2) {
      return;
    }
    if (chart3d) {
      config2.update({
        chart: {
          options3d: {
            ...this._baseChart3d,
            ...this.additionalOptions && this.additionalOptions.chart && this.additionalOptions.chart.options3d,
            enabled: true
          }
        }
      });
    } else {
      config2.update({
        chart: {
          options3d: {
            enabled: false
          }
        }
      });
    }
  }
  /** @private */
  __polarObserver(polar, config2) {
    if (polar === void 0 || !config2) {
      return;
    }
    config2.update({
      chart: { polar }
    });
  }
  /** @private */
  __emptyTextObserver(emptyText, config2) {
    if (emptyText === void 0 || !config2) {
      return;
    }
    config2.update({
      lang: {
        noData: emptyText
      }
    });
    this.__updateNoDataElement(config2);
  }
  /**
   * Force the no data text element to become visible if the chart has no data.
   * This is necessary in cases where Highcharts does not update the element
   * automatically, for example when setting the language config
   * @private
   */
  __updateNoDataElement(config2) {
    const isEmpty = config2.series.every((e2) => e2.data.length === 0);
    if (isEmpty) {
      config2.hideNoData();
      config2.showNoData(this.emptyText);
    }
  }
  /** @private */
  __callChartFunction(functionName, ...args) {
    if (this.configuration) {
      const functionToCall = this.configuration[functionName];
      if (functionToCall && typeof functionToCall === "function") {
        args.forEach((arg) => inflateFunctions(arg));
        functionToCall.apply(this.configuration, args);
      }
    }
  }
  /** @private */
  __callSeriesFunction(functionName, seriesIndex, ...args) {
    if (this.configuration && this.configuration.series[seriesIndex]) {
      const series = this.configuration.series[seriesIndex];
      const functionToCall = series[functionName];
      if (functionToCall && typeof functionToCall === "function") {
        args.forEach((arg) => inflateFunctions(arg));
        functionToCall.apply(series, args);
      }
    }
  }
  /** @private */
  __callAxisFunction(functionName, axisCategory, axisIndex, ...args) {
    if (this.configuration) {
      let axes;
      switch (axisCategory) {
        case 0:
          axes = this.configuration.xAxis;
          break;
        case 1:
          axes = this.configuration.yAxis;
          break;
        case 2:
          axes = this.configuration.zAxis;
          break;
        case 3:
          axes = this.configuration.colorAxis;
          break;
        default:
          break;
      }
      if (axes && axes[axisIndex]) {
        const axis = axes[axisIndex];
        const functionToCall = axis[functionName];
        if (functionToCall && typeof functionToCall === "function") {
          args.forEach((arg) => inflateFunctions(arg));
          functionToCall.apply(axis, args);
        }
      }
    }
  }
  /** @private */
  __callPointFunction(functionName, seriesIndex, pointIndex, ...args) {
    if (this.configuration && this.configuration.series[seriesIndex] && this.configuration.series[seriesIndex].data[pointIndex]) {
      const point = this.configuration.series[seriesIndex].data[pointIndex];
      const functionToCall = point[functionName];
      if (functionToCall && typeof functionToCall === "function") {
        functionToCall.apply(point, args);
      }
    }
  }
  /**
   * Updates chart container and current chart style property depending on flex status
   * @private
   */
  __updateStyles() {
    const isFlex = getComputedStyle(this).flex !== "0 1 auto";
    if (isFlex) {
      this.$.chart.setAttribute("style", "flex: 1; ");
      let style = "";
      if (this.hasAttribute("style")) {
        style = this.getAttribute("style");
        if (!style.endsWith(";")) {
          style += ";";
        }
      }
      style += "display: flex;";
      this.setAttribute("style", style);
    } else {
      this.$.chart.setAttribute("style", "height:100%; width:100%;");
    }
  }
  /** @private */
  __showWarn(propertyName, acceptedValues) {
    console.warn(`<vaadin-chart> Acceptable values for "${propertyName}" are ${acceptedValues}`);
  }
  /** @private */
  __onRedraw() {
    this.__checkTurboMode();
  }
  /** @private */
  __checkTurboMode() {
    const isDevelopmentMode = !!window.Vaadin.developmentMode;
    if (!this.configuration || !isDevelopmentMode || this.__turboModeWarningAlreadyLogged) {
      return;
    }
    const exceedsTurboThreshold = this.configuration.series.some((series) => {
      const threshold = series.options && series.options.turboThreshold || 0;
      const dataLength = series.data.length;
      return threshold > 0 && dataLength > threshold;
    });
    if (exceedsTurboThreshold) {
      this.__turboModeWarningAlreadyLogged = true;
      console.warn(
        "<vaadin-chart> Turbo mode has been enabled for one or more series, because the number of data items exceeds the configured threshold. Turbo mode improves the performance of charts with lots of data, but is not compatible with every type of series. Please consult the documentation on compatibility, or how to disable turbo mode."
      );
    }
  }
};
defineCustomElement(Chart2);
/*! Bundled license information:

@vaadin/charts/theme/vaadin-chart-base-theme.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)
  (**
   * @license Highcharts
   *
   * (c) 2009-2016 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/highcharts.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/highcharts
   *
   * (c) 2009-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/broken-axis.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/broken-axis
   * @requires highcharts
   *
   * (c) 2009-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/stock.src.js:
  (**
   * @license Highstock JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/stock
   * @requires highcharts
   *
   * Highcharts Stock as a plugin for Highcharts
   *
   * (c) 2010-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/highstock.src.js:
  (**
   * @license Highstock JS v9.2.2 (2021-08-24)
   * @module highcharts/highstock
   *
   * (c) 2009-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/accessibility.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/accessibility
   * @requires highcharts
   *
   * Accessibility module
   *
   * (c) 2010-2021 Highsoft AS
   * Author: Oystein Moseng
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/annotations.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/annotations
   * @requires highcharts
   *
   * Annotations module
   *
   * (c) 2009-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/highcharts-more.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/highcharts-more
   * @requires highcharts
   *
   * (c) 2009-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/highcharts-3d.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/highcharts-3d
   * @requires highcharts
   *
   * 3D features for Highcharts JS
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/data.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/data
   * @requires highcharts
   *
   * Data module
   *
   * (c) 2012-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/drilldown.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/drilldown
   * @requires highcharts
   *
   * Highcharts Drilldown module
   *
   * Author: Torstein Honsi
   * License: www.highcharts.com/license
   *
   *)

highcharts/es-modules/masters/modules/exporting.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/exporting
   * @requires highcharts
   *
   * Exporting module
   *
   * (c) 2010-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/funnel.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/funnel
   * @requires highcharts
   *
   * Highcharts funnel module
   *
   * (c) 2010-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/heatmap.src.js:
  (**
   * @license Highmaps JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/heatmap
   * @requires highcharts
   *
   * (c) 2009-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/solid-gauge.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/solid-gauge
   * @requires highcharts
   * @requires highcharts/highcharts-more
   *
   * Solid angular gauge module
   *
   * (c) 2010-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/treemap.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/treemap
   * @requires highcharts
   *
   * (c) 2014-2021 Highsoft AS
   * Authors: Jon Arild Nygard / Oystein Moseng
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/no-data-to-display.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/no-data-to-display
   * @requires highcharts
   *
   * Plugin for displaying a message when there is no data visible in chart.
   *
   * (c) 2010-2021 Highsoft AS
   * Author: Oystein Moseng
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/sankey.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/sankey
   * @requires highcharts
   *
   * Sankey diagram module
   *
   * (c) 2010-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/timeline.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/timeline
   * @requires highcharts
   *
   * Timeline series
   *
   * (c) 2010-2021 Highsoft AS
   * Author: Daniel Studencki
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/organization.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * Organization chart series type
   * @module highcharts/modules/organization
   * @requires highcharts
   * @requires highcharts/modules/sankey
   *
   * (c) 2019-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/xrange.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/xrange
   * @requires highcharts
   *
   * X-range series
   *
   * (c) 2010-2021 Torstein Honsi, Lars A. V. Cabrera
   *
   * License: www.highcharts.com/license
   *)

highcharts/es-modules/masters/modules/bullet.src.js:
  (**
   * @license Highcharts JS v9.2.2 (2021-08-24)
   * @module highcharts/modules/bullet
   * @requires highcharts
   *
   * Bullet graph series type for Highcharts
   *
   * (c) 2010-2021 Kacper Madej
   *
   * License: www.highcharts.com/license
   *)

@vaadin/charts/src/vaadin-chart-series.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)

@vaadin/charts/src/vaadin-chart.js:
  (**
   * @license
   * Copyright (c) 2000 - 2023 Vaadin Ltd.
   *
   * This program is available under Vaadin Commercial License and Service Terms.
   *
   *
   * See https://vaadin.com/commercial-license-and-service-terms for the full
   * license.
   *)
*/
//# sourceMappingURL=@vaadin_charts_theme_lumo_vaadin-chart__js.js.map
