{
  "version": 3,
  "sources": ["../../ol/src/layer/Property.js", "../../ol/src/layer/Base.js", "../../ol/src/render/EventType.js", "../../ol/src/layer/Layer.js", "../../ol/src/renderer/Layer.js", "../../ol/src/render/Event.js", "../../ol/src/renderer/canvas/Layer.js"],
  "sourcesContent": ["/**\n * @module ol/layer/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  OPACITY: 'opacity',\n  VISIBLE: 'visible',\n  EXTENT: 'extent',\n  Z_INDEX: 'zIndex',\n  MAX_RESOLUTION: 'maxResolution',\n  MIN_RESOLUTION: 'minResolution',\n  MAX_ZOOM: 'maxZoom',\n  MIN_ZOOM: 'minZoom',\n  SOURCE: 'source',\n  MAP: 'map',\n};\n", "/**\n * @module ol/layer/Base\n */\nimport BaseObject from '../Object.js';\nimport LayerProperty from './Property.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {assign} from '../obj.js';\nimport {clamp} from '../math.js';\n\n/**\n * A css color, or a function called with a view resolution returning a css color.\n *\n * @typedef {string|function(number):string} BackgroundColor\n * @api\n */\n\n/**\n * @typedef {import(\"../ObjectEventType\").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|\n *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<BaseLayerObjectEventTypes, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in\n * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so\n * is observable, and has get/set accessors.\n *\n * @api\n */\nclass BaseLayer extends BaseObject {\n  /**\n   * @param {Options} options Layer options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {BackgroundColor|false}\n     * @private\n     */\n    this.background_ = options.background;\n\n    /**\n     * @type {Object<string, *>}\n     */\n    const properties = assign({}, options);\n    if (typeof options.properties === 'object') {\n      delete properties.properties;\n      assign(properties, options.properties);\n    }\n\n    properties[LayerProperty.OPACITY] =\n      options.opacity !== undefined ? options.opacity : 1;\n    assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number\n\n    properties[LayerProperty.VISIBLE] =\n      options.visible !== undefined ? options.visible : true;\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\n    properties[LayerProperty.MAX_RESOLUTION] =\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\n    properties[LayerProperty.MIN_RESOLUTION] =\n      options.minResolution !== undefined ? options.minResolution : 0;\n    properties[LayerProperty.MIN_ZOOM] =\n      options.minZoom !== undefined ? options.minZoom : -Infinity;\n    properties[LayerProperty.MAX_ZOOM] =\n      options.maxZoom !== undefined ? options.maxZoom : Infinity;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.className_ =\n      properties.className !== undefined ? properties.className : 'ol-layer';\n    delete properties.className;\n\n    this.setProperties(properties);\n\n    /**\n     * @type {import(\"./Layer.js\").State}\n     * @private\n     */\n    this.state_ = null;\n  }\n\n  /**\n   * Get the background for this layer.\n   * @return {BackgroundColor|false} Layer background.\n   */\n  getBackground() {\n    return this.background_;\n  }\n\n  /**\n   * @return {string} CSS class name.\n   */\n  getClassName() {\n    return this.className_;\n  }\n\n  /**\n   * This method is not meant to be called by layers or layer renderers because the state\n   * is incorrect if the layer is included in a layer group.\n   *\n   * @param {boolean} [opt_managed] Layer is managed.\n   * @return {import(\"./Layer.js\").State} Layer state.\n   */\n  getLayerState(opt_managed) {\n    /** @type {import(\"./Layer.js\").State} */\n    const state =\n      this.state_ ||\n      /** @type {?} */ ({\n        layer: this,\n        managed: opt_managed === undefined ? true : opt_managed,\n      });\n    const zIndex = this.getZIndex();\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\n    state.visible = this.getVisible();\n    state.extent = this.getExtent();\n    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;\n    state.maxResolution = this.getMaxResolution();\n    state.minResolution = Math.max(this.getMinResolution(), 0);\n    state.minZoom = this.getMinZoom();\n    state.maxZoom = this.getMaxZoom();\n    this.state_ = state;\n\n    return state;\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").default>} [opt_array] Array of layers (to be\n   *     modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(opt_array) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").State>} [opt_states] Optional list of layer\n   *     states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(opt_states) {\n    return abstract();\n  }\n\n  /**\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\n   * will be visible regardless of extent.\n   * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\n   * @observable\n   * @api\n   */\n  getExtent() {\n    return /** @type {import(\"../extent.js\").Extent|undefined} */ (\n      this.get(LayerProperty.EXTENT)\n    );\n  }\n\n  /**\n   * Return the maximum resolution of the layer.\n   * @return {number} The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMaxResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum resolution of the layer.\n   * @return {number} The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMinResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum zoom level of the layer.\n   * @return {number} The minimum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));\n  }\n\n  /**\n   * Return the maximum zoom level of the layer.\n   * @return {number} The maximum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));\n  }\n\n  /**\n   * Return the opacity of the layer (between 0 and 1).\n   * @return {number} The opacity of the layer.\n   * @observable\n   * @api\n   */\n  getOpacity() {\n    return /** @type {number} */ (this.get(LayerProperty.OPACITY));\n  }\n\n  /**\n   * @abstract\n   * @return {import(\"../source/State.js\").default} Source state.\n   */\n  getSourceState() {\n    return abstract();\n  }\n\n  /**\n   * Return the visibility of the layer (`true` or `false`).\n   * @return {boolean} The visibility of the layer.\n   * @observable\n   * @api\n   */\n  getVisible() {\n    return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\n  }\n\n  /**\n   * Return the Z-index of the layer, which is used to order layers before\n   * rendering. The default Z-index is 0.\n   * @return {number} The Z-index of the layer.\n   * @observable\n   * @api\n   */\n  getZIndex() {\n    return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));\n  }\n\n  /**\n   * Sets the background color.\n   * @param {BackgroundColor} [opt_background] Background color.\n   */\n  setBackground(opt_background) {\n    this.background_ = opt_background;\n    this.changed();\n  }\n\n  /**\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\n   * will be visible at all extents.\n   * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\n   * @observable\n   * @api\n   */\n  setExtent(extent) {\n    this.set(LayerProperty.EXTENT, extent);\n  }\n\n  /**\n   * Set the maximum resolution at which the layer is visible.\n   * @param {number} maxResolution The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMaxResolution(maxResolution) {\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\n  }\n\n  /**\n   * Set the minimum resolution at which the layer is visible.\n   * @param {number} minResolution The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMinResolution(minResolution) {\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\n  }\n\n  /**\n   * Set the maximum zoom (exclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} maxZoom The maximum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMaxZoom(maxZoom) {\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\n  }\n\n  /**\n   * Set the minimum zoom (inclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} minZoom The minimum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMinZoom(minZoom) {\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\n  }\n\n  /**\n   * Set the opacity of the layer, allowed values range from 0 to 1.\n   * @param {number} opacity The opacity of the layer.\n   * @observable\n   * @api\n   */\n  setOpacity(opacity) {\n    assert(typeof opacity === 'number', 64); // Layer opacity must be a number\n    this.set(LayerProperty.OPACITY, opacity);\n  }\n\n  /**\n   * Set the visibility of the layer (`true` or `false`).\n   * @param {boolean} visible The visibility of the layer.\n   * @observable\n   * @api\n   */\n  setVisible(visible) {\n    this.set(LayerProperty.VISIBLE, visible);\n  }\n\n  /**\n   * Set Z-index of the layer, which is used to order layers before rendering.\n   * The default Z-index is 0.\n   * @param {number} zindex The z-index of the layer.\n   * @observable\n   * @api\n   */\n  setZIndex(zindex) {\n    this.set(LayerProperty.Z_INDEX, zindex);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.state_) {\n      this.state_.layer = null;\n      this.state_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default BaseLayer;\n", "/**\n * @module ol/render/EventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered before a layer is rendered.\n   * @event module:ol/render/Event~RenderEvent#prerender\n   * @api\n   */\n  PRERENDER: 'prerender',\n\n  /**\n   * Triggered after a layer is rendered.\n   * @event module:ol/render/Event~RenderEvent#postrender\n   * @api\n   */\n  POSTRENDER: 'postrender',\n\n  /**\n   * Triggered before layers are composed.  When dispatched by the map, the event object will not have\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\n   * WebGL layers currently dispatch this event.\n   * @event module:ol/render/Event~RenderEvent#precompose\n   * @api\n   */\n  PRECOMPOSE: 'precompose',\n\n  /**\n   * Triggered after layers are composed.  When dispatched by the map, the event object will not have\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\n   * WebGL layers currently dispatch this event.\n   * @event module:ol/render/Event~RenderEvent#postcompose\n   * @api\n   */\n  POSTCOMPOSE: 'postcompose',\n\n  /**\n   * Triggered when rendering is complete, i.e. all sources and tiles have\n   * finished loading for the current viewport, and all tiles are faded in.\n   * The event object will not have a `context` set.\n   * @event module:ol/render/Event~RenderEvent#rendercomplete\n   * @api\n   */\n  RENDERCOMPLETE: 'rendercomplete',\n};\n\n/**\n * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes\n */\n\n/**\n * @typedef {'postrender'|'prerender'} LayerRenderEventTypes\n */\n", "/**\n * @module ol/layer/Layer\n */\nimport BaseLayer from './Base.js';\nimport EventType from '../events/EventType.js';\nimport LayerProperty from './Property.js';\nimport RenderEventType from '../render/EventType.js';\nimport SourceState from '../source/State.js';\nimport {assert} from '../asserts.js';\nimport {assign} from '../obj.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(import(\"../PluggableMap.js\").FrameState):HTMLElement} RenderFunction\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     'change:source', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|'change:source'|\n *     import(\"../render/EventType\").LayerRenderEventTypes, Return>} LayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,\n * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after\n * construction.\n * @property {import(\"../PluggableMap.js\").default|null} [map] Map.\n * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an\n * HTML element. Will overwrite the default rendering for the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./Layer.js\").default} layer Layer.\n * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.\n * @property {import(\"../source/Source.js\").default|undefined} source Source being rendered (only for multi-source layers).\n * @property {boolean} visible Visible.\n * @property {boolean} managed Managed.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {number} zIndex ZIndex.\n * @property {number} maxResolution Maximum resolution.\n * @property {number} minResolution Minimum resolution.\n * @property {number} minZoom Minimum zoom.\n * @property {number} maxZoom Maximum zoom.\n */\n\n/**\n * @classdesc\n * Base class from which all layer types are derived. This should only be instantiated\n * in the case where a custom layer is added to the map with a custom `render` function.\n * Such a function can be specified in the `options` object, and is expected to return an HTML element.\n *\n * A visual representation of raster or vector map data.\n * Layers group together those properties that pertain to how the data is to be\n * displayed, irrespective of the source of that data.\n *\n * Layers are usually added to a map with {@link import(\"../PluggableMap.js\").default#addLayer map.addLayer()}. Components\n * like {@link module:ol/interaction/Draw~Draw} use unmanaged layers\n * internally. These unmanaged layers are associated with the map using\n * {@link module:ol/layer/Layer~Layer#setMap} instead.\n *\n * A generic `change` event is fired when the state of the source changes.\n *\n * Please note that for performance reasons several layers might get rendered to\n * the same HTML element, which will cause {@link import(\"../PluggableMap.js\").default#forEachLayerAtPixel map.forEachLayerAtPixel()} to\n * give false positives. To avoid this, apply different `className` properties to the\n * layers at creation time.\n *\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n *\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @template {import(\"../renderer/Layer.js\").default} [RendererType=import(\"../renderer/Layer.js\").default]\n * @api\n */\nclass Layer extends BaseLayer {\n  /**\n   * @param {Options<SourceType>} options Layer options.\n   */\n  constructor(options) {\n    const baseOptions = assign({}, options);\n    delete baseOptions.source;\n\n    super(baseOptions);\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {LayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapPrecomposeKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapRenderKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceChangeKey_ = null;\n\n    /**\n     * @private\n     * @type {RendererType}\n     */\n    this.renderer_ = null;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.rendered = false;\n\n    // Overwrite default render method with a custom one\n    if (options.render) {\n      this.render = options.render;\n    }\n\n    if (options.map) {\n      this.setMap(options.map);\n    }\n\n    this.addChangeListener(\n      LayerProperty.SOURCE,\n      this.handleSourcePropertyChange_\n    );\n\n    const source = options.source\n      ? /** @type {SourceType} */ (options.source)\n      : null;\n    this.setSource(source);\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").default>} [opt_array] Array of layers (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(opt_array) {\n    const array = opt_array ? opt_array : [];\n    array.push(this);\n    return array;\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").State>} [opt_states] Optional list of layer states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(opt_states) {\n    const states = opt_states ? opt_states : [];\n    states.push(this.getLayerState());\n    return states;\n  }\n\n  /**\n   * Get the layer source.\n   * @return {SourceType|null} The layer source (or `null` if not yet set).\n   * @observable\n   * @api\n   */\n  getSource() {\n    return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;\n  }\n\n  /**\n   * @return {SourceType|null} The source being rendered.\n   */\n  getRenderSource() {\n    return this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/State.js\").default} Source state.\n   */\n  getSourceState() {\n    const source = this.getSource();\n    return !source ? SourceState.UNDEFINED : source.getState();\n  }\n\n  /**\n   * @private\n   */\n  handleSourceChange_() {\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  handleSourcePropertyChange_() {\n    if (this.sourceChangeKey_) {\n      unlistenByKey(this.sourceChangeKey_);\n      this.sourceChangeKey_ = null;\n    }\n    const source = this.getSource();\n    if (source) {\n      this.sourceChangeKey_ = listen(\n        source,\n        EventType.CHANGE,\n        this.handleSourceChange_,\n        this\n      );\n    }\n    this.changed();\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.renderer_) {\n      return new Promise((resolve) => resolve([]));\n    }\n    return this.renderer_.getFeatures(pixel);\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    if (!this.renderer_ || !this.rendered) {\n      return null;\n    }\n    return this.renderer_.getData(pixel);\n  }\n\n  /**\n   * In charge to manage the rendering of the layer. One layer type is\n   * bounded with one layer renderer.\n   * @param {?import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement} The rendered element.\n   */\n  render(frameState, target) {\n    const layerRenderer = this.getRenderer();\n\n    if (layerRenderer.prepareFrame(frameState)) {\n      this.rendered = true;\n      return layerRenderer.renderFrame(frameState, target);\n    }\n  }\n\n  /**\n   * Called when a layer is not visible during a map render.\n   */\n  unrender() {\n    this.rendered = false;\n  }\n\n  /**\n   * For use inside the library only.\n   * @param {import(\"../PluggableMap.js\").default|null} map Map.\n   */\n  setMapInternal(map) {\n    if (!map) {\n      this.unrender();\n    }\n    this.set(LayerProperty.MAP, map);\n  }\n\n  /**\n   * For use inside the library only.\n   * @return {import(\"../PluggableMap.js\").default|null} Map.\n   */\n  getMapInternal() {\n    return this.get(LayerProperty.MAP);\n  }\n\n  /**\n   * Sets the layer to be rendered on top of other layers on a map. The map will\n   * not manage this layer in its layers collection, and the callback in\n   * {@link module:ol/Map~Map#forEachLayerAtPixel} will receive `null` as layer. This\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\n   * use `#setMap(null)`.\n   *\n   * To add the layer to a map and have it managed by the map, use\n   * {@link module:ol/Map~Map#addLayer} instead.\n   * @param {import(\"../PluggableMap.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    if (this.mapPrecomposeKey_) {\n      unlistenByKey(this.mapPrecomposeKey_);\n      this.mapPrecomposeKey_ = null;\n    }\n    if (!map) {\n      this.changed();\n    }\n    if (this.mapRenderKey_) {\n      unlistenByKey(this.mapRenderKey_);\n      this.mapRenderKey_ = null;\n    }\n    if (map) {\n      this.mapPrecomposeKey_ = listen(\n        map,\n        RenderEventType.PRECOMPOSE,\n        function (evt) {\n          const renderEvent =\n            /** @type {import(\"../render/Event.js\").default} */ (evt);\n          const layerStatesArray = renderEvent.frameState.layerStatesArray;\n          const layerState = this.getLayerState(false);\n          // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.\n          assert(\n            !layerStatesArray.some(function (arrayLayerState) {\n              return arrayLayerState.layer === layerState.layer;\n            }),\n            67\n          );\n          layerStatesArray.push(layerState);\n        },\n        this\n      );\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the layer source.\n   * @param {SourceType|null} source The layer source.\n   * @observable\n   * @api\n   */\n  setSource(source) {\n    this.set(LayerProperty.SOURCE, source);\n  }\n\n  /**\n   * Get the renderer for this layer.\n   * @return {RendererType} The layer renderer.\n   */\n  getRenderer() {\n    if (!this.renderer_) {\n      this.renderer_ = this.createRenderer();\n    }\n    return this.renderer_;\n  }\n\n  /**\n   * @return {boolean} The layer has a renderer.\n   */\n  hasRenderer() {\n    return !!this.renderer_;\n  }\n\n  /**\n   * Create a renderer for this layer.\n   * @return {RendererType} A layer renderer.\n   * @protected\n   */\n  createRenderer() {\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.renderer_) {\n      this.renderer_.dispose();\n      delete this.renderer_;\n    }\n\n    this.setSource(null);\n    super.disposeInternal();\n  }\n}\n\n/**\n * Return `true` if the layer is visible and if the provided view state\n * has resolution and zoom levels that are in range of the layer's min/max.\n * @param {State} layerState Layer state.\n * @param {import(\"../View.js\").State} viewState View state.\n * @return {boolean} The layer is visible at the given view state.\n */\nexport function inView(layerState, viewState) {\n  if (!layerState.visible) {\n    return false;\n  }\n  const resolution = viewState.resolution;\n  if (\n    resolution < layerState.minResolution ||\n    resolution >= layerState.maxResolution\n  ) {\n    return false;\n  }\n  const zoom = viewState.zoom;\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\n}\n\nexport default Layer;\n", "/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport SourceState from '../source/State.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       * @this {LayerRenderer}\n       */\n      function (zoom, tileRange) {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }.bind(this)\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n   *    location, null will be returned.  If there is data, but pixel values cannot be\n   *    returned, and empty array will be returned.\n   */\n  getDataAtPixel(pixel, frameState, hitTolerance) {\n    return null;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n", "/**\n * @module ol/render/Event\n */\n\nimport Event from '../events/Event.js';\n\nclass RenderEvent extends Event {\n  /**\n   * @param {import(\"./EventType.js\").default} type Type.\n   * @param {import(\"../transform.js\").Transform} [opt_inversePixelTransform] Transform for\n   *     CSS pixels to rendered pixels.\n   * @param {import(\"../PluggableMap.js\").FrameState} [opt_frameState] Frame state.\n   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [opt_context] Context.\n   */\n  constructor(type, opt_inversePixelTransform, opt_frameState, opt_context) {\n    super(type);\n\n    /**\n     * Transform from CSS pixels (relative to the top-left corner of the map viewport)\n     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.\n     * @type {import(\"../transform.js\").Transform|undefined}\n     * @api\n     */\n    this.inversePixelTransform = opt_inversePixelTransform;\n\n    /**\n     * An object representing the current render frame state.\n     * @type {import(\"../PluggableMap.js\").FrameState|undefined}\n     * @api\n     */\n    this.frameState = opt_frameState;\n\n    /**\n     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,\n     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL\n     * context.\n     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}\n     * @api\n     */\n    this.context = opt_context;\n  }\n}\n\nexport default RenderEvent;\n", "/**\n * @module ol/renderer/canvas/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\nimport {asArray} from '../../color.js';\nimport {\n  containsCoordinate,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../../extent.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {equals} from '../../array.js';\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  const canvas = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  pixelContext = canvas.getContext('2d');\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"../../PluggableMap.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS Transform.\n   * @param {number} opacity Opacity.\n   * @param {string} [opt_backgroundColor] Background color.\n   */\n  useContainer(target, transform, opacity, opt_backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      target.style.opacity === '' &&\n      opacity === 1 &&\n      (!opt_backgroundColor ||\n        (target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(opt_backgroundColor)\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && context.canvas.style.transform === transform) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      if (opt_backgroundColor) {\n        style.backgroundColor = opt_backgroundColor;\n      }\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2\n    );\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n   *    location, null will be returned.  If there is data, but pixel values cannot be\n   *    returned, and empty array will be returned.\n   */\n  getDataAtPixel(pixel, frameState, hitTolerance) {\n    const renderPixel = applyTransform(\n      this.inversePixelTransform,\n      pixel.slice()\n    );\n    const context = this.context;\n\n    const layer = this.getLayer();\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      const renderCoordinate = applyTransform(\n        frameState.pixelToCoordinateTransform,\n        pixel.slice()\n      );\n\n      /** get only data inside of the layer extent */\n      if (!containsCoordinate(layerExtent, renderCoordinate)) {\n        return null;\n      }\n    }\n\n    const x = Math.round(renderPixel[0]);\n    const y = Math.round(renderPixel[1]);\n    let pixelContext = this.pixelContext_;\n    if (!pixelContext) {\n      const pixelCanvas = document.createElement('canvas');\n      pixelCanvas.width = 1;\n      pixelCanvas.height = 1;\n      pixelContext = pixelCanvas.getContext('2d');\n      this.pixelContext_ = pixelContext;\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n    let data;\n    try {\n      pixelContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      if (err.name === 'SecurityError') {\n        // tainted canvas, we assume there is data at the given pixel (although there might not be)\n        this.pixelContext_ = null;\n        return new Uint8Array();\n      }\n      return data;\n    }\n\n    if (data[3] === 0) {\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n"],
  "mappings": "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",
  "names": ["BaseLayer", "EventType_default", "__extends", "Layer", "EventType_default", "__extends", "LayerRenderer", "Layer_default", "__extends", "RenderEvent", "Event_default", "__extends", "CanvasLayerRenderer", "Event_default", "EventType_default", "pixelContext", "Layer_default"]
}
