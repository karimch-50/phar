{
  "version": 3,
  "sources": ["../../ol/src/ViewProperty.js", "../../ol/src/centerconstraint.js", "../../ol/src/resolutionconstraint.js", "../../ol/src/rotationconstraint.js", "../../ol/src/geom/flat/closest.js", "../../ol/src/geom/flat/area.js", "../../ol/src/geom/LinearRing.js", "../../ol/src/geom/flat/contains.js", "../../ol/src/geom/flat/interiorpoint.js", "../../ol/src/geom/flat/segments.js", "../../ol/src/geom/flat/intersectsextent.js", "../../ol/src/geom/flat/reverse.js", "../../ol/src/geom/flat/orient.js", "../../ol/src/geom/Polygon.js", "../../ol/src/View.js"],
  "sourcesContent": ["/**\n * @module ol/ViewProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  CENTER: 'center',\n  RESOLUTION: 'resolution',\n  ROTATION: 'rotation',\n};\n", "/**\n * @module ol/centerconstraint\n */\nimport {clamp} from './math.js';\n\n/**\n * @typedef {function((import(\"./coordinate.js\").Coordinate|undefined), number, import(\"./size.js\").Size, boolean=, Array<number>=): (import(\"./coordinate.js\").Coordinate|undefined)} Type\n */\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.\n * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent\n * (only during interaction and animation).\n * @return {Type} The constraint.\n */\nexport function createExtent(extent, onlyCenter, smooth) {\n  return (\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center Center.\n     * @param {number|undefined} resolution Resolution.\n     * @param {import(\"./size.js\").Size} size Viewport size; unused if `onlyCenter` was specified.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @param {Array<number>} [opt_centerShift] Shift between map center and viewport center.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n     */\n    function (center, resolution, size, opt_isMoving, opt_centerShift) {\n      if (!center) {\n        return undefined;\n      }\n      if (!resolution && !onlyCenter) {\n        return center;\n      }\n      const viewWidth = onlyCenter ? 0 : size[0] * resolution;\n      const viewHeight = onlyCenter ? 0 : size[1] * resolution;\n      const shiftX = opt_centerShift ? opt_centerShift[0] : 0;\n      const shiftY = opt_centerShift ? opt_centerShift[1] : 0;\n      let minX = extent[0] + viewWidth / 2 + shiftX;\n      let maxX = extent[2] - viewWidth / 2 + shiftX;\n      let minY = extent[1] + viewHeight / 2 + shiftY;\n      let maxY = extent[3] - viewHeight / 2 + shiftY;\n\n      // note: when zooming out of bounds, min and max values for x and y may\n      // end up inverted (min > max); this has to be accounted for\n      if (minX > maxX) {\n        minX = (maxX + minX) / 2;\n        maxX = minX;\n      }\n      if (minY > maxY) {\n        minY = (maxY + minY) / 2;\n        maxY = minY;\n      }\n\n      let x = clamp(center[0], minX, maxX);\n      let y = clamp(center[1], minY, maxY);\n\n      // during an interaction, allow some overscroll\n      if (opt_isMoving && smooth && resolution) {\n        const ratio = 30 * resolution;\n        x +=\n          -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +\n          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);\n        y +=\n          -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +\n          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);\n      }\n\n      return [x, y];\n    }\n  );\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} [center] Center.\n * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n */\nexport function none(center) {\n  return center;\n}\n", "/**\n * @module ol/resolutionconstraint\n */\nimport {clamp} from './math.js';\nimport {getHeight, getWidth} from './extent.js';\nimport {linearFindNearest} from './array.js';\n\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(\n  resolution,\n  maxExtent,\n  viewportSize,\n  showFullExtent\n) {\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\n\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  let result = Math.min(resolution, maxResolution);\n  const ratio = 50;\n\n  result *=\n    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n    1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /=\n      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n        ratio +\n      1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(\n  resolutions,\n  opt_smooth,\n  opt_maxExtent,\n  opt_showFullExtent\n) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        const maxResolution = resolutions[0];\n        const minResolution = resolutions[resolutions.length - 1];\n        const cappedMaxRes = opt_maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              opt_maxExtent,\n              size,\n              opt_showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (opt_isMoving) {\n          const smooth = opt_smooth !== undefined ? opt_smooth : true;\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const capped = Math.min(cappedMaxRes, resolution);\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [opt_minResolution] Minimum resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(\n  power,\n  maxResolution,\n  opt_minResolution,\n  opt_smooth,\n  opt_maxExtent,\n  opt_showFullExtent\n) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = opt_maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              opt_maxExtent,\n              size,\n              opt_showFullExtent\n            )\n          : maxResolution;\n        const minResolution =\n          opt_minResolution !== undefined ? opt_minResolution : 0;\n\n        // during interacting or animating, allow intermediary values\n        if (opt_isMoving) {\n          const smooth = opt_smooth !== undefined ? opt_smooth : true;\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const tolerance = 1e-9;\n        const minZoomLevel = Math.ceil(\n          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance\n        );\n        const offset = -direction * (0.5 - tolerance) + 0.5;\n        const capped = Math.min(cappedMaxRes, resolution);\n        const cappedZoomLevel = Math.floor(\n          Math.log(maxResolution / capped) / Math.log(power) + offset\n        );\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(\n  maxResolution,\n  minResolution,\n  opt_smooth,\n  opt_maxExtent,\n  opt_showFullExtent\n) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = opt_maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              opt_maxExtent,\n              size,\n              opt_showFullExtent\n            )\n          : maxResolution;\n        const smooth = opt_smooth !== undefined ? opt_smooth : true;\n\n        if (!smooth || !opt_isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(\n          resolution,\n          cappedMaxRes,\n          minResolution\n        );\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n", "/**\n * @module ol/rotationconstraint\n */\nimport {toRadians} from './math.js';\n\n/**\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\n */\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function disable(rotation) {\n  if (rotation !== undefined) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function none(rotation) {\n  if (rotation !== undefined) {\n    return rotation;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToN(n) {\n  const theta = (2 * Math.PI) / n;\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, opt_isMoving) {\n      if (opt_isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        rotation = Math.floor(rotation / theta + 0.5) * theta;\n        return rotation;\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n/**\n * @param {number} [opt_tolerance] Tolerance.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToZero(opt_tolerance) {\n  const tolerance = opt_tolerance || toRadians(5);\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, opt_isMoving) {\n      if (opt_isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        if (Math.abs(rotation) <= tolerance) {\n          return 0;\n        } else {\n          return rotation;\n        }\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n", "/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(\n  flatCoordinates,\n  offset1,\n  offset2,\n  stride,\n  x,\n  y,\n  closestPoint\n) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(\n          flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i],\n          t\n        );\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  max\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  max\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  opt_tmpPoint\n) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[offset],\n      flatCoordinates[offset + 1]\n    );\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates,\n      index - stride,\n      index,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index +=\n        stride *\n        Math.max(\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n            maxDelta) |\n            0,\n          1\n        );\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates,\n      end - stride,\n      offset,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  opt_tmpPoint\n) {\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  opt_tmpPoint\n) {\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n", "/**\n * @module ol/geom/flat/area\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRing(flatCoordinates, offset, end, stride) {\n  let twiceArea = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    twiceArea += y1 * x2 - x1 * y2;\n    x1 = x2;\n    y1 = y2;\n  }\n  return twiceArea / 2;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRings(flatCoordinates, offset, ends, stride) {\n  let area = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    area += linearRing(flatCoordinates, offset, end, stride);\n    offset = end;\n  }\n  return area;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  let area = 0;\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    area += linearRings(flatCoordinates, offset, ends, stride);\n    offset = ends[ends.length - 1];\n  }\n  return area;\n}\n", "/**\n * @module ol/geom/LinearRing\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {linearRing as linearRingArea} from './flat/area.js';\n\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\nclass LinearRing extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   */\n  constructor(coordinates, opt_layout) {\n    super();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        opt_layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        opt_layout\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LinearRing} Clone.\n   * @api\n   */\n  clone() {\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * Return the area of the linear ring on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingArea(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * Return the coordinates of the linear ring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LinearRing} Simplified LinearRing.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0\n    );\n    return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n  getType() {\n    return GeometryType.LINEAR_RING;\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the linear ring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride\n    );\n    this.changed();\n  }\n}\n\nexport default LinearRing;\n", "/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1]\n      );\n    }\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n", "/**\n * @module ol/geom/flat/interiorpoint\n */\nimport {linearRingsContainsXY} from './contains.js';\nimport {numberSafeCompareFunction} from '../../array.js';\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  flatCenters,\n  flatCentersOffset,\n  opt_dest\n) {\n  let i, ii, x, x1, x2, y1, y2;\n  const y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n  const intersections = [];\n  // Calculate intersections with the horizontal line\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\n    const end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  let pointX = NaN;\n  let maxSegmentLength = -Infinity;\n  intersections.sort(numberSafeCompareFunction);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    const segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (opt_dest) {\n    opt_dest.push(pointX, y, maxSegmentLength);\n    return opt_dest;\n  } else {\n    return [pointX, y, maxSegmentLength];\n  }\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  flatCenters\n) {\n  let interiorPoints = [];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      flatCenters,\n      2 * i,\n      interiorPoints\n    );\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}\n", "/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride)\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n", "/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  containsExtent,\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {forEach as forEachSegment} from './segments.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  const coordinatesExtent = extendFlatCoordinates(\n    createEmpty(),\n    flatCoordinates,\n    offset,\n    end,\n    stride\n  );\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (containsExtent(extent, coordinatesExtent)) {\n    return true;\n  }\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    }\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3]\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n", "/**\n * @module ol/geom/flat/reverse\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nexport function coordinates(flatCoordinates, offset, end, stride) {\n  while (offset < end - stride) {\n    for (let i = 0; i < stride; ++i) {\n      const tmp = flatCoordinates[offset + i];\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n      flatCoordinates[end - stride + i] = tmp;\n    }\n    offset += stride;\n    end -= stride;\n  }\n}\n", "/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from './reverse.js';\n\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  let edge = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge === 0 ? undefined : edge > 0;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  opt_right\n) {\n  const right = opt_right !== undefined ? opt_right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  opt_right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      !linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)\n    ) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  opt_right\n) {\n  const right = opt_right !== undefined ? opt_right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    const reverse =\n      i === 0\n        ? (right && isClockwise) || (!right && !isClockwise)\n        : (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  opt_right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates,\n      offset,\n      endss[i],\n      stride,\n      opt_right\n    );\n  }\n  return offset;\n}\n\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to contruct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n  const endss = [];\n  let offset = 0;\n  let prevEndIndex = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    // classifies an array of rings into polygons with outer rings and holes\n    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n      endss.push(ends.slice(prevEndIndex, i + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n    prevEndIndex = i + 1;\n    offset = end;\n  }\n  return endss;\n}\n", "/**\n * @module ol/geom/Polygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {closestSquaredDistanceXY, getCenter} from '../extent.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointOfArray} from './flat/interiorpoint.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRings} from './flat/orient.js';\nimport {linearRings as linearRingsArea} from './flat/area.js';\nimport {linearRingsContainsXY} from './flat/contains.js';\nimport {modulo} from '../math.js';\nimport {quantizeArray} from './flat/simplify.js';\nimport {offset as sphereOffset} from '../sphere.js';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nclass Polygon extends SimpleGeometry {\n  /**\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n   *     Array of linear rings that define the polygon. The first linear ring of the\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\n   *     an array of vertices' coordinates where the first coordinate and the last are\n   *     equivalent. (For internal use, flat coordinates in combination with\n   *     `opt_layout` and `opt_ends` are also accepted.)\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).\n   */\n  constructor(coordinates, opt_layout, opt_ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatInteriorPoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(\n        opt_layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n      this.ends_ = opt_ends;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        opt_layout\n      );\n    }\n  }\n\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {LinearRing} linearRing Linear ring.\n   * @api\n   */\n  appendLinearRing(linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Polygon} Clone.\n   * @api\n   */\n  clone() {\n    const polygon = new Polygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice()\n    );\n    polygon.applyProperties(this);\n    return polygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingsContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      x,\n      y\n    );\n  }\n\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingsArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n  getCoordinates(opt_right) {\n    let flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * @return {Array<number>} Interior point.\n   */\n  getFlatInteriorPoint() {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.ends_,\n        this.stride,\n        flatCenter,\n        0\n      );\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoint_;\n  }\n\n  /**\n   * Return an interior point of the polygon.\n   * @return {Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoint() {\n    return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n  }\n\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n  getLinearRingCount() {\n    return this.ends_.length;\n  }\n\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {LinearRing|null} Linear ring.\n   * @api\n   */\n  getLinearRing(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LinearRing(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index]\n      ),\n      this.layout\n    );\n  }\n\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array<LinearRing>} Linear rings.\n   * @api\n   */\n  getLinearRings() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const linearRings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const linearRing = new LinearRing(\n        flatCoordinates.slice(offset, end),\n        layout\n      );\n      linearRings.push(linearRing);\n      offset = end;\n    }\n    return linearRings;\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRings(\n          this.orientedFlatCoordinates_,\n          0,\n          this.ends_,\n          this.stride\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Polygon} Simplified Polygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds\n    );\n    return new Polygon(\n      simplifiedFlatCoordinates,\n      GeometryLayout.XY,\n      simplifiedEnds\n    );\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n  getType() {\n    return GeometryType.POLYGON;\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default Polygon;\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [opt_n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n  const n = opt_n ? opt_n : 32;\n  /** @type {Array<number>} */\n  const flatCoordinates = [];\n  for (let i = 0; i < n; ++i) {\n    extend(\n      flatCoordinates,\n      sphereOffset(center, radius, (2 * Math.PI * i) / n, opt_sphereRadius)\n    );\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [\n    flatCoordinates.length,\n  ]);\n}\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const flatCoordinates = [\n    minX,\n    minY,\n    minX,\n    maxY,\n    maxX,\n    maxY,\n    maxX,\n    minY,\n    minX,\n    minY,\n  ];\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [\n    flatCoordinates.length,\n  ]);\n}\n\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, opt_sides, opt_angle) {\n  const sides = opt_sides ? opt_sides : 32;\n  const stride = circle.getStride();\n  const layout = circle.getLayout();\n  const center = circle.getCenter();\n  const arrayLength = stride * (sides + 1);\n  const flatCoordinates = new Array(arrayLength);\n  for (let i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n    for (let j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n  const ends = [flatCoordinates.length];\n  const polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), opt_angle);\n  return polygon;\n}\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, opt_angle) {\n  const flatCoordinates = polygon.getFlatCoordinates();\n  const stride = polygon.getStride();\n  const sides = flatCoordinates.length / stride - 1;\n  const startAngle = opt_angle ? opt_angle : 0;\n  for (let i = 0; i <= sides; ++i) {\n    const offset = i * stride;\n    const angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n  polygon.changed();\n}\n", "/**\n * @module ol/View\n */\nimport BaseObject from './Object.js';\nimport GeometryType from './geom/GeometryType.js';\nimport Units from './proj/Units.js';\nimport ViewHint from './ViewHint.js';\nimport ViewProperty from './ViewProperty.js';\nimport {DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {\n  METERS_PER_UNIT,\n  createProjection,\n  disableCoordinateWarning,\n  fromUserCoordinate,\n  fromUserExtent,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from './proj.js';\nimport {VOID} from './functions.js';\nimport {\n  add as addCoordinate,\n  equals as coordinatesEqual,\n  equals,\n  rotate as rotateCoordinate,\n} from './coordinate.js';\nimport {assert} from './asserts.js';\nimport {assign} from './obj.js';\nimport {none as centerNone, createExtent} from './centerconstraint.js';\nimport {clamp, modulo} from './math.js';\nimport {\n  createMinMaxResolution,\n  createSnapToPower,\n  createSnapToResolutions,\n} from './resolutionconstraint.js';\nimport {\n  createSnapToN,\n  createSnapToZero,\n  disable,\n  none as rotationNone,\n} from './rotationconstraint.js';\nimport {easeOut, inAndOut} from './easing.js';\nimport {\n  getCenter,\n  getForViewAndSize,\n  getHeight,\n  getWidth,\n  isEmpty,\n} from './extent.js';\nimport {linearFindNearest} from './array.js';\nimport {fromExtent as polygonFromExtent} from './geom/Polygon.js';\n\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter] Source center.\n * @property {import(\"./coordinate.js\").Coordinate} [targetCenter] Target center.\n * @property {number} [sourceResolution] Source resolution.\n * @property {number} [targetResolution] Target resolution.\n * @property {number} [sourceRotation] Source rotation.\n * @property {number} [targetRotation] Target rotation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Anchor.\n * @property {number} start Start.\n * @property {number} duration Duration.\n * @property {boolean} complete Complete.\n * @property {function(number):number} easing Easing.\n * @property {function(boolean):void} callback Callback.\n */\n\n/**\n * @typedef {Object} Constraints\n * @property {import(\"./centerconstraint.js\").Type} center Center.\n * @property {import(\"./resolutionconstraint.js\").Type} resolution Resolution.\n * @property {import(\"./rotationconstraint.js\").Type} rotation Rotation.\n */\n\n/**\n * @typedef {Object} FitOptions\n * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to fit\n * the extent into. Default is the current size of the first map in the DOM that\n * uses this view, or `[100, 100]` if no such map is found.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,\n * get the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean):void} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n\n/**\n * @typedef {Object} ViewOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\n * the view. If a user projection is not set, the coordinate system for the center is\n * specified with the `projection` option. Layer sources will not be fetched if this\n * is not set, but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\n * view, in other words, nothing outside of this extent can be visible on the map.\n * @property {boolean} [constrainOnlyCenter=false] If true, the extent\n * constraint will only apply to the view center and not the whole extent.\n * @property {boolean} [smoothExtentConstraint=true] If true, the extent\n * constraint will be applied smoothly, i.e. allow the view to go slightly outside\n * of the given `extent`.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection's validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {boolean} [multiWorld=false] If `false` the view is constrained so\n * only one world is visible, and you cannot pan off the edge.  If `true` the map\n * may show multiple worlds at low zoom levels.  Only used if the `projection` is\n * global.  Note that if `extent` is also provided it is given precedence.\n * @property {boolean} [constrainResolution=false] If true, the view will always\n * animate to the closest zoom level after an interaction; false means\n * intermediary zoom levels are allowed.\n * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution\n * min/max values will be applied smoothly, i. e. allow the view to exceed slightly\n * the given resolution or zoom bounds.\n * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to\n * show the full configured extent. By default, when a view is configured with an\n * extent, users will not be able to zoom out so the viewport exceeds the extent in\n * either dimension. This means the full extent may not be visible if the viewport\n * is taller or wider than the aspect ratio of the configured extent. If\n * showFullExtent is true, the user will be able to zoom out so that the viewport\n * exceeds the height or width of the configured extent, but not both, allowing the\n * full extent to be shown.\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array<number>} [resolutions] Resolutions that determine the\n * zoom levels if specified. The index in the array corresponds to the zoom level,\n * therefore the resolution values have to be in descending order. It also constrains\n * the resolution by the minimum and maximum value. If set the `maxResolution`,\n * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view.\n * @property {number} [zoomFactor=2] The zoom factor used to compute the\n * corresponding resolution.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).\n * If the map viewport is partially covered with other content (overlays) along\n * its edges, this setting allows to shift the center of the viewport away from\n * that content. The order of the values is top, right, bottom, left.\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\n * the animation.\n * @property {number} [zoom] The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number} [resolution] The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number} [rotation] The rotation of the view at the end of\n * the animation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remain fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./coordinate.js\").Coordinate} center Center.\n * @property {import(\"./proj/Projection.js\").default} projection Projection.\n * @property {number} resolution Resolution.\n * @property {import(\"./coordinate.js\").Coordinate} [nextCenter] The next center during an animation series.\n * @property {number} [nextResolution] The next resolution during an animation series.\n * @property {number} [nextRotation] The next rotation during an animation series.\n * @property {number} rotation Rotation.\n * @property {number} zoom Zoom.\n */\n\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\nconst DEFAULT_MIN_ZOOM = 0;\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<ViewObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature\n */\n\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * A View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Web Mercator (EPSG:3857).\n *\n * ### The view states\n *\n * A View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * The `zoom` state is actually not saved on the view: all computations\n * internally use the `resolution` state. Still, the `setZoom` and `getZoom`\n * methods are available, as well as `getResolutionForZoom` and\n * `getZoomForResolution` to switch from one system to the other.\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view, but any constraint defined in the constructor will\n * be applied along the way.\n *\n * A View object can have a *resolution constraint*, a *rotation constraint*\n * and a *center constraint*.\n *\n * The *resolution constraint* typically restricts min/max values and\n * snaps to specific resolutions. It is determined by the following\n * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.\n * If `resolutions` is set, the other three options are ignored. See\n * documentation for each option for more information. By default, the view\n * only has a min/max restriction and allow intermediary zoom levels when\n * pinch-zooming for example.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default rotation is allowed and its value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the view center is not constrained at all.\n *\n * ### Changing the view state\n *\n * It is important to note that `setZoom`, `setResolution`, `setCenter` and\n * `setRotation` are subject to the above mentioned constraints. As such, it\n * may sometimes not be possible to know in advance the resulting state of the\n * View. For example, calling `setResolution(10)` does not guarantee that\n * `getResolution()` will return `10`.\n *\n * A consequence of this is that, when applying a delta on the view state, one\n * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`\n * rather than the corresponding setters. This will let view do its internal\n * computations. Besides, the `adjust*` methods also take an `opt_anchor`\n * argument which allows specifying an origin for the transformation.\n *\n * ### Interacting with the view\n *\n * View constraints are usually only applied when the view is *at rest*, meaning that\n * no interaction or animation is ongoing. As such, if the user puts the view in a\n * state that is not equivalent to a constrained one (e.g. rotating the view when\n * the snap angle is 0), an animation will be triggered at the interaction end to\n * put back the view to a stable state;\n *\n * @api\n */\nclass View extends BaseObject {\n  /**\n   * @param {ViewOptions} [opt_options] View options.\n   */\n  constructor(opt_options) {\n    super();\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ViewOnSignature<void>}\n     */\n    this.un;\n\n    const options = assign({}, opt_options);\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.hints_ = [0, 0];\n\n    /**\n     * @private\n     * @type {Array<Array<Animation>>}\n     */\n    this.animations_ = [];\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.updateAnimationKey_;\n\n    /**\n     * @private\n     * @const\n     * @type {import(\"./proj/Projection.js\").default}\n     */\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\n\n    /**\n     * @private\n     * @type {import(\"./size.js\").Size}\n     */\n    this.viewportSize_ = [100, 100];\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.targetCenter_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetResolution_;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate}\n     */\n    this.nextCenter_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextResolution_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.cancelAnchor_ = undefined;\n\n    if (options.center) {\n      options.center = fromUserCoordinate(options.center, this.projection_);\n    }\n    if (options.extent) {\n      options.extent = fromUserExtent(options.extent, this.projection_);\n    }\n    if (options.projection) {\n      disableCoordinateWarning();\n    }\n\n    this.applyOptions_(options);\n  }\n\n  /**\n   * Set up the view with the given options.\n   * @param {ViewOptions} options View options.\n   */\n  applyOptions_(options) {\n    const properties = assign({}, options);\n    for (const key in ViewProperty) {\n      delete properties[key];\n    }\n    this.setProperties(properties, true);\n\n    const resolutionConstraintInfo = createResolutionConstraint(options);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n\n    /**\n     * @private\n     * @type {Array<number>|undefined}\n     */\n    this.resolutions_ = options.resolutions;\n\n    /**\n     * @type {Array<number>|undefined}\n     * @private\n     */\n    this.padding_ = options.padding;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n\n    const centerConstraint = createCenterConstraint(options);\n    const resolutionConstraint = resolutionConstraintInfo.constraint;\n    const rotationConstraint = createRotationConstraint(options);\n\n    /**\n     * @private\n     * @type {Constraints}\n     */\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint,\n    };\n\n    this.setRotation(options.rotation !== undefined ? options.rotation : 0);\n    this.setCenterInternal(\n      options.center !== undefined ? options.center : null\n    );\n    if (options.resolution !== undefined) {\n      this.setResolution(options.resolution);\n    } else if (options.zoom !== undefined) {\n      this.setZoom(options.zoom);\n    }\n  }\n\n  /**\n   * Padding (in css pixels).\n   * If the map viewport is partially covered with other content (overlays) along\n   * its edges, this setting allows to shift the center of the viewport away from that\n   * content. The order of the values in the array is top, right, bottom, left.\n   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.\n   * @type {Array<number>|undefined}\n   * @api\n   */\n  get padding() {\n    return this.padding_;\n  }\n  set padding(padding) {\n    let oldPadding = this.padding_;\n    this.padding_ = padding;\n    const center = this.getCenter();\n    if (center) {\n      const newPadding = padding || [0, 0, 0, 0];\n      oldPadding = oldPadding || [0, 0, 0, 0];\n      const resolution = this.getResolution();\n      const offsetX =\n        (resolution / 2) *\n        (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\n      const offsetY =\n        (resolution / 2) *\n        (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\n      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\n    }\n  }\n\n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be used to apply new min/max zoom or\n   * resolution limits.\n   * @param {ViewOptions} newOptions New options to be applied.\n   * @return {ViewOptions} New options updated with the current view state.\n   */\n  getUpdatedOptions_(newOptions) {\n    const options = this.getProperties();\n\n    // preserve resolution (or zoom)\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    }\n\n    // preserve center\n    options.center = this.getCenterInternal();\n\n    // preserve rotation\n    options.rotation = this.getRotation();\n\n    return assign({}, options, newOptions);\n  }\n\n  /**\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link module:ol/easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n  animate(var_args) {\n    if (this.isDef() && !this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n    const args = new Array(arguments.length);\n    for (let i = 0; i < args.length; ++i) {\n      let options = arguments[i];\n      if (options.center) {\n        options = assign({}, options);\n        options.center = fromUserCoordinate(\n          options.center,\n          this.getProjection()\n        );\n      }\n      if (options.anchor) {\n        options = assign({}, options);\n        options.anchor = fromUserCoordinate(\n          options.anchor,\n          this.getProjection()\n        );\n      }\n      args[i] = options;\n    }\n    this.animateInternal.apply(this, args);\n  }\n\n  /**\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.\n   */\n  animateInternal(var_args) {\n    let animationCount = arguments.length;\n    let callback;\n    if (\n      animationCount > 1 &&\n      typeof arguments[animationCount - 1] === 'function'\n    ) {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n\n    let i = 0;\n    for (; i < animationCount && !this.isDef(); ++i) {\n      // if view properties are not yet set, shortcut to the final state\n      const state = arguments[i];\n      if (state.center) {\n        this.setCenterInternal(state.center);\n      }\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      } else if (state.resolution) {\n        this.setResolution(state.resolution);\n      }\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n    }\n    if (i === animationCount) {\n      if (callback) {\n        animationCallback(callback, true);\n      }\n      return;\n    }\n\n    let start = Date.now();\n    let center = this.targetCenter_.slice();\n    let resolution = this.targetResolution_;\n    let rotation = this.targetRotation_;\n    const series = [];\n    for (; i < animationCount; ++i) {\n      const options = /** @type {AnimationOptions} */ (arguments[i]);\n\n      const animation = {\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || inAndOut,\n        callback: callback,\n      };\n\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center.slice();\n        center = animation.targetCenter;\n      }\n\n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this.getResolutionForZoom(options.zoom);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n\n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        const delta =\n          modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n\n      // check if animation is a no-op\n      if (isNoopAnimation(animation)) {\n        animation.complete = true;\n        // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n      series.push(animation);\n    }\n    this.animations_.push(series);\n    this.setHint(ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  }\n\n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n  getAnimating() {\n    return this.hints_[ViewHint.ANIMATING] > 0;\n  }\n\n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n  getInteracting() {\n    return this.hints_[ViewHint.INTERACTING] > 0;\n  }\n\n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n  cancelAnimations() {\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n    let anchor;\n    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {\n      const series = this.animations_[i];\n      if (series[0].callback) {\n        animationCallback(series[0].callback, false);\n      }\n      if (!anchor) {\n        for (let j = 0, jj = series.length; j < jj; ++j) {\n          const animation = series[j];\n          if (!animation.complete) {\n            anchor = animation.anchor;\n            break;\n          }\n        }\n      }\n    }\n    this.animations_.length = 0;\n    this.cancelAnchor_ = anchor;\n    this.nextCenter_ = null;\n    this.nextResolution_ = NaN;\n    this.nextRotation_ = NaN;\n  }\n\n  /**\n   * Update all animations.\n   */\n  updateAnimations_() {\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n    if (!this.getAnimating()) {\n      return;\n    }\n    const now = Date.now();\n    let more = false;\n    for (let i = this.animations_.length - 1; i >= 0; --i) {\n      const series = this.animations_[i];\n      let seriesComplete = true;\n      for (let j = 0, jj = series.length; j < jj; ++j) {\n        const animation = series[j];\n        if (animation.complete) {\n          continue;\n        }\n        const elapsed = now - animation.start;\n        let fraction =\n          animation.duration > 0 ? elapsed / animation.duration : 1;\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n        const progress = animation.easing(fraction);\n        if (animation.sourceCenter) {\n          const x0 = animation.sourceCenter[0];\n          const y0 = animation.sourceCenter[1];\n          const x1 = animation.targetCenter[0];\n          const y1 = animation.targetCenter[1];\n          this.nextCenter_ = animation.targetCenter;\n          const x = x0 + progress * (x1 - x0);\n          const y = y0 + progress * (y1 - y0);\n          this.targetCenter_ = [x, y];\n        }\n        if (animation.sourceResolution && animation.targetResolution) {\n          const resolution =\n            progress === 1\n              ? animation.targetResolution\n              : animation.sourceResolution +\n                progress *\n                  (animation.targetResolution - animation.sourceResolution);\n          if (animation.anchor) {\n            const size = this.getViewportSize_(this.getRotation());\n            const constrainedResolution = this.constraints_.resolution(\n              resolution,\n              0,\n              size,\n              true\n            );\n            this.targetCenter_ = this.calculateCenterZoom(\n              constrainedResolution,\n              animation.anchor\n            );\n          }\n          this.nextResolution_ = animation.targetResolution;\n          this.targetResolution_ = resolution;\n          this.applyTargetState_(true);\n        }\n        if (\n          animation.sourceRotation !== undefined &&\n          animation.targetRotation !== undefined\n        ) {\n          const rotation =\n            progress === 1\n              ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -\n                Math.PI\n              : animation.sourceRotation +\n                progress *\n                  (animation.targetRotation - animation.sourceRotation);\n          if (animation.anchor) {\n            const constrainedRotation = this.constraints_.rotation(\n              rotation,\n              true\n            );\n            this.targetCenter_ = this.calculateCenterRotate(\n              constrainedRotation,\n              animation.anchor\n            );\n          }\n          this.nextRotation_ = animation.targetRotation;\n          this.targetRotation_ = rotation;\n        }\n        this.applyTargetState_(true);\n        more = true;\n        if (!animation.complete) {\n          break;\n        }\n      }\n      if (seriesComplete) {\n        this.animations_[i] = null;\n        this.setHint(ViewHint.ANIMATING, -1);\n        this.nextCenter_ = null;\n        this.nextResolution_ = NaN;\n        this.nextRotation_ = NaN;\n        const callback = series[0].callback;\n        if (callback) {\n          animationCallback(callback, true);\n        }\n      }\n    }\n    // prune completed series\n    this.animations_ = this.animations_.filter(Boolean);\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(\n        this.updateAnimations_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * @param {number} rotation Target rotation.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\n   */\n  calculateCenterRotate(rotation, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      rotateCoordinate(center, rotation - this.getRotation());\n      addCoordinate(center, anchor);\n    }\n    return center;\n  }\n\n  /**\n   * @param {number} resolution Target resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\n   */\n  calculateCenterZoom(resolution, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    const currentResolution = this.getResolution();\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      const x =\n        anchor[0] -\n        (resolution * (anchor[0] - currentCenter[0])) / currentResolution;\n      const y =\n        anchor[1] -\n        (resolution * (anchor[1] - currentCenter[1])) / currentResolution;\n      center = [x, y];\n    }\n    return center;\n  }\n\n  /**\n   * Returns the current viewport size.\n   * @private\n   * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n  getViewportSize_(opt_rotation) {\n    const size = this.viewportSize_;\n    if (opt_rotation) {\n      const w = size[0];\n      const h = size[1];\n      return [\n        Math.abs(w * Math.cos(opt_rotation)) +\n          Math.abs(h * Math.sin(opt_rotation)),\n        Math.abs(w * Math.sin(opt_rotation)) +\n          Math.abs(h * Math.cos(opt_rotation)),\n      ];\n    } else {\n      return size;\n    }\n  }\n\n  /**\n   * Stores the viewport size on the view. The viewport size is not read every time from the DOM\n   * to avoid performance hit and layout reflow.\n   * This should be done on map size change.\n   * Note: the constraints are not resolved during an animation to avoid stopping it\n   * @param {import(\"./size.js\").Size} [opt_size] Viewport size; if undefined, [100, 100] is assumed\n   */\n  setViewportSize(opt_size) {\n    this.viewportSize_ = Array.isArray(opt_size)\n      ? opt_size.slice()\n      : [100, 100];\n    if (!this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n  }\n\n  /**\n   * Get the view center.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n  getCenter() {\n    const center = this.getCenterInternal();\n    if (!center) {\n      return center;\n    }\n    return toUserCoordinate(center, this.getProjection());\n  }\n\n  /**\n   * Get the view center without transforming to user projection.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   */\n  getCenterInternal() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(ViewProperty.CENTER)\n    );\n  }\n\n  /**\n   * @return {Constraints} Constraints.\n   */\n  getConstraints() {\n    return this.constraints_;\n  }\n\n  /**\n   * @return {boolean} Resolution constraint is set\n   */\n  getConstrainResolution() {\n    return this.get('constrainResolution');\n  }\n\n  /**\n   * @param {Array<number>} [opt_hints] Destination array.\n   * @return {Array<number>} Hint.\n   */\n  getHints(opt_hints) {\n    if (opt_hints !== undefined) {\n      opt_hints[0] = this.hints_[0];\n      opt_hints[1] = this.hints_[1];\n      return opt_hints;\n    } else {\n      return this.hints_.slice();\n    }\n  }\n\n  /**\n   * Calculate the extent for the current view state and the passed size.\n   * The size is the pixel dimensions of the box into which the calculated extent\n   * should fit. In most cases you want to get the extent of the entire map,\n   * that is `map.getSize()`.\n   * @param {import(\"./size.js\").Size} [opt_size] Box pixel size. If not provided, the size\n   * of the map that uses this view will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   * @api\n   */\n  calculateExtent(opt_size) {\n    const extent = this.calculateExtentInternal(opt_size);\n    return toUserExtent(extent, this.getProjection());\n  }\n\n  /**\n   * @param {import(\"./size.js\").Size} [opt_size] Box pixel size. If not provided,\n   * the map's last known viewport size will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  calculateExtentInternal(opt_size) {\n    const size = opt_size || this.getViewportSizeMinusPadding_();\n    const center = /** @type {!import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    assert(center, 1); // The view center is not defined\n    const resolution = /** @type {!number} */ (this.getResolution());\n    assert(resolution !== undefined, 2); // The view resolution is not defined\n    const rotation = /** @type {!number} */ (this.getRotation());\n    assert(rotation !== undefined, 3); // The view rotation is not defined\n\n    return getForViewAndSize(center, resolution, rotation, size);\n  }\n\n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n  getMaxResolution() {\n    return this.maxResolution_;\n  }\n\n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n  getMinResolution() {\n    return this.minResolution_;\n  }\n\n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.minResolution_)\n    );\n  }\n\n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n  setMaxZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\n  }\n\n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.maxResolution_)\n    );\n  }\n\n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n  setMinZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\n  }\n\n  /**\n   * Set whether the view should allow intermediary zoom levels.\n   * @param {boolean} enabled Whether the resolution is constrained.\n   * @api\n   */\n  setConstrainResolution(enabled) {\n    this.applyOptions_(this.getUpdatedOptions_({constrainResolution: enabled}));\n  }\n\n  /**\n   * Get the view projection.\n   * @return {import(\"./proj/Projection.js\").default} The projection of the view.\n   * @api\n   */\n  getProjection() {\n    return this.projection_;\n  }\n\n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n  getResolution() {\n    return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\n  }\n\n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the View, or undefined if none were given.\n   * @return {Array<number>|undefined} The resolutions of the view.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [opt_size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n  getResolutionForExtent(extent, opt_size) {\n    return this.getResolutionForExtentInternal(\n      fromUserExtent(extent, this.getProjection()),\n      opt_size\n    );\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [opt_size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   */\n  getResolutionForExtentInternal(extent, opt_size) {\n    const size = opt_size || this.getViewportSizeMinusPadding_();\n    const xResolution = getWidth(extent) / size[0];\n    const yResolution = getHeight(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  }\n\n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number} [opt_power] Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n  getResolutionForValueFunction(opt_power) {\n    const power = opt_power || 2;\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function (value) {\n        const resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      }\n    );\n  }\n\n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  getRotation() {\n    return /** @type {number} */ (this.get(ViewProperty.ROTATION));\n  }\n\n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number} [opt_power] Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n  getValueForResolutionFunction(opt_power) {\n    const logPower = Math.log(opt_power || 2);\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / logPower;\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function (resolution) {\n        const value = Math.log(maxResolution / resolution) / logPower / max;\n        return value;\n      }\n    );\n  }\n\n  /**\n   * Returns the size of the viewport minus padding.\n   * @private\n   * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size reduced by the padding.\n   */\n  getViewportSizeMinusPadding_(opt_rotation) {\n    let size = this.getViewportSize_(opt_rotation);\n    const padding = this.padding_;\n    if (padding) {\n      size = [\n        size[0] - padding[1] - padding[3],\n        size[1] - padding[0] - padding[2],\n      ];\n    }\n    return size;\n  }\n\n  /**\n   * @return {State} View state.\n   */\n  getState() {\n    const projection = this.getProjection();\n    const resolution = this.getResolution();\n    const rotation = this.getRotation();\n    let center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    const padding = this.padding_;\n    if (padding) {\n      const reducedSize = this.getViewportSizeMinusPadding_();\n      center = calculateCenterOn(\n        center,\n        this.getViewportSize_(),\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation\n      );\n    }\n    return {\n      center: center.slice(0),\n      projection: projection !== undefined ? projection : null,\n      resolution: resolution,\n      nextCenter: this.nextCenter_,\n      nextResolution: this.nextResolution_,\n      nextRotation: this.nextRotation_,\n      rotation: rotation,\n      zoom: this.getZoom(),\n    };\n  }\n\n  /**\n   * Get the current zoom level. This method may return non-integer zoom levels\n   * if the view does not constrain the resolution, or if an interaction or\n   * animation is underway.\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n  getZoom() {\n    let zoom;\n    const resolution = this.getResolution();\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n    return zoom;\n  }\n\n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n  getZoomForResolution(resolution) {\n    let offset = this.minZoom_ || 0;\n    let max, zoomFactor;\n    if (this.resolutions_) {\n      const nearest = linearFindNearest(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  }\n\n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n  getResolutionForZoom(zoom) {\n    if (this.resolutions_) {\n      if (this.resolutions_.length <= 1) {\n        return 0;\n      }\n      const baseLevel = clamp(\n        Math.floor(zoom),\n        0,\n        this.resolutions_.length - 2\n      );\n      const zoomFactor =\n        this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\n      return (\n        this.resolutions_[baseLevel] /\n        Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1))\n      );\n    } else {\n      return (\n        this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_)\n      );\n    }\n  }\n\n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {FitOptions} [opt_options] Options.\n   * @api\n   */\n  fit(geometryOrExtent, opt_options) {\n    /** @type {import(\"./geom/SimpleGeometry.js\").default} */\n    let geometry;\n    assert(\n      Array.isArray(geometryOrExtent) ||\n        typeof (/** @type {?} */ (geometryOrExtent).getSimplifiedGeometry) ===\n          'function',\n      24\n    ); // Invalid extent or geometry provided as `geometry`\n    if (Array.isArray(geometryOrExtent)) {\n      assert(!isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`\n      const extent = fromUserExtent(geometryOrExtent, this.getProjection());\n      geometry = polygonFromExtent(extent);\n    } else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {\n      const extent = fromUserExtent(\n        geometryOrExtent.getExtent(),\n        this.getProjection()\n      );\n      geometry = polygonFromExtent(extent);\n      geometry.rotate(this.getRotation(), getCenter(extent));\n    } else {\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        geometry = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n          geometryOrExtent\n            .clone()\n            .transform(userProjection, this.getProjection())\n        );\n      } else {\n        geometry = geometryOrExtent;\n      }\n    }\n\n    this.fitInternal(geometry, opt_options);\n  }\n\n  /**\n   * Calculate rotated extent\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @return {import(\"./extent\").Extent} The rotated extent for the geometry.\n   */\n  rotatedExtentForGeometry(geometry) {\n    const rotation = this.getRotation();\n    const cosAngle = Math.cos(rotation);\n    const sinAngle = Math.sin(-rotation);\n    const coords = geometry.getFlatCoordinates();\n    const stride = geometry.getStride();\n    let minRotX = +Infinity;\n    let minRotY = +Infinity;\n    let maxRotX = -Infinity;\n    let maxRotY = -Infinity;\n    for (let i = 0, ii = coords.length; i < ii; i += stride) {\n      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    }\n    return [minRotX, minRotY, maxRotX, maxRotY];\n  }\n\n  /**\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @param {FitOptions} [opt_options] Options.\n   */\n  fitInternal(geometry, opt_options) {\n    const options = opt_options || {};\n    let size = options.size;\n    if (!size) {\n      size = this.getViewportSizeMinusPadding_();\n    }\n    const padding =\n      options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    const nearest = options.nearest !== undefined ? options.nearest : false;\n    let minResolution;\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.getResolutionForZoom(options.maxZoom);\n    } else {\n      minResolution = 0;\n    }\n\n    const rotatedExtent = this.rotatedExtentForGeometry(geometry);\n\n    // calculate resolution\n    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [\n      size[0] - padding[1] - padding[3],\n      size[1] - padding[0] - padding[2],\n    ]);\n    resolution = isNaN(resolution)\n      ? minResolution\n      : Math.max(resolution, minResolution);\n    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);\n\n    // calculate center\n    const rotation = this.getRotation();\n    const sinAngle = Math.sin(rotation);\n    const cosAngle = Math.cos(rotation);\n    const centerRot = getCenter(rotatedExtent);\n    centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;\n    centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;\n    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\n    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\n    const center = this.getConstrainedCenter([centerX, centerY], resolution);\n    const callback = options.callback ? options.callback : VOID;\n\n    if (options.duration !== undefined) {\n      this.animateInternal(\n        {\n          resolution: resolution,\n          center: center,\n          duration: options.duration,\n          easing: options.easing,\n        },\n        callback\n      );\n    } else {\n      this.targetResolution_ = resolution;\n      this.targetCenter_ = center;\n      this.applyTargetState_(false, true);\n      animationCallback(callback, true);\n    }\n  }\n\n  /**\n   * Center on coordinate and view position.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   * @api\n   */\n  centerOn(coordinate, size, position) {\n    this.centerOnInternal(\n      fromUserCoordinate(coordinate, this.getProjection()),\n      size,\n      position\n    );\n  }\n\n  /**\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   */\n  centerOnInternal(coordinate, size, position) {\n    this.setCenterInternal(\n      calculateCenterOn(\n        coordinate,\n        size,\n        position,\n        this.getResolution(),\n        this.getRotation()\n      )\n    );\n  }\n\n  /**\n   * Calculates the shift between map and viewport center.\n   * @param {import(\"./coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {import(\"./size.js\").Size} size Size.\n   * @return {Array<number>|undefined} Center shift.\n   */\n  calculateCenterShift(center, resolution, rotation, size) {\n    let centerShift;\n    const padding = this.padding_;\n    if (padding && center) {\n      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);\n      const shiftedCenter = calculateCenterOn(\n        center,\n        size,\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation\n      );\n      centerShift = [\n        center[0] - shiftedCenter[0],\n        center[1] - shiftedCenter[1],\n      ];\n    }\n    return centerShift;\n  }\n\n  /**\n   * @return {boolean} Is defined.\n   */\n  isDef() {\n    return !!this.getCenterInternal() && this.getResolution() !== undefined;\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   * @api\n   */\n  adjustCenter(deltaCoordinates) {\n    const center = toUserCoordinate(this.targetCenter_, this.getProjection());\n    this.setCenter([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   */\n  adjustCenterInternal(deltaCoordinates) {\n    const center = this.targetCenter_;\n    this.setCenterInternal([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n   * @api\n   */\n  adjustResolution(ratio, opt_anchor) {\n    const anchor =\n      opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());\n    this.adjustResolutionInternal(ratio, anchor);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n   */\n  adjustResolutionInternal(ratio, opt_anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const size = this.getViewportSize_(this.getRotation());\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_ * ratio,\n      0,\n      size,\n      isMoving\n    );\n\n    if (opt_anchor) {\n      this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);\n    }\n\n    this.targetResolution_ *= ratio;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Adds a value to the view zoom level, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom level.\n   * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n   * @api\n   */\n  adjustZoom(delta, opt_anchor) {\n    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);\n  }\n\n  /**\n   * Adds a value to the view rotation, optionally using an anchor. Any rotation\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The rotation center.\n   * @api\n   */\n  adjustRotation(delta, opt_anchor) {\n    if (opt_anchor) {\n      opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());\n    }\n    this.adjustRotationInternal(delta, opt_anchor);\n  }\n\n  /**\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The rotation center.\n   */\n  adjustRotationInternal(delta, opt_anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_ + delta,\n      isMoving\n    );\n    if (opt_anchor) {\n      this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);\n    }\n    this.targetRotation_ += delta;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the center of the current view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n  setCenter(center) {\n    this.setCenterInternal(\n      center ? fromUserCoordinate(center, this.getProjection()) : center\n    );\n  }\n\n  /**\n   * Set the center using the view projection (not the user projection).\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   */\n  setCenterInternal(center) {\n    this.targetCenter_ = center;\n    this.applyTargetState_();\n  }\n\n  /**\n   * @param {import(\"./ViewHint.js\").default} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n  setHint(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  }\n\n  /**\n   * Set the resolution for this view. Any resolution constraint will apply.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n  setResolution(resolution) {\n    this.targetResolution_ = resolution;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the rotation for this view. Any rotation constraint will apply.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  setRotation(rotation) {\n    this.targetRotation_ = rotation;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Zoom to a specific zoom level. Any resolution constrain will apply.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n  setZoom(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  }\n\n  /**\n   * Recompute rotation/resolution/center based on target values.\n   * Note: we have to compute rotation first, then resolution and center considering that\n   * parameters can influence one another in case a view extent constraint is present.\n   * @param {boolean} [opt_doNotCancelAnims] Do not cancel animations.\n   * @param {boolean} [opt_forceMoving] Apply constraints as if the view is moving.\n   * @private\n   */\n  applyTargetState_(opt_doNotCancelAnims, opt_forceMoving) {\n    const isMoving =\n      this.getAnimating() || this.getInteracting() || opt_forceMoving;\n\n    // compute rotation\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_,\n      isMoving\n    );\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      0,\n      size,\n      isMoving\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      isMoving,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size\n      )\n    );\n\n    if (this.get(ViewProperty.ROTATION) !== newRotation) {\n      this.set(ViewProperty.ROTATION, newRotation);\n    }\n    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\n      this.set(ViewProperty.RESOLUTION, newResolution);\n      this.set('zoom', this.getZoom(), true);\n    }\n    if (\n      !newCenter ||\n      !this.get(ViewProperty.CENTER) ||\n      !equals(this.get(ViewProperty.CENTER), newCenter)\n    ) {\n      this.set(ViewProperty.CENTER, newCenter);\n    }\n\n    if (this.getAnimating() && !opt_doNotCancelAnims) {\n      this.cancelAnimations();\n    }\n    this.cancelAnchor_ = undefined;\n  }\n\n  /**\n   * If any constraints need to be applied, an animation will be triggered.\n   * This is typically done on interaction end.\n   * Note: calling this with a duration of 0 will apply the constrained values straight away,\n   * without animation.\n   * @param {number} [opt_duration] The animation duration in ms.\n   * @param {number} [opt_resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n   */\n  resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor) {\n    const duration = opt_duration !== undefined ? opt_duration : 200;\n    const direction = opt_resolutionDirection || 0;\n\n    const newRotation = this.constraints_.rotation(this.targetRotation_);\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      direction,\n      size\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      false,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size\n      )\n    );\n\n    if (duration === 0 && !this.cancelAnchor_) {\n      this.targetResolution_ = newResolution;\n      this.targetRotation_ = newRotation;\n      this.targetCenter_ = newCenter;\n      this.applyTargetState_();\n      return;\n    }\n\n    const anchor =\n      opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);\n    this.cancelAnchor_ = undefined;\n\n    if (\n      this.getResolution() !== newResolution ||\n      this.getRotation() !== newRotation ||\n      !this.getCenterInternal() ||\n      !equals(this.getCenterInternal(), newCenter)\n    ) {\n      if (this.getAnimating()) {\n        this.cancelAnimations();\n      }\n\n      this.animateInternal({\n        rotation: newRotation,\n        center: newCenter,\n        resolution: newResolution,\n        duration: duration,\n        easing: easeOut,\n        anchor: anchor,\n      });\n    }\n  }\n\n  /**\n   * Notify the View that an interaction has started.\n   * The view state will be resolved to a stable one if needed\n   * (depending on its constraints).\n   * @api\n   */\n  beginInteraction() {\n    this.resolveConstraints(0);\n\n    this.setHint(ViewHint.INTERACTING, 1);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [opt_duration] Animation duration in ms.\n   * @param {number} [opt_resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n   * @api\n   */\n  endInteraction(opt_duration, opt_resolutionDirection, opt_anchor) {\n    const anchor =\n      opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());\n    this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [opt_duration] Animation duration in ms.\n   * @param {number} [opt_resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n   */\n  endInteractionInternal(opt_duration, opt_resolutionDirection, opt_anchor) {\n    this.setHint(ViewHint.INTERACTING, -1);\n\n    this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);\n  }\n\n  /**\n   * Get a valid position for the view center according to the current constraints.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} targetCenter Target center position.\n   * @param {number} [opt_targetResolution] Target resolution. If not supplied, the current one will be used.\n   * This is useful to guess a valid center position at a different zoom level.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Valid center position.\n   */\n  getConstrainedCenter(targetCenter, opt_targetResolution) {\n    const size = this.getViewportSize_(this.getRotation());\n    return this.constraints_.center(\n      targetCenter,\n      opt_targetResolution || this.getResolution(),\n      size\n    );\n  }\n\n  /**\n   * Get a valid zoom level according to the current view constraints.\n   * @param {number|undefined} targetZoom Target zoom.\n   * @param {number} [opt_direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid zoom level.\n   */\n  getConstrainedZoom(targetZoom, opt_direction) {\n    const targetRes = this.getResolutionForZoom(targetZoom);\n    return this.getZoomForResolution(\n      this.getConstrainedResolution(targetRes, opt_direction)\n    );\n  }\n\n  /**\n   * Get a valid resolution according to the current view constraints.\n   * @param {number|undefined} targetResolution Target resolution.\n   * @param {number} [opt_direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid resolution.\n   */\n  getConstrainedResolution(targetResolution, opt_direction) {\n    const direction = opt_direction || 0;\n    const size = this.getViewportSize_(this.getRotation());\n\n    return this.constraints_.resolution(targetResolution, direction, size);\n  }\n}\n\n/**\n * @param {Function} callback Callback.\n * @param {*} returnValue Return value.\n */\nfunction animationCallback(callback, returnValue) {\n  setTimeout(function () {\n    callback(returnValue);\n  }, 0);\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./centerconstraint.js\").Type} The constraint.\n */\nexport function createCenterConstraint(options) {\n  if (options.extent !== undefined) {\n    const smooth =\n      options.smoothExtentConstraint !== undefined\n        ? options.smoothExtentConstraint\n        : true;\n    return createExtent(options.extent, options.constrainOnlyCenter, smooth);\n  }\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  if (options.multiWorld !== true && projection.isGlobal()) {\n    const extent = projection.getExtent().slice();\n    extent[0] = -Infinity;\n    extent[2] = Infinity;\n    return createExtent(extent, false, false);\n  }\n\n  return centerNone;\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\nexport function createResolutionConstraint(options) {\n  let resolutionConstraint;\n  let maxResolution;\n  let minResolution;\n\n  // TODO: move these to be ol constants\n  // see https://github.com/openlayers/openlayers/issues/2076\n  const defaultMaxZoom = 28;\n  const defaultZoomFactor = 2;\n\n  let minZoom =\n    options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n\n  let maxZoom =\n    options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n\n  const zoomFactor =\n    options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n\n  const multiWorld =\n    options.multiWorld !== undefined ? options.multiWorld : false;\n\n  const smooth =\n    options.smoothResolutionConstraint !== undefined\n      ? options.smoothResolutionConstraint\n      : true;\n\n  const showFullExtent =\n    options.showFullExtent !== undefined ? options.showFullExtent : false;\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  const projExtent = projection.getExtent();\n  let constrainOnlyCenter = options.constrainOnlyCenter;\n  let extent = options.extent;\n  if (!multiWorld && !extent && projection.isGlobal()) {\n    constrainOnlyCenter = false;\n    extent = projExtent;\n  }\n\n  if (options.resolutions !== undefined) {\n    const resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution =\n      resolutions[maxZoom] !== undefined\n        ? resolutions[maxZoom]\n        : resolutions[resolutions.length - 1];\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToResolutions(\n        resolutions,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    }\n  } else {\n    // calculate the default min and max resolution\n    const size = !projExtent\n      ? // use an extent that can fit the whole world if need be\n        (360 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit()\n      : Math.max(getWidth(projExtent), getHeight(projExtent));\n\n    const defaultMaxResolution =\n      size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n\n    const defaultMinResolution =\n      defaultMaxResolution /\n      Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\n\n    // user provided maxResolution takes precedence\n    maxResolution = options.maxResolution;\n    if (maxResolution !== undefined) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    }\n\n    // user provided minResolution takes precedence\n    minResolution = options.minResolution;\n    if (minResolution === undefined) {\n      if (options.maxZoom !== undefined) {\n        if (options.maxResolution !== undefined) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    }\n\n    // given discrete zoom levels, minResolution may be different than provided\n    maxZoom =\n      minZoom +\n      Math.floor(\n        Math.log(maxResolution / minResolution) / Math.log(zoomFactor)\n      );\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToPower(\n        zoomFactor,\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent\n      );\n    }\n  }\n  return {\n    constraint: resolutionConstraint,\n    maxResolution: maxResolution,\n    minResolution: minResolution,\n    minZoom: minZoom,\n    zoomFactor: zoomFactor,\n  };\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\n */\nexport function createRotationConstraint(options) {\n  const enableRotation =\n    options.enableRotation !== undefined ? options.enableRotation : true;\n  if (enableRotation) {\n    const constrainRotation = options.constrainRotation;\n    if (constrainRotation === undefined || constrainRotation === true) {\n      return createSnapToZero();\n    } else if (constrainRotation === false) {\n      return rotationNone;\n    } else if (typeof constrainRotation === 'number') {\n      return createSnapToN(constrainRotation);\n    } else {\n      return rotationNone;\n    }\n  } else {\n    return disable;\n  }\n}\n\n/**\n * Determine if an animation involves no view change.\n * @param {Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\nexport function isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {import(\"./size.js\").Size} size Box pixel size.\n * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @return {import(\"./coordinate.js\").Coordinate} Shifted center.\n */\nfunction calculateCenterOn(coordinate, size, position, resolution, rotation) {\n  // calculate rotated position\n  const cosAngle = Math.cos(-rotation);\n  let sinAngle = Math.sin(-rotation);\n  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  rotX += (size[0] / 2 - position[0]) * resolution;\n  rotY += (position[1] - size[1] / 2) * resolution;\n\n  // go back to original angle\n  sinAngle = -sinAngle; // go back to original rotation\n  const centerX = rotX * cosAngle - rotY * sinAngle;\n  const centerY = rotY * cosAngle + rotX * sinAngle;\n\n  return [centerX, centerY];\n}\n\nexport default View;\n"],
  "mappings": "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",
  "names": ["offset", "none", "offset", "squaredDistance", "offset", "LinearRing", "coordinates", "offset", "offset", "offset", "offset", "offset", "offset", "__extends", "Polygon", "coordinates", "linearRing", "linearRings", "offset", "offset", "__extends", "View", "offset", "none"]
}
