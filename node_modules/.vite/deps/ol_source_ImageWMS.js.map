{
  "version": 3,
  "sources": ["../../ol/src/reproj/Image.js", "../../ol/src/source/Image.js", "../../ol/src/source/ImageWMS.js"],
  "sourcesContent": ["/**\n * @module ol/reproj/Image\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport ImageBase from '../ImageBase.js';\nimport ImageState from '../ImageState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceResolution,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {getCenter, getHeight, getIntersection, getWidth} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(import(\"../extent.js\").Extent, number, number) : import(\"../ImageBase.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected image.\n * See {@link module:ol/source/Image~ImageSource}.\n */\nclass ReprojImage extends ImageBase {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection (of the data).\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent.\n   * @param {number} targetResolution Target resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {FunctionType} getImageFunction\n   *     Function returning source images (extent, resolution, pixelRatio).\n   * @param {boolean} interpolate Use linear interpolation when resampling.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    targetResolution,\n    pixelRatio,\n    getImageFunction,\n    interpolate\n  ) {\n    const maxSourceExtent = sourceProj.getExtent();\n    const maxTargetExtent = targetProj.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    const targetCenter = getCenter(limitedTargetExtent);\n    const sourceResolution = calculateSourceResolution(\n      sourceProj,\n      targetProj,\n      targetCenter,\n      targetResolution\n    );\n\n    const errorThresholdInPixels = ERROR_THRESHOLD;\n\n    const triangulation = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    const sourceExtent = triangulation.calculateSourceExtent();\n    const sourceImage = getImageFunction(\n      sourceExtent,\n      sourceResolution,\n      pixelRatio\n    );\n    const state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;\n    const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;\n\n    super(targetExtent, targetResolution, sourcePixelRatio, state);\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.targetProj_ = targetProj;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = triangulation;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.targetResolution_ = targetResolution;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.targetExtent_ = targetExtent;\n\n    /**\n     * @private\n     * @type {import(\"../ImageBase.js\").default}\n     */\n    this.sourceImage_ = sourceImage;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourcePixelRatio_ = sourcePixelRatio;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.interpolate_ = interpolate;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceListenerKey_ = null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.state == ImageState.LOADING) {\n      this.unlistenSource_();\n    }\n    super.disposeInternal();\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  getProjection() {\n    return this.targetProj_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sourceState = this.sourceImage_.getState();\n    if (sourceState == ImageState.LOADED) {\n      const width = getWidth(this.targetExtent_) / this.targetResolution_;\n      const height = getHeight(this.targetExtent_) / this.targetResolution_;\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.sourcePixelRatio_,\n        this.sourceImage_.getResolution(),\n        this.maxSourceExtent_,\n        this.targetResolution_,\n        this.targetExtent_,\n        this.triangulation_,\n        [\n          {\n            extent: this.sourceImage_.getExtent(),\n            image: this.sourceImage_.getImage(),\n          },\n        ],\n        0,\n        undefined,\n        this.interpolate_\n      );\n    }\n    this.state = sourceState;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n\n      const sourceState = this.sourceImage_.getState();\n      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n        this.reproject_();\n      } else {\n        this.sourceListenerKey_ = listen(\n          this.sourceImage_,\n          EventType.CHANGE,\n          function (e) {\n            const sourceState = this.sourceImage_.getState();\n            if (\n              sourceState == ImageState.LOADED ||\n              sourceState == ImageState.ERROR\n            ) {\n              this.unlistenSource_();\n              this.reproject_();\n            }\n          },\n          this\n        );\n        this.sourceImage_.load();\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSource_() {\n    unlistenByKey(\n      /** @type {!import(\"../events.js\").EventsKey} */ (this.sourceListenerKey_)\n    );\n    this.sourceListenerKey_ = null;\n  }\n}\n\nexport default ReprojImage;\n", "/**\n * @module ol/source/Image\n */\nimport Event from '../events/Event.js';\nimport ImageState from '../ImageState.js';\nimport ReprojImage from '../reproj/Image.js';\nimport Source from './Source.js';\nimport {ENABLE_RASTER_REPROJECTION} from '../reproj/common.js';\nimport {abstract} from '../util.js';\nimport {equals} from '../extent.js';\nimport {equivalent} from '../proj.js';\nimport {linearFindNearest} from '../array.js';\n\n/**\n * @enum {string}\n */\nexport const ImageSourceEventType = {\n  /**\n   * Triggered when an image starts loading.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart\n   * @api\n   */\n  IMAGELOADSTART: 'imageloadstart',\n\n  /**\n   * Triggered when an image finishes loading.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadend\n   * @api\n   */\n  IMAGELOADEND: 'imageloadend',\n\n  /**\n   * Triggered if image loading results in an error.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror\n   * @api\n   */\n  IMAGELOADERROR: 'imageloaderror',\n};\n\n/**\n * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this\n * type.\n */\nexport class ImageSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Image.js\").default} image The image.\n   */\n  constructor(type, image) {\n    super(type);\n\n    /**\n     * The image related to the event.\n     * @type {import(\"../Image.js\").default}\n     * @api\n     */\n    this.image = image;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {Array<number>} [resolutions] Resolutions.\n * @property {import(\"./State.js\").default} [state] State.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing a single image.\n * @abstract\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageSource extends Source {\n  /**\n   * @param {Options} options Single image source options.\n   */\n  constructor(options) {\n    let interpolate =\n      options.imageSmoothing !== undefined ? options.imageSmoothing : true;\n    if (options.interpolate !== undefined) {\n      interpolate = options.interpolate;\n    }\n\n    super({\n      attributions: options.attributions,\n      projection: options.projection,\n      state: options.state,\n      interpolate: interpolate,\n    });\n\n    /***\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ImageSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.resolutions_ =\n      options.resolutions !== undefined ? options.resolutions : null;\n\n    /**\n     * @private\n     * @type {import(\"../reproj/Image.js\").default}\n     */\n    this.reprojectedImage_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.reprojectedRevision_ = 0;\n  }\n\n  /**\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @protected\n   * @param {number} resolution Resolution.\n   * @return {number} Resolution.\n   */\n  findNearestResolution(resolution) {\n    if (this.resolutions_) {\n      const idx = linearFindNearest(this.resolutions_, resolution, 0);\n      resolution = this.resolutions_[idx];\n    }\n    return resolution;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageBase.js\").default} Single image.\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !ENABLE_RASTER_REPROJECTION ||\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      if (sourceProjection) {\n        projection = sourceProjection;\n      }\n      return this.getImageInternal(extent, resolution, pixelRatio, projection);\n    } else {\n      if (this.reprojectedImage_) {\n        if (\n          this.reprojectedRevision_ == this.getRevision() &&\n          equivalent(this.reprojectedImage_.getProjection(), projection) &&\n          this.reprojectedImage_.getResolution() == resolution &&\n          equals(this.reprojectedImage_.getExtent(), extent)\n        ) {\n          return this.reprojectedImage_;\n        }\n        this.reprojectedImage_.dispose();\n        this.reprojectedImage_ = null;\n      }\n\n      this.reprojectedImage_ = new ReprojImage(\n        sourceProjection,\n        projection,\n        extent,\n        resolution,\n        pixelRatio,\n        function (extent, resolution, pixelRatio) {\n          return this.getImageInternal(\n            extent,\n            resolution,\n            pixelRatio,\n            sourceProjection\n          );\n        }.bind(this),\n        this.getInterpolate()\n      );\n      this.reprojectedRevision_ = this.getRevision();\n\n      return this.reprojectedImage_;\n    }\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageBase.js\").default} Single image.\n   * @protected\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Handle image change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleImageChange(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    let type;\n    switch (image.getState()) {\n      case ImageState.LOADING:\n        this.loading = true;\n        type = ImageSourceEventType.IMAGELOADSTART;\n        break;\n      case ImageState.LOADED:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADEND;\n        break;\n      case ImageState.ERROR:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADERROR;\n        break;\n      default:\n        return;\n    }\n    if (this.hasListener(type)) {\n      this.dispatchEvent(new ImageSourceEvent(type, image));\n    }\n  }\n}\n\n/**\n * Default image load function for image sources that use import(\"../Image.js\").Image image\n * instances.\n * @param {import(\"../Image.js\").default} image Image.\n * @param {string} src Source.\n */\nexport function defaultImageLoadFunction(image, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (image.getImage()).src = src;\n}\n\nexport default ImageSource;\n", "/**\n * @module ol/source/ImageWMS\n */\n\nimport {DEFAULT_WMS_VERSION} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport ImageWrapper from '../Image.js';\nimport WMSServerType from './WMSServerType.js';\nimport {appendParams} from '../uri.js';\nimport {assert} from '../asserts.js';\nimport {assign} from '../obj.js';\nimport {calculateSourceResolution} from '../reproj.js';\nimport {ceil, floor, round} from '../math.js';\nimport {compareVersions} from '../string.js';\nimport {\n  containsExtent,\n  getCenter,\n  getForViewAndSize,\n  getHeight,\n  getWidth,\n} from '../extent.js';\nimport {get as getProjection, transform} from '../proj.js';\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nconst DECIMALS = 4;\n\n/**\n * @const\n * @type {import(\"../size.js\").Size}\n */\nconst GETFEATUREINFO_IMAGE_SIZE = [101, 101];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {import(\"./WMSServerType.js\").default|string} [serverType] The type of\n * the remote WMS server: `mapserver`, `geoserver` or `qgis`. Only needed if `hidpi` is `true`.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.\n * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} params WMS request parameters.\n * At least a `LAYERS` param is required. `STYLES` is\n * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`\n * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means\n * twice the width and height of the map viewport, and so on. Must be `1` or\n * higher.\n * @property {Array<number>} [resolutions] Resolutions.\n * If specified, requests will be made for these resolutions only.\n * @property {string} url WMS service URL.\n */\n\n/**\n * @classdesc\n * Source for WMS servers providing single, untiled images.\n *\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageWMS extends ImageSource {\n  /**\n   * @param {Options} [opt_options] ImageWMS options.\n   */\n  constructor(opt_options) {\n    const options = opt_options ? opt_options : {};\n\n    let interpolate =\n      options.imageSmoothing !== undefined ? options.imageSmoothing : true;\n    if (options.interpolate !== undefined) {\n      interpolate = options.interpolate;\n    }\n\n    super({\n      attributions: options.attributions,\n      interpolate: interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions,\n    });\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").LoadFunction}\n     */\n    this.imageLoadFunction_ =\n      options.imageLoadFunction !== undefined\n        ? options.imageLoadFunction\n        : defaultImageLoadFunction;\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = options.params || {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.v13_ = true;\n    this.updateV13_();\n\n    /**\n     * @private\n     * @type {import(\"./WMSServerType.js\").default|undefined}\n     */\n    this.serverType_ =\n      /** @type {import(\"./WMSServerType.js\").default|undefined} */ (\n        options.serverType\n      );\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").default}\n     */\n    this.image_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.imageSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\n  }\n\n  /**\n   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and\n   * projection. Return `undefined` if the GetFeatureInfo URL cannot be\n   * constructed.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should\n   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified\n   *     in the `LAYERS` parameter will be used. `VERSION` should not be\n   *     specified here.\n   * @return {string|undefined} GetFeatureInfo URL.\n   * @api\n   */\n  getFeatureInfoUrl(coordinate, resolution, projection, params) {\n    if (this.url_ === undefined) {\n      return undefined;\n    }\n    const projectionObj = getProjection(projection);\n    const sourceProjectionObj = this.getProjection();\n\n    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {\n      resolution = calculateSourceResolution(\n        sourceProjectionObj,\n        projectionObj,\n        coordinate,\n        resolution\n      );\n      coordinate = transform(coordinate, projectionObj, sourceProjectionObj);\n    }\n\n    const extent = getForViewAndSize(\n      coordinate,\n      resolution,\n      0,\n      GETFEATUREINFO_IMAGE_SIZE\n    );\n\n    const baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_WMS_VERSION,\n      'REQUEST': 'GetFeatureInfo',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true,\n      'QUERY_LAYERS': this.params_['LAYERS'],\n    };\n    assign(baseParams, this.params_, params);\n\n    const x = floor((coordinate[0] - extent[0]) / resolution, DECIMALS);\n    const y = floor((extent[3] - coordinate[1]) / resolution, DECIMALS);\n    baseParams[this.v13_ ? 'I' : 'X'] = x;\n    baseParams[this.v13_ ? 'J' : 'Y'] = y;\n\n    return this.getRequestUrl_(\n      extent,\n      GETFEATUREINFO_IMAGE_SIZE,\n      1,\n      sourceProjectionObj || projectionObj,\n      baseParams\n    );\n  }\n\n  /**\n   * Return the GetLegendGraphic URL, optionally optimized for the passed\n   * resolution and possibly including any passed specific parameters. Returns\n   * `undefined` if the GetLegendGraphic URL cannot be constructed.\n   *\n   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`\n   *     will not be calculated and included in URL.\n   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the\n   *     request is generated for this wms layer, else it will try to use the\n   *     configured wms layer. Default `FORMAT` is `image/png`.\n   *     `VERSION` should not be specified here.\n   * @return {string|undefined} GetLegendGraphic URL.\n   * @api\n   */\n  getLegendUrl(resolution, params) {\n    if (this.url_ === undefined) {\n      return undefined;\n    }\n\n    const baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_WMS_VERSION,\n      'REQUEST': 'GetLegendGraphic',\n      'FORMAT': 'image/png',\n    };\n\n    if (params === undefined || params['LAYER'] === undefined) {\n      const layers = this.params_.LAYERS;\n      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;\n      if (!isSingleLayer) {\n        return undefined;\n      }\n      baseParams['LAYER'] = layers;\n    }\n\n    if (resolution !== undefined) {\n      const mpu = this.getProjection()\n        ? this.getProjection().getMetersPerUnit()\n        : 1;\n      const pixelSize = 0.00028;\n      baseParams['SCALE'] = (resolution * mpu) / pixelSize;\n    }\n\n    assign(baseParams, params);\n\n    return appendParams(/** @type {string} */ (this.url_), baseParams);\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (this.url_ === undefined) {\n      return null;\n    }\n\n    resolution = this.findNearestResolution(resolution);\n\n    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {\n      pixelRatio = 1;\n    }\n\n    const imageResolution = resolution / pixelRatio;\n\n    const center = getCenter(extent);\n    const viewWidth = ceil(getWidth(extent) / imageResolution, DECIMALS);\n    const viewHeight = ceil(getHeight(extent) / imageResolution, DECIMALS);\n    const viewExtent = getForViewAndSize(center, imageResolution, 0, [\n      viewWidth,\n      viewHeight,\n    ]);\n    const requestWidth = ceil(\n      (this.ratio_ * getWidth(extent)) / imageResolution,\n      DECIMALS\n    );\n    const requestHeight = ceil(\n      (this.ratio_ * getHeight(extent)) / imageResolution,\n      DECIMALS\n    );\n    const requestExtent = getForViewAndSize(center, imageResolution, 0, [\n      requestWidth,\n      requestHeight,\n    ]);\n\n    const image = this.image_;\n    if (\n      image &&\n      this.renderedRevision_ == this.getRevision() &&\n      image.getResolution() == resolution &&\n      image.getPixelRatio() == pixelRatio &&\n      containsExtent(image.getExtent(), viewExtent)\n    ) {\n      return image;\n    }\n\n    const params = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_WMS_VERSION,\n      'REQUEST': 'GetMap',\n      'FORMAT': 'image/png',\n      'TRANSPARENT': true,\n    };\n    assign(params, this.params_);\n\n    this.imageSize_[0] = round(\n      getWidth(requestExtent) / imageResolution,\n      DECIMALS\n    );\n    this.imageSize_[1] = round(\n      getHeight(requestExtent) / imageResolution,\n      DECIMALS\n    );\n\n    const url = this.getRequestUrl_(\n      requestExtent,\n      this.imageSize_,\n      pixelRatio,\n      projection,\n      params\n    );\n\n    this.image_ = new ImageWrapper(\n      requestExtent,\n      resolution,\n      pixelRatio,\n      url,\n      this.crossOrigin_,\n      this.imageLoadFunction_\n    );\n\n    this.renderedRevision_ = this.getRevision();\n\n    this.image_.addEventListener(\n      EventType.CHANGE,\n      this.handleImageChange.bind(this)\n    );\n\n    return this.image_;\n  }\n\n  /**\n   * Return the image load function of the source.\n   * @return {import(\"../Image.js\").LoadFunction} The image load function.\n   * @api\n   */\n  getImageLoadFunction() {\n    return this.imageLoadFunction_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../size.js\").Size} size Size.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {Object} params Params.\n   * @return {string} Request URL.\n   * @private\n   */\n  getRequestUrl_(extent, size, pixelRatio, projection, params) {\n    assert(this.url_ !== undefined, 9); // `url` must be configured or set using `#setUrl()`\n\n    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();\n\n    if (!('STYLES' in this.params_)) {\n      params['STYLES'] = '';\n    }\n\n    if (pixelRatio != 1) {\n      switch (this.serverType_) {\n        case WMSServerType.GEOSERVER:\n          const dpi = (90 * pixelRatio + 0.5) | 0;\n          if ('FORMAT_OPTIONS' in params) {\n            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;\n          } else {\n            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;\n          }\n          break;\n        case WMSServerType.MAPSERVER:\n          params['MAP_RESOLUTION'] = 90 * pixelRatio;\n          break;\n        case WMSServerType.CARMENTA_SERVER:\n        case WMSServerType.QGIS:\n          params['DPI'] = 90 * pixelRatio;\n          break;\n        default:\n          assert(false, 8); // Unknown `serverType` configured\n          break;\n      }\n    }\n\n    params['WIDTH'] = size[0];\n    params['HEIGHT'] = size[1];\n\n    const axisOrientation = projection.getAxisOrientation();\n    let bbox;\n    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {\n      bbox = [extent[1], extent[0], extent[3], extent[2]];\n    } else {\n      bbox = extent;\n    }\n    params['BBOX'] = bbox.join(',');\n\n    return appendParams(/** @type {string} */ (this.url_), params);\n  }\n\n  /**\n   * Return the URL used for this WMS source.\n   * @return {string|undefined} URL.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * Set the image load function of the source.\n   * @param {import(\"../Image.js\").LoadFunction} imageLoadFunction Image load function.\n   * @api\n   */\n  setImageLoadFunction(imageLoadFunction) {\n    this.image_ = null;\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string|undefined} url URL.\n   * @api\n   */\n  setUrl(url) {\n    if (url != this.url_) {\n      this.url_ = url;\n      this.image_ = null;\n      this.changed();\n    }\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    assign(this.params_, params);\n    this.updateV13_();\n    this.image_ = null;\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  updateV13_() {\n    const version = this.params_['VERSION'] || DEFAULT_WMS_VERSION;\n    this.v13_ = compareVersions(version, '1.3') >= 0;\n  }\n}\n\nexport default ImageWMS;\n"],
  "mappings": "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",
  "names": ["ReprojImage", "sourceState", "Image_default", "__extends", "ImageSourceEvent", "__extends", "ImageSource", "Image_default", "extent", "resolution", "pixelRatio", "__extends", "ImageWMS", "Image_default"]
}
