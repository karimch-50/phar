import {
  AbortException,
  AnnotationActionEventType,
  AnnotationBorderStyleType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationReplyType,
  AnnotationType,
  BaseException,
  CMapCompressionType,
  DocumentActionEventType,
  FONT_IDENTITY_MATRIX,
  FontType,
  FormatError,
  IDENTITY_MATRIX,
  ImageKind,
  InvalidPDFException,
  IsEvalSupportedCached,
  MissingPDFException,
  OPS,
  PageActionEventType,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  StreamType,
  TextRenderingMode,
  UNSUPPORTED_FEATURES,
  UnexpectedResponseException,
  UnknownErrorException,
  Util,
  VerbosityLevel,
  arrayByteLength,
  arraysToBytes,
  assert,
  bytesToString,
  createPromiseCapability,
  createValidAbsoluteUrl,
  escapeString,
  getModificationDate,
  getVerbosityLevel,
  info,
  init_util,
  isArrayBuffer,
  isArrayEqual,
  isAscii,
  isBool,
  isNodeJS,
  isNum,
  isString,
  objectSize,
  setVerbosityLevel,
  shadow,
  string32,
  stringToBytes,
  stringToPDFString,
  stringToUTF16BEString,
  stringToUTF8String,
  unreachable,
  utf8StringToString,
  warn
} from "./chunk-U4PJHKRL.js";
import {
  __export
} from "./chunk-WGAPYIUP.js";

// node_modules/@vaadin-component-factory/vcf-pdf-viewer/pdfjs/dist/worker.js
var worker_exports = {};
__export(worker_exports, {
  WorkerMessageHandler: () => WorkerMessageHandler,
  WorkerTask: () => WorkerTask
});
init_util();

// node_modules/@vaadin-component-factory/vcf-pdf-viewer/pdfjs/dist/message_handler.js
init_util();
var CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
var StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function wrapReason(reason) {
  if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
    assert(reason instanceof Error || typeof reason === "object" && reason !== null, 'wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  } else {
    if (typeof reason !== "object" || reason === null) {
      return reason;
    }
  }
  switch (reason.name) {
    case "AbortException":
      return new AbortException(reason.message);
    case "MissingPDFException":
      return new MissingPDFException(reason.message);
    case "UnexpectedResponseException":
      return new UnexpectedResponseException(reason.message, reason.status);
    case "UnknownErrorException":
      return new UnknownErrorException(reason.message, reason.details);
    default:
      return new UnknownErrorException(reason.message, reason.toString());
  }
}
var MessageHandler = class {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.postMessageTransfers = true;
    this.streamSinks = /* @__PURE__ */ Object.create(null);
    this.streamControllers = /* @__PURE__ */ Object.create(null);
    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
    this.actionHandler = /* @__PURE__ */ Object.create(null);
    this._onComObjOnMessage = (event) => {
      const data = event.data;
      if (data.targetName !== this.sourceName) {
        return;
      }
      if (data.stream) {
        this._processStreamMessage(data);
        return;
      }
      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];
        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }
        delete this.callbackCapabilities[callbackId];
        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }
        return;
      }
      const action = this.actionHandler[data.action];
      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }
      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function(resolve) {
          resolve(action(data.data));
        }).then(function(result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }
      if (data.streamId) {
        this._createStreamSink(data);
        return;
      }
      action(data.data);
    };
    comObj.addEventListener("message", this._onComObjOnMessage);
  }
  on(actionName, handler) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(typeof handler === "function", 'MessageHandler.on: Expected "handler" to be a function.');
    }
    const ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }
    ah[actionName] = handler;
  }
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * @param {string} actionName - Action to call.
   * @param {JSON} data - JSON data to send.
   * @param {Array} [transfers] - List of transfers/ArrayBuffers.
   */
  send(actionName, data, transfers) {
    this._postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * Expects that the other side will callback with the response.
   * @param {string} actionName - Action to call.
   * @param {JSON} data - JSON data to send.
   * @param {Array} [transfers] - List of transfers/ArrayBuffers.
   * @returns {Promise} Promise to be resolved with response data.
   */
  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = createPromiseCapability();
    this.callbackCapabilities[callbackId] = capability;
    try {
      this._postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }
    return capability.promise;
  }
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * Expect that the other side will callback to signal 'start_complete'.
   * @param {string} actionName - Action to call.
   * @param {JSON} data - JSON data to send.
   * @param {Object} queueingStrategy - Strategy to signal backpressure based on
   *                 internal queue.
   * @param {Array} [transfers] - List of transfers/ArrayBuffers.
   * @returns {ReadableStream} ReadableStream to read data in chunks.
   */
  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++;
    const sourceName = this.sourceName;
    const targetName = this.targetName;
    const comObj = this.comObj;
    return new ReadableStream({
      start: (controller) => {
        const startCapability = createPromiseCapability();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        this._postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: (controller) => {
        const pullCapability = createPromiseCapability();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: (reason) => {
        assert(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = createPromiseCapability();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }
  /**
   * @private
   */
  _createStreamSink(data) {
    const self2 = this;
    const action = this.actionHandler[data.action];
    const streamId = data.streamId;
    const sourceName = this.sourceName;
    const targetName = data.sourceName;
    const comObj = this.comObj;
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }
        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;
        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = createPromiseCapability();
          this.ready = this.sinkCapability.promise;
        }
        self2._postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },
      close() {
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self2.streamSinks[streamId];
      },
      error(reason) {
        assert(reason instanceof Error, "error must have a valid reason");
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },
      sinkCapability: createPromiseCapability(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function(resolve) {
      resolve(action(data.data, streamSink));
    }).then(function() {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function(reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }
  /**
   * @private
   */
  _processStreamMessage(data) {
    const streamId = data.streamId;
    const sourceName = this.sourceName;
    const targetName = data.sourceName;
    const comObj = this.comObj;
    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          this.streamControllers[streamId].startCall.resolve();
        } else {
          this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          this.streamControllers[streamId].pullCall.resolve();
        } else {
          this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL:
        if (!this.streamSinks[streamId]) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }
        if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
          this.streamSinks[streamId].sinkCapability.resolve();
        }
        this.streamSinks[streamId].desiredSize = data.desiredSize;
        const {
          onPull
        } = this.streamSinks[data.streamId];
        new Promise(function(resolve) {
          resolve(onPull && onPull());
        }).then(function() {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;
      case StreamKind.ENQUEUE:
        assert(this.streamControllers[streamId], "enqueue should have stream controller");
        if (this.streamControllers[streamId].isClosed) {
          break;
        }
        this.streamControllers[streamId].controller.enqueue(data.chunk);
        break;
      case StreamKind.CLOSE:
        assert(this.streamControllers[streamId], "close should have stream controller");
        if (this.streamControllers[streamId].isClosed) {
          break;
        }
        this.streamControllers[streamId].isClosed = true;
        this.streamControllers[streamId].controller.close();
        this._deleteStreamController(streamId);
        break;
      case StreamKind.ERROR:
        assert(this.streamControllers[streamId], "error should have stream controller");
        this.streamControllers[streamId].controller.error(wrapReason(data.reason));
        this._deleteStreamController(streamId);
        break;
      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          this.streamControllers[streamId].cancelCall.resolve();
        } else {
          this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
        }
        this._deleteStreamController(streamId);
        break;
      case StreamKind.CANCEL:
        if (!this.streamSinks[streamId]) {
          break;
        }
        const {
          onCancel
        } = this.streamSinks[data.streamId];
        new Promise(function(resolve) {
          resolve(onCancel && onCancel(wrapReason(data.reason)));
        }).then(function() {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
        this.streamSinks[streamId].isCancelled = true;
        delete this.streamSinks[streamId];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  /**
   * @private
   */
  async _deleteStreamController(streamId) {
    await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function(capability) {
      return capability && capability.promise;
    }));
    delete this.streamControllers[streamId];
  }
  /**
   * Sends raw message to the comObj.
   * @param {Object} message - Raw message.
   * @param transfers List of transfers/ArrayBuffers, or undefined.
   * @private
   */
  _postMessage(message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
};

// node_modules/@vaadin-component-factory/vcf-pdf-viewer/pdfjs/dist/worker.js
var BaseStream = class _BaseStream {
  constructor() {
    if (this.constructor === _BaseStream) {
      unreachable("Cannot initialize BaseStream.");
    }
  }
  // eslint-disable-next-line getter-return
  get length() {
    unreachable("Abstract getter `length` accessed");
  }
  // eslint-disable-next-line getter-return
  get isEmpty() {
    unreachable("Abstract getter `isEmpty` accessed");
  }
  get isDataLoaded() {
    return shadow(this, "isDataLoaded", true);
  }
  getByte() {
    unreachable("Abstract method `getByte` called");
  }
  getBytes(length, forceClamped = false) {
    unreachable("Abstract method `getBytes` called");
  }
  peekByte() {
    const peekedByte = this.getByte();
    if (peekedByte !== -1) {
      this.pos--;
    }
    return peekedByte;
  }
  peekBytes(length, forceClamped = false) {
    const bytes = this.getBytes(length, forceClamped);
    this.pos -= bytes.length;
    return bytes;
  }
  getUint16() {
    const b0 = this.getByte();
    const b1 = this.getByte();
    if (b0 === -1 || b1 === -1) {
      return -1;
    }
    return (b0 << 8) + b1;
  }
  getInt32() {
    const b0 = this.getByte();
    const b1 = this.getByte();
    const b2 = this.getByte();
    const b3 = this.getByte();
    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
  }
  getByteRange(begin, end) {
    unreachable("Abstract method `getByteRange` called");
  }
  getString(length) {
    return bytesToString(this.getBytes(
      length,
      /* forceClamped = */
      false
    ));
  }
  skip(n) {
    this.pos += n || 1;
  }
  reset() {
    unreachable("Abstract method `reset` called");
  }
  moveStart() {
    unreachable("Abstract method `moveStart` called");
  }
  makeSubStream(start, length, dict = null) {
    unreachable("Abstract method `makeSubStream` called");
  }
  /**
   * @returns {Array | null}
   */
  getBaseStreams() {
    return null;
  }
};
var EOF = {};
var Name = /* @__PURE__ */ function NameClosure() {
  let nameCache = /* @__PURE__ */ Object.create(null);
  class Name2 {
    constructor(name) {
      this.name = name;
    }
    static get(name) {
      const nameValue = nameCache[name];
      return nameValue ? nameValue : nameCache[name] = new Name2(name);
    }
    static _clearCache() {
      nameCache = /* @__PURE__ */ Object.create(null);
    }
  }
  return Name2;
}();
var Cmd = /* @__PURE__ */ function CmdClosure() {
  let cmdCache = /* @__PURE__ */ Object.create(null);
  class Cmd2 {
    constructor(cmd) {
      this.cmd = cmd;
    }
    static get(cmd) {
      const cmdValue = cmdCache[cmd];
      return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd2(cmd);
    }
    static _clearCache() {
      cmdCache = /* @__PURE__ */ Object.create(null);
    }
  }
  return Cmd2;
}();
var nonSerializable = function nonSerializableClosure() {
  return nonSerializable;
};
var Dict = class _Dict {
  constructor(xref = null) {
    this._map = /* @__PURE__ */ Object.create(null);
    this.xref = xref;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = nonSerializable;
  }
  assignXref(newXref) {
    this.xref = newXref;
  }
  get size() {
    return Object.keys(this._map).length;
  }
  // Automatically dereferences Ref objects.
  get(key1, key2, key3) {
    let value = this._map[key1];
    if (value === void 0 && key2 !== void 0) {
      value = this._map[key2];
      if (value === void 0 && key3 !== void 0) {
        value = this._map[key3];
      }
    }
    if (value instanceof Ref && this.xref) {
      return this.xref.fetch(value, this.suppressEncryption);
    }
    return value;
  }
  // Same as get(), but returns a promise and uses fetchIfRefAsync().
  async getAsync(key1, key2, key3) {
    let value = this._map[key1];
    if (value === void 0 && key2 !== void 0) {
      value = this._map[key2];
      if (value === void 0 && key3 !== void 0) {
        value = this._map[key3];
      }
    }
    if (value instanceof Ref && this.xref) {
      return this.xref.fetchAsync(value, this.suppressEncryption);
    }
    return value;
  }
  // Same as get(), but dereferences all elements if the result is an Array.
  getArray(key1, key2, key3) {
    let value = this._map[key1];
    if (value === void 0 && key2 !== void 0) {
      value = this._map[key2];
      if (value === void 0 && key3 !== void 0) {
        value = this._map[key3];
      }
    }
    if (value instanceof Ref && this.xref) {
      value = this.xref.fetch(value, this.suppressEncryption);
    }
    if (Array.isArray(value)) {
      value = value.slice();
      for (let i = 0, ii = value.length; i < ii; i++) {
        if (value[i] instanceof Ref && this.xref) {
          value[i] = this.xref.fetch(value[i], this.suppressEncryption);
        }
      }
    }
    return value;
  }
  // No dereferencing.
  getRaw(key) {
    return this._map[key];
  }
  getKeys() {
    return Object.keys(this._map);
  }
  // No dereferencing.
  getRawValues() {
    return Object.values(this._map);
  }
  set(key, value) {
    if ((typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) && value === void 0) {
      unreachable('Dict.set: The "value" cannot be undefined.');
    }
    this._map[key] = value;
  }
  has(key) {
    return this._map[key] !== void 0;
  }
  forEach(callback) {
    for (const key in this._map) {
      callback(key, this.get(key));
    }
  }
  static get empty() {
    const emptyDict = new _Dict(null);
    emptyDict.set = (key, value) => {
      unreachable("Should not call `set` on the empty dictionary.");
    };
    return shadow(this, "empty", emptyDict);
  }
  static merge({
    xref,
    dictArray,
    mergeSubDicts = false
  }) {
    const mergedDict = new _Dict(xref), properties = /* @__PURE__ */ new Map();
    for (const dict of dictArray) {
      if (!(dict instanceof _Dict)) {
        continue;
      }
      for (const [key, value] of Object.entries(dict._map)) {
        let property = properties.get(key);
        if (property === void 0) {
          property = [];
          properties.set(key, property);
        } else if (!mergeSubDicts) {
          continue;
        }
        property.push(value);
      }
    }
    for (const [name, values] of properties) {
      if (values.length === 1 || !(values[0] instanceof _Dict)) {
        mergedDict._map[name] = values[0];
        continue;
      }
      const subDict = new _Dict(xref);
      for (const dict of values) {
        if (!(dict instanceof _Dict)) {
          continue;
        }
        for (const [key, value] of Object.entries(dict._map)) {
          if (subDict._map[key] === void 0) {
            subDict._map[key] = value;
          }
        }
      }
      if (subDict.size > 0) {
        mergedDict._map[name] = subDict;
      }
    }
    properties.clear();
    return mergedDict.size > 0 ? mergedDict : _Dict.empty;
  }
};
var Ref = /* @__PURE__ */ function RefClosure() {
  let refCache = /* @__PURE__ */ Object.create(null);
  class Ref2 {
    constructor(num, gen) {
      this.num = num;
      this.gen = gen;
    }
    toString() {
      if (this.gen === 0) {
        return `${this.num}R`;
      }
      return `${this.num}R${this.gen}`;
    }
    static get(num, gen) {
      const key = gen === 0 ? `${num}R` : `${num}R${gen}`;
      const refValue = refCache[key];
      return refValue ? refValue : refCache[key] = new Ref2(num, gen);
    }
    static _clearCache() {
      refCache = /* @__PURE__ */ Object.create(null);
    }
  }
  return Ref2;
}();
var RefSet = class _RefSet {
  constructor(parent = null) {
    if ((typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) && parent && !(parent instanceof _RefSet)) {
      unreachable('RefSet: Invalid "parent" value.');
    }
    this._set = new Set(parent && parent._set);
  }
  has(ref) {
    return this._set.has(ref.toString());
  }
  put(ref) {
    this._set.add(ref.toString());
  }
  remove(ref) {
    this._set.delete(ref.toString());
  }
  forEach(callback) {
    for (const ref of this._set.values()) {
      callback(ref);
    }
  }
  clear() {
    this._set.clear();
  }
};
var RefSetCache = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._map.size;
  }
  get(ref) {
    return this._map.get(ref.toString());
  }
  has(ref) {
    return this._map.has(ref.toString());
  }
  put(ref, obj) {
    this._map.set(ref.toString(), obj);
  }
  putAlias(ref, aliasRef) {
    this._map.set(ref.toString(), this.get(aliasRef));
  }
  forEach(callback) {
    for (const value of this._map.values()) {
      callback(value);
    }
  }
  clear() {
    this._map.clear();
  }
};
function isEOF(v) {
  return v === EOF;
}
function isName(v, name) {
  return v instanceof Name && (name === void 0 || v.name === name);
}
function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === void 0 || v.cmd === cmd);
}
function isDict(v, type) {
  return v instanceof Dict && (type === void 0 || isName(v.get("Type"), type));
}
function isRef(v) {
  return v instanceof Ref;
}
function isRefsEqual(v1, v2) {
  if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
    assert(v1 instanceof Ref && v2 instanceof Ref, "isRefsEqual: Both parameters should be `Ref`s.");
  }
  return v1.num === v2.num && v1.gen === v2.gen;
}
function isStream(v) {
  return v instanceof BaseStream;
}
function clearPrimitiveCaches() {
  Cmd._clearCache();
  Name._clearCache();
  Ref._clearCache();
}
function getLookupTableFactory(initializer) {
  let lookup;
  return function() {
    if (initializer) {
      lookup = /* @__PURE__ */ Object.create(null);
      initializer(lookup);
      initializer = null;
    }
    return lookup;
  };
}
function getArrayLookupTableFactory(initializer) {
  let lookup;
  return function() {
    if (initializer) {
      let arr = initializer();
      initializer = null;
      lookup = /* @__PURE__ */ Object.create(null);
      for (let i = 0, ii = arr.length; i < ii; i += 2) {
        lookup[arr[i]] = arr[i + 1];
      }
      arr = null;
    }
    return lookup;
  };
}
var MissingDataException = class extends BaseException {
  constructor(begin, end) {
    super(`Missing data [${begin}, ${end})`);
    this.begin = begin;
    this.end = end;
  }
};
var ParserEOFException = class extends BaseException {
};
var XRefEntryException = class extends BaseException {
};
var XRefParseException = class extends BaseException {
};
function getInheritableProperty({
  dict,
  key,
  getArray = false,
  stopWhenFound = true
}) {
  let values;
  const visited = new RefSet();
  while (dict instanceof Dict && !(dict.objId && visited.has(dict.objId))) {
    if (dict.objId) {
      visited.put(dict.objId);
    }
    const value = getArray ? dict.getArray(key) : dict.get(key);
    if (value !== void 0) {
      if (stopWhenFound) {
        return value;
      }
      if (!values) {
        values = [];
      }
      values.push(value);
    }
    dict = dict.get("Parent");
  }
  return values;
}
var ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
function toRomanNumerals(number, lowerCase = false) {
  assert(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
  const romanBuf = [];
  let pos;
  while (number >= 1e3) {
    number -= 1e3;
    romanBuf.push("M");
  }
  pos = number / 100 | 0;
  number %= 100;
  romanBuf.push(ROMAN_NUMBER_MAP[pos]);
  pos = number / 10 | 0;
  number %= 10;
  romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
  romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
  const romanStr = romanBuf.join("");
  return lowerCase ? romanStr.toLowerCase() : romanStr;
}
function log2(x) {
  if (x <= 0) {
    return 0;
  }
  return Math.ceil(Math.log2(x));
}
function readInt8(data, offset) {
  return data[offset] << 24 >> 24;
}
function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}
function readUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 13 || ch === 10;
}
function parseXFAPath(path) {
  const positionPattern = /(.+)\[([0-9]+)\]$/;
  return path.split(".").map((component) => {
    const m = component.match(positionPattern);
    if (m) {
      return {
        name: m[1],
        pos: parseInt(m[2], 10)
      };
    }
    return {
      name: component,
      pos: 0
    };
  });
}
function escapePDFName(str) {
  const buffer = [];
  let start = 0;
  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    if (char < 33 || char > 126 || char === 35 || char === 40 || char === 41 || char === 60 || char === 62 || char === 91 || char === 93 || char === 123 || char === 125 || char === 47 || char === 37) {
      if (start < i) {
        buffer.push(str.substring(start, i));
      }
      buffer.push(`#${char.toString(16)}`);
      start = i + 1;
    }
  }
  if (buffer.length === 0) {
    return str;
  }
  if (start < str.length) {
    buffer.push(str.substring(start, str.length));
  }
  return buffer.join("");
}
function _collectJS(entry, xref, list, parents) {
  if (!entry) {
    return;
  }
  let parent = null;
  if (isRef(entry)) {
    if (parents.has(entry)) {
      return;
    }
    parent = entry;
    parents.put(parent);
    entry = xref.fetch(entry);
  }
  if (Array.isArray(entry)) {
    for (const element of entry) {
      _collectJS(element, xref, list, parents);
    }
  } else if (entry instanceof Dict) {
    if (isName(entry.get("S"), "JavaScript") && entry.has("JS")) {
      const js = entry.get("JS");
      let code;
      if (isStream(js)) {
        code = js.getString();
      } else {
        code = js;
      }
      code = stringToPDFString(code);
      if (code) {
        list.push(code);
      }
    }
    _collectJS(entry.getRaw("Next"), xref, list, parents);
  }
  if (parent) {
    parents.remove(parent);
  }
}
function collectActions(xref, dict, eventType) {
  const actions = /* @__PURE__ */ Object.create(null);
  const additionalActionsDicts = getInheritableProperty({
    dict,
    key: "AA",
    stopWhenFound: false
  });
  if (additionalActionsDicts) {
    for (let i = additionalActionsDicts.length - 1; i >= 0; i--) {
      const additionalActions = additionalActionsDicts[i];
      if (!(additionalActions instanceof Dict)) {
        continue;
      }
      for (const key of additionalActions.getKeys()) {
        const action = eventType[key];
        if (!action) {
          continue;
        }
        const actionDict = additionalActions.getRaw(key);
        const parents = new RefSet();
        const list = [];
        _collectJS(actionDict, xref, list, parents);
        if (list.length > 0) {
          actions[action] = list;
        }
      }
    }
  }
  if (dict.has("A")) {
    const actionDict = dict.get("A");
    const parents = new RefSet();
    const list = [];
    _collectJS(actionDict, xref, list, parents);
    if (list.length > 0) {
      actions.Action = list;
    }
  }
  return objectSize(actions) > 0 ? actions : null;
}
var XMLEntities = {
  /* < */
  60: "&lt;",
  /* > */
  62: "&gt;",
  /* & */
  38: "&amp;",
  /* " */
  34: "&quot;",
  /* ' */
  39: "&apos;"
};
function encodeToXmlString(str) {
  const buffer = [];
  let start = 0;
  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.codePointAt(i);
    if (32 <= char && char <= 126) {
      const entity = XMLEntities[char];
      if (entity) {
        if (start < i) {
          buffer.push(str.substring(start, i));
        }
        buffer.push(entity);
        start = i + 1;
      }
    } else {
      if (start < i) {
        buffer.push(str.substring(start, i));
      }
      buffer.push(`&#x${char.toString(16).toUpperCase()};`);
      if (char > 55295 && (char < 57344 || char > 65533)) {
        i++;
      }
      start = i + 1;
    }
  }
  if (buffer.length === 0) {
    return str;
  }
  if (start < str.length) {
    buffer.push(str.substring(start, str.length));
  }
  return buffer.join("");
}
function validateCSSFont(cssFontInfo) {
  const DEFAULT_CSS_FONT_OBLIQUE = "14";
  const DEFAULT_CSS_FONT_WEIGHT = "400";
  const CSS_FONT_WEIGHT_VALUES = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]);
  const {
    fontFamily,
    fontWeight,
    italicAngle
  } = cssFontInfo;
  if (/^".*"$/.test(fontFamily)) {
    if (/[^\\]"/.test(fontFamily.slice(1, fontFamily.length - 1))) {
      warn(`XFA - FontFamily contains some unescaped ": ${fontFamily}.`);
      return false;
    }
  } else if (/^'.*'$/.test(fontFamily)) {
    if (/[^\\]'/.test(fontFamily.slice(1, fontFamily.length - 1))) {
      warn(`XFA - FontFamily contains some unescaped ': ${fontFamily}.`);
      return false;
    }
  } else {
    for (const ident of fontFamily.split(/[ \t]+/)) {
      if (/^([0-9]|(-([0-9]|-)))/.test(ident) || !/^[a-zA-Z0-9\-_\\]+$/.test(ident)) {
        warn(`XFA - FontFamily contains some invalid <custom-ident>: ${fontFamily}.`);
        return false;
      }
    }
  }
  const weight = fontWeight ? fontWeight.toString() : "";
  cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight) ? weight : DEFAULT_CSS_FONT_WEIGHT;
  const angle = parseFloat(italicAngle);
  cssFontInfo.italicAngle = isNaN(angle) || angle < -90 || angle > 90 ? DEFAULT_CSS_FONT_OBLIQUE : italicAngle.toString();
  return true;
}
var Stream = class _Stream extends BaseStream {
  constructor(arrayBuffer, start, length, dict) {
    super();
    this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
    this.start = start || 0;
    this.pos = this.start;
    this.end = start + length || this.bytes.length;
    this.dict = dict;
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return this.length === 0;
  }
  getByte() {
    if (this.pos >= this.end) {
      return -1;
    }
    return this.bytes[this.pos++];
  }
  getBytes(length, forceClamped = false) {
    const bytes = this.bytes;
    const pos = this.pos;
    const strEnd = this.end;
    if (!length) {
      const subarray2 = bytes.subarray(pos, strEnd);
      return forceClamped ? new Uint8ClampedArray(subarray2) : subarray2;
    }
    let end = pos + length;
    if (end > strEnd) {
      end = strEnd;
    }
    this.pos = end;
    const subarray = bytes.subarray(pos, end);
    return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
  }
  getByteRange(begin, end) {
    if (begin < 0) {
      begin = 0;
    }
    if (end > this.end) {
      end = this.end;
    }
    return this.bytes.subarray(begin, end);
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(start, length, dict = null) {
    return new _Stream(this.bytes.buffer, start, length, dict);
  }
};
var StringStream = class extends Stream {
  constructor(str) {
    super(stringToBytes(str));
  }
};
var NullStream = class extends Stream {
  constructor() {
    super(new Uint8Array(0));
  }
};
var ChunkedStream = class extends Stream {
  constructor(length, chunkSize2, manager) {
    super(
      /* arrayBuffer = */
      new Uint8Array(length),
      /* start = */
      0,
      /* length = */
      length,
      /* dict = */
      null
    );
    this.chunkSize = chunkSize2;
    this._loadedChunks = /* @__PURE__ */ new Set();
    this.numChunks = Math.ceil(length / chunkSize2);
    this.manager = manager;
    this.progressiveDataLength = 0;
    this.lastSuccessfulEnsureByteChunk = -1;
  }
  // If a particular stream does not implement one or more of these methods,
  // an error should be thrown.
  getMissingChunks() {
    const chunks = [];
    for (let chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
      if (!this._loadedChunks.has(chunk)) {
        chunks.push(chunk);
      }
    }
    return chunks;
  }
  get numChunksLoaded() {
    return this._loadedChunks.size;
  }
  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(begin, chunk) {
    const chunkSize2 = this.chunkSize;
    if (begin % chunkSize2 !== 0) {
      throw new Error(`Bad begin offset: ${begin}`);
    }
    const end = begin + chunk.byteLength;
    if (end % chunkSize2 !== 0 && end !== this.bytes.length) {
      throw new Error(`Bad end offset: ${end}`);
    }
    this.bytes.set(new Uint8Array(chunk), begin);
    const beginChunk = Math.floor(begin / chunkSize2);
    const endChunk = Math.floor((end - 1) / chunkSize2) + 1;
    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      this._loadedChunks.add(curChunk);
    }
  }
  onReceiveProgressiveData(data) {
    let position = this.progressiveDataLength;
    const beginChunk = Math.floor(position / this.chunkSize);
    this.bytes.set(new Uint8Array(data), position);
    position += data.byteLength;
    this.progressiveDataLength = position;
    const endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      this._loadedChunks.add(curChunk);
    }
  }
  ensureByte(pos) {
    if (pos < this.progressiveDataLength) {
      return;
    }
    const chunk = Math.floor(pos / this.chunkSize);
    if (chunk === this.lastSuccessfulEnsureByteChunk) {
      return;
    }
    if (!this._loadedChunks.has(chunk)) {
      throw new MissingDataException(pos, pos + 1);
    }
    this.lastSuccessfulEnsureByteChunk = chunk;
  }
  ensureRange(begin, end) {
    if (begin >= end) {
      return;
    }
    if (end <= this.progressiveDataLength) {
      return;
    }
    const chunkSize2 = this.chunkSize;
    const beginChunk = Math.floor(begin / chunkSize2);
    const endChunk = Math.floor((end - 1) / chunkSize2) + 1;
    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
      if (!this._loadedChunks.has(chunk)) {
        throw new MissingDataException(begin, end);
      }
    }
  }
  nextEmptyChunk(beginChunk) {
    const numChunks = this.numChunks;
    for (let i = 0; i < numChunks; ++i) {
      const chunk = (beginChunk + i) % numChunks;
      if (!this._loadedChunks.has(chunk)) {
        return chunk;
      }
    }
    return null;
  }
  hasChunk(chunk) {
    return this._loadedChunks.has(chunk);
  }
  getByte() {
    const pos = this.pos;
    if (pos >= this.end) {
      return -1;
    }
    if (pos >= this.progressiveDataLength) {
      this.ensureByte(pos);
    }
    return this.bytes[this.pos++];
  }
  getBytes(length, forceClamped = false) {
    const bytes = this.bytes;
    const pos = this.pos;
    const strEnd = this.end;
    if (!length) {
      if (strEnd > this.progressiveDataLength) {
        this.ensureRange(pos, strEnd);
      }
      const subarray2 = bytes.subarray(pos, strEnd);
      return forceClamped ? new Uint8ClampedArray(subarray2) : subarray2;
    }
    let end = pos + length;
    if (end > strEnd) {
      end = strEnd;
    }
    if (end > this.progressiveDataLength) {
      this.ensureRange(pos, end);
    }
    this.pos = end;
    const subarray = bytes.subarray(pos, end);
    return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
  }
  getByteRange(begin, end) {
    if (begin < 0) {
      begin = 0;
    }
    if (end > this.end) {
      end = this.end;
    }
    if (end > this.progressiveDataLength) {
      this.ensureRange(begin, end);
    }
    return this.bytes.subarray(begin, end);
  }
  makeSubStream(start, length, dict = null) {
    if (length) {
      if (start + length > this.progressiveDataLength) {
        this.ensureRange(start, start + length);
      }
    } else {
      if (start >= this.progressiveDataLength) {
        this.ensureByte(start);
      }
    }
    function ChunkedStreamSubstream() {
    }
    ChunkedStreamSubstream.prototype = Object.create(this);
    ChunkedStreamSubstream.prototype.getMissingChunks = function() {
      const chunkSize2 = this.chunkSize;
      const beginChunk = Math.floor(this.start / chunkSize2);
      const endChunk = Math.floor((this.end - 1) / chunkSize2) + 1;
      const missingChunks = [];
      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
        if (!this._loadedChunks.has(chunk)) {
          missingChunks.push(chunk);
        }
      }
      return missingChunks;
    };
    Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
      get() {
        if (this.numChunksLoaded === this.numChunks) {
          return true;
        }
        return this.getMissingChunks().length === 0;
      },
      configurable: true
    });
    const subStream = new ChunkedStreamSubstream();
    subStream.pos = subStream.start = start;
    subStream.end = start + length || this.end;
    subStream.dict = dict;
    return subStream;
  }
  getBaseStreams() {
    return [this];
  }
};
var ChunkedStreamManager = class {
  constructor(pdfNetworkStream, args) {
    this.length = args.length;
    this.chunkSize = args.rangeChunkSize;
    this.stream = new ChunkedStream(this.length, this.chunkSize, this);
    this.pdfNetworkStream = pdfNetworkStream;
    this.disableAutoFetch = args.disableAutoFetch;
    this.msgHandler = args.msgHandler;
    this.currRequestId = 0;
    this._chunksNeededByRequest = /* @__PURE__ */ new Map();
    this._requestsByChunk = /* @__PURE__ */ new Map();
    this._promisesByRequest = /* @__PURE__ */ new Map();
    this.progressiveDataLength = 0;
    this.aborted = false;
    this._loadedStreamCapability = createPromiseCapability();
  }
  onLoadedStream() {
    return this._loadedStreamCapability.promise;
  }
  sendRequest(begin, end) {
    const rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
    if (!rangeReader.isStreamingSupported) {
      rangeReader.onProgress = this.onProgress.bind(this);
    }
    let chunks = [], loaded = 0;
    const promise = new Promise((resolve, reject) => {
      const readChunk = (chunk) => {
        try {
          if (!chunk.done) {
            const data = chunk.value;
            chunks.push(data);
            loaded += arrayByteLength(data);
            if (rangeReader.isStreamingSupported) {
              this.onProgress({
                loaded
              });
            }
            rangeReader.read().then(readChunk, reject);
            return;
          }
          const chunkData = arraysToBytes(chunks);
          chunks = null;
          resolve(chunkData);
        } catch (e) {
          reject(e);
        }
      };
      rangeReader.read().then(readChunk, reject);
    });
    promise.then((data) => {
      if (this.aborted) {
        return;
      }
      this.onReceiveData({
        chunk: data,
        begin
      });
    });
  }
  /**
   * Get all the chunks that are not yet loaded and group them into
   * contiguous ranges to load in as few requests as possible.
   */
  requestAllChunks() {
    const missingChunks = this.stream.getMissingChunks();
    this._requestChunks(missingChunks);
    return this._loadedStreamCapability.promise;
  }
  _requestChunks(chunks) {
    const requestId = this.currRequestId++;
    const chunksNeeded = /* @__PURE__ */ new Set();
    this._chunksNeededByRequest.set(requestId, chunksNeeded);
    for (const chunk of chunks) {
      if (!this.stream.hasChunk(chunk)) {
        chunksNeeded.add(chunk);
      }
    }
    if (chunksNeeded.size === 0) {
      return Promise.resolve();
    }
    const capability = createPromiseCapability();
    this._promisesByRequest.set(requestId, capability);
    const chunksToRequest = [];
    for (const chunk of chunksNeeded) {
      let requestIds = this._requestsByChunk.get(chunk);
      if (!requestIds) {
        requestIds = [];
        this._requestsByChunk.set(chunk, requestIds);
        chunksToRequest.push(chunk);
      }
      requestIds.push(requestId);
    }
    if (chunksToRequest.length > 0) {
      const groupedChunksToRequest = this.groupChunks(chunksToRequest);
      for (const groupedChunk of groupedChunksToRequest) {
        const begin = groupedChunk.beginChunk * this.chunkSize;
        const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
        this.sendRequest(begin, end);
      }
    }
    return capability.promise.catch((reason) => {
      if (this.aborted) {
        return;
      }
      throw reason;
    });
  }
  getStream() {
    return this.stream;
  }
  /**
   * Loads any chunks in the requested range that are not yet loaded.
   */
  requestRange(begin, end) {
    end = Math.min(end, this.length);
    const beginChunk = this.getBeginChunk(begin);
    const endChunk = this.getEndChunk(end);
    const chunks = [];
    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
      chunks.push(chunk);
    }
    return this._requestChunks(chunks);
  }
  requestRanges(ranges = []) {
    const chunksToRequest = [];
    for (const range of ranges) {
      const beginChunk = this.getBeginChunk(range.begin);
      const endChunk = this.getEndChunk(range.end);
      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
        if (!chunksToRequest.includes(chunk)) {
          chunksToRequest.push(chunk);
        }
      }
    }
    chunksToRequest.sort(function(a, b) {
      return a - b;
    });
    return this._requestChunks(chunksToRequest);
  }
  /**
   * Groups a sorted array of chunks into as few contiguous larger
   * chunks as possible.
   */
  groupChunks(chunks) {
    const groupedChunks = [];
    let beginChunk = -1;
    let prevChunk = -1;
    for (let i = 0, ii = chunks.length; i < ii; ++i) {
      const chunk = chunks[i];
      if (beginChunk < 0) {
        beginChunk = chunk;
      }
      if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
        groupedChunks.push({
          beginChunk,
          endChunk: prevChunk + 1
        });
        beginChunk = chunk;
      }
      if (i + 1 === chunks.length) {
        groupedChunks.push({
          beginChunk,
          endChunk: chunk + 1
        });
      }
      prevChunk = chunk;
    }
    return groupedChunks;
  }
  onProgress(args) {
    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded,
      total: this.length
    });
  }
  onReceiveData(args) {
    const chunk = args.chunk;
    const isProgressive = args.begin === void 0;
    const begin = isProgressive ? this.progressiveDataLength : args.begin;
    const end = begin + chunk.byteLength;
    const beginChunk = Math.floor(begin / this.chunkSize);
    const endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
    if (isProgressive) {
      this.stream.onReceiveProgressiveData(chunk);
      this.progressiveDataLength = end;
    } else {
      this.stream.onReceiveData(begin, chunk);
    }
    if (this.stream.isDataLoaded) {
      this._loadedStreamCapability.resolve(this.stream);
    }
    const loadedRequests = [];
    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
      const requestIds = this._requestsByChunk.get(curChunk);
      if (!requestIds) {
        continue;
      }
      this._requestsByChunk.delete(curChunk);
      for (const requestId of requestIds) {
        const chunksNeeded = this._chunksNeededByRequest.get(requestId);
        if (chunksNeeded.has(curChunk)) {
          chunksNeeded.delete(curChunk);
        }
        if (chunksNeeded.size > 0) {
          continue;
        }
        loadedRequests.push(requestId);
      }
    }
    if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
      let nextEmptyChunk;
      if (this.stream.numChunksLoaded === 1) {
        const lastChunk = this.stream.numChunks - 1;
        if (!this.stream.hasChunk(lastChunk)) {
          nextEmptyChunk = lastChunk;
        }
      } else {
        nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
      }
      if (Number.isInteger(nextEmptyChunk)) {
        this._requestChunks([nextEmptyChunk]);
      }
    }
    for (const requestId of loadedRequests) {
      const capability = this._promisesByRequest.get(requestId);
      this._promisesByRequest.delete(requestId);
      capability.resolve();
    }
    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize,
      total: this.length
    });
  }
  onError(err) {
    this._loadedStreamCapability.reject(err);
  }
  getBeginChunk(begin) {
    return Math.floor(begin / this.chunkSize);
  }
  getEndChunk(end) {
    return Math.floor((end - 1) / this.chunkSize) + 1;
  }
  abort(reason) {
    this.aborted = true;
    if (this.pdfNetworkStream) {
      this.pdfNetworkStream.cancelAllRequests(reason);
    }
    for (const capability of this._promisesByRequest.values()) {
      capability.reject(reason);
    }
  }
};
function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {
  const COMPONENTS = 3;
  alpha01 = alpha01 !== 1 ? 0 : alpha01;
  const xRatio = w1 / w2;
  const yRatio = h1 / h2;
  let newIndex = 0, oldIndex;
  const xScaled = new Uint16Array(w2);
  const w1Scanline = w1 * COMPONENTS;
  for (let i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
  }
  for (let i = 0; i < h2; i++) {
    const py = Math.floor(i * yRatio) * w1Scanline;
    for (let j = 0; j < w2; j++) {
      oldIndex = py + xScaled[j];
      dest[newIndex++] = src[oldIndex++];
      dest[newIndex++] = src[oldIndex++];
      dest[newIndex++] = src[oldIndex++];
      newIndex += alpha01;
    }
  }
}
var ColorSpace = class _ColorSpace {
  constructor(name, numComps) {
    if (this.constructor === _ColorSpace) {
      unreachable("Cannot initialize ColorSpace.");
    }
    this.name = name;
    this.numComps = numComps;
  }
  /**
   * Converts the color value to the RGB color. The color components are
   * located in the src array starting from the srcOffset. Returns the array
   * of the rgb components, each value ranging from [0,255].
   */
  getRgb(src, srcOffset) {
    const rgb = new Uint8ClampedArray(3);
    this.getRgbItem(src, srcOffset, rgb, 0);
    return rgb;
  }
  /**
   * Converts the color value to the RGB color, similar to the getRgb method.
   * The result placed into the dest array starting from the destOffset.
   */
  getRgbItem(src, srcOffset, dest, destOffset) {
    unreachable("Should not call ColorSpace.getRgbItem");
  }
  /**
   * Converts the specified number of the color values to the RGB colors.
   * The colors are located in the src array starting from the srcOffset.
   * The result is placed into the dest array starting from the destOffset.
   * The src array items shall be in [0,2^bits) range, the dest array items
   * will be in [0,255] range. alpha01 indicates how many alpha components
   * there are in the dest array; it will be either 0 (RGB array) or 1 (RGBA
   * array).
   */
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    unreachable("Should not call ColorSpace.getRgbBuffer");
  }
  /**
   * Determines the number of bytes required to store the result of the
   * conversion done by the getRgbBuffer method. As in getRgbBuffer,
   * |alpha01| is either 0 (RGB output) or 1 (RGBA output).
   */
  getOutputLength(inputLength, alpha01) {
    unreachable("Should not call ColorSpace.getOutputLength");
  }
  /**
   * Returns true if source data will be equal the result/output data.
   */
  isPassthrough(bits) {
    return false;
  }
  /**
   * Refer to the static `ColorSpace.isDefaultDecode` method below.
   */
  isDefaultDecode(decodeMap, bpc) {
    return _ColorSpace.isDefaultDecode(decodeMap, this.numComps);
  }
  /**
   * Fills in the RGB colors in the destination buffer.  alpha01 indicates
   * how many alpha components there are in the dest array; it will be either
   * 0 (RGB array) or 1 (RGBA array).
   */
  fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(dest instanceof Uint8ClampedArray, 'ColorSpace.fillRgb: Unsupported "dest" type.');
    }
    const count = originalWidth * originalHeight;
    let rgbBuf = null;
    const numComponentColors = 1 << bpc;
    const needsResizing = originalHeight !== height || originalWidth !== width;
    if (this.isPassthrough(bpc)) {
      rgbBuf = comps;
    } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
      const allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
      for (let i = 0; i < numComponentColors; i++) {
        allColors[i] = i;
      }
      const colorMap = new Uint8ClampedArray(numComponentColors * 3);
      this.getRgbBuffer(
        allColors,
        0,
        numComponentColors,
        colorMap,
        0,
        bpc,
        /* alpha01 = */
        0
      );
      if (!needsResizing) {
        let destPos = 0;
        for (let i = 0; i < count; ++i) {
          const key = comps[i] * 3;
          dest[destPos++] = colorMap[key];
          dest[destPos++] = colorMap[key + 1];
          dest[destPos++] = colorMap[key + 2];
          destPos += alpha01;
        }
      } else {
        rgbBuf = new Uint8Array(count * 3);
        let rgbPos = 0;
        for (let i = 0; i < count; ++i) {
          const key = comps[i] * 3;
          rgbBuf[rgbPos++] = colorMap[key];
          rgbBuf[rgbPos++] = colorMap[key + 1];
          rgbBuf[rgbPos++] = colorMap[key + 2];
        }
      }
    } else {
      if (!needsResizing) {
        this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
      } else {
        rgbBuf = new Uint8ClampedArray(count * 3);
        this.getRgbBuffer(
          comps,
          0,
          count,
          rgbBuf,
          0,
          bpc,
          /* alpha01 = */
          0
        );
      }
    }
    if (rgbBuf) {
      if (needsResizing) {
        resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);
      } else {
        let destPos = 0, rgbPos = 0;
        for (let i = 0, ii = width * actualHeight; i < ii; i++) {
          dest[destPos++] = rgbBuf[rgbPos++];
          dest[destPos++] = rgbBuf[rgbPos++];
          dest[destPos++] = rgbBuf[rgbPos++];
          destPos += alpha01;
        }
      }
    }
  }
  /**
   * True if the colorspace has components in the default range of [0, 1].
   * This should be true for all colorspaces except for lab color spaces
   * which are [0,100], [-128, 127], [-128, 127].
   */
  get usesZeroToOneRange() {
    return shadow(this, "usesZeroToOneRange", true);
  }
  /**
   * @private
   */
  static _cache(cacheKey, xref, localColorSpaceCache, parsedColorSpace) {
    if (!localColorSpaceCache) {
      throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
    }
    if (!parsedColorSpace) {
      throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
    }
    let csName, csRef;
    if (cacheKey instanceof Ref) {
      csRef = cacheKey;
      cacheKey = xref.fetch(cacheKey);
    }
    if (cacheKey instanceof Name) {
      csName = cacheKey.name;
    }
    if (csName || csRef) {
      localColorSpaceCache.set(csName, csRef, parsedColorSpace);
    }
  }
  static getCached(cacheKey, xref, localColorSpaceCache) {
    if (!localColorSpaceCache) {
      throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
    }
    if (cacheKey instanceof Ref) {
      const localColorSpace = localColorSpaceCache.getByRef(cacheKey);
      if (localColorSpace) {
        return localColorSpace;
      }
      try {
        cacheKey = xref.fetch(cacheKey);
      } catch (ex) {
        if (ex instanceof MissingDataException) {
          throw ex;
        }
      }
    }
    if (cacheKey instanceof Name) {
      const localColorSpace = localColorSpaceCache.getByName(cacheKey.name);
      if (localColorSpace) {
        return localColorSpace;
      }
    }
    return null;
  }
  static async parseAsync({
    cs,
    xref,
    resources = null,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(!this.getCached(cs, xref, localColorSpaceCache), "Expected `ColorSpace.getCached` to have been manually checked before calling `ColorSpace.parseAsync`.");
    }
    const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);
    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
    return parsedColorSpace;
  }
  static parse({
    cs,
    xref,
    resources = null,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const cachedColorSpace = this.getCached(cs, xref, localColorSpaceCache);
    if (cachedColorSpace) {
      return cachedColorSpace;
    }
    const parsedColorSpace = this._parse(cs, xref, resources, pdfFunctionFactory);
    this._cache(cs, xref, localColorSpaceCache, parsedColorSpace);
    return parsedColorSpace;
  }
  /**
   * @private
   */
  static _parse(cs, xref, resources = null, pdfFunctionFactory) {
    cs = xref.fetchIfRef(cs);
    if (isName(cs)) {
      switch (cs.name) {
        case "DeviceGray":
        case "G":
          return this.singletons.gray;
        case "DeviceRGB":
        case "RGB":
          return this.singletons.rgb;
        case "DeviceCMYK":
        case "CMYK":
          return this.singletons.cmyk;
        case "Pattern":
          return new PatternCS(
            /* baseCS = */
            null
          );
        default:
          if (isDict(resources)) {
            const colorSpaces = resources.get("ColorSpace");
            if (isDict(colorSpaces)) {
              const resourcesCS = colorSpaces.get(cs.name);
              if (resourcesCS) {
                if (isName(resourcesCS)) {
                  return this._parse(resourcesCS, xref, resources, pdfFunctionFactory);
                }
                cs = resourcesCS;
                break;
              }
            }
          }
          throw new FormatError(`Unrecognized ColorSpace: ${cs.name}`);
      }
    }
    if (Array.isArray(cs)) {
      const mode = xref.fetchIfRef(cs[0]).name;
      let params, numComps, baseCS, whitePoint, blackPoint, gamma;
      switch (mode) {
        case "DeviceGray":
        case "G":
          return this.singletons.gray;
        case "DeviceRGB":
        case "RGB":
          return this.singletons.rgb;
        case "DeviceCMYK":
        case "CMYK":
          return this.singletons.cmyk;
        case "CalGray":
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray("WhitePoint");
          blackPoint = params.getArray("BlackPoint");
          gamma = params.get("Gamma");
          return new CalGrayCS(whitePoint, blackPoint, gamma);
        case "CalRGB":
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray("WhitePoint");
          blackPoint = params.getArray("BlackPoint");
          gamma = params.getArray("Gamma");
          const matrix = params.getArray("Matrix");
          return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
        case "ICCBased":
          const stream = xref.fetchIfRef(cs[1]);
          const dict = stream.dict;
          numComps = dict.get("N");
          const alt = dict.get("Alternate");
          if (alt) {
            const altCS = this._parse(alt, xref, resources, pdfFunctionFactory);
            if (altCS.numComps === numComps) {
              return altCS;
            }
            warn("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }
          if (numComps === 1) {
            return this.singletons.gray;
          } else if (numComps === 3) {
            return this.singletons.rgb;
          } else if (numComps === 4) {
            return this.singletons.cmyk;
          }
          break;
        case "Pattern":
          baseCS = cs[1] || null;
          if (baseCS) {
            baseCS = this._parse(baseCS, xref, resources, pdfFunctionFactory);
          }
          return new PatternCS(baseCS);
        case "Indexed":
        case "I":
          baseCS = this._parse(cs[1], xref, resources, pdfFunctionFactory);
          const hiVal = xref.fetchIfRef(cs[2]) + 1;
          const lookup = xref.fetchIfRef(cs[3]);
          return new IndexedCS(baseCS, hiVal, lookup);
        case "Separation":
        case "DeviceN":
          const name = xref.fetchIfRef(cs[1]);
          numComps = Array.isArray(name) ? name.length : 1;
          baseCS = this._parse(cs[2], xref, resources, pdfFunctionFactory);
          const tintFn = pdfFunctionFactory.create(cs[3]);
          return new AlternateCS(numComps, baseCS, tintFn);
        case "Lab":
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray("WhitePoint");
          blackPoint = params.getArray("BlackPoint");
          const range = params.getArray("Range");
          return new LabCS(whitePoint, blackPoint, range);
        default:
          throw new FormatError(`Unimplemented ColorSpace object: ${mode}`);
      }
    }
    throw new FormatError(`Unrecognized ColorSpace object: ${cs}`);
  }
  /**
   * Checks if a decode map matches the default decode map for a color space.
   * This handles the general decode maps where there are two values per
   * component, e.g. [0, 1, 0, 1, 0, 1] for a RGB color.
   * This does not handle Lab, Indexed, or Pattern decode maps since they are
   * slightly different.
   * @param {Array} decode - Decode map (usually from an image).
   * @param {number} numComps - Number of components the color space has.
   */
  static isDefaultDecode(decode, numComps) {
    if (!Array.isArray(decode)) {
      return true;
    }
    if (numComps * 2 !== decode.length) {
      warn("The decode map is not the correct length");
      return true;
    }
    for (let i = 0, ii = decode.length; i < ii; i += 2) {
      if (decode[i] !== 0 || decode[i + 1] !== 1) {
        return false;
      }
    }
    return true;
  }
  static get singletons() {
    return shadow(this, "singletons", {
      get gray() {
        return shadow(this, "gray", new DeviceGrayCS());
      },
      get rgb() {
        return shadow(this, "rgb", new DeviceRgbCS());
      },
      get cmyk() {
        return shadow(this, "cmyk", new DeviceCmykCS());
      }
    });
  }
};
var AlternateCS = class extends ColorSpace {
  constructor(numComps, base, tintFn) {
    super("Alternate", numComps);
    this.base = base;
    this.tintFn = tintFn;
    this.tmpBuf = new Float32Array(base.numComps);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(dest instanceof Uint8ClampedArray, 'AlternateCS.getRgbItem: Unsupported "dest" type.');
    }
    const tmpBuf = this.tmpBuf;
    this.tintFn(src, srcOffset, tmpBuf, 0);
    this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(dest instanceof Uint8ClampedArray, 'AlternateCS.getRgbBuffer: Unsupported "dest" type.');
    }
    const tintFn = this.tintFn;
    const base = this.base;
    const scale = 1 / ((1 << bits) - 1);
    const baseNumComps = base.numComps;
    const usesZeroToOneRange = base.usesZeroToOneRange;
    const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
    let pos = isPassthrough ? destOffset : 0;
    const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);
    const numComps = this.numComps;
    const scaled = new Float32Array(numComps);
    const tinted = new Float32Array(baseNumComps);
    let i, j;
    for (i = 0; i < count; i++) {
      for (j = 0; j < numComps; j++) {
        scaled[j] = src[srcOffset++] * scale;
      }
      tintFn(scaled, 0, tinted, 0);
      if (usesZeroToOneRange) {
        for (j = 0; j < baseNumComps; j++) {
          baseBuf[pos++] = tinted[j] * 255;
        }
      } else {
        base.getRgbItem(tinted, 0, baseBuf, pos);
        pos += baseNumComps;
      }
    }
    if (!isPassthrough) {
      base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
    }
  }
  getOutputLength(inputLength, alpha01) {
    return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
  }
};
var PatternCS = class extends ColorSpace {
  constructor(baseCS) {
    super("Pattern", null);
    this.base = baseCS;
  }
  isDefaultDecode(decodeMap, bpc) {
    unreachable("Should not call PatternCS.isDefaultDecode");
  }
};
var IndexedCS = class extends ColorSpace {
  constructor(base, highVal, lookup) {
    super("Indexed", 1);
    this.base = base;
    this.highVal = highVal;
    const length = base.numComps * highVal;
    this.lookup = new Uint8Array(length);
    if (isStream(lookup)) {
      const bytes = lookup.getBytes(length);
      this.lookup.set(bytes);
    } else if (typeof lookup === "string") {
      for (let i = 0; i < length; ++i) {
        this.lookup[i] = lookup.charCodeAt(i) & 255;
      }
    } else {
      throw new FormatError(`IndexedCS - unrecognized lookup table: ${lookup}`);
    }
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(dest instanceof Uint8ClampedArray, 'IndexedCS.getRgbItem: Unsupported "dest" type.');
    }
    const numComps = this.base.numComps;
    const start = src[srcOffset] * numComps;
    this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(dest instanceof Uint8ClampedArray, 'IndexedCS.getRgbBuffer: Unsupported "dest" type.');
    }
    const base = this.base;
    const numComps = base.numComps;
    const outputDelta = base.getOutputLength(numComps, alpha01);
    const lookup = this.lookup;
    for (let i = 0; i < count; ++i) {
      const lookupPos = src[srcOffset++] * numComps;
      base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
      destOffset += outputDelta;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
  }
  isDefaultDecode(decodeMap, bpc) {
    if (!Array.isArray(decodeMap)) {
      return true;
    }
    if (decodeMap.length !== 2) {
      warn("Decode map length is not correct");
      return true;
    }
    if (!Number.isInteger(bpc) || bpc < 1) {
      warn("Bits per component is not correct");
      return true;
    }
    return decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;
  }
};
var DeviceGrayCS = class extends ColorSpace {
  constructor() {
    super("DeviceGray", 1);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(dest instanceof Uint8ClampedArray, 'DeviceGrayCS.getRgbItem: Unsupported "dest" type.');
    }
    const c = src[srcOffset] * 255;
    dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(dest instanceof Uint8ClampedArray, 'DeviceGrayCS.getRgbBuffer: Unsupported "dest" type.');
    }
    const scale = 255 / ((1 << bits) - 1);
    let j = srcOffset, q = destOffset;
    for (let i = 0; i < count; ++i) {
      const c = scale * src[j++];
      dest[q++] = c;
      dest[q++] = c;
      dest[q++] = c;
      q += alpha01;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return inputLength * (3 + alpha01);
  }
};
var DeviceRgbCS = class extends ColorSpace {
  constructor() {
    super("DeviceRGB", 3);
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(dest instanceof Uint8ClampedArray, 'DeviceRgbCS.getRgbItem: Unsupported "dest" type.');
    }
    dest[destOffset] = src[srcOffset] * 255;
    dest[destOffset + 1] = src[srcOffset + 1] * 255;
    dest[destOffset + 2] = src[srcOffset + 2] * 255;
  }
  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(dest instanceof Uint8ClampedArray, 'DeviceRgbCS.getRgbBuffer: Unsupported "dest" type.');
    }
    if (bits === 8 && alpha01 === 0) {
      dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
      return;
    }
    const scale = 255 / ((1 << bits) - 1);
    let j = srcOffset, q = destOffset;
    for (let i = 0; i < count; ++i) {
      dest[q++] = scale * src[j++];
      dest[q++] = scale * src[j++];
      dest[q++] = scale * src[j++];
      q += alpha01;
    }
  }
  getOutputLength(inputLength, alpha01) {
    return inputLength * (3 + alpha01) / 3 | 0;
  }
  isPassthrough(bits) {
    return bits === 8;
  }
};
var DeviceCmykCS = /* @__PURE__ */ function DeviceCmykCSClosure() {
  function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
    const c = src[srcOffset] * srcScale;
    const m = src[srcOffset + 1] * srcScale;
    const y = src[srcOffset + 2] * srcScale;
    const k = src[srcOffset + 3] * srcScale;
    dest[destOffset] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
    dest[destOffset + 1] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);
    dest[destOffset + 2] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);
  }
  class DeviceCmykCS2 extends ColorSpace {
    constructor() {
      super("DeviceCMYK", 4);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
        assert(dest instanceof Uint8ClampedArray, 'DeviceCmykCS.getRgbItem: Unsupported "dest" type.');
      }
      convertToRgb(src, srcOffset, 1, dest, destOffset);
    }
    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
        assert(dest instanceof Uint8ClampedArray, 'DeviceCmykCS.getRgbBuffer: Unsupported "dest" type.');
      }
      const scale = 1 / ((1 << bits) - 1);
      for (let i = 0; i < count; i++) {
        convertToRgb(src, srcOffset, scale, dest, destOffset);
        srcOffset += 4;
        destOffset += 3 + alpha01;
      }
    }
    getOutputLength(inputLength, alpha01) {
      return inputLength / 4 * (3 + alpha01) | 0;
    }
  }
  return DeviceCmykCS2;
}();
var CalGrayCS = /* @__PURE__ */ function CalGrayCSClosure() {
  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    const A2 = src[srcOffset] * scale;
    const AG = A2 ** cs.G;
    const L = cs.YW * AG;
    const val = Math.max(295.8 * L ** 0.3333333333333333 - 40.8, 0);
    dest[destOffset] = val;
    dest[destOffset + 1] = val;
    dest[destOffset + 2] = val;
  }
  class CalGrayCS2 extends ColorSpace {
    constructor(whitePoint, blackPoint, gamma) {
      super("CalGray", 1);
      if (!whitePoint) {
        throw new FormatError("WhitePoint missing - required for color space CalGray");
      }
      blackPoint = blackPoint || [0, 0, 0];
      gamma = gamma || 1;
      this.XW = whitePoint[0];
      this.YW = whitePoint[1];
      this.ZW = whitePoint[2];
      this.XB = blackPoint[0];
      this.YB = blackPoint[1];
      this.ZB = blackPoint[2];
      this.G = gamma;
      if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
        throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
      }
      if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
        info(`Invalid BlackPoint for ${this.name}, falling back to default.`);
        this.XB = this.YB = this.ZB = 0;
      }
      if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
        warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
      }
      if (this.G < 1) {
        info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
        this.G = 1;
      }
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
        assert(dest instanceof Uint8ClampedArray, 'CalGrayCS.getRgbItem: Unsupported "dest" type.');
      }
      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
    }
    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
        assert(dest instanceof Uint8ClampedArray, 'CalGrayCS.getRgbBuffer: Unsupported "dest" type.');
      }
      const scale = 1 / ((1 << bits) - 1);
      for (let i = 0; i < count; ++i) {
        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
        srcOffset += 1;
        destOffset += 3 + alpha01;
      }
    }
    getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01);
    }
  }
  return CalGrayCS2;
}();
var CalRGBCS = function CalRGBCSClosure() {
  const BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  const BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
  const SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
  const FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
  const tempNormalizeMatrix = new Float32Array(3);
  const tempConvertMatrix1 = new Float32Array(3);
  const tempConvertMatrix2 = new Float32Array(3);
  const DECODE_L_CONSTANT = ((8 + 16) / 116) ** 3 / 8;
  function matrixProduct(a, b, result) {
    result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
    result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
  }
  function convertToFlat(sourceWhitePoint, LMS, result) {
    result[0] = LMS[0] * 1 / sourceWhitePoint[0];
    result[1] = LMS[1] * 1 / sourceWhitePoint[1];
    result[2] = LMS[2] * 1 / sourceWhitePoint[2];
  }
  function convertToD65(sourceWhitePoint, LMS, result) {
    const D65X = 0.95047;
    const D65Y = 1;
    const D65Z = 1.08883;
    result[0] = LMS[0] * D65X / sourceWhitePoint[0];
    result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
    result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
  }
  function sRGBTransferFunction(color) {
    if (color <= 31308e-7) {
      return adjustToRange(0, 1, 12.92 * color);
    }
    if (color >= 0.99554525) {
      return 1;
    }
    return adjustToRange(0, 1, (1 + 0.055) * color ** (1 / 2.4) - 0.055);
  }
  function adjustToRange(min, max, value) {
    return Math.max(min, Math.min(max, value));
  }
  function decodeL(L) {
    if (L < 0) {
      return -decodeL(-L);
    }
    if (L > 8) {
      return ((L + 16) / 116) ** 3;
    }
    return L * DECODE_L_CONSTANT;
  }
  function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
    if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
      result[0] = XYZ_Flat[0];
      result[1] = XYZ_Flat[1];
      result[2] = XYZ_Flat[2];
      return;
    }
    const zeroDecodeL = decodeL(0);
    const X_DST = zeroDecodeL;
    const X_SRC = decodeL(sourceBlackPoint[0]);
    const Y_DST = zeroDecodeL;
    const Y_SRC = decodeL(sourceBlackPoint[1]);
    const Z_DST = zeroDecodeL;
    const Z_SRC = decodeL(sourceBlackPoint[2]);
    const X_Scale = (1 - X_DST) / (1 - X_SRC);
    const X_Offset = 1 - X_Scale;
    const Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
    const Y_Offset = 1 - Y_Scale;
    const Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
    const Z_Offset = 1 - Z_Scale;
    result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
    result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
    result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
  }
  function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
    if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
      result[0] = XYZ_In[0];
      result[1] = XYZ_In[1];
      result[2] = XYZ_In[2];
      return;
    }
    const LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    const LMS_Flat = tempNormalizeMatrix;
    convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
  }
  function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
    const LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    const LMS_D65 = tempNormalizeMatrix;
    convertToD65(sourceWhitePoint, LMS, LMS_D65);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
  }
  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    const A2 = adjustToRange(0, 1, src[srcOffset] * scale);
    const B2 = adjustToRange(0, 1, src[srcOffset + 1] * scale);
    const C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
    const AGR = A2 === 1 ? 1 : A2 ** cs.GR;
    const BGG = B2 === 1 ? 1 : B2 ** cs.GG;
    const CGB = C === 1 ? 1 : C ** cs.GB;
    const X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
    const Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
    const Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
    const XYZ = tempConvertMatrix1;
    XYZ[0] = X;
    XYZ[1] = Y;
    XYZ[2] = Z;
    const XYZ_Flat = tempConvertMatrix2;
    normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
    const XYZ_Black = tempConvertMatrix1;
    compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
    const XYZ_D65 = tempConvertMatrix2;
    normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
    const SRGB = tempConvertMatrix1;
    matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
    dest[destOffset] = sRGBTransferFunction(SRGB[0]) * 255;
    dest[destOffset + 1] = sRGBTransferFunction(SRGB[1]) * 255;
    dest[destOffset + 2] = sRGBTransferFunction(SRGB[2]) * 255;
  }
  class CalRGBCS2 extends ColorSpace {
    constructor(whitePoint, blackPoint, gamma, matrix) {
      super("CalRGB", 3);
      if (!whitePoint) {
        throw new FormatError("WhitePoint missing - required for color space CalRGB");
      }
      blackPoint = blackPoint || new Float32Array(3);
      gamma = gamma || new Float32Array([1, 1, 1]);
      matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      const XW = whitePoint[0];
      const YW = whitePoint[1];
      const ZW = whitePoint[2];
      this.whitePoint = whitePoint;
      const XB = blackPoint[0];
      const YB = blackPoint[1];
      const ZB = blackPoint[2];
      this.blackPoint = blackPoint;
      this.GR = gamma[0];
      this.GG = gamma[1];
      this.GB = gamma[2];
      this.MXA = matrix[0];
      this.MYA = matrix[1];
      this.MZA = matrix[2];
      this.MXB = matrix[3];
      this.MYB = matrix[4];
      this.MZB = matrix[5];
      this.MXC = matrix[6];
      this.MYC = matrix[7];
      this.MZC = matrix[8];
      if (XW < 0 || ZW < 0 || YW !== 1) {
        throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
      }
      if (XB < 0 || YB < 0 || ZB < 0) {
        info(`Invalid BlackPoint for ${this.name} [${XB}, ${YB}, ${ZB}], falling back to default.`);
        this.blackPoint = new Float32Array(3);
      }
      if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
        info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
        this.GR = this.GG = this.GB = 1;
      }
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
        assert(dest instanceof Uint8ClampedArray, 'CalRGBCS.getRgbItem: Unsupported "dest" type.');
      }
      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
    }
    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
        assert(dest instanceof Uint8ClampedArray, 'CalRGBCS.getRgbBuffer: Unsupported "dest" type.');
      }
      const scale = 1 / ((1 << bits) - 1);
      for (let i = 0; i < count; ++i) {
        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
        srcOffset += 3;
        destOffset += 3 + alpha01;
      }
    }
    getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    }
  }
  return CalRGBCS2;
}();
var LabCS = /* @__PURE__ */ function LabCSClosure() {
  function fn_g(x) {
    let result;
    if (x >= 6 / 29) {
      result = x ** 3;
    } else {
      result = 108 / 841 * (x - 4 / 29);
    }
    return result;
  }
  function decode(value, high1, low2, high2) {
    return low2 + value * (high2 - low2) / high1;
  }
  function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
    let Ls = src[srcOffset];
    let as = src[srcOffset + 1];
    let bs = src[srcOffset + 2];
    if (maxVal !== false) {
      Ls = decode(Ls, maxVal, 0, 100);
      as = decode(as, maxVal, cs.amin, cs.amax);
      bs = decode(bs, maxVal, cs.bmin, cs.bmax);
    }
    if (as > cs.amax) {
      as = cs.amax;
    } else if (as < cs.amin) {
      as = cs.amin;
    }
    if (bs > cs.bmax) {
      bs = cs.bmax;
    } else if (bs < cs.bmin) {
      bs = cs.bmin;
    }
    const M = (Ls + 16) / 116;
    const L = M + as / 500;
    const N = M - bs / 200;
    const X = cs.XW * fn_g(L);
    const Y = cs.YW * fn_g(M);
    const Z = cs.ZW * fn_g(N);
    let r, g, b;
    if (cs.ZW < 1) {
      r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
      g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
      b = X * 0.072 + Y * -0.229 + Z * 1.4057;
    } else {
      r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
      g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
      b = X * 0.0557 + Y * -0.204 + Z * 1.057;
    }
    dest[destOffset] = Math.sqrt(r) * 255;
    dest[destOffset + 1] = Math.sqrt(g) * 255;
    dest[destOffset + 2] = Math.sqrt(b) * 255;
  }
  class LabCS2 extends ColorSpace {
    constructor(whitePoint, blackPoint, range) {
      super("Lab", 3);
      if (!whitePoint) {
        throw new FormatError("WhitePoint missing - required for color space Lab");
      }
      blackPoint = blackPoint || [0, 0, 0];
      range = range || [-100, 100, -100, 100];
      this.XW = whitePoint[0];
      this.YW = whitePoint[1];
      this.ZW = whitePoint[2];
      this.amin = range[0];
      this.amax = range[1];
      this.bmin = range[2];
      this.bmax = range[3];
      this.XB = blackPoint[0];
      this.YB = blackPoint[1];
      this.ZB = blackPoint[2];
      if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
        throw new FormatError("Invalid WhitePoint components, no fallback available");
      }
      if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
        info("Invalid BlackPoint, falling back to default");
        this.XB = this.YB = this.ZB = 0;
      }
      if (this.amin > this.amax || this.bmin > this.bmax) {
        info("Invalid Range, falling back to defaults");
        this.amin = -100;
        this.amax = 100;
        this.bmin = -100;
        this.bmax = 100;
      }
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
        assert(dest instanceof Uint8ClampedArray, 'LabCS.getRgbItem: Unsupported "dest" type.');
      }
      convertToRgb(this, src, srcOffset, false, dest, destOffset);
    }
    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
        assert(dest instanceof Uint8ClampedArray, 'LabCS.getRgbBuffer: Unsupported "dest" type.');
      }
      const maxVal = (1 << bits) - 1;
      for (let i = 0; i < count; i++) {
        convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
        srcOffset += 3;
        destOffset += 3 + alpha01;
      }
    }
    getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    }
    isDefaultDecode(decodeMap, bpc) {
      return true;
    }
    get usesZeroToOneRange() {
      return shadow(this, "usesZeroToOneRange", false);
    }
  }
  return LabCS2;
}();
var emptyBuffer = new Uint8Array(0);
var DecodeStream = class extends BaseStream {
  constructor(maybeMinBufferLength) {
    super();
    this._rawMinBufferLength = maybeMinBufferLength || 0;
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = emptyBuffer;
    this.minBufferLength = 512;
    if (maybeMinBufferLength) {
      while (this.minBufferLength < maybeMinBufferLength) {
        this.minBufferLength *= 2;
      }
    }
  }
  get isEmpty() {
    while (!this.eof && this.bufferLength === 0) {
      this.readBlock();
    }
    return this.bufferLength === 0;
  }
  ensureBuffer(requested) {
    const buffer = this.buffer;
    if (requested <= buffer.byteLength) {
      return buffer;
    }
    let size = this.minBufferLength;
    while (size < requested) {
      size *= 2;
    }
    const buffer2 = new Uint8Array(size);
    buffer2.set(buffer);
    return this.buffer = buffer2;
  }
  getByte() {
    const pos = this.pos;
    while (this.bufferLength <= pos) {
      if (this.eof) {
        return -1;
      }
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }
  getBytes(length, forceClamped = false) {
    const pos = this.pos;
    let end;
    if (length) {
      this.ensureBuffer(pos + length);
      end = pos + length;
      while (!this.eof && this.bufferLength < end) {
        this.readBlock();
      }
      const bufEnd = this.bufferLength;
      if (end > bufEnd) {
        end = bufEnd;
      }
    } else {
      while (!this.eof) {
        this.readBlock();
      }
      end = this.bufferLength;
    }
    this.pos = end;
    const subarray = this.buffer.subarray(pos, end);
    return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(start, length, dict = null) {
    if (length === void 0) {
      while (!this.eof) {
        this.readBlock();
      }
    } else {
      const end = start + length;
      while (this.bufferLength <= end && !this.eof) {
        this.readBlock();
      }
    }
    return new Stream(this.buffer, start, length, dict);
  }
  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }
};
var StreamsSequenceStream = class extends DecodeStream {
  constructor(streams) {
    let maybeLength = 0;
    for (const stream of streams) {
      maybeLength += stream instanceof DecodeStream ? stream._rawMinBufferLength : stream.length;
    }
    super(maybeLength);
    this.streams = streams;
  }
  readBlock() {
    const streams = this.streams;
    if (streams.length === 0) {
      this.eof = true;
      return;
    }
    const stream = streams.shift();
    const chunk = stream.getBytes();
    const bufferLength = this.bufferLength;
    const newLength = bufferLength + chunk.length;
    const buffer = this.ensureBuffer(newLength);
    buffer.set(chunk, bufferLength);
    this.bufferLength = newLength;
  }
  getBaseStreams() {
    const baseStreamsBuf = [];
    for (const stream of this.streams) {
      const baseStreams = stream.getBaseStreams();
      if (baseStreams) {
        baseStreamsBuf.push(...baseStreams);
      }
    }
    return baseStreamsBuf.length > 0 ? baseStreamsBuf : null;
  }
};
var Ascii85Stream = class extends DecodeStream {
  constructor(str, maybeLength) {
    if (maybeLength) {
      maybeLength *= 0.8;
    }
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.input = new Uint8Array(5);
  }
  readBlock() {
    const TILDA_CHAR = 126;
    const Z_LOWER_CHAR = 122;
    const EOF2 = -1;
    const str = this.str;
    let c = str.getByte();
    while (isWhiteSpace(c)) {
      c = str.getByte();
    }
    if (c === EOF2 || c === TILDA_CHAR) {
      this.eof = true;
      return;
    }
    const bufferLength = this.bufferLength;
    let buffer, i;
    if (c === Z_LOWER_CHAR) {
      buffer = this.ensureBuffer(bufferLength + 4);
      for (i = 0; i < 4; ++i) {
        buffer[bufferLength + i] = 0;
      }
      this.bufferLength += 4;
    } else {
      const input = this.input;
      input[0] = c;
      for (i = 1; i < 5; ++i) {
        c = str.getByte();
        while (isWhiteSpace(c)) {
          c = str.getByte();
        }
        input[i] = c;
        if (c === EOF2 || c === TILDA_CHAR) {
          break;
        }
      }
      buffer = this.ensureBuffer(bufferLength + i - 1);
      this.bufferLength += i - 1;
      if (i < 5) {
        for (; i < 5; ++i) {
          input[i] = 33 + 84;
        }
        this.eof = true;
      }
      let t = 0;
      for (i = 0; i < 5; ++i) {
        t = t * 85 + (input[i] - 33);
      }
      for (i = 3; i >= 0; --i) {
        buffer[bufferLength + i] = t & 255;
        t >>= 8;
      }
    }
  }
};
var AsciiHexStream = class extends DecodeStream {
  constructor(str, maybeLength) {
    if (maybeLength) {
      maybeLength *= 0.5;
    }
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.firstDigit = -1;
  }
  readBlock() {
    const UPSTREAM_BLOCK_SIZE = 8e3;
    const bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
    if (!bytes.length) {
      this.eof = true;
      return;
    }
    const maxDecodeLength = bytes.length + 1 >> 1;
    const buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
    let bufferLength = this.bufferLength;
    let firstDigit = this.firstDigit;
    for (const ch of bytes) {
      let digit;
      if (ch >= /* '0' = */
      48 && ch <= /* '9' = */
      57) {
        digit = ch & 15;
      } else if (ch >= /* 'A' = */
      65 && ch <= /* 'Z' = */
      70 || ch >= /* 'a' = */
      97 && ch <= /* 'z' = */
      102) {
        digit = (ch & 15) + 9;
      } else if (ch === /* '>' = */
      62) {
        this.eof = true;
        break;
      } else {
        continue;
      }
      if (firstDigit < 0) {
        firstDigit = digit;
      } else {
        buffer[bufferLength++] = firstDigit << 4 | digit;
        firstDigit = -1;
      }
    }
    if (firstDigit >= 0 && this.eof) {
      buffer[bufferLength++] = firstDigit << 4;
      firstDigit = -1;
    }
    this.firstDigit = firstDigit;
    this.bufferLength = bufferLength;
  }
};
var ccittEOL = -2;
var ccittEOF = -1;
var twoDimPass = 0;
var twoDimHoriz = 1;
var twoDimVert0 = 2;
var twoDimVertR1 = 3;
var twoDimVertL1 = 4;
var twoDimVertR2 = 5;
var twoDimVertL2 = 6;
var twoDimVertR3 = 7;
var twoDimVertL3 = 8;
var twoDimTable = [
  [-1, -1],
  [-1, -1],
  // 000000x
  [7, twoDimVertL3],
  // 0000010
  [7, twoDimVertR3],
  // 0000011
  [6, twoDimVertL2],
  [6, twoDimVertL2],
  // 000010x
  [6, twoDimVertR2],
  [6, twoDimVertR2],
  // 000011x
  [4, twoDimPass],
  [4, twoDimPass],
  // 0001xxx
  [4, twoDimPass],
  [4, twoDimPass],
  [4, twoDimPass],
  [4, twoDimPass],
  [4, twoDimPass],
  [4, twoDimPass],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  // 001xxxx
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimHoriz],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  // 010xxxx
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertL1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  // 011xxxx
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [3, twoDimVertR1],
  [1, twoDimVert0],
  [1, twoDimVert0],
  // 1xxxxxx
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0],
  [1, twoDimVert0]
];
var whiteTable1 = [
  [-1, -1],
  // 00000
  [12, ccittEOL],
  // 00001
  [-1, -1],
  [-1, -1],
  // 0001x
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 001xx
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 010xx
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 011xx
  [11, 1792],
  [11, 1792],
  // 1000x
  [12, 1984],
  // 10010
  [12, 2048],
  // 10011
  [12, 2112],
  // 10100
  [12, 2176],
  // 10101
  [12, 2240],
  // 10110
  [12, 2304],
  // 10111
  [11, 1856],
  [11, 1856],
  // 1100x
  [11, 1920],
  [11, 1920],
  // 1101x
  [12, 2368],
  // 11100
  [12, 2432],
  // 11101
  [12, 2496],
  // 11110
  [12, 2560]
  // 11111
];
var whiteTable2 = [
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 0000000xx
  [8, 29],
  [8, 29],
  // 00000010x
  [8, 30],
  [8, 30],
  // 00000011x
  [8, 45],
  [8, 45],
  // 00000100x
  [8, 46],
  [8, 46],
  // 00000101x
  [7, 22],
  [7, 22],
  [7, 22],
  [7, 22],
  // 0000011xx
  [7, 23],
  [7, 23],
  [7, 23],
  [7, 23],
  // 0000100xx
  [8, 47],
  [8, 47],
  // 00001010x
  [8, 48],
  [8, 48],
  // 00001011x
  [6, 13],
  [6, 13],
  [6, 13],
  [6, 13],
  // 000011xxx
  [6, 13],
  [6, 13],
  [6, 13],
  [6, 13],
  [7, 20],
  [7, 20],
  [7, 20],
  [7, 20],
  // 0001000xx
  [8, 33],
  [8, 33],
  // 00010010x
  [8, 34],
  [8, 34],
  // 00010011x
  [8, 35],
  [8, 35],
  // 00010100x
  [8, 36],
  [8, 36],
  // 00010101x
  [8, 37],
  [8, 37],
  // 00010110x
  [8, 38],
  [8, 38],
  // 00010111x
  [7, 19],
  [7, 19],
  [7, 19],
  [7, 19],
  // 0001100xx
  [8, 31],
  [8, 31],
  // 00011010x
  [8, 32],
  [8, 32],
  // 00011011x
  [6, 1],
  [6, 1],
  [6, 1],
  [6, 1],
  // 000111xxx
  [6, 1],
  [6, 1],
  [6, 1],
  [6, 1],
  [6, 12],
  [6, 12],
  [6, 12],
  [6, 12],
  // 001000xxx
  [6, 12],
  [6, 12],
  [6, 12],
  [6, 12],
  [8, 53],
  [8, 53],
  // 00100100x
  [8, 54],
  [8, 54],
  // 00100101x
  [7, 26],
  [7, 26],
  [7, 26],
  [7, 26],
  // 0010011xx
  [8, 39],
  [8, 39],
  // 00101000x
  [8, 40],
  [8, 40],
  // 00101001x
  [8, 41],
  [8, 41],
  // 00101010x
  [8, 42],
  [8, 42],
  // 00101011x
  [8, 43],
  [8, 43],
  // 00101100x
  [8, 44],
  [8, 44],
  // 00101101x
  [7, 21],
  [7, 21],
  [7, 21],
  [7, 21],
  // 0010111xx
  [7, 28],
  [7, 28],
  [7, 28],
  [7, 28],
  // 0011000xx
  [8, 61],
  [8, 61],
  // 00110010x
  [8, 62],
  [8, 62],
  // 00110011x
  [8, 63],
  [8, 63],
  // 00110100x
  [8, 0],
  [8, 0],
  // 00110101x
  [8, 320],
  [8, 320],
  // 00110110x
  [8, 384],
  [8, 384],
  // 00110111x
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  // 00111xxxx
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 10],
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  // 01000xxxx
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  [5, 11],
  [7, 27],
  [7, 27],
  [7, 27],
  [7, 27],
  // 0100100xx
  [8, 59],
  [8, 59],
  // 01001010x
  [8, 60],
  [8, 60],
  // 01001011x
  [9, 1472],
  // 010011000
  [9, 1536],
  // 010011001
  [9, 1600],
  // 010011010
  [9, 1728],
  // 010011011
  [7, 18],
  [7, 18],
  [7, 18],
  [7, 18],
  // 0100111xx
  [7, 24],
  [7, 24],
  [7, 24],
  [7, 24],
  // 0101000xx
  [8, 49],
  [8, 49],
  // 01010010x
  [8, 50],
  [8, 50],
  // 01010011x
  [8, 51],
  [8, 51],
  // 01010100x
  [8, 52],
  [8, 52],
  // 01010101x
  [7, 25],
  [7, 25],
  [7, 25],
  [7, 25],
  // 0101011xx
  [8, 55],
  [8, 55],
  // 01011000x
  [8, 56],
  [8, 56],
  // 01011001x
  [8, 57],
  [8, 57],
  // 01011010x
  [8, 58],
  [8, 58],
  // 01011011x
  [6, 192],
  [6, 192],
  [6, 192],
  [6, 192],
  // 010111xxx
  [6, 192],
  [6, 192],
  [6, 192],
  [6, 192],
  [6, 1664],
  [6, 1664],
  [6, 1664],
  [6, 1664],
  // 011000xxx
  [6, 1664],
  [6, 1664],
  [6, 1664],
  [6, 1664],
  [8, 448],
  [8, 448],
  // 01100100x
  [8, 512],
  [8, 512],
  // 01100101x
  [9, 704],
  // 011001100
  [9, 768],
  // 011001101
  [8, 640],
  [8, 640],
  // 01100111x
  [8, 576],
  [8, 576],
  // 01101000x
  [9, 832],
  // 011010010
  [9, 896],
  // 011010011
  [9, 960],
  // 011010100
  [9, 1024],
  // 011010101
  [9, 1088],
  // 011010110
  [9, 1152],
  // 011010111
  [9, 1216],
  // 011011000
  [9, 1280],
  // 011011001
  [9, 1344],
  // 011011010
  [9, 1408],
  // 011011011
  [7, 256],
  [7, 256],
  [7, 256],
  [7, 256],
  // 0110111xx
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  // 0111xxxxx
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 2],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  // 1000xxxxx
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [4, 3],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  // 10010xxxx
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 128],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  // 10011xxxx
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 8],
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  // 10100xxxx
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  [5, 9],
  [6, 16],
  [6, 16],
  [6, 16],
  [6, 16],
  // 101010xxx
  [6, 16],
  [6, 16],
  [6, 16],
  [6, 16],
  [6, 17],
  [6, 17],
  [6, 17],
  [6, 17],
  // 101011xxx
  [6, 17],
  [6, 17],
  [6, 17],
  [6, 17],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  // 1011xxxxx
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 4],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  // 1100xxxxx
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  [6, 14],
  [6, 14],
  [6, 14],
  [6, 14],
  // 110100xxx
  [6, 14],
  [6, 14],
  [6, 14],
  [6, 14],
  [6, 15],
  [6, 15],
  [6, 15],
  [6, 15],
  // 110101xxx
  [6, 15],
  [6, 15],
  [6, 15],
  [6, 15],
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  // 11011xxxx
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  [5, 64],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  // 1110xxxxx
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  // 1111xxxxx
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7],
  [4, 7]
];
var blackTable1 = [
  [-1, -1],
  [-1, -1],
  // 000000000000x
  [12, ccittEOL],
  [12, ccittEOL],
  // 000000000001x
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 00000000001xx
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 00000000010xx
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 00000000011xx
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 00000000100xx
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 00000000101xx
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 00000000110xx
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 00000000111xx
  [11, 1792],
  [11, 1792],
  [11, 1792],
  [11, 1792],
  // 00000001000xx
  [12, 1984],
  [12, 1984],
  // 000000010010x
  [12, 2048],
  [12, 2048],
  // 000000010011x
  [12, 2112],
  [12, 2112],
  // 000000010100x
  [12, 2176],
  [12, 2176],
  // 000000010101x
  [12, 2240],
  [12, 2240],
  // 000000010110x
  [12, 2304],
  [12, 2304],
  // 000000010111x
  [11, 1856],
  [11, 1856],
  [11, 1856],
  [11, 1856],
  // 00000001100xx
  [11, 1920],
  [11, 1920],
  [11, 1920],
  [11, 1920],
  // 00000001101xx
  [12, 2368],
  [12, 2368],
  // 000000011100x
  [12, 2432],
  [12, 2432],
  // 000000011101x
  [12, 2496],
  [12, 2496],
  // 000000011110x
  [12, 2560],
  [12, 2560],
  // 000000011111x
  [10, 18],
  [10, 18],
  [10, 18],
  [10, 18],
  // 0000001000xxx
  [10, 18],
  [10, 18],
  [10, 18],
  [10, 18],
  [12, 52],
  [12, 52],
  // 000000100100x
  [13, 640],
  // 0000001001010
  [13, 704],
  // 0000001001011
  [13, 768],
  // 0000001001100
  [13, 832],
  // 0000001001101
  [12, 55],
  [12, 55],
  // 000000100111x
  [12, 56],
  [12, 56],
  // 000000101000x
  [13, 1280],
  // 0000001010010
  [13, 1344],
  // 0000001010011
  [13, 1408],
  // 0000001010100
  [13, 1472],
  // 0000001010101
  [12, 59],
  [12, 59],
  // 000000101011x
  [12, 60],
  [12, 60],
  // 000000101100x
  [13, 1536],
  // 0000001011010
  [13, 1600],
  // 0000001011011
  [11, 24],
  [11, 24],
  [11, 24],
  [11, 24],
  // 00000010111xx
  [11, 25],
  [11, 25],
  [11, 25],
  [11, 25],
  // 00000011000xx
  [13, 1664],
  // 0000001100100
  [13, 1728],
  // 0000001100101
  [12, 320],
  [12, 320],
  // 000000110011x
  [12, 384],
  [12, 384],
  // 000000110100x
  [12, 448],
  [12, 448],
  // 000000110101x
  [13, 512],
  // 0000001101100
  [13, 576],
  // 0000001101101
  [12, 53],
  [12, 53],
  // 000000110111x
  [12, 54],
  [12, 54],
  // 000000111000x
  [13, 896],
  // 0000001110010
  [13, 960],
  // 0000001110011
  [13, 1024],
  // 0000001110100
  [13, 1088],
  // 0000001110101
  [13, 1152],
  // 0000001110110
  [13, 1216],
  // 0000001110111
  [10, 64],
  [10, 64],
  [10, 64],
  [10, 64],
  // 0000001111xxx
  [10, 64],
  [10, 64],
  [10, 64],
  [10, 64]
];
var blackTable2 = [
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  // 00000100xxxx
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  [8, 13],
  [11, 23],
  [11, 23],
  // 00000101000x
  [12, 50],
  // 000001010010
  [12, 51],
  // 000001010011
  [12, 44],
  // 000001010100
  [12, 45],
  // 000001010101
  [12, 46],
  // 000001010110
  [12, 47],
  // 000001010111
  [12, 57],
  // 000001011000
  [12, 58],
  // 000001011001
  [12, 61],
  // 000001011010
  [12, 256],
  // 000001011011
  [10, 16],
  [10, 16],
  [10, 16],
  [10, 16],
  // 0000010111xx
  [10, 17],
  [10, 17],
  [10, 17],
  [10, 17],
  // 0000011000xx
  [12, 48],
  // 000001100100
  [12, 49],
  // 000001100101
  [12, 62],
  // 000001100110
  [12, 63],
  // 000001100111
  [12, 30],
  // 000001101000
  [12, 31],
  // 000001101001
  [12, 32],
  // 000001101010
  [12, 33],
  // 000001101011
  [12, 40],
  // 000001101100
  [12, 41],
  // 000001101101
  [11, 22],
  [11, 22],
  // 00000110111x
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  // 00000111xxxx
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  [8, 14],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  // 0000100xxxxx
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 10],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  // 0000101xxxxx
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [7, 11],
  [9, 15],
  [9, 15],
  [9, 15],
  [9, 15],
  // 000011000xxx
  [9, 15],
  [9, 15],
  [9, 15],
  [9, 15],
  [12, 128],
  // 000011001000
  [12, 192],
  // 000011001001
  [12, 26],
  // 000011001010
  [12, 27],
  // 000011001011
  [12, 28],
  // 000011001100
  [12, 29],
  // 000011001101
  [11, 19],
  [11, 19],
  // 00001100111x
  [11, 20],
  [11, 20],
  // 00001101000x
  [12, 34],
  // 000011010010
  [12, 35],
  // 000011010011
  [12, 36],
  // 000011010100
  [12, 37],
  // 000011010101
  [12, 38],
  // 000011010110
  [12, 39],
  // 000011010111
  [11, 21],
  [11, 21],
  // 00001101100x
  [12, 42],
  // 000011011010
  [12, 43],
  // 000011011011
  [10, 0],
  [10, 0],
  [10, 0],
  [10, 0],
  // 0000110111xx
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  // 0000111xxxxx
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12],
  [7, 12]
];
var blackTable3 = [
  [-1, -1],
  [-1, -1],
  [-1, -1],
  [-1, -1],
  // 0000xx
  [6, 9],
  // 000100
  [6, 8],
  // 000101
  [5, 7],
  [5, 7],
  // 00011x
  [4, 6],
  [4, 6],
  [4, 6],
  [4, 6],
  // 0010xx
  [4, 5],
  [4, 5],
  [4, 5],
  [4, 5],
  // 0011xx
  [3, 1],
  [3, 1],
  [3, 1],
  [3, 1],
  // 010xxx
  [3, 1],
  [3, 1],
  [3, 1],
  [3, 1],
  [3, 4],
  [3, 4],
  [3, 4],
  [3, 4],
  // 011xxx
  [3, 4],
  [3, 4],
  [3, 4],
  [3, 4],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  // 10xxxx
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 3],
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2],
  // 11xxxx
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2],
  [2, 2]
];
var CCITTFaxDecoder = class {
  constructor(source, options = {}) {
    if (!source || typeof source.next !== "function") {
      throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    }
    this.source = source;
    this.eof = false;
    this.encoding = options.K || 0;
    this.eoline = options.EndOfLine || false;
    this.byteAlign = options.EncodedByteAlign || false;
    this.columns = options.Columns || 1728;
    this.rows = options.Rows || 0;
    let eoblock = options.EndOfBlock;
    if (eoblock === null || eoblock === void 0) {
      eoblock = true;
    }
    this.eoblock = eoblock;
    this.black = options.BlackIs1 || false;
    this.codingLine = new Uint32Array(this.columns + 1);
    this.refLine = new Uint32Array(this.columns + 2);
    this.codingLine[0] = this.columns;
    this.codingPos = 0;
    this.row = 0;
    this.nextLine2D = this.encoding < 0;
    this.inputBits = 0;
    this.inputBuf = 0;
    this.outputBits = 0;
    this.rowsDone = false;
    let code1;
    while ((code1 = this._lookBits(12)) === 0) {
      this._eatBits(1);
    }
    if (code1 === 1) {
      this._eatBits(12);
    }
    if (this.encoding > 0) {
      this.nextLine2D = !this._lookBits(1);
      this._eatBits(1);
    }
  }
  readNextChar() {
    if (this.eof) {
      return -1;
    }
    const refLine = this.refLine;
    const codingLine = this.codingLine;
    const columns = this.columns;
    let refPos, blackPixels, bits, i;
    if (this.outputBits === 0) {
      if (this.rowsDone) {
        this.eof = true;
      }
      if (this.eof) {
        return -1;
      }
      this.err = false;
      let code1, code2, code3;
      if (this.nextLine2D) {
        for (i = 0; codingLine[i] < columns; ++i) {
          refLine[i] = codingLine[i];
        }
        refLine[i++] = columns;
        refLine[i] = columns;
        codingLine[0] = 0;
        this.codingPos = 0;
        refPos = 0;
        blackPixels = 0;
        while (codingLine[this.codingPos] < columns) {
          code1 = this._getTwoDimCode();
          switch (code1) {
            case twoDimPass:
              this._addPixels(refLine[refPos + 1], blackPixels);
              if (refLine[refPos + 1] < columns) {
                refPos += 2;
              }
              break;
            case twoDimHoriz:
              code1 = code2 = 0;
              if (blackPixels) {
                do {
                  code1 += code3 = this._getBlackCode();
                } while (code3 >= 64);
                do {
                  code2 += code3 = this._getWhiteCode();
                } while (code3 >= 64);
              } else {
                do {
                  code1 += code3 = this._getWhiteCode();
                } while (code3 >= 64);
                do {
                  code2 += code3 = this._getBlackCode();
                } while (code3 >= 64);
              }
              this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
              if (codingLine[this.codingPos] < columns) {
                this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
              }
              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                refPos += 2;
              }
              break;
            case twoDimVertR3:
              this._addPixels(refLine[refPos] + 3, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertR2:
              this._addPixels(refLine[refPos] + 2, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertR1:
              this._addPixels(refLine[refPos] + 1, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVert0:
              this._addPixels(refLine[refPos], blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                ++refPos;
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertL3:
              this._addPixelsNeg(refLine[refPos] - 3, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertL2:
              this._addPixelsNeg(refLine[refPos] - 2, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case twoDimVertL1:
              this._addPixelsNeg(refLine[refPos] - 1, blackPixels);
              blackPixels ^= 1;
              if (codingLine[this.codingPos] < columns) {
                if (refPos > 0) {
                  --refPos;
                } else {
                  ++refPos;
                }
                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                  refPos += 2;
                }
              }
              break;
            case ccittEOF:
              this._addPixels(columns, 0);
              this.eof = true;
              break;
            default:
              info("bad 2d code");
              this._addPixels(columns, 0);
              this.err = true;
          }
        }
      } else {
        codingLine[0] = 0;
        this.codingPos = 0;
        blackPixels = 0;
        while (codingLine[this.codingPos] < columns) {
          code1 = 0;
          if (blackPixels) {
            do {
              code1 += code3 = this._getBlackCode();
            } while (code3 >= 64);
          } else {
            do {
              code1 += code3 = this._getWhiteCode();
            } while (code3 >= 64);
          }
          this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
          blackPixels ^= 1;
        }
      }
      let gotEOL = false;
      if (this.byteAlign) {
        this.inputBits &= ~7;
      }
      if (!this.eoblock && this.row === this.rows - 1) {
        this.rowsDone = true;
      } else {
        code1 = this._lookBits(12);
        if (this.eoline) {
          while (code1 !== ccittEOF && code1 !== 1) {
            this._eatBits(1);
            code1 = this._lookBits(12);
          }
        } else {
          while (code1 === 0) {
            this._eatBits(1);
            code1 = this._lookBits(12);
          }
        }
        if (code1 === 1) {
          this._eatBits(12);
          gotEOL = true;
        } else if (code1 === ccittEOF) {
          this.eof = true;
        }
      }
      if (!this.eof && this.encoding > 0 && !this.rowsDone) {
        this.nextLine2D = !this._lookBits(1);
        this._eatBits(1);
      }
      if (this.eoblock && gotEOL && this.byteAlign) {
        code1 = this._lookBits(12);
        if (code1 === 1) {
          this._eatBits(12);
          if (this.encoding > 0) {
            this._lookBits(1);
            this._eatBits(1);
          }
          if (this.encoding >= 0) {
            for (i = 0; i < 4; ++i) {
              code1 = this._lookBits(12);
              if (code1 !== 1) {
                info("bad rtc code: " + code1);
              }
              this._eatBits(12);
              if (this.encoding > 0) {
                this._lookBits(1);
                this._eatBits(1);
              }
            }
          }
          this.eof = true;
        }
      } else if (this.err && this.eoline) {
        while (true) {
          code1 = this._lookBits(13);
          if (code1 === ccittEOF) {
            this.eof = true;
            return -1;
          }
          if (code1 >> 1 === 1) {
            break;
          }
          this._eatBits(1);
        }
        this._eatBits(12);
        if (this.encoding > 0) {
          this._eatBits(1);
          this.nextLine2D = !(code1 & 1);
        }
      }
      if (codingLine[0] > 0) {
        this.outputBits = codingLine[this.codingPos = 0];
      } else {
        this.outputBits = codingLine[this.codingPos = 1];
      }
      this.row++;
    }
    let c;
    if (this.outputBits >= 8) {
      c = this.codingPos & 1 ? 0 : 255;
      this.outputBits -= 8;
      if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
        this.codingPos++;
        this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
      }
    } else {
      bits = 8;
      c = 0;
      do {
        if (this.outputBits > bits) {
          c <<= bits;
          if (!(this.codingPos & 1)) {
            c |= 255 >> 8 - bits;
          }
          this.outputBits -= bits;
          bits = 0;
        } else {
          c <<= this.outputBits;
          if (!(this.codingPos & 1)) {
            c |= 255 >> 8 - this.outputBits;
          }
          bits -= this.outputBits;
          this.outputBits = 0;
          if (codingLine[this.codingPos] < columns) {
            this.codingPos++;
            this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
          } else if (bits > 0) {
            c <<= bits;
            bits = 0;
          }
        }
      } while (bits);
    }
    if (this.black) {
      c ^= 255;
    }
    return c;
  }
  /**
   * @private
   */
  _addPixels(a1, blackPixels) {
    const codingLine = this.codingLine;
    let codingPos = this.codingPos;
    if (a1 > codingLine[codingPos]) {
      if (a1 > this.columns) {
        info("row is wrong length");
        this.err = true;
        a1 = this.columns;
      }
      if (codingPos & 1 ^ blackPixels) {
        ++codingPos;
      }
      codingLine[codingPos] = a1;
    }
    this.codingPos = codingPos;
  }
  /**
   * @private
   */
  _addPixelsNeg(a1, blackPixels) {
    const codingLine = this.codingLine;
    let codingPos = this.codingPos;
    if (a1 > codingLine[codingPos]) {
      if (a1 > this.columns) {
        info("row is wrong length");
        this.err = true;
        a1 = this.columns;
      }
      if (codingPos & 1 ^ blackPixels) {
        ++codingPos;
      }
      codingLine[codingPos] = a1;
    } else if (a1 < codingLine[codingPos]) {
      if (a1 < 0) {
        info("invalid code");
        this.err = true;
        a1 = 0;
      }
      while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
        --codingPos;
      }
      codingLine[codingPos] = a1;
    }
    this.codingPos = codingPos;
  }
  /**
   * This function returns the code found from the table.
   * The start and end parameters set the boundaries for searching the table.
   * The limit parameter is optional. Function returns an array with three
   * values. The first array element indicates whether a valid code is being
   * returned. The second array element is the actual code. The third array
   * element indicates whether EOF was reached.
   * @private
   */
  _findTableCode(start, end, table, limit) {
    const limitValue = limit || 0;
    for (let i = start; i <= end; ++i) {
      let code = this._lookBits(i);
      if (code === ccittEOF) {
        return [true, 1, false];
      }
      if (i < end) {
        code <<= end - i;
      }
      if (!limitValue || code >= limitValue) {
        const p = table[code - limitValue];
        if (p[0] === i) {
          this._eatBits(i);
          return [true, p[1], true];
        }
      }
    }
    return [false, 0, false];
  }
  /**
   * @private
   */
  _getTwoDimCode() {
    let code = 0;
    let p;
    if (this.eoblock) {
      code = this._lookBits(7);
      p = twoDimTable[code];
      if (p && p[0] > 0) {
        this._eatBits(p[0]);
        return p[1];
      }
    } else {
      const result = this._findTableCode(1, 7, twoDimTable);
      if (result[0] && result[2]) {
        return result[1];
      }
    }
    info("Bad two dim code");
    return ccittEOF;
  }
  /**
   * @private
   */
  _getWhiteCode() {
    let code = 0;
    let p;
    if (this.eoblock) {
      code = this._lookBits(12);
      if (code === ccittEOF) {
        return 1;
      }
      if (code >> 5 === 0) {
        p = whiteTable1[code];
      } else {
        p = whiteTable2[code >> 3];
      }
      if (p[0] > 0) {
        this._eatBits(p[0]);
        return p[1];
      }
    } else {
      let result = this._findTableCode(1, 9, whiteTable2);
      if (result[0]) {
        return result[1];
      }
      result = this._findTableCode(11, 12, whiteTable1);
      if (result[0]) {
        return result[1];
      }
    }
    info("bad white code");
    this._eatBits(1);
    return 1;
  }
  /**
   * @private
   */
  _getBlackCode() {
    let code, p;
    if (this.eoblock) {
      code = this._lookBits(13);
      if (code === ccittEOF) {
        return 1;
      }
      if (code >> 7 === 0) {
        p = blackTable1[code];
      } else if (code >> 9 === 0 && code >> 7 !== 0) {
        p = blackTable2[(code >> 1) - 64];
      } else {
        p = blackTable3[code >> 7];
      }
      if (p[0] > 0) {
        this._eatBits(p[0]);
        return p[1];
      }
    } else {
      let result = this._findTableCode(2, 6, blackTable3);
      if (result[0]) {
        return result[1];
      }
      result = this._findTableCode(7, 12, blackTable2, 64);
      if (result[0]) {
        return result[1];
      }
      result = this._findTableCode(10, 13, blackTable1);
      if (result[0]) {
        return result[1];
      }
    }
    info("bad black code");
    this._eatBits(1);
    return 1;
  }
  /**
   * @private
   */
  _lookBits(n) {
    let c;
    while (this.inputBits < n) {
      if ((c = this.source.next()) === -1) {
        if (this.inputBits === 0) {
          return ccittEOF;
        }
        return this.inputBuf << n - this.inputBits & 65535 >> 16 - n;
      }
      this.inputBuf = this.inputBuf << 8 | c;
      this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - n & 65535 >> 16 - n;
  }
  /**
   * @private
   */
  _eatBits(n) {
    if ((this.inputBits -= n) < 0) {
      this.inputBits = 0;
    }
  }
};
var CCITTFaxStream = class extends DecodeStream {
  constructor(str, maybeLength, params) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    if (!isDict(params)) {
      params = Dict.empty;
    }
    const source = {
      next() {
        return str.getByte();
      }
    };
    this.ccittFaxDecoder = new CCITTFaxDecoder(source, {
      K: params.get("K"),
      EndOfLine: params.get("EndOfLine"),
      EncodedByteAlign: params.get("EncodedByteAlign"),
      Columns: params.get("Columns"),
      Rows: params.get("Rows"),
      EndOfBlock: params.get("EndOfBlock"),
      BlackIs1: params.get("BlackIs1")
    });
  }
  readBlock() {
    while (!this.eof) {
      const c = this.ccittFaxDecoder.readNextChar();
      if (c === -1) {
        this.eof = true;
        return;
      }
      this.ensureBuffer(this.bufferLength + 1);
      this.buffer[this.bufferLength++] = c;
    }
  }
};
var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var lengthDecode = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
var distDecode = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
var fixedLitCodeTab = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
var fixedDistCodeTab = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
var FlateStream = class extends DecodeStream {
  constructor(str, maybeLength) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    const cmf = str.getByte();
    const flg = str.getByte();
    if (cmf === -1 || flg === -1) {
      throw new FormatError(`Invalid header in flate stream: ${cmf}, ${flg}`);
    }
    if ((cmf & 15) !== 8) {
      throw new FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
    }
    if (((cmf << 8) + flg) % 31 !== 0) {
      throw new FormatError(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);
    }
    if (flg & 32) {
      throw new FormatError(`FDICT bit set in flate stream: ${cmf}, ${flg}`);
    }
    this.codeSize = 0;
    this.codeBuf = 0;
  }
  getBits(bits) {
    const str = this.str;
    let codeSize = this.codeSize;
    let codeBuf = this.codeBuf;
    let b;
    while (codeSize < bits) {
      if ((b = str.getByte()) === -1) {
        throw new FormatError("Bad encoding in flate stream");
      }
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    b = codeBuf & (1 << bits) - 1;
    this.codeBuf = codeBuf >> bits;
    this.codeSize = codeSize -= bits;
    return b;
  }
  getCode(table) {
    const str = this.str;
    const codes = table[0];
    const maxLen = table[1];
    let codeSize = this.codeSize;
    let codeBuf = this.codeBuf;
    let b;
    while (codeSize < maxLen) {
      if ((b = str.getByte()) === -1) {
        break;
      }
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    const code = codes[codeBuf & (1 << maxLen) - 1];
    const codeLen = code >> 16;
    const codeVal = code & 65535;
    if (codeLen < 1 || codeSize < codeLen) {
      throw new FormatError("Bad encoding in flate stream");
    }
    this.codeBuf = codeBuf >> codeLen;
    this.codeSize = codeSize - codeLen;
    return codeVal;
  }
  generateHuffmanTable(lengths) {
    const n = lengths.length;
    let maxLen = 0;
    let i;
    for (i = 0; i < n; ++i) {
      if (lengths[i] > maxLen) {
        maxLen = lengths[i];
      }
    }
    const size = 1 << maxLen;
    const codes = new Int32Array(size);
    for (let len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
      for (let val = 0; val < n; ++val) {
        if (lengths[val] === len) {
          let code2 = 0;
          let t = code;
          for (i = 0; i < len; ++i) {
            code2 = code2 << 1 | t & 1;
            t >>= 1;
          }
          for (i = code2; i < size; i += skip) {
            codes[i] = len << 16 | val;
          }
          ++code;
        }
      }
    }
    return [codes, maxLen];
  }
  readBlock() {
    let buffer, len;
    const str = this.str;
    let hdr = this.getBits(3);
    if (hdr & 1) {
      this.eof = true;
    }
    hdr >>= 1;
    if (hdr === 0) {
      let b;
      if ((b = str.getByte()) === -1) {
        throw new FormatError("Bad block header in flate stream");
      }
      let blockLen = b;
      if ((b = str.getByte()) === -1) {
        throw new FormatError("Bad block header in flate stream");
      }
      blockLen |= b << 8;
      if ((b = str.getByte()) === -1) {
        throw new FormatError("Bad block header in flate stream");
      }
      let check = b;
      if ((b = str.getByte()) === -1) {
        throw new FormatError("Bad block header in flate stream");
      }
      check |= b << 8;
      if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
        throw new FormatError("Bad uncompressed block length in flate stream");
      }
      this.codeBuf = 0;
      this.codeSize = 0;
      const bufferLength = this.bufferLength, end = bufferLength + blockLen;
      buffer = this.ensureBuffer(end);
      this.bufferLength = end;
      if (blockLen === 0) {
        if (str.peekByte() === -1) {
          this.eof = true;
        }
      } else {
        const block = str.getBytes(blockLen);
        buffer.set(block, bufferLength);
        if (block.length < blockLen) {
          this.eof = true;
        }
      }
      return;
    }
    let litCodeTable;
    let distCodeTable;
    if (hdr === 1) {
      litCodeTable = fixedLitCodeTab;
      distCodeTable = fixedDistCodeTab;
    } else if (hdr === 2) {
      const numLitCodes = this.getBits(5) + 257;
      const numDistCodes = this.getBits(5) + 1;
      const numCodeLenCodes = this.getBits(4) + 4;
      const codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
      let i;
      for (i = 0; i < numCodeLenCodes; ++i) {
        codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
      }
      const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
      len = 0;
      i = 0;
      const codes = numLitCodes + numDistCodes;
      const codeLengths = new Uint8Array(codes);
      let bitsLength, bitsOffset, what;
      while (i < codes) {
        const code = this.getCode(codeLenCodeTab);
        if (code === 16) {
          bitsLength = 2;
          bitsOffset = 3;
          what = len;
        } else if (code === 17) {
          bitsLength = 3;
          bitsOffset = 3;
          what = len = 0;
        } else if (code === 18) {
          bitsLength = 7;
          bitsOffset = 11;
          what = len = 0;
        } else {
          codeLengths[i++] = len = code;
          continue;
        }
        let repeatLength = this.getBits(bitsLength) + bitsOffset;
        while (repeatLength-- > 0) {
          codeLengths[i++] = what;
        }
      }
      litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
      distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
    } else {
      throw new FormatError("Unknown block type in flate stream");
    }
    buffer = this.buffer;
    let limit = buffer ? buffer.length : 0;
    let pos = this.bufferLength;
    while (true) {
      let code1 = this.getCode(litCodeTable);
      if (code1 < 256) {
        if (pos + 1 >= limit) {
          buffer = this.ensureBuffer(pos + 1);
          limit = buffer.length;
        }
        buffer[pos++] = code1;
        continue;
      }
      if (code1 === 256) {
        this.bufferLength = pos;
        return;
      }
      code1 -= 257;
      code1 = lengthDecode[code1];
      let code2 = code1 >> 16;
      if (code2 > 0) {
        code2 = this.getBits(code2);
      }
      len = (code1 & 65535) + code2;
      code1 = this.getCode(distCodeTable);
      code1 = distDecode[code1];
      code2 = code1 >> 16;
      if (code2 > 0) {
        code2 = this.getBits(code2);
      }
      const dist = (code1 & 65535) + code2;
      if (pos + len >= limit) {
        buffer = this.ensureBuffer(pos + len);
        limit = buffer.length;
      }
      for (let k = 0; k < len; ++k, ++pos) {
        buffer[pos] = buffer[pos - dist];
      }
    }
  }
};
var QeTable = [{
  qe: 22017,
  nmps: 1,
  nlps: 1,
  switchFlag: 1
}, {
  qe: 13313,
  nmps: 2,
  nlps: 6,
  switchFlag: 0
}, {
  qe: 6145,
  nmps: 3,
  nlps: 9,
  switchFlag: 0
}, {
  qe: 2753,
  nmps: 4,
  nlps: 12,
  switchFlag: 0
}, {
  qe: 1313,
  nmps: 5,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 545,
  nmps: 38,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 22017,
  nmps: 7,
  nlps: 6,
  switchFlag: 1
}, {
  qe: 21505,
  nmps: 8,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 18433,
  nmps: 9,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 14337,
  nmps: 10,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 12289,
  nmps: 11,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 9217,
  nmps: 12,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 7169,
  nmps: 13,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 5633,
  nmps: 29,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 22017,
  nmps: 15,
  nlps: 14,
  switchFlag: 1
}, {
  qe: 21505,
  nmps: 16,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 20737,
  nmps: 17,
  nlps: 15,
  switchFlag: 0
}, {
  qe: 18433,
  nmps: 18,
  nlps: 16,
  switchFlag: 0
}, {
  qe: 14337,
  nmps: 19,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 13313,
  nmps: 20,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 12289,
  nmps: 21,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 10241,
  nmps: 22,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 9217,
  nmps: 23,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 8705,
  nmps: 24,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 7169,
  nmps: 25,
  nlps: 22,
  switchFlag: 0
}, {
  qe: 6145,
  nmps: 26,
  nlps: 23,
  switchFlag: 0
}, {
  qe: 5633,
  nmps: 27,
  nlps: 24,
  switchFlag: 0
}, {
  qe: 5121,
  nmps: 28,
  nlps: 25,
  switchFlag: 0
}, {
  qe: 4609,
  nmps: 29,
  nlps: 26,
  switchFlag: 0
}, {
  qe: 4353,
  nmps: 30,
  nlps: 27,
  switchFlag: 0
}, {
  qe: 2753,
  nmps: 31,
  nlps: 28,
  switchFlag: 0
}, {
  qe: 2497,
  nmps: 32,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 2209,
  nmps: 33,
  nlps: 30,
  switchFlag: 0
}, {
  qe: 1313,
  nmps: 34,
  nlps: 31,
  switchFlag: 0
}, {
  qe: 1089,
  nmps: 35,
  nlps: 32,
  switchFlag: 0
}, {
  qe: 673,
  nmps: 36,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 545,
  nmps: 37,
  nlps: 34,
  switchFlag: 0
}, {
  qe: 321,
  nmps: 38,
  nlps: 35,
  switchFlag: 0
}, {
  qe: 273,
  nmps: 39,
  nlps: 36,
  switchFlag: 0
}, {
  qe: 133,
  nmps: 40,
  nlps: 37,
  switchFlag: 0
}, {
  qe: 73,
  nmps: 41,
  nlps: 38,
  switchFlag: 0
}, {
  qe: 37,
  nmps: 42,
  nlps: 39,
  switchFlag: 0
}, {
  qe: 21,
  nmps: 43,
  nlps: 40,
  switchFlag: 0
}, {
  qe: 9,
  nmps: 44,
  nlps: 41,
  switchFlag: 0
}, {
  qe: 5,
  nmps: 45,
  nlps: 42,
  switchFlag: 0
}, {
  qe: 1,
  nmps: 45,
  nlps: 43,
  switchFlag: 0
}, {
  qe: 22017,
  nmps: 46,
  nlps: 46,
  switchFlag: 0
}];
var ArithmeticDecoder = class {
  // C.3.5 Initialisation of the decoder (INITDEC)
  constructor(data, start, end) {
    this.data = data;
    this.bp = start;
    this.dataEnd = end;
    this.chigh = data[start];
    this.clow = 0;
    this.byteIn();
    this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
    this.clow = this.clow << 7 & 65535;
    this.ct -= 7;
    this.a = 32768;
  }
  // C.3.4 Compressed data input (BYTEIN)
  byteIn() {
    const data = this.data;
    let bp = this.bp;
    if (data[bp] === 255) {
      if (data[bp + 1] > 143) {
        this.clow += 65280;
        this.ct = 8;
      } else {
        bp++;
        this.clow += data[bp] << 9;
        this.ct = 7;
        this.bp = bp;
      }
    } else {
      bp++;
      this.clow += bp < this.dataEnd ? data[bp] << 8 : 65280;
      this.ct = 8;
      this.bp = bp;
    }
    if (this.clow > 65535) {
      this.chigh += this.clow >> 16;
      this.clow &= 65535;
    }
  }
  // C.3.2 Decoding a decision (DECODE)
  readBit(contexts, pos) {
    let cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
    const qeTableIcx = QeTable[cx_index];
    const qeIcx = qeTableIcx.qe;
    let d;
    let a = this.a - qeIcx;
    if (this.chigh < qeIcx) {
      if (a < qeIcx) {
        a = qeIcx;
        d = cx_mps;
        cx_index = qeTableIcx.nmps;
      } else {
        a = qeIcx;
        d = 1 ^ cx_mps;
        if (qeTableIcx.switchFlag === 1) {
          cx_mps = d;
        }
        cx_index = qeTableIcx.nlps;
      }
    } else {
      this.chigh -= qeIcx;
      if ((a & 32768) !== 0) {
        this.a = a;
        return cx_mps;
      }
      if (a < qeIcx) {
        d = 1 ^ cx_mps;
        if (qeTableIcx.switchFlag === 1) {
          cx_mps = d;
        }
        cx_index = qeTableIcx.nlps;
      } else {
        d = cx_mps;
        cx_index = qeTableIcx.nmps;
      }
    }
    do {
      if (this.ct === 0) {
        this.byteIn();
      }
      a <<= 1;
      this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
      this.clow = this.clow << 1 & 65535;
      this.ct--;
    } while ((a & 32768) === 0);
    this.a = a;
    contexts[pos] = cx_index << 1 | cx_mps;
    return d;
  }
};
var Jbig2Error = class extends BaseException {
  constructor(msg) {
    super(`JBIG2 error: ${msg}`);
  }
};
var ContextCache = class {
  getContexts(id) {
    if (id in this) {
      return this[id];
    }
    return this[id] = new Int8Array(1 << 16);
  }
};
var DecodingContext = class {
  constructor(data, start, end) {
    this.data = data;
    this.start = start;
    this.end = end;
  }
  get decoder() {
    const decoder = new ArithmeticDecoder(this.data, this.start, this.end);
    return shadow(this, "decoder", decoder);
  }
  get contextCache() {
    const cache = new ContextCache();
    return shadow(this, "contextCache", cache);
  }
};
function decodeInteger(contextCache, procedure, decoder) {
  const contexts = contextCache.getContexts(procedure);
  let prev = 1;
  function readBits(length) {
    let v = 0;
    for (let i = 0; i < length; i++) {
      const bit = decoder.readBit(contexts, prev);
      prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
      v = v << 1 | bit;
    }
    return v >>> 0;
  }
  const sign = readBits(1);
  const value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
  if (sign === 0) {
    return value;
  } else if (value > 0) {
    return -value;
  }
  return null;
}
function decodeIAID(contextCache, decoder, codeLength) {
  const contexts = contextCache.getContexts("IAID");
  let prev = 1;
  for (let i = 0; i < codeLength; i++) {
    const bit = decoder.readBit(contexts, prev);
    prev = prev << 1 | bit;
  }
  if (codeLength < 31) {
    return prev & (1 << codeLength) - 1;
  }
  return prev & 2147483647;
}
var SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
var CodingTemplates = [[{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: 2,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -3,
  y: -1
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}]];
var RefinementTemplates = [{
  coding: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: -1,
    y: 1
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}, {
  coding: [{
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}];
var ReusedContexts = [
  39717,
  // 10011 0110010 0101
  1941,
  // 0011 110010 101
  229,
  // 001 11001 01
  405
  // 011001 0101
];
var RefinementReusedContexts = [
  32,
  // '000' + '0' (coding) + '00010000' + '0' (reference)
  8
  // '0000' + '001000'
];
function decodeBitmapTemplate0(width, height, decodingContext) {
  const decoder = decodingContext.decoder;
  const contexts = decodingContext.contextCache.getContexts("GB");
  const bitmap = [];
  let contextLabel, i, j, pixel, row, row1, row2;
  const OLD_PIXEL_MASK = 31735;
  for (i = 0; i < height; i++) {
    row = bitmap[i] = new Uint8Array(width);
    row1 = i < 1 ? row : bitmap[i - 1];
    row2 = i < 2 ? row : bitmap[i - 2];
    contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;
    for (j = 0; j < width; j++) {
      row[j] = pixel = decoder.readBit(contexts, contextLabel);
      contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
    }
  }
  return bitmap;
}
function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
  if (mmr) {
    const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
    return decodeMMRBitmap(input, width, height, false);
  }
  if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
    return decodeBitmapTemplate0(width, height, decodingContext);
  }
  const useskip = !!skip;
  const template = CodingTemplates[templateIndex].concat(at);
  template.sort(function(a, b) {
    return a.y - b.y || a.x - b.x;
  });
  const templateLength = template.length;
  const templateX = new Int8Array(templateLength);
  const templateY = new Int8Array(templateLength);
  const changingTemplateEntries = [];
  let reuseMask = 0, minX = 0, maxX = 0, minY = 0;
  let c, k;
  for (k = 0; k < templateLength; k++) {
    templateX[k] = template[k].x;
    templateY[k] = template[k].y;
    minX = Math.min(minX, template[k].x);
    maxX = Math.max(maxX, template[k].x);
    minY = Math.min(minY, template[k].y);
    if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
      reuseMask |= 1 << templateLength - 1 - k;
    } else {
      changingTemplateEntries.push(k);
    }
  }
  const changingEntriesLength = changingTemplateEntries.length;
  const changingTemplateX = new Int8Array(changingEntriesLength);
  const changingTemplateY = new Int8Array(changingEntriesLength);
  const changingTemplateBit = new Uint16Array(changingEntriesLength);
  for (c = 0; c < changingEntriesLength; c++) {
    k = changingTemplateEntries[c];
    changingTemplateX[c] = template[k].x;
    changingTemplateY[c] = template[k].y;
    changingTemplateBit[c] = 1 << templateLength - 1 - k;
  }
  const sbb_left = -minX;
  const sbb_top = -minY;
  const sbb_right = width - maxX;
  const pseudoPixelContext = ReusedContexts[templateIndex];
  let row = new Uint8Array(width);
  const bitmap = [];
  const decoder = decodingContext.decoder;
  const contexts = decodingContext.contextCache.getContexts("GB");
  let ltp = 0, j, i0, j0, contextLabel = 0, bit, shift;
  for (let i = 0; i < height; i++) {
    if (prediction) {
      const sltp = decoder.readBit(contexts, pseudoPixelContext);
      ltp ^= sltp;
      if (ltp) {
        bitmap.push(row);
        continue;
      }
    }
    row = new Uint8Array(row);
    bitmap.push(row);
    for (j = 0; j < width; j++) {
      if (useskip && skip[i][j]) {
        row[j] = 0;
        continue;
      }
      if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
        contextLabel = contextLabel << 1 & reuseMask;
        for (k = 0; k < changingEntriesLength; k++) {
          i0 = i + changingTemplateY[k];
          j0 = j + changingTemplateX[k];
          bit = bitmap[i0][j0];
          if (bit) {
            bit = changingTemplateBit[k];
            contextLabel |= bit;
          }
        }
      } else {
        contextLabel = 0;
        shift = templateLength - 1;
        for (k = 0; k < templateLength; k++, shift--) {
          j0 = j + templateX[k];
          if (j0 >= 0 && j0 < width) {
            i0 = i + templateY[k];
            if (i0 >= 0) {
              bit = bitmap[i0][j0];
              if (bit) {
                contextLabel |= bit << shift;
              }
            }
          }
        }
      }
      const pixel = decoder.readBit(contexts, contextLabel);
      row[j] = pixel;
    }
  }
  return bitmap;
}
function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
  let codingTemplate = RefinementTemplates[templateIndex].coding;
  if (templateIndex === 0) {
    codingTemplate = codingTemplate.concat([at[0]]);
  }
  const codingTemplateLength = codingTemplate.length;
  const codingTemplateX = new Int32Array(codingTemplateLength);
  const codingTemplateY = new Int32Array(codingTemplateLength);
  let k;
  for (k = 0; k < codingTemplateLength; k++) {
    codingTemplateX[k] = codingTemplate[k].x;
    codingTemplateY[k] = codingTemplate[k].y;
  }
  let referenceTemplate = RefinementTemplates[templateIndex].reference;
  if (templateIndex === 0) {
    referenceTemplate = referenceTemplate.concat([at[1]]);
  }
  const referenceTemplateLength = referenceTemplate.length;
  const referenceTemplateX = new Int32Array(referenceTemplateLength);
  const referenceTemplateY = new Int32Array(referenceTemplateLength);
  for (k = 0; k < referenceTemplateLength; k++) {
    referenceTemplateX[k] = referenceTemplate[k].x;
    referenceTemplateY[k] = referenceTemplate[k].y;
  }
  const referenceWidth = referenceBitmap[0].length;
  const referenceHeight = referenceBitmap.length;
  const pseudoPixelContext = RefinementReusedContexts[templateIndex];
  const bitmap = [];
  const decoder = decodingContext.decoder;
  const contexts = decodingContext.contextCache.getContexts("GR");
  let ltp = 0;
  for (let i = 0; i < height; i++) {
    if (prediction) {
      const sltp = decoder.readBit(contexts, pseudoPixelContext);
      ltp ^= sltp;
      if (ltp) {
        throw new Jbig2Error("prediction is not supported");
      }
    }
    const row = new Uint8Array(width);
    bitmap.push(row);
    for (let j = 0; j < width; j++) {
      let i0, j0;
      let contextLabel = 0;
      for (k = 0; k < codingTemplateLength; k++) {
        i0 = i + codingTemplateY[k];
        j0 = j + codingTemplateX[k];
        if (i0 < 0 || j0 < 0 || j0 >= width) {
          contextLabel <<= 1;
        } else {
          contextLabel = contextLabel << 1 | bitmap[i0][j0];
        }
      }
      for (k = 0; k < referenceTemplateLength; k++) {
        i0 = i + referenceTemplateY[k] - offsetY;
        j0 = j + referenceTemplateX[k] - offsetX;
        if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
          contextLabel <<= 1;
        } else {
          contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
        }
      }
      const pixel = decoder.readBit(contexts, contextLabel);
      row[j] = pixel;
    }
  }
  return bitmap;
}
function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
  if (huffman && refinement) {
    throw new Jbig2Error("symbol refinement with Huffman is not supported");
  }
  const newSymbols = [];
  let currentHeight = 0;
  let symbolCodeLength = log2(symbols.length + numberOfNewSymbols);
  const decoder = decodingContext.decoder;
  const contextCache = decodingContext.contextCache;
  let tableB1, symbolWidths;
  if (huffman) {
    tableB1 = getStandardTable(1);
    symbolWidths = [];
    symbolCodeLength = Math.max(symbolCodeLength, 1);
  }
  while (newSymbols.length < numberOfNewSymbols) {
    const deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
    currentHeight += deltaHeight;
    let currentWidth = 0, totalWidth = 0;
    const firstSymbol = huffman ? symbolWidths.length : 0;
    while (true) {
      const deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);
      if (deltaWidth === null) {
        break;
      }
      currentWidth += deltaWidth;
      totalWidth += currentWidth;
      let bitmap;
      if (refinement) {
        const numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);
        if (numberOfInstances > 1) {
          bitmap = decodeTextRegion(
            huffman,
            refinement,
            currentWidth,
            currentHeight,
            0,
            numberOfInstances,
            1,
            // strip size
            symbols.concat(newSymbols),
            symbolCodeLength,
            0,
            // transposed
            0,
            // ds offset
            1,
            // top left 7.4.3.1.1
            0,
            // OR operator
            huffmanTables,
            refinementTemplateIndex,
            refinementAt,
            decodingContext,
            0,
            huffmanInput
          );
        } else {
          const symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
          const rdx = decodeInteger(contextCache, "IARDX", decoder);
          const rdy = decodeInteger(contextCache, "IARDY", decoder);
          const symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
          bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
        }
        newSymbols.push(bitmap);
      } else if (huffman) {
        symbolWidths.push(currentWidth);
      } else {
        bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
        newSymbols.push(bitmap);
      }
    }
    if (huffman && !refinement) {
      const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
      huffmanInput.byteAlign();
      let collectiveBitmap;
      if (bitmapSize === 0) {
        collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
      } else {
        const originalEnd = huffmanInput.end;
        const bitmapEnd = huffmanInput.position + bitmapSize;
        huffmanInput.end = bitmapEnd;
        collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
        huffmanInput.end = originalEnd;
        huffmanInput.position = bitmapEnd;
      }
      const numberOfSymbolsDecoded = symbolWidths.length;
      if (firstSymbol === numberOfSymbolsDecoded - 1) {
        newSymbols.push(collectiveBitmap);
      } else {
        let i2, y, xMin = 0, xMax, bitmapWidth, symbolBitmap;
        for (i2 = firstSymbol; i2 < numberOfSymbolsDecoded; i2++) {
          bitmapWidth = symbolWidths[i2];
          xMax = xMin + bitmapWidth;
          symbolBitmap = [];
          for (y = 0; y < currentHeight; y++) {
            symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
          }
          newSymbols.push(symbolBitmap);
          xMin = xMax;
        }
      }
    }
  }
  const exportedSymbols = [], flags = [];
  let currentFlag = false, i, ii;
  const totalSymbolsLength = symbols.length + numberOfNewSymbols;
  while (flags.length < totalSymbolsLength) {
    let runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);
    while (runLength--) {
      flags.push(currentFlag);
    }
    currentFlag = !currentFlag;
  }
  for (i = 0, ii = symbols.length; i < ii; i++) {
    if (flags[i]) {
      exportedSymbols.push(symbols[i]);
    }
  }
  for (let j = 0; j < numberOfNewSymbols; i++, j++) {
    if (flags[i]) {
      exportedSymbols.push(newSymbols[j]);
    }
  }
  return exportedSymbols;
}
function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
  if (huffman && refinement) {
    throw new Jbig2Error("refinement with Huffman is not supported");
  }
  const bitmap = [];
  let i, row;
  for (i = 0; i < height; i++) {
    row = new Uint8Array(width);
    if (defaultPixelValue) {
      for (let j = 0; j < width; j++) {
        row[j] = defaultPixelValue;
      }
    }
    bitmap.push(row);
  }
  const decoder = decodingContext.decoder;
  const contextCache = decodingContext.contextCache;
  let stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
  let firstS = 0;
  i = 0;
  while (i < numberOfSymbolInstances) {
    const deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
    stripT += deltaT;
    const deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
    firstS += deltaFirstS;
    let currentS = firstS;
    do {
      let currentT = 0;
      if (stripSize > 1) {
        currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
      }
      const t = stripSize * stripT + currentT;
      const symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
      const applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
      let symbolBitmap = inputSymbols[symbolId];
      let symbolWidth = symbolBitmap[0].length;
      let symbolHeight = symbolBitmap.length;
      if (applyRefinement) {
        const rdw = decodeInteger(contextCache, "IARDW", decoder);
        const rdh = decodeInteger(contextCache, "IARDH", decoder);
        const rdx = decodeInteger(contextCache, "IARDX", decoder);
        const rdy = decodeInteger(contextCache, "IARDY", decoder);
        symbolWidth += rdw;
        symbolHeight += rdh;
        symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
      }
      const offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);
      const offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
      let s2, t2, symbolRow;
      if (transposed) {
        for (s2 = 0; s2 < symbolHeight; s2++) {
          row = bitmap[offsetS + s2];
          if (!row) {
            continue;
          }
          symbolRow = symbolBitmap[s2];
          const maxWidth = Math.min(width - offsetT, symbolWidth);
          switch (combinationOperator) {
            case 0:
              for (t2 = 0; t2 < maxWidth; t2++) {
                row[offsetT + t2] |= symbolRow[t2];
              }
              break;
            case 2:
              for (t2 = 0; t2 < maxWidth; t2++) {
                row[offsetT + t2] ^= symbolRow[t2];
              }
              break;
            default:
              throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
          }
        }
        currentS += symbolHeight - 1;
      } else {
        for (t2 = 0; t2 < symbolHeight; t2++) {
          row = bitmap[offsetT + t2];
          if (!row) {
            continue;
          }
          symbolRow = symbolBitmap[t2];
          switch (combinationOperator) {
            case 0:
              for (s2 = 0; s2 < symbolWidth; s2++) {
                row[offsetS + s2] |= symbolRow[s2];
              }
              break;
            case 2:
              for (s2 = 0; s2 < symbolWidth; s2++) {
                row[offsetS + s2] ^= symbolRow[s2];
              }
              break;
            default:
              throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
          }
        }
        currentS += symbolWidth - 1;
      }
      i++;
      const deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);
      if (deltaS === null) {
        break;
      }
      currentS += deltaS + dsOffset;
    } while (true);
  }
  return bitmap;
}
function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
  const at = [];
  if (!mmr) {
    at.push({
      x: -patternWidth,
      y: 0
    });
    if (template === 0) {
      at.push({
        x: -3,
        y: -1
      }, {
        x: 2,
        y: -2
      }, {
        x: -2,
        y: -2
      });
    }
  }
  const collectiveWidth = (maxPatternIndex + 1) * patternWidth;
  const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
  const patterns = [];
  for (let i = 0; i <= maxPatternIndex; i++) {
    const patternBitmap = [];
    const xMin = patternWidth * i;
    const xMax = xMin + patternWidth;
    for (let y = 0; y < patternHeight; y++) {
      patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
    }
    patterns.push(patternBitmap);
  }
  return patterns;
}
function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
  const skip = null;
  if (enableSkip) {
    throw new Jbig2Error("skip is not supported");
  }
  if (combinationOperator !== 0) {
    throw new Jbig2Error(`operator "${combinationOperator}" is not supported in halftone region`);
  }
  const regionBitmap = [];
  let i, j, row;
  for (i = 0; i < regionHeight; i++) {
    row = new Uint8Array(regionWidth);
    if (defaultPixelValue) {
      for (j = 0; j < regionWidth; j++) {
        row[j] = defaultPixelValue;
      }
    }
    regionBitmap.push(row);
  }
  const numberOfPatterns = patterns.length;
  const pattern0 = patterns[0];
  const patternWidth = pattern0[0].length, patternHeight = pattern0.length;
  const bitsPerValue = log2(numberOfPatterns);
  const at = [];
  if (!mmr) {
    at.push({
      x: template <= 1 ? 3 : 2,
      y: -1
    });
    if (template === 0) {
      at.push({
        x: -3,
        y: -1
      }, {
        x: 2,
        y: -2
      }, {
        x: -2,
        y: -2
      });
    }
  }
  const grayScaleBitPlanes = [];
  let mmrInput, bitmap;
  if (mmr) {
    mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
  }
  for (i = bitsPerValue - 1; i >= 0; i--) {
    if (mmr) {
      bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
    } else {
      bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
    }
    grayScaleBitPlanes[i] = bitmap;
  }
  let mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow;
  for (mg = 0; mg < gridHeight; mg++) {
    for (ng = 0; ng < gridWidth; ng++) {
      bit = 0;
      patternIndex = 0;
      for (j = bitsPerValue - 1; j >= 0; j--) {
        bit ^= grayScaleBitPlanes[j][mg][ng];
        patternIndex |= bit << j;
      }
      patternBitmap = patterns[patternIndex];
      x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
      y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;
      if (x >= 0 && x + patternWidth <= regionWidth && y >= 0 && y + patternHeight <= regionHeight) {
        for (i = 0; i < patternHeight; i++) {
          regionRow = regionBitmap[y + i];
          patternRow = patternBitmap[i];
          for (j = 0; j < patternWidth; j++) {
            regionRow[x + j] |= patternRow[j];
          }
        }
      } else {
        let regionX, regionY;
        for (i = 0; i < patternHeight; i++) {
          regionY = y + i;
          if (regionY < 0 || regionY >= regionHeight) {
            continue;
          }
          regionRow = regionBitmap[regionY];
          patternRow = patternBitmap[i];
          for (j = 0; j < patternWidth; j++) {
            regionX = x + j;
            if (regionX >= 0 && regionX < regionWidth) {
              regionRow[regionX] |= patternRow[j];
            }
          }
        }
      }
    }
  }
  return regionBitmap;
}
function readSegmentHeader(data, start) {
  const segmentHeader = {};
  segmentHeader.number = readUint32(data, start);
  const flags = data[start + 4];
  const segmentType = flags & 63;
  if (!SegmentTypes[segmentType]) {
    throw new Jbig2Error("invalid segment type: " + segmentType);
  }
  segmentHeader.type = segmentType;
  segmentHeader.typeName = SegmentTypes[segmentType];
  segmentHeader.deferredNonRetain = !!(flags & 128);
  const pageAssociationFieldSize = !!(flags & 64);
  const referredFlags = data[start + 5];
  let referredToCount = referredFlags >> 5 & 7;
  const retainBits = [referredFlags & 31];
  let position = start + 6;
  if (referredFlags === 7) {
    referredToCount = readUint32(data, position - 1) & 536870911;
    position += 3;
    let bytes = referredToCount + 7 >> 3;
    retainBits[0] = data[position++];
    while (--bytes > 0) {
      retainBits.push(data[position++]);
    }
  } else if (referredFlags === 5 || referredFlags === 6) {
    throw new Jbig2Error("invalid referred-to flags");
  }
  segmentHeader.retainBits = retainBits;
  let referredToSegmentNumberSize = 4;
  if (segmentHeader.number <= 256) {
    referredToSegmentNumberSize = 1;
  } else if (segmentHeader.number <= 65536) {
    referredToSegmentNumberSize = 2;
  }
  const referredTo = [];
  let i, ii;
  for (i = 0; i < referredToCount; i++) {
    let number;
    if (referredToSegmentNumberSize === 1) {
      number = data[position];
    } else if (referredToSegmentNumberSize === 2) {
      number = readUint16(data, position);
    } else {
      number = readUint32(data, position);
    }
    referredTo.push(number);
    position += referredToSegmentNumberSize;
  }
  segmentHeader.referredTo = referredTo;
  if (!pageAssociationFieldSize) {
    segmentHeader.pageAssociation = data[position++];
  } else {
    segmentHeader.pageAssociation = readUint32(data, position);
    position += 4;
  }
  segmentHeader.length = readUint32(data, position);
  position += 4;
  if (segmentHeader.length === 4294967295) {
    if (segmentType === 38) {
      const genericRegionInfo = readRegionSegmentInformation(data, position);
      const genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
      const genericRegionMmr = !!(genericRegionSegmentFlags & 1);
      const searchPatternLength = 6;
      const searchPattern = new Uint8Array(searchPatternLength);
      if (!genericRegionMmr) {
        searchPattern[0] = 255;
        searchPattern[1] = 172;
      }
      searchPattern[2] = genericRegionInfo.height >>> 24 & 255;
      searchPattern[3] = genericRegionInfo.height >> 16 & 255;
      searchPattern[4] = genericRegionInfo.height >> 8 & 255;
      searchPattern[5] = genericRegionInfo.height & 255;
      for (i = position, ii = data.length; i < ii; i++) {
        let j = 0;
        while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
          j++;
        }
        if (j === searchPatternLength) {
          segmentHeader.length = i + searchPatternLength;
          break;
        }
      }
      if (segmentHeader.length === 4294967295) {
        throw new Jbig2Error("segment end was not found");
      }
    } else {
      throw new Jbig2Error("invalid unknown segment length");
    }
  }
  segmentHeader.headerEnd = position;
  return segmentHeader;
}
function readSegments(header, data, start, end) {
  const segments = [];
  let position = start;
  while (position < end) {
    const segmentHeader = readSegmentHeader(data, position);
    position = segmentHeader.headerEnd;
    const segment = {
      header: segmentHeader,
      data
    };
    if (!header.randomAccess) {
      segment.start = position;
      position += segmentHeader.length;
      segment.end = position;
    }
    segments.push(segment);
    if (segmentHeader.type === 51) {
      break;
    }
  }
  if (header.randomAccess) {
    for (let i = 0, ii = segments.length; i < ii; i++) {
      segments[i].start = position;
      position += segments[i].header.length;
      segments[i].end = position;
    }
  }
  return segments;
}
function readRegionSegmentInformation(data, start) {
  return {
    width: readUint32(data, start),
    height: readUint32(data, start + 4),
    x: readUint32(data, start + 8),
    y: readUint32(data, start + 12),
    combinationOperator: data[start + 16] & 7
  };
}
var RegionSegmentInformationFieldLength = 17;
function processSegment(segment, visitor) {
  const header = segment.header;
  const data = segment.data, end = segment.end;
  let position = segment.start;
  let args, at, i, atLength;
  switch (header.type) {
    case 0:
      const dictionary = {};
      const dictionaryFlags = readUint16(data, position);
      dictionary.huffman = !!(dictionaryFlags & 1);
      dictionary.refinement = !!(dictionaryFlags & 2);
      dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
      dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
      dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
      dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
      dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
      dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
      dictionary.template = dictionaryFlags >> 10 & 3;
      dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
      position += 2;
      if (!dictionary.huffman) {
        atLength = dictionary.template === 0 ? 4 : 1;
        at = [];
        for (i = 0; i < atLength; i++) {
          at.push({
            x: readInt8(data, position),
            y: readInt8(data, position + 1)
          });
          position += 2;
        }
        dictionary.at = at;
      }
      if (dictionary.refinement && !dictionary.refinementTemplate) {
        at = [];
        for (i = 0; i < 2; i++) {
          at.push({
            x: readInt8(data, position),
            y: readInt8(data, position + 1)
          });
          position += 2;
        }
        dictionary.refinementAt = at;
      }
      dictionary.numberOfExportedSymbols = readUint32(data, position);
      position += 4;
      dictionary.numberOfNewSymbols = readUint32(data, position);
      position += 4;
      args = [dictionary, header.number, header.referredTo, data, position, end];
      break;
    case 6:
    case 7:
      const textRegion = {};
      textRegion.info = readRegionSegmentInformation(data, position);
      position += RegionSegmentInformationFieldLength;
      const textRegionSegmentFlags = readUint16(data, position);
      position += 2;
      textRegion.huffman = !!(textRegionSegmentFlags & 1);
      textRegion.refinement = !!(textRegionSegmentFlags & 2);
      textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;
      textRegion.stripSize = 1 << textRegion.logStripSize;
      textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
      textRegion.transposed = !!(textRegionSegmentFlags & 64);
      textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
      textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
      textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
      textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;
      if (textRegion.huffman) {
        const textRegionHuffmanFlags = readUint16(data, position);
        position += 2;
        textRegion.huffmanFS = textRegionHuffmanFlags & 3;
        textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
        textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
        textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
        textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
        textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
        textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
        textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 16384);
      }
      if (textRegion.refinement && !textRegion.refinementTemplate) {
        at = [];
        for (i = 0; i < 2; i++) {
          at.push({
            x: readInt8(data, position),
            y: readInt8(data, position + 1)
          });
          position += 2;
        }
        textRegion.refinementAt = at;
      }
      textRegion.numberOfSymbolInstances = readUint32(data, position);
      position += 4;
      args = [textRegion, header.referredTo, data, position, end];
      break;
    case 16:
      const patternDictionary = {};
      const patternDictionaryFlags = data[position++];
      patternDictionary.mmr = !!(patternDictionaryFlags & 1);
      patternDictionary.template = patternDictionaryFlags >> 1 & 3;
      patternDictionary.patternWidth = data[position++];
      patternDictionary.patternHeight = data[position++];
      patternDictionary.maxPatternIndex = readUint32(data, position);
      position += 4;
      args = [patternDictionary, header.number, data, position, end];
      break;
    case 22:
    case 23:
      const halftoneRegion = {};
      halftoneRegion.info = readRegionSegmentInformation(data, position);
      position += RegionSegmentInformationFieldLength;
      const halftoneRegionFlags = data[position++];
      halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
      halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
      halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
      halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
      halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
      halftoneRegion.gridWidth = readUint32(data, position);
      position += 4;
      halftoneRegion.gridHeight = readUint32(data, position);
      position += 4;
      halftoneRegion.gridOffsetX = readUint32(data, position) & 4294967295;
      position += 4;
      halftoneRegion.gridOffsetY = readUint32(data, position) & 4294967295;
      position += 4;
      halftoneRegion.gridVectorX = readUint16(data, position);
      position += 2;
      halftoneRegion.gridVectorY = readUint16(data, position);
      position += 2;
      args = [halftoneRegion, header.referredTo, data, position, end];
      break;
    case 38:
    case 39:
      const genericRegion = {};
      genericRegion.info = readRegionSegmentInformation(data, position);
      position += RegionSegmentInformationFieldLength;
      const genericRegionSegmentFlags = data[position++];
      genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
      genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
      genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
      if (!genericRegion.mmr) {
        atLength = genericRegion.template === 0 ? 4 : 1;
        at = [];
        for (i = 0; i < atLength; i++) {
          at.push({
            x: readInt8(data, position),
            y: readInt8(data, position + 1)
          });
          position += 2;
        }
        genericRegion.at = at;
      }
      args = [genericRegion, data, position, end];
      break;
    case 48:
      const pageInfo = {
        width: readUint32(data, position),
        height: readUint32(data, position + 4),
        resolutionX: readUint32(data, position + 8),
        resolutionY: readUint32(data, position + 12)
      };
      if (pageInfo.height === 4294967295) {
        delete pageInfo.height;
      }
      const pageSegmentFlags = data[position + 16];
      readUint16(data, position + 17);
      pageInfo.lossless = !!(pageSegmentFlags & 1);
      pageInfo.refinement = !!(pageSegmentFlags & 2);
      pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
      pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
      pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
      pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
      args = [pageInfo];
      break;
    case 49:
      break;
    case 50:
      break;
    case 51:
      break;
    case 53:
      args = [header.number, data, position, end];
      break;
    case 62:
      break;
    default:
      throw new Jbig2Error(`segment type ${header.typeName}(${header.type}) is not implemented`);
  }
  const callbackName = "on" + header.typeName;
  if (callbackName in visitor) {
    visitor[callbackName].apply(visitor, args);
  }
}
function processSegments(segments, visitor) {
  for (let i = 0, ii = segments.length; i < ii; i++) {
    processSegment(segments[i], visitor);
  }
}
function parseJbig2Chunks(chunks) {
  const visitor = new SimpleSegmentVisitor();
  for (let i = 0, ii = chunks.length; i < ii; i++) {
    const chunk = chunks[i];
    const segments = readSegments({}, chunk.data, chunk.start, chunk.end);
    processSegments(segments, visitor);
  }
  return visitor.buffer;
}
function parseJbig2(data) {
  const end = data.length;
  let position = 0;
  if (data[position] !== 151 || data[position + 1] !== 74 || data[position + 2] !== 66 || data[position + 3] !== 50 || data[position + 4] !== 13 || data[position + 5] !== 10 || data[position + 6] !== 26 || data[position + 7] !== 10) {
    throw new Jbig2Error("parseJbig2 - invalid header.");
  }
  const header = /* @__PURE__ */ Object.create(null);
  position += 8;
  const flags = data[position++];
  header.randomAccess = !(flags & 1);
  if (!(flags & 2)) {
    header.numberOfPages = readUint32(data, position);
    position += 4;
  }
  const segments = readSegments(header, data, position, end);
  const visitor = new SimpleSegmentVisitor();
  processSegments(segments, visitor);
  const {
    width,
    height
  } = visitor.currentPageInfo;
  const bitPacked = visitor.buffer;
  const imgData = new Uint8ClampedArray(width * height);
  let q = 0, k = 0;
  for (let i = 0; i < height; i++) {
    let mask = 0, buffer;
    for (let j = 0; j < width; j++) {
      if (!mask) {
        mask = 128;
        buffer = bitPacked[k++];
      }
      imgData[q++] = buffer & mask ? 0 : 255;
      mask >>= 1;
    }
  }
  return {
    imgData,
    width,
    height
  };
}
var SimpleSegmentVisitor = class {
  onPageInformation(info2) {
    this.currentPageInfo = info2;
    const rowSize = info2.width + 7 >> 3;
    const buffer = new Uint8ClampedArray(rowSize * info2.height);
    if (info2.defaultPixelValue) {
      for (let i = 0, ii = buffer.length; i < ii; i++) {
        buffer[i] = 255;
      }
    }
    this.buffer = buffer;
  }
  drawBitmap(regionInfo, bitmap) {
    const pageInfo = this.currentPageInfo;
    const width = regionInfo.width, height = regionInfo.height;
    const rowSize = pageInfo.width + 7 >> 3;
    const combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
    const buffer = this.buffer;
    const mask0 = 128 >> (regionInfo.x & 7);
    let offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
    let i, j, mask, offset;
    switch (combinationOperator) {
      case 0:
        for (i = 0; i < height; i++) {
          mask = mask0;
          offset = offset0;
          for (j = 0; j < width; j++) {
            if (bitmap[i][j]) {
              buffer[offset] |= mask;
            }
            mask >>= 1;
            if (!mask) {
              mask = 128;
              offset++;
            }
          }
          offset0 += rowSize;
        }
        break;
      case 2:
        for (i = 0; i < height; i++) {
          mask = mask0;
          offset = offset0;
          for (j = 0; j < width; j++) {
            if (bitmap[i][j]) {
              buffer[offset] ^= mask;
            }
            mask >>= 1;
            if (!mask) {
              mask = 128;
              offset++;
            }
          }
          offset0 += rowSize;
        }
        break;
      default:
        throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
    }
  }
  onImmediateGenericRegion(region, data, start, end) {
    const regionInfo = region.info;
    const decodingContext = new DecodingContext(data, start, end);
    const bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
    this.drawBitmap(regionInfo, bitmap);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion.apply(this, arguments);
  }
  onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
    let huffmanTables, huffmanInput;
    if (dictionary.huffman) {
      huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);
      huffmanInput = new Reader(data, start, end);
    }
    let symbols = this.symbols;
    if (!symbols) {
      this.symbols = symbols = {};
    }
    let inputSymbols = [];
    for (let i = 0, ii = referredSegments.length; i < ii; i++) {
      const referredSymbols = symbols[referredSegments[i]];
      if (referredSymbols) {
        inputSymbols = inputSymbols.concat(referredSymbols);
      }
    }
    const decodingContext = new DecodingContext(data, start, end);
    symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
  }
  onImmediateTextRegion(region, referredSegments, data, start, end) {
    const regionInfo = region.info;
    let huffmanTables, huffmanInput;
    const symbols = this.symbols;
    let inputSymbols = [];
    for (let i = 0, ii = referredSegments.length; i < ii; i++) {
      const referredSymbols = symbols[referredSegments[i]];
      if (referredSymbols) {
        inputSymbols = inputSymbols.concat(referredSymbols);
      }
    }
    const symbolCodeLength = log2(inputSymbols.length);
    if (region.huffman) {
      huffmanInput = new Reader(data, start, end);
      huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);
    }
    const decodingContext = new DecodingContext(data, start, end);
    const bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
    this.drawBitmap(regionInfo, bitmap);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion.apply(this, arguments);
  }
  onPatternDictionary(dictionary, currentSegment, data, start, end) {
    let patterns = this.patterns;
    if (!patterns) {
      this.patterns = patterns = {};
    }
    const decodingContext = new DecodingContext(data, start, end);
    patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
  }
  onImmediateHalftoneRegion(region, referredSegments, data, start, end) {
    const patterns = this.patterns[referredSegments[0]];
    const regionInfo = region.info;
    const decodingContext = new DecodingContext(data, start, end);
    const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
    this.drawBitmap(regionInfo, bitmap);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion.apply(this, arguments);
  }
  onTables(currentSegment, data, start, end) {
    let customTables = this.customTables;
    if (!customTables) {
      this.customTables = customTables = {};
    }
    customTables[currentSegment] = decodeTablesSegment(data, start, end);
  }
};
var HuffmanLine = class {
  constructor(lineData) {
    if (lineData.length === 2) {
      this.isOOB = true;
      this.rangeLow = 0;
      this.prefixLength = lineData[0];
      this.rangeLength = 0;
      this.prefixCode = lineData[1];
      this.isLowerRange = false;
    } else {
      this.isOOB = false;
      this.rangeLow = lineData[0];
      this.prefixLength = lineData[1];
      this.rangeLength = lineData[2];
      this.prefixCode = lineData[3];
      this.isLowerRange = lineData[4] === "lower";
    }
  }
};
var HuffmanTreeNode = class _HuffmanTreeNode {
  constructor(line) {
    this.children = [];
    if (line) {
      this.isLeaf = true;
      this.rangeLength = line.rangeLength;
      this.rangeLow = line.rangeLow;
      this.isLowerRange = line.isLowerRange;
      this.isOOB = line.isOOB;
    } else {
      this.isLeaf = false;
    }
  }
  buildTree(line, shift) {
    const bit = line.prefixCode >> shift & 1;
    if (shift <= 0) {
      this.children[bit] = new _HuffmanTreeNode(line);
    } else {
      let node = this.children[bit];
      if (!node) {
        this.children[bit] = node = new _HuffmanTreeNode(null);
      }
      node.buildTree(line, shift - 1);
    }
  }
  decodeNode(reader) {
    if (this.isLeaf) {
      if (this.isOOB) {
        return null;
      }
      const htOffset = reader.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
    }
    const node = this.children[reader.readBit()];
    if (!node) {
      throw new Jbig2Error("invalid Huffman data");
    }
    return node.decodeNode(reader);
  }
};
var HuffmanTable = class {
  constructor(lines, prefixCodesDone) {
    if (!prefixCodesDone) {
      this.assignPrefixCodes(lines);
    }
    this.rootNode = new HuffmanTreeNode(null);
    for (let i = 0, ii = lines.length; i < ii; i++) {
      const line = lines[i];
      if (line.prefixLength > 0) {
        this.rootNode.buildTree(line, line.prefixLength - 1);
      }
    }
  }
  decode(reader) {
    return this.rootNode.decodeNode(reader);
  }
  assignPrefixCodes(lines) {
    const linesLength = lines.length;
    let prefixLengthMax = 0;
    for (let i = 0; i < linesLength; i++) {
      prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);
    }
    const histogram = new Uint32Array(prefixLengthMax + 1);
    for (let i = 0; i < linesLength; i++) {
      histogram[lines[i].prefixLength]++;
    }
    let currentLength = 1, firstCode = 0, currentCode, currentTemp, line;
    histogram[0] = 0;
    while (currentLength <= prefixLengthMax) {
      firstCode = firstCode + histogram[currentLength - 1] << 1;
      currentCode = firstCode;
      currentTemp = 0;
      while (currentTemp < linesLength) {
        line = lines[currentTemp];
        if (line.prefixLength === currentLength) {
          line.prefixCode = currentCode;
          currentCode++;
        }
        currentTemp++;
      }
      currentLength++;
    }
  }
};
function decodeTablesSegment(data, start, end) {
  const flags = data[start];
  const lowestValue = readUint32(data, start + 1) & 4294967295;
  const highestValue = readUint32(data, start + 5) & 4294967295;
  const reader = new Reader(data, start + 9, end);
  const prefixSizeBits = (flags >> 1 & 7) + 1;
  const rangeSizeBits = (flags >> 4 & 7) + 1;
  const lines = [];
  let prefixLength, rangeLength, currentRangeLow = lowestValue;
  do {
    prefixLength = reader.readBits(prefixSizeBits);
    rangeLength = reader.readBits(rangeSizeBits);
    lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
    currentRangeLow += 1 << rangeLength;
  } while (currentRangeLow < highestValue);
  prefixLength = reader.readBits(prefixSizeBits);
  lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
  prefixLength = reader.readBits(prefixSizeBits);
  lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));
  if (flags & 1) {
    prefixLength = reader.readBits(prefixSizeBits);
    lines.push(new HuffmanLine([prefixLength, 0]));
  }
  return new HuffmanTable(lines, false);
}
var standardTablesCache = {};
function getStandardTable(number) {
  let table = standardTablesCache[number];
  if (table) {
    return table;
  }
  let lines;
  switch (number) {
    case 1:
      lines = [
        [0, 1, 4, 0],
        [16, 2, 8, 2],
        [272, 3, 16, 6],
        [65808, 3, 32, 7]
        // upper
      ];
      break;
    case 2:
      lines = [
        [0, 1, 0, 0],
        [1, 2, 0, 2],
        [2, 3, 0, 6],
        [3, 4, 3, 14],
        [11, 5, 6, 30],
        [75, 6, 32, 62],
        // upper
        [6, 63]
        // OOB
      ];
      break;
    case 3:
      lines = [
        [-256, 8, 8, 254],
        [0, 1, 0, 0],
        [1, 2, 0, 2],
        [2, 3, 0, 6],
        [3, 4, 3, 14],
        [11, 5, 6, 30],
        [-257, 8, 32, 255, "lower"],
        [75, 7, 32, 126],
        // upper
        [6, 62]
        // OOB
      ];
      break;
    case 4:
      lines = [
        [1, 1, 0, 0],
        [2, 2, 0, 2],
        [3, 3, 0, 6],
        [4, 4, 3, 14],
        [12, 5, 6, 30],
        [76, 5, 32, 31]
        // upper
      ];
      break;
    case 5:
      lines = [
        [-255, 7, 8, 126],
        [1, 1, 0, 0],
        [2, 2, 0, 2],
        [3, 3, 0, 6],
        [4, 4, 3, 14],
        [12, 5, 6, 30],
        [-256, 7, 32, 127, "lower"],
        [76, 6, 32, 62]
        // upper
      ];
      break;
    case 6:
      lines = [
        [-2048, 5, 10, 28],
        [-1024, 4, 9, 8],
        [-512, 4, 8, 9],
        [-256, 4, 7, 10],
        [-128, 5, 6, 29],
        [-64, 5, 5, 30],
        [-32, 4, 5, 11],
        [0, 2, 7, 0],
        [128, 3, 7, 2],
        [256, 3, 8, 3],
        [512, 4, 9, 12],
        [1024, 4, 10, 13],
        [-2049, 6, 32, 62, "lower"],
        [2048, 6, 32, 63]
        // upper
      ];
      break;
    case 7:
      lines = [
        [-1024, 4, 9, 8],
        [-512, 3, 8, 0],
        [-256, 4, 7, 9],
        [-128, 5, 6, 26],
        [-64, 5, 5, 27],
        [-32, 4, 5, 10],
        [0, 4, 5, 11],
        [32, 5, 5, 28],
        [64, 5, 6, 29],
        [128, 4, 7, 12],
        [256, 3, 8, 1],
        [512, 3, 9, 2],
        [1024, 3, 10, 3],
        [-1025, 5, 32, 30, "lower"],
        [2048, 5, 32, 31]
        // upper
      ];
      break;
    case 8:
      lines = [
        [-15, 8, 3, 252],
        [-7, 9, 1, 508],
        [-5, 8, 1, 253],
        [-3, 9, 0, 509],
        [-2, 7, 0, 124],
        [-1, 4, 0, 10],
        [0, 2, 1, 0],
        [2, 5, 0, 26],
        [3, 6, 0, 58],
        [4, 3, 4, 4],
        [20, 6, 1, 59],
        [22, 4, 4, 11],
        [38, 4, 5, 12],
        [70, 5, 6, 27],
        [134, 5, 7, 28],
        [262, 6, 7, 60],
        [390, 7, 8, 125],
        [646, 6, 10, 61],
        [-16, 9, 32, 510, "lower"],
        [1670, 9, 32, 511],
        // upper
        [2, 1]
        // OOB
      ];
      break;
    case 9:
      lines = [
        [-31, 8, 4, 252],
        [-15, 9, 2, 508],
        [-11, 8, 2, 253],
        [-7, 9, 1, 509],
        [-5, 7, 1, 124],
        [-3, 4, 1, 10],
        [-1, 3, 1, 2],
        [1, 3, 1, 3],
        [3, 5, 1, 26],
        [5, 6, 1, 58],
        [7, 3, 5, 4],
        [39, 6, 2, 59],
        [43, 4, 5, 11],
        [75, 4, 6, 12],
        [139, 5, 7, 27],
        [267, 5, 8, 28],
        [523, 6, 8, 60],
        [779, 7, 9, 125],
        [1291, 6, 11, 61],
        [-32, 9, 32, 510, "lower"],
        [3339, 9, 32, 511],
        // upper
        [2, 0]
        // OOB
      ];
      break;
    case 10:
      lines = [
        [-21, 7, 4, 122],
        [-5, 8, 0, 252],
        [-4, 7, 0, 123],
        [-3, 5, 0, 24],
        [-2, 2, 2, 0],
        [2, 5, 0, 25],
        [3, 6, 0, 54],
        [4, 7, 0, 124],
        [5, 8, 0, 253],
        [6, 2, 6, 1],
        [70, 5, 5, 26],
        [102, 6, 5, 55],
        [134, 6, 6, 56],
        [198, 6, 7, 57],
        [326, 6, 8, 58],
        [582, 6, 9, 59],
        [1094, 6, 10, 60],
        [2118, 7, 11, 125],
        [-22, 8, 32, 254, "lower"],
        [4166, 8, 32, 255],
        // upper
        [2, 2]
        // OOB
      ];
      break;
    case 11:
      lines = [
        [1, 1, 0, 0],
        [2, 2, 1, 2],
        [4, 4, 0, 12],
        [5, 4, 1, 13],
        [7, 5, 1, 28],
        [9, 5, 2, 29],
        [13, 6, 2, 60],
        [17, 7, 2, 122],
        [21, 7, 3, 123],
        [29, 7, 4, 124],
        [45, 7, 5, 125],
        [77, 7, 6, 126],
        [141, 7, 32, 127]
        // upper
      ];
      break;
    case 12:
      lines = [
        [1, 1, 0, 0],
        [2, 2, 0, 2],
        [3, 3, 1, 6],
        [5, 5, 0, 28],
        [6, 5, 1, 29],
        [8, 6, 1, 60],
        [10, 7, 0, 122],
        [11, 7, 1, 123],
        [13, 7, 2, 124],
        [17, 7, 3, 125],
        [25, 7, 4, 126],
        [41, 8, 5, 254],
        [73, 8, 32, 255]
        // upper
      ];
      break;
    case 13:
      lines = [
        [1, 1, 0, 0],
        [2, 3, 0, 4],
        [3, 4, 0, 12],
        [4, 5, 0, 28],
        [5, 4, 1, 13],
        [7, 3, 3, 5],
        [15, 6, 1, 58],
        [17, 6, 2, 59],
        [21, 6, 3, 60],
        [29, 6, 4, 61],
        [45, 6, 5, 62],
        [77, 7, 6, 126],
        [141, 7, 32, 127]
        // upper
      ];
      break;
    case 14:
      lines = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      lines = [
        [-24, 7, 4, 124],
        [-8, 6, 2, 60],
        [-4, 5, 1, 28],
        [-2, 4, 0, 12],
        [-1, 3, 0, 4],
        [0, 1, 0, 0],
        [1, 3, 0, 5],
        [2, 4, 0, 13],
        [3, 5, 1, 29],
        [5, 6, 2, 61],
        [9, 7, 4, 125],
        [-25, 7, 32, 126, "lower"],
        [25, 7, 32, 127]
        // upper
      ];
      break;
    default:
      throw new Jbig2Error(`standard table B.${number} does not exist`);
  }
  for (let i = 0, ii = lines.length; i < ii; i++) {
    lines[i] = new HuffmanLine(lines[i]);
  }
  table = new HuffmanTable(lines, true);
  standardTablesCache[number] = table;
  return table;
}
var Reader = class {
  constructor(data, start, end) {
    this.data = data;
    this.start = start;
    this.end = end;
    this.position = start;
    this.shift = -1;
    this.currentByte = 0;
  }
  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end) {
        throw new Jbig2Error("end of data while reading bit");
      }
      this.currentByte = this.data[this.position++];
      this.shift = 7;
    }
    const bit = this.currentByte >> this.shift & 1;
    this.shift--;
    return bit;
  }
  readBits(numBits) {
    let result = 0, i;
    for (i = numBits - 1; i >= 0; i--) {
      result |= this.readBit() << i;
    }
    return result;
  }
  byteAlign() {
    this.shift = -1;
  }
  next() {
    if (this.position >= this.end) {
      return -1;
    }
    return this.data[this.position++];
  }
};
function getCustomHuffmanTable(index, referredTo, customTables) {
  let currentIndex = 0;
  for (let i = 0, ii = referredTo.length; i < ii; i++) {
    const table = customTables[referredTo[i]];
    if (table) {
      if (index === currentIndex) {
        return table;
      }
      currentIndex++;
    }
  }
  throw new Jbig2Error("can't find custom Huffman table");
}
function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
  const codes = [];
  for (let i = 0; i <= 34; i++) {
    const codeLength = reader.readBits(4);
    codes.push(new HuffmanLine([i, codeLength, 0, 0]));
  }
  const runCodesTable = new HuffmanTable(codes, false);
  codes.length = 0;
  for (let i = 0; i < numberOfSymbols; ) {
    const codeLength = runCodesTable.decode(reader);
    if (codeLength >= 32) {
      let repeatedLength, numberOfRepeats, j;
      switch (codeLength) {
        case 32:
          if (i === 0) {
            throw new Jbig2Error("no previous value in symbol ID table");
          }
          numberOfRepeats = reader.readBits(2) + 3;
          repeatedLength = codes[i - 1].prefixLength;
          break;
        case 33:
          numberOfRepeats = reader.readBits(3) + 3;
          repeatedLength = 0;
          break;
        case 34:
          numberOfRepeats = reader.readBits(7) + 11;
          repeatedLength = 0;
          break;
        default:
          throw new Jbig2Error("invalid code length in symbol ID table");
      }
      for (j = 0; j < numberOfRepeats; j++) {
        codes.push(new HuffmanLine([i, repeatedLength, 0, 0]));
        i++;
      }
    } else {
      codes.push(new HuffmanLine([i, codeLength, 0, 0]));
      i++;
    }
  }
  reader.byteAlign();
  const symbolIDTable = new HuffmanTable(codes, false);
  let customIndex = 0, tableFirstS, tableDeltaS, tableDeltaT;
  switch (textRegion.huffmanFS) {
    case 0:
    case 1:
      tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
      break;
    case 3:
      tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman FS selector");
  }
  switch (textRegion.huffmanDS) {
    case 0:
    case 1:
    case 2:
      tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
      break;
    case 3:
      tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman DS selector");
  }
  switch (textRegion.huffmanDT) {
    case 0:
    case 1:
    case 2:
      tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
      break;
    case 3:
      tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman DT selector");
  }
  if (textRegion.refinement) {
    throw new Jbig2Error("refinement with Huffman is not supported");
  }
  return {
    symbolIDTable,
    tableFirstS,
    tableDeltaS,
    tableDeltaT
  };
}
function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {
  let customIndex = 0, tableDeltaHeight, tableDeltaWidth;
  switch (dictionary.huffmanDHSelector) {
    case 0:
    case 1:
      tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
      break;
    case 3:
      tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman DH selector");
  }
  switch (dictionary.huffmanDWSelector) {
    case 0:
    case 1:
      tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
      break;
    case 3:
      tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
      customIndex++;
      break;
    default:
      throw new Jbig2Error("invalid Huffman DW selector");
  }
  let tableBitmapSize, tableAggregateInstances;
  if (dictionary.bitmapSizeSelector) {
    tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
    customIndex++;
  } else {
    tableBitmapSize = getStandardTable(1);
  }
  if (dictionary.aggregationInstancesSelector) {
    tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
  } else {
    tableAggregateInstances = getStandardTable(1);
  }
  return {
    tableDeltaHeight,
    tableDeltaWidth,
    tableBitmapSize,
    tableAggregateInstances
  };
}
function readUncompressedBitmap(reader, width, height) {
  const bitmap = [];
  for (let y = 0; y < height; y++) {
    const row = new Uint8Array(width);
    bitmap.push(row);
    for (let x = 0; x < width; x++) {
      row[x] = reader.readBit();
    }
    reader.byteAlign();
  }
  return bitmap;
}
function decodeMMRBitmap(input, width, height, endOfBlock) {
  const params = {
    K: -1,
    Columns: width,
    Rows: height,
    BlackIs1: true,
    EndOfBlock: endOfBlock
  };
  const decoder = new CCITTFaxDecoder(input, params);
  const bitmap = [];
  let currentByte, eof = false;
  for (let y = 0; y < height; y++) {
    const row = new Uint8Array(width);
    bitmap.push(row);
    let shift = -1;
    for (let x = 0; x < width; x++) {
      if (shift < 0) {
        currentByte = decoder.readNextChar();
        if (currentByte === -1) {
          currentByte = 0;
          eof = true;
        }
        shift = 7;
      }
      row[x] = currentByte >> shift & 1;
      shift--;
    }
  }
  if (endOfBlock && !eof) {
    const lookForEOFLimit = 5;
    for (let i = 0; i < lookForEOFLimit; i++) {
      if (decoder.readNextChar() === -1) {
        break;
      }
    }
  }
  return bitmap;
}
var Jbig2Image = class {
  parseChunks(chunks) {
    return parseJbig2Chunks(chunks);
  }
  parse(data) {
    const {
      imgData,
      width,
      height
    } = parseJbig2(data);
    this.width = width;
    this.height = height;
    return imgData;
  }
};
var Jbig2Stream = class extends DecodeStream {
  constructor(stream, maybeLength, params) {
    super(maybeLength);
    this.stream = stream;
    this.dict = stream.dict;
    this.maybeLength = maybeLength;
    this.params = params;
  }
  get bytes() {
    return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(requested) {
  }
  readBlock() {
    if (this.eof) {
      return;
    }
    const jbig2Image = new Jbig2Image();
    const chunks = [];
    if (isDict(this.params)) {
      const globalsStream = this.params.get("JBIG2Globals");
      if (isStream(globalsStream)) {
        const globals = globalsStream.getBytes();
        chunks.push({
          data: globals,
          start: 0,
          end: globals.length
        });
      }
    }
    chunks.push({
      data: this.bytes,
      start: 0,
      end: this.bytes.length
    });
    const data = jbig2Image.parseChunks(chunks);
    const dataLength = data.length;
    for (let i = 0; i < dataLength; i++) {
      data[i] ^= 255;
    }
    this.buffer = data;
    this.bufferLength = dataLength;
    this.eof = true;
  }
};
var JpegError = class extends BaseException {
  constructor(msg) {
    super(`JPEG error: ${msg}`);
  }
};
var DNLMarkerError = class extends BaseException {
  constructor(message, scanLines) {
    super(message);
    this.scanLines = scanLines;
  }
};
var EOIMarkerError = class extends BaseException {
};
var dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
var dctCos1 = 4017;
var dctSin1 = 799;
var dctCos3 = 3406;
var dctSin3 = 2276;
var dctCos6 = 1567;
var dctSin6 = 3784;
var dctSqrt2 = 5793;
var dctSqrt1d2 = 2896;
function buildHuffmanTable(codeLengths, values) {
  let k = 0, i, j, length = 16;
  while (length > 0 && !codeLengths[length - 1]) {
    length--;
  }
  const code = [{
    children: [],
    index: 0
  }];
  let p = code[0], q;
  for (i = 0; i < length; i++) {
    for (j = 0; j < codeLengths[i]; j++) {
      p = code.pop();
      p.children[p.index] = values[k];
      while (p.index > 0) {
        p = code.pop();
      }
      p.index++;
      code.push(p);
      while (code.length <= i) {
        code.push(q = {
          children: [],
          index: 0
        });
        p.children[p.index] = q.children;
        p = q;
      }
      k++;
    }
    if (i + 1 < length) {
      code.push(q = {
        children: [],
        index: 0
      });
      p.children[p.index] = q.children;
      p = q;
    }
  }
  return code[0].children;
}
function getBlockBufferOffset(component, row, col) {
  return 64 * ((component.blocksPerLine + 1) * row + col);
}
function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {
  const mcusPerLine = frame.mcusPerLine;
  const progressive = frame.progressive;
  const startOffset = offset;
  let bitsData = 0, bitsCount = 0;
  function readBit() {
    if (bitsCount > 0) {
      bitsCount--;
      return bitsData >> bitsCount & 1;
    }
    bitsData = data[offset++];
    if (bitsData === 255) {
      const nextByte = data[offset++];
      if (nextByte) {
        if (nextByte === /* DNL = */
        220 && parseDNLMarker) {
          offset += 2;
          const scanLines = readUint16(data, offset);
          offset += 2;
          if (scanLines > 0 && scanLines !== frame.scanLines) {
            throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
          }
        } else if (nextByte === /* EOI = */
        217) {
          if (parseDNLMarker) {
            const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);
            if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 10) {
              throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", maybeScanLines);
            }
          }
          throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new JpegError(`unexpected marker ${(bitsData << 8 | nextByte).toString(16)}`);
      }
    }
    bitsCount = 7;
    return bitsData >>> 7;
  }
  function decodeHuffman(tree) {
    let node = tree;
    while (true) {
      node = node[readBit()];
      switch (typeof node) {
        case "number":
          return node;
        case "object":
          continue;
      }
      throw new JpegError("invalid huffman sequence");
    }
  }
  function receive(length) {
    let n2 = 0;
    while (length > 0) {
      n2 = n2 << 1 | readBit();
      length--;
    }
    return n2;
  }
  function receiveAndExtend(length) {
    if (length === 1) {
      return readBit() === 1 ? 1 : -1;
    }
    const n2 = receive(length);
    if (n2 >= 1 << length - 1) {
      return n2;
    }
    return n2 + (-1 << length) + 1;
  }
  function decodeBaseline(component2, blockOffset) {
    const t = decodeHuffman(component2.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t);
    component2.blockData[blockOffset] = component2.pred += diff;
    let k2 = 1;
    while (k2 < 64) {
      const rs = decodeHuffman(component2.huffmanTableAC);
      const s = rs & 15, r = rs >> 4;
      if (s === 0) {
        if (r < 15) {
          break;
        }
        k2 += 16;
        continue;
      }
      k2 += r;
      const z = dctZigZag[k2];
      component2.blockData[blockOffset + z] = receiveAndExtend(s);
      k2++;
    }
  }
  function decodeDCFirst(component2, blockOffset) {
    const t = decodeHuffman(component2.huffmanTableDC);
    const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
    component2.blockData[blockOffset] = component2.pred += diff;
  }
  function decodeDCSuccessive(component2, blockOffset) {
    component2.blockData[blockOffset] |= readBit() << successive;
  }
  let eobrun = 0;
  function decodeACFirst(component2, blockOffset) {
    if (eobrun > 0) {
      eobrun--;
      return;
    }
    let k2 = spectralStart;
    const e = spectralEnd;
    while (k2 <= e) {
      const rs = decodeHuffman(component2.huffmanTableAC);
      const s = rs & 15, r = rs >> 4;
      if (s === 0) {
        if (r < 15) {
          eobrun = receive(r) + (1 << r) - 1;
          break;
        }
        k2 += 16;
        continue;
      }
      k2 += r;
      const z = dctZigZag[k2];
      component2.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);
      k2++;
    }
  }
  let successiveACState = 0, successiveACNextValue;
  function decodeACSuccessive(component2, blockOffset) {
    let k2 = spectralStart;
    const e = spectralEnd;
    let r = 0;
    let s;
    let rs;
    while (k2 <= e) {
      const offsetZ = blockOffset + dctZigZag[k2];
      const sign = component2.blockData[offsetZ] < 0 ? -1 : 1;
      switch (successiveACState) {
        case 0:
          rs = decodeHuffman(component2.huffmanTableAC);
          s = rs & 15;
          r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1) {
              throw new JpegError("invalid ACn encoding");
            }
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          if (component2.blockData[offsetZ]) {
            component2.blockData[offsetZ] += sign * (readBit() << successive);
          } else {
            r--;
            if (r === 0) {
              successiveACState = successiveACState === 2 ? 3 : 0;
            }
          }
          break;
        case 3:
          if (component2.blockData[offsetZ]) {
            component2.blockData[offsetZ] += sign * (readBit() << successive);
          } else {
            component2.blockData[offsetZ] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4:
          if (component2.blockData[offsetZ]) {
            component2.blockData[offsetZ] += sign * (readBit() << successive);
          }
          break;
      }
      k2++;
    }
    if (successiveACState === 4) {
      eobrun--;
      if (eobrun === 0) {
        successiveACState = 0;
      }
    }
  }
  let blockRow = 0;
  function decodeMcu(component2, decode, mcu2, row, col) {
    const mcuRow = mcu2 / mcusPerLine | 0;
    const mcuCol = mcu2 % mcusPerLine;
    blockRow = mcuRow * component2.v + row;
    const blockCol = mcuCol * component2.h + col;
    const blockOffset = getBlockBufferOffset(component2, blockRow, blockCol);
    decode(component2, blockOffset);
  }
  function decodeBlock(component2, decode, mcu2) {
    blockRow = mcu2 / component2.blocksPerLine | 0;
    const blockCol = mcu2 % component2.blocksPerLine;
    const blockOffset = getBlockBufferOffset(component2, blockRow, blockCol);
    decode(component2, blockOffset);
  }
  const componentsLength = components.length;
  let component, i, j, k, n;
  let decodeFn;
  if (progressive) {
    if (spectralStart === 0) {
      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
    } else {
      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    }
  } else {
    decodeFn = decodeBaseline;
  }
  let mcu = 0, fileMarker;
  let mcuExpected;
  if (componentsLength === 1) {
    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
  } else {
    mcuExpected = mcusPerLine * frame.mcusPerColumn;
  }
  let h, v;
  while (mcu <= mcuExpected) {
    const mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;
    if (mcuToRead > 0) {
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;
      if (componentsLength === 1) {
        component = components[0];
        for (n = 0; n < mcuToRead; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < mcuToRead; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }
    }
    bitsCount = 0;
    fileMarker = findNextFileMarker(data, offset);
    if (!fileMarker) {
      break;
    }
    if (fileMarker.invalid) {
      const partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
      warn(`decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`);
      offset = fileMarker.offset;
    }
    if (fileMarker.marker >= 65488 && fileMarker.marker <= 65495) {
      offset += 2;
    } else {
      break;
    }
  }
  return offset - startOffset;
}
function quantizeAndInverse(component, blockBufferOffset, p) {
  const qt = component.quantizationTable, blockData = component.blockData;
  let v0, v1, v2, v3, v4, v5, v6, v7;
  let p0, p1, p2, p3, p4, p5, p6, p7;
  let t;
  if (!qt) {
    throw new JpegError("missing required Quantization Table.");
  }
  for (let row = 0; row < 64; row += 8) {
    p0 = blockData[blockBufferOffset + row];
    p1 = blockData[blockBufferOffset + row + 1];
    p2 = blockData[blockBufferOffset + row + 2];
    p3 = blockData[blockBufferOffset + row + 3];
    p4 = blockData[blockBufferOffset + row + 4];
    p5 = blockData[blockBufferOffset + row + 5];
    p6 = blockData[blockBufferOffset + row + 6];
    p7 = blockData[blockBufferOffset + row + 7];
    p0 *= qt[row];
    if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
      t = dctSqrt2 * p0 + 512 >> 10;
      p[row] = t;
      p[row + 1] = t;
      p[row + 2] = t;
      p[row + 3] = t;
      p[row + 4] = t;
      p[row + 5] = t;
      p[row + 6] = t;
      p[row + 7] = t;
      continue;
    }
    p1 *= qt[row + 1];
    p2 *= qt[row + 2];
    p3 *= qt[row + 3];
    p4 *= qt[row + 4];
    p5 *= qt[row + 5];
    p6 *= qt[row + 6];
    p7 *= qt[row + 7];
    v0 = dctSqrt2 * p0 + 128 >> 8;
    v1 = dctSqrt2 * p4 + 128 >> 8;
    v2 = p2;
    v3 = p6;
    v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
    v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
    v5 = p3 << 4;
    v6 = p5 << 4;
    v0 = v0 + v1 + 1 >> 1;
    v1 = v0 - v1;
    t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
    v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
    v3 = t;
    v4 = v4 + v6 + 1 >> 1;
    v6 = v4 - v6;
    v7 = v7 + v5 + 1 >> 1;
    v5 = v7 - v5;
    v0 = v0 + v3 + 1 >> 1;
    v3 = v0 - v3;
    v1 = v1 + v2 + 1 >> 1;
    v2 = v1 - v2;
    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
    v6 = t;
    p[row] = v0 + v7;
    p[row + 7] = v0 - v7;
    p[row + 1] = v1 + v6;
    p[row + 6] = v1 - v6;
    p[row + 2] = v2 + v5;
    p[row + 5] = v2 - v5;
    p[row + 3] = v3 + v4;
    p[row + 4] = v3 - v4;
  }
  for (let col = 0; col < 8; ++col) {
    p0 = p[col];
    p1 = p[col + 8];
    p2 = p[col + 16];
    p3 = p[col + 24];
    p4 = p[col + 32];
    p5 = p[col + 40];
    p6 = p[col + 48];
    p7 = p[col + 56];
    if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
      t = dctSqrt2 * p0 + 8192 >> 14;
      if (t < -2040) {
        t = 0;
      } else if (t >= 2024) {
        t = 255;
      } else {
        t = t + 2056 >> 4;
      }
      blockData[blockBufferOffset + col] = t;
      blockData[blockBufferOffset + col + 8] = t;
      blockData[blockBufferOffset + col + 16] = t;
      blockData[blockBufferOffset + col + 24] = t;
      blockData[blockBufferOffset + col + 32] = t;
      blockData[blockBufferOffset + col + 40] = t;
      blockData[blockBufferOffset + col + 48] = t;
      blockData[blockBufferOffset + col + 56] = t;
      continue;
    }
    v0 = dctSqrt2 * p0 + 2048 >> 12;
    v1 = dctSqrt2 * p4 + 2048 >> 12;
    v2 = p2;
    v3 = p6;
    v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
    v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
    v5 = p3;
    v6 = p5;
    v0 = (v0 + v1 + 1 >> 1) + 4112;
    v1 = v0 - v1;
    t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
    v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
    v3 = t;
    v4 = v4 + v6 + 1 >> 1;
    v6 = v4 - v6;
    v7 = v7 + v5 + 1 >> 1;
    v5 = v7 - v5;
    v0 = v0 + v3 + 1 >> 1;
    v3 = v0 - v3;
    v1 = v1 + v2 + 1 >> 1;
    v2 = v1 - v2;
    t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
    v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
    v7 = t;
    t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
    v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
    v6 = t;
    p0 = v0 + v7;
    p7 = v0 - v7;
    p1 = v1 + v6;
    p6 = v1 - v6;
    p2 = v2 + v5;
    p5 = v2 - v5;
    p3 = v3 + v4;
    p4 = v3 - v4;
    if (p0 < 16) {
      p0 = 0;
    } else if (p0 >= 4080) {
      p0 = 255;
    } else {
      p0 >>= 4;
    }
    if (p1 < 16) {
      p1 = 0;
    } else if (p1 >= 4080) {
      p1 = 255;
    } else {
      p1 >>= 4;
    }
    if (p2 < 16) {
      p2 = 0;
    } else if (p2 >= 4080) {
      p2 = 255;
    } else {
      p2 >>= 4;
    }
    if (p3 < 16) {
      p3 = 0;
    } else if (p3 >= 4080) {
      p3 = 255;
    } else {
      p3 >>= 4;
    }
    if (p4 < 16) {
      p4 = 0;
    } else if (p4 >= 4080) {
      p4 = 255;
    } else {
      p4 >>= 4;
    }
    if (p5 < 16) {
      p5 = 0;
    } else if (p5 >= 4080) {
      p5 = 255;
    } else {
      p5 >>= 4;
    }
    if (p6 < 16) {
      p6 = 0;
    } else if (p6 >= 4080) {
      p6 = 255;
    } else {
      p6 >>= 4;
    }
    if (p7 < 16) {
      p7 = 0;
    } else if (p7 >= 4080) {
      p7 = 255;
    } else {
      p7 >>= 4;
    }
    blockData[blockBufferOffset + col] = p0;
    blockData[blockBufferOffset + col + 8] = p1;
    blockData[blockBufferOffset + col + 16] = p2;
    blockData[blockBufferOffset + col + 24] = p3;
    blockData[blockBufferOffset + col + 32] = p4;
    blockData[blockBufferOffset + col + 40] = p5;
    blockData[blockBufferOffset + col + 48] = p6;
    blockData[blockBufferOffset + col + 56] = p7;
  }
}
function buildComponentData(frame, component) {
  const blocksPerLine = component.blocksPerLine;
  const blocksPerColumn = component.blocksPerColumn;
  const computationBuffer = new Int16Array(64);
  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
      const offset = getBlockBufferOffset(component, blockRow, blockCol);
      quantizeAndInverse(component, offset, computationBuffer);
    }
  }
  return component.blockData;
}
function findNextFileMarker(data, currentPos, startPos = currentPos) {
  const maxPos = data.length - 1;
  let newPos = startPos < currentPos ? startPos : currentPos;
  if (currentPos >= maxPos) {
    return null;
  }
  const currentMarker = readUint16(data, currentPos);
  if (currentMarker >= 65472 && currentMarker <= 65534) {
    return {
      invalid: null,
      marker: currentMarker,
      offset: currentPos
    };
  }
  let newMarker = readUint16(data, newPos);
  while (!(newMarker >= 65472 && newMarker <= 65534)) {
    if (++newPos >= maxPos) {
      return null;
    }
    newMarker = readUint16(data, newPos);
  }
  return {
    invalid: currentMarker.toString(16),
    marker: newMarker,
    offset: newPos
  };
}
var JpegImage = class {
  constructor({
    decodeTransform = null,
    colorTransform = -1
  } = {}) {
    this._decodeTransform = decodeTransform;
    this._colorTransform = colorTransform;
  }
  parse(data, {
    dnlScanLines = null
  } = {}) {
    function readDataBlock() {
      const length = readUint16(data, offset);
      offset += 2;
      let endOffset = offset + length - 2;
      const fileMarker2 = findNextFileMarker(data, endOffset, offset);
      if (fileMarker2 && fileMarker2.invalid) {
        warn("readDataBlock - incorrect length, current marker is: " + fileMarker2.invalid);
        endOffset = fileMarker2.offset;
      }
      const array = data.subarray(offset, endOffset);
      offset += array.length;
      return array;
    }
    function prepareComponents(frame2) {
      const mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / frame2.maxH);
      const mcusPerColumn = Math.ceil(frame2.scanLines / 8 / frame2.maxV);
      for (let i = 0, ii = frame2.components.length; i < ii; i++) {
        const component = frame2.components[i];
        const blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component.h / frame2.maxH);
        const blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component.v / frame2.maxV);
        const blocksPerLineForMcu = mcusPerLine * component.h;
        const blocksPerColumnForMcu = mcusPerColumn * component.v;
        const blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
        component.blockData = new Int16Array(blocksBufferSize);
        component.blocksPerLine = blocksPerLine;
        component.blocksPerColumn = blocksPerColumn;
      }
      frame2.mcusPerLine = mcusPerLine;
      frame2.mcusPerColumn = mcusPerColumn;
    }
    let offset = 0;
    let jfif = null;
    let adobe = null;
    let frame, resetInterval;
    let numSOSMarkers = 0;
    const quantizationTables = [];
    const huffmanTablesAC = [], huffmanTablesDC = [];
    let fileMarker = readUint16(data, offset);
    offset += 2;
    if (fileMarker !== /* SOI (Start of Image) = */
    65496) {
      throw new JpegError("SOI not found");
    }
    fileMarker = readUint16(data, offset);
    offset += 2;
    markerLoop:
      while (fileMarker !== /* EOI (End of Image) = */
      65497) {
        let i, j, l;
        switch (fileMarker) {
          case 65504:
          case 65505:
          case 65506:
          case 65507:
          case 65508:
          case 65509:
          case 65510:
          case 65511:
          case 65512:
          case 65513:
          case 65514:
          case 65515:
          case 65516:
          case 65517:
          case 65518:
          case 65519:
          case 65534:
            const appData = readDataBlock();
            if (fileMarker === 65504) {
              if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                jfif = {
                  version: {
                    major: appData[5],
                    minor: appData[6]
                  },
                  densityUnits: appData[7],
                  xDensity: appData[8] << 8 | appData[9],
                  yDensity: appData[10] << 8 | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            if (fileMarker === 65518) {
              if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101) {
                adobe = {
                  version: appData[5] << 8 | appData[6],
                  flags0: appData[7] << 8 | appData[8],
                  flags1: appData[9] << 8 | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;
          case 65499:
            const quantizationTablesLength = readUint16(data, offset);
            offset += 2;
            const quantizationTablesEnd = quantizationTablesLength + offset - 2;
            let z;
            while (offset < quantizationTablesEnd) {
              const quantizationTableSpec = data[offset++];
              const tableData = new Uint16Array(64);
              if (quantizationTableSpec >> 4 === 0) {
                for (j = 0; j < 64; j++) {
                  z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if (quantizationTableSpec >> 4 === 1) {
                for (j = 0; j < 64; j++) {
                  z = dctZigZag[j];
                  tableData[z] = readUint16(data, offset);
                  offset += 2;
                }
              } else {
                throw new JpegError("DQT - invalid table spec");
              }
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;
          case 65472:
          case 65473:
          case 65474:
            if (frame) {
              throw new JpegError("Only single frame JPEGs supported");
            }
            offset += 2;
            frame = {};
            frame.extended = fileMarker === 65473;
            frame.progressive = fileMarker === 65474;
            frame.precision = data[offset++];
            const sofScanLines = readUint16(data, offset);
            offset += 2;
            frame.scanLines = dnlScanLines || sofScanLines;
            frame.samplesPerLine = readUint16(data, offset);
            offset += 2;
            frame.components = [];
            frame.componentIds = {};
            const componentsCount = data[offset++];
            let maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              const componentId = data[offset];
              const h = data[offset + 1] >> 4;
              const v = data[offset + 1] & 15;
              if (maxH < h) {
                maxH = h;
              }
              if (maxV < v) {
                maxV = v;
              }
              const qId = data[offset + 2];
              l = frame.components.push({
                h,
                v,
                quantizationId: qId,
                quantizationTable: null
                // See comment below.
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;
          case 65476:
            const huffmanLength = readUint16(data, offset);
            offset += 2;
            for (i = 2; i < huffmanLength; ) {
              const huffmanTableSpec = data[offset++];
              const codeLengths = new Uint8Array(16);
              let codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++) {
                codeLengthSum += codeLengths[j] = data[offset];
              }
              const huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++) {
                huffmanValues[j] = data[offset];
              }
              i += 17 + codeLengthSum;
              (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;
          case 65501:
            offset += 2;
            resetInterval = readUint16(data, offset);
            offset += 2;
            break;
          case 65498:
            const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
            offset += 2;
            const selectorsCount = data[offset++], components = [];
            for (i = 0; i < selectorsCount; i++) {
              const index = data[offset++];
              const componentIndex = frame.componentIds[index];
              const component = frame.components[componentIndex];
              component.index = index;
              const tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            const spectralStart = data[offset++], spectralEnd = data[offset++], successiveApproximation = data[offset++];
            try {
              const processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
              offset += processed;
            } catch (ex) {
              if (ex instanceof DNLMarkerError) {
                warn(`${ex.message} -- attempting to re-parse the JPEG image.`);
                return this.parse(data, {
                  dnlScanLines: ex.scanLines
                });
              } else if (ex instanceof EOIMarkerError) {
                warn(`${ex.message} -- ignoring the rest of the image data.`);
                break markerLoop;
              }
              throw ex;
            }
            break;
          case 65500:
            offset += 4;
            break;
          case 65535:
            if (data[offset] !== 255) {
              offset--;
            }
            break;
          default:
            const nextFileMarker = findNextFileMarker(
              data,
              /* currentPos = */
              offset - 2,
              /* startPos = */
              offset - 3
            );
            if (nextFileMarker && nextFileMarker.invalid) {
              warn("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
              offset = nextFileMarker.offset;
              break;
            }
            if (!nextFileMarker || offset >= data.length - 1) {
              warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
              break markerLoop;
            }
            throw new JpegError("JpegImage.parse - unknown marker: " + fileMarker.toString(16));
        }
        fileMarker = readUint16(data, offset);
        offset += 2;
      }
    this.width = frame.samplesPerLine;
    this.height = frame.scanLines;
    this.jfif = jfif;
    this.adobe = adobe;
    this.components = [];
    for (let i = 0, ii = frame.components.length; i < ii; i++) {
      const component = frame.components[i];
      const quantizationTable = quantizationTables[component.quantizationId];
      if (quantizationTable) {
        component.quantizationTable = quantizationTable;
      }
      this.components.push({
        index: component.index,
        output: buildComponentData(frame, component),
        scaleX: component.h / frame.maxH,
        scaleY: component.v / frame.maxV,
        blocksPerLine: component.blocksPerLine,
        blocksPerColumn: component.blocksPerColumn
      });
    }
    this.numComponents = this.components.length;
    return void 0;
  }
  _getLinearizedBlockData(width, height, isSourcePDF = false) {
    const scaleX = this.width / width, scaleY = this.height / height;
    let component, componentScaleX, componentScaleY, blocksPerScanline;
    let x, y, i, j, k;
    let index;
    let offset = 0;
    let output;
    const numComponents = this.components.length;
    const dataLength = width * height * numComponents;
    const data = new Uint8ClampedArray(dataLength);
    const xScaleBlockOffset = new Uint32Array(width);
    const mask3LSB = 4294967288;
    let lastComponentScaleX;
    for (i = 0; i < numComponents; i++) {
      component = this.components[i];
      componentScaleX = component.scaleX * scaleX;
      componentScaleY = component.scaleY * scaleY;
      offset = i;
      output = component.output;
      blocksPerScanline = component.blocksPerLine + 1 << 3;
      if (componentScaleX !== lastComponentScaleX) {
        for (x = 0; x < width; x++) {
          j = 0 | x * componentScaleX;
          xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
        }
        lastComponentScaleX = componentScaleX;
      }
      for (y = 0; y < height; y++) {
        j = 0 | y * componentScaleY;
        index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;
        for (x = 0; x < width; x++) {
          data[offset] = output[index + xScaleBlockOffset[x]];
          offset += numComponents;
        }
      }
    }
    let transform = this._decodeTransform;
    if (!isSourcePDF && numComponents === 4 && !transform) {
      transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
    }
    if (transform) {
      for (i = 0; i < dataLength; ) {
        for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
          data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
        }
      }
    }
    return data;
  }
  get _isColorConversionNeeded() {
    if (this.adobe) {
      return !!this.adobe.transformCode;
    }
    if (this.numComponents === 3) {
      if (this._colorTransform === 0) {
        return false;
      } else if (this.components[0].index === /* "R" = */
      82 && this.components[1].index === /* "G" = */
      71 && this.components[2].index === /* "B" = */
      66) {
        return false;
      }
      return true;
    }
    if (this._colorTransform === 1) {
      return true;
    }
    return false;
  }
  _convertYccToRgb(data) {
    let Y, Cb, Cr;
    for (let i = 0, length = data.length; i < length; i += 3) {
      Y = data[i];
      Cb = data[i + 1];
      Cr = data[i + 2];
      data[i] = Y - 179.456 + 1.402 * Cr;
      data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
      data[i + 2] = Y - 226.816 + 1.772 * Cb;
    }
    return data;
  }
  _convertYcckToRgb(data) {
    let Y, Cb, Cr, k;
    let offset = 0;
    for (let i = 0, length = data.length; i < length; i += 4) {
      Y = data[i];
      Cb = data[i + 1];
      Cr = data[i + 2];
      k = data[i + 3];
      data[offset++] = -122.67195406894 + Cb * (-660635669420364e-19 * Cb + 437130475926232e-18 * Cr - 54080610064599e-18 * Y + 48449797120281e-17 * k - 0.154362151871126) + Cr * (-957964378445773e-18 * Cr + 817076911346625e-18 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (961250184130688e-18 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-336197177618394e-18 * k + 0.484791561490776);
      data[offset++] = 107.268039397724 + Cb * (219927104525741e-19 * Cb - 640992018297945e-18 * Cr + 659397001245577e-18 * Y + 426105652938837e-18 * k - 0.176491792462875) + Cr * (-778269941513683e-18 * Cr + 0.00130872261408275 * Y + 770482631801132e-18 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-318913117588328e-18 * k - 0.213742400323665);
      data[offset++] = -20.810012546947 + Cb * (-570115196973677e-18 * Cb - 263409051004589e-19 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-153496057440975e-19 * Cr - 132689043961446e-18 * Y + 560833691242812e-18 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-343531996510555e-18 * k + 0.24165260232407);
    }
    return data.subarray(0, offset);
  }
  _convertYcckToCmyk(data) {
    let Y, Cb, Cr;
    for (let i = 0, length = data.length; i < length; i += 4) {
      Y = data[i];
      Cb = data[i + 1];
      Cr = data[i + 2];
      data[i] = 434.456 - Y - 1.402 * Cr;
      data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
      data[i + 2] = 481.816 - Y - 1.772 * Cb;
    }
    return data;
  }
  _convertCmykToRgb(data) {
    let c, m, y, k;
    let offset = 0;
    for (let i = 0, length = data.length; i < length; i += 4) {
      c = data[i];
      m = data[i + 1];
      y = data[i + 2];
      k = data[i + 3];
      data[offset++] = 255 + c * (-6747147073602441e-20 * c + 8379262121013727e-19 * m + 2894718188643294e-19 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (26374107616089405e-21 * m - 8626949158638572e-20 * y - 2748769067499491e-19 * k - 0.02155688794978967) + y * (-3878099212869363e-20 * y - 3267808279485286e-19 * k + 0.0686742238595345) - k * (3361971776183937e-19 * k + 0.7430659151342254);
      data[offset++] = 255 + c * (13596372813588848e-20 * c + 924537132573585e-18 * m + 10567359618683593e-20 * y + 4791864687436512e-19 * k - 0.3109689587515875) + m * (-23545346108370344e-20 * m + 2702845253534714e-19 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (6834815998235662e-20 * y + 15168452363460973e-20 * k - 0.09751927774728933) - k * (3189131175883281e-19 * k + 0.7364883807733168);
      data[offset++] = 255 + c * (13598650411385307e-21 * c + 12423956175490851e-20 * m + 4751985097583589e-19 * y - 36729317476630422e-22 * k - 0.05562186980264034) + m * (16141380598724676e-20 * m + 9692239130725186e-19 * y + 7782692450036253e-19 * k - 0.44015232367526463) + y * (5068882914068769e-22 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (3435319965105553e-19 * k + 0.7063770186160144);
    }
    return data.subarray(0, offset);
  }
  getData({
    width,
    height,
    forceRGB = false,
    isSourcePDF = false
  }) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(isSourcePDF === true, 'JpegImage.getData: Unexpected "isSourcePDF" value for PDF files.');
    }
    if (this.numComponents > 4) {
      throw new JpegError("Unsupported color mode");
    }
    const data = this._getLinearizedBlockData(width, height, isSourcePDF);
    if (this.numComponents === 1 && forceRGB) {
      const dataLength = data.length;
      const rgbData = new Uint8ClampedArray(dataLength * 3);
      let offset = 0;
      for (let i = 0; i < dataLength; i++) {
        const grayColor = data[i];
        rgbData[offset++] = grayColor;
        rgbData[offset++] = grayColor;
        rgbData[offset++] = grayColor;
      }
      return rgbData;
    } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
      return this._convertYccToRgb(data);
    } else if (this.numComponents === 4) {
      if (this._isColorConversionNeeded) {
        if (forceRGB) {
          return this._convertYcckToRgb(data);
        }
        return this._convertYcckToCmyk(data);
      } else if (forceRGB) {
        return this._convertCmykToRgb(data);
      }
    }
    return data;
  }
};
var JpegStream = class extends DecodeStream {
  constructor(stream, maybeLength, params) {
    let ch;
    while ((ch = stream.getByte()) !== -1) {
      if (ch === 255) {
        stream.skip(-1);
        break;
      }
    }
    super(maybeLength);
    this.stream = stream;
    this.dict = stream.dict;
    this.maybeLength = maybeLength;
    this.params = params;
  }
  get bytes() {
    return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(requested) {
  }
  readBlock() {
    if (this.eof) {
      return;
    }
    const jpegOptions = {
      decodeTransform: void 0,
      colorTransform: void 0
    };
    const decodeArr = this.dict.getArray("Decode", "D");
    if (this.forceRGB && Array.isArray(decodeArr)) {
      const bitsPerComponent = this.dict.get("BitsPerComponent") || 8;
      const decodeArrLength = decodeArr.length;
      const transform = new Int32Array(decodeArrLength);
      let transformNeeded = false;
      const maxValue = (1 << bitsPerComponent) - 1;
      for (let i = 0; i < decodeArrLength; i += 2) {
        transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
        transform[i + 1] = decodeArr[i] * maxValue | 0;
        if (transform[i] !== 256 || transform[i + 1] !== 0) {
          transformNeeded = true;
        }
      }
      if (transformNeeded) {
        jpegOptions.decodeTransform = transform;
      }
    }
    if (isDict(this.params)) {
      const colorTransform = this.params.get("ColorTransform");
      if (Number.isInteger(colorTransform)) {
        jpegOptions.colorTransform = colorTransform;
      }
    }
    const jpegImage = new JpegImage(jpegOptions);
    jpegImage.parse(this.bytes);
    const data = jpegImage.getData({
      width: this.drawWidth,
      height: this.drawHeight,
      forceRGB: this.forceRGB,
      isSourcePDF: true
    });
    this.buffer = data;
    this.bufferLength = data.length;
    this.eof = true;
  }
};
var JpxError = class extends BaseException {
  constructor(msg) {
    super(`JPX error: ${msg}`);
  }
};
var SubbandsGainLog2 = {
  LL: 0,
  LH: 1,
  HL: 1,
  HH: 2
};
var JpxImage = class {
  constructor() {
    this.failOnCorruptedImage = false;
  }
  parse(data) {
    const head = readUint16(data, 0);
    if (head === 65359) {
      this.parseCodestream(data, 0, data.length);
      return;
    }
    const length = data.length;
    let position = 0;
    while (position < length) {
      let headerSize = 8;
      let lbox = readUint32(data, position);
      const tbox = readUint32(data, position + 4);
      position += headerSize;
      if (lbox === 1) {
        lbox = readUint32(data, position) * 4294967296 + readUint32(data, position + 4);
        position += 8;
        headerSize += 8;
      }
      if (lbox === 0) {
        lbox = length - position + headerSize;
      }
      if (lbox < headerSize) {
        throw new JpxError("Invalid box field size");
      }
      const dataLength = lbox - headerSize;
      let jumpDataLength = true;
      switch (tbox) {
        case 1785737832:
          jumpDataLength = false;
          break;
        case 1668246642:
          const method = data[position];
          if (method === 1) {
            const colorspace = readUint32(data, position + 3);
            switch (colorspace) {
              case 16:
              case 17:
              case 18:
                break;
              default:
                warn("Unknown colorspace " + colorspace);
                break;
            }
          } else if (method === 2) {
            info("ICC profile not supported");
          }
          break;
        case 1785737827:
          this.parseCodestream(data, position, position + dataLength);
          break;
        case 1783636e3:
          if (readUint32(data, position) !== 218793738) {
            warn("Invalid JP2 signature");
          }
          break;
        case 1783634458:
        case 1718909296:
        case 1920099697:
        case 1919251232:
        case 1768449138:
          break;
        default:
          const headerType = String.fromCharCode(tbox >> 24 & 255, tbox >> 16 & 255, tbox >> 8 & 255, tbox & 255);
          warn(`Unsupported header type ${tbox} (${headerType}).`);
          break;
      }
      if (jumpDataLength) {
        position += dataLength;
      }
    }
  }
  parseImageProperties(stream) {
    let newByte = stream.getByte();
    while (newByte >= 0) {
      const oldByte = newByte;
      newByte = stream.getByte();
      const code = oldByte << 8 | newByte;
      if (code === 65361) {
        stream.skip(4);
        const Xsiz = stream.getInt32() >>> 0;
        const Ysiz = stream.getInt32() >>> 0;
        const XOsiz = stream.getInt32() >>> 0;
        const YOsiz = stream.getInt32() >>> 0;
        stream.skip(16);
        const Csiz = stream.getUint16();
        this.width = Xsiz - XOsiz;
        this.height = Ysiz - YOsiz;
        this.componentsCount = Csiz;
        this.bitsPerComponent = 8;
        return;
      }
    }
    throw new JpxError("No size marker found in JPX stream");
  }
  parseCodestream(data, start, end) {
    const context = {};
    let doNotRecover = false;
    try {
      let position = start;
      while (position + 1 < end) {
        const code = readUint16(data, position);
        position += 2;
        let length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
        switch (code) {
          case 65359:
            context.mainHeader = true;
            break;
          case 65497:
            break;
          case 65361:
            length = readUint16(data, position);
            const siz = {};
            siz.Xsiz = readUint32(data, position + 4);
            siz.Ysiz = readUint32(data, position + 8);
            siz.XOsiz = readUint32(data, position + 12);
            siz.YOsiz = readUint32(data, position + 16);
            siz.XTsiz = readUint32(data, position + 20);
            siz.YTsiz = readUint32(data, position + 24);
            siz.XTOsiz = readUint32(data, position + 28);
            siz.YTOsiz = readUint32(data, position + 32);
            const componentsCount = readUint16(data, position + 36);
            siz.Csiz = componentsCount;
            const components = [];
            j = position + 38;
            for (let i = 0; i < componentsCount; i++) {
              const component = {
                precision: (data[j] & 127) + 1,
                isSigned: !!(data[j] & 128),
                XRsiz: data[j + 1],
                YRsiz: data[j + 2]
              };
              j += 3;
              calculateComponentDimensions(component, siz);
              components.push(component);
            }
            context.SIZ = siz;
            context.components = components;
            calculateTileGrids(context, components);
            context.QCC = [];
            context.COC = [];
            break;
          case 65372:
            length = readUint16(data, position);
            const qcd = {};
            j = position + 2;
            sqcd = data[j++];
            switch (sqcd & 31) {
              case 0:
                spqcdSize = 8;
                scalarExpounded = true;
                break;
              case 1:
                spqcdSize = 16;
                scalarExpounded = false;
                break;
              case 2:
                spqcdSize = 16;
                scalarExpounded = true;
                break;
              default:
                throw new Error("Invalid SQcd value " + sqcd);
            }
            qcd.noQuantization = spqcdSize === 8;
            qcd.scalarExpounded = scalarExpounded;
            qcd.guardBits = sqcd >> 5;
            spqcds = [];
            while (j < length + position) {
              const spqcd = {};
              if (spqcdSize === 8) {
                spqcd.epsilon = data[j++] >> 3;
                spqcd.mu = 0;
              } else {
                spqcd.epsilon = data[j] >> 3;
                spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                j += 2;
              }
              spqcds.push(spqcd);
            }
            qcd.SPqcds = spqcds;
            if (context.mainHeader) {
              context.QCD = qcd;
            } else {
              context.currentTile.QCD = qcd;
              context.currentTile.QCC = [];
            }
            break;
          case 65373:
            length = readUint16(data, position);
            const qcc = {};
            j = position + 2;
            let cqcc;
            if (context.SIZ.Csiz < 257) {
              cqcc = data[j++];
            } else {
              cqcc = readUint16(data, j);
              j += 2;
            }
            sqcd = data[j++];
            switch (sqcd & 31) {
              case 0:
                spqcdSize = 8;
                scalarExpounded = true;
                break;
              case 1:
                spqcdSize = 16;
                scalarExpounded = false;
                break;
              case 2:
                spqcdSize = 16;
                scalarExpounded = true;
                break;
              default:
                throw new Error("Invalid SQcd value " + sqcd);
            }
            qcc.noQuantization = spqcdSize === 8;
            qcc.scalarExpounded = scalarExpounded;
            qcc.guardBits = sqcd >> 5;
            spqcds = [];
            while (j < length + position) {
              const spqcd = {};
              if (spqcdSize === 8) {
                spqcd.epsilon = data[j++] >> 3;
                spqcd.mu = 0;
              } else {
                spqcd.epsilon = data[j] >> 3;
                spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                j += 2;
              }
              spqcds.push(spqcd);
            }
            qcc.SPqcds = spqcds;
            if (context.mainHeader) {
              context.QCC[cqcc] = qcc;
            } else {
              context.currentTile.QCC[cqcc] = qcc;
            }
            break;
          case 65362:
            length = readUint16(data, position);
            const cod = {};
            j = position + 2;
            const scod = data[j++];
            cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
            cod.sopMarkerUsed = !!(scod & 2);
            cod.ephMarkerUsed = !!(scod & 4);
            cod.progressionOrder = data[j++];
            cod.layersCount = readUint16(data, j);
            j += 2;
            cod.multipleComponentTransform = data[j++];
            cod.decompositionLevelsCount = data[j++];
            cod.xcb = (data[j++] & 15) + 2;
            cod.ycb = (data[j++] & 15) + 2;
            const blockStyle = data[j++];
            cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
            cod.resetContextProbabilities = !!(blockStyle & 2);
            cod.terminationOnEachCodingPass = !!(blockStyle & 4);
            cod.verticallyStripe = !!(blockStyle & 8);
            cod.predictableTermination = !!(blockStyle & 16);
            cod.segmentationSymbolUsed = !!(blockStyle & 32);
            cod.reversibleTransformation = data[j++];
            if (cod.entropyCoderWithCustomPrecincts) {
              const precinctsSizes = [];
              while (j < length + position) {
                const precinctsSize = data[j++];
                precinctsSizes.push({
                  PPx: precinctsSize & 15,
                  PPy: precinctsSize >> 4
                });
              }
              cod.precinctsSizes = precinctsSizes;
            }
            const unsupported = [];
            if (cod.selectiveArithmeticCodingBypass) {
              unsupported.push("selectiveArithmeticCodingBypass");
            }
            if (cod.resetContextProbabilities) {
              unsupported.push("resetContextProbabilities");
            }
            if (cod.terminationOnEachCodingPass) {
              unsupported.push("terminationOnEachCodingPass");
            }
            if (cod.verticallyStripe) {
              unsupported.push("verticallyStripe");
            }
            if (cod.predictableTermination) {
              unsupported.push("predictableTermination");
            }
            if (unsupported.length > 0) {
              doNotRecover = true;
              warn(`JPX: Unsupported COD options (${unsupported.join(", ")}).`);
            }
            if (context.mainHeader) {
              context.COD = cod;
            } else {
              context.currentTile.COD = cod;
              context.currentTile.COC = [];
            }
            break;
          case 65424:
            length = readUint16(data, position);
            tile = {};
            tile.index = readUint16(data, position + 2);
            tile.length = readUint32(data, position + 4);
            tile.dataEnd = tile.length + position - 2;
            tile.partIndex = data[position + 8];
            tile.partsCount = data[position + 9];
            context.mainHeader = false;
            if (tile.partIndex === 0) {
              tile.COD = context.COD;
              tile.COC = context.COC.slice(0);
              tile.QCD = context.QCD;
              tile.QCC = context.QCC.slice(0);
            }
            context.currentTile = tile;
            break;
          case 65427:
            tile = context.currentTile;
            if (tile.partIndex === 0) {
              initializeTile(context, tile.index);
              buildPackets(context);
            }
            length = tile.dataEnd - position;
            parseTilePackets(context, data, position, length);
            break;
          case 65363:
            warn("JPX: Codestream code 0xFF53 (COC) is not implemented.");
          case 65365:
          case 65367:
          case 65368:
          case 65380:
            length = readUint16(data, position);
            break;
          default:
            throw new Error("Unknown codestream code: " + code.toString(16));
        }
        position += length;
      }
    } catch (e) {
      if (doNotRecover || this.failOnCorruptedImage) {
        throw new JpxError(e.message);
      } else {
        warn(`JPX: Trying to recover from: "${e.message}".`);
      }
    }
    this.tiles = transformComponents(context);
    this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
    this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
    this.componentsCount = context.SIZ.Csiz;
  }
};
function calculateComponentDimensions(component, siz) {
  component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
  component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
  component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
  component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
  component.width = component.x1 - component.x0;
  component.height = component.y1 - component.y0;
}
function calculateTileGrids(context, components) {
  const siz = context.SIZ;
  const tiles = [];
  let tile;
  const numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
  const numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
  for (let q = 0; q < numYtiles; q++) {
    for (let p = 0; p < numXtiles; p++) {
      tile = {};
      tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
      tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
      tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
      tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
      tile.width = tile.tx1 - tile.tx0;
      tile.height = tile.ty1 - tile.ty0;
      tile.components = [];
      tiles.push(tile);
    }
  }
  context.tiles = tiles;
  const componentsCount = siz.Csiz;
  for (let i = 0, ii = componentsCount; i < ii; i++) {
    const component = components[i];
    for (let j = 0, jj = tiles.length; j < jj; j++) {
      const tileComponent = {};
      tile = tiles[j];
      tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
      tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
      tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
      tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
      tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
      tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
      tile.components[i] = tileComponent;
    }
  }
}
function getBlocksDimensions(context, component, r) {
  const codOrCoc = component.codingStyleParameters;
  const result = {};
  if (!codOrCoc.entropyCoderWithCustomPrecincts) {
    result.PPx = 15;
    result.PPy = 15;
  } else {
    result.PPx = codOrCoc.precinctsSizes[r].PPx;
    result.PPy = codOrCoc.precinctsSizes[r].PPy;
  }
  result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
  result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
  return result;
}
function buildPrecincts(context, resolution, dimensions) {
  const precinctWidth = 1 << dimensions.PPx;
  const precinctHeight = 1 << dimensions.PPy;
  const isZeroRes = resolution.resLevel === 0;
  const precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
  const precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
  const numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
  const numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
  const numprecincts = numprecinctswide * numprecinctshigh;
  resolution.precinctParameters = {
    precinctWidth,
    precinctHeight,
    numprecinctswide,
    numprecinctshigh,
    numprecincts,
    precinctWidthInSubband,
    precinctHeightInSubband
  };
}
function buildCodeblocks(context, subband, dimensions) {
  const xcb_ = dimensions.xcb_;
  const ycb_ = dimensions.ycb_;
  const codeblockWidth = 1 << xcb_;
  const codeblockHeight = 1 << ycb_;
  const cbx0 = subband.tbx0 >> xcb_;
  const cby0 = subband.tby0 >> ycb_;
  const cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
  const cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
  const precinctParameters = subband.resolution.precinctParameters;
  const codeblocks = [];
  const precincts = [];
  let i, j, codeblock, precinctNumber;
  for (j = cby0; j < cby1; j++) {
    for (i = cbx0; i < cbx1; i++) {
      codeblock = {
        cbx: i,
        cby: j,
        tbx0: codeblockWidth * i,
        tby0: codeblockHeight * j,
        tbx1: codeblockWidth * (i + 1),
        tby1: codeblockHeight * (j + 1)
      };
      codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
      codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
      codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
      codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
      const pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
      const pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
      precinctNumber = pi + pj * precinctParameters.numprecinctswide;
      codeblock.precinctNumber = precinctNumber;
      codeblock.subbandType = subband.type;
      codeblock.Lblock = 3;
      if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
        continue;
      }
      codeblocks.push(codeblock);
      let precinct = precincts[precinctNumber];
      if (precinct !== void 0) {
        if (i < precinct.cbxMin) {
          precinct.cbxMin = i;
        } else if (i > precinct.cbxMax) {
          precinct.cbxMax = i;
        }
        if (j < precinct.cbyMin) {
          precinct.cbxMin = j;
        } else if (j > precinct.cbyMax) {
          precinct.cbyMax = j;
        }
      } else {
        precincts[precinctNumber] = precinct = {
          cbxMin: i,
          cbyMin: j,
          cbxMax: i,
          cbyMax: j
        };
      }
      codeblock.precinct = precinct;
    }
  }
  subband.codeblockParameters = {
    codeblockWidth: xcb_,
    codeblockHeight: ycb_,
    numcodeblockwide: cbx1 - cbx0 + 1,
    numcodeblockhigh: cby1 - cby0 + 1
  };
  subband.codeblocks = codeblocks;
  subband.precincts = precincts;
}
function createPacket(resolution, precinctNumber, layerNumber) {
  const precinctCodeblocks = [];
  const subbands = resolution.subbands;
  for (let i = 0, ii = subbands.length; i < ii; i++) {
    const subband = subbands[i];
    const codeblocks = subband.codeblocks;
    for (let j = 0, jj = codeblocks.length; j < jj; j++) {
      const codeblock = codeblocks[j];
      if (codeblock.precinctNumber !== precinctNumber) {
        continue;
      }
      precinctCodeblocks.push(codeblock);
    }
  }
  return {
    layerNumber,
    codeblocks: precinctCodeblocks
  };
}
function LayerResolutionComponentPositionIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  let maxDecompositionLevelsCount = 0;
  for (let q = 0; q < componentsCount; q++) {
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
  }
  let l = 0, r = 0, i = 0, k = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; l < layersCount; l++) {
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; i < componentsCount; i++) {
          const component = tile.components[i];
          if (r > component.codingStyleParameters.decompositionLevelsCount) {
            continue;
          }
          const resolution = component.resolutions[r];
          const numprecincts = resolution.precinctParameters.numprecincts;
          for (; k < numprecincts; ) {
            const packet = createPacket(resolution, k, l);
            k++;
            return packet;
          }
          k = 0;
        }
        i = 0;
      }
      r = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function ResolutionLayerComponentPositionIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  let maxDecompositionLevelsCount = 0;
  for (let q = 0; q < componentsCount; q++) {
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
  }
  let r = 0, l = 0, i = 0, k = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; r <= maxDecompositionLevelsCount; r++) {
      for (; l < layersCount; l++) {
        for (; i < componentsCount; i++) {
          const component = tile.components[i];
          if (r > component.codingStyleParameters.decompositionLevelsCount) {
            continue;
          }
          const resolution = component.resolutions[r];
          const numprecincts = resolution.precinctParameters.numprecincts;
          for (; k < numprecincts; ) {
            const packet = createPacket(resolution, k, l);
            k++;
            return packet;
          }
          k = 0;
        }
        i = 0;
      }
      l = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function ResolutionPositionComponentLayerIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  let l, r, c, p;
  let maxDecompositionLevelsCount = 0;
  for (c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
  }
  const maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
  for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
    let maxNumPrecincts = 0;
    for (c = 0; c < componentsCount; ++c) {
      const resolutions = tile.components[c].resolutions;
      if (r < resolutions.length) {
        maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
      }
    }
    maxNumPrecinctsInLevel[r] = maxNumPrecincts;
  }
  l = 0;
  r = 0;
  c = 0;
  p = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; r <= maxDecompositionLevelsCount; r++) {
      for (; p < maxNumPrecinctsInLevel[r]; p++) {
        for (; c < componentsCount; c++) {
          const component = tile.components[c];
          if (r > component.codingStyleParameters.decompositionLevelsCount) {
            continue;
          }
          const resolution = component.resolutions[r];
          const numprecincts = resolution.precinctParameters.numprecincts;
          if (p >= numprecincts) {
            continue;
          }
          for (; l < layersCount; ) {
            const packet = createPacket(resolution, p, l);
            l++;
            return packet;
          }
          l = 0;
        }
        c = 0;
      }
      p = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function PositionComponentResolutionLayerIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  const precinctsSizes = getPrecinctSizesInImageScale(tile);
  const precinctsIterationSizes = precinctsSizes;
  let l = 0, r = 0, c = 0, px = 0, py = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; py < precinctsIterationSizes.maxNumHigh; py++) {
      for (; px < precinctsIterationSizes.maxNumWide; px++) {
        for (; c < componentsCount; c++) {
          const component = tile.components[c];
          const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
          for (; r <= decompositionLevelsCount; r++) {
            const resolution = component.resolutions[r];
            const sizeInImageScale = precinctsSizes.components[c].resolutions[r];
            const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
            if (k === null) {
              continue;
            }
            for (; l < layersCount; ) {
              const packet = createPacket(resolution, k, l);
              l++;
              return packet;
            }
            l = 0;
          }
          r = 0;
        }
        c = 0;
      }
      px = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function ComponentPositionResolutionLayerIterator(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const layersCount = tile.codingStyleDefaultParameters.layersCount;
  const componentsCount = siz.Csiz;
  const precinctsSizes = getPrecinctSizesInImageScale(tile);
  let l = 0, r = 0, c = 0, px = 0, py = 0;
  this.nextPacket = function JpxImage_nextPacket() {
    for (; c < componentsCount; ++c) {
      const component = tile.components[c];
      const precinctsIterationSizes = precinctsSizes.components[c];
      const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; r <= decompositionLevelsCount; r++) {
            const resolution = component.resolutions[r];
            const sizeInImageScale = precinctsIterationSizes.resolutions[r];
            const k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
            if (k === null) {
              continue;
            }
            for (; l < layersCount; ) {
              const packet = createPacket(resolution, k, l);
              l++;
              return packet;
            }
            l = 0;
          }
          r = 0;
        }
        px = 0;
      }
      py = 0;
    }
    throw new JpxError("Out of packets");
  };
}
function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
  const posX = pxIndex * precinctIterationSizes.minWidth;
  const posY = pyIndex * precinctIterationSizes.minHeight;
  if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
    return null;
  }
  const startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
  return posX / sizeInImageScale.height + startPrecinctRowIndex;
}
function getPrecinctSizesInImageScale(tile) {
  const componentsCount = tile.components.length;
  let minWidth = Number.MAX_VALUE;
  let minHeight = Number.MAX_VALUE;
  let maxNumWide = 0;
  let maxNumHigh = 0;
  const sizePerComponent = new Array(componentsCount);
  for (let c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
    const sizePerResolution = new Array(decompositionLevelsCount + 1);
    let minWidthCurrentComponent = Number.MAX_VALUE;
    let minHeightCurrentComponent = Number.MAX_VALUE;
    let maxNumWideCurrentComponent = 0;
    let maxNumHighCurrentComponent = 0;
    let scale = 1;
    for (let r = decompositionLevelsCount; r >= 0; --r) {
      const resolution = component.resolutions[r];
      const widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
      const heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
      minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
      minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
      maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
      maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
      sizePerResolution[r] = {
        width: widthCurrentResolution,
        height: heightCurrentResolution
      };
      scale <<= 1;
    }
    minWidth = Math.min(minWidth, minWidthCurrentComponent);
    minHeight = Math.min(minHeight, minHeightCurrentComponent);
    maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
    maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
    sizePerComponent[c] = {
      resolutions: sizePerResolution,
      minWidth: minWidthCurrentComponent,
      minHeight: minHeightCurrentComponent,
      maxNumWide: maxNumWideCurrentComponent,
      maxNumHigh: maxNumHighCurrentComponent
    };
  }
  return {
    components: sizePerComponent,
    minWidth,
    minHeight,
    maxNumWide,
    maxNumHigh
  };
}
function buildPackets(context) {
  const siz = context.SIZ;
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const componentsCount = siz.Csiz;
  for (let c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    const decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
    const resolutions = [];
    const subbands = [];
    for (let r = 0; r <= decompositionLevelsCount; r++) {
      const blocksDimensions = getBlocksDimensions(context, component, r);
      const resolution = {};
      const scale = 1 << decompositionLevelsCount - r;
      resolution.trx0 = Math.ceil(component.tcx0 / scale);
      resolution.try0 = Math.ceil(component.tcy0 / scale);
      resolution.trx1 = Math.ceil(component.tcx1 / scale);
      resolution.try1 = Math.ceil(component.tcy1 / scale);
      resolution.resLevel = r;
      buildPrecincts(context, resolution, blocksDimensions);
      resolutions.push(resolution);
      let subband;
      if (r === 0) {
        subband = {};
        subband.type = "LL";
        subband.tbx0 = Math.ceil(component.tcx0 / scale);
        subband.tby0 = Math.ceil(component.tcy0 / scale);
        subband.tbx1 = Math.ceil(component.tcx1 / scale);
        subband.tby1 = Math.ceil(component.tcy1 / scale);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolution.subbands = [subband];
      } else {
        const bscale = 1 << decompositionLevelsCount - r + 1;
        const resolutionSubbands = [];
        subband = {};
        subband.type = "HL";
        subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
        subband.tby0 = Math.ceil(component.tcy0 / bscale);
        subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
        subband.tby1 = Math.ceil(component.tcy1 / bscale);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolutionSubbands.push(subband);
        subband = {};
        subband.type = "LH";
        subband.tbx0 = Math.ceil(component.tcx0 / bscale);
        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
        subband.tbx1 = Math.ceil(component.tcx1 / bscale);
        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolutionSubbands.push(subband);
        subband = {};
        subband.type = "HH";
        subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
        subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
        subband.resolution = resolution;
        buildCodeblocks(context, subband, blocksDimensions);
        subbands.push(subband);
        resolutionSubbands.push(subband);
        resolution.subbands = resolutionSubbands;
      }
    }
    component.resolutions = resolutions;
    component.subbands = subbands;
  }
  const progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
  switch (progressionOrder) {
    case 0:
      tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
      break;
    case 1:
      tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
      break;
    case 2:
      tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
      break;
    case 3:
      tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
      break;
    case 4:
      tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
      break;
    default:
      throw new JpxError(`Unsupported progression order ${progressionOrder}`);
  }
}
function parseTilePackets(context, data, offset, dataLength) {
  let position = 0;
  let buffer, bufferSize = 0, skipNextBit = false;
  function readBits(count) {
    while (bufferSize < count) {
      const b = data[offset + position];
      position++;
      if (skipNextBit) {
        buffer = buffer << 7 | b;
        bufferSize += 7;
        skipNextBit = false;
      } else {
        buffer = buffer << 8 | b;
        bufferSize += 8;
      }
      if (b === 255) {
        skipNextBit = true;
      }
    }
    bufferSize -= count;
    return buffer >>> bufferSize & (1 << count) - 1;
  }
  function skipMarkerIfEqual(value) {
    if (data[offset + position - 1] === 255 && data[offset + position] === value) {
      skipBytes(1);
      return true;
    } else if (data[offset + position] === 255 && data[offset + position + 1] === value) {
      skipBytes(2);
      return true;
    }
    return false;
  }
  function skipBytes(count) {
    position += count;
  }
  function alignToByte() {
    bufferSize = 0;
    if (skipNextBit) {
      position++;
      skipNextBit = false;
    }
  }
  function readCodingpasses() {
    if (readBits(1) === 0) {
      return 1;
    }
    if (readBits(1) === 0) {
      return 2;
    }
    let value = readBits(2);
    if (value < 3) {
      return value + 3;
    }
    value = readBits(5);
    if (value < 31) {
      return value + 6;
    }
    value = readBits(7);
    return value + 37;
  }
  const tileIndex = context.currentTile.index;
  const tile = context.tiles[tileIndex];
  const sopMarkerUsed = context.COD.sopMarkerUsed;
  const ephMarkerUsed = context.COD.ephMarkerUsed;
  const packetsIterator = tile.packetsIterator;
  while (position < dataLength) {
    alignToByte();
    if (sopMarkerUsed && skipMarkerIfEqual(145)) {
      skipBytes(4);
    }
    const packet = packetsIterator.nextPacket();
    if (!readBits(1)) {
      continue;
    }
    const layerNumber = packet.layerNumber, queue = [];
    let codeblock;
    for (let i = 0, ii = packet.codeblocks.length; i < ii; i++) {
      codeblock = packet.codeblocks[i];
      let precinct = codeblock.precinct;
      const codeblockColumn = codeblock.cbx - precinct.cbxMin;
      const codeblockRow = codeblock.cby - precinct.cbyMin;
      let codeblockIncluded = false;
      let firstTimeInclusion = false;
      let valueReady, zeroBitPlanesTree;
      if (codeblock.included !== void 0) {
        codeblockIncluded = !!readBits(1);
      } else {
        precinct = codeblock.precinct;
        let inclusionTree;
        if (precinct.inclusionTree !== void 0) {
          inclusionTree = precinct.inclusionTree;
        } else {
          const width = precinct.cbxMax - precinct.cbxMin + 1;
          const height = precinct.cbyMax - precinct.cbyMin + 1;
          inclusionTree = new InclusionTree(width, height, layerNumber);
          zeroBitPlanesTree = new TagTree(width, height);
          precinct.inclusionTree = inclusionTree;
          precinct.zeroBitPlanesTree = zeroBitPlanesTree;
        }
        if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
          while (true) {
            if (readBits(1)) {
              valueReady = !inclusionTree.nextLevel();
              if (valueReady) {
                codeblock.included = true;
                codeblockIncluded = firstTimeInclusion = true;
                break;
              }
            } else {
              inclusionTree.incrementValue(layerNumber);
              break;
            }
          }
        }
      }
      if (!codeblockIncluded) {
        continue;
      }
      if (firstTimeInclusion) {
        zeroBitPlanesTree = precinct.zeroBitPlanesTree;
        zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
        while (true) {
          if (readBits(1)) {
            valueReady = !zeroBitPlanesTree.nextLevel();
            if (valueReady) {
              break;
            }
          } else {
            zeroBitPlanesTree.incrementValue();
          }
        }
        codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
      }
      const codingpasses = readCodingpasses();
      while (readBits(1)) {
        codeblock.Lblock++;
      }
      const codingpassesLog2 = log2(codingpasses);
      const bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
      const codedDataLength = readBits(bits);
      queue.push({
        codeblock,
        codingpasses,
        dataLength: codedDataLength
      });
    }
    alignToByte();
    if (ephMarkerUsed) {
      skipMarkerIfEqual(146);
    }
    while (queue.length > 0) {
      const packetItem = queue.shift();
      codeblock = packetItem.codeblock;
      if (codeblock.data === void 0) {
        codeblock.data = [];
      }
      codeblock.data.push({
        data,
        start: offset + position,
        end: offset + position + packetItem.dataLength,
        codingpasses: packetItem.codingpasses
      });
      position += packetItem.dataLength;
    }
  }
  return position;
}
function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
  const x0 = subband.tbx0;
  const y0 = subband.tby0;
  const width = subband.tbx1 - subband.tbx0;
  const codeblocks = subband.codeblocks;
  const right = subband.type.charAt(0) === "H" ? 1 : 0;
  const bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
  for (let i = 0, ii = codeblocks.length; i < ii; ++i) {
    const codeblock = codeblocks[i];
    const blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
    const blockHeight = codeblock.tby1_ - codeblock.tby0_;
    if (blockWidth === 0 || blockHeight === 0) {
      continue;
    }
    if (codeblock.data === void 0) {
      continue;
    }
    const bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
    let currentCodingpassType = 2;
    const data = codeblock.data;
    let totalLength = 0, codingpasses = 0;
    let j, jj, dataItem;
    for (j = 0, jj = data.length; j < jj; j++) {
      dataItem = data[j];
      totalLength += dataItem.end - dataItem.start;
      codingpasses += dataItem.codingpasses;
    }
    const encodedData = new Uint8Array(totalLength);
    let position = 0;
    for (j = 0, jj = data.length; j < jj; j++) {
      dataItem = data[j];
      const chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
      encodedData.set(chunk, position);
      position += chunk.length;
    }
    const decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
    bitModel.setDecoder(decoder);
    for (j = 0; j < codingpasses; j++) {
      switch (currentCodingpassType) {
        case 0:
          bitModel.runSignificancePropagationPass();
          break;
        case 1:
          bitModel.runMagnitudeRefinementPass();
          break;
        case 2:
          bitModel.runCleanupPass();
          if (segmentationSymbolUsed) {
            bitModel.checkSegmentationSymbol();
          }
          break;
      }
      currentCodingpassType = (currentCodingpassType + 1) % 3;
    }
    let offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
    const sign = bitModel.coefficentsSign;
    const magnitude = bitModel.coefficentsMagnitude;
    const bitsDecoded = bitModel.bitsDecoded;
    const magnitudeCorrection = reversible ? 0 : 0.5;
    let k, n, nb;
    position = 0;
    const interleave = subband.type !== "LL";
    for (j = 0; j < blockHeight; j++) {
      const row = offset / width | 0;
      const levelOffset = 2 * row * (levelWidth - width) + right + bottom;
      for (k = 0; k < blockWidth; k++) {
        n = magnitude[position];
        if (n !== 0) {
          n = (n + magnitudeCorrection) * delta;
          if (sign[position] !== 0) {
            n = -n;
          }
          nb = bitsDecoded[position];
          const pos = interleave ? levelOffset + (offset << 1) : offset;
          if (reversible && nb >= mb) {
            coefficients[pos] = n;
          } else {
            coefficients[pos] = n * (1 << mb - nb);
          }
        }
        offset++;
        position++;
      }
      offset += width - blockWidth;
    }
  }
}
function transformTile(context, tile, c) {
  const component = tile.components[c];
  const codingStyleParameters = component.codingStyleParameters;
  const quantizationParameters = component.quantizationParameters;
  const decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
  const spqcds = quantizationParameters.SPqcds;
  const scalarExpounded = quantizationParameters.scalarExpounded;
  const guardBits = quantizationParameters.guardBits;
  const segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
  const precision = context.components[c].precision;
  const reversible = codingStyleParameters.reversibleTransformation;
  const transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
  const subbandCoefficients = [];
  let b = 0;
  for (let i = 0; i <= decompositionLevelsCount; i++) {
    const resolution = component.resolutions[i];
    const width = resolution.trx1 - resolution.trx0;
    const height = resolution.try1 - resolution.try0;
    const coefficients = new Float32Array(width * height);
    for (let j = 0, jj = resolution.subbands.length; j < jj; j++) {
      let mu, epsilon;
      if (!scalarExpounded) {
        mu = spqcds[0].mu;
        epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
      } else {
        mu = spqcds[b].mu;
        epsilon = spqcds[b].epsilon;
        b++;
      }
      const subband = resolution.subbands[j];
      const gainLog2 = SubbandsGainLog2[subband.type];
      const delta = reversible ? 1 : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048);
      const mb = guardBits + epsilon - 1;
      copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
    }
    subbandCoefficients.push({
      width,
      height,
      items: coefficients
    });
  }
  const result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
  return {
    left: component.tcx0,
    top: component.tcy0,
    width: result.width,
    height: result.height,
    items: result.items
  };
}
function transformComponents(context) {
  const siz = context.SIZ;
  const components = context.components;
  const componentsCount = siz.Csiz;
  const resultImages = [];
  for (let i = 0, ii = context.tiles.length; i < ii; i++) {
    const tile = context.tiles[i];
    const transformedTiles = [];
    for (let c = 0; c < componentsCount; c++) {
      transformedTiles[c] = transformTile(context, tile, c);
    }
    const tile0 = transformedTiles[0];
    const out = new Uint8ClampedArray(tile0.items.length * componentsCount);
    const result = {
      left: tile0.left,
      top: tile0.top,
      width: tile0.width,
      height: tile0.height,
      items: out
    };
    let shift, offset;
    let pos = 0, j, jj, y0, y1, y2;
    if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
      const fourComponents = componentsCount === 4;
      const y0items = transformedTiles[0].items;
      const y1items = transformedTiles[1].items;
      const y2items = transformedTiles[2].items;
      const y3items = fourComponents ? transformedTiles[3].items : null;
      shift = components[0].precision - 8;
      offset = (128 << shift) + 0.5;
      const component0 = tile.components[0];
      const alpha01 = componentsCount - 3;
      jj = y0items.length;
      if (!component0.codingStyleParameters.reversibleTransformation) {
        for (j = 0; j < jj; j++, pos += alpha01) {
          y0 = y0items[j] + offset;
          y1 = y1items[j];
          y2 = y2items[j];
          out[pos++] = y0 + 1.402 * y2 >> shift;
          out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
          out[pos++] = y0 + 1.772 * y1 >> shift;
        }
      } else {
        for (j = 0; j < jj; j++, pos += alpha01) {
          y0 = y0items[j] + offset;
          y1 = y1items[j];
          y2 = y2items[j];
          const g = y0 - (y2 + y1 >> 2);
          out[pos++] = g + y2 >> shift;
          out[pos++] = g >> shift;
          out[pos++] = g + y1 >> shift;
        }
      }
      if (fourComponents) {
        for (j = 0, pos = 3; j < jj; j++, pos += 4) {
          out[pos] = y3items[j] + offset >> shift;
        }
      }
    } else {
      for (let c = 0; c < componentsCount; c++) {
        const items = transformedTiles[c].items;
        shift = components[c].precision - 8;
        offset = (128 << shift) + 0.5;
        for (pos = c, j = 0, jj = items.length; j < jj; j++) {
          out[pos] = items[j] + offset >> shift;
          pos += componentsCount;
        }
      }
    }
    resultImages.push(result);
  }
  return resultImages;
}
function initializeTile(context, tileIndex) {
  const siz = context.SIZ;
  const componentsCount = siz.Csiz;
  const tile = context.tiles[tileIndex];
  for (let c = 0; c < componentsCount; c++) {
    const component = tile.components[c];
    const qcdOrQcc = context.currentTile.QCC[c] !== void 0 ? context.currentTile.QCC[c] : context.currentTile.QCD;
    component.quantizationParameters = qcdOrQcc;
    const codOrCoc = context.currentTile.COC[c] !== void 0 ? context.currentTile.COC[c] : context.currentTile.COD;
    component.codingStyleParameters = codOrCoc;
  }
  tile.codingStyleDefaultParameters = context.currentTile.COD;
}
var TagTree = class {
  constructor(width, height) {
    const levelsLength = log2(Math.max(width, height)) + 1;
    this.levels = [];
    for (let i = 0; i < levelsLength; i++) {
      const level = {
        width,
        height,
        items: []
      };
      this.levels.push(level);
      width = Math.ceil(width / 2);
      height = Math.ceil(height / 2);
    }
  }
  reset(i, j) {
    let currentLevel = 0, value = 0, level;
    while (currentLevel < this.levels.length) {
      level = this.levels[currentLevel];
      const index = i + j * level.width;
      if (level.items[index] !== void 0) {
        value = level.items[index];
        break;
      }
      level.index = index;
      i >>= 1;
      j >>= 1;
      currentLevel++;
    }
    currentLevel--;
    level = this.levels[currentLevel];
    level.items[level.index] = value;
    this.currentLevel = currentLevel;
    delete this.value;
  }
  incrementValue() {
    const level = this.levels[this.currentLevel];
    level.items[level.index]++;
  }
  nextLevel() {
    let currentLevel = this.currentLevel;
    let level = this.levels[currentLevel];
    const value = level.items[level.index];
    currentLevel--;
    if (currentLevel < 0) {
      this.value = value;
      return false;
    }
    this.currentLevel = currentLevel;
    level = this.levels[currentLevel];
    level.items[level.index] = value;
    return true;
  }
};
var InclusionTree = class {
  constructor(width, height, defaultValue) {
    const levelsLength = log2(Math.max(width, height)) + 1;
    this.levels = [];
    for (let i = 0; i < levelsLength; i++) {
      const items = new Uint8Array(width * height);
      for (let j = 0, jj = items.length; j < jj; j++) {
        items[j] = defaultValue;
      }
      const level = {
        width,
        height,
        items
      };
      this.levels.push(level);
      width = Math.ceil(width / 2);
      height = Math.ceil(height / 2);
    }
  }
  reset(i, j, stopValue) {
    let currentLevel = 0;
    while (currentLevel < this.levels.length) {
      const level = this.levels[currentLevel];
      const index = i + j * level.width;
      level.index = index;
      const value = level.items[index];
      if (value === 255) {
        break;
      }
      if (value > stopValue) {
        this.currentLevel = currentLevel;
        this.propagateValues();
        return false;
      }
      i >>= 1;
      j >>= 1;
      currentLevel++;
    }
    this.currentLevel = currentLevel - 1;
    return true;
  }
  incrementValue(stopValue) {
    const level = this.levels[this.currentLevel];
    level.items[level.index] = stopValue + 1;
    this.propagateValues();
  }
  propagateValues() {
    let levelIndex = this.currentLevel;
    let level = this.levels[levelIndex];
    const currentValue = level.items[level.index];
    while (--levelIndex >= 0) {
      level = this.levels[levelIndex];
      level.items[level.index] = currentValue;
    }
  }
  nextLevel() {
    let currentLevel = this.currentLevel;
    let level = this.levels[currentLevel];
    const value = level.items[level.index];
    level.items[level.index] = 255;
    currentLevel--;
    if (currentLevel < 0) {
      return false;
    }
    this.currentLevel = currentLevel;
    level = this.levels[currentLevel];
    level.items[level.index] = value;
    return true;
  }
};
var BitModel = function BitModelClosure() {
  const UNIFORM_CONTEXT = 17;
  const RUNLENGTH_CONTEXT = 18;
  const LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
  const HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
  const HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
  class BitModel2 {
    constructor(width, height, subband, zeroBitPlanes, mb) {
      this.width = width;
      this.height = height;
      let contextLabelTable;
      if (subband === "HH") {
        contextLabelTable = HHContextLabel;
      } else if (subband === "HL") {
        contextLabelTable = HLContextLabel;
      } else {
        contextLabelTable = LLAndLHContextsLabel;
      }
      this.contextLabelTable = contextLabelTable;
      const coefficientCount = width * height;
      this.neighborsSignificance = new Uint8Array(coefficientCount);
      this.coefficentsSign = new Uint8Array(coefficientCount);
      let coefficentsMagnitude;
      if (mb > 14) {
        coefficentsMagnitude = new Uint32Array(coefficientCount);
      } else if (mb > 6) {
        coefficentsMagnitude = new Uint16Array(coefficientCount);
      } else {
        coefficentsMagnitude = new Uint8Array(coefficientCount);
      }
      this.coefficentsMagnitude = coefficentsMagnitude;
      this.processingFlags = new Uint8Array(coefficientCount);
      const bitsDecoded = new Uint8Array(coefficientCount);
      if (zeroBitPlanes !== 0) {
        for (let i = 0; i < coefficientCount; i++) {
          bitsDecoded[i] = zeroBitPlanes;
        }
      }
      this.bitsDecoded = bitsDecoded;
      this.reset();
    }
    setDecoder(decoder) {
      this.decoder = decoder;
    }
    reset() {
      this.contexts = new Int8Array(19);
      this.contexts[0] = 4 << 1 | 0;
      this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
      this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
    }
    setNeighborsSignificance(row, column, index) {
      const neighborsSignificance = this.neighborsSignificance;
      const width = this.width, height = this.height;
      const left = column > 0;
      const right = column + 1 < width;
      let i;
      if (row > 0) {
        i = index - width;
        if (left) {
          neighborsSignificance[i - 1] += 16;
        }
        if (right) {
          neighborsSignificance[i + 1] += 16;
        }
        neighborsSignificance[i] += 4;
      }
      if (row + 1 < height) {
        i = index + width;
        if (left) {
          neighborsSignificance[i - 1] += 16;
        }
        if (right) {
          neighborsSignificance[i + 1] += 16;
        }
        neighborsSignificance[i] += 4;
      }
      if (left) {
        neighborsSignificance[index - 1] += 1;
      }
      if (right) {
        neighborsSignificance[index + 1] += 1;
      }
      neighborsSignificance[index] |= 128;
    }
    runSignificancePropagationPass() {
      const decoder = this.decoder;
      const width = this.width, height = this.height;
      const coefficentsMagnitude = this.coefficentsMagnitude;
      const coefficentsSign = this.coefficentsSign;
      const neighborsSignificance = this.neighborsSignificance;
      const processingFlags = this.processingFlags;
      const contexts = this.contexts;
      const labels = this.contextLabelTable;
      const bitsDecoded = this.bitsDecoded;
      const processedInverseMask = ~1;
      const processedMask = 1;
      const firstMagnitudeBitMask = 2;
      for (let i0 = 0; i0 < height; i0 += 4) {
        for (let j = 0; j < width; j++) {
          let index = i0 * width + j;
          for (let i1 = 0; i1 < 4; i1++, index += width) {
            const i = i0 + i1;
            if (i >= height) {
              break;
            }
            processingFlags[index] &= processedInverseMask;
            if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
              continue;
            }
            const contextLabel = labels[neighborsSignificance[index]];
            const decision = decoder.readBit(contexts, contextLabel);
            if (decision) {
              const sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;
            }
            bitsDecoded[index]++;
            processingFlags[index] |= processedMask;
          }
        }
      }
    }
    decodeSignBit(row, column, index) {
      const width = this.width, height = this.height;
      const coefficentsMagnitude = this.coefficentsMagnitude;
      const coefficentsSign = this.coefficentsSign;
      let contribution, sign0, sign1, significance1;
      let contextLabel, decoded;
      significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
      if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
        sign1 = coefficentsSign[index + 1];
        if (significance1) {
          sign0 = coefficentsSign[index - 1];
          contribution = 1 - sign1 - sign0;
        } else {
          contribution = 1 - sign1 - sign1;
        }
      } else if (significance1) {
        sign0 = coefficentsSign[index - 1];
        contribution = 1 - sign0 - sign0;
      } else {
        contribution = 0;
      }
      const horizontalContribution = 3 * contribution;
      significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
      if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
        sign1 = coefficentsSign[index + width];
        if (significance1) {
          sign0 = coefficentsSign[index - width];
          contribution = 1 - sign1 - sign0 + horizontalContribution;
        } else {
          contribution = 1 - sign1 - sign1 + horizontalContribution;
        }
      } else if (significance1) {
        sign0 = coefficentsSign[index - width];
        contribution = 1 - sign0 - sign0 + horizontalContribution;
      } else {
        contribution = horizontalContribution;
      }
      if (contribution >= 0) {
        contextLabel = 9 + contribution;
        decoded = this.decoder.readBit(this.contexts, contextLabel);
      } else {
        contextLabel = 9 - contribution;
        decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
      }
      return decoded;
    }
    runMagnitudeRefinementPass() {
      const decoder = this.decoder;
      const width = this.width, height = this.height;
      const coefficentsMagnitude = this.coefficentsMagnitude;
      const neighborsSignificance = this.neighborsSignificance;
      const contexts = this.contexts;
      const bitsDecoded = this.bitsDecoded;
      const processingFlags = this.processingFlags;
      const processedMask = 1;
      const firstMagnitudeBitMask = 2;
      const length = width * height;
      const width4 = width * 4;
      for (let index0 = 0, indexNext; index0 < length; index0 = indexNext) {
        indexNext = Math.min(length, index0 + width4);
        for (let j = 0; j < width; j++) {
          for (let index = index0 + j; index < indexNext; index += width) {
            if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
              continue;
            }
            let contextLabel = 16;
            if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
              processingFlags[index] ^= firstMagnitudeBitMask;
              const significance = neighborsSignificance[index] & 127;
              contextLabel = significance === 0 ? 15 : 14;
            }
            const bit = decoder.readBit(contexts, contextLabel);
            coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
            bitsDecoded[index]++;
            processingFlags[index] |= processedMask;
          }
        }
      }
    }
    runCleanupPass() {
      const decoder = this.decoder;
      const width = this.width, height = this.height;
      const neighborsSignificance = this.neighborsSignificance;
      const coefficentsMagnitude = this.coefficentsMagnitude;
      const coefficentsSign = this.coefficentsSign;
      const contexts = this.contexts;
      const labels = this.contextLabelTable;
      const bitsDecoded = this.bitsDecoded;
      const processingFlags = this.processingFlags;
      const processedMask = 1;
      const firstMagnitudeBitMask = 2;
      const oneRowDown = width;
      const twoRowsDown = width * 2;
      const threeRowsDown = width * 3;
      let iNext;
      for (let i0 = 0; i0 < height; i0 = iNext) {
        iNext = Math.min(i0 + 4, height);
        const indexBase = i0 * width;
        const checkAllEmpty = i0 + 3 < height;
        for (let j = 0; j < width; j++) {
          const index0 = indexBase + j;
          const allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
          let i1 = 0, index = index0;
          let i = i0, sign;
          if (allEmpty) {
            const hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);
            if (!hasSignificantCoefficent) {
              bitsDecoded[index0]++;
              bitsDecoded[index0 + oneRowDown]++;
              bitsDecoded[index0 + twoRowsDown]++;
              bitsDecoded[index0 + threeRowsDown]++;
              continue;
            }
            i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
            if (i1 !== 0) {
              i = i0 + i1;
              index += i1 * width;
            }
            sign = this.decodeSignBit(i, j, index);
            coefficentsSign[index] = sign;
            coefficentsMagnitude[index] = 1;
            this.setNeighborsSignificance(i, j, index);
            processingFlags[index] |= firstMagnitudeBitMask;
            index = index0;
            for (let i2 = i0; i2 <= i; i2++, index += width) {
              bitsDecoded[index]++;
            }
            i1++;
          }
          for (i = i0 + i1; i < iNext; i++, index += width) {
            if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
              continue;
            }
            const contextLabel = labels[neighborsSignificance[index]];
            const decision = decoder.readBit(contexts, contextLabel);
            if (decision === 1) {
              sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;
            }
            bitsDecoded[index]++;
          }
        }
      }
    }
    checkSegmentationSymbol() {
      const decoder = this.decoder;
      const contexts = this.contexts;
      const symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
      if (symbol !== 10) {
        throw new JpxError("Invalid segmentation symbol");
      }
    }
  }
  return BitModel2;
}();
var Transform$1 = class _Transform$1 {
  constructor() {
    if (this.constructor === _Transform$1) {
      unreachable("Cannot initialize Transform.");
    }
  }
  calculate(subbands, u0, v0) {
    let ll = subbands[0];
    for (let i = 1, ii = subbands.length; i < ii; i++) {
      ll = this.iterate(ll, subbands[i], u0, v0);
    }
    return ll;
  }
  extend(buffer, offset, size) {
    let i1 = offset - 1, j1 = offset + 1;
    let i2 = offset + size - 2, j2 = offset + size;
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1--] = buffer[j1++];
    buffer[j2++] = buffer[i2--];
    buffer[i1] = buffer[j1];
    buffer[j2] = buffer[i2];
  }
  filter(x, offset, length) {
    unreachable("Abstract method `filter` called");
  }
  iterate(ll, hl_lh_hh, u0, v0) {
    const llWidth = ll.width, llHeight = ll.height;
    let llItems = ll.items;
    const width = hl_lh_hh.width;
    const height = hl_lh_hh.height;
    const items = hl_lh_hh.items;
    let i, j, k, l, u, v;
    for (k = 0, i = 0; i < llHeight; i++) {
      l = i * 2 * width;
      for (j = 0; j < llWidth; j++, k++, l += 2) {
        items[l] = llItems[k];
      }
    }
    llItems = ll.items = null;
    const bufferPadding = 4;
    const rowBuffer = new Float32Array(width + 2 * bufferPadding);
    if (width === 1) {
      if ((u0 & 1) !== 0) {
        for (v = 0, k = 0; v < height; v++, k += width) {
          items[k] *= 0.5;
        }
      }
    } else {
      for (v = 0, k = 0; v < height; v++, k += width) {
        rowBuffer.set(items.subarray(k, k + width), bufferPadding);
        this.extend(rowBuffer, bufferPadding, width);
        this.filter(rowBuffer, bufferPadding, width);
        items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
      }
    }
    let numBuffers = 16;
    const colBuffers = [];
    for (i = 0; i < numBuffers; i++) {
      colBuffers.push(new Float32Array(height + 2 * bufferPadding));
    }
    let b, currentBuffer = 0;
    ll = bufferPadding + height;
    if (height === 1) {
      if ((v0 & 1) !== 0) {
        for (u = 0; u < width; u++) {
          items[u] *= 0.5;
        }
      }
    } else {
      for (u = 0; u < width; u++) {
        if (currentBuffer === 0) {
          numBuffers = Math.min(width - u, numBuffers);
          for (k = u, l = bufferPadding; l < ll; k += width, l++) {
            for (b = 0; b < numBuffers; b++) {
              colBuffers[b][l] = items[k + b];
            }
          }
          currentBuffer = numBuffers;
        }
        currentBuffer--;
        const buffer = colBuffers[currentBuffer];
        this.extend(buffer, bufferPadding, height);
        this.filter(buffer, bufferPadding, height);
        if (currentBuffer === 0) {
          k = u - numBuffers + 1;
          for (l = bufferPadding; l < ll; k += width, l++) {
            for (b = 0; b < numBuffers; b++) {
              items[k + b] = colBuffers[b][l];
            }
          }
        }
      }
    }
    return {
      width,
      height,
      items
    };
  }
};
var IrreversibleTransform = class extends Transform$1 {
  filter(x, offset, length) {
    const len = length >> 1;
    offset |= 0;
    let j, n, current, next;
    const alpha = -1.586134342059924;
    const beta = -0.052980118572961;
    const gamma = 0.882911075530934;
    const delta = 0.443506852043971;
    const K = 1.230174104914001;
    const K_ = 1 / K;
    j = offset - 3;
    for (n = len + 4; n--; j += 2) {
      x[j] *= K_;
    }
    j = offset - 2;
    current = delta * x[j - 1];
    for (n = len + 3; n--; j += 2) {
      next = delta * x[j + 1];
      x[j] = K * x[j] - current - next;
      if (n--) {
        j += 2;
        current = delta * x[j + 1];
        x[j] = K * x[j] - current - next;
      } else {
        break;
      }
    }
    j = offset - 1;
    current = gamma * x[j - 1];
    for (n = len + 2; n--; j += 2) {
      next = gamma * x[j + 1];
      x[j] -= current + next;
      if (n--) {
        j += 2;
        current = gamma * x[j + 1];
        x[j] -= current + next;
      } else {
        break;
      }
    }
    j = offset;
    current = beta * x[j - 1];
    for (n = len + 1; n--; j += 2) {
      next = beta * x[j + 1];
      x[j] -= current + next;
      if (n--) {
        j += 2;
        current = beta * x[j + 1];
        x[j] -= current + next;
      } else {
        break;
      }
    }
    if (len !== 0) {
      j = offset + 1;
      current = alpha * x[j - 1];
      for (n = len; n--; j += 2) {
        next = alpha * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = alpha * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }
    }
  }
};
var ReversibleTransform = class extends Transform$1 {
  filter(x, offset, length) {
    const len = length >> 1;
    offset |= 0;
    let j, n;
    for (j = offset, n = len + 1; n--; j += 2) {
      x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
    }
    for (j = offset + 1, n = len; n--; j += 2) {
      x[j] += x[j - 1] + x[j + 1] >> 1;
    }
  }
};
var JpxStream = class extends DecodeStream {
  constructor(stream, maybeLength, params) {
    super(maybeLength);
    this.stream = stream;
    this.dict = stream.dict;
    this.maybeLength = maybeLength;
    this.params = params;
  }
  get bytes() {
    return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(requested) {
  }
  readBlock() {
    if (this.eof) {
      return;
    }
    const jpxImage = new JpxImage();
    jpxImage.parse(this.bytes);
    const width = jpxImage.width;
    const height = jpxImage.height;
    const componentsCount = jpxImage.componentsCount;
    const tileCount = jpxImage.tiles.length;
    if (tileCount === 1) {
      this.buffer = jpxImage.tiles[0].items;
    } else {
      const data = new Uint8ClampedArray(width * height * componentsCount);
      for (let k = 0; k < tileCount; k++) {
        const tileComponents = jpxImage.tiles[k];
        const tileWidth = tileComponents.width;
        const tileHeight = tileComponents.height;
        const tileLeft = tileComponents.left;
        const tileTop = tileComponents.top;
        const src = tileComponents.items;
        let srcPosition = 0;
        let dataPosition = (width * tileTop + tileLeft) * componentsCount;
        const imgRowSize = width * componentsCount;
        const tileRowSize = tileWidth * componentsCount;
        for (let j = 0; j < tileHeight; j++) {
          const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
          data.set(rowBytes, dataPosition);
          srcPosition += tileRowSize;
          dataPosition += imgRowSize;
        }
      }
      this.buffer = data;
    }
    this.bufferLength = this.buffer.length;
    this.eof = true;
  }
};
var LZWStream = class extends DecodeStream {
  constructor(str, maybeLength, earlyChange) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.cachedData = 0;
    this.bitsCached = 0;
    const maxLzwDictionarySize = 4096;
    const lzwState = {
      earlyChange,
      codeLength: 9,
      nextCode: 258,
      dictionaryValues: new Uint8Array(maxLzwDictionarySize),
      dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
      dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
      currentSequence: new Uint8Array(maxLzwDictionarySize),
      currentSequenceLength: 0
    };
    for (let i = 0; i < 256; ++i) {
      lzwState.dictionaryValues[i] = i;
      lzwState.dictionaryLengths[i] = 1;
    }
    this.lzwState = lzwState;
  }
  readBits(n) {
    let bitsCached = this.bitsCached;
    let cachedData = this.cachedData;
    while (bitsCached < n) {
      const c = this.str.getByte();
      if (c === -1) {
        this.eof = true;
        return null;
      }
      cachedData = cachedData << 8 | c;
      bitsCached += 8;
    }
    this.bitsCached = bitsCached -= n;
    this.cachedData = cachedData;
    this.lastCode = null;
    return cachedData >>> bitsCached & (1 << n) - 1;
  }
  readBlock() {
    const blockSize = 512, decodedSizeDelta = blockSize;
    let estimatedDecodedSize = blockSize * 2;
    let i, j, q;
    const lzwState = this.lzwState;
    if (!lzwState) {
      return;
    }
    const earlyChange = lzwState.earlyChange;
    let nextCode = lzwState.nextCode;
    const dictionaryValues = lzwState.dictionaryValues;
    const dictionaryLengths = lzwState.dictionaryLengths;
    const dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
    let codeLength = lzwState.codeLength;
    let prevCode = lzwState.prevCode;
    const currentSequence = lzwState.currentSequence;
    let currentSequenceLength = lzwState.currentSequenceLength;
    let decodedLength = 0;
    let currentBufferLength = this.bufferLength;
    let buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
    for (i = 0; i < blockSize; i++) {
      const code = this.readBits(codeLength);
      const hasPrev = currentSequenceLength > 0;
      if (code < 256) {
        currentSequence[0] = code;
        currentSequenceLength = 1;
      } else if (code >= 258) {
        if (code < nextCode) {
          currentSequenceLength = dictionaryLengths[code];
          for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
            currentSequence[j] = dictionaryValues[q];
            q = dictionaryPrevCodes[q];
          }
        } else {
          currentSequence[currentSequenceLength++] = currentSequence[0];
        }
      } else if (code === 256) {
        codeLength = 9;
        nextCode = 258;
        currentSequenceLength = 0;
        continue;
      } else {
        this.eof = true;
        delete this.lzwState;
        break;
      }
      if (hasPrev) {
        dictionaryPrevCodes[nextCode] = prevCode;
        dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
        dictionaryValues[nextCode] = currentSequence[0];
        nextCode++;
        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
      }
      prevCode = code;
      decodedLength += currentSequenceLength;
      if (estimatedDecodedSize < decodedLength) {
        do {
          estimatedDecodedSize += decodedSizeDelta;
        } while (estimatedDecodedSize < decodedLength);
        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
      }
      for (j = 0; j < currentSequenceLength; j++) {
        buffer[currentBufferLength++] = currentSequence[j];
      }
    }
    lzwState.nextCode = nextCode;
    lzwState.codeLength = codeLength;
    lzwState.prevCode = prevCode;
    lzwState.currentSequenceLength = currentSequenceLength;
    this.bufferLength = currentBufferLength;
  }
};
var PredictorStream = class extends DecodeStream {
  constructor(str, maybeLength, params) {
    super(maybeLength);
    if (!isDict(params)) {
      return str;
    }
    const predictor = this.predictor = params.get("Predictor") || 1;
    if (predictor <= 1) {
      return str;
    }
    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
      throw new FormatError(`Unsupported predictor: ${predictor}`);
    }
    if (predictor === 2) {
      this.readBlock = this.readBlockTiff;
    } else {
      this.readBlock = this.readBlockPng;
    }
    this.str = str;
    this.dict = str.dict;
    const colors = this.colors = params.get("Colors") || 1;
    const bits = this.bits = params.get("BitsPerComponent") || 8;
    const columns = this.columns = params.get("Columns") || 1;
    this.pixBytes = colors * bits + 7 >> 3;
    this.rowBytes = columns * colors * bits + 7 >> 3;
    return this;
  }
  readBlockTiff() {
    const rowBytes = this.rowBytes;
    const bufferLength = this.bufferLength;
    const buffer = this.ensureBuffer(bufferLength + rowBytes);
    const bits = this.bits;
    const colors = this.colors;
    const rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    if (this.eof) {
      return;
    }
    let inbuf = 0, outbuf = 0;
    let inbits = 0, outbits = 0;
    let pos = bufferLength;
    let i;
    if (bits === 1 && colors === 1) {
      for (i = 0; i < rowBytes; ++i) {
        let c = rawBytes[i] ^ inbuf;
        c ^= c >> 1;
        c ^= c >> 2;
        c ^= c >> 4;
        inbuf = (c & 1) << 7;
        buffer[pos++] = c;
      }
    } else if (bits === 8) {
      for (i = 0; i < colors; ++i) {
        buffer[pos++] = rawBytes[i];
      }
      for (; i < rowBytes; ++i) {
        buffer[pos] = buffer[pos - colors] + rawBytes[i];
        pos++;
      }
    } else if (bits === 16) {
      const bytesPerPixel = colors * 2;
      for (i = 0; i < bytesPerPixel; ++i) {
        buffer[pos++] = rawBytes[i];
      }
      for (; i < rowBytes; i += 2) {
        const sum = ((rawBytes[i] & 255) << 8) + (rawBytes[i + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);
        buffer[pos++] = sum >> 8 & 255;
        buffer[pos++] = sum & 255;
      }
    } else {
      const compArray = new Uint8Array(colors + 1);
      const bitMask = (1 << bits) - 1;
      let j = 0, k = bufferLength;
      const columns = this.columns;
      for (i = 0; i < columns; ++i) {
        for (let kk = 0; kk < colors; ++kk) {
          if (inbits < bits) {
            inbuf = inbuf << 8 | rawBytes[j++] & 255;
            inbits += 8;
          }
          compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
          inbits -= bits;
          outbuf = outbuf << bits | compArray[kk];
          outbits += bits;
          if (outbits >= 8) {
            buffer[k++] = outbuf >> outbits - 8 & 255;
            outbits -= 8;
          }
        }
      }
      if (outbits > 0) {
        buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
      }
    }
    this.bufferLength += rowBytes;
  }
  readBlockPng() {
    const rowBytes = this.rowBytes;
    const pixBytes = this.pixBytes;
    const predictor = this.str.getByte();
    const rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    if (this.eof) {
      return;
    }
    const bufferLength = this.bufferLength;
    const buffer = this.ensureBuffer(bufferLength + rowBytes);
    let prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
    if (prevRow.length === 0) {
      prevRow = new Uint8Array(rowBytes);
    }
    let i, j = bufferLength, up, c;
    switch (predictor) {
      case 0:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        break;
      case 1:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        for (; i < rowBytes; ++i) {
          buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 255;
          j++;
        }
        break;
      case 2:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = prevRow[i] + rawBytes[i] & 255;
        }
        break;
      case 3:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
        }
        for (; i < rowBytes; ++i) {
          buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 255;
          j++;
        }
        break;
      case 4:
        for (i = 0; i < pixBytes; ++i) {
          up = prevRow[i];
          c = rawBytes[i];
          buffer[j++] = up + c;
        }
        for (; i < rowBytes; ++i) {
          up = prevRow[i];
          const upLeft = prevRow[i - pixBytes];
          const left = buffer[j - pixBytes];
          const p = left + up - upLeft;
          let pa = p - left;
          if (pa < 0) {
            pa = -pa;
          }
          let pb = p - up;
          if (pb < 0) {
            pb = -pb;
          }
          let pc = p - upLeft;
          if (pc < 0) {
            pc = -pc;
          }
          c = rawBytes[i];
          if (pa <= pb && pa <= pc) {
            buffer[j++] = left + c;
          } else if (pb <= pc) {
            buffer[j++] = up + c;
          } else {
            buffer[j++] = upLeft + c;
          }
        }
        break;
      default:
        throw new FormatError(`Unsupported predictor: ${predictor}`);
    }
    this.bufferLength += rowBytes;
  }
};
var RunLengthStream = class extends DecodeStream {
  constructor(str, maybeLength) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
  }
  readBlock() {
    const repeatHeader = this.str.getBytes(2);
    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
      this.eof = true;
      return;
    }
    let buffer;
    let bufferLength = this.bufferLength;
    let n = repeatHeader[0];
    if (n < 128) {
      buffer = this.ensureBuffer(bufferLength + n + 1);
      buffer[bufferLength++] = repeatHeader[1];
      if (n > 0) {
        const source = this.str.getBytes(n);
        buffer.set(source, bufferLength);
        bufferLength += n;
      }
    } else {
      n = 257 - n;
      const b = repeatHeader[1];
      buffer = this.ensureBuffer(bufferLength + n + 1);
      for (let i = 0; i < n; i++) {
        buffer[bufferLength++] = b;
      }
    }
    this.bufferLength = bufferLength;
  }
};
var MAX_LENGTH_TO_CACHE = 1e3;
var MAX_ADLER32_LENGTH = 5552;
function computeAdler32(bytes) {
  const bytesLength = bytes.length;
  if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
    assert(bytesLength < MAX_ADLER32_LENGTH, 'computeAdler32: Unsupported "bytes" length.');
  }
  let a = 1, b = 0;
  for (let i = 0; i < bytesLength; ++i) {
    a += bytes[i] & 255;
    b += a;
  }
  return b % 65521 << 16 | a % 65521;
}
var Parser = class {
  constructor({
    lexer,
    xref,
    allowStreams = false,
    recoveryMode = false
  }) {
    this.lexer = lexer;
    this.xref = xref;
    this.allowStreams = allowStreams;
    this.recoveryMode = recoveryMode;
    this.imageCache = /* @__PURE__ */ Object.create(null);
    this.refill();
  }
  refill() {
    this.buf1 = this.lexer.getObj();
    this.buf2 = this.lexer.getObj();
  }
  shift() {
    if (this.buf2 instanceof Cmd && this.buf2.cmd === "ID") {
      this.buf1 = this.buf2;
      this.buf2 = null;
    } else {
      this.buf1 = this.buf2;
      this.buf2 = this.lexer.getObj();
    }
  }
  tryShift() {
    try {
      this.shift();
      return true;
    } catch (e) {
      if (e instanceof MissingDataException) {
        throw e;
      }
      return false;
    }
  }
  getObj(cipherTransform = null) {
    const buf1 = this.buf1;
    this.shift();
    if (buf1 instanceof Cmd) {
      switch (buf1.cmd) {
        case "BI":
          return this.makeInlineImage(cipherTransform);
        case "[":
          const array = [];
          while (!isCmd(this.buf1, "]") && !isEOF(this.buf1)) {
            array.push(this.getObj(cipherTransform));
          }
          if (isEOF(this.buf1)) {
            if (this.recoveryMode) {
              return array;
            }
            throw new ParserEOFException("End of file inside array.");
          }
          this.shift();
          return array;
        case "<<":
          const dict = new Dict(this.xref);
          while (!isCmd(this.buf1, ">>") && !isEOF(this.buf1)) {
            if (!isName(this.buf1)) {
              info("Malformed dictionary: key must be a name object");
              this.shift();
              continue;
            }
            const key = this.buf1.name;
            this.shift();
            if (isEOF(this.buf1)) {
              break;
            }
            dict.set(key, this.getObj(cipherTransform));
          }
          if (isEOF(this.buf1)) {
            if (this.recoveryMode) {
              return dict;
            }
            throw new ParserEOFException("End of file inside dictionary.");
          }
          if (isCmd(this.buf2, "stream")) {
            return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
          }
          this.shift();
          return dict;
        default:
          return buf1;
      }
    }
    if (Number.isInteger(buf1)) {
      if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
        const ref = Ref.get(buf1, this.buf1);
        this.shift();
        this.shift();
        return ref;
      }
      return buf1;
    }
    if (typeof buf1 === "string") {
      if (cipherTransform) {
        return cipherTransform.decryptString(buf1);
      }
      return buf1;
    }
    return buf1;
  }
  /**
   * Find the end of the stream by searching for the /EI\s/.
   * @returns {number} The inline stream length.
   */
  findDefaultInlineStreamEnd(stream) {
    const E = 69, I2 = 73, SPACE = 32, LF = 10, CR = 13, NUL = 0;
    const lexer = this.lexer, startPos = stream.pos, n = 10;
    let state = 0, ch, maybeEIPos;
    while ((ch = stream.getByte()) !== -1) {
      if (state === 0) {
        state = ch === E ? 1 : 0;
      } else if (state === 1) {
        state = ch === I2 ? 2 : 0;
      } else {
        assert(state === 2, "findDefaultInlineStreamEnd - invalid state.");
        if (ch === SPACE || ch === LF || ch === CR) {
          maybeEIPos = stream.pos;
          const followingBytes = stream.peekBytes(n);
          for (let i = 0, ii = followingBytes.length; i < ii; i++) {
            ch = followingBytes[i];
            if (ch === NUL && followingBytes[i + 1] !== NUL) {
              continue;
            }
            if (ch !== LF && ch !== CR && (ch < SPACE || ch > 127)) {
              state = 0;
              break;
            }
          }
          if (state !== 2) {
            continue;
          }
          if (lexer.knownCommands) {
            const nextObj = lexer.peekObj();
            if (nextObj instanceof Cmd && !lexer.knownCommands[nextObj.cmd]) {
              state = 0;
            }
          } else {
            warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
          }
          if (state === 2) {
            break;
          }
        } else {
          state = 0;
        }
      }
    }
    if (ch === -1) {
      warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
      if (maybeEIPos) {
        warn('... trying to recover by using the last "EI" occurrence.');
        stream.skip(-(stream.pos - maybeEIPos));
      }
    }
    let endOffset = 4;
    stream.skip(-endOffset);
    ch = stream.peekByte();
    stream.skip(endOffset);
    if (!isWhiteSpace(ch)) {
      endOffset--;
    }
    return stream.pos - endOffset - startPos;
  }
  /**
   * Find the EOI (end-of-image) marker 0xFFD9 of the stream.
   * @returns {number} The inline stream length.
   */
  findDCTDecodeInlineStreamEnd(stream) {
    const startPos = stream.pos;
    let foundEOI = false, b, markerLength;
    while ((b = stream.getByte()) !== -1) {
      if (b !== 255) {
        continue;
      }
      switch (stream.getByte()) {
        case 0:
          break;
        case 255:
          stream.skip(-1);
          break;
        case 217:
          foundEOI = true;
          break;
        case 192:
        case 193:
        case 194:
        case 195:
        case 197:
        case 198:
        case 199:
        case 201:
        case 202:
        case 203:
        case 205:
        case 206:
        case 207:
        case 196:
        case 204:
        case 218:
        case 219:
        case 220:
        case 221:
        case 222:
        case 223:
        case 224:
        case 225:
        case 226:
        case 227:
        case 228:
        case 229:
        case 230:
        case 231:
        case 232:
        case 233:
        case 234:
        case 235:
        case 236:
        case 237:
        case 238:
        case 239:
        case 254:
          markerLength = stream.getUint16();
          if (markerLength > 2) {
            stream.skip(markerLength - 2);
          } else {
            stream.skip(-2);
          }
          break;
      }
      if (foundEOI) {
        break;
      }
    }
    const length = stream.pos - startPos;
    if (b === -1) {
      warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
      stream.skip(-length);
      return this.findDefaultInlineStreamEnd(stream);
    }
    this.inlineStreamSkipEI(stream);
    return length;
  }
  /**
   * Find the EOD (end-of-data) marker '~>' (i.e. TILDE + GT) of the stream.
   * @returns {number} The inline stream length.
   */
  findASCII85DecodeInlineStreamEnd(stream) {
    const TILDE = 126, GT = 62;
    const startPos = stream.pos;
    let ch;
    while ((ch = stream.getByte()) !== -1) {
      if (ch === TILDE) {
        const tildePos = stream.pos;
        ch = stream.peekByte();
        while (isWhiteSpace(ch)) {
          stream.skip();
          ch = stream.peekByte();
        }
        if (ch === GT) {
          stream.skip();
          break;
        }
        if (stream.pos > tildePos) {
          const maybeEI = stream.peekBytes(2);
          if (maybeEI[0] === /* E = */
          69 && maybeEI[1] === /* I = */
          73) {
            break;
          }
        }
      }
    }
    const length = stream.pos - startPos;
    if (ch === -1) {
      warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
      stream.skip(-length);
      return this.findDefaultInlineStreamEnd(stream);
    }
    this.inlineStreamSkipEI(stream);
    return length;
  }
  /**
   * Find the EOD (end-of-data) marker '>' (i.e. GT) of the stream.
   * @returns {number} The inline stream length.
   */
  findASCIIHexDecodeInlineStreamEnd(stream) {
    const GT = 62;
    const startPos = stream.pos;
    let ch;
    while ((ch = stream.getByte()) !== -1) {
      if (ch === GT) {
        break;
      }
    }
    const length = stream.pos - startPos;
    if (ch === -1) {
      warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
      stream.skip(-length);
      return this.findDefaultInlineStreamEnd(stream);
    }
    this.inlineStreamSkipEI(stream);
    return length;
  }
  /**
   * Skip over the /EI/ for streams where we search for an EOD marker.
   */
  inlineStreamSkipEI(stream) {
    const E = 69, I2 = 73;
    let state = 0, ch;
    while ((ch = stream.getByte()) !== -1) {
      if (state === 0) {
        state = ch === E ? 1 : 0;
      } else if (state === 1) {
        state = ch === I2 ? 2 : 0;
      } else if (state === 2) {
        break;
      }
    }
  }
  makeInlineImage(cipherTransform) {
    const lexer = this.lexer;
    const stream = lexer.stream;
    const dict = new Dict(this.xref);
    let dictLength;
    while (!isCmd(this.buf1, "ID") && !isEOF(this.buf1)) {
      if (!isName(this.buf1)) {
        throw new FormatError("Dictionary key must be a name object");
      }
      const key = this.buf1.name;
      this.shift();
      if (isEOF(this.buf1)) {
        break;
      }
      dict.set(key, this.getObj(cipherTransform));
    }
    if (lexer.beginInlineImagePos !== -1) {
      dictLength = stream.pos - lexer.beginInlineImagePos;
    }
    const filter = dict.get("Filter", "F");
    let filterName;
    if (isName(filter)) {
      filterName = filter.name;
    } else if (Array.isArray(filter)) {
      const filterZero = this.xref.fetchIfRef(filter[0]);
      if (isName(filterZero)) {
        filterName = filterZero.name;
      }
    }
    const startPos = stream.pos;
    let length;
    if (filterName === "DCTDecode" || filterName === "DCT") {
      length = this.findDCTDecodeInlineStreamEnd(stream);
    } else if (filterName === "ASCII85Decode" || filterName === "A85") {
      length = this.findASCII85DecodeInlineStreamEnd(stream);
    } else if (filterName === "ASCIIHexDecode" || filterName === "AHx") {
      length = this.findASCIIHexDecodeInlineStreamEnd(stream);
    } else {
      length = this.findDefaultInlineStreamEnd(stream);
    }
    let imageStream = stream.makeSubStream(startPos, length, dict);
    let cacheKey;
    if (length < MAX_LENGTH_TO_CACHE && dictLength < MAX_ADLER32_LENGTH) {
      const imageBytes = imageStream.getBytes();
      imageStream.reset();
      const initialStreamPos = stream.pos;
      stream.pos = lexer.beginInlineImagePos;
      const dictBytes = stream.getBytes(dictLength);
      stream.pos = initialStreamPos;
      cacheKey = computeAdler32(imageBytes) + "_" + computeAdler32(dictBytes);
      const cacheEntry = this.imageCache[cacheKey];
      if (cacheEntry !== void 0) {
        this.buf2 = Cmd.get("EI");
        this.shift();
        cacheEntry.reset();
        return cacheEntry;
      }
    }
    if (cipherTransform) {
      imageStream = cipherTransform.createStream(imageStream, length);
    }
    imageStream = this.filter(imageStream, dict, length);
    imageStream.dict = dict;
    if (cacheKey !== void 0) {
      imageStream.cacheKey = `inline_${length}_${cacheKey}`;
      this.imageCache[cacheKey] = imageStream;
    }
    this.buf2 = Cmd.get("EI");
    this.shift();
    return imageStream;
  }
  _findStreamLength(startPos, signature) {
    const {
      stream
    } = this.lexer;
    stream.pos = startPos;
    const SCAN_BLOCK_LENGTH = 2048;
    const signatureLength = signature.length;
    while (stream.pos < stream.end) {
      const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
      const scanLength = scanBytes.length - signatureLength;
      if (scanLength <= 0) {
        break;
      }
      let pos = 0;
      while (pos < scanLength) {
        let j = 0;
        while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
          j++;
        }
        if (j >= signatureLength) {
          stream.pos += pos;
          return stream.pos - startPos;
        }
        pos++;
      }
      stream.pos += scanLength;
    }
    return -1;
  }
  makeStream(dict, cipherTransform) {
    const lexer = this.lexer;
    let stream = lexer.stream;
    lexer.skipToNextLine();
    const startPos = stream.pos - 1;
    let length = dict.get("Length");
    if (!Number.isInteger(length)) {
      info(`Bad length "${length}" in stream`);
      length = 0;
    }
    stream.pos = startPos + length;
    lexer.nextChar();
    if (this.tryShift() && isCmd(this.buf2, "endstream")) {
      this.shift();
    } else {
      const ENDSTREAM_SIGNATURE = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
      let actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);
      if (actualLength < 0) {
        const MAX_TRUNCATION = 1;
        for (let i = 1; i <= MAX_TRUNCATION; i++) {
          const end = ENDSTREAM_SIGNATURE.length - i;
          const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end);
          const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);
          if (maybeLength >= 0) {
            const lastByte = stream.peekBytes(end + 1)[end];
            if (!isWhiteSpace(lastByte)) {
              break;
            }
            info(`Found "${bytesToString(TRUNCATED_SIGNATURE)}" when searching for endstream command.`);
            actualLength = maybeLength;
            break;
          }
        }
        if (actualLength < 0) {
          throw new FormatError("Missing endstream command.");
        }
      }
      length = actualLength;
      lexer.nextChar();
      this.shift();
      this.shift();
    }
    this.shift();
    stream = stream.makeSubStream(startPos, length, dict);
    if (cipherTransform) {
      stream = cipherTransform.createStream(stream, length);
    }
    stream = this.filter(stream, dict, length);
    stream.dict = dict;
    return stream;
  }
  filter(stream, dict, length) {
    let filter = dict.get("Filter", "F");
    let params = dict.get("DecodeParms", "DP");
    if (isName(filter)) {
      if (Array.isArray(params)) {
        warn("/DecodeParms should not contain an Array, when /Filter contains a Name.");
      }
      return this.makeFilter(stream, filter.name, length, params);
    }
    let maybeLength = length;
    if (Array.isArray(filter)) {
      const filterArray = filter;
      const paramsArray = params;
      for (let i = 0, ii = filterArray.length; i < ii; ++i) {
        filter = this.xref.fetchIfRef(filterArray[i]);
        if (!isName(filter)) {
          throw new FormatError(`Bad filter name "${filter}"`);
        }
        params = null;
        if (Array.isArray(paramsArray) && i in paramsArray) {
          params = this.xref.fetchIfRef(paramsArray[i]);
        }
        stream = this.makeFilter(stream, filter.name, maybeLength, params);
        maybeLength = null;
      }
    }
    return stream;
  }
  makeFilter(stream, name, maybeLength, params) {
    if (maybeLength === 0) {
      warn(`Empty "${name}" stream.`);
      return new NullStream();
    }
    try {
      const xrefStreamStats = this.xref.stats.streamTypes;
      if (name === "FlateDecode" || name === "Fl") {
        xrefStreamStats[StreamType.FLATE] = true;
        if (params) {
          return new PredictorStream(new FlateStream(stream, maybeLength), maybeLength, params);
        }
        return new FlateStream(stream, maybeLength);
      }
      if (name === "LZWDecode" || name === "LZW") {
        xrefStreamStats[StreamType.LZW] = true;
        let earlyChange = 1;
        if (params) {
          if (params.has("EarlyChange")) {
            earlyChange = params.get("EarlyChange");
          }
          return new PredictorStream(new LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
        }
        return new LZWStream(stream, maybeLength, earlyChange);
      }
      if (name === "DCTDecode" || name === "DCT") {
        xrefStreamStats[StreamType.DCT] = true;
        return new JpegStream(stream, maybeLength, params);
      }
      if (name === "JPXDecode" || name === "JPX") {
        xrefStreamStats[StreamType.JPX] = true;
        return new JpxStream(stream, maybeLength, params);
      }
      if (name === "ASCII85Decode" || name === "A85") {
        xrefStreamStats[StreamType.A85] = true;
        return new Ascii85Stream(stream, maybeLength);
      }
      if (name === "ASCIIHexDecode" || name === "AHx") {
        xrefStreamStats[StreamType.AHX] = true;
        return new AsciiHexStream(stream, maybeLength);
      }
      if (name === "CCITTFaxDecode" || name === "CCF") {
        xrefStreamStats[StreamType.CCF] = true;
        return new CCITTFaxStream(stream, maybeLength, params);
      }
      if (name === "RunLengthDecode" || name === "RL") {
        xrefStreamStats[StreamType.RLX] = true;
        return new RunLengthStream(stream, maybeLength);
      }
      if (name === "JBIG2Decode") {
        xrefStreamStats[StreamType.JBIG] = true;
        return new Jbig2Stream(stream, maybeLength, params);
      }
      warn(`Filter "${name}" is not supported.`);
      return stream;
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn(`Invalid stream: "${ex}"`);
      return new NullStream();
    }
  }
};
var specialChars = [
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  // 0x
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 1x
  1,
  0,
  0,
  0,
  0,
  2,
  0,
  0,
  2,
  2,
  0,
  0,
  0,
  0,
  0,
  2,
  // 2x
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  2,
  0,
  // 3x
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 4x
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  2,
  0,
  0,
  // 5x
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 6x
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  2,
  0,
  0,
  // 7x
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 8x
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 9x
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // ax
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // bx
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // cx
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // dx
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // ex
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
  // fx
];
function toHexDigit(ch) {
  if (ch >= /* '0' = */
  48 && ch <= 57) {
    return ch & 15;
  }
  if (ch >= /* 'A' = */
  65 && ch <= /* 'F' = */
  70 || ch >= /* 'a' = */
  97 && ch <= /* 'f' = */
  102) {
    return (ch & 15) + 9;
  }
  return -1;
}
var Lexer = class {
  constructor(stream, knownCommands = null) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
    this.knownCommands = knownCommands;
    this._hexStringNumWarn = 0;
    this.beginInlineImagePos = -1;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  peekChar() {
    return this.stream.peekByte();
  }
  getNumber() {
    let ch = this.currentChar;
    let eNotation = false;
    let divideBy = 0;
    let sign = 0;
    if (ch === /* '-' = */
    45) {
      sign = -1;
      ch = this.nextChar();
      if (ch === /* '-' = */
      45) {
        ch = this.nextChar();
      }
    } else if (ch === /* '+' = */
    43) {
      sign = 1;
      ch = this.nextChar();
    }
    if (ch === /* LF = */
    10 || ch === /* CR = */
    13) {
      do {
        ch = this.nextChar();
      } while (ch === 10 || ch === 13);
    }
    if (ch === /* '.' = */
    46) {
      divideBy = 10;
      ch = this.nextChar();
    }
    if (ch < /* '0' = */
    48 || ch > /* '9' = */
    57) {
      if (divideBy === 10 && sign === 0 && (isWhiteSpace(ch) || ch === /* EOF = */
      -1)) {
        warn("Lexer.getNumber - treating a single decimal point as zero.");
        return 0;
      }
      throw new FormatError(`Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`);
    }
    sign = sign || 1;
    let baseValue = ch - 48;
    let powerValue = 0;
    let powerValueSign = 1;
    while ((ch = this.nextChar()) >= 0) {
      if (ch >= /* '0' = */
      48 && ch <= /* '9' = */
      57) {
        const currentDigit = ch - 48;
        if (eNotation) {
          powerValue = powerValue * 10 + currentDigit;
        } else {
          if (divideBy !== 0) {
            divideBy *= 10;
          }
          baseValue = baseValue * 10 + currentDigit;
        }
      } else if (ch === /* '.' = */
      46) {
        if (divideBy === 0) {
          divideBy = 1;
        } else {
          break;
        }
      } else if (ch === /* '-' = */
      45) {
        warn("Badly formatted number: minus sign in the middle");
      } else if (ch === /* 'E' = */
      69 || ch === /* 'e' = */
      101) {
        ch = this.peekChar();
        if (ch === /* '+' = */
        43 || ch === /* '-' = */
        45) {
          powerValueSign = ch === 45 ? -1 : 1;
          this.nextChar();
        } else if (ch < /* '0' = */
        48 || ch > /* '9' = */
        57) {
          break;
        }
        eNotation = true;
      } else {
        break;
      }
    }
    if (divideBy !== 0) {
      baseValue /= divideBy;
    }
    if (eNotation) {
      baseValue *= 10 ** (powerValueSign * powerValue);
    }
    return sign * baseValue;
  }
  getString() {
    let numParen = 1;
    let done = false;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    let ch = this.nextChar();
    while (true) {
      let charBuffered = false;
      switch (ch | 0) {
        case -1:
          warn("Unterminated string");
          done = true;
          break;
        case 40:
          ++numParen;
          strBuf.push("(");
          break;
        case 41:
          if (--numParen === 0) {
            this.nextChar();
            done = true;
          } else {
            strBuf.push(")");
          }
          break;
        case 92:
          ch = this.nextChar();
          switch (ch) {
            case -1:
              warn("Unterminated string");
              done = true;
              break;
            case 110:
              strBuf.push("\n");
              break;
            case 114:
              strBuf.push("\r");
              break;
            case 116:
              strBuf.push("	");
              break;
            case 98:
              strBuf.push("\b");
              break;
            case 102:
              strBuf.push("\f");
              break;
            case 92:
            case 40:
            case 41:
              strBuf.push(String.fromCharCode(ch));
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
              let x = ch & 15;
              ch = this.nextChar();
              charBuffered = true;
              if (ch >= /* '0' = */
              48 && ch <= /* '7' = */
              55) {
                x = (x << 3) + (ch & 15);
                ch = this.nextChar();
                if (ch >= /* '0' = */
                48 && ch <= 55) {
                  charBuffered = false;
                  x = (x << 3) + (ch & 15);
                }
              }
              strBuf.push(String.fromCharCode(x));
              break;
            case 13:
              if (this.peekChar() === /* LF = */
              10) {
                this.nextChar();
              }
              break;
            case 10:
              break;
            default:
              strBuf.push(String.fromCharCode(ch));
              break;
          }
          break;
        default:
          strBuf.push(String.fromCharCode(ch));
          break;
      }
      if (done) {
        break;
      }
      if (!charBuffered) {
        ch = this.nextChar();
      }
    }
    return strBuf.join("");
  }
  getName() {
    let ch, previousCh;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
      if (ch === /* '#' = */
      35) {
        ch = this.nextChar();
        if (specialChars[ch]) {
          warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
          strBuf.push("#");
          break;
        }
        const x = toHexDigit(ch);
        if (x !== -1) {
          previousCh = ch;
          ch = this.nextChar();
          const x2 = toHexDigit(ch);
          if (x2 === -1) {
            warn(`Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) in hexadecimal number.`);
            strBuf.push("#", String.fromCharCode(previousCh));
            if (specialChars[ch]) {
              break;
            }
            strBuf.push(String.fromCharCode(ch));
            continue;
          }
          strBuf.push(String.fromCharCode(x << 4 | x2));
        } else {
          strBuf.push("#", String.fromCharCode(ch));
        }
      } else {
        strBuf.push(String.fromCharCode(ch));
      }
    }
    if (strBuf.length > 127) {
      warn(`Name token is longer than allowed by the spec: ${strBuf.length}`);
    } else if (strBuf.length === 0) {
      warn("Name token is empty.");
    }
    return Name.get(strBuf.join(""));
  }
  /**
   * @private
   */
  _hexStringWarn(ch) {
    const MAX_HEX_STRING_NUM_WARN = 5;
    if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
      warn("getHexString - ignoring additional invalid characters.");
      return;
    }
    if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
      return;
    }
    warn(`getHexString - ignoring invalid character: ${ch}`);
  }
  getHexString() {
    const strBuf = this.strBuf;
    strBuf.length = 0;
    let ch = this.currentChar;
    let isFirstHex = true;
    let firstDigit, secondDigit;
    this._hexStringNumWarn = 0;
    while (true) {
      if (ch < 0) {
        warn("Unterminated hex string");
        break;
      } else if (ch === /* '>' = */
      62) {
        this.nextChar();
        break;
      } else if (specialChars[ch] === 1) {
        ch = this.nextChar();
        continue;
      } else {
        if (isFirstHex) {
          firstDigit = toHexDigit(ch);
          if (firstDigit === -1) {
            this._hexStringWarn(ch);
            ch = this.nextChar();
            continue;
          }
        } else {
          secondDigit = toHexDigit(ch);
          if (secondDigit === -1) {
            this._hexStringWarn(ch);
            ch = this.nextChar();
            continue;
          }
          strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
        }
        isFirstHex = !isFirstHex;
        ch = this.nextChar();
      }
    }
    return strBuf.join("");
  }
  getObj() {
    let comment = false;
    let ch = this.currentChar;
    while (true) {
      if (ch < 0) {
        return EOF;
      }
      if (comment) {
        if (ch === /* LF = */
        10 || ch === /* CR = */
        13) {
          comment = false;
        }
      } else if (ch === /* '%' = */
      37) {
        comment = true;
      } else if (specialChars[ch] !== 1) {
        break;
      }
      ch = this.nextChar();
    }
    switch (ch | 0) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return this.getNumber();
      case 40:
        return this.getString();
      case 47:
        return this.getName();
      case 91:
        this.nextChar();
        return Cmd.get("[");
      case 93:
        this.nextChar();
        return Cmd.get("]");
      case 60:
        ch = this.nextChar();
        if (ch === 60) {
          this.nextChar();
          return Cmd.get("<<");
        }
        return this.getHexString();
      case 62:
        ch = this.nextChar();
        if (ch === 62) {
          this.nextChar();
          return Cmd.get(">>");
        }
        return Cmd.get(">");
      case 123:
        this.nextChar();
        return Cmd.get("{");
      case 125:
        this.nextChar();
        return Cmd.get("}");
      case 41:
        this.nextChar();
        throw new FormatError(`Illegal character: ${ch}`);
    }
    let str = String.fromCharCode(ch);
    const knownCommands = this.knownCommands;
    let knownCommandFound = knownCommands && knownCommands[str] !== void 0;
    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
      const possibleCommand = str + String.fromCharCode(ch);
      if (knownCommandFound && knownCommands[possibleCommand] === void 0) {
        break;
      }
      if (str.length === 128) {
        throw new FormatError(`Command token too long: ${str.length}`);
      }
      str = possibleCommand;
      knownCommandFound = knownCommands && knownCommands[str] !== void 0;
    }
    if (str === "true") {
      return true;
    }
    if (str === "false") {
      return false;
    }
    if (str === "null") {
      return null;
    }
    if (str === "BI") {
      this.beginInlineImagePos = this.stream.pos;
    }
    return Cmd.get(str);
  }
  peekObj() {
    const streamPos = this.stream.pos, currentChar = this.currentChar, beginInlineImagePos = this.beginInlineImagePos;
    let nextObj;
    try {
      nextObj = this.getObj();
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn(`peekObj: ${ex}`);
    }
    this.stream.pos = streamPos;
    this.currentChar = currentChar;
    this.beginInlineImagePos = beginInlineImagePos;
    return nextObj;
  }
  skipToNextLine() {
    let ch = this.currentChar;
    while (ch >= 0) {
      if (ch === /* CR = */
      13) {
        ch = this.nextChar();
        if (ch === /* LF = */
        10) {
          this.nextChar();
        }
        break;
      } else if (ch === /* LF = */
      10) {
        this.nextChar();
        break;
      }
      ch = this.nextChar();
    }
  }
};
var Linearization = class {
  static create(stream) {
    function getInt(linDict2, name, allowZeroValue = false) {
      const obj4 = linDict2.get(name);
      if (Number.isInteger(obj4) && (allowZeroValue ? obj4 >= 0 : obj4 > 0)) {
        return obj4;
      }
      throw new Error(`The "${name}" parameter in the linearization dictionary is invalid.`);
    }
    function getHints(linDict2) {
      const hints = linDict2.get("H");
      let hintsLength;
      if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
        for (let index = 0; index < hintsLength; index++) {
          const hint = hints[index];
          if (!(Number.isInteger(hint) && hint > 0)) {
            throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`);
          }
        }
        return hints;
      }
      throw new Error("Hint array in the linearization dictionary is invalid.");
    }
    const parser = new Parser({
      lexer: new Lexer(stream),
      xref: null
    });
    const obj1 = parser.getObj();
    const obj2 = parser.getObj();
    const obj3 = parser.getObj();
    const linDict = parser.getObj();
    let obj, length;
    if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && isCmd(obj3, "obj") && isDict(linDict) && isNum(obj = linDict.get("Linearized")) && obj > 0)) {
      return null;
    } else if ((length = getInt(linDict, "L")) !== stream.length) {
      throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
    }
    return {
      length,
      hints: getHints(linDict),
      objectNumberFirst: getInt(linDict, "O"),
      endFirst: getInt(linDict, "E"),
      numPages: getInt(linDict, "N"),
      mainXRefEntriesOffset: getInt(linDict, "T"),
      pageFirst: linDict.has("P") ? getInt(
        linDict,
        "P",
        /* allowZeroValue = */
        true
      ) : 0
    };
  }
};
var BUILT_IN_CMAPS = [
  // << Start unicode maps.
  "Adobe-GB1-UCS2",
  "Adobe-CNS1-UCS2",
  "Adobe-Japan1-UCS2",
  "Adobe-Korea1-UCS2",
  // >> End unicode maps.
  "78-EUC-H",
  "78-EUC-V",
  "78-H",
  "78-RKSJ-H",
  "78-RKSJ-V",
  "78-V",
  "78ms-RKSJ-H",
  "78ms-RKSJ-V",
  "83pv-RKSJ-H",
  "90ms-RKSJ-H",
  "90ms-RKSJ-V",
  "90msp-RKSJ-H",
  "90msp-RKSJ-V",
  "90pv-RKSJ-H",
  "90pv-RKSJ-V",
  "Add-H",
  "Add-RKSJ-H",
  "Add-RKSJ-V",
  "Add-V",
  "Adobe-CNS1-0",
  "Adobe-CNS1-1",
  "Adobe-CNS1-2",
  "Adobe-CNS1-3",
  "Adobe-CNS1-4",
  "Adobe-CNS1-5",
  "Adobe-CNS1-6",
  "Adobe-GB1-0",
  "Adobe-GB1-1",
  "Adobe-GB1-2",
  "Adobe-GB1-3",
  "Adobe-GB1-4",
  "Adobe-GB1-5",
  "Adobe-Japan1-0",
  "Adobe-Japan1-1",
  "Adobe-Japan1-2",
  "Adobe-Japan1-3",
  "Adobe-Japan1-4",
  "Adobe-Japan1-5",
  "Adobe-Japan1-6",
  "Adobe-Korea1-0",
  "Adobe-Korea1-1",
  "Adobe-Korea1-2",
  "B5-H",
  "B5-V",
  "B5pc-H",
  "B5pc-V",
  "CNS-EUC-H",
  "CNS-EUC-V",
  "CNS1-H",
  "CNS1-V",
  "CNS2-H",
  "CNS2-V",
  "ETHK-B5-H",
  "ETHK-B5-V",
  "ETen-B5-H",
  "ETen-B5-V",
  "ETenms-B5-H",
  "ETenms-B5-V",
  "EUC-H",
  "EUC-V",
  "Ext-H",
  "Ext-RKSJ-H",
  "Ext-RKSJ-V",
  "Ext-V",
  "GB-EUC-H",
  "GB-EUC-V",
  "GB-H",
  "GB-V",
  "GBK-EUC-H",
  "GBK-EUC-V",
  "GBK2K-H",
  "GBK2K-V",
  "GBKp-EUC-H",
  "GBKp-EUC-V",
  "GBT-EUC-H",
  "GBT-EUC-V",
  "GBT-H",
  "GBT-V",
  "GBTpc-EUC-H",
  "GBTpc-EUC-V",
  "GBpc-EUC-H",
  "GBpc-EUC-V",
  "H",
  "HKdla-B5-H",
  "HKdla-B5-V",
  "HKdlb-B5-H",
  "HKdlb-B5-V",
  "HKgccs-B5-H",
  "HKgccs-B5-V",
  "HKm314-B5-H",
  "HKm314-B5-V",
  "HKm471-B5-H",
  "HKm471-B5-V",
  "HKscs-B5-H",
  "HKscs-B5-V",
  "Hankaku",
  "Hiragana",
  "KSC-EUC-H",
  "KSC-EUC-V",
  "KSC-H",
  "KSC-Johab-H",
  "KSC-Johab-V",
  "KSC-V",
  "KSCms-UHC-H",
  "KSCms-UHC-HW-H",
  "KSCms-UHC-HW-V",
  "KSCms-UHC-V",
  "KSCpc-EUC-H",
  "KSCpc-EUC-V",
  "Katakana",
  "NWP-H",
  "NWP-V",
  "RKSJ-H",
  "RKSJ-V",
  "Roman",
  "UniCNS-UCS2-H",
  "UniCNS-UCS2-V",
  "UniCNS-UTF16-H",
  "UniCNS-UTF16-V",
  "UniCNS-UTF32-H",
  "UniCNS-UTF32-V",
  "UniCNS-UTF8-H",
  "UniCNS-UTF8-V",
  "UniGB-UCS2-H",
  "UniGB-UCS2-V",
  "UniGB-UTF16-H",
  "UniGB-UTF16-V",
  "UniGB-UTF32-H",
  "UniGB-UTF32-V",
  "UniGB-UTF8-H",
  "UniGB-UTF8-V",
  "UniJIS-UCS2-H",
  "UniJIS-UCS2-HW-H",
  "UniJIS-UCS2-HW-V",
  "UniJIS-UCS2-V",
  "UniJIS-UTF16-H",
  "UniJIS-UTF16-V",
  "UniJIS-UTF32-H",
  "UniJIS-UTF32-V",
  "UniJIS-UTF8-H",
  "UniJIS-UTF8-V",
  "UniJIS2004-UTF16-H",
  "UniJIS2004-UTF16-V",
  "UniJIS2004-UTF32-H",
  "UniJIS2004-UTF32-V",
  "UniJIS2004-UTF8-H",
  "UniJIS2004-UTF8-V",
  "UniJISPro-UCS2-HW-V",
  "UniJISPro-UCS2-V",
  "UniJISPro-UTF8-V",
  "UniJISX0213-UTF32-H",
  "UniJISX0213-UTF32-V",
  "UniJISX02132004-UTF32-H",
  "UniJISX02132004-UTF32-V",
  "UniKS-UCS2-H",
  "UniKS-UCS2-V",
  "UniKS-UTF16-H",
  "UniKS-UTF16-V",
  "UniKS-UTF32-H",
  "UniKS-UTF32-V",
  "UniKS-UTF8-H",
  "UniKS-UTF8-V",
  "V",
  "WP-Symbol"
];
var MAX_MAP_RANGE = 2 ** 24 - 1;
var CMap = class {
  constructor(builtInCMap = false) {
    this.codespaceRanges = [[], [], [], []];
    this.numCodespaceRanges = 0;
    this._map = [];
    this.name = "";
    this.vertical = false;
    this.useCMap = null;
    this.builtInCMap = builtInCMap;
  }
  addCodespaceRange(n, low, high) {
    this.codespaceRanges[n - 1].push(low, high);
    this.numCodespaceRanges++;
  }
  mapCidRange(low, high, dstLow) {
    if (high - low > MAX_MAP_RANGE) {
      throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    }
    while (low <= high) {
      this._map[low++] = dstLow++;
    }
  }
  mapBfRange(low, high, dstLow) {
    if (high - low > MAX_MAP_RANGE) {
      throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    }
    const lastByte = dstLow.length - 1;
    while (low <= high) {
      this._map[low++] = dstLow;
      dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(dstLow.charCodeAt(lastByte) + 1);
    }
  }
  mapBfRangeToArray(low, high, array) {
    if (high - low > MAX_MAP_RANGE) {
      throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    }
    const ii = array.length;
    let i = 0;
    while (low <= high && i < ii) {
      this._map[low] = array[i++];
      ++low;
    }
  }
  // This is used for both bf and cid chars.
  mapOne(src, dst) {
    this._map[src] = dst;
  }
  lookup(code) {
    return this._map[code];
  }
  contains(code) {
    return this._map[code] !== void 0;
  }
  forEach(callback) {
    const map = this._map;
    const length = map.length;
    if (length <= 65536) {
      for (let i = 0; i < length; i++) {
        if (map[i] !== void 0) {
          callback(i, map[i]);
        }
      }
    } else {
      for (const i in map) {
        callback(i, map[i]);
      }
    }
  }
  charCodeOf(value) {
    const map = this._map;
    if (map.length <= 65536) {
      return map.indexOf(value);
    }
    for (const charCode in map) {
      if (map[charCode] === value) {
        return charCode | 0;
      }
    }
    return -1;
  }
  getMap() {
    return this._map;
  }
  readCharCode(str, offset, out) {
    let c = 0;
    const codespaceRanges = this.codespaceRanges;
    for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
      c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
      const codespaceRange = codespaceRanges[n];
      for (let k = 0, kk = codespaceRange.length; k < kk; ) {
        const low = codespaceRange[k++];
        const high = codespaceRange[k++];
        if (c >= low && c <= high) {
          out.charcode = c;
          out.length = n + 1;
          return;
        }
      }
    }
    out.charcode = 0;
    out.length = 1;
  }
  getCharCodeLength(charCode) {
    const codespaceRanges = this.codespaceRanges;
    for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
      const codespaceRange = codespaceRanges[n];
      for (let k = 0, kk = codespaceRange.length; k < kk; ) {
        const low = codespaceRange[k++];
        const high = codespaceRange[k++];
        if (charCode >= low && charCode <= high) {
          return n + 1;
        }
      }
    }
    return 1;
  }
  get length() {
    return this._map.length;
  }
  get isIdentityCMap() {
    if (!(this.name === "Identity-H" || this.name === "Identity-V")) {
      return false;
    }
    if (this._map.length !== 65536) {
      return false;
    }
    for (let i = 0; i < 65536; i++) {
      if (this._map[i] !== i) {
        return false;
      }
    }
    return true;
  }
};
var IdentityCMap = class extends CMap {
  constructor(vertical, n) {
    super();
    this.vertical = vertical;
    this.addCodespaceRange(n, 0, 65535);
  }
  mapCidRange(low, high, dstLow) {
    unreachable("should not call mapCidRange");
  }
  mapBfRange(low, high, dstLow) {
    unreachable("should not call mapBfRange");
  }
  mapBfRangeToArray(low, high, array) {
    unreachable("should not call mapBfRangeToArray");
  }
  mapOne(src, dst) {
    unreachable("should not call mapCidOne");
  }
  lookup(code) {
    return Number.isInteger(code) && code <= 65535 ? code : void 0;
  }
  contains(code) {
    return Number.isInteger(code) && code <= 65535;
  }
  forEach(callback) {
    for (let i = 0; i <= 65535; i++) {
      callback(i, i);
    }
  }
  charCodeOf(value) {
    return Number.isInteger(value) && value <= 65535 ? value : -1;
  }
  getMap() {
    const map = new Array(65536);
    for (let i = 0; i <= 65535; i++) {
      map[i] = i;
    }
    return map;
  }
  get length() {
    return 65536;
  }
  // eslint-disable-next-line getter-return
  get isIdentityCMap() {
    unreachable("should not access .isIdentityCMap");
  }
};
var BinaryCMapReader = /* @__PURE__ */ function BinaryCMapReaderClosure() {
  function hexToInt(a, size) {
    let n = 0;
    for (let i = 0; i <= size; i++) {
      n = n << 8 | a[i];
    }
    return n >>> 0;
  }
  function hexToStr(a, size) {
    if (size === 1) {
      return String.fromCharCode(a[0], a[1]);
    }
    if (size === 3) {
      return String.fromCharCode(a[0], a[1], a[2], a[3]);
    }
    return String.fromCharCode.apply(null, a.subarray(0, size + 1));
  }
  function addHex(a, b, size) {
    let c = 0;
    for (let i = size; i >= 0; i--) {
      c += a[i] + b[i];
      a[i] = c & 255;
      c >>= 8;
    }
  }
  function incHex(a, size) {
    let c = 1;
    for (let i = size; i >= 0 && c > 0; i--) {
      c += a[i];
      a[i] = c & 255;
      c >>= 8;
    }
  }
  const MAX_NUM_SIZE = 16;
  const MAX_ENCODED_NUM_SIZE = 19;
  class BinaryCMapStream {
    constructor(data) {
      this.buffer = data;
      this.pos = 0;
      this.end = data.length;
      this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
    }
    readByte() {
      if (this.pos >= this.end) {
        return -1;
      }
      return this.buffer[this.pos++];
    }
    readNumber() {
      let n = 0;
      let last;
      do {
        const b = this.readByte();
        if (b < 0) {
          throw new FormatError("unexpected EOF in bcmap");
        }
        last = !(b & 128);
        n = n << 7 | b & 127;
      } while (!last);
      return n;
    }
    readSigned() {
      const n = this.readNumber();
      return n & 1 ? ~(n >>> 1) : n >>> 1;
    }
    readHex(num, size) {
      num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
      this.pos += size + 1;
    }
    readHexNumber(num, size) {
      let last;
      const stack = this.tmpBuf;
      let sp = 0;
      do {
        const b = this.readByte();
        if (b < 0) {
          throw new FormatError("unexpected EOF in bcmap");
        }
        last = !(b & 128);
        stack[sp++] = b & 127;
      } while (!last);
      let i = size, buffer = 0, bufferSize = 0;
      while (i >= 0) {
        while (bufferSize < 8 && stack.length > 0) {
          buffer |= stack[--sp] << bufferSize;
          bufferSize += 7;
        }
        num[i] = buffer & 255;
        i--;
        buffer >>= 8;
        bufferSize -= 8;
      }
    }
    readHexSigned(num, size) {
      this.readHexNumber(num, size);
      const sign = num[size] & 1 ? 255 : 0;
      let c = 0;
      for (let i = 0; i <= size; i++) {
        c = (c & 1) << 8 | num[i];
        num[i] = c >> 1 ^ sign;
      }
    }
    readString() {
      const len = this.readNumber();
      let s = "";
      for (let i = 0; i < len; i++) {
        s += String.fromCharCode(this.readNumber());
      }
      return s;
    }
  }
  class BinaryCMapReader2 {
    async process(data, cMap, extend) {
      const stream = new BinaryCMapStream(data);
      const header = stream.readByte();
      cMap.vertical = !!(header & 1);
      let useCMap = null;
      const start = new Uint8Array(MAX_NUM_SIZE);
      const end = new Uint8Array(MAX_NUM_SIZE);
      const char = new Uint8Array(MAX_NUM_SIZE);
      const charCode = new Uint8Array(MAX_NUM_SIZE);
      const tmp = new Uint8Array(MAX_NUM_SIZE);
      let code;
      let b;
      while ((b = stream.readByte()) >= 0) {
        const type = b >> 5;
        if (type === 7) {
          switch (b & 31) {
            case 0:
              stream.readString();
              break;
            case 1:
              useCMap = stream.readString();
              break;
          }
          continue;
        }
        const sequence = !!(b & 16);
        const dataSize = b & 15;
        if (dataSize + 1 > MAX_NUM_SIZE) {
          throw new Error("BinaryCMapReader.process: Invalid dataSize.");
        }
        const ucs2DataSize = 1;
        const subitemsCount = stream.readNumber();
        switch (type) {
          case 0:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
            for (let i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              stream.readHexNumber(start, dataSize);
              addHex(start, end, dataSize);
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
            }
            break;
          case 1:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            stream.readNumber();
            for (let i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              stream.readHexNumber(start, dataSize);
              addHex(start, end, dataSize);
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              stream.readNumber();
            }
            break;
          case 2:
            stream.readHex(char, dataSize);
            code = stream.readNumber();
            cMap.mapOne(hexToInt(char, dataSize), code);
            for (let i = 1; i < subitemsCount; i++) {
              incHex(char, dataSize);
              if (!sequence) {
                stream.readHexNumber(tmp, dataSize);
                addHex(char, tmp, dataSize);
              }
              code = stream.readSigned() + (code + 1);
              cMap.mapOne(hexToInt(char, dataSize), code);
            }
            break;
          case 3:
            stream.readHex(start, dataSize);
            stream.readHexNumber(end, dataSize);
            addHex(end, start, dataSize);
            code = stream.readNumber();
            cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
            for (let i = 1; i < subitemsCount; i++) {
              incHex(end, dataSize);
              if (!sequence) {
                stream.readHexNumber(start, dataSize);
                addHex(start, end, dataSize);
              } else {
                start.set(end);
              }
              stream.readHexNumber(end, dataSize);
              addHex(end, start, dataSize);
              code = stream.readNumber();
              cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
            }
            break;
          case 4:
            stream.readHex(char, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
            for (let i = 1; i < subitemsCount; i++) {
              incHex(char, ucs2DataSize);
              if (!sequence) {
                stream.readHexNumber(tmp, ucs2DataSize);
                addHex(char, tmp, ucs2DataSize);
              }
              incHex(charCode, dataSize);
              stream.readHexSigned(tmp, dataSize);
              addHex(charCode, tmp, dataSize);
              cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
            }
            break;
          case 5:
            stream.readHex(start, ucs2DataSize);
            stream.readHexNumber(end, ucs2DataSize);
            addHex(end, start, ucs2DataSize);
            stream.readHex(charCode, dataSize);
            cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
            for (let i = 1; i < subitemsCount; i++) {
              incHex(end, ucs2DataSize);
              if (!sequence) {
                stream.readHexNumber(start, ucs2DataSize);
                addHex(start, end, ucs2DataSize);
              } else {
                start.set(end);
              }
              stream.readHexNumber(end, ucs2DataSize);
              addHex(end, start, ucs2DataSize);
              stream.readHex(charCode, dataSize);
              cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
            }
            break;
          default:
            throw new Error(`BinaryCMapReader.process - unknown type: ${type}`);
        }
      }
      if (useCMap) {
        return extend(useCMap);
      }
      return cMap;
    }
  }
  return BinaryCMapReader2;
}();
var CMapFactory = /* @__PURE__ */ function CMapFactoryClosure() {
  function strToInt(str) {
    let a = 0;
    for (let i = 0; i < str.length; i++) {
      a = a << 8 | str.charCodeAt(i);
    }
    return a >>> 0;
  }
  function expectString(obj) {
    if (!isString(obj)) {
      throw new FormatError("Malformed CMap: expected string.");
    }
  }
  function expectInt(obj) {
    if (!Number.isInteger(obj)) {
      throw new FormatError("Malformed CMap: expected int.");
    }
  }
  function parseBfChar(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, "endbfchar")) {
        return;
      }
      expectString(obj);
      const src = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      const dst = obj;
      cMap.mapOne(src, dst);
    }
  }
  function parseBfRange(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, "endbfrange")) {
        return;
      }
      expectString(obj);
      const low = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      const high = strToInt(obj);
      obj = lexer.getObj();
      if (Number.isInteger(obj) || isString(obj)) {
        const dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
        cMap.mapBfRange(low, high, dstLow);
      } else if (isCmd(obj, "[")) {
        obj = lexer.getObj();
        const array = [];
        while (!isCmd(obj, "]") && !isEOF(obj)) {
          array.push(obj);
          obj = lexer.getObj();
        }
        cMap.mapBfRangeToArray(low, high, array);
      } else {
        break;
      }
    }
    throw new FormatError("Invalid bf range.");
  }
  function parseCidChar(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, "endcidchar")) {
        return;
      }
      expectString(obj);
      const src = strToInt(obj);
      obj = lexer.getObj();
      expectInt(obj);
      const dst = obj;
      cMap.mapOne(src, dst);
    }
  }
  function parseCidRange(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, "endcidrange")) {
        return;
      }
      expectString(obj);
      const low = strToInt(obj);
      obj = lexer.getObj();
      expectString(obj);
      const high = strToInt(obj);
      obj = lexer.getObj();
      expectInt(obj);
      const dstLow = obj;
      cMap.mapCidRange(low, high, dstLow);
    }
  }
  function parseCodespaceRange(cMap, lexer) {
    while (true) {
      let obj = lexer.getObj();
      if (isEOF(obj)) {
        break;
      }
      if (isCmd(obj, "endcodespacerange")) {
        return;
      }
      if (!isString(obj)) {
        break;
      }
      const low = strToInt(obj);
      obj = lexer.getObj();
      if (!isString(obj)) {
        break;
      }
      const high = strToInt(obj);
      cMap.addCodespaceRange(obj.length, low, high);
    }
    throw new FormatError("Invalid codespace range.");
  }
  function parseWMode(cMap, lexer) {
    const obj = lexer.getObj();
    if (Number.isInteger(obj)) {
      cMap.vertical = !!obj;
    }
  }
  function parseCMapName(cMap, lexer) {
    const obj = lexer.getObj();
    if (isName(obj) && isString(obj.name)) {
      cMap.name = obj.name;
    }
  }
  async function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
    let previous, embeddedUseCMap;
    objLoop:
      while (true) {
        try {
          const obj = lexer.getObj();
          if (isEOF(obj)) {
            break;
          } else if (isName(obj)) {
            if (obj.name === "WMode") {
              parseWMode(cMap, lexer);
            } else if (obj.name === "CMapName") {
              parseCMapName(cMap, lexer);
            }
            previous = obj;
          } else if (isCmd(obj)) {
            switch (obj.cmd) {
              case "endcmap":
                break objLoop;
              case "usecmap":
                if (isName(previous)) {
                  embeddedUseCMap = previous.name;
                }
                break;
              case "begincodespacerange":
                parseCodespaceRange(cMap, lexer);
                break;
              case "beginbfchar":
                parseBfChar(cMap, lexer);
                break;
              case "begincidchar":
                parseCidChar(cMap, lexer);
                break;
              case "beginbfrange":
                parseBfRange(cMap, lexer);
                break;
              case "begincidrange":
                parseCidRange(cMap, lexer);
                break;
            }
          }
        } catch (ex) {
          if (ex instanceof MissingDataException) {
            throw ex;
          }
          warn("Invalid cMap data: " + ex);
          continue;
        }
      }
    if (!useCMap && embeddedUseCMap) {
      useCMap = embeddedUseCMap;
    }
    if (useCMap) {
      return extendCMap(cMap, fetchBuiltInCMap, useCMap);
    }
    return cMap;
  }
  async function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
    cMap.useCMap = await createBuiltInCMap(useCMap, fetchBuiltInCMap);
    if (cMap.numCodespaceRanges === 0) {
      const useCodespaceRanges = cMap.useCMap.codespaceRanges;
      for (let i = 0; i < useCodespaceRanges.length; i++) {
        cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
      }
      cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
    }
    cMap.useCMap.forEach(function(key, value) {
      if (!cMap.contains(key)) {
        cMap.mapOne(key, cMap.useCMap.lookup(key));
      }
    });
    return cMap;
  }
  async function createBuiltInCMap(name, fetchBuiltInCMap) {
    if (name === "Identity-H") {
      return new IdentityCMap(false, 2);
    } else if (name === "Identity-V") {
      return new IdentityCMap(true, 2);
    }
    if (!BUILT_IN_CMAPS.includes(name)) {
      throw new Error("Unknown CMap name: " + name);
    }
    if (!fetchBuiltInCMap) {
      throw new Error("Built-in CMap parameters are not provided.");
    }
    const {
      cMapData,
      compressionType
    } = await fetchBuiltInCMap(name);
    const cMap = new CMap(true);
    if (compressionType === CMapCompressionType.BINARY) {
      return new BinaryCMapReader().process(cMapData, cMap, (useCMap) => {
        return extendCMap(cMap, fetchBuiltInCMap, useCMap);
      });
    }
    if (compressionType === CMapCompressionType.NONE) {
      const lexer = new Lexer(new Stream(cMapData));
      return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
    }
    throw new Error("TODO: Only BINARY/NONE CMap compression is currently supported.");
  }
  return {
    async create(params) {
      const encoding = params.encoding;
      const fetchBuiltInCMap = params.fetchBuiltInCMap;
      const useCMap = params.useCMap;
      if (isName(encoding)) {
        return createBuiltInCMap(encoding.name, fetchBuiltInCMap);
      } else if (isStream(encoding)) {
        const parsedCMap = await parseCMap(
          /* cMap = */
          new CMap(),
          /* lexer = */
          new Lexer(encoding),
          fetchBuiltInCMap,
          useCMap
        );
        if (parsedCMap.isIdentityCMap) {
          return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
        }
        return parsedCMap;
      }
      throw new Error("Encoding required.");
    }
  };
}();
var ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
var ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
var ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
var MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
var StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
var WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
var SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
var ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
function getEncoding(encodingName) {
  switch (encodingName) {
    case "WinAnsiEncoding":
      return WinAnsiEncoding;
    case "StandardEncoding":
      return StandardEncoding;
    case "MacRomanEncoding":
      return MacRomanEncoding;
    case "SymbolSetEncoding":
      return SymbolSetEncoding;
    case "ZapfDingbatsEncoding":
      return ZapfDingbatsEncoding;
    case "ExpertEncoding":
      return ExpertEncoding;
    case "MacExpertEncoding":
      return MacExpertEncoding;
    default:
      return null;
  }
}
var MAX_SUBR_NESTING = 10;
var CFFStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
var NUM_STANDARD_CFF_STRINGS = 391;
var CFFParser = /* @__PURE__ */ function CFFParserClosure() {
  const CharstringValidationData = [
    null,
    {
      id: "hstem",
      min: 2,
      stackClearing: true,
      stem: true
    },
    null,
    {
      id: "vstem",
      min: 2,
      stackClearing: true,
      stem: true
    },
    {
      id: "vmoveto",
      min: 1,
      stackClearing: true
    },
    {
      id: "rlineto",
      min: 2,
      resetStack: true
    },
    {
      id: "hlineto",
      min: 1,
      resetStack: true
    },
    {
      id: "vlineto",
      min: 1,
      resetStack: true
    },
    {
      id: "rrcurveto",
      min: 6,
      resetStack: true
    },
    null,
    {
      id: "callsubr",
      min: 1,
      undefStack: true
    },
    {
      id: "return",
      min: 0,
      undefStack: true
    },
    null,
    // 12
    null,
    {
      id: "endchar",
      min: 0,
      stackClearing: true
    },
    null,
    null,
    null,
    {
      id: "hstemhm",
      min: 2,
      stackClearing: true,
      stem: true
    },
    {
      id: "hintmask",
      min: 0,
      stackClearing: true
    },
    {
      id: "cntrmask",
      min: 0,
      stackClearing: true
    },
    {
      id: "rmoveto",
      min: 2,
      stackClearing: true
    },
    {
      id: "hmoveto",
      min: 1,
      stackClearing: true
    },
    {
      id: "vstemhm",
      min: 2,
      stackClearing: true,
      stem: true
    },
    {
      id: "rcurveline",
      min: 8,
      resetStack: true
    },
    {
      id: "rlinecurve",
      min: 8,
      resetStack: true
    },
    {
      id: "vvcurveto",
      min: 4,
      resetStack: true
    },
    {
      id: "hhcurveto",
      min: 4,
      resetStack: true
    },
    null,
    // shortint
    {
      id: "callgsubr",
      min: 1,
      undefStack: true
    },
    {
      id: "vhcurveto",
      min: 4,
      resetStack: true
    },
    {
      id: "hvcurveto",
      min: 4,
      resetStack: true
    }
  ];
  const CharstringValidationData12 = [null, null, null, {
    id: "and",
    min: 2,
    stackDelta: -1
  }, {
    id: "or",
    min: 2,
    stackDelta: -1
  }, {
    id: "not",
    min: 1,
    stackDelta: 0
  }, null, null, null, {
    id: "abs",
    min: 1,
    stackDelta: 0
  }, {
    id: "add",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] + stack[index - 1];
    }
  }, {
    id: "sub",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] - stack[index - 1];
    }
  }, {
    id: "div",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] / stack[index - 1];
    }
  }, null, {
    id: "neg",
    min: 1,
    stackDelta: 0,
    stackFn: function stack_div(stack, index) {
      stack[index - 1] = -stack[index - 1];
    }
  }, {
    id: "eq",
    min: 2,
    stackDelta: -1
  }, null, null, {
    id: "drop",
    min: 1,
    stackDelta: -1
  }, null, {
    id: "put",
    min: 2,
    stackDelta: -2
  }, {
    id: "get",
    min: 1,
    stackDelta: 0
  }, {
    id: "ifelse",
    min: 4,
    stackDelta: -3
  }, {
    id: "random",
    min: 0,
    stackDelta: 1
  }, {
    id: "mul",
    min: 2,
    stackDelta: -1,
    stackFn: function stack_div(stack, index) {
      stack[index - 2] = stack[index - 2] * stack[index - 1];
    }
  }, null, {
    id: "sqrt",
    min: 1,
    stackDelta: 0
  }, {
    id: "dup",
    min: 1,
    stackDelta: 1
  }, {
    id: "exch",
    min: 2,
    stackDelta: 0
  }, {
    id: "index",
    min: 2,
    stackDelta: 0
  }, {
    id: "roll",
    min: 3,
    stackDelta: -2
  }, null, null, null, {
    id: "hflex",
    min: 7,
    resetStack: true
  }, {
    id: "flex",
    min: 13,
    resetStack: true
  }, {
    id: "hflex1",
    min: 9,
    resetStack: true
  }, {
    id: "flex1",
    min: 11,
    resetStack: true
  }];
  class CFFParser2 {
    constructor(file, properties, seacAnalysisEnabled) {
      this.bytes = file.getBytes();
      this.properties = properties;
      this.seacAnalysisEnabled = !!seacAnalysisEnabled;
    }
    parse() {
      const properties = this.properties;
      const cff = new CFF();
      this.cff = cff;
      const header = this.parseHeader();
      const nameIndex = this.parseIndex(header.endPos);
      const topDictIndex = this.parseIndex(nameIndex.endPos);
      const stringIndex = this.parseIndex(topDictIndex.endPos);
      const globalSubrIndex = this.parseIndex(stringIndex.endPos);
      const topDictParsed = this.parseDict(topDictIndex.obj.get(0));
      const topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
      cff.header = header.obj;
      cff.names = this.parseNameIndex(nameIndex.obj);
      cff.strings = this.parseStringIndex(stringIndex.obj);
      cff.topDict = topDict;
      cff.globalSubrIndex = globalSubrIndex.obj;
      this.parsePrivateDict(cff.topDict);
      cff.isCIDFont = topDict.hasName("ROS");
      const charStringOffset = topDict.getByName("CharStrings");
      const charStringIndex = this.parseIndex(charStringOffset).obj;
      const fontMatrix = topDict.getByName("FontMatrix");
      if (fontMatrix) {
        properties.fontMatrix = fontMatrix;
      }
      const fontBBox = topDict.getByName("FontBBox");
      if (fontBBox) {
        properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
        properties.descent = Math.min(fontBBox[1], fontBBox[3]);
        properties.ascentScaled = true;
      }
      let charset, encoding;
      if (cff.isCIDFont) {
        const fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;
        for (let i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
          const dictRaw = fdArrayIndex.get(i);
          const fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
          this.parsePrivateDict(fontDict);
          cff.fdArray.push(fontDict);
        }
        encoding = null;
        charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
        cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
      } else {
        charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
        encoding = this.parseEncoding(topDict.getByName("Encoding"), properties, cff.strings, charset.charset);
      }
      cff.charset = charset;
      cff.encoding = encoding;
      const charStringsAndSeacs = this.parseCharStrings({
        charStrings: charStringIndex,
        localSubrIndex: topDict.privateDict.subrsIndex,
        globalSubrIndex: globalSubrIndex.obj,
        fdSelect: cff.fdSelect,
        fdArray: cff.fdArray,
        privateDict: topDict.privateDict
      });
      cff.charStrings = charStringsAndSeacs.charStrings;
      cff.seacs = charStringsAndSeacs.seacs;
      cff.widths = charStringsAndSeacs.widths;
      return cff;
    }
    parseHeader() {
      let bytes = this.bytes;
      const bytesLength = bytes.length;
      let offset = 0;
      while (offset < bytesLength && bytes[offset] !== 1) {
        ++offset;
      }
      if (offset >= bytesLength) {
        throw new FormatError("Invalid CFF header");
      }
      if (offset !== 0) {
        info("cff data is shifted");
        bytes = bytes.subarray(offset);
        this.bytes = bytes;
      }
      const major = bytes[0];
      const minor = bytes[1];
      const hdrSize = bytes[2];
      const offSize = bytes[3];
      const header = new CFFHeader(major, minor, hdrSize, offSize);
      return {
        obj: header,
        endPos: hdrSize
      };
    }
    parseDict(dict) {
      let pos = 0;
      function parseOperand() {
        let value = dict[pos++];
        if (value === 30) {
          return parseFloatOperand();
        } else if (value === 28) {
          value = dict[pos++];
          value = (value << 24 | dict[pos++] << 16) >> 16;
          return value;
        } else if (value === 29) {
          value = dict[pos++];
          value = value << 8 | dict[pos++];
          value = value << 8 | dict[pos++];
          value = value << 8 | dict[pos++];
          return value;
        } else if (value >= 32 && value <= 246) {
          return value - 139;
        } else if (value >= 247 && value <= 250) {
          return (value - 247) * 256 + dict[pos++] + 108;
        } else if (value >= 251 && value <= 254) {
          return -((value - 251) * 256) - dict[pos++] - 108;
        }
        warn('CFFParser_parseDict: "' + value + '" is a reserved command.');
        return NaN;
      }
      function parseFloatOperand() {
        let str = "";
        const eof = 15;
        const lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
        const length = dict.length;
        while (pos < length) {
          const b = dict[pos++];
          const b1 = b >> 4;
          const b2 = b & 15;
          if (b1 === eof) {
            break;
          }
          str += lookup[b1];
          if (b2 === eof) {
            break;
          }
          str += lookup[b2];
        }
        return parseFloat(str);
      }
      let operands = [];
      const entries = [];
      pos = 0;
      const end = dict.length;
      while (pos < end) {
        let b = dict[pos];
        if (b <= 21) {
          if (b === 12) {
            b = b << 8 | dict[++pos];
          }
          entries.push([b, operands]);
          operands = [];
          ++pos;
        } else {
          operands.push(parseOperand());
        }
      }
      return entries;
    }
    parseIndex(pos) {
      const cffIndex = new CFFIndex();
      const bytes = this.bytes;
      const count = bytes[pos++] << 8 | bytes[pos++];
      const offsets = [];
      let end = pos;
      let i, ii;
      if (count !== 0) {
        const offsetSize = bytes[pos++];
        const startPos = pos + (count + 1) * offsetSize - 1;
        for (i = 0, ii = count + 1; i < ii; ++i) {
          let offset = 0;
          for (let j = 0; j < offsetSize; ++j) {
            offset <<= 8;
            offset += bytes[pos++];
          }
          offsets.push(startPos + offset);
        }
        end = offsets[count];
      }
      for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
        const offsetStart = offsets[i];
        const offsetEnd = offsets[i + 1];
        cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
      }
      return {
        obj: cffIndex,
        endPos: end
      };
    }
    parseNameIndex(index) {
      const names = [];
      for (let i = 0, ii = index.count; i < ii; ++i) {
        const name = index.get(i);
        names.push(bytesToString(name));
      }
      return names;
    }
    parseStringIndex(index) {
      const strings = new CFFStrings();
      for (let i = 0, ii = index.count; i < ii; ++i) {
        const data = index.get(i);
        strings.add(bytesToString(data));
      }
      return strings;
    }
    createDict(Type2, dict, strings) {
      const cffDict = new Type2(strings);
      for (let i = 0, ii = dict.length; i < ii; ++i) {
        const pair = dict[i];
        const key = pair[0];
        const value = pair[1];
        cffDict.setByKey(key, value);
      }
      return cffDict;
    }
    parseCharString(state, data, localSubrIndex, globalSubrIndex) {
      if (!data || state.callDepth > MAX_SUBR_NESTING) {
        return false;
      }
      let stackSize = state.stackSize;
      const stack = state.stack;
      const length = data.length;
      for (let j = 0; j < length; ) {
        const value = data[j++];
        let validationCommand = null;
        if (value === 12) {
          const q = data[j++];
          if (q === 0) {
            data[j - 2] = 139;
            data[j - 1] = 22;
            stackSize = 0;
          } else {
            validationCommand = CharstringValidationData12[q];
          }
        } else if (value === 28) {
          stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
          j += 2;
          stackSize++;
        } else if (value === 14) {
          if (stackSize >= 4) {
            stackSize -= 4;
            if (this.seacAnalysisEnabled) {
              state.seac = stack.slice(stackSize, stackSize + 4);
              return false;
            }
          }
          validationCommand = CharstringValidationData[value];
        } else if (value >= 32 && value <= 246) {
          stack[stackSize] = value - 139;
          stackSize++;
        } else if (value >= 247 && value <= 254) {
          stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
          j++;
          stackSize++;
        } else if (value === 255) {
          stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
          j += 4;
          stackSize++;
        } else if (value === 19 || value === 20) {
          state.hints += stackSize >> 1;
          j += state.hints + 7 >> 3;
          stackSize %= 2;
          validationCommand = CharstringValidationData[value];
        } else if (value === 10 || value === 29) {
          let subrsIndex;
          if (value === 10) {
            subrsIndex = localSubrIndex;
          } else {
            subrsIndex = globalSubrIndex;
          }
          if (!subrsIndex) {
            validationCommand = CharstringValidationData[value];
            warn("Missing subrsIndex for " + validationCommand.id);
            return false;
          }
          let bias = 32768;
          if (subrsIndex.count < 1240) {
            bias = 107;
          } else if (subrsIndex.count < 33900) {
            bias = 1131;
          }
          const subrNumber = stack[--stackSize] + bias;
          if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
            validationCommand = CharstringValidationData[value];
            warn("Out of bounds subrIndex for " + validationCommand.id);
            return false;
          }
          state.stackSize = stackSize;
          state.callDepth++;
          const valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
          if (!valid) {
            return false;
          }
          state.callDepth--;
          stackSize = state.stackSize;
          continue;
        } else if (value === 11) {
          state.stackSize = stackSize;
          return true;
        } else if (value === 0 && j === data.length) {
          data[j - 1] = 14;
          validationCommand = CharstringValidationData[14];
        } else {
          validationCommand = CharstringValidationData[value];
        }
        if (validationCommand) {
          if (validationCommand.stem) {
            state.hints += stackSize >> 1;
            if (value === 3 || value === 23) {
              state.hasVStems = true;
            } else if (state.hasVStems && (value === 1 || value === 18)) {
              warn("CFF stem hints are in wrong order");
              data[j - 1] = value === 1 ? 3 : 23;
            }
          }
          if ("min" in validationCommand) {
            if (!state.undefStack && stackSize < validationCommand.min) {
              warn("Not enough parameters for " + validationCommand.id + "; actual: " + stackSize + ", expected: " + validationCommand.min);
              if (stackSize === 0) {
                data[j - 1] = 14;
                return true;
              }
              return false;
            }
          }
          if (state.firstStackClearing && validationCommand.stackClearing) {
            state.firstStackClearing = false;
            stackSize -= validationCommand.min;
            if (stackSize >= 2 && validationCommand.stem) {
              stackSize %= 2;
            } else if (stackSize > 1) {
              warn("Found too many parameters for stack-clearing command");
            }
            if (stackSize > 0) {
              state.width = stack[stackSize - 1];
            }
          }
          if ("stackDelta" in validationCommand) {
            if ("stackFn" in validationCommand) {
              validationCommand.stackFn(stack, stackSize);
            }
            stackSize += validationCommand.stackDelta;
          } else if (validationCommand.stackClearing) {
            stackSize = 0;
          } else if (validationCommand.resetStack) {
            stackSize = 0;
            state.undefStack = false;
          } else if (validationCommand.undefStack) {
            stackSize = 0;
            state.undefStack = true;
            state.firstStackClearing = false;
          }
        }
      }
      state.stackSize = stackSize;
      return true;
    }
    parseCharStrings({
      charStrings,
      localSubrIndex,
      globalSubrIndex,
      fdSelect,
      fdArray,
      privateDict
    }) {
      const seacs = [];
      const widths = [];
      const count = charStrings.count;
      for (let i = 0; i < count; i++) {
        const charstring = charStrings.get(i);
        const state = {
          callDepth: 0,
          stackSize: 0,
          stack: [],
          undefStack: true,
          hints: 0,
          firstStackClearing: true,
          seac: null,
          width: null,
          hasVStems: false
        };
        let valid = true;
        let localSubrToUse = null;
        let privateDictToUse = privateDict;
        if (fdSelect && fdArray.length) {
          const fdIndex = fdSelect.getFDIndex(i);
          if (fdIndex === -1) {
            warn("Glyph index is not in fd select.");
            valid = false;
          }
          if (fdIndex >= fdArray.length) {
            warn("Invalid fd index for glyph index.");
            valid = false;
          }
          if (valid) {
            privateDictToUse = fdArray[fdIndex].privateDict;
            localSubrToUse = privateDictToUse.subrsIndex;
          }
        } else if (localSubrIndex) {
          localSubrToUse = localSubrIndex;
        }
        if (valid) {
          valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
        }
        if (state.width !== null) {
          const nominalWidth = privateDictToUse.getByName("nominalWidthX");
          widths[i] = nominalWidth + state.width;
        } else {
          const defaultWidth = privateDictToUse.getByName("defaultWidthX");
          widths[i] = defaultWidth;
        }
        if (state.seac !== null) {
          seacs[i] = state.seac;
        }
        if (!valid) {
          charStrings.set(i, new Uint8Array([14]));
        }
      }
      return {
        charStrings,
        seacs,
        widths
      };
    }
    emptyPrivateDictionary(parentDict) {
      const privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
      parentDict.setByKey(18, [0, 0]);
      parentDict.privateDict = privateDict;
    }
    parsePrivateDict(parentDict) {
      if (!parentDict.hasName("Private")) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }
      const privateOffset = parentDict.getByName("Private");
      if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
        parentDict.removeByName("Private");
        return;
      }
      const size = privateOffset[0];
      const offset = privateOffset[1];
      if (size === 0 || offset >= this.bytes.length) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }
      const privateDictEnd = offset + size;
      const dictData = this.bytes.subarray(offset, privateDictEnd);
      const dict = this.parseDict(dictData);
      const privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
      parentDict.privateDict = privateDict;
      if (!privateDict.getByName("Subrs")) {
        return;
      }
      const subrsOffset = privateDict.getByName("Subrs");
      const relativeOffset = offset + subrsOffset;
      if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }
      const subrsIndex = this.parseIndex(relativeOffset);
      privateDict.subrsIndex = subrsIndex.obj;
    }
    parseCharsets(pos, length, strings, cid) {
      if (pos === 0) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, ISOAdobeCharset);
      } else if (pos === 1) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, ExpertCharset);
      } else if (pos === 2) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, ExpertSubsetCharset);
      }
      const bytes = this.bytes;
      const start = pos;
      const format = bytes[pos++];
      const charset = [cid ? 0 : ".notdef"];
      let id, count, i;
      length -= 1;
      switch (format) {
        case 0:
          for (i = 0; i < length; i++) {
            id = bytes[pos++] << 8 | bytes[pos++];
            charset.push(cid ? id : strings.get(id));
          }
          break;
        case 1:
          while (charset.length <= length) {
            id = bytes[pos++] << 8 | bytes[pos++];
            count = bytes[pos++];
            for (i = 0; i <= count; i++) {
              charset.push(cid ? id++ : strings.get(id++));
            }
          }
          break;
        case 2:
          while (charset.length <= length) {
            id = bytes[pos++] << 8 | bytes[pos++];
            count = bytes[pos++] << 8 | bytes[pos++];
            for (i = 0; i <= count; i++) {
              charset.push(cid ? id++ : strings.get(id++));
            }
          }
          break;
        default:
          throw new FormatError("Unknown charset format");
      }
      const end = pos;
      const raw = bytes.subarray(start, end);
      return new CFFCharset(false, format, charset, raw);
    }
    parseEncoding(pos, properties, strings, charset) {
      const encoding = /* @__PURE__ */ Object.create(null);
      const bytes = this.bytes;
      let predefined = false;
      let format, i, ii;
      let raw = null;
      function readSupplement() {
        const supplementsCount = bytes[pos++];
        for (i = 0; i < supplementsCount; i++) {
          const code = bytes[pos++];
          const sid = (bytes[pos++] << 8) + (bytes[pos++] & 255);
          encoding[code] = charset.indexOf(strings.get(sid));
        }
      }
      if (pos === 0 || pos === 1) {
        predefined = true;
        format = pos;
        const baseEncoding = pos ? ExpertEncoding : StandardEncoding;
        for (i = 0, ii = charset.length; i < ii; i++) {
          const index = baseEncoding.indexOf(charset[i]);
          if (index !== -1) {
            encoding[index] = i;
          }
        }
      } else {
        const dataStart = pos;
        format = bytes[pos++];
        switch (format & 127) {
          case 0:
            const glyphsCount = bytes[pos++];
            for (i = 1; i <= glyphsCount; i++) {
              encoding[bytes[pos++]] = i;
            }
            break;
          case 1:
            const rangesCount = bytes[pos++];
            let gid = 1;
            for (i = 0; i < rangesCount; i++) {
              const start = bytes[pos++];
              const left = bytes[pos++];
              for (let j = start; j <= start + left; j++) {
                encoding[j] = gid++;
              }
            }
            break;
          default:
            throw new FormatError(`Unknown encoding format: ${format} in CFF`);
        }
        const dataEnd = pos;
        if (format & 128) {
          bytes[dataStart] &= 127;
          readSupplement();
        }
        raw = bytes.subarray(dataStart, dataEnd);
      }
      format &= 127;
      return new CFFEncoding(predefined, format, encoding, raw);
    }
    parseFDSelect(pos, length) {
      const bytes = this.bytes;
      const format = bytes[pos++];
      const fdSelect = [];
      let i;
      switch (format) {
        case 0:
          for (i = 0; i < length; ++i) {
            const id = bytes[pos++];
            fdSelect.push(id);
          }
          break;
        case 3:
          const rangesCount = bytes[pos++] << 8 | bytes[pos++];
          for (i = 0; i < rangesCount; ++i) {
            let first = bytes[pos++] << 8 | bytes[pos++];
            if (i === 0 && first !== 0) {
              warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
              first = 0;
            }
            const fdIndex = bytes[pos++];
            const next = bytes[pos] << 8 | bytes[pos + 1];
            for (let j = first; j < next; ++j) {
              fdSelect.push(fdIndex);
            }
          }
          pos += 2;
          break;
        default:
          throw new FormatError(`parseFDSelect: Unknown format "${format}".`);
      }
      if (fdSelect.length !== length) {
        throw new FormatError("parseFDSelect: Invalid font data.");
      }
      return new CFFFDSelect(format, fdSelect);
    }
  }
  return CFFParser2;
}();
var CFF = class {
  constructor() {
    this.header = null;
    this.names = [];
    this.topDict = null;
    this.strings = new CFFStrings();
    this.globalSubrIndex = null;
    this.encoding = null;
    this.charset = null;
    this.charStrings = null;
    this.fdArray = [];
    this.fdSelect = null;
    this.isCIDFont = false;
  }
  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) {
      warn("Not enough space in charstrings to duplicate first glyph.");
      return;
    }
    const glyphZero = this.charStrings.get(0);
    this.charStrings.add(glyphZero);
    if (this.isCIDFont) {
      this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
    }
  }
  hasGlyphId(id) {
    if (id < 0 || id >= this.charStrings.count) {
      return false;
    }
    const glyph = this.charStrings.get(id);
    return glyph.length > 0;
  }
};
var CFFHeader = class {
  constructor(major, minor, hdrSize, offSize) {
    this.major = major;
    this.minor = minor;
    this.hdrSize = hdrSize;
    this.offSize = offSize;
  }
};
var CFFStrings = class {
  constructor() {
    this.strings = [];
  }
  get(index) {
    if (index >= 0 && index <= NUM_STANDARD_CFF_STRINGS - 1) {
      return CFFStandardStrings[index];
    }
    if (index - NUM_STANDARD_CFF_STRINGS <= this.strings.length) {
      return this.strings[index - NUM_STANDARD_CFF_STRINGS];
    }
    return CFFStandardStrings[0];
  }
  getSID(str) {
    let index = CFFStandardStrings.indexOf(str);
    if (index !== -1) {
      return index;
    }
    index = this.strings.indexOf(str);
    if (index !== -1) {
      return index + NUM_STANDARD_CFF_STRINGS;
    }
    return -1;
  }
  add(value) {
    this.strings.push(value);
  }
  get count() {
    return this.strings.length;
  }
};
var CFFIndex = class {
  constructor() {
    this.objects = [];
    this.length = 0;
  }
  add(data) {
    this.length += data.length;
    this.objects.push(data);
  }
  set(index, data) {
    this.length += data.length - this.objects[index].length;
    this.objects[index] = data;
  }
  get(index) {
    return this.objects[index];
  }
  get count() {
    return this.objects.length;
  }
};
var CFFDict = class {
  constructor(tables, strings) {
    this.keyToNameMap = tables.keyToNameMap;
    this.nameToKeyMap = tables.nameToKeyMap;
    this.defaults = tables.defaults;
    this.types = tables.types;
    this.opcodes = tables.opcodes;
    this.order = tables.order;
    this.strings = strings;
    this.values = /* @__PURE__ */ Object.create(null);
  }
  // value should always be an array
  setByKey(key, value) {
    if (!(key in this.keyToNameMap)) {
      return false;
    }
    const valueLength = value.length;
    if (valueLength === 0) {
      return true;
    }
    for (let i = 0; i < valueLength; i++) {
      if (isNaN(value[i])) {
        warn('Invalid CFFDict value: "' + value + '" for key "' + key + '".');
        return true;
      }
    }
    const type = this.types[key];
    if (type === "num" || type === "sid" || type === "offset") {
      value = value[0];
    }
    this.values[key] = value;
    return true;
  }
  setByName(name, value) {
    if (!(name in this.nameToKeyMap)) {
      throw new FormatError(`Invalid dictionary name "${name}"`);
    }
    this.values[this.nameToKeyMap[name]] = value;
  }
  hasName(name) {
    return this.nameToKeyMap[name] in this.values;
  }
  getByName(name) {
    if (!(name in this.nameToKeyMap)) {
      throw new FormatError(`Invalid dictionary name ${name}"`);
    }
    const key = this.nameToKeyMap[name];
    if (!(key in this.values)) {
      return this.defaults[key];
    }
    return this.values[key];
  }
  removeByName(name) {
    delete this.values[this.nameToKeyMap[name]];
  }
  static createTables(layout) {
    const tables = {
      keyToNameMap: {},
      nameToKeyMap: {},
      defaults: {},
      types: {},
      opcodes: {},
      order: []
    };
    for (let i = 0, ii = layout.length; i < ii; ++i) {
      const entry = layout[i];
      const key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
      tables.keyToNameMap[key] = entry[1];
      tables.nameToKeyMap[entry[1]] = key;
      tables.types[key] = entry[2];
      tables.defaults[key] = entry[3];
      tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
      tables.order.push(key);
    }
    return tables;
  }
};
var CFFTopDict = /* @__PURE__ */ function CFFTopDictClosure() {
  const layout = [
    [[12, 30], "ROS", ["sid", "sid", "num"], null],
    [[12, 20], "SyntheticBase", "num", null],
    [0, "version", "sid", null],
    [1, "Notice", "sid", null],
    [[12, 0], "Copyright", "sid", null],
    [2, "FullName", "sid", null],
    [3, "FamilyName", "sid", null],
    [4, "Weight", "sid", null],
    [[12, 1], "isFixedPitch", "num", 0],
    [[12, 2], "ItalicAngle", "num", 0],
    [[12, 3], "UnderlinePosition", "num", -100],
    [[12, 4], "UnderlineThickness", "num", 50],
    [[12, 5], "PaintType", "num", 0],
    [[12, 6], "CharstringType", "num", 2],
    // prettier-ignore
    [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]],
    [13, "UniqueID", "num", null],
    [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]],
    [[12, 8], "StrokeWidth", "num", 0],
    [14, "XUID", "array", null],
    [15, "charset", "offset", 0],
    [16, "Encoding", "offset", 0],
    [17, "CharStrings", "offset", 0],
    [18, "Private", ["offset", "offset"], null],
    [[12, 21], "PostScript", "sid", null],
    [[12, 22], "BaseFontName", "sid", null],
    [[12, 23], "BaseFontBlend", "delta", null],
    [[12, 31], "CIDFontVersion", "num", 0],
    [[12, 32], "CIDFontRevision", "num", 0],
    [[12, 33], "CIDFontType", "num", 0],
    [[12, 34], "CIDCount", "num", 8720],
    [[12, 35], "UIDBase", "num", null],
    // XXX: CID Fonts on DirectWrite 6.1 only seem to work if FDSelect comes
    // before FDArray.
    [[12, 37], "FDSelect", "offset", null],
    [[12, 36], "FDArray", "offset", null],
    [[12, 38], "FontName", "sid", null]
  ];
  let tables = null;
  class CFFTopDict2 extends CFFDict {
    constructor(strings) {
      if (tables === null) {
        tables = CFFDict.createTables(layout);
      }
      super(tables, strings);
      this.privateDict = null;
    }
  }
  return CFFTopDict2;
}();
var CFFPrivateDict = /* @__PURE__ */ function CFFPrivateDictClosure() {
  const layout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
  let tables = null;
  class CFFPrivateDict2 extends CFFDict {
    constructor(strings) {
      if (tables === null) {
        tables = CFFDict.createTables(layout);
      }
      super(tables, strings);
      this.subrsIndex = null;
    }
  }
  return CFFPrivateDict2;
}();
var CFFCharsetPredefinedTypes = {
  ISO_ADOBE: 0,
  EXPERT: 1,
  EXPERT_SUBSET: 2
};
var CFFCharset = class {
  constructor(predefined, format, charset, raw) {
    this.predefined = predefined;
    this.format = format;
    this.charset = charset;
    this.raw = raw;
  }
};
var CFFEncoding = class {
  constructor(predefined, format, encoding, raw) {
    this.predefined = predefined;
    this.format = format;
    this.encoding = encoding;
    this.raw = raw;
  }
};
var CFFFDSelect = class {
  constructor(format, fdSelect) {
    this.format = format;
    this.fdSelect = fdSelect;
  }
  getFDIndex(glyphIndex) {
    if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
      return -1;
    }
    return this.fdSelect[glyphIndex];
  }
};
var CFFOffsetTracker = class {
  constructor() {
    this.offsets = /* @__PURE__ */ Object.create(null);
  }
  isTracking(key) {
    return key in this.offsets;
  }
  track(key, location) {
    if (key in this.offsets) {
      throw new FormatError(`Already tracking location of ${key}`);
    }
    this.offsets[key] = location;
  }
  offset(value) {
    for (const key in this.offsets) {
      this.offsets[key] += value;
    }
  }
  setEntryLocation(key, values, output) {
    if (!(key in this.offsets)) {
      throw new FormatError(`Not tracking location of ${key}`);
    }
    const data = output.data;
    const dataOffset = this.offsets[key];
    const size = 5;
    for (let i = 0, ii = values.length; i < ii; ++i) {
      const offset0 = i * size + dataOffset;
      const offset1 = offset0 + 1;
      const offset2 = offset0 + 2;
      const offset3 = offset0 + 3;
      const offset4 = offset0 + 4;
      if (data[offset0] !== 29 || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
        throw new FormatError("writing to an offset that is not empty");
      }
      const value = values[i];
      data[offset0] = 29;
      data[offset1] = value >> 24 & 255;
      data[offset2] = value >> 16 & 255;
      data[offset3] = value >> 8 & 255;
      data[offset4] = value & 255;
    }
  }
};
var CFFCompiler = class _CFFCompiler {
  constructor(cff) {
    this.cff = cff;
  }
  compile() {
    const cff = this.cff;
    const output = {
      data: [],
      length: 0,
      add: function CFFCompiler_add(data) {
        this.data = this.data.concat(data);
        this.length = this.data.length;
      }
    };
    const header = this.compileHeader(cff.header);
    output.add(header);
    const nameIndex = this.compileNameIndex(cff.names);
    output.add(nameIndex);
    if (cff.isCIDFont) {
      if (cff.topDict.hasName("FontMatrix")) {
        const base = cff.topDict.getByName("FontMatrix");
        cff.topDict.removeByName("FontMatrix");
        for (let i = 0, ii = cff.fdArray.length; i < ii; i++) {
          const subDict = cff.fdArray[i];
          let matrix = base.slice(0);
          if (subDict.hasName("FontMatrix")) {
            matrix = Util.transform(matrix, subDict.getByName("FontMatrix"));
          }
          subDict.setByName("FontMatrix", matrix);
        }
      }
    }
    const xuid = cff.topDict.getByName("XUID");
    if (xuid && xuid.length > 16) {
      cff.topDict.removeByName("XUID");
    }
    cff.topDict.setByName("charset", 0);
    let compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
    output.add(compiled.output);
    const topDictTracker = compiled.trackers[0];
    const stringIndex = this.compileStringIndex(cff.strings.strings);
    output.add(stringIndex);
    const globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
    output.add(globalSubrIndex);
    if (cff.encoding && cff.topDict.hasName("Encoding")) {
      if (cff.encoding.predefined) {
        topDictTracker.setEntryLocation("Encoding", [cff.encoding.format], output);
      } else {
        const encoding = this.compileEncoding(cff.encoding);
        topDictTracker.setEntryLocation("Encoding", [output.length], output);
        output.add(encoding);
      }
    }
    const charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);
    topDictTracker.setEntryLocation("charset", [output.length], output);
    output.add(charset);
    const charStrings = this.compileCharStrings(cff.charStrings);
    topDictTracker.setEntryLocation("CharStrings", [output.length], output);
    output.add(charStrings);
    if (cff.isCIDFont) {
      topDictTracker.setEntryLocation("FDSelect", [output.length], output);
      const fdSelect = this.compileFDSelect(cff.fdSelect);
      output.add(fdSelect);
      compiled = this.compileTopDicts(cff.fdArray, output.length, true);
      topDictTracker.setEntryLocation("FDArray", [output.length], output);
      output.add(compiled.output);
      const fontDictTrackers = compiled.trackers;
      this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
    }
    this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
    output.add([0]);
    return output.data;
  }
  encodeNumber(value) {
    if (Number.isInteger(value)) {
      return this.encodeInteger(value);
    }
    return this.encodeFloat(value);
  }
  static get EncodeFloatRegExp() {
    return shadow(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  encodeFloat(num) {
    let value = num.toString();
    const m = _CFFCompiler.EncodeFloatRegExp.exec(value);
    if (m) {
      const epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
      value = (Math.round(num * epsilon) / epsilon).toString();
    }
    let nibbles = "";
    let i, ii;
    for (i = 0, ii = value.length; i < ii; ++i) {
      const a = value[i];
      if (a === "e") {
        nibbles += value[++i] === "-" ? "c" : "b";
      } else if (a === ".") {
        nibbles += "a";
      } else if (a === "-") {
        nibbles += "e";
      } else {
        nibbles += a;
      }
    }
    nibbles += nibbles.length & 1 ? "f" : "ff";
    const out = [30];
    for (i = 0, ii = nibbles.length; i < ii; i += 2) {
      out.push(parseInt(nibbles.substring(i, i + 2), 16));
    }
    return out;
  }
  encodeInteger(value) {
    let code;
    if (value >= -107 && value <= 107) {
      code = [value + 139];
    } else if (value >= 108 && value <= 1131) {
      value -= 108;
      code = [(value >> 8) + 247, value & 255];
    } else if (value >= -1131 && value <= -108) {
      value = -value - 108;
      code = [(value >> 8) + 251, value & 255];
    } else if (value >= -32768 && value <= 32767) {
      code = [28, value >> 8 & 255, value & 255];
    } else {
      code = [29, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255];
    }
    return code;
  }
  compileHeader(header) {
    return [header.major, header.minor, 4, header.offSize];
  }
  compileNameIndex(names) {
    const nameIndex = new CFFIndex();
    for (let i = 0, ii = names.length; i < ii; ++i) {
      const name = names[i];
      const length = Math.min(name.length, 127);
      let sanitizedName = new Array(length);
      for (let j = 0; j < length; j++) {
        let char = name[j];
        if (char < "!" || char > "~" || char === "[" || char === "]" || char === "(" || char === ")" || char === "{" || char === "}" || char === "<" || char === ">" || char === "/" || char === "%") {
          char = "_";
        }
        sanitizedName[j] = char;
      }
      sanitizedName = sanitizedName.join("");
      if (sanitizedName === "") {
        sanitizedName = "Bad_Font_Name";
      }
      nameIndex.add(stringToBytes(sanitizedName));
    }
    return this.compileIndex(nameIndex);
  }
  compileTopDicts(dicts, length, removeCidKeys) {
    const fontDictTrackers = [];
    let fdArrayIndex = new CFFIndex();
    for (let i = 0, ii = dicts.length; i < ii; ++i) {
      const fontDict = dicts[i];
      if (removeCidKeys) {
        fontDict.removeByName("CIDFontVersion");
        fontDict.removeByName("CIDFontRevision");
        fontDict.removeByName("CIDFontType");
        fontDict.removeByName("CIDCount");
        fontDict.removeByName("UIDBase");
      }
      const fontDictTracker = new CFFOffsetTracker();
      const fontDictData = this.compileDict(fontDict, fontDictTracker);
      fontDictTrackers.push(fontDictTracker);
      fdArrayIndex.add(fontDictData);
      fontDictTracker.offset(length);
    }
    fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
    return {
      trackers: fontDictTrackers,
      output: fdArrayIndex
    };
  }
  compilePrivateDicts(dicts, trackers, output) {
    for (let i = 0, ii = dicts.length; i < ii; ++i) {
      const fontDict = dicts[i];
      const privateDict = fontDict.privateDict;
      if (!privateDict || !fontDict.hasName("Private")) {
        throw new FormatError("There must be a private dictionary.");
      }
      const privateDictTracker = new CFFOffsetTracker();
      const privateDictData = this.compileDict(privateDict, privateDictTracker);
      let outputLength = output.length;
      privateDictTracker.offset(outputLength);
      if (!privateDictData.length) {
        outputLength = 0;
      }
      trackers[i].setEntryLocation("Private", [privateDictData.length, outputLength], output);
      output.add(privateDictData);
      if (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
        const subrs = this.compileIndex(privateDict.subrsIndex);
        privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
        output.add(subrs);
      }
    }
  }
  compileDict(dict, offsetTracker) {
    let out = [];
    const order = dict.order;
    for (let i = 0; i < order.length; ++i) {
      const key = order[i];
      if (!(key in dict.values)) {
        continue;
      }
      let values = dict.values[key];
      let types2 = dict.types[key];
      if (!Array.isArray(types2)) {
        types2 = [types2];
      }
      if (!Array.isArray(values)) {
        values = [values];
      }
      if (values.length === 0) {
        continue;
      }
      for (let j = 0, jj = types2.length; j < jj; ++j) {
        const type = types2[j];
        const value = values[j];
        switch (type) {
          case "num":
          case "sid":
            out = out.concat(this.encodeNumber(value));
            break;
          case "offset":
            const name = dict.keyToNameMap[key];
            if (!offsetTracker.isTracking(name)) {
              offsetTracker.track(name, out.length);
            }
            out = out.concat([29, 0, 0, 0, 0]);
            break;
          case "array":
          case "delta":
            out = out.concat(this.encodeNumber(value));
            for (let k = 1, kk = values.length; k < kk; ++k) {
              out = out.concat(this.encodeNumber(values[k]));
            }
            break;
          default:
            throw new FormatError(`Unknown data type of ${type}`);
        }
      }
      out = out.concat(dict.opcodes[key]);
    }
    return out;
  }
  compileStringIndex(strings) {
    const stringIndex = new CFFIndex();
    for (let i = 0, ii = strings.length; i < ii; ++i) {
      stringIndex.add(stringToBytes(strings[i]));
    }
    return this.compileIndex(stringIndex);
  }
  compileGlobalSubrIndex() {
    const globalSubrIndex = this.cff.globalSubrIndex;
    this.out.writeByteArray(this.compileIndex(globalSubrIndex));
  }
  compileCharStrings(charStrings) {
    const charStringsIndex = new CFFIndex();
    for (let i = 0; i < charStrings.count; i++) {
      const glyph = charStrings.get(i);
      if (glyph.length === 0) {
        charStringsIndex.add(new Uint8Array([139, 14]));
        continue;
      }
      charStringsIndex.add(glyph);
    }
    return this.compileIndex(charStringsIndex);
  }
  compileCharset(charset, numGlyphs, strings, isCIDFont) {
    let out;
    const numGlyphsLessNotDef = numGlyphs - 1;
    if (isCIDFont) {
      out = new Uint8Array([
        2,
        // format
        0,
        // first CID upper byte
        0,
        // first CID lower byte
        numGlyphsLessNotDef >> 8 & 255,
        numGlyphsLessNotDef & 255
      ]);
    } else {
      const length = 1 + numGlyphsLessNotDef * 2;
      out = new Uint8Array(length);
      out[0] = 0;
      let charsetIndex = 0;
      const numCharsets = charset.charset.length;
      let warned = false;
      for (let i = 1; i < out.length; i += 2) {
        let sid = 0;
        if (charsetIndex < numCharsets) {
          const name = charset.charset[charsetIndex++];
          sid = strings.getSID(name);
          if (sid === -1) {
            sid = 0;
            if (!warned) {
              warned = true;
              warn(`Couldn't find ${name} in CFF strings`);
            }
          }
        }
        out[i] = sid >> 8 & 255;
        out[i + 1] = sid & 255;
      }
    }
    return this.compileTypedArray(out);
  }
  compileEncoding(encoding) {
    return this.compileTypedArray(encoding.raw);
  }
  compileFDSelect(fdSelect) {
    const format = fdSelect.format;
    let out, i;
    switch (format) {
      case 0:
        out = new Uint8Array(1 + fdSelect.fdSelect.length);
        out[0] = format;
        for (i = 0; i < fdSelect.fdSelect.length; i++) {
          out[i + 1] = fdSelect.fdSelect[i];
        }
        break;
      case 3:
        const start = 0;
        let lastFD = fdSelect.fdSelect[0];
        const ranges = [
          format,
          0,
          // nRanges place holder
          0,
          // nRanges place holder
          start >> 8 & 255,
          start & 255,
          lastFD
        ];
        for (i = 1; i < fdSelect.fdSelect.length; i++) {
          const currentFD = fdSelect.fdSelect[i];
          if (currentFD !== lastFD) {
            ranges.push(i >> 8 & 255, i & 255, currentFD);
            lastFD = currentFD;
          }
        }
        const numRanges = (ranges.length - 3) / 3;
        ranges[1] = numRanges >> 8 & 255;
        ranges[2] = numRanges & 255;
        ranges.push(i >> 8 & 255, i & 255);
        out = new Uint8Array(ranges);
        break;
    }
    return this.compileTypedArray(out);
  }
  compileTypedArray(data) {
    const out = [];
    for (let i = 0, ii = data.length; i < ii; ++i) {
      out[i] = data[i];
    }
    return out;
  }
  compileIndex(index, trackers = []) {
    const objects = index.objects;
    const count = objects.length;
    if (count === 0) {
      return [0, 0, 0];
    }
    const data = [count >> 8 & 255, count & 255];
    let lastOffset = 1, i;
    for (i = 0; i < count; ++i) {
      lastOffset += objects[i].length;
    }
    let offsetSize;
    if (lastOffset < 256) {
      offsetSize = 1;
    } else if (lastOffset < 65536) {
      offsetSize = 2;
    } else if (lastOffset < 16777216) {
      offsetSize = 3;
    } else {
      offsetSize = 4;
    }
    data.push(offsetSize);
    let relativeOffset = 1;
    for (i = 0; i < count + 1; i++) {
      if (offsetSize === 1) {
        data.push(relativeOffset & 255);
      } else if (offsetSize === 2) {
        data.push(relativeOffset >> 8 & 255, relativeOffset & 255);
      } else if (offsetSize === 3) {
        data.push(relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
      } else {
        data.push(relativeOffset >>> 24 & 255, relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
      }
      if (objects[i]) {
        relativeOffset += objects[i].length;
      }
    }
    for (i = 0; i < count; i++) {
      if (trackers[i]) {
        trackers[i].offset(data.length);
      }
      for (let j = 0, jj = objects[i].length; j < jj; j++) {
        data.push(objects[i][j]);
      }
    }
    return data;
  }
};
var getGlyphsUnicode = getArrayLookupTableFactory(function() {
  return [
    "A",
    65,
    "AE",
    198,
    "AEacute",
    508,
    "AEmacron",
    482,
    "AEsmall",
    63462,
    "Aacute",
    193,
    "Aacutesmall",
    63457,
    "Abreve",
    258,
    "Abreveacute",
    7854,
    "Abrevecyrillic",
    1232,
    "Abrevedotbelow",
    7862,
    "Abrevegrave",
    7856,
    "Abrevehookabove",
    7858,
    "Abrevetilde",
    7860,
    "Acaron",
    461,
    "Acircle",
    9398,
    "Acircumflex",
    194,
    "Acircumflexacute",
    7844,
    "Acircumflexdotbelow",
    7852,
    "Acircumflexgrave",
    7846,
    "Acircumflexhookabove",
    7848,
    "Acircumflexsmall",
    63458,
    "Acircumflextilde",
    7850,
    "Acute",
    63177,
    "Acutesmall",
    63412,
    "Acyrillic",
    1040,
    "Adblgrave",
    512,
    "Adieresis",
    196,
    "Adieresiscyrillic",
    1234,
    "Adieresismacron",
    478,
    "Adieresissmall",
    63460,
    "Adotbelow",
    7840,
    "Adotmacron",
    480,
    "Agrave",
    192,
    "Agravesmall",
    63456,
    "Ahookabove",
    7842,
    "Aiecyrillic",
    1236,
    "Ainvertedbreve",
    514,
    "Alpha",
    913,
    "Alphatonos",
    902,
    "Amacron",
    256,
    "Amonospace",
    65313,
    "Aogonek",
    260,
    "Aring",
    197,
    "Aringacute",
    506,
    "Aringbelow",
    7680,
    "Aringsmall",
    63461,
    "Asmall",
    63329,
    "Atilde",
    195,
    "Atildesmall",
    63459,
    "Aybarmenian",
    1329,
    "B",
    66,
    "Bcircle",
    9399,
    "Bdotaccent",
    7682,
    "Bdotbelow",
    7684,
    "Becyrillic",
    1041,
    "Benarmenian",
    1330,
    "Beta",
    914,
    "Bhook",
    385,
    "Blinebelow",
    7686,
    "Bmonospace",
    65314,
    "Brevesmall",
    63220,
    "Bsmall",
    63330,
    "Btopbar",
    386,
    "C",
    67,
    "Caarmenian",
    1342,
    "Cacute",
    262,
    "Caron",
    63178,
    "Caronsmall",
    63221,
    "Ccaron",
    268,
    "Ccedilla",
    199,
    "Ccedillaacute",
    7688,
    "Ccedillasmall",
    63463,
    "Ccircle",
    9400,
    "Ccircumflex",
    264,
    "Cdot",
    266,
    "Cdotaccent",
    266,
    "Cedillasmall",
    63416,
    "Chaarmenian",
    1353,
    "Cheabkhasiancyrillic",
    1212,
    "Checyrillic",
    1063,
    "Chedescenderabkhasiancyrillic",
    1214,
    "Chedescendercyrillic",
    1206,
    "Chedieresiscyrillic",
    1268,
    "Cheharmenian",
    1347,
    "Chekhakassiancyrillic",
    1227,
    "Cheverticalstrokecyrillic",
    1208,
    "Chi",
    935,
    "Chook",
    391,
    "Circumflexsmall",
    63222,
    "Cmonospace",
    65315,
    "Coarmenian",
    1361,
    "Csmall",
    63331,
    "D",
    68,
    "DZ",
    497,
    "DZcaron",
    452,
    "Daarmenian",
    1332,
    "Dafrican",
    393,
    "Dcaron",
    270,
    "Dcedilla",
    7696,
    "Dcircle",
    9401,
    "Dcircumflexbelow",
    7698,
    "Dcroat",
    272,
    "Ddotaccent",
    7690,
    "Ddotbelow",
    7692,
    "Decyrillic",
    1044,
    "Deicoptic",
    1006,
    "Delta",
    8710,
    "Deltagreek",
    916,
    "Dhook",
    394,
    "Dieresis",
    63179,
    "DieresisAcute",
    63180,
    "DieresisGrave",
    63181,
    "Dieresissmall",
    63400,
    "Digammagreek",
    988,
    "Djecyrillic",
    1026,
    "Dlinebelow",
    7694,
    "Dmonospace",
    65316,
    "Dotaccentsmall",
    63223,
    "Dslash",
    272,
    "Dsmall",
    63332,
    "Dtopbar",
    395,
    "Dz",
    498,
    "Dzcaron",
    453,
    "Dzeabkhasiancyrillic",
    1248,
    "Dzecyrillic",
    1029,
    "Dzhecyrillic",
    1039,
    "E",
    69,
    "Eacute",
    201,
    "Eacutesmall",
    63465,
    "Ebreve",
    276,
    "Ecaron",
    282,
    "Ecedillabreve",
    7708,
    "Echarmenian",
    1333,
    "Ecircle",
    9402,
    "Ecircumflex",
    202,
    "Ecircumflexacute",
    7870,
    "Ecircumflexbelow",
    7704,
    "Ecircumflexdotbelow",
    7878,
    "Ecircumflexgrave",
    7872,
    "Ecircumflexhookabove",
    7874,
    "Ecircumflexsmall",
    63466,
    "Ecircumflextilde",
    7876,
    "Ecyrillic",
    1028,
    "Edblgrave",
    516,
    "Edieresis",
    203,
    "Edieresissmall",
    63467,
    "Edot",
    278,
    "Edotaccent",
    278,
    "Edotbelow",
    7864,
    "Efcyrillic",
    1060,
    "Egrave",
    200,
    "Egravesmall",
    63464,
    "Eharmenian",
    1335,
    "Ehookabove",
    7866,
    "Eightroman",
    8551,
    "Einvertedbreve",
    518,
    "Eiotifiedcyrillic",
    1124,
    "Elcyrillic",
    1051,
    "Elevenroman",
    8554,
    "Emacron",
    274,
    "Emacronacute",
    7702,
    "Emacrongrave",
    7700,
    "Emcyrillic",
    1052,
    "Emonospace",
    65317,
    "Encyrillic",
    1053,
    "Endescendercyrillic",
    1186,
    "Eng",
    330,
    "Enghecyrillic",
    1188,
    "Enhookcyrillic",
    1223,
    "Eogonek",
    280,
    "Eopen",
    400,
    "Epsilon",
    917,
    "Epsilontonos",
    904,
    "Ercyrillic",
    1056,
    "Ereversed",
    398,
    "Ereversedcyrillic",
    1069,
    "Escyrillic",
    1057,
    "Esdescendercyrillic",
    1194,
    "Esh",
    425,
    "Esmall",
    63333,
    "Eta",
    919,
    "Etarmenian",
    1336,
    "Etatonos",
    905,
    "Eth",
    208,
    "Ethsmall",
    63472,
    "Etilde",
    7868,
    "Etildebelow",
    7706,
    "Euro",
    8364,
    "Ezh",
    439,
    "Ezhcaron",
    494,
    "Ezhreversed",
    440,
    "F",
    70,
    "Fcircle",
    9403,
    "Fdotaccent",
    7710,
    "Feharmenian",
    1366,
    "Feicoptic",
    996,
    "Fhook",
    401,
    "Fitacyrillic",
    1138,
    "Fiveroman",
    8548,
    "Fmonospace",
    65318,
    "Fourroman",
    8547,
    "Fsmall",
    63334,
    "G",
    71,
    "GBsquare",
    13191,
    "Gacute",
    500,
    "Gamma",
    915,
    "Gammaafrican",
    404,
    "Gangiacoptic",
    1002,
    "Gbreve",
    286,
    "Gcaron",
    486,
    "Gcedilla",
    290,
    "Gcircle",
    9404,
    "Gcircumflex",
    284,
    "Gcommaaccent",
    290,
    "Gdot",
    288,
    "Gdotaccent",
    288,
    "Gecyrillic",
    1043,
    "Ghadarmenian",
    1346,
    "Ghemiddlehookcyrillic",
    1172,
    "Ghestrokecyrillic",
    1170,
    "Gheupturncyrillic",
    1168,
    "Ghook",
    403,
    "Gimarmenian",
    1331,
    "Gjecyrillic",
    1027,
    "Gmacron",
    7712,
    "Gmonospace",
    65319,
    "Grave",
    63182,
    "Gravesmall",
    63328,
    "Gsmall",
    63335,
    "Gsmallhook",
    667,
    "Gstroke",
    484,
    "H",
    72,
    "H18533",
    9679,
    "H18543",
    9642,
    "H18551",
    9643,
    "H22073",
    9633,
    "HPsquare",
    13259,
    "Haabkhasiancyrillic",
    1192,
    "Hadescendercyrillic",
    1202,
    "Hardsigncyrillic",
    1066,
    "Hbar",
    294,
    "Hbrevebelow",
    7722,
    "Hcedilla",
    7720,
    "Hcircle",
    9405,
    "Hcircumflex",
    292,
    "Hdieresis",
    7718,
    "Hdotaccent",
    7714,
    "Hdotbelow",
    7716,
    "Hmonospace",
    65320,
    "Hoarmenian",
    1344,
    "Horicoptic",
    1e3,
    "Hsmall",
    63336,
    "Hungarumlaut",
    63183,
    "Hungarumlautsmall",
    63224,
    "Hzsquare",
    13200,
    "I",
    73,
    "IAcyrillic",
    1071,
    "IJ",
    306,
    "IUcyrillic",
    1070,
    "Iacute",
    205,
    "Iacutesmall",
    63469,
    "Ibreve",
    300,
    "Icaron",
    463,
    "Icircle",
    9406,
    "Icircumflex",
    206,
    "Icircumflexsmall",
    63470,
    "Icyrillic",
    1030,
    "Idblgrave",
    520,
    "Idieresis",
    207,
    "Idieresisacute",
    7726,
    "Idieresiscyrillic",
    1252,
    "Idieresissmall",
    63471,
    "Idot",
    304,
    "Idotaccent",
    304,
    "Idotbelow",
    7882,
    "Iebrevecyrillic",
    1238,
    "Iecyrillic",
    1045,
    "Ifraktur",
    8465,
    "Igrave",
    204,
    "Igravesmall",
    63468,
    "Ihookabove",
    7880,
    "Iicyrillic",
    1048,
    "Iinvertedbreve",
    522,
    "Iishortcyrillic",
    1049,
    "Imacron",
    298,
    "Imacroncyrillic",
    1250,
    "Imonospace",
    65321,
    "Iniarmenian",
    1339,
    "Iocyrillic",
    1025,
    "Iogonek",
    302,
    "Iota",
    921,
    "Iotaafrican",
    406,
    "Iotadieresis",
    938,
    "Iotatonos",
    906,
    "Ismall",
    63337,
    "Istroke",
    407,
    "Itilde",
    296,
    "Itildebelow",
    7724,
    "Izhitsacyrillic",
    1140,
    "Izhitsadblgravecyrillic",
    1142,
    "J",
    74,
    "Jaarmenian",
    1345,
    "Jcircle",
    9407,
    "Jcircumflex",
    308,
    "Jecyrillic",
    1032,
    "Jheharmenian",
    1355,
    "Jmonospace",
    65322,
    "Jsmall",
    63338,
    "K",
    75,
    "KBsquare",
    13189,
    "KKsquare",
    13261,
    "Kabashkircyrillic",
    1184,
    "Kacute",
    7728,
    "Kacyrillic",
    1050,
    "Kadescendercyrillic",
    1178,
    "Kahookcyrillic",
    1219,
    "Kappa",
    922,
    "Kastrokecyrillic",
    1182,
    "Kaverticalstrokecyrillic",
    1180,
    "Kcaron",
    488,
    "Kcedilla",
    310,
    "Kcircle",
    9408,
    "Kcommaaccent",
    310,
    "Kdotbelow",
    7730,
    "Keharmenian",
    1364,
    "Kenarmenian",
    1343,
    "Khacyrillic",
    1061,
    "Kheicoptic",
    998,
    "Khook",
    408,
    "Kjecyrillic",
    1036,
    "Klinebelow",
    7732,
    "Kmonospace",
    65323,
    "Koppacyrillic",
    1152,
    "Koppagreek",
    990,
    "Ksicyrillic",
    1134,
    "Ksmall",
    63339,
    "L",
    76,
    "LJ",
    455,
    "LL",
    63167,
    "Lacute",
    313,
    "Lambda",
    923,
    "Lcaron",
    317,
    "Lcedilla",
    315,
    "Lcircle",
    9409,
    "Lcircumflexbelow",
    7740,
    "Lcommaaccent",
    315,
    "Ldot",
    319,
    "Ldotaccent",
    319,
    "Ldotbelow",
    7734,
    "Ldotbelowmacron",
    7736,
    "Liwnarmenian",
    1340,
    "Lj",
    456,
    "Ljecyrillic",
    1033,
    "Llinebelow",
    7738,
    "Lmonospace",
    65324,
    "Lslash",
    321,
    "Lslashsmall",
    63225,
    "Lsmall",
    63340,
    "M",
    77,
    "MBsquare",
    13190,
    "Macron",
    63184,
    "Macronsmall",
    63407,
    "Macute",
    7742,
    "Mcircle",
    9410,
    "Mdotaccent",
    7744,
    "Mdotbelow",
    7746,
    "Menarmenian",
    1348,
    "Mmonospace",
    65325,
    "Msmall",
    63341,
    "Mturned",
    412,
    "Mu",
    924,
    "N",
    78,
    "NJ",
    458,
    "Nacute",
    323,
    "Ncaron",
    327,
    "Ncedilla",
    325,
    "Ncircle",
    9411,
    "Ncircumflexbelow",
    7754,
    "Ncommaaccent",
    325,
    "Ndotaccent",
    7748,
    "Ndotbelow",
    7750,
    "Nhookleft",
    413,
    "Nineroman",
    8552,
    "Nj",
    459,
    "Njecyrillic",
    1034,
    "Nlinebelow",
    7752,
    "Nmonospace",
    65326,
    "Nowarmenian",
    1350,
    "Nsmall",
    63342,
    "Ntilde",
    209,
    "Ntildesmall",
    63473,
    "Nu",
    925,
    "O",
    79,
    "OE",
    338,
    "OEsmall",
    63226,
    "Oacute",
    211,
    "Oacutesmall",
    63475,
    "Obarredcyrillic",
    1256,
    "Obarreddieresiscyrillic",
    1258,
    "Obreve",
    334,
    "Ocaron",
    465,
    "Ocenteredtilde",
    415,
    "Ocircle",
    9412,
    "Ocircumflex",
    212,
    "Ocircumflexacute",
    7888,
    "Ocircumflexdotbelow",
    7896,
    "Ocircumflexgrave",
    7890,
    "Ocircumflexhookabove",
    7892,
    "Ocircumflexsmall",
    63476,
    "Ocircumflextilde",
    7894,
    "Ocyrillic",
    1054,
    "Odblacute",
    336,
    "Odblgrave",
    524,
    "Odieresis",
    214,
    "Odieresiscyrillic",
    1254,
    "Odieresissmall",
    63478,
    "Odotbelow",
    7884,
    "Ogoneksmall",
    63227,
    "Ograve",
    210,
    "Ogravesmall",
    63474,
    "Oharmenian",
    1365,
    "Ohm",
    8486,
    "Ohookabove",
    7886,
    "Ohorn",
    416,
    "Ohornacute",
    7898,
    "Ohorndotbelow",
    7906,
    "Ohorngrave",
    7900,
    "Ohornhookabove",
    7902,
    "Ohorntilde",
    7904,
    "Ohungarumlaut",
    336,
    "Oi",
    418,
    "Oinvertedbreve",
    526,
    "Omacron",
    332,
    "Omacronacute",
    7762,
    "Omacrongrave",
    7760,
    "Omega",
    8486,
    "Omegacyrillic",
    1120,
    "Omegagreek",
    937,
    "Omegaroundcyrillic",
    1146,
    "Omegatitlocyrillic",
    1148,
    "Omegatonos",
    911,
    "Omicron",
    927,
    "Omicrontonos",
    908,
    "Omonospace",
    65327,
    "Oneroman",
    8544,
    "Oogonek",
    490,
    "Oogonekmacron",
    492,
    "Oopen",
    390,
    "Oslash",
    216,
    "Oslashacute",
    510,
    "Oslashsmall",
    63480,
    "Osmall",
    63343,
    "Ostrokeacute",
    510,
    "Otcyrillic",
    1150,
    "Otilde",
    213,
    "Otildeacute",
    7756,
    "Otildedieresis",
    7758,
    "Otildesmall",
    63477,
    "P",
    80,
    "Pacute",
    7764,
    "Pcircle",
    9413,
    "Pdotaccent",
    7766,
    "Pecyrillic",
    1055,
    "Peharmenian",
    1354,
    "Pemiddlehookcyrillic",
    1190,
    "Phi",
    934,
    "Phook",
    420,
    "Pi",
    928,
    "Piwrarmenian",
    1363,
    "Pmonospace",
    65328,
    "Psi",
    936,
    "Psicyrillic",
    1136,
    "Psmall",
    63344,
    "Q",
    81,
    "Qcircle",
    9414,
    "Qmonospace",
    65329,
    "Qsmall",
    63345,
    "R",
    82,
    "Raarmenian",
    1356,
    "Racute",
    340,
    "Rcaron",
    344,
    "Rcedilla",
    342,
    "Rcircle",
    9415,
    "Rcommaaccent",
    342,
    "Rdblgrave",
    528,
    "Rdotaccent",
    7768,
    "Rdotbelow",
    7770,
    "Rdotbelowmacron",
    7772,
    "Reharmenian",
    1360,
    "Rfraktur",
    8476,
    "Rho",
    929,
    "Ringsmall",
    63228,
    "Rinvertedbreve",
    530,
    "Rlinebelow",
    7774,
    "Rmonospace",
    65330,
    "Rsmall",
    63346,
    "Rsmallinverted",
    641,
    "Rsmallinvertedsuperior",
    694,
    "S",
    83,
    "SF010000",
    9484,
    "SF020000",
    9492,
    "SF030000",
    9488,
    "SF040000",
    9496,
    "SF050000",
    9532,
    "SF060000",
    9516,
    "SF070000",
    9524,
    "SF080000",
    9500,
    "SF090000",
    9508,
    "SF100000",
    9472,
    "SF110000",
    9474,
    "SF190000",
    9569,
    "SF200000",
    9570,
    "SF210000",
    9558,
    "SF220000",
    9557,
    "SF230000",
    9571,
    "SF240000",
    9553,
    "SF250000",
    9559,
    "SF260000",
    9565,
    "SF270000",
    9564,
    "SF280000",
    9563,
    "SF360000",
    9566,
    "SF370000",
    9567,
    "SF380000",
    9562,
    "SF390000",
    9556,
    "SF400000",
    9577,
    "SF410000",
    9574,
    "SF420000",
    9568,
    "SF430000",
    9552,
    "SF440000",
    9580,
    "SF450000",
    9575,
    "SF460000",
    9576,
    "SF470000",
    9572,
    "SF480000",
    9573,
    "SF490000",
    9561,
    "SF500000",
    9560,
    "SF510000",
    9554,
    "SF520000",
    9555,
    "SF530000",
    9579,
    "SF540000",
    9578,
    "Sacute",
    346,
    "Sacutedotaccent",
    7780,
    "Sampigreek",
    992,
    "Scaron",
    352,
    "Scarondotaccent",
    7782,
    "Scaronsmall",
    63229,
    "Scedilla",
    350,
    "Schwa",
    399,
    "Schwacyrillic",
    1240,
    "Schwadieresiscyrillic",
    1242,
    "Scircle",
    9416,
    "Scircumflex",
    348,
    "Scommaaccent",
    536,
    "Sdotaccent",
    7776,
    "Sdotbelow",
    7778,
    "Sdotbelowdotaccent",
    7784,
    "Seharmenian",
    1357,
    "Sevenroman",
    8550,
    "Shaarmenian",
    1351,
    "Shacyrillic",
    1064,
    "Shchacyrillic",
    1065,
    "Sheicoptic",
    994,
    "Shhacyrillic",
    1210,
    "Shimacoptic",
    1004,
    "Sigma",
    931,
    "Sixroman",
    8549,
    "Smonospace",
    65331,
    "Softsigncyrillic",
    1068,
    "Ssmall",
    63347,
    "Stigmagreek",
    986,
    "T",
    84,
    "Tau",
    932,
    "Tbar",
    358,
    "Tcaron",
    356,
    "Tcedilla",
    354,
    "Tcircle",
    9417,
    "Tcircumflexbelow",
    7792,
    "Tcommaaccent",
    354,
    "Tdotaccent",
    7786,
    "Tdotbelow",
    7788,
    "Tecyrillic",
    1058,
    "Tedescendercyrillic",
    1196,
    "Tenroman",
    8553,
    "Tetsecyrillic",
    1204,
    "Theta",
    920,
    "Thook",
    428,
    "Thorn",
    222,
    "Thornsmall",
    63486,
    "Threeroman",
    8546,
    "Tildesmall",
    63230,
    "Tiwnarmenian",
    1359,
    "Tlinebelow",
    7790,
    "Tmonospace",
    65332,
    "Toarmenian",
    1337,
    "Tonefive",
    444,
    "Tonesix",
    388,
    "Tonetwo",
    423,
    "Tretroflexhook",
    430,
    "Tsecyrillic",
    1062,
    "Tshecyrillic",
    1035,
    "Tsmall",
    63348,
    "Twelveroman",
    8555,
    "Tworoman",
    8545,
    "U",
    85,
    "Uacute",
    218,
    "Uacutesmall",
    63482,
    "Ubreve",
    364,
    "Ucaron",
    467,
    "Ucircle",
    9418,
    "Ucircumflex",
    219,
    "Ucircumflexbelow",
    7798,
    "Ucircumflexsmall",
    63483,
    "Ucyrillic",
    1059,
    "Udblacute",
    368,
    "Udblgrave",
    532,
    "Udieresis",
    220,
    "Udieresisacute",
    471,
    "Udieresisbelow",
    7794,
    "Udieresiscaron",
    473,
    "Udieresiscyrillic",
    1264,
    "Udieresisgrave",
    475,
    "Udieresismacron",
    469,
    "Udieresissmall",
    63484,
    "Udotbelow",
    7908,
    "Ugrave",
    217,
    "Ugravesmall",
    63481,
    "Uhookabove",
    7910,
    "Uhorn",
    431,
    "Uhornacute",
    7912,
    "Uhorndotbelow",
    7920,
    "Uhorngrave",
    7914,
    "Uhornhookabove",
    7916,
    "Uhorntilde",
    7918,
    "Uhungarumlaut",
    368,
    "Uhungarumlautcyrillic",
    1266,
    "Uinvertedbreve",
    534,
    "Ukcyrillic",
    1144,
    "Umacron",
    362,
    "Umacroncyrillic",
    1262,
    "Umacrondieresis",
    7802,
    "Umonospace",
    65333,
    "Uogonek",
    370,
    "Upsilon",
    933,
    "Upsilon1",
    978,
    "Upsilonacutehooksymbolgreek",
    979,
    "Upsilonafrican",
    433,
    "Upsilondieresis",
    939,
    "Upsilondieresishooksymbolgreek",
    980,
    "Upsilonhooksymbol",
    978,
    "Upsilontonos",
    910,
    "Uring",
    366,
    "Ushortcyrillic",
    1038,
    "Usmall",
    63349,
    "Ustraightcyrillic",
    1198,
    "Ustraightstrokecyrillic",
    1200,
    "Utilde",
    360,
    "Utildeacute",
    7800,
    "Utildebelow",
    7796,
    "V",
    86,
    "Vcircle",
    9419,
    "Vdotbelow",
    7806,
    "Vecyrillic",
    1042,
    "Vewarmenian",
    1358,
    "Vhook",
    434,
    "Vmonospace",
    65334,
    "Voarmenian",
    1352,
    "Vsmall",
    63350,
    "Vtilde",
    7804,
    "W",
    87,
    "Wacute",
    7810,
    "Wcircle",
    9420,
    "Wcircumflex",
    372,
    "Wdieresis",
    7812,
    "Wdotaccent",
    7814,
    "Wdotbelow",
    7816,
    "Wgrave",
    7808,
    "Wmonospace",
    65335,
    "Wsmall",
    63351,
    "X",
    88,
    "Xcircle",
    9421,
    "Xdieresis",
    7820,
    "Xdotaccent",
    7818,
    "Xeharmenian",
    1341,
    "Xi",
    926,
    "Xmonospace",
    65336,
    "Xsmall",
    63352,
    "Y",
    89,
    "Yacute",
    221,
    "Yacutesmall",
    63485,
    "Yatcyrillic",
    1122,
    "Ycircle",
    9422,
    "Ycircumflex",
    374,
    "Ydieresis",
    376,
    "Ydieresissmall",
    63487,
    "Ydotaccent",
    7822,
    "Ydotbelow",
    7924,
    "Yericyrillic",
    1067,
    "Yerudieresiscyrillic",
    1272,
    "Ygrave",
    7922,
    "Yhook",
    435,
    "Yhookabove",
    7926,
    "Yiarmenian",
    1349,
    "Yicyrillic",
    1031,
    "Yiwnarmenian",
    1362,
    "Ymonospace",
    65337,
    "Ysmall",
    63353,
    "Ytilde",
    7928,
    "Yusbigcyrillic",
    1130,
    "Yusbigiotifiedcyrillic",
    1132,
    "Yuslittlecyrillic",
    1126,
    "Yuslittleiotifiedcyrillic",
    1128,
    "Z",
    90,
    "Zaarmenian",
    1334,
    "Zacute",
    377,
    "Zcaron",
    381,
    "Zcaronsmall",
    63231,
    "Zcircle",
    9423,
    "Zcircumflex",
    7824,
    "Zdot",
    379,
    "Zdotaccent",
    379,
    "Zdotbelow",
    7826,
    "Zecyrillic",
    1047,
    "Zedescendercyrillic",
    1176,
    "Zedieresiscyrillic",
    1246,
    "Zeta",
    918,
    "Zhearmenian",
    1338,
    "Zhebrevecyrillic",
    1217,
    "Zhecyrillic",
    1046,
    "Zhedescendercyrillic",
    1174,
    "Zhedieresiscyrillic",
    1244,
    "Zlinebelow",
    7828,
    "Zmonospace",
    65338,
    "Zsmall",
    63354,
    "Zstroke",
    437,
    "a",
    97,
    "aabengali",
    2438,
    "aacute",
    225,
    "aadeva",
    2310,
    "aagujarati",
    2694,
    "aagurmukhi",
    2566,
    "aamatragurmukhi",
    2622,
    "aarusquare",
    13059,
    "aavowelsignbengali",
    2494,
    "aavowelsigndeva",
    2366,
    "aavowelsigngujarati",
    2750,
    "abbreviationmarkarmenian",
    1375,
    "abbreviationsigndeva",
    2416,
    "abengali",
    2437,
    "abopomofo",
    12570,
    "abreve",
    259,
    "abreveacute",
    7855,
    "abrevecyrillic",
    1233,
    "abrevedotbelow",
    7863,
    "abrevegrave",
    7857,
    "abrevehookabove",
    7859,
    "abrevetilde",
    7861,
    "acaron",
    462,
    "acircle",
    9424,
    "acircumflex",
    226,
    "acircumflexacute",
    7845,
    "acircumflexdotbelow",
    7853,
    "acircumflexgrave",
    7847,
    "acircumflexhookabove",
    7849,
    "acircumflextilde",
    7851,
    "acute",
    180,
    "acutebelowcmb",
    791,
    "acutecmb",
    769,
    "acutecomb",
    769,
    "acutedeva",
    2388,
    "acutelowmod",
    719,
    "acutetonecmb",
    833,
    "acyrillic",
    1072,
    "adblgrave",
    513,
    "addakgurmukhi",
    2673,
    "adeva",
    2309,
    "adieresis",
    228,
    "adieresiscyrillic",
    1235,
    "adieresismacron",
    479,
    "adotbelow",
    7841,
    "adotmacron",
    481,
    "ae",
    230,
    "aeacute",
    509,
    "aekorean",
    12624,
    "aemacron",
    483,
    "afii00208",
    8213,
    "afii08941",
    8356,
    "afii10017",
    1040,
    "afii10018",
    1041,
    "afii10019",
    1042,
    "afii10020",
    1043,
    "afii10021",
    1044,
    "afii10022",
    1045,
    "afii10023",
    1025,
    "afii10024",
    1046,
    "afii10025",
    1047,
    "afii10026",
    1048,
    "afii10027",
    1049,
    "afii10028",
    1050,
    "afii10029",
    1051,
    "afii10030",
    1052,
    "afii10031",
    1053,
    "afii10032",
    1054,
    "afii10033",
    1055,
    "afii10034",
    1056,
    "afii10035",
    1057,
    "afii10036",
    1058,
    "afii10037",
    1059,
    "afii10038",
    1060,
    "afii10039",
    1061,
    "afii10040",
    1062,
    "afii10041",
    1063,
    "afii10042",
    1064,
    "afii10043",
    1065,
    "afii10044",
    1066,
    "afii10045",
    1067,
    "afii10046",
    1068,
    "afii10047",
    1069,
    "afii10048",
    1070,
    "afii10049",
    1071,
    "afii10050",
    1168,
    "afii10051",
    1026,
    "afii10052",
    1027,
    "afii10053",
    1028,
    "afii10054",
    1029,
    "afii10055",
    1030,
    "afii10056",
    1031,
    "afii10057",
    1032,
    "afii10058",
    1033,
    "afii10059",
    1034,
    "afii10060",
    1035,
    "afii10061",
    1036,
    "afii10062",
    1038,
    "afii10063",
    63172,
    "afii10064",
    63173,
    "afii10065",
    1072,
    "afii10066",
    1073,
    "afii10067",
    1074,
    "afii10068",
    1075,
    "afii10069",
    1076,
    "afii10070",
    1077,
    "afii10071",
    1105,
    "afii10072",
    1078,
    "afii10073",
    1079,
    "afii10074",
    1080,
    "afii10075",
    1081,
    "afii10076",
    1082,
    "afii10077",
    1083,
    "afii10078",
    1084,
    "afii10079",
    1085,
    "afii10080",
    1086,
    "afii10081",
    1087,
    "afii10082",
    1088,
    "afii10083",
    1089,
    "afii10084",
    1090,
    "afii10085",
    1091,
    "afii10086",
    1092,
    "afii10087",
    1093,
    "afii10088",
    1094,
    "afii10089",
    1095,
    "afii10090",
    1096,
    "afii10091",
    1097,
    "afii10092",
    1098,
    "afii10093",
    1099,
    "afii10094",
    1100,
    "afii10095",
    1101,
    "afii10096",
    1102,
    "afii10097",
    1103,
    "afii10098",
    1169,
    "afii10099",
    1106,
    "afii10100",
    1107,
    "afii10101",
    1108,
    "afii10102",
    1109,
    "afii10103",
    1110,
    "afii10104",
    1111,
    "afii10105",
    1112,
    "afii10106",
    1113,
    "afii10107",
    1114,
    "afii10108",
    1115,
    "afii10109",
    1116,
    "afii10110",
    1118,
    "afii10145",
    1039,
    "afii10146",
    1122,
    "afii10147",
    1138,
    "afii10148",
    1140,
    "afii10192",
    63174,
    "afii10193",
    1119,
    "afii10194",
    1123,
    "afii10195",
    1139,
    "afii10196",
    1141,
    "afii10831",
    63175,
    "afii10832",
    63176,
    "afii10846",
    1241,
    "afii299",
    8206,
    "afii300",
    8207,
    "afii301",
    8205,
    "afii57381",
    1642,
    "afii57388",
    1548,
    "afii57392",
    1632,
    "afii57393",
    1633,
    "afii57394",
    1634,
    "afii57395",
    1635,
    "afii57396",
    1636,
    "afii57397",
    1637,
    "afii57398",
    1638,
    "afii57399",
    1639,
    "afii57400",
    1640,
    "afii57401",
    1641,
    "afii57403",
    1563,
    "afii57407",
    1567,
    "afii57409",
    1569,
    "afii57410",
    1570,
    "afii57411",
    1571,
    "afii57412",
    1572,
    "afii57413",
    1573,
    "afii57414",
    1574,
    "afii57415",
    1575,
    "afii57416",
    1576,
    "afii57417",
    1577,
    "afii57418",
    1578,
    "afii57419",
    1579,
    "afii57420",
    1580,
    "afii57421",
    1581,
    "afii57422",
    1582,
    "afii57423",
    1583,
    "afii57424",
    1584,
    "afii57425",
    1585,
    "afii57426",
    1586,
    "afii57427",
    1587,
    "afii57428",
    1588,
    "afii57429",
    1589,
    "afii57430",
    1590,
    "afii57431",
    1591,
    "afii57432",
    1592,
    "afii57433",
    1593,
    "afii57434",
    1594,
    "afii57440",
    1600,
    "afii57441",
    1601,
    "afii57442",
    1602,
    "afii57443",
    1603,
    "afii57444",
    1604,
    "afii57445",
    1605,
    "afii57446",
    1606,
    "afii57448",
    1608,
    "afii57449",
    1609,
    "afii57450",
    1610,
    "afii57451",
    1611,
    "afii57452",
    1612,
    "afii57453",
    1613,
    "afii57454",
    1614,
    "afii57455",
    1615,
    "afii57456",
    1616,
    "afii57457",
    1617,
    "afii57458",
    1618,
    "afii57470",
    1607,
    "afii57505",
    1700,
    "afii57506",
    1662,
    "afii57507",
    1670,
    "afii57508",
    1688,
    "afii57509",
    1711,
    "afii57511",
    1657,
    "afii57512",
    1672,
    "afii57513",
    1681,
    "afii57514",
    1722,
    "afii57519",
    1746,
    "afii57534",
    1749,
    "afii57636",
    8362,
    "afii57645",
    1470,
    "afii57658",
    1475,
    "afii57664",
    1488,
    "afii57665",
    1489,
    "afii57666",
    1490,
    "afii57667",
    1491,
    "afii57668",
    1492,
    "afii57669",
    1493,
    "afii57670",
    1494,
    "afii57671",
    1495,
    "afii57672",
    1496,
    "afii57673",
    1497,
    "afii57674",
    1498,
    "afii57675",
    1499,
    "afii57676",
    1500,
    "afii57677",
    1501,
    "afii57678",
    1502,
    "afii57679",
    1503,
    "afii57680",
    1504,
    "afii57681",
    1505,
    "afii57682",
    1506,
    "afii57683",
    1507,
    "afii57684",
    1508,
    "afii57685",
    1509,
    "afii57686",
    1510,
    "afii57687",
    1511,
    "afii57688",
    1512,
    "afii57689",
    1513,
    "afii57690",
    1514,
    "afii57694",
    64298,
    "afii57695",
    64299,
    "afii57700",
    64331,
    "afii57705",
    64287,
    "afii57716",
    1520,
    "afii57717",
    1521,
    "afii57718",
    1522,
    "afii57723",
    64309,
    "afii57793",
    1460,
    "afii57794",
    1461,
    "afii57795",
    1462,
    "afii57796",
    1467,
    "afii57797",
    1464,
    "afii57798",
    1463,
    "afii57799",
    1456,
    "afii57800",
    1458,
    "afii57801",
    1457,
    "afii57802",
    1459,
    "afii57803",
    1474,
    "afii57804",
    1473,
    "afii57806",
    1465,
    "afii57807",
    1468,
    "afii57839",
    1469,
    "afii57841",
    1471,
    "afii57842",
    1472,
    "afii57929",
    700,
    "afii61248",
    8453,
    "afii61289",
    8467,
    "afii61352",
    8470,
    "afii61573",
    8236,
    "afii61574",
    8237,
    "afii61575",
    8238,
    "afii61664",
    8204,
    "afii63167",
    1645,
    "afii64937",
    701,
    "agrave",
    224,
    "agujarati",
    2693,
    "agurmukhi",
    2565,
    "ahiragana",
    12354,
    "ahookabove",
    7843,
    "aibengali",
    2448,
    "aibopomofo",
    12574,
    "aideva",
    2320,
    "aiecyrillic",
    1237,
    "aigujarati",
    2704,
    "aigurmukhi",
    2576,
    "aimatragurmukhi",
    2632,
    "ainarabic",
    1593,
    "ainfinalarabic",
    65226,
    "aininitialarabic",
    65227,
    "ainmedialarabic",
    65228,
    "ainvertedbreve",
    515,
    "aivowelsignbengali",
    2504,
    "aivowelsigndeva",
    2376,
    "aivowelsigngujarati",
    2760,
    "akatakana",
    12450,
    "akatakanahalfwidth",
    65393,
    "akorean",
    12623,
    "alef",
    1488,
    "alefarabic",
    1575,
    "alefdageshhebrew",
    64304,
    "aleffinalarabic",
    65166,
    "alefhamzaabovearabic",
    1571,
    "alefhamzaabovefinalarabic",
    65156,
    "alefhamzabelowarabic",
    1573,
    "alefhamzabelowfinalarabic",
    65160,
    "alefhebrew",
    1488,
    "aleflamedhebrew",
    64335,
    "alefmaddaabovearabic",
    1570,
    "alefmaddaabovefinalarabic",
    65154,
    "alefmaksuraarabic",
    1609,
    "alefmaksurafinalarabic",
    65264,
    "alefmaksurainitialarabic",
    65267,
    "alefmaksuramedialarabic",
    65268,
    "alefpatahhebrew",
    64302,
    "alefqamatshebrew",
    64303,
    "aleph",
    8501,
    "allequal",
    8780,
    "alpha",
    945,
    "alphatonos",
    940,
    "amacron",
    257,
    "amonospace",
    65345,
    "ampersand",
    38,
    "ampersandmonospace",
    65286,
    "ampersandsmall",
    63270,
    "amsquare",
    13250,
    "anbopomofo",
    12578,
    "angbopomofo",
    12580,
    "angbracketleft",
    12296,
    // Glyph is missing from Adobe's original list.
    "angbracketright",
    12297,
    // Glyph is missing from Adobe's original list.
    "angkhankhuthai",
    3674,
    "angle",
    8736,
    "anglebracketleft",
    12296,
    "anglebracketleftvertical",
    65087,
    "anglebracketright",
    12297,
    "anglebracketrightvertical",
    65088,
    "angleleft",
    9001,
    "angleright",
    9002,
    "angstrom",
    8491,
    "anoteleia",
    903,
    "anudattadeva",
    2386,
    "anusvarabengali",
    2434,
    "anusvaradeva",
    2306,
    "anusvaragujarati",
    2690,
    "aogonek",
    261,
    "apaatosquare",
    13056,
    "aparen",
    9372,
    "apostrophearmenian",
    1370,
    "apostrophemod",
    700,
    "apple",
    63743,
    "approaches",
    8784,
    "approxequal",
    8776,
    "approxequalorimage",
    8786,
    "approximatelyequal",
    8773,
    "araeaekorean",
    12686,
    "araeakorean",
    12685,
    "arc",
    8978,
    "arighthalfring",
    7834,
    "aring",
    229,
    "aringacute",
    507,
    "aringbelow",
    7681,
    "arrowboth",
    8596,
    "arrowdashdown",
    8675,
    "arrowdashleft",
    8672,
    "arrowdashright",
    8674,
    "arrowdashup",
    8673,
    "arrowdblboth",
    8660,
    "arrowdbldown",
    8659,
    "arrowdblleft",
    8656,
    "arrowdblright",
    8658,
    "arrowdblup",
    8657,
    "arrowdown",
    8595,
    "arrowdownleft",
    8601,
    "arrowdownright",
    8600,
    "arrowdownwhite",
    8681,
    "arrowheaddownmod",
    709,
    "arrowheadleftmod",
    706,
    "arrowheadrightmod",
    707,
    "arrowheadupmod",
    708,
    "arrowhorizex",
    63719,
    "arrowleft",
    8592,
    "arrowleftdbl",
    8656,
    "arrowleftdblstroke",
    8653,
    "arrowleftoverright",
    8646,
    "arrowleftwhite",
    8678,
    "arrowright",
    8594,
    "arrowrightdblstroke",
    8655,
    "arrowrightheavy",
    10142,
    "arrowrightoverleft",
    8644,
    "arrowrightwhite",
    8680,
    "arrowtableft",
    8676,
    "arrowtabright",
    8677,
    "arrowup",
    8593,
    "arrowupdn",
    8597,
    "arrowupdnbse",
    8616,
    "arrowupdownbase",
    8616,
    "arrowupleft",
    8598,
    "arrowupleftofdown",
    8645,
    "arrowupright",
    8599,
    "arrowupwhite",
    8679,
    "arrowvertex",
    63718,
    "asciicircum",
    94,
    "asciicircummonospace",
    65342,
    "asciitilde",
    126,
    "asciitildemonospace",
    65374,
    "ascript",
    593,
    "ascriptturned",
    594,
    "asmallhiragana",
    12353,
    "asmallkatakana",
    12449,
    "asmallkatakanahalfwidth",
    65383,
    "asterisk",
    42,
    "asteriskaltonearabic",
    1645,
    "asteriskarabic",
    1645,
    "asteriskmath",
    8727,
    "asteriskmonospace",
    65290,
    "asterisksmall",
    65121,
    "asterism",
    8258,
    "asuperior",
    63209,
    "asymptoticallyequal",
    8771,
    "at",
    64,
    "atilde",
    227,
    "atmonospace",
    65312,
    "atsmall",
    65131,
    "aturned",
    592,
    "aubengali",
    2452,
    "aubopomofo",
    12576,
    "audeva",
    2324,
    "augujarati",
    2708,
    "augurmukhi",
    2580,
    "aulengthmarkbengali",
    2519,
    "aumatragurmukhi",
    2636,
    "auvowelsignbengali",
    2508,
    "auvowelsigndeva",
    2380,
    "auvowelsigngujarati",
    2764,
    "avagrahadeva",
    2365,
    "aybarmenian",
    1377,
    "ayin",
    1506,
    "ayinaltonehebrew",
    64288,
    "ayinhebrew",
    1506,
    "b",
    98,
    "babengali",
    2476,
    "backslash",
    92,
    "backslashmonospace",
    65340,
    "badeva",
    2348,
    "bagujarati",
    2732,
    "bagurmukhi",
    2604,
    "bahiragana",
    12400,
    "bahtthai",
    3647,
    "bakatakana",
    12496,
    "bar",
    124,
    "barmonospace",
    65372,
    "bbopomofo",
    12549,
    "bcircle",
    9425,
    "bdotaccent",
    7683,
    "bdotbelow",
    7685,
    "beamedsixteenthnotes",
    9836,
    "because",
    8757,
    "becyrillic",
    1073,
    "beharabic",
    1576,
    "behfinalarabic",
    65168,
    "behinitialarabic",
    65169,
    "behiragana",
    12409,
    "behmedialarabic",
    65170,
    "behmeeminitialarabic",
    64671,
    "behmeemisolatedarabic",
    64520,
    "behnoonfinalarabic",
    64621,
    "bekatakana",
    12505,
    "benarmenian",
    1378,
    "bet",
    1489,
    "beta",
    946,
    "betasymbolgreek",
    976,
    "betdagesh",
    64305,
    "betdageshhebrew",
    64305,
    "bethebrew",
    1489,
    "betrafehebrew",
    64332,
    "bhabengali",
    2477,
    "bhadeva",
    2349,
    "bhagujarati",
    2733,
    "bhagurmukhi",
    2605,
    "bhook",
    595,
    "bihiragana",
    12403,
    "bikatakana",
    12499,
    "bilabialclick",
    664,
    "bindigurmukhi",
    2562,
    "birusquare",
    13105,
    "blackcircle",
    9679,
    "blackdiamond",
    9670,
    "blackdownpointingtriangle",
    9660,
    "blackleftpointingpointer",
    9668,
    "blackleftpointingtriangle",
    9664,
    "blacklenticularbracketleft",
    12304,
    "blacklenticularbracketleftvertical",
    65083,
    "blacklenticularbracketright",
    12305,
    "blacklenticularbracketrightvertical",
    65084,
    "blacklowerlefttriangle",
    9699,
    "blacklowerrighttriangle",
    9698,
    "blackrectangle",
    9644,
    "blackrightpointingpointer",
    9658,
    "blackrightpointingtriangle",
    9654,
    "blacksmallsquare",
    9642,
    "blacksmilingface",
    9787,
    "blacksquare",
    9632,
    "blackstar",
    9733,
    "blackupperlefttriangle",
    9700,
    "blackupperrighttriangle",
    9701,
    "blackuppointingsmalltriangle",
    9652,
    "blackuppointingtriangle",
    9650,
    "blank",
    9251,
    "blinebelow",
    7687,
    "block",
    9608,
    "bmonospace",
    65346,
    "bobaimaithai",
    3610,
    "bohiragana",
    12412,
    "bokatakana",
    12508,
    "bparen",
    9373,
    "bqsquare",
    13251,
    "braceex",
    63732,
    "braceleft",
    123,
    "braceleftbt",
    63731,
    "braceleftmid",
    63730,
    "braceleftmonospace",
    65371,
    "braceleftsmall",
    65115,
    "bracelefttp",
    63729,
    "braceleftvertical",
    65079,
    "braceright",
    125,
    "bracerightbt",
    63742,
    "bracerightmid",
    63741,
    "bracerightmonospace",
    65373,
    "bracerightsmall",
    65116,
    "bracerighttp",
    63740,
    "bracerightvertical",
    65080,
    "bracketleft",
    91,
    "bracketleftbt",
    63728,
    "bracketleftex",
    63727,
    "bracketleftmonospace",
    65339,
    "bracketlefttp",
    63726,
    "bracketright",
    93,
    "bracketrightbt",
    63739,
    "bracketrightex",
    63738,
    "bracketrightmonospace",
    65341,
    "bracketrighttp",
    63737,
    "breve",
    728,
    "brevebelowcmb",
    814,
    "brevecmb",
    774,
    "breveinvertedbelowcmb",
    815,
    "breveinvertedcmb",
    785,
    "breveinverteddoublecmb",
    865,
    "bridgebelowcmb",
    810,
    "bridgeinvertedbelowcmb",
    826,
    "brokenbar",
    166,
    "bstroke",
    384,
    "bsuperior",
    63210,
    "btopbar",
    387,
    "buhiragana",
    12406,
    "bukatakana",
    12502,
    "bullet",
    8226,
    "bulletinverse",
    9688,
    "bulletoperator",
    8729,
    "bullseye",
    9678,
    "c",
    99,
    "caarmenian",
    1390,
    "cabengali",
    2458,
    "cacute",
    263,
    "cadeva",
    2330,
    "cagujarati",
    2714,
    "cagurmukhi",
    2586,
    "calsquare",
    13192,
    "candrabindubengali",
    2433,
    "candrabinducmb",
    784,
    "candrabindudeva",
    2305,
    "candrabindugujarati",
    2689,
    "capslock",
    8682,
    "careof",
    8453,
    "caron",
    711,
    "caronbelowcmb",
    812,
    "caroncmb",
    780,
    "carriagereturn",
    8629,
    "cbopomofo",
    12568,
    "ccaron",
    269,
    "ccedilla",
    231,
    "ccedillaacute",
    7689,
    "ccircle",
    9426,
    "ccircumflex",
    265,
    "ccurl",
    597,
    "cdot",
    267,
    "cdotaccent",
    267,
    "cdsquare",
    13253,
    "cedilla",
    184,
    "cedillacmb",
    807,
    "cent",
    162,
    "centigrade",
    8451,
    "centinferior",
    63199,
    "centmonospace",
    65504,
    "centoldstyle",
    63394,
    "centsuperior",
    63200,
    "chaarmenian",
    1401,
    "chabengali",
    2459,
    "chadeva",
    2331,
    "chagujarati",
    2715,
    "chagurmukhi",
    2587,
    "chbopomofo",
    12564,
    "cheabkhasiancyrillic",
    1213,
    "checkmark",
    10003,
    "checyrillic",
    1095,
    "chedescenderabkhasiancyrillic",
    1215,
    "chedescendercyrillic",
    1207,
    "chedieresiscyrillic",
    1269,
    "cheharmenian",
    1395,
    "chekhakassiancyrillic",
    1228,
    "cheverticalstrokecyrillic",
    1209,
    "chi",
    967,
    "chieuchacirclekorean",
    12919,
    "chieuchaparenkorean",
    12823,
    "chieuchcirclekorean",
    12905,
    "chieuchkorean",
    12618,
    "chieuchparenkorean",
    12809,
    "chochangthai",
    3594,
    "chochanthai",
    3592,
    "chochingthai",
    3593,
    "chochoethai",
    3596,
    "chook",
    392,
    "cieucacirclekorean",
    12918,
    "cieucaparenkorean",
    12822,
    "cieuccirclekorean",
    12904,
    "cieuckorean",
    12616,
    "cieucparenkorean",
    12808,
    "cieucuparenkorean",
    12828,
    "circle",
    9675,
    "circlecopyrt",
    169,
    // Glyph is missing from Adobe's original list.
    "circlemultiply",
    8855,
    "circleot",
    8857,
    "circleplus",
    8853,
    "circlepostalmark",
    12342,
    "circlewithlefthalfblack",
    9680,
    "circlewithrighthalfblack",
    9681,
    "circumflex",
    710,
    "circumflexbelowcmb",
    813,
    "circumflexcmb",
    770,
    "clear",
    8999,
    "clickalveolar",
    450,
    "clickdental",
    448,
    "clicklateral",
    449,
    "clickretroflex",
    451,
    "club",
    9827,
    "clubsuitblack",
    9827,
    "clubsuitwhite",
    9831,
    "cmcubedsquare",
    13220,
    "cmonospace",
    65347,
    "cmsquaredsquare",
    13216,
    "coarmenian",
    1409,
    "colon",
    58,
    "colonmonetary",
    8353,
    "colonmonospace",
    65306,
    "colonsign",
    8353,
    "colonsmall",
    65109,
    "colontriangularhalfmod",
    721,
    "colontriangularmod",
    720,
    "comma",
    44,
    "commaabovecmb",
    787,
    "commaaboverightcmb",
    789,
    "commaaccent",
    63171,
    "commaarabic",
    1548,
    "commaarmenian",
    1373,
    "commainferior",
    63201,
    "commamonospace",
    65292,
    "commareversedabovecmb",
    788,
    "commareversedmod",
    701,
    "commasmall",
    65104,
    "commasuperior",
    63202,
    "commaturnedabovecmb",
    786,
    "commaturnedmod",
    699,
    "compass",
    9788,
    "congruent",
    8773,
    "contourintegral",
    8750,
    "control",
    8963,
    "controlACK",
    6,
    "controlBEL",
    7,
    "controlBS",
    8,
    "controlCAN",
    24,
    "controlCR",
    13,
    "controlDC1",
    17,
    "controlDC2",
    18,
    "controlDC3",
    19,
    "controlDC4",
    20,
    "controlDEL",
    127,
    "controlDLE",
    16,
    "controlEM",
    25,
    "controlENQ",
    5,
    "controlEOT",
    4,
    "controlESC",
    27,
    "controlETB",
    23,
    "controlETX",
    3,
    "controlFF",
    12,
    "controlFS",
    28,
    "controlGS",
    29,
    "controlHT",
    9,
    "controlLF",
    10,
    "controlNAK",
    21,
    "controlNULL",
    0,
    // Glyph is missing from Adobe's original list.
    "controlRS",
    30,
    "controlSI",
    15,
    "controlSO",
    14,
    "controlSOT",
    2,
    "controlSTX",
    1,
    "controlSUB",
    26,
    "controlSYN",
    22,
    "controlUS",
    31,
    "controlVT",
    11,
    "copyright",
    169,
    "copyrightsans",
    63721,
    "copyrightserif",
    63193,
    "cornerbracketleft",
    12300,
    "cornerbracketlefthalfwidth",
    65378,
    "cornerbracketleftvertical",
    65089,
    "cornerbracketright",
    12301,
    "cornerbracketrighthalfwidth",
    65379,
    "cornerbracketrightvertical",
    65090,
    "corporationsquare",
    13183,
    "cosquare",
    13255,
    "coverkgsquare",
    13254,
    "cparen",
    9374,
    "cruzeiro",
    8354,
    "cstretched",
    663,
    "curlyand",
    8911,
    "curlyor",
    8910,
    "currency",
    164,
    "cyrBreve",
    63185,
    "cyrFlex",
    63186,
    "cyrbreve",
    63188,
    "cyrflex",
    63189,
    "d",
    100,
    "daarmenian",
    1380,
    "dabengali",
    2470,
    "dadarabic",
    1590,
    "dadeva",
    2342,
    "dadfinalarabic",
    65214,
    "dadinitialarabic",
    65215,
    "dadmedialarabic",
    65216,
    "dagesh",
    1468,
    "dageshhebrew",
    1468,
    "dagger",
    8224,
    "daggerdbl",
    8225,
    "dagujarati",
    2726,
    "dagurmukhi",
    2598,
    "dahiragana",
    12384,
    "dakatakana",
    12480,
    "dalarabic",
    1583,
    "dalet",
    1491,
    "daletdagesh",
    64307,
    "daletdageshhebrew",
    64307,
    "dalethebrew",
    1491,
    "dalfinalarabic",
    65194,
    "dammaarabic",
    1615,
    "dammalowarabic",
    1615,
    "dammatanaltonearabic",
    1612,
    "dammatanarabic",
    1612,
    "danda",
    2404,
    "dargahebrew",
    1447,
    "dargalefthebrew",
    1447,
    "dasiapneumatacyrilliccmb",
    1157,
    "dblGrave",
    63187,
    "dblanglebracketleft",
    12298,
    "dblanglebracketleftvertical",
    65085,
    "dblanglebracketright",
    12299,
    "dblanglebracketrightvertical",
    65086,
    "dblarchinvertedbelowcmb",
    811,
    "dblarrowleft",
    8660,
    "dblarrowright",
    8658,
    "dbldanda",
    2405,
    "dblgrave",
    63190,
    "dblgravecmb",
    783,
    "dblintegral",
    8748,
    "dbllowline",
    8215,
    "dbllowlinecmb",
    819,
    "dbloverlinecmb",
    831,
    "dblprimemod",
    698,
    "dblverticalbar",
    8214,
    "dblverticallineabovecmb",
    782,
    "dbopomofo",
    12553,
    "dbsquare",
    13256,
    "dcaron",
    271,
    "dcedilla",
    7697,
    "dcircle",
    9427,
    "dcircumflexbelow",
    7699,
    "dcroat",
    273,
    "ddabengali",
    2465,
    "ddadeva",
    2337,
    "ddagujarati",
    2721,
    "ddagurmukhi",
    2593,
    "ddalarabic",
    1672,
    "ddalfinalarabic",
    64393,
    "dddhadeva",
    2396,
    "ddhabengali",
    2466,
    "ddhadeva",
    2338,
    "ddhagujarati",
    2722,
    "ddhagurmukhi",
    2594,
    "ddotaccent",
    7691,
    "ddotbelow",
    7693,
    "decimalseparatorarabic",
    1643,
    "decimalseparatorpersian",
    1643,
    "decyrillic",
    1076,
    "degree",
    176,
    "dehihebrew",
    1453,
    "dehiragana",
    12391,
    "deicoptic",
    1007,
    "dekatakana",
    12487,
    "deleteleft",
    9003,
    "deleteright",
    8998,
    "delta",
    948,
    "deltaturned",
    397,
    "denominatorminusonenumeratorbengali",
    2552,
    "dezh",
    676,
    "dhabengali",
    2471,
    "dhadeva",
    2343,
    "dhagujarati",
    2727,
    "dhagurmukhi",
    2599,
    "dhook",
    599,
    "dialytikatonos",
    901,
    "dialytikatonoscmb",
    836,
    "diamond",
    9830,
    "diamondsuitwhite",
    9826,
    "dieresis",
    168,
    "dieresisacute",
    63191,
    "dieresisbelowcmb",
    804,
    "dieresiscmb",
    776,
    "dieresisgrave",
    63192,
    "dieresistonos",
    901,
    "dihiragana",
    12386,
    "dikatakana",
    12482,
    "dittomark",
    12291,
    "divide",
    247,
    "divides",
    8739,
    "divisionslash",
    8725,
    "djecyrillic",
    1106,
    "dkshade",
    9619,
    "dlinebelow",
    7695,
    "dlsquare",
    13207,
    "dmacron",
    273,
    "dmonospace",
    65348,
    "dnblock",
    9604,
    "dochadathai",
    3598,
    "dodekthai",
    3604,
    "dohiragana",
    12393,
    "dokatakana",
    12489,
    "dollar",
    36,
    "dollarinferior",
    63203,
    "dollarmonospace",
    65284,
    "dollaroldstyle",
    63268,
    "dollarsmall",
    65129,
    "dollarsuperior",
    63204,
    "dong",
    8363,
    "dorusquare",
    13094,
    "dotaccent",
    729,
    "dotaccentcmb",
    775,
    "dotbelowcmb",
    803,
    "dotbelowcomb",
    803,
    "dotkatakana",
    12539,
    "dotlessi",
    305,
    "dotlessj",
    63166,
    "dotlessjstrokehook",
    644,
    "dotmath",
    8901,
    "dottedcircle",
    9676,
    "doubleyodpatah",
    64287,
    "doubleyodpatahhebrew",
    64287,
    "downtackbelowcmb",
    798,
    "downtackmod",
    725,
    "dparen",
    9375,
    "dsuperior",
    63211,
    "dtail",
    598,
    "dtopbar",
    396,
    "duhiragana",
    12389,
    "dukatakana",
    12485,
    "dz",
    499,
    "dzaltone",
    675,
    "dzcaron",
    454,
    "dzcurl",
    677,
    "dzeabkhasiancyrillic",
    1249,
    "dzecyrillic",
    1109,
    "dzhecyrillic",
    1119,
    "e",
    101,
    "eacute",
    233,
    "earth",
    9793,
    "ebengali",
    2447,
    "ebopomofo",
    12572,
    "ebreve",
    277,
    "ecandradeva",
    2317,
    "ecandragujarati",
    2701,
    "ecandravowelsigndeva",
    2373,
    "ecandravowelsigngujarati",
    2757,
    "ecaron",
    283,
    "ecedillabreve",
    7709,
    "echarmenian",
    1381,
    "echyiwnarmenian",
    1415,
    "ecircle",
    9428,
    "ecircumflex",
    234,
    "ecircumflexacute",
    7871,
    "ecircumflexbelow",
    7705,
    "ecircumflexdotbelow",
    7879,
    "ecircumflexgrave",
    7873,
    "ecircumflexhookabove",
    7875,
    "ecircumflextilde",
    7877,
    "ecyrillic",
    1108,
    "edblgrave",
    517,
    "edeva",
    2319,
    "edieresis",
    235,
    "edot",
    279,
    "edotaccent",
    279,
    "edotbelow",
    7865,
    "eegurmukhi",
    2575,
    "eematragurmukhi",
    2631,
    "efcyrillic",
    1092,
    "egrave",
    232,
    "egujarati",
    2703,
    "eharmenian",
    1383,
    "ehbopomofo",
    12573,
    "ehiragana",
    12360,
    "ehookabove",
    7867,
    "eibopomofo",
    12575,
    "eight",
    56,
    "eightarabic",
    1640,
    "eightbengali",
    2542,
    "eightcircle",
    9319,
    "eightcircleinversesansserif",
    10129,
    "eightdeva",
    2414,
    "eighteencircle",
    9329,
    "eighteenparen",
    9349,
    "eighteenperiod",
    9369,
    "eightgujarati",
    2798,
    "eightgurmukhi",
    2670,
    "eighthackarabic",
    1640,
    "eighthangzhou",
    12328,
    "eighthnotebeamed",
    9835,
    "eightideographicparen",
    12839,
    "eightinferior",
    8328,
    "eightmonospace",
    65304,
    "eightoldstyle",
    63288,
    "eightparen",
    9339,
    "eightperiod",
    9359,
    "eightpersian",
    1784,
    "eightroman",
    8567,
    "eightsuperior",
    8312,
    "eightthai",
    3672,
    "einvertedbreve",
    519,
    "eiotifiedcyrillic",
    1125,
    "ekatakana",
    12456,
    "ekatakanahalfwidth",
    65396,
    "ekonkargurmukhi",
    2676,
    "ekorean",
    12628,
    "elcyrillic",
    1083,
    "element",
    8712,
    "elevencircle",
    9322,
    "elevenparen",
    9342,
    "elevenperiod",
    9362,
    "elevenroman",
    8570,
    "ellipsis",
    8230,
    "ellipsisvertical",
    8942,
    "emacron",
    275,
    "emacronacute",
    7703,
    "emacrongrave",
    7701,
    "emcyrillic",
    1084,
    "emdash",
    8212,
    "emdashvertical",
    65073,
    "emonospace",
    65349,
    "emphasismarkarmenian",
    1371,
    "emptyset",
    8709,
    "enbopomofo",
    12579,
    "encyrillic",
    1085,
    "endash",
    8211,
    "endashvertical",
    65074,
    "endescendercyrillic",
    1187,
    "eng",
    331,
    "engbopomofo",
    12581,
    "enghecyrillic",
    1189,
    "enhookcyrillic",
    1224,
    "enspace",
    8194,
    "eogonek",
    281,
    "eokorean",
    12627,
    "eopen",
    603,
    "eopenclosed",
    666,
    "eopenreversed",
    604,
    "eopenreversedclosed",
    606,
    "eopenreversedhook",
    605,
    "eparen",
    9376,
    "epsilon",
    949,
    "epsilontonos",
    941,
    "equal",
    61,
    "equalmonospace",
    65309,
    "equalsmall",
    65126,
    "equalsuperior",
    8316,
    "equivalence",
    8801,
    "erbopomofo",
    12582,
    "ercyrillic",
    1088,
    "ereversed",
    600,
    "ereversedcyrillic",
    1101,
    "escyrillic",
    1089,
    "esdescendercyrillic",
    1195,
    "esh",
    643,
    "eshcurl",
    646,
    "eshortdeva",
    2318,
    "eshortvowelsigndeva",
    2374,
    "eshreversedloop",
    426,
    "eshsquatreversed",
    645,
    "esmallhiragana",
    12359,
    "esmallkatakana",
    12455,
    "esmallkatakanahalfwidth",
    65386,
    "estimated",
    8494,
    "esuperior",
    63212,
    "eta",
    951,
    "etarmenian",
    1384,
    "etatonos",
    942,
    "eth",
    240,
    "etilde",
    7869,
    "etildebelow",
    7707,
    "etnahtafoukhhebrew",
    1425,
    "etnahtafoukhlefthebrew",
    1425,
    "etnahtahebrew",
    1425,
    "etnahtalefthebrew",
    1425,
    "eturned",
    477,
    "eukorean",
    12641,
    "euro",
    8364,
    "evowelsignbengali",
    2503,
    "evowelsigndeva",
    2375,
    "evowelsigngujarati",
    2759,
    "exclam",
    33,
    "exclamarmenian",
    1372,
    "exclamdbl",
    8252,
    "exclamdown",
    161,
    "exclamdownsmall",
    63393,
    "exclammonospace",
    65281,
    "exclamsmall",
    63265,
    "existential",
    8707,
    "ezh",
    658,
    "ezhcaron",
    495,
    "ezhcurl",
    659,
    "ezhreversed",
    441,
    "ezhtail",
    442,
    "f",
    102,
    "fadeva",
    2398,
    "fagurmukhi",
    2654,
    "fahrenheit",
    8457,
    "fathaarabic",
    1614,
    "fathalowarabic",
    1614,
    "fathatanarabic",
    1611,
    "fbopomofo",
    12552,
    "fcircle",
    9429,
    "fdotaccent",
    7711,
    "feharabic",
    1601,
    "feharmenian",
    1414,
    "fehfinalarabic",
    65234,
    "fehinitialarabic",
    65235,
    "fehmedialarabic",
    65236,
    "feicoptic",
    997,
    "female",
    9792,
    "ff",
    64256,
    "f_f",
    64256,
    // Fixes issue 11016.
    "ffi",
    64259,
    "ffl",
    64260,
    "fi",
    64257,
    "fifteencircle",
    9326,
    "fifteenparen",
    9346,
    "fifteenperiod",
    9366,
    "figuredash",
    8210,
    "filledbox",
    9632,
    "filledrect",
    9644,
    "finalkaf",
    1498,
    "finalkafdagesh",
    64314,
    "finalkafdageshhebrew",
    64314,
    "finalkafhebrew",
    1498,
    "finalmem",
    1501,
    "finalmemhebrew",
    1501,
    "finalnun",
    1503,
    "finalnunhebrew",
    1503,
    "finalpe",
    1507,
    "finalpehebrew",
    1507,
    "finaltsadi",
    1509,
    "finaltsadihebrew",
    1509,
    "firsttonechinese",
    713,
    "fisheye",
    9673,
    "fitacyrillic",
    1139,
    "five",
    53,
    "fivearabic",
    1637,
    "fivebengali",
    2539,
    "fivecircle",
    9316,
    "fivecircleinversesansserif",
    10126,
    "fivedeva",
    2411,
    "fiveeighths",
    8541,
    "fivegujarati",
    2795,
    "fivegurmukhi",
    2667,
    "fivehackarabic",
    1637,
    "fivehangzhou",
    12325,
    "fiveideographicparen",
    12836,
    "fiveinferior",
    8325,
    "fivemonospace",
    65301,
    "fiveoldstyle",
    63285,
    "fiveparen",
    9336,
    "fiveperiod",
    9356,
    "fivepersian",
    1781,
    "fiveroman",
    8564,
    "fivesuperior",
    8309,
    "fivethai",
    3669,
    "fl",
    64258,
    "florin",
    402,
    "fmonospace",
    65350,
    "fmsquare",
    13209,
    "fofanthai",
    3615,
    "fofathai",
    3613,
    "fongmanthai",
    3663,
    "forall",
    8704,
    "four",
    52,
    "fourarabic",
    1636,
    "fourbengali",
    2538,
    "fourcircle",
    9315,
    "fourcircleinversesansserif",
    10125,
    "fourdeva",
    2410,
    "fourgujarati",
    2794,
    "fourgurmukhi",
    2666,
    "fourhackarabic",
    1636,
    "fourhangzhou",
    12324,
    "fourideographicparen",
    12835,
    "fourinferior",
    8324,
    "fourmonospace",
    65300,
    "fournumeratorbengali",
    2551,
    "fouroldstyle",
    63284,
    "fourparen",
    9335,
    "fourperiod",
    9355,
    "fourpersian",
    1780,
    "fourroman",
    8563,
    "foursuperior",
    8308,
    "fourteencircle",
    9325,
    "fourteenparen",
    9345,
    "fourteenperiod",
    9365,
    "fourthai",
    3668,
    "fourthtonechinese",
    715,
    "fparen",
    9377,
    "fraction",
    8260,
    "franc",
    8355,
    "g",
    103,
    "gabengali",
    2455,
    "gacute",
    501,
    "gadeva",
    2327,
    "gafarabic",
    1711,
    "gaffinalarabic",
    64403,
    "gafinitialarabic",
    64404,
    "gafmedialarabic",
    64405,
    "gagujarati",
    2711,
    "gagurmukhi",
    2583,
    "gahiragana",
    12364,
    "gakatakana",
    12460,
    "gamma",
    947,
    "gammalatinsmall",
    611,
    "gammasuperior",
    736,
    "gangiacoptic",
    1003,
    "gbopomofo",
    12557,
    "gbreve",
    287,
    "gcaron",
    487,
    "gcedilla",
    291,
    "gcircle",
    9430,
    "gcircumflex",
    285,
    "gcommaaccent",
    291,
    "gdot",
    289,
    "gdotaccent",
    289,
    "gecyrillic",
    1075,
    "gehiragana",
    12370,
    "gekatakana",
    12466,
    "geometricallyequal",
    8785,
    "gereshaccenthebrew",
    1436,
    "gereshhebrew",
    1523,
    "gereshmuqdamhebrew",
    1437,
    "germandbls",
    223,
    "gershayimaccenthebrew",
    1438,
    "gershayimhebrew",
    1524,
    "getamark",
    12307,
    "ghabengali",
    2456,
    "ghadarmenian",
    1394,
    "ghadeva",
    2328,
    "ghagujarati",
    2712,
    "ghagurmukhi",
    2584,
    "ghainarabic",
    1594,
    "ghainfinalarabic",
    65230,
    "ghaininitialarabic",
    65231,
    "ghainmedialarabic",
    65232,
    "ghemiddlehookcyrillic",
    1173,
    "ghestrokecyrillic",
    1171,
    "gheupturncyrillic",
    1169,
    "ghhadeva",
    2394,
    "ghhagurmukhi",
    2650,
    "ghook",
    608,
    "ghzsquare",
    13203,
    "gihiragana",
    12366,
    "gikatakana",
    12462,
    "gimarmenian",
    1379,
    "gimel",
    1490,
    "gimeldagesh",
    64306,
    "gimeldageshhebrew",
    64306,
    "gimelhebrew",
    1490,
    "gjecyrillic",
    1107,
    "glottalinvertedstroke",
    446,
    "glottalstop",
    660,
    "glottalstopinverted",
    662,
    "glottalstopmod",
    704,
    "glottalstopreversed",
    661,
    "glottalstopreversedmod",
    705,
    "glottalstopreversedsuperior",
    740,
    "glottalstopstroke",
    673,
    "glottalstopstrokereversed",
    674,
    "gmacron",
    7713,
    "gmonospace",
    65351,
    "gohiragana",
    12372,
    "gokatakana",
    12468,
    "gparen",
    9378,
    "gpasquare",
    13228,
    "gradient",
    8711,
    "grave",
    96,
    "gravebelowcmb",
    790,
    "gravecmb",
    768,
    "gravecomb",
    768,
    "gravedeva",
    2387,
    "gravelowmod",
    718,
    "gravemonospace",
    65344,
    "gravetonecmb",
    832,
    "greater",
    62,
    "greaterequal",
    8805,
    "greaterequalorless",
    8923,
    "greatermonospace",
    65310,
    "greaterorequivalent",
    8819,
    "greaterorless",
    8823,
    "greateroverequal",
    8807,
    "greatersmall",
    65125,
    "gscript",
    609,
    "gstroke",
    485,
    "guhiragana",
    12368,
    "guillemotleft",
    171,
    "guillemotright",
    187,
    "guilsinglleft",
    8249,
    "guilsinglright",
    8250,
    "gukatakana",
    12464,
    "guramusquare",
    13080,
    "gysquare",
    13257,
    "h",
    104,
    "haabkhasiancyrillic",
    1193,
    "haaltonearabic",
    1729,
    "habengali",
    2489,
    "hadescendercyrillic",
    1203,
    "hadeva",
    2361,
    "hagujarati",
    2745,
    "hagurmukhi",
    2617,
    "haharabic",
    1581,
    "hahfinalarabic",
    65186,
    "hahinitialarabic",
    65187,
    "hahiragana",
    12399,
    "hahmedialarabic",
    65188,
    "haitusquare",
    13098,
    "hakatakana",
    12495,
    "hakatakanahalfwidth",
    65418,
    "halantgurmukhi",
    2637,
    "hamzaarabic",
    1569,
    "hamzalowarabic",
    1569,
    "hangulfiller",
    12644,
    "hardsigncyrillic",
    1098,
    "harpoonleftbarbup",
    8636,
    "harpoonrightbarbup",
    8640,
    "hasquare",
    13258,
    "hatafpatah",
    1458,
    "hatafpatah16",
    1458,
    "hatafpatah23",
    1458,
    "hatafpatah2f",
    1458,
    "hatafpatahhebrew",
    1458,
    "hatafpatahnarrowhebrew",
    1458,
    "hatafpatahquarterhebrew",
    1458,
    "hatafpatahwidehebrew",
    1458,
    "hatafqamats",
    1459,
    "hatafqamats1b",
    1459,
    "hatafqamats28",
    1459,
    "hatafqamats34",
    1459,
    "hatafqamatshebrew",
    1459,
    "hatafqamatsnarrowhebrew",
    1459,
    "hatafqamatsquarterhebrew",
    1459,
    "hatafqamatswidehebrew",
    1459,
    "hatafsegol",
    1457,
    "hatafsegol17",
    1457,
    "hatafsegol24",
    1457,
    "hatafsegol30",
    1457,
    "hatafsegolhebrew",
    1457,
    "hatafsegolnarrowhebrew",
    1457,
    "hatafsegolquarterhebrew",
    1457,
    "hatafsegolwidehebrew",
    1457,
    "hbar",
    295,
    "hbopomofo",
    12559,
    "hbrevebelow",
    7723,
    "hcedilla",
    7721,
    "hcircle",
    9431,
    "hcircumflex",
    293,
    "hdieresis",
    7719,
    "hdotaccent",
    7715,
    "hdotbelow",
    7717,
    "he",
    1492,
    "heart",
    9829,
    "heartsuitblack",
    9829,
    "heartsuitwhite",
    9825,
    "hedagesh",
    64308,
    "hedageshhebrew",
    64308,
    "hehaltonearabic",
    1729,
    "heharabic",
    1607,
    "hehebrew",
    1492,
    "hehfinalaltonearabic",
    64423,
    "hehfinalalttwoarabic",
    65258,
    "hehfinalarabic",
    65258,
    "hehhamzaabovefinalarabic",
    64421,
    "hehhamzaaboveisolatedarabic",
    64420,
    "hehinitialaltonearabic",
    64424,
    "hehinitialarabic",
    65259,
    "hehiragana",
    12408,
    "hehmedialaltonearabic",
    64425,
    "hehmedialarabic",
    65260,
    "heiseierasquare",
    13179,
    "hekatakana",
    12504,
    "hekatakanahalfwidth",
    65421,
    "hekutaarusquare",
    13110,
    "henghook",
    615,
    "herutusquare",
    13113,
    "het",
    1495,
    "hethebrew",
    1495,
    "hhook",
    614,
    "hhooksuperior",
    689,
    "hieuhacirclekorean",
    12923,
    "hieuhaparenkorean",
    12827,
    "hieuhcirclekorean",
    12909,
    "hieuhkorean",
    12622,
    "hieuhparenkorean",
    12813,
    "hihiragana",
    12402,
    "hikatakana",
    12498,
    "hikatakanahalfwidth",
    65419,
    "hiriq",
    1460,
    "hiriq14",
    1460,
    "hiriq21",
    1460,
    "hiriq2d",
    1460,
    "hiriqhebrew",
    1460,
    "hiriqnarrowhebrew",
    1460,
    "hiriqquarterhebrew",
    1460,
    "hiriqwidehebrew",
    1460,
    "hlinebelow",
    7830,
    "hmonospace",
    65352,
    "hoarmenian",
    1392,
    "hohipthai",
    3627,
    "hohiragana",
    12411,
    "hokatakana",
    12507,
    "hokatakanahalfwidth",
    65422,
    "holam",
    1465,
    "holam19",
    1465,
    "holam26",
    1465,
    "holam32",
    1465,
    "holamhebrew",
    1465,
    "holamnarrowhebrew",
    1465,
    "holamquarterhebrew",
    1465,
    "holamwidehebrew",
    1465,
    "honokhukthai",
    3630,
    "hookabovecomb",
    777,
    "hookcmb",
    777,
    "hookpalatalizedbelowcmb",
    801,
    "hookretroflexbelowcmb",
    802,
    "hoonsquare",
    13122,
    "horicoptic",
    1001,
    "horizontalbar",
    8213,
    "horncmb",
    795,
    "hotsprings",
    9832,
    "house",
    8962,
    "hparen",
    9379,
    "hsuperior",
    688,
    "hturned",
    613,
    "huhiragana",
    12405,
    "huiitosquare",
    13107,
    "hukatakana",
    12501,
    "hukatakanahalfwidth",
    65420,
    "hungarumlaut",
    733,
    "hungarumlautcmb",
    779,
    "hv",
    405,
    "hyphen",
    45,
    "hypheninferior",
    63205,
    "hyphenmonospace",
    65293,
    "hyphensmall",
    65123,
    "hyphensuperior",
    63206,
    "hyphentwo",
    8208,
    "i",
    105,
    "iacute",
    237,
    "iacyrillic",
    1103,
    "ibengali",
    2439,
    "ibopomofo",
    12583,
    "ibreve",
    301,
    "icaron",
    464,
    "icircle",
    9432,
    "icircumflex",
    238,
    "icyrillic",
    1110,
    "idblgrave",
    521,
    "ideographearthcircle",
    12943,
    "ideographfirecircle",
    12939,
    "ideographicallianceparen",
    12863,
    "ideographiccallparen",
    12858,
    "ideographiccentrecircle",
    12965,
    "ideographicclose",
    12294,
    "ideographiccomma",
    12289,
    "ideographiccommaleft",
    65380,
    "ideographiccongratulationparen",
    12855,
    "ideographiccorrectcircle",
    12963,
    "ideographicearthparen",
    12847,
    "ideographicenterpriseparen",
    12861,
    "ideographicexcellentcircle",
    12957,
    "ideographicfestivalparen",
    12864,
    "ideographicfinancialcircle",
    12950,
    "ideographicfinancialparen",
    12854,
    "ideographicfireparen",
    12843,
    "ideographichaveparen",
    12850,
    "ideographichighcircle",
    12964,
    "ideographiciterationmark",
    12293,
    "ideographiclaborcircle",
    12952,
    "ideographiclaborparen",
    12856,
    "ideographicleftcircle",
    12967,
    "ideographiclowcircle",
    12966,
    "ideographicmedicinecircle",
    12969,
    "ideographicmetalparen",
    12846,
    "ideographicmoonparen",
    12842,
    "ideographicnameparen",
    12852,
    "ideographicperiod",
    12290,
    "ideographicprintcircle",
    12958,
    "ideographicreachparen",
    12867,
    "ideographicrepresentparen",
    12857,
    "ideographicresourceparen",
    12862,
    "ideographicrightcircle",
    12968,
    "ideographicsecretcircle",
    12953,
    "ideographicselfparen",
    12866,
    "ideographicsocietyparen",
    12851,
    "ideographicspace",
    12288,
    "ideographicspecialparen",
    12853,
    "ideographicstockparen",
    12849,
    "ideographicstudyparen",
    12859,
    "ideographicsunparen",
    12848,
    "ideographicsuperviseparen",
    12860,
    "ideographicwaterparen",
    12844,
    "ideographicwoodparen",
    12845,
    "ideographiczero",
    12295,
    "ideographmetalcircle",
    12942,
    "ideographmooncircle",
    12938,
    "ideographnamecircle",
    12948,
    "ideographsuncircle",
    12944,
    "ideographwatercircle",
    12940,
    "ideographwoodcircle",
    12941,
    "ideva",
    2311,
    "idieresis",
    239,
    "idieresisacute",
    7727,
    "idieresiscyrillic",
    1253,
    "idotbelow",
    7883,
    "iebrevecyrillic",
    1239,
    "iecyrillic",
    1077,
    "ieungacirclekorean",
    12917,
    "ieungaparenkorean",
    12821,
    "ieungcirclekorean",
    12903,
    "ieungkorean",
    12615,
    "ieungparenkorean",
    12807,
    "igrave",
    236,
    "igujarati",
    2695,
    "igurmukhi",
    2567,
    "ihiragana",
    12356,
    "ihookabove",
    7881,
    "iibengali",
    2440,
    "iicyrillic",
    1080,
    "iideva",
    2312,
    "iigujarati",
    2696,
    "iigurmukhi",
    2568,
    "iimatragurmukhi",
    2624,
    "iinvertedbreve",
    523,
    "iishortcyrillic",
    1081,
    "iivowelsignbengali",
    2496,
    "iivowelsigndeva",
    2368,
    "iivowelsigngujarati",
    2752,
    "ij",
    307,
    "ikatakana",
    12452,
    "ikatakanahalfwidth",
    65394,
    "ikorean",
    12643,
    "ilde",
    732,
    "iluyhebrew",
    1452,
    "imacron",
    299,
    "imacroncyrillic",
    1251,
    "imageorapproximatelyequal",
    8787,
    "imatragurmukhi",
    2623,
    "imonospace",
    65353,
    "increment",
    8710,
    "infinity",
    8734,
    "iniarmenian",
    1387,
    "integral",
    8747,
    "integralbottom",
    8993,
    "integralbt",
    8993,
    "integralex",
    63733,
    "integraltop",
    8992,
    "integraltp",
    8992,
    "intersection",
    8745,
    "intisquare",
    13061,
    "invbullet",
    9688,
    "invcircle",
    9689,
    "invsmileface",
    9787,
    "iocyrillic",
    1105,
    "iogonek",
    303,
    "iota",
    953,
    "iotadieresis",
    970,
    "iotadieresistonos",
    912,
    "iotalatin",
    617,
    "iotatonos",
    943,
    "iparen",
    9380,
    "irigurmukhi",
    2674,
    "ismallhiragana",
    12355,
    "ismallkatakana",
    12451,
    "ismallkatakanahalfwidth",
    65384,
    "issharbengali",
    2554,
    "istroke",
    616,
    "isuperior",
    63213,
    "iterationhiragana",
    12445,
    "iterationkatakana",
    12541,
    "itilde",
    297,
    "itildebelow",
    7725,
    "iubopomofo",
    12585,
    "iucyrillic",
    1102,
    "ivowelsignbengali",
    2495,
    "ivowelsigndeva",
    2367,
    "ivowelsigngujarati",
    2751,
    "izhitsacyrillic",
    1141,
    "izhitsadblgravecyrillic",
    1143,
    "j",
    106,
    "jaarmenian",
    1393,
    "jabengali",
    2460,
    "jadeva",
    2332,
    "jagujarati",
    2716,
    "jagurmukhi",
    2588,
    "jbopomofo",
    12560,
    "jcaron",
    496,
    "jcircle",
    9433,
    "jcircumflex",
    309,
    "jcrossedtail",
    669,
    "jdotlessstroke",
    607,
    "jecyrillic",
    1112,
    "jeemarabic",
    1580,
    "jeemfinalarabic",
    65182,
    "jeeminitialarabic",
    65183,
    "jeemmedialarabic",
    65184,
    "jeharabic",
    1688,
    "jehfinalarabic",
    64395,
    "jhabengali",
    2461,
    "jhadeva",
    2333,
    "jhagujarati",
    2717,
    "jhagurmukhi",
    2589,
    "jheharmenian",
    1403,
    "jis",
    12292,
    "jmonospace",
    65354,
    "jparen",
    9381,
    "jsuperior",
    690,
    "k",
    107,
    "kabashkircyrillic",
    1185,
    "kabengali",
    2453,
    "kacute",
    7729,
    "kacyrillic",
    1082,
    "kadescendercyrillic",
    1179,
    "kadeva",
    2325,
    "kaf",
    1499,
    "kafarabic",
    1603,
    "kafdagesh",
    64315,
    "kafdageshhebrew",
    64315,
    "kaffinalarabic",
    65242,
    "kafhebrew",
    1499,
    "kafinitialarabic",
    65243,
    "kafmedialarabic",
    65244,
    "kafrafehebrew",
    64333,
    "kagujarati",
    2709,
    "kagurmukhi",
    2581,
    "kahiragana",
    12363,
    "kahookcyrillic",
    1220,
    "kakatakana",
    12459,
    "kakatakanahalfwidth",
    65398,
    "kappa",
    954,
    "kappasymbolgreek",
    1008,
    "kapyeounmieumkorean",
    12657,
    "kapyeounphieuphkorean",
    12676,
    "kapyeounpieupkorean",
    12664,
    "kapyeounssangpieupkorean",
    12665,
    "karoriisquare",
    13069,
    "kashidaautoarabic",
    1600,
    "kashidaautonosidebearingarabic",
    1600,
    "kasmallkatakana",
    12533,
    "kasquare",
    13188,
    "kasraarabic",
    1616,
    "kasratanarabic",
    1613,
    "kastrokecyrillic",
    1183,
    "katahiraprolongmarkhalfwidth",
    65392,
    "kaverticalstrokecyrillic",
    1181,
    "kbopomofo",
    12558,
    "kcalsquare",
    13193,
    "kcaron",
    489,
    "kcedilla",
    311,
    "kcircle",
    9434,
    "kcommaaccent",
    311,
    "kdotbelow",
    7731,
    "keharmenian",
    1412,
    "kehiragana",
    12369,
    "kekatakana",
    12465,
    "kekatakanahalfwidth",
    65401,
    "kenarmenian",
    1391,
    "kesmallkatakana",
    12534,
    "kgreenlandic",
    312,
    "khabengali",
    2454,
    "khacyrillic",
    1093,
    "khadeva",
    2326,
    "khagujarati",
    2710,
    "khagurmukhi",
    2582,
    "khaharabic",
    1582,
    "khahfinalarabic",
    65190,
    "khahinitialarabic",
    65191,
    "khahmedialarabic",
    65192,
    "kheicoptic",
    999,
    "khhadeva",
    2393,
    "khhagurmukhi",
    2649,
    "khieukhacirclekorean",
    12920,
    "khieukhaparenkorean",
    12824,
    "khieukhcirclekorean",
    12906,
    "khieukhkorean",
    12619,
    "khieukhparenkorean",
    12810,
    "khokhaithai",
    3586,
    "khokhonthai",
    3589,
    "khokhuatthai",
    3587,
    "khokhwaithai",
    3588,
    "khomutthai",
    3675,
    "khook",
    409,
    "khorakhangthai",
    3590,
    "khzsquare",
    13201,
    "kihiragana",
    12365,
    "kikatakana",
    12461,
    "kikatakanahalfwidth",
    65399,
    "kiroguramusquare",
    13077,
    "kiromeetorusquare",
    13078,
    "kirosquare",
    13076,
    "kiyeokacirclekorean",
    12910,
    "kiyeokaparenkorean",
    12814,
    "kiyeokcirclekorean",
    12896,
    "kiyeokkorean",
    12593,
    "kiyeokparenkorean",
    12800,
    "kiyeoksioskorean",
    12595,
    "kjecyrillic",
    1116,
    "klinebelow",
    7733,
    "klsquare",
    13208,
    "kmcubedsquare",
    13222,
    "kmonospace",
    65355,
    "kmsquaredsquare",
    13218,
    "kohiragana",
    12371,
    "kohmsquare",
    13248,
    "kokaithai",
    3585,
    "kokatakana",
    12467,
    "kokatakanahalfwidth",
    65402,
    "kooposquare",
    13086,
    "koppacyrillic",
    1153,
    "koreanstandardsymbol",
    12927,
    "koroniscmb",
    835,
    "kparen",
    9382,
    "kpasquare",
    13226,
    "ksicyrillic",
    1135,
    "ktsquare",
    13263,
    "kturned",
    670,
    "kuhiragana",
    12367,
    "kukatakana",
    12463,
    "kukatakanahalfwidth",
    65400,
    "kvsquare",
    13240,
    "kwsquare",
    13246,
    "l",
    108,
    "labengali",
    2482,
    "lacute",
    314,
    "ladeva",
    2354,
    "lagujarati",
    2738,
    "lagurmukhi",
    2610,
    "lakkhangyaothai",
    3653,
    "lamaleffinalarabic",
    65276,
    "lamalefhamzaabovefinalarabic",
    65272,
    "lamalefhamzaaboveisolatedarabic",
    65271,
    "lamalefhamzabelowfinalarabic",
    65274,
    "lamalefhamzabelowisolatedarabic",
    65273,
    "lamalefisolatedarabic",
    65275,
    "lamalefmaddaabovefinalarabic",
    65270,
    "lamalefmaddaaboveisolatedarabic",
    65269,
    "lamarabic",
    1604,
    "lambda",
    955,
    "lambdastroke",
    411,
    "lamed",
    1500,
    "lameddagesh",
    64316,
    "lameddageshhebrew",
    64316,
    "lamedhebrew",
    1500,
    "lamfinalarabic",
    65246,
    "lamhahinitialarabic",
    64714,
    "laminitialarabic",
    65247,
    "lamjeeminitialarabic",
    64713,
    "lamkhahinitialarabic",
    64715,
    "lamlamhehisolatedarabic",
    65010,
    "lammedialarabic",
    65248,
    "lammeemhahinitialarabic",
    64904,
    "lammeeminitialarabic",
    64716,
    "largecircle",
    9711,
    "lbar",
    410,
    "lbelt",
    620,
    "lbopomofo",
    12556,
    "lcaron",
    318,
    "lcedilla",
    316,
    "lcircle",
    9435,
    "lcircumflexbelow",
    7741,
    "lcommaaccent",
    316,
    "ldot",
    320,
    "ldotaccent",
    320,
    "ldotbelow",
    7735,
    "ldotbelowmacron",
    7737,
    "leftangleabovecmb",
    794,
    "lefttackbelowcmb",
    792,
    "less",
    60,
    "lessequal",
    8804,
    "lessequalorgreater",
    8922,
    "lessmonospace",
    65308,
    "lessorequivalent",
    8818,
    "lessorgreater",
    8822,
    "lessoverequal",
    8806,
    "lesssmall",
    65124,
    "lezh",
    622,
    "lfblock",
    9612,
    "lhookretroflex",
    621,
    "lira",
    8356,
    "liwnarmenian",
    1388,
    "lj",
    457,
    "ljecyrillic",
    1113,
    "ll",
    63168,
    "lladeva",
    2355,
    "llagujarati",
    2739,
    "llinebelow",
    7739,
    "llladeva",
    2356,
    "llvocalicbengali",
    2529,
    "llvocalicdeva",
    2401,
    "llvocalicvowelsignbengali",
    2531,
    "llvocalicvowelsigndeva",
    2403,
    "lmiddletilde",
    619,
    "lmonospace",
    65356,
    "lmsquare",
    13264,
    "lochulathai",
    3628,
    "logicaland",
    8743,
    "logicalnot",
    172,
    "logicalnotreversed",
    8976,
    "logicalor",
    8744,
    "lolingthai",
    3621,
    "longs",
    383,
    "lowlinecenterline",
    65102,
    "lowlinecmb",
    818,
    "lowlinedashed",
    65101,
    "lozenge",
    9674,
    "lparen",
    9383,
    "lslash",
    322,
    "lsquare",
    8467,
    "lsuperior",
    63214,
    "ltshade",
    9617,
    "luthai",
    3622,
    "lvocalicbengali",
    2444,
    "lvocalicdeva",
    2316,
    "lvocalicvowelsignbengali",
    2530,
    "lvocalicvowelsigndeva",
    2402,
    "lxsquare",
    13267,
    "m",
    109,
    "mabengali",
    2478,
    "macron",
    175,
    "macronbelowcmb",
    817,
    "macroncmb",
    772,
    "macronlowmod",
    717,
    "macronmonospace",
    65507,
    "macute",
    7743,
    "madeva",
    2350,
    "magujarati",
    2734,
    "magurmukhi",
    2606,
    "mahapakhhebrew",
    1444,
    "mahapakhlefthebrew",
    1444,
    "mahiragana",
    12414,
    "maichattawalowleftthai",
    63637,
    "maichattawalowrightthai",
    63636,
    "maichattawathai",
    3659,
    "maichattawaupperleftthai",
    63635,
    "maieklowleftthai",
    63628,
    "maieklowrightthai",
    63627,
    "maiekthai",
    3656,
    "maiekupperleftthai",
    63626,
    "maihanakatleftthai",
    63620,
    "maihanakatthai",
    3633,
    "maitaikhuleftthai",
    63625,
    "maitaikhuthai",
    3655,
    "maitholowleftthai",
    63631,
    "maitholowrightthai",
    63630,
    "maithothai",
    3657,
    "maithoupperleftthai",
    63629,
    "maitrilowleftthai",
    63634,
    "maitrilowrightthai",
    63633,
    "maitrithai",
    3658,
    "maitriupperleftthai",
    63632,
    "maiyamokthai",
    3654,
    "makatakana",
    12510,
    "makatakanahalfwidth",
    65423,
    "male",
    9794,
    "mansyonsquare",
    13127,
    "maqafhebrew",
    1470,
    "mars",
    9794,
    "masoracirclehebrew",
    1455,
    "masquare",
    13187,
    "mbopomofo",
    12551,
    "mbsquare",
    13268,
    "mcircle",
    9436,
    "mcubedsquare",
    13221,
    "mdotaccent",
    7745,
    "mdotbelow",
    7747,
    "meemarabic",
    1605,
    "meemfinalarabic",
    65250,
    "meeminitialarabic",
    65251,
    "meemmedialarabic",
    65252,
    "meemmeeminitialarabic",
    64721,
    "meemmeemisolatedarabic",
    64584,
    "meetorusquare",
    13133,
    "mehiragana",
    12417,
    "meizierasquare",
    13182,
    "mekatakana",
    12513,
    "mekatakanahalfwidth",
    65426,
    "mem",
    1502,
    "memdagesh",
    64318,
    "memdageshhebrew",
    64318,
    "memhebrew",
    1502,
    "menarmenian",
    1396,
    "merkhahebrew",
    1445,
    "merkhakefulahebrew",
    1446,
    "merkhakefulalefthebrew",
    1446,
    "merkhalefthebrew",
    1445,
    "mhook",
    625,
    "mhzsquare",
    13202,
    "middledotkatakanahalfwidth",
    65381,
    "middot",
    183,
    "mieumacirclekorean",
    12914,
    "mieumaparenkorean",
    12818,
    "mieumcirclekorean",
    12900,
    "mieumkorean",
    12609,
    "mieumpansioskorean",
    12656,
    "mieumparenkorean",
    12804,
    "mieumpieupkorean",
    12654,
    "mieumsioskorean",
    12655,
    "mihiragana",
    12415,
    "mikatakana",
    12511,
    "mikatakanahalfwidth",
    65424,
    "minus",
    8722,
    "minusbelowcmb",
    800,
    "minuscircle",
    8854,
    "minusmod",
    727,
    "minusplus",
    8723,
    "minute",
    8242,
    "miribaarusquare",
    13130,
    "mirisquare",
    13129,
    "mlonglegturned",
    624,
    "mlsquare",
    13206,
    "mmcubedsquare",
    13219,
    "mmonospace",
    65357,
    "mmsquaredsquare",
    13215,
    "mohiragana",
    12418,
    "mohmsquare",
    13249,
    "mokatakana",
    12514,
    "mokatakanahalfwidth",
    65427,
    "molsquare",
    13270,
    "momathai",
    3617,
    "moverssquare",
    13223,
    "moverssquaredsquare",
    13224,
    "mparen",
    9384,
    "mpasquare",
    13227,
    "mssquare",
    13235,
    "msuperior",
    63215,
    "mturned",
    623,
    "mu",
    181,
    "mu1",
    181,
    "muasquare",
    13186,
    "muchgreater",
    8811,
    "muchless",
    8810,
    "mufsquare",
    13196,
    "mugreek",
    956,
    "mugsquare",
    13197,
    "muhiragana",
    12416,
    "mukatakana",
    12512,
    "mukatakanahalfwidth",
    65425,
    "mulsquare",
    13205,
    "multiply",
    215,
    "mumsquare",
    13211,
    "munahhebrew",
    1443,
    "munahlefthebrew",
    1443,
    "musicalnote",
    9834,
    "musicalnotedbl",
    9835,
    "musicflatsign",
    9837,
    "musicsharpsign",
    9839,
    "mussquare",
    13234,
    "muvsquare",
    13238,
    "muwsquare",
    13244,
    "mvmegasquare",
    13241,
    "mvsquare",
    13239,
    "mwmegasquare",
    13247,
    "mwsquare",
    13245,
    "n",
    110,
    "nabengali",
    2472,
    "nabla",
    8711,
    "nacute",
    324,
    "nadeva",
    2344,
    "nagujarati",
    2728,
    "nagurmukhi",
    2600,
    "nahiragana",
    12394,
    "nakatakana",
    12490,
    "nakatakanahalfwidth",
    65413,
    "napostrophe",
    329,
    "nasquare",
    13185,
    "nbopomofo",
    12555,
    "nbspace",
    160,
    "ncaron",
    328,
    "ncedilla",
    326,
    "ncircle",
    9437,
    "ncircumflexbelow",
    7755,
    "ncommaaccent",
    326,
    "ndotaccent",
    7749,
    "ndotbelow",
    7751,
    "nehiragana",
    12397,
    "nekatakana",
    12493,
    "nekatakanahalfwidth",
    65416,
    "newsheqelsign",
    8362,
    "nfsquare",
    13195,
    "ngabengali",
    2457,
    "ngadeva",
    2329,
    "ngagujarati",
    2713,
    "ngagurmukhi",
    2585,
    "ngonguthai",
    3591,
    "nhiragana",
    12435,
    "nhookleft",
    626,
    "nhookretroflex",
    627,
    "nieunacirclekorean",
    12911,
    "nieunaparenkorean",
    12815,
    "nieuncieuckorean",
    12597,
    "nieuncirclekorean",
    12897,
    "nieunhieuhkorean",
    12598,
    "nieunkorean",
    12596,
    "nieunpansioskorean",
    12648,
    "nieunparenkorean",
    12801,
    "nieunsioskorean",
    12647,
    "nieuntikeutkorean",
    12646,
    "nihiragana",
    12395,
    "nikatakana",
    12491,
    "nikatakanahalfwidth",
    65414,
    "nikhahitleftthai",
    63641,
    "nikhahitthai",
    3661,
    "nine",
    57,
    "ninearabic",
    1641,
    "ninebengali",
    2543,
    "ninecircle",
    9320,
    "ninecircleinversesansserif",
    10130,
    "ninedeva",
    2415,
    "ninegujarati",
    2799,
    "ninegurmukhi",
    2671,
    "ninehackarabic",
    1641,
    "ninehangzhou",
    12329,
    "nineideographicparen",
    12840,
    "nineinferior",
    8329,
    "ninemonospace",
    65305,
    "nineoldstyle",
    63289,
    "nineparen",
    9340,
    "nineperiod",
    9360,
    "ninepersian",
    1785,
    "nineroman",
    8568,
    "ninesuperior",
    8313,
    "nineteencircle",
    9330,
    "nineteenparen",
    9350,
    "nineteenperiod",
    9370,
    "ninethai",
    3673,
    "nj",
    460,
    "njecyrillic",
    1114,
    "nkatakana",
    12531,
    "nkatakanahalfwidth",
    65437,
    "nlegrightlong",
    414,
    "nlinebelow",
    7753,
    "nmonospace",
    65358,
    "nmsquare",
    13210,
    "nnabengali",
    2467,
    "nnadeva",
    2339,
    "nnagujarati",
    2723,
    "nnagurmukhi",
    2595,
    "nnnadeva",
    2345,
    "nohiragana",
    12398,
    "nokatakana",
    12494,
    "nokatakanahalfwidth",
    65417,
    "nonbreakingspace",
    160,
    "nonenthai",
    3603,
    "nonuthai",
    3609,
    "noonarabic",
    1606,
    "noonfinalarabic",
    65254,
    "noonghunnaarabic",
    1722,
    "noonghunnafinalarabic",
    64415,
    "nooninitialarabic",
    65255,
    "noonjeeminitialarabic",
    64722,
    "noonjeemisolatedarabic",
    64587,
    "noonmedialarabic",
    65256,
    "noonmeeminitialarabic",
    64725,
    "noonmeemisolatedarabic",
    64590,
    "noonnoonfinalarabic",
    64653,
    "notcontains",
    8716,
    "notelement",
    8713,
    "notelementof",
    8713,
    "notequal",
    8800,
    "notgreater",
    8815,
    "notgreaternorequal",
    8817,
    "notgreaternorless",
    8825,
    "notidentical",
    8802,
    "notless",
    8814,
    "notlessnorequal",
    8816,
    "notparallel",
    8742,
    "notprecedes",
    8832,
    "notsubset",
    8836,
    "notsucceeds",
    8833,
    "notsuperset",
    8837,
    "nowarmenian",
    1398,
    "nparen",
    9385,
    "nssquare",
    13233,
    "nsuperior",
    8319,
    "ntilde",
    241,
    "nu",
    957,
    "nuhiragana",
    12396,
    "nukatakana",
    12492,
    "nukatakanahalfwidth",
    65415,
    "nuktabengali",
    2492,
    "nuktadeva",
    2364,
    "nuktagujarati",
    2748,
    "nuktagurmukhi",
    2620,
    "numbersign",
    35,
    "numbersignmonospace",
    65283,
    "numbersignsmall",
    65119,
    "numeralsigngreek",
    884,
    "numeralsignlowergreek",
    885,
    "numero",
    8470,
    "nun",
    1504,
    "nundagesh",
    64320,
    "nundageshhebrew",
    64320,
    "nunhebrew",
    1504,
    "nvsquare",
    13237,
    "nwsquare",
    13243,
    "nyabengali",
    2462,
    "nyadeva",
    2334,
    "nyagujarati",
    2718,
    "nyagurmukhi",
    2590,
    "o",
    111,
    "oacute",
    243,
    "oangthai",
    3629,
    "obarred",
    629,
    "obarredcyrillic",
    1257,
    "obarreddieresiscyrillic",
    1259,
    "obengali",
    2451,
    "obopomofo",
    12571,
    "obreve",
    335,
    "ocandradeva",
    2321,
    "ocandragujarati",
    2705,
    "ocandravowelsigndeva",
    2377,
    "ocandravowelsigngujarati",
    2761,
    "ocaron",
    466,
    "ocircle",
    9438,
    "ocircumflex",
    244,
    "ocircumflexacute",
    7889,
    "ocircumflexdotbelow",
    7897,
    "ocircumflexgrave",
    7891,
    "ocircumflexhookabove",
    7893,
    "ocircumflextilde",
    7895,
    "ocyrillic",
    1086,
    "odblacute",
    337,
    "odblgrave",
    525,
    "odeva",
    2323,
    "odieresis",
    246,
    "odieresiscyrillic",
    1255,
    "odotbelow",
    7885,
    "oe",
    339,
    "oekorean",
    12634,
    "ogonek",
    731,
    "ogonekcmb",
    808,
    "ograve",
    242,
    "ogujarati",
    2707,
    "oharmenian",
    1413,
    "ohiragana",
    12362,
    "ohookabove",
    7887,
    "ohorn",
    417,
    "ohornacute",
    7899,
    "ohorndotbelow",
    7907,
    "ohorngrave",
    7901,
    "ohornhookabove",
    7903,
    "ohorntilde",
    7905,
    "ohungarumlaut",
    337,
    "oi",
    419,
    "oinvertedbreve",
    527,
    "okatakana",
    12458,
    "okatakanahalfwidth",
    65397,
    "okorean",
    12631,
    "olehebrew",
    1451,
    "omacron",
    333,
    "omacronacute",
    7763,
    "omacrongrave",
    7761,
    "omdeva",
    2384,
    "omega",
    969,
    "omega1",
    982,
    "omegacyrillic",
    1121,
    "omegalatinclosed",
    631,
    "omegaroundcyrillic",
    1147,
    "omegatitlocyrillic",
    1149,
    "omegatonos",
    974,
    "omgujarati",
    2768,
    "omicron",
    959,
    "omicrontonos",
    972,
    "omonospace",
    65359,
    "one",
    49,
    "onearabic",
    1633,
    "onebengali",
    2535,
    "onecircle",
    9312,
    "onecircleinversesansserif",
    10122,
    "onedeva",
    2407,
    "onedotenleader",
    8228,
    "oneeighth",
    8539,
    "onefitted",
    63196,
    "onegujarati",
    2791,
    "onegurmukhi",
    2663,
    "onehackarabic",
    1633,
    "onehalf",
    189,
    "onehangzhou",
    12321,
    "oneideographicparen",
    12832,
    "oneinferior",
    8321,
    "onemonospace",
    65297,
    "onenumeratorbengali",
    2548,
    "oneoldstyle",
    63281,
    "oneparen",
    9332,
    "oneperiod",
    9352,
    "onepersian",
    1777,
    "onequarter",
    188,
    "oneroman",
    8560,
    "onesuperior",
    185,
    "onethai",
    3665,
    "onethird",
    8531,
    "oogonek",
    491,
    "oogonekmacron",
    493,
    "oogurmukhi",
    2579,
    "oomatragurmukhi",
    2635,
    "oopen",
    596,
    "oparen",
    9386,
    "openbullet",
    9702,
    "option",
    8997,
    "ordfeminine",
    170,
    "ordmasculine",
    186,
    "orthogonal",
    8735,
    "oshortdeva",
    2322,
    "oshortvowelsigndeva",
    2378,
    "oslash",
    248,
    "oslashacute",
    511,
    "osmallhiragana",
    12361,
    "osmallkatakana",
    12457,
    "osmallkatakanahalfwidth",
    65387,
    "ostrokeacute",
    511,
    "osuperior",
    63216,
    "otcyrillic",
    1151,
    "otilde",
    245,
    "otildeacute",
    7757,
    "otildedieresis",
    7759,
    "oubopomofo",
    12577,
    "overline",
    8254,
    "overlinecenterline",
    65098,
    "overlinecmb",
    773,
    "overlinedashed",
    65097,
    "overlinedblwavy",
    65100,
    "overlinewavy",
    65099,
    "overscore",
    175,
    "ovowelsignbengali",
    2507,
    "ovowelsigndeva",
    2379,
    "ovowelsigngujarati",
    2763,
    "p",
    112,
    "paampssquare",
    13184,
    "paasentosquare",
    13099,
    "pabengali",
    2474,
    "pacute",
    7765,
    "padeva",
    2346,
    "pagedown",
    8671,
    "pageup",
    8670,
    "pagujarati",
    2730,
    "pagurmukhi",
    2602,
    "pahiragana",
    12401,
    "paiyannoithai",
    3631,
    "pakatakana",
    12497,
    "palatalizationcyrilliccmb",
    1156,
    "palochkacyrillic",
    1216,
    "pansioskorean",
    12671,
    "paragraph",
    182,
    "parallel",
    8741,
    "parenleft",
    40,
    "parenleftaltonearabic",
    64830,
    "parenleftbt",
    63725,
    "parenleftex",
    63724,
    "parenleftinferior",
    8333,
    "parenleftmonospace",
    65288,
    "parenleftsmall",
    65113,
    "parenleftsuperior",
    8317,
    "parenlefttp",
    63723,
    "parenleftvertical",
    65077,
    "parenright",
    41,
    "parenrightaltonearabic",
    64831,
    "parenrightbt",
    63736,
    "parenrightex",
    63735,
    "parenrightinferior",
    8334,
    "parenrightmonospace",
    65289,
    "parenrightsmall",
    65114,
    "parenrightsuperior",
    8318,
    "parenrighttp",
    63734,
    "parenrightvertical",
    65078,
    "partialdiff",
    8706,
    "paseqhebrew",
    1472,
    "pashtahebrew",
    1433,
    "pasquare",
    13225,
    "patah",
    1463,
    "patah11",
    1463,
    "patah1d",
    1463,
    "patah2a",
    1463,
    "patahhebrew",
    1463,
    "patahnarrowhebrew",
    1463,
    "patahquarterhebrew",
    1463,
    "patahwidehebrew",
    1463,
    "pazerhebrew",
    1441,
    "pbopomofo",
    12550,
    "pcircle",
    9439,
    "pdotaccent",
    7767,
    "pe",
    1508,
    "pecyrillic",
    1087,
    "pedagesh",
    64324,
    "pedageshhebrew",
    64324,
    "peezisquare",
    13115,
    "pefinaldageshhebrew",
    64323,
    "peharabic",
    1662,
    "peharmenian",
    1402,
    "pehebrew",
    1508,
    "pehfinalarabic",
    64343,
    "pehinitialarabic",
    64344,
    "pehiragana",
    12410,
    "pehmedialarabic",
    64345,
    "pekatakana",
    12506,
    "pemiddlehookcyrillic",
    1191,
    "perafehebrew",
    64334,
    "percent",
    37,
    "percentarabic",
    1642,
    "percentmonospace",
    65285,
    "percentsmall",
    65130,
    "period",
    46,
    "periodarmenian",
    1417,
    "periodcentered",
    183,
    "periodhalfwidth",
    65377,
    "periodinferior",
    63207,
    "periodmonospace",
    65294,
    "periodsmall",
    65106,
    "periodsuperior",
    63208,
    "perispomenigreekcmb",
    834,
    "perpendicular",
    8869,
    "perthousand",
    8240,
    "peseta",
    8359,
    "pfsquare",
    13194,
    "phabengali",
    2475,
    "phadeva",
    2347,
    "phagujarati",
    2731,
    "phagurmukhi",
    2603,
    "phi",
    966,
    "phi1",
    981,
    "phieuphacirclekorean",
    12922,
    "phieuphaparenkorean",
    12826,
    "phieuphcirclekorean",
    12908,
    "phieuphkorean",
    12621,
    "phieuphparenkorean",
    12812,
    "philatin",
    632,
    "phinthuthai",
    3642,
    "phisymbolgreek",
    981,
    "phook",
    421,
    "phophanthai",
    3614,
    "phophungthai",
    3612,
    "phosamphaothai",
    3616,
    "pi",
    960,
    "pieupacirclekorean",
    12915,
    "pieupaparenkorean",
    12819,
    "pieupcieuckorean",
    12662,
    "pieupcirclekorean",
    12901,
    "pieupkiyeokkorean",
    12658,
    "pieupkorean",
    12610,
    "pieupparenkorean",
    12805,
    "pieupsioskiyeokkorean",
    12660,
    "pieupsioskorean",
    12612,
    "pieupsiostikeutkorean",
    12661,
    "pieupthieuthkorean",
    12663,
    "pieuptikeutkorean",
    12659,
    "pihiragana",
    12404,
    "pikatakana",
    12500,
    "pisymbolgreek",
    982,
    "piwrarmenian",
    1411,
    "plus",
    43,
    "plusbelowcmb",
    799,
    "pluscircle",
    8853,
    "plusminus",
    177,
    "plusmod",
    726,
    "plusmonospace",
    65291,
    "plussmall",
    65122,
    "plussuperior",
    8314,
    "pmonospace",
    65360,
    "pmsquare",
    13272,
    "pohiragana",
    12413,
    "pointingindexdownwhite",
    9759,
    "pointingindexleftwhite",
    9756,
    "pointingindexrightwhite",
    9758,
    "pointingindexupwhite",
    9757,
    "pokatakana",
    12509,
    "poplathai",
    3611,
    "postalmark",
    12306,
    "postalmarkface",
    12320,
    "pparen",
    9387,
    "precedes",
    8826,
    "prescription",
    8478,
    "primemod",
    697,
    "primereversed",
    8245,
    "product",
    8719,
    "projective",
    8965,
    "prolongedkana",
    12540,
    "propellor",
    8984,
    "propersubset",
    8834,
    "propersuperset",
    8835,
    "proportion",
    8759,
    "proportional",
    8733,
    "psi",
    968,
    "psicyrillic",
    1137,
    "psilipneumatacyrilliccmb",
    1158,
    "pssquare",
    13232,
    "puhiragana",
    12407,
    "pukatakana",
    12503,
    "pvsquare",
    13236,
    "pwsquare",
    13242,
    "q",
    113,
    "qadeva",
    2392,
    "qadmahebrew",
    1448,
    "qafarabic",
    1602,
    "qaffinalarabic",
    65238,
    "qafinitialarabic",
    65239,
    "qafmedialarabic",
    65240,
    "qamats",
    1464,
    "qamats10",
    1464,
    "qamats1a",
    1464,
    "qamats1c",
    1464,
    "qamats27",
    1464,
    "qamats29",
    1464,
    "qamats33",
    1464,
    "qamatsde",
    1464,
    "qamatshebrew",
    1464,
    "qamatsnarrowhebrew",
    1464,
    "qamatsqatanhebrew",
    1464,
    "qamatsqatannarrowhebrew",
    1464,
    "qamatsqatanquarterhebrew",
    1464,
    "qamatsqatanwidehebrew",
    1464,
    "qamatsquarterhebrew",
    1464,
    "qamatswidehebrew",
    1464,
    "qarneyparahebrew",
    1439,
    "qbopomofo",
    12561,
    "qcircle",
    9440,
    "qhook",
    672,
    "qmonospace",
    65361,
    "qof",
    1511,
    "qofdagesh",
    64327,
    "qofdageshhebrew",
    64327,
    "qofhebrew",
    1511,
    "qparen",
    9388,
    "quarternote",
    9833,
    "qubuts",
    1467,
    "qubuts18",
    1467,
    "qubuts25",
    1467,
    "qubuts31",
    1467,
    "qubutshebrew",
    1467,
    "qubutsnarrowhebrew",
    1467,
    "qubutsquarterhebrew",
    1467,
    "qubutswidehebrew",
    1467,
    "question",
    63,
    "questionarabic",
    1567,
    "questionarmenian",
    1374,
    "questiondown",
    191,
    "questiondownsmall",
    63423,
    "questiongreek",
    894,
    "questionmonospace",
    65311,
    "questionsmall",
    63295,
    "quotedbl",
    34,
    "quotedblbase",
    8222,
    "quotedblleft",
    8220,
    "quotedblmonospace",
    65282,
    "quotedblprime",
    12318,
    "quotedblprimereversed",
    12317,
    "quotedblright",
    8221,
    "quoteleft",
    8216,
    "quoteleftreversed",
    8219,
    "quotereversed",
    8219,
    "quoteright",
    8217,
    "quoterightn",
    329,
    "quotesinglbase",
    8218,
    "quotesingle",
    39,
    "quotesinglemonospace",
    65287,
    "r",
    114,
    "raarmenian",
    1404,
    "rabengali",
    2480,
    "racute",
    341,
    "radeva",
    2352,
    "radical",
    8730,
    "radicalex",
    63717,
    "radoverssquare",
    13230,
    "radoverssquaredsquare",
    13231,
    "radsquare",
    13229,
    "rafe",
    1471,
    "rafehebrew",
    1471,
    "ragujarati",
    2736,
    "ragurmukhi",
    2608,
    "rahiragana",
    12425,
    "rakatakana",
    12521,
    "rakatakanahalfwidth",
    65431,
    "ralowerdiagonalbengali",
    2545,
    "ramiddlediagonalbengali",
    2544,
    "ramshorn",
    612,
    "ratio",
    8758,
    "rbopomofo",
    12566,
    "rcaron",
    345,
    "rcedilla",
    343,
    "rcircle",
    9441,
    "rcommaaccent",
    343,
    "rdblgrave",
    529,
    "rdotaccent",
    7769,
    "rdotbelow",
    7771,
    "rdotbelowmacron",
    7773,
    "referencemark",
    8251,
    "reflexsubset",
    8838,
    "reflexsuperset",
    8839,
    "registered",
    174,
    "registersans",
    63720,
    "registerserif",
    63194,
    "reharabic",
    1585,
    "reharmenian",
    1408,
    "rehfinalarabic",
    65198,
    "rehiragana",
    12428,
    "rekatakana",
    12524,
    "rekatakanahalfwidth",
    65434,
    "resh",
    1512,
    "reshdageshhebrew",
    64328,
    "reshhebrew",
    1512,
    "reversedtilde",
    8765,
    "reviahebrew",
    1431,
    "reviamugrashhebrew",
    1431,
    "revlogicalnot",
    8976,
    "rfishhook",
    638,
    "rfishhookreversed",
    639,
    "rhabengali",
    2525,
    "rhadeva",
    2397,
    "rho",
    961,
    "rhook",
    637,
    "rhookturned",
    635,
    "rhookturnedsuperior",
    693,
    "rhosymbolgreek",
    1009,
    "rhotichookmod",
    734,
    "rieulacirclekorean",
    12913,
    "rieulaparenkorean",
    12817,
    "rieulcirclekorean",
    12899,
    "rieulhieuhkorean",
    12608,
    "rieulkiyeokkorean",
    12602,
    "rieulkiyeoksioskorean",
    12649,
    "rieulkorean",
    12601,
    "rieulmieumkorean",
    12603,
    "rieulpansioskorean",
    12652,
    "rieulparenkorean",
    12803,
    "rieulphieuphkorean",
    12607,
    "rieulpieupkorean",
    12604,
    "rieulpieupsioskorean",
    12651,
    "rieulsioskorean",
    12605,
    "rieulthieuthkorean",
    12606,
    "rieultikeutkorean",
    12650,
    "rieulyeorinhieuhkorean",
    12653,
    "rightangle",
    8735,
    "righttackbelowcmb",
    793,
    "righttriangle",
    8895,
    "rihiragana",
    12426,
    "rikatakana",
    12522,
    "rikatakanahalfwidth",
    65432,
    "ring",
    730,
    "ringbelowcmb",
    805,
    "ringcmb",
    778,
    "ringhalfleft",
    703,
    "ringhalfleftarmenian",
    1369,
    "ringhalfleftbelowcmb",
    796,
    "ringhalfleftcentered",
    723,
    "ringhalfright",
    702,
    "ringhalfrightbelowcmb",
    825,
    "ringhalfrightcentered",
    722,
    "rinvertedbreve",
    531,
    "rittorusquare",
    13137,
    "rlinebelow",
    7775,
    "rlongleg",
    636,
    "rlonglegturned",
    634,
    "rmonospace",
    65362,
    "rohiragana",
    12429,
    "rokatakana",
    12525,
    "rokatakanahalfwidth",
    65435,
    "roruathai",
    3619,
    "rparen",
    9389,
    "rrabengali",
    2524,
    "rradeva",
    2353,
    "rragurmukhi",
    2652,
    "rreharabic",
    1681,
    "rrehfinalarabic",
    64397,
    "rrvocalicbengali",
    2528,
    "rrvocalicdeva",
    2400,
    "rrvocalicgujarati",
    2784,
    "rrvocalicvowelsignbengali",
    2500,
    "rrvocalicvowelsigndeva",
    2372,
    "rrvocalicvowelsigngujarati",
    2756,
    "rsuperior",
    63217,
    "rtblock",
    9616,
    "rturned",
    633,
    "rturnedsuperior",
    692,
    "ruhiragana",
    12427,
    "rukatakana",
    12523,
    "rukatakanahalfwidth",
    65433,
    "rupeemarkbengali",
    2546,
    "rupeesignbengali",
    2547,
    "rupiah",
    63197,
    "ruthai",
    3620,
    "rvocalicbengali",
    2443,
    "rvocalicdeva",
    2315,
    "rvocalicgujarati",
    2699,
    "rvocalicvowelsignbengali",
    2499,
    "rvocalicvowelsigndeva",
    2371,
    "rvocalicvowelsigngujarati",
    2755,
    "s",
    115,
    "sabengali",
    2488,
    "sacute",
    347,
    "sacutedotaccent",
    7781,
    "sadarabic",
    1589,
    "sadeva",
    2360,
    "sadfinalarabic",
    65210,
    "sadinitialarabic",
    65211,
    "sadmedialarabic",
    65212,
    "sagujarati",
    2744,
    "sagurmukhi",
    2616,
    "sahiragana",
    12373,
    "sakatakana",
    12469,
    "sakatakanahalfwidth",
    65403,
    "sallallahoualayhewasallamarabic",
    65018,
    "samekh",
    1505,
    "samekhdagesh",
    64321,
    "samekhdageshhebrew",
    64321,
    "samekhhebrew",
    1505,
    "saraaathai",
    3634,
    "saraaethai",
    3649,
    "saraaimaimalaithai",
    3652,
    "saraaimaimuanthai",
    3651,
    "saraamthai",
    3635,
    "saraathai",
    3632,
    "saraethai",
    3648,
    "saraiileftthai",
    63622,
    "saraiithai",
    3637,
    "saraileftthai",
    63621,
    "saraithai",
    3636,
    "saraothai",
    3650,
    "saraueeleftthai",
    63624,
    "saraueethai",
    3639,
    "saraueleftthai",
    63623,
    "sarauethai",
    3638,
    "sarauthai",
    3640,
    "sarauuthai",
    3641,
    "sbopomofo",
    12569,
    "scaron",
    353,
    "scarondotaccent",
    7783,
    "scedilla",
    351,
    "schwa",
    601,
    "schwacyrillic",
    1241,
    "schwadieresiscyrillic",
    1243,
    "schwahook",
    602,
    "scircle",
    9442,
    "scircumflex",
    349,
    "scommaaccent",
    537,
    "sdotaccent",
    7777,
    "sdotbelow",
    7779,
    "sdotbelowdotaccent",
    7785,
    "seagullbelowcmb",
    828,
    "second",
    8243,
    "secondtonechinese",
    714,
    "section",
    167,
    "seenarabic",
    1587,
    "seenfinalarabic",
    65202,
    "seeninitialarabic",
    65203,
    "seenmedialarabic",
    65204,
    "segol",
    1462,
    "segol13",
    1462,
    "segol1f",
    1462,
    "segol2c",
    1462,
    "segolhebrew",
    1462,
    "segolnarrowhebrew",
    1462,
    "segolquarterhebrew",
    1462,
    "segoltahebrew",
    1426,
    "segolwidehebrew",
    1462,
    "seharmenian",
    1405,
    "sehiragana",
    12379,
    "sekatakana",
    12475,
    "sekatakanahalfwidth",
    65406,
    "semicolon",
    59,
    "semicolonarabic",
    1563,
    "semicolonmonospace",
    65307,
    "semicolonsmall",
    65108,
    "semivoicedmarkkana",
    12444,
    "semivoicedmarkkanahalfwidth",
    65439,
    "sentisquare",
    13090,
    "sentosquare",
    13091,
    "seven",
    55,
    "sevenarabic",
    1639,
    "sevenbengali",
    2541,
    "sevencircle",
    9318,
    "sevencircleinversesansserif",
    10128,
    "sevendeva",
    2413,
    "seveneighths",
    8542,
    "sevengujarati",
    2797,
    "sevengurmukhi",
    2669,
    "sevenhackarabic",
    1639,
    "sevenhangzhou",
    12327,
    "sevenideographicparen",
    12838,
    "seveninferior",
    8327,
    "sevenmonospace",
    65303,
    "sevenoldstyle",
    63287,
    "sevenparen",
    9338,
    "sevenperiod",
    9358,
    "sevenpersian",
    1783,
    "sevenroman",
    8566,
    "sevensuperior",
    8311,
    "seventeencircle",
    9328,
    "seventeenparen",
    9348,
    "seventeenperiod",
    9368,
    "seventhai",
    3671,
    "sfthyphen",
    173,
    "shaarmenian",
    1399,
    "shabengali",
    2486,
    "shacyrillic",
    1096,
    "shaddaarabic",
    1617,
    "shaddadammaarabic",
    64609,
    "shaddadammatanarabic",
    64606,
    "shaddafathaarabic",
    64608,
    "shaddakasraarabic",
    64610,
    "shaddakasratanarabic",
    64607,
    "shade",
    9618,
    "shadedark",
    9619,
    "shadelight",
    9617,
    "shademedium",
    9618,
    "shadeva",
    2358,
    "shagujarati",
    2742,
    "shagurmukhi",
    2614,
    "shalshelethebrew",
    1427,
    "shbopomofo",
    12565,
    "shchacyrillic",
    1097,
    "sheenarabic",
    1588,
    "sheenfinalarabic",
    65206,
    "sheeninitialarabic",
    65207,
    "sheenmedialarabic",
    65208,
    "sheicoptic",
    995,
    "sheqel",
    8362,
    "sheqelhebrew",
    8362,
    "sheva",
    1456,
    "sheva115",
    1456,
    "sheva15",
    1456,
    "sheva22",
    1456,
    "sheva2e",
    1456,
    "shevahebrew",
    1456,
    "shevanarrowhebrew",
    1456,
    "shevaquarterhebrew",
    1456,
    "shevawidehebrew",
    1456,
    "shhacyrillic",
    1211,
    "shimacoptic",
    1005,
    "shin",
    1513,
    "shindagesh",
    64329,
    "shindageshhebrew",
    64329,
    "shindageshshindot",
    64300,
    "shindageshshindothebrew",
    64300,
    "shindageshsindot",
    64301,
    "shindageshsindothebrew",
    64301,
    "shindothebrew",
    1473,
    "shinhebrew",
    1513,
    "shinshindot",
    64298,
    "shinshindothebrew",
    64298,
    "shinsindot",
    64299,
    "shinsindothebrew",
    64299,
    "shook",
    642,
    "sigma",
    963,
    "sigma1",
    962,
    "sigmafinal",
    962,
    "sigmalunatesymbolgreek",
    1010,
    "sihiragana",
    12375,
    "sikatakana",
    12471,
    "sikatakanahalfwidth",
    65404,
    "siluqhebrew",
    1469,
    "siluqlefthebrew",
    1469,
    "similar",
    8764,
    "sindothebrew",
    1474,
    "siosacirclekorean",
    12916,
    "siosaparenkorean",
    12820,
    "sioscieuckorean",
    12670,
    "sioscirclekorean",
    12902,
    "sioskiyeokkorean",
    12666,
    "sioskorean",
    12613,
    "siosnieunkorean",
    12667,
    "siosparenkorean",
    12806,
    "siospieupkorean",
    12669,
    "siostikeutkorean",
    12668,
    "six",
    54,
    "sixarabic",
    1638,
    "sixbengali",
    2540,
    "sixcircle",
    9317,
    "sixcircleinversesansserif",
    10127,
    "sixdeva",
    2412,
    "sixgujarati",
    2796,
    "sixgurmukhi",
    2668,
    "sixhackarabic",
    1638,
    "sixhangzhou",
    12326,
    "sixideographicparen",
    12837,
    "sixinferior",
    8326,
    "sixmonospace",
    65302,
    "sixoldstyle",
    63286,
    "sixparen",
    9337,
    "sixperiod",
    9357,
    "sixpersian",
    1782,
    "sixroman",
    8565,
    "sixsuperior",
    8310,
    "sixteencircle",
    9327,
    "sixteencurrencydenominatorbengali",
    2553,
    "sixteenparen",
    9347,
    "sixteenperiod",
    9367,
    "sixthai",
    3670,
    "slash",
    47,
    "slashmonospace",
    65295,
    "slong",
    383,
    "slongdotaccent",
    7835,
    "smileface",
    9786,
    "smonospace",
    65363,
    "sofpasuqhebrew",
    1475,
    "softhyphen",
    173,
    "softsigncyrillic",
    1100,
    "sohiragana",
    12381,
    "sokatakana",
    12477,
    "sokatakanahalfwidth",
    65407,
    "soliduslongoverlaycmb",
    824,
    "solidusshortoverlaycmb",
    823,
    "sorusithai",
    3625,
    "sosalathai",
    3624,
    "sosothai",
    3595,
    "sosuathai",
    3626,
    "space",
    32,
    "spacehackarabic",
    32,
    "spade",
    9824,
    "spadesuitblack",
    9824,
    "spadesuitwhite",
    9828,
    "sparen",
    9390,
    "squarebelowcmb",
    827,
    "squarecc",
    13252,
    "squarecm",
    13213,
    "squarediagonalcrosshatchfill",
    9641,
    "squarehorizontalfill",
    9636,
    "squarekg",
    13199,
    "squarekm",
    13214,
    "squarekmcapital",
    13262,
    "squareln",
    13265,
    "squarelog",
    13266,
    "squaremg",
    13198,
    "squaremil",
    13269,
    "squaremm",
    13212,
    "squaremsquared",
    13217,
    "squareorthogonalcrosshatchfill",
    9638,
    "squareupperlefttolowerrightfill",
    9639,
    "squareupperrighttolowerleftfill",
    9640,
    "squareverticalfill",
    9637,
    "squarewhitewithsmallblack",
    9635,
    "srsquare",
    13275,
    "ssabengali",
    2487,
    "ssadeva",
    2359,
    "ssagujarati",
    2743,
    "ssangcieuckorean",
    12617,
    "ssanghieuhkorean",
    12677,
    "ssangieungkorean",
    12672,
    "ssangkiyeokkorean",
    12594,
    "ssangnieunkorean",
    12645,
    "ssangpieupkorean",
    12611,
    "ssangsioskorean",
    12614,
    "ssangtikeutkorean",
    12600,
    "ssuperior",
    63218,
    "sterling",
    163,
    "sterlingmonospace",
    65505,
    "strokelongoverlaycmb",
    822,
    "strokeshortoverlaycmb",
    821,
    "subset",
    8834,
    "subsetnotequal",
    8842,
    "subsetorequal",
    8838,
    "succeeds",
    8827,
    "suchthat",
    8715,
    "suhiragana",
    12377,
    "sukatakana",
    12473,
    "sukatakanahalfwidth",
    65405,
    "sukunarabic",
    1618,
    "summation",
    8721,
    "sun",
    9788,
    "superset",
    8835,
    "supersetnotequal",
    8843,
    "supersetorequal",
    8839,
    "svsquare",
    13276,
    "syouwaerasquare",
    13180,
    "t",
    116,
    "tabengali",
    2468,
    "tackdown",
    8868,
    "tackleft",
    8867,
    "tadeva",
    2340,
    "tagujarati",
    2724,
    "tagurmukhi",
    2596,
    "taharabic",
    1591,
    "tahfinalarabic",
    65218,
    "tahinitialarabic",
    65219,
    "tahiragana",
    12383,
    "tahmedialarabic",
    65220,
    "taisyouerasquare",
    13181,
    "takatakana",
    12479,
    "takatakanahalfwidth",
    65408,
    "tatweelarabic",
    1600,
    "tau",
    964,
    "tav",
    1514,
    "tavdages",
    64330,
    "tavdagesh",
    64330,
    "tavdageshhebrew",
    64330,
    "tavhebrew",
    1514,
    "tbar",
    359,
    "tbopomofo",
    12554,
    "tcaron",
    357,
    "tccurl",
    680,
    "tcedilla",
    355,
    "tcheharabic",
    1670,
    "tchehfinalarabic",
    64379,
    "tchehinitialarabic",
    64380,
    "tchehmedialarabic",
    64381,
    "tcircle",
    9443,
    "tcircumflexbelow",
    7793,
    "tcommaaccent",
    355,
    "tdieresis",
    7831,
    "tdotaccent",
    7787,
    "tdotbelow",
    7789,
    "tecyrillic",
    1090,
    "tedescendercyrillic",
    1197,
    "teharabic",
    1578,
    "tehfinalarabic",
    65174,
    "tehhahinitialarabic",
    64674,
    "tehhahisolatedarabic",
    64524,
    "tehinitialarabic",
    65175,
    "tehiragana",
    12390,
    "tehjeeminitialarabic",
    64673,
    "tehjeemisolatedarabic",
    64523,
    "tehmarbutaarabic",
    1577,
    "tehmarbutafinalarabic",
    65172,
    "tehmedialarabic",
    65176,
    "tehmeeminitialarabic",
    64676,
    "tehmeemisolatedarabic",
    64526,
    "tehnoonfinalarabic",
    64627,
    "tekatakana",
    12486,
    "tekatakanahalfwidth",
    65411,
    "telephone",
    8481,
    "telephoneblack",
    9742,
    "telishagedolahebrew",
    1440,
    "telishaqetanahebrew",
    1449,
    "tencircle",
    9321,
    "tenideographicparen",
    12841,
    "tenparen",
    9341,
    "tenperiod",
    9361,
    "tenroman",
    8569,
    "tesh",
    679,
    "tet",
    1496,
    "tetdagesh",
    64312,
    "tetdageshhebrew",
    64312,
    "tethebrew",
    1496,
    "tetsecyrillic",
    1205,
    "tevirhebrew",
    1435,
    "tevirlefthebrew",
    1435,
    "thabengali",
    2469,
    "thadeva",
    2341,
    "thagujarati",
    2725,
    "thagurmukhi",
    2597,
    "thalarabic",
    1584,
    "thalfinalarabic",
    65196,
    "thanthakhatlowleftthai",
    63640,
    "thanthakhatlowrightthai",
    63639,
    "thanthakhatthai",
    3660,
    "thanthakhatupperleftthai",
    63638,
    "theharabic",
    1579,
    "thehfinalarabic",
    65178,
    "thehinitialarabic",
    65179,
    "thehmedialarabic",
    65180,
    "thereexists",
    8707,
    "therefore",
    8756,
    "theta",
    952,
    "theta1",
    977,
    "thetasymbolgreek",
    977,
    "thieuthacirclekorean",
    12921,
    "thieuthaparenkorean",
    12825,
    "thieuthcirclekorean",
    12907,
    "thieuthkorean",
    12620,
    "thieuthparenkorean",
    12811,
    "thirteencircle",
    9324,
    "thirteenparen",
    9344,
    "thirteenperiod",
    9364,
    "thonangmonthothai",
    3601,
    "thook",
    429,
    "thophuthaothai",
    3602,
    "thorn",
    254,
    "thothahanthai",
    3607,
    "thothanthai",
    3600,
    "thothongthai",
    3608,
    "thothungthai",
    3606,
    "thousandcyrillic",
    1154,
    "thousandsseparatorarabic",
    1644,
    "thousandsseparatorpersian",
    1644,
    "three",
    51,
    "threearabic",
    1635,
    "threebengali",
    2537,
    "threecircle",
    9314,
    "threecircleinversesansserif",
    10124,
    "threedeva",
    2409,
    "threeeighths",
    8540,
    "threegujarati",
    2793,
    "threegurmukhi",
    2665,
    "threehackarabic",
    1635,
    "threehangzhou",
    12323,
    "threeideographicparen",
    12834,
    "threeinferior",
    8323,
    "threemonospace",
    65299,
    "threenumeratorbengali",
    2550,
    "threeoldstyle",
    63283,
    "threeparen",
    9334,
    "threeperiod",
    9354,
    "threepersian",
    1779,
    "threequarters",
    190,
    "threequartersemdash",
    63198,
    "threeroman",
    8562,
    "threesuperior",
    179,
    "threethai",
    3667,
    "thzsquare",
    13204,
    "tihiragana",
    12385,
    "tikatakana",
    12481,
    "tikatakanahalfwidth",
    65409,
    "tikeutacirclekorean",
    12912,
    "tikeutaparenkorean",
    12816,
    "tikeutcirclekorean",
    12898,
    "tikeutkorean",
    12599,
    "tikeutparenkorean",
    12802,
    "tilde",
    732,
    "tildebelowcmb",
    816,
    "tildecmb",
    771,
    "tildecomb",
    771,
    "tildedoublecmb",
    864,
    "tildeoperator",
    8764,
    "tildeoverlaycmb",
    820,
    "tildeverticalcmb",
    830,
    "timescircle",
    8855,
    "tipehahebrew",
    1430,
    "tipehalefthebrew",
    1430,
    "tippigurmukhi",
    2672,
    "titlocyrilliccmb",
    1155,
    "tiwnarmenian",
    1407,
    "tlinebelow",
    7791,
    "tmonospace",
    65364,
    "toarmenian",
    1385,
    "tohiragana",
    12392,
    "tokatakana",
    12488,
    "tokatakanahalfwidth",
    65412,
    "tonebarextrahighmod",
    741,
    "tonebarextralowmod",
    745,
    "tonebarhighmod",
    742,
    "tonebarlowmod",
    744,
    "tonebarmidmod",
    743,
    "tonefive",
    445,
    "tonesix",
    389,
    "tonetwo",
    424,
    "tonos",
    900,
    "tonsquare",
    13095,
    "topatakthai",
    3599,
    "tortoiseshellbracketleft",
    12308,
    "tortoiseshellbracketleftsmall",
    65117,
    "tortoiseshellbracketleftvertical",
    65081,
    "tortoiseshellbracketright",
    12309,
    "tortoiseshellbracketrightsmall",
    65118,
    "tortoiseshellbracketrightvertical",
    65082,
    "totaothai",
    3605,
    "tpalatalhook",
    427,
    "tparen",
    9391,
    "trademark",
    8482,
    "trademarksans",
    63722,
    "trademarkserif",
    63195,
    "tretroflexhook",
    648,
    "triagdn",
    9660,
    "triaglf",
    9668,
    "triagrt",
    9658,
    "triagup",
    9650,
    "ts",
    678,
    "tsadi",
    1510,
    "tsadidagesh",
    64326,
    "tsadidageshhebrew",
    64326,
    "tsadihebrew",
    1510,
    "tsecyrillic",
    1094,
    "tsere",
    1461,
    "tsere12",
    1461,
    "tsere1e",
    1461,
    "tsere2b",
    1461,
    "tserehebrew",
    1461,
    "tserenarrowhebrew",
    1461,
    "tserequarterhebrew",
    1461,
    "tserewidehebrew",
    1461,
    "tshecyrillic",
    1115,
    "tsuperior",
    63219,
    "ttabengali",
    2463,
    "ttadeva",
    2335,
    "ttagujarati",
    2719,
    "ttagurmukhi",
    2591,
    "tteharabic",
    1657,
    "ttehfinalarabic",
    64359,
    "ttehinitialarabic",
    64360,
    "ttehmedialarabic",
    64361,
    "tthabengali",
    2464,
    "tthadeva",
    2336,
    "tthagujarati",
    2720,
    "tthagurmukhi",
    2592,
    "tturned",
    647,
    "tuhiragana",
    12388,
    "tukatakana",
    12484,
    "tukatakanahalfwidth",
    65410,
    "tusmallhiragana",
    12387,
    "tusmallkatakana",
    12483,
    "tusmallkatakanahalfwidth",
    65391,
    "twelvecircle",
    9323,
    "twelveparen",
    9343,
    "twelveperiod",
    9363,
    "twelveroman",
    8571,
    "twentycircle",
    9331,
    "twentyhangzhou",
    21316,
    "twentyparen",
    9351,
    "twentyperiod",
    9371,
    "two",
    50,
    "twoarabic",
    1634,
    "twobengali",
    2536,
    "twocircle",
    9313,
    "twocircleinversesansserif",
    10123,
    "twodeva",
    2408,
    "twodotenleader",
    8229,
    "twodotleader",
    8229,
    "twodotleadervertical",
    65072,
    "twogujarati",
    2792,
    "twogurmukhi",
    2664,
    "twohackarabic",
    1634,
    "twohangzhou",
    12322,
    "twoideographicparen",
    12833,
    "twoinferior",
    8322,
    "twomonospace",
    65298,
    "twonumeratorbengali",
    2549,
    "twooldstyle",
    63282,
    "twoparen",
    9333,
    "twoperiod",
    9353,
    "twopersian",
    1778,
    "tworoman",
    8561,
    "twostroke",
    443,
    "twosuperior",
    178,
    "twothai",
    3666,
    "twothirds",
    8532,
    "u",
    117,
    "uacute",
    250,
    "ubar",
    649,
    "ubengali",
    2441,
    "ubopomofo",
    12584,
    "ubreve",
    365,
    "ucaron",
    468,
    "ucircle",
    9444,
    "ucircumflex",
    251,
    "ucircumflexbelow",
    7799,
    "ucyrillic",
    1091,
    "udattadeva",
    2385,
    "udblacute",
    369,
    "udblgrave",
    533,
    "udeva",
    2313,
    "udieresis",
    252,
    "udieresisacute",
    472,
    "udieresisbelow",
    7795,
    "udieresiscaron",
    474,
    "udieresiscyrillic",
    1265,
    "udieresisgrave",
    476,
    "udieresismacron",
    470,
    "udotbelow",
    7909,
    "ugrave",
    249,
    "ugujarati",
    2697,
    "ugurmukhi",
    2569,
    "uhiragana",
    12358,
    "uhookabove",
    7911,
    "uhorn",
    432,
    "uhornacute",
    7913,
    "uhorndotbelow",
    7921,
    "uhorngrave",
    7915,
    "uhornhookabove",
    7917,
    "uhorntilde",
    7919,
    "uhungarumlaut",
    369,
    "uhungarumlautcyrillic",
    1267,
    "uinvertedbreve",
    535,
    "ukatakana",
    12454,
    "ukatakanahalfwidth",
    65395,
    "ukcyrillic",
    1145,
    "ukorean",
    12636,
    "umacron",
    363,
    "umacroncyrillic",
    1263,
    "umacrondieresis",
    7803,
    "umatragurmukhi",
    2625,
    "umonospace",
    65365,
    "underscore",
    95,
    "underscoredbl",
    8215,
    "underscoremonospace",
    65343,
    "underscorevertical",
    65075,
    "underscorewavy",
    65103,
    "union",
    8746,
    "universal",
    8704,
    "uogonek",
    371,
    "uparen",
    9392,
    "upblock",
    9600,
    "upperdothebrew",
    1476,
    "upsilon",
    965,
    "upsilondieresis",
    971,
    "upsilondieresistonos",
    944,
    "upsilonlatin",
    650,
    "upsilontonos",
    973,
    "uptackbelowcmb",
    797,
    "uptackmod",
    724,
    "uragurmukhi",
    2675,
    "uring",
    367,
    "ushortcyrillic",
    1118,
    "usmallhiragana",
    12357,
    "usmallkatakana",
    12453,
    "usmallkatakanahalfwidth",
    65385,
    "ustraightcyrillic",
    1199,
    "ustraightstrokecyrillic",
    1201,
    "utilde",
    361,
    "utildeacute",
    7801,
    "utildebelow",
    7797,
    "uubengali",
    2442,
    "uudeva",
    2314,
    "uugujarati",
    2698,
    "uugurmukhi",
    2570,
    "uumatragurmukhi",
    2626,
    "uuvowelsignbengali",
    2498,
    "uuvowelsigndeva",
    2370,
    "uuvowelsigngujarati",
    2754,
    "uvowelsignbengali",
    2497,
    "uvowelsigndeva",
    2369,
    "uvowelsigngujarati",
    2753,
    "v",
    118,
    "vadeva",
    2357,
    "vagujarati",
    2741,
    "vagurmukhi",
    2613,
    "vakatakana",
    12535,
    "vav",
    1493,
    "vavdagesh",
    64309,
    "vavdagesh65",
    64309,
    "vavdageshhebrew",
    64309,
    "vavhebrew",
    1493,
    "vavholam",
    64331,
    "vavholamhebrew",
    64331,
    "vavvavhebrew",
    1520,
    "vavyodhebrew",
    1521,
    "vcircle",
    9445,
    "vdotbelow",
    7807,
    "vecyrillic",
    1074,
    "veharabic",
    1700,
    "vehfinalarabic",
    64363,
    "vehinitialarabic",
    64364,
    "vehmedialarabic",
    64365,
    "vekatakana",
    12537,
    "venus",
    9792,
    "verticalbar",
    124,
    "verticallineabovecmb",
    781,
    "verticallinebelowcmb",
    809,
    "verticallinelowmod",
    716,
    "verticallinemod",
    712,
    "vewarmenian",
    1406,
    "vhook",
    651,
    "vikatakana",
    12536,
    "viramabengali",
    2509,
    "viramadeva",
    2381,
    "viramagujarati",
    2765,
    "visargabengali",
    2435,
    "visargadeva",
    2307,
    "visargagujarati",
    2691,
    "vmonospace",
    65366,
    "voarmenian",
    1400,
    "voicediterationhiragana",
    12446,
    "voicediterationkatakana",
    12542,
    "voicedmarkkana",
    12443,
    "voicedmarkkanahalfwidth",
    65438,
    "vokatakana",
    12538,
    "vparen",
    9393,
    "vtilde",
    7805,
    "vturned",
    652,
    "vuhiragana",
    12436,
    "vukatakana",
    12532,
    "w",
    119,
    "wacute",
    7811,
    "waekorean",
    12633,
    "wahiragana",
    12431,
    "wakatakana",
    12527,
    "wakatakanahalfwidth",
    65436,
    "wakorean",
    12632,
    "wasmallhiragana",
    12430,
    "wasmallkatakana",
    12526,
    "wattosquare",
    13143,
    "wavedash",
    12316,
    "wavyunderscorevertical",
    65076,
    "wawarabic",
    1608,
    "wawfinalarabic",
    65262,
    "wawhamzaabovearabic",
    1572,
    "wawhamzaabovefinalarabic",
    65158,
    "wbsquare",
    13277,
    "wcircle",
    9446,
    "wcircumflex",
    373,
    "wdieresis",
    7813,
    "wdotaccent",
    7815,
    "wdotbelow",
    7817,
    "wehiragana",
    12433,
    "weierstrass",
    8472,
    "wekatakana",
    12529,
    "wekorean",
    12638,
    "weokorean",
    12637,
    "wgrave",
    7809,
    "whitebullet",
    9702,
    "whitecircle",
    9675,
    "whitecircleinverse",
    9689,
    "whitecornerbracketleft",
    12302,
    "whitecornerbracketleftvertical",
    65091,
    "whitecornerbracketright",
    12303,
    "whitecornerbracketrightvertical",
    65092,
    "whitediamond",
    9671,
    "whitediamondcontainingblacksmalldiamond",
    9672,
    "whitedownpointingsmalltriangle",
    9663,
    "whitedownpointingtriangle",
    9661,
    "whiteleftpointingsmalltriangle",
    9667,
    "whiteleftpointingtriangle",
    9665,
    "whitelenticularbracketleft",
    12310,
    "whitelenticularbracketright",
    12311,
    "whiterightpointingsmalltriangle",
    9657,
    "whiterightpointingtriangle",
    9655,
    "whitesmallsquare",
    9643,
    "whitesmilingface",
    9786,
    "whitesquare",
    9633,
    "whitestar",
    9734,
    "whitetelephone",
    9743,
    "whitetortoiseshellbracketleft",
    12312,
    "whitetortoiseshellbracketright",
    12313,
    "whiteuppointingsmalltriangle",
    9653,
    "whiteuppointingtriangle",
    9651,
    "wihiragana",
    12432,
    "wikatakana",
    12528,
    "wikorean",
    12639,
    "wmonospace",
    65367,
    "wohiragana",
    12434,
    "wokatakana",
    12530,
    "wokatakanahalfwidth",
    65382,
    "won",
    8361,
    "wonmonospace",
    65510,
    "wowaenthai",
    3623,
    "wparen",
    9394,
    "wring",
    7832,
    "wsuperior",
    695,
    "wturned",
    653,
    "wynn",
    447,
    "x",
    120,
    "xabovecmb",
    829,
    "xbopomofo",
    12562,
    "xcircle",
    9447,
    "xdieresis",
    7821,
    "xdotaccent",
    7819,
    "xeharmenian",
    1389,
    "xi",
    958,
    "xmonospace",
    65368,
    "xparen",
    9395,
    "xsuperior",
    739,
    "y",
    121,
    "yaadosquare",
    13134,
    "yabengali",
    2479,
    "yacute",
    253,
    "yadeva",
    2351,
    "yaekorean",
    12626,
    "yagujarati",
    2735,
    "yagurmukhi",
    2607,
    "yahiragana",
    12420,
    "yakatakana",
    12516,
    "yakatakanahalfwidth",
    65428,
    "yakorean",
    12625,
    "yamakkanthai",
    3662,
    "yasmallhiragana",
    12419,
    "yasmallkatakana",
    12515,
    "yasmallkatakanahalfwidth",
    65388,
    "yatcyrillic",
    1123,
    "ycircle",
    9448,
    "ycircumflex",
    375,
    "ydieresis",
    255,
    "ydotaccent",
    7823,
    "ydotbelow",
    7925,
    "yeharabic",
    1610,
    "yehbarreearabic",
    1746,
    "yehbarreefinalarabic",
    64431,
    "yehfinalarabic",
    65266,
    "yehhamzaabovearabic",
    1574,
    "yehhamzaabovefinalarabic",
    65162,
    "yehhamzaaboveinitialarabic",
    65163,
    "yehhamzaabovemedialarabic",
    65164,
    "yehinitialarabic",
    65267,
    "yehmedialarabic",
    65268,
    "yehmeeminitialarabic",
    64733,
    "yehmeemisolatedarabic",
    64600,
    "yehnoonfinalarabic",
    64660,
    "yehthreedotsbelowarabic",
    1745,
    "yekorean",
    12630,
    "yen",
    165,
    "yenmonospace",
    65509,
    "yeokorean",
    12629,
    "yeorinhieuhkorean",
    12678,
    "yerahbenyomohebrew",
    1450,
    "yerahbenyomolefthebrew",
    1450,
    "yericyrillic",
    1099,
    "yerudieresiscyrillic",
    1273,
    "yesieungkorean",
    12673,
    "yesieungpansioskorean",
    12675,
    "yesieungsioskorean",
    12674,
    "yetivhebrew",
    1434,
    "ygrave",
    7923,
    "yhook",
    436,
    "yhookabove",
    7927,
    "yiarmenian",
    1397,
    "yicyrillic",
    1111,
    "yikorean",
    12642,
    "yinyang",
    9775,
    "yiwnarmenian",
    1410,
    "ymonospace",
    65369,
    "yod",
    1497,
    "yoddagesh",
    64313,
    "yoddageshhebrew",
    64313,
    "yodhebrew",
    1497,
    "yodyodhebrew",
    1522,
    "yodyodpatahhebrew",
    64287,
    "yohiragana",
    12424,
    "yoikorean",
    12681,
    "yokatakana",
    12520,
    "yokatakanahalfwidth",
    65430,
    "yokorean",
    12635,
    "yosmallhiragana",
    12423,
    "yosmallkatakana",
    12519,
    "yosmallkatakanahalfwidth",
    65390,
    "yotgreek",
    1011,
    "yoyaekorean",
    12680,
    "yoyakorean",
    12679,
    "yoyakthai",
    3618,
    "yoyingthai",
    3597,
    "yparen",
    9396,
    "ypogegrammeni",
    890,
    "ypogegrammenigreekcmb",
    837,
    "yr",
    422,
    "yring",
    7833,
    "ysuperior",
    696,
    "ytilde",
    7929,
    "yturned",
    654,
    "yuhiragana",
    12422,
    "yuikorean",
    12684,
    "yukatakana",
    12518,
    "yukatakanahalfwidth",
    65429,
    "yukorean",
    12640,
    "yusbigcyrillic",
    1131,
    "yusbigiotifiedcyrillic",
    1133,
    "yuslittlecyrillic",
    1127,
    "yuslittleiotifiedcyrillic",
    1129,
    "yusmallhiragana",
    12421,
    "yusmallkatakana",
    12517,
    "yusmallkatakanahalfwidth",
    65389,
    "yuyekorean",
    12683,
    "yuyeokorean",
    12682,
    "yyabengali",
    2527,
    "yyadeva",
    2399,
    "z",
    122,
    "zaarmenian",
    1382,
    "zacute",
    378,
    "zadeva",
    2395,
    "zagurmukhi",
    2651,
    "zaharabic",
    1592,
    "zahfinalarabic",
    65222,
    "zahinitialarabic",
    65223,
    "zahiragana",
    12374,
    "zahmedialarabic",
    65224,
    "zainarabic",
    1586,
    "zainfinalarabic",
    65200,
    "zakatakana",
    12470,
    "zaqefgadolhebrew",
    1429,
    "zaqefqatanhebrew",
    1428,
    "zarqahebrew",
    1432,
    "zayin",
    1494,
    "zayindagesh",
    64310,
    "zayindageshhebrew",
    64310,
    "zayinhebrew",
    1494,
    "zbopomofo",
    12567,
    "zcaron",
    382,
    "zcircle",
    9449,
    "zcircumflex",
    7825,
    "zcurl",
    657,
    "zdot",
    380,
    "zdotaccent",
    380,
    "zdotbelow",
    7827,
    "zecyrillic",
    1079,
    "zedescendercyrillic",
    1177,
    "zedieresiscyrillic",
    1247,
    "zehiragana",
    12380,
    "zekatakana",
    12476,
    "zero",
    48,
    "zeroarabic",
    1632,
    "zerobengali",
    2534,
    "zerodeva",
    2406,
    "zerogujarati",
    2790,
    "zerogurmukhi",
    2662,
    "zerohackarabic",
    1632,
    "zeroinferior",
    8320,
    "zeromonospace",
    65296,
    "zerooldstyle",
    63280,
    "zeropersian",
    1776,
    "zerosuperior",
    8304,
    "zerothai",
    3664,
    "zerowidthjoiner",
    65279,
    "zerowidthnonjoiner",
    8204,
    "zerowidthspace",
    8203,
    "zeta",
    950,
    "zhbopomofo",
    12563,
    "zhearmenian",
    1386,
    "zhebrevecyrillic",
    1218,
    "zhecyrillic",
    1078,
    "zhedescendercyrillic",
    1175,
    "zhedieresiscyrillic",
    1245,
    "zihiragana",
    12376,
    "zikatakana",
    12472,
    "zinorhebrew",
    1454,
    "zlinebelow",
    7829,
    "zmonospace",
    65370,
    "zohiragana",
    12382,
    "zokatakana",
    12478,
    "zparen",
    9397,
    "zretroflexhook",
    656,
    "zstroke",
    438,
    "zuhiragana",
    12378,
    "zukatakana",
    12474,
    ".notdef",
    0,
    // TeX-specific glyph names.
    "angbracketleftbig",
    9001,
    "angbracketleftBig",
    9001,
    "angbracketleftbigg",
    9001,
    "angbracketleftBigg",
    9001,
    "angbracketrightBig",
    9002,
    "angbracketrightbig",
    9002,
    "angbracketrightBigg",
    9002,
    "angbracketrightbigg",
    9002,
    "arrowhookleft",
    8618,
    "arrowhookright",
    8617,
    "arrowlefttophalf",
    8636,
    "arrowleftbothalf",
    8637,
    "arrownortheast",
    8599,
    "arrownorthwest",
    8598,
    "arrowrighttophalf",
    8640,
    "arrowrightbothalf",
    8641,
    "arrowsoutheast",
    8600,
    "arrowsouthwest",
    8601,
    "backslashbig",
    8726,
    "backslashBig",
    8726,
    "backslashBigg",
    8726,
    "backslashbigg",
    8726,
    "bardbl",
    8214,
    "bracehtipdownleft",
    65079,
    "bracehtipdownright",
    65079,
    "bracehtipupleft",
    65080,
    "bracehtipupright",
    65080,
    "braceleftBig",
    123,
    "braceleftbig",
    123,
    "braceleftbigg",
    123,
    "braceleftBigg",
    123,
    "bracerightBig",
    125,
    "bracerightbig",
    125,
    "bracerightbigg",
    125,
    "bracerightBigg",
    125,
    "bracketleftbig",
    91,
    "bracketleftBig",
    91,
    "bracketleftbigg",
    91,
    "bracketleftBigg",
    91,
    "bracketrightBig",
    93,
    "bracketrightbig",
    93,
    "bracketrightbigg",
    93,
    "bracketrightBigg",
    93,
    "ceilingleftbig",
    8968,
    "ceilingleftBig",
    8968,
    "ceilingleftBigg",
    8968,
    "ceilingleftbigg",
    8968,
    "ceilingrightbig",
    8969,
    "ceilingrightBig",
    8969,
    "ceilingrightbigg",
    8969,
    "ceilingrightBigg",
    8969,
    "circledotdisplay",
    8857,
    "circledottext",
    8857,
    "circlemultiplydisplay",
    8855,
    "circlemultiplytext",
    8855,
    "circleplusdisplay",
    8853,
    "circleplustext",
    8853,
    "contintegraldisplay",
    8750,
    "contintegraltext",
    8750,
    "coproductdisplay",
    8720,
    "coproducttext",
    8720,
    "floorleftBig",
    8970,
    "floorleftbig",
    8970,
    "floorleftbigg",
    8970,
    "floorleftBigg",
    8970,
    "floorrightbig",
    8971,
    "floorrightBig",
    8971,
    "floorrightBigg",
    8971,
    "floorrightbigg",
    8971,
    "hatwide",
    770,
    "hatwider",
    770,
    "hatwidest",
    770,
    "intercal",
    7488,
    "integraldisplay",
    8747,
    "integraltext",
    8747,
    "intersectiondisplay",
    8898,
    "intersectiontext",
    8898,
    "logicalanddisplay",
    8743,
    "logicalandtext",
    8743,
    "logicalordisplay",
    8744,
    "logicalortext",
    8744,
    "parenleftBig",
    40,
    "parenleftbig",
    40,
    "parenleftBigg",
    40,
    "parenleftbigg",
    40,
    "parenrightBig",
    41,
    "parenrightbig",
    41,
    "parenrightBigg",
    41,
    "parenrightbigg",
    41,
    "prime",
    8242,
    "productdisplay",
    8719,
    "producttext",
    8719,
    "radicalbig",
    8730,
    "radicalBig",
    8730,
    "radicalBigg",
    8730,
    "radicalbigg",
    8730,
    "radicalbt",
    8730,
    "radicaltp",
    8730,
    "radicalvertex",
    8730,
    "slashbig",
    47,
    "slashBig",
    47,
    "slashBigg",
    47,
    "slashbigg",
    47,
    "summationdisplay",
    8721,
    "summationtext",
    8721,
    "tildewide",
    732,
    "tildewider",
    732,
    "tildewidest",
    732,
    "uniondisplay",
    8899,
    "unionmultidisplay",
    8846,
    "unionmultitext",
    8846,
    "unionsqdisplay",
    8852,
    "unionsqtext",
    8852,
    "uniontext",
    8899,
    "vextenddouble",
    8741,
    "vextendsingle",
    8739
  ];
});
var getDingbatsGlyphsUnicode = getArrayLookupTableFactory(function() {
  return [
    "space",
    32,
    "a1",
    9985,
    "a2",
    9986,
    "a202",
    9987,
    "a3",
    9988,
    "a4",
    9742,
    "a5",
    9990,
    "a119",
    9991,
    "a118",
    9992,
    "a117",
    9993,
    "a11",
    9755,
    "a12",
    9758,
    "a13",
    9996,
    "a14",
    9997,
    "a15",
    9998,
    "a16",
    9999,
    "a105",
    1e4,
    "a17",
    10001,
    "a18",
    10002,
    "a19",
    10003,
    "a20",
    10004,
    "a21",
    10005,
    "a22",
    10006,
    "a23",
    10007,
    "a24",
    10008,
    "a25",
    10009,
    "a26",
    10010,
    "a27",
    10011,
    "a28",
    10012,
    "a6",
    10013,
    "a7",
    10014,
    "a8",
    10015,
    "a9",
    10016,
    "a10",
    10017,
    "a29",
    10018,
    "a30",
    10019,
    "a31",
    10020,
    "a32",
    10021,
    "a33",
    10022,
    "a34",
    10023,
    "a35",
    9733,
    "a36",
    10025,
    "a37",
    10026,
    "a38",
    10027,
    "a39",
    10028,
    "a40",
    10029,
    "a41",
    10030,
    "a42",
    10031,
    "a43",
    10032,
    "a44",
    10033,
    "a45",
    10034,
    "a46",
    10035,
    "a47",
    10036,
    "a48",
    10037,
    "a49",
    10038,
    "a50",
    10039,
    "a51",
    10040,
    "a52",
    10041,
    "a53",
    10042,
    "a54",
    10043,
    "a55",
    10044,
    "a56",
    10045,
    "a57",
    10046,
    "a58",
    10047,
    "a59",
    10048,
    "a60",
    10049,
    "a61",
    10050,
    "a62",
    10051,
    "a63",
    10052,
    "a64",
    10053,
    "a65",
    10054,
    "a66",
    10055,
    "a67",
    10056,
    "a68",
    10057,
    "a69",
    10058,
    "a70",
    10059,
    "a71",
    9679,
    "a72",
    10061,
    "a73",
    9632,
    "a74",
    10063,
    "a203",
    10064,
    "a75",
    10065,
    "a204",
    10066,
    "a76",
    9650,
    "a77",
    9660,
    "a78",
    9670,
    "a79",
    10070,
    "a81",
    9687,
    "a82",
    10072,
    "a83",
    10073,
    "a84",
    10074,
    "a97",
    10075,
    "a98",
    10076,
    "a99",
    10077,
    "a100",
    10078,
    "a101",
    10081,
    "a102",
    10082,
    "a103",
    10083,
    "a104",
    10084,
    "a106",
    10085,
    "a107",
    10086,
    "a108",
    10087,
    "a112",
    9827,
    "a111",
    9830,
    "a110",
    9829,
    "a109",
    9824,
    "a120",
    9312,
    "a121",
    9313,
    "a122",
    9314,
    "a123",
    9315,
    "a124",
    9316,
    "a125",
    9317,
    "a126",
    9318,
    "a127",
    9319,
    "a128",
    9320,
    "a129",
    9321,
    "a130",
    10102,
    "a131",
    10103,
    "a132",
    10104,
    "a133",
    10105,
    "a134",
    10106,
    "a135",
    10107,
    "a136",
    10108,
    "a137",
    10109,
    "a138",
    10110,
    "a139",
    10111,
    "a140",
    10112,
    "a141",
    10113,
    "a142",
    10114,
    "a143",
    10115,
    "a144",
    10116,
    "a145",
    10117,
    "a146",
    10118,
    "a147",
    10119,
    "a148",
    10120,
    "a149",
    10121,
    "a150",
    10122,
    "a151",
    10123,
    "a152",
    10124,
    "a153",
    10125,
    "a154",
    10126,
    "a155",
    10127,
    "a156",
    10128,
    "a157",
    10129,
    "a158",
    10130,
    "a159",
    10131,
    "a160",
    10132,
    "a161",
    8594,
    "a163",
    8596,
    "a164",
    8597,
    "a196",
    10136,
    "a165",
    10137,
    "a192",
    10138,
    "a166",
    10139,
    "a167",
    10140,
    "a168",
    10141,
    "a169",
    10142,
    "a170",
    10143,
    "a171",
    10144,
    "a172",
    10145,
    "a173",
    10146,
    "a162",
    10147,
    "a174",
    10148,
    "a175",
    10149,
    "a176",
    10150,
    "a177",
    10151,
    "a178",
    10152,
    "a179",
    10153,
    "a193",
    10154,
    "a180",
    10155,
    "a199",
    10156,
    "a181",
    10157,
    "a200",
    10158,
    "a182",
    10159,
    "a201",
    10161,
    "a183",
    10162,
    "a184",
    10163,
    "a197",
    10164,
    "a185",
    10165,
    "a194",
    10166,
    "a198",
    10167,
    "a186",
    10168,
    "a195",
    10169,
    "a187",
    10170,
    "a188",
    10171,
    "a189",
    10172,
    "a190",
    10173,
    "a191",
    10174,
    "a89",
    10088,
    // 0xF8D7
    "a90",
    10089,
    // 0xF8D8
    "a93",
    10090,
    // 0xF8D9
    "a94",
    10091,
    // 0xF8DA
    "a91",
    10092,
    // 0xF8DB
    "a92",
    10093,
    // 0xF8DC
    "a205",
    10094,
    // 0xF8DD
    "a85",
    10095,
    // 0xF8DE
    "a206",
    10096,
    // 0xF8DF
    "a86",
    10097,
    // 0xF8E0
    "a87",
    10098,
    // 0xF8E1
    "a88",
    10099,
    // 0xF8E2
    "a95",
    10100,
    // 0xF8E3
    "a96",
    10101,
    // 0xF8E4
    ".notdef",
    0
  ];
});
var getSpecialPUASymbols = getLookupTableFactory(function(t) {
  t[63721] = 169;
  t[63193] = 169;
  t[63720] = 174;
  t[63194] = 174;
  t[63722] = 8482;
  t[63195] = 8482;
  t[63729] = 9127;
  t[63730] = 9128;
  t[63731] = 9129;
  t[63740] = 9131;
  t[63741] = 9132;
  t[63742] = 9133;
  t[63726] = 9121;
  t[63727] = 9122;
  t[63728] = 9123;
  t[63737] = 9124;
  t[63738] = 9125;
  t[63739] = 9126;
  t[63723] = 9115;
  t[63724] = 9116;
  t[63725] = 9117;
  t[63734] = 9118;
  t[63735] = 9119;
  t[63736] = 9120;
});
function mapSpecialUnicodeValues(code) {
  if (code >= 65520 && code <= 65535) {
    return 0;
  } else if (code >= 62976 && code <= 63743) {
    return getSpecialPUASymbols()[code] || code;
  } else if (code === /* softhyphen = */
  173) {
    return 45;
  }
  return code;
}
function getUnicodeForGlyph(name, glyphsUnicodeMap) {
  let unicode = glyphsUnicodeMap[name];
  if (unicode !== void 0) {
    return unicode;
  }
  if (!name) {
    return -1;
  }
  if (name[0] === "u") {
    const nameLen = name.length;
    let hexStr;
    if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
      hexStr = name.substring(3);
    } else if (nameLen >= 5 && nameLen <= 7) {
      hexStr = name.substring(1);
    } else {
      return -1;
    }
    if (hexStr === hexStr.toUpperCase()) {
      unicode = parseInt(hexStr, 16);
      if (unicode >= 0) {
        return unicode;
      }
    }
  }
  return -1;
}
var UnicodeRanges = [
  {
    begin: 0,
    end: 127
  },
  // Basic Latin
  {
    begin: 128,
    end: 255
  },
  // Latin-1 Supplement
  {
    begin: 256,
    end: 383
  },
  // Latin Extended-A
  {
    begin: 384,
    end: 591
  },
  // Latin Extended-B
  {
    begin: 592,
    end: 687
  },
  // IPA Extensions
  {
    begin: 688,
    end: 767
  },
  // Spacing Modifier Letters
  {
    begin: 768,
    end: 879
  },
  // Combining Diacritical Marks
  {
    begin: 880,
    end: 1023
  },
  // Greek and Coptic
  {
    begin: 11392,
    end: 11519
  },
  // Coptic
  {
    begin: 1024,
    end: 1279
  },
  // Cyrillic
  {
    begin: 1328,
    end: 1423
  },
  // Armenian
  {
    begin: 1424,
    end: 1535
  },
  // Hebrew
  {
    begin: 42240,
    end: 42559
  },
  // Vai
  {
    begin: 1536,
    end: 1791
  },
  // Arabic
  {
    begin: 1984,
    end: 2047
  },
  // NKo
  {
    begin: 2304,
    end: 2431
  },
  // Devanagari
  {
    begin: 2432,
    end: 2559
  },
  // Bengali
  {
    begin: 2560,
    end: 2687
  },
  // Gurmukhi
  {
    begin: 2688,
    end: 2815
  },
  // Gujarati
  {
    begin: 2816,
    end: 2943
  },
  // Oriya
  {
    begin: 2944,
    end: 3071
  },
  // Tamil
  {
    begin: 3072,
    end: 3199
  },
  // Telugu
  {
    begin: 3200,
    end: 3327
  },
  // Kannada
  {
    begin: 3328,
    end: 3455
  },
  // Malayalam
  {
    begin: 3584,
    end: 3711
  },
  // Thai
  {
    begin: 3712,
    end: 3839
  },
  // Lao
  {
    begin: 4256,
    end: 4351
  },
  // Georgian
  {
    begin: 6912,
    end: 7039
  },
  // Balinese
  {
    begin: 4352,
    end: 4607
  },
  // Hangul Jamo
  {
    begin: 7680,
    end: 7935
  },
  // Latin Extended Additional
  {
    begin: 7936,
    end: 8191
  },
  // Greek Extended
  {
    begin: 8192,
    end: 8303
  },
  // General Punctuation
  {
    begin: 8304,
    end: 8351
  },
  // Superscripts And Subscripts
  {
    begin: 8352,
    end: 8399
  },
  // Currency Symbol
  {
    begin: 8400,
    end: 8447
  },
  // Combining Diacritical Marks
  {
    begin: 8448,
    end: 8527
  },
  // Letterlike Symbols
  {
    begin: 8528,
    end: 8591
  },
  // Number Forms
  {
    begin: 8592,
    end: 8703
  },
  // Arrows
  {
    begin: 8704,
    end: 8959
  },
  // Mathematical Operators
  {
    begin: 8960,
    end: 9215
  },
  // Miscellaneous Technical
  {
    begin: 9216,
    end: 9279
  },
  // Control Pictures
  {
    begin: 9280,
    end: 9311
  },
  // Optical Character Recognition
  {
    begin: 9312,
    end: 9471
  },
  // Enclosed Alphanumerics
  {
    begin: 9472,
    end: 9599
  },
  // Box Drawing
  {
    begin: 9600,
    end: 9631
  },
  // Block Elements
  {
    begin: 9632,
    end: 9727
  },
  // Geometric Shapes
  {
    begin: 9728,
    end: 9983
  },
  // Miscellaneous Symbols
  {
    begin: 9984,
    end: 10175
  },
  // Dingbats
  {
    begin: 12288,
    end: 12351
  },
  // CJK Symbols And Punctuation
  {
    begin: 12352,
    end: 12447
  },
  // Hiragana
  {
    begin: 12448,
    end: 12543
  },
  // Katakana
  {
    begin: 12544,
    end: 12591
  },
  // Bopomofo
  {
    begin: 12592,
    end: 12687
  },
  // Hangul Compatibility Jamo
  {
    begin: 43072,
    end: 43135
  },
  // Phags-pa
  {
    begin: 12800,
    end: 13055
  },
  // Enclosed CJK Letters And Months
  {
    begin: 13056,
    end: 13311
  },
  // CJK Compatibility
  {
    begin: 44032,
    end: 55215
  },
  // Hangul Syllables
  {
    begin: 55296,
    end: 57343
  },
  // Non-Plane 0 *
  {
    begin: 67840,
    end: 67871
  },
  // Phoenicia
  {
    begin: 19968,
    end: 40959
  },
  // CJK Unified Ideographs
  {
    begin: 57344,
    end: 63743
  },
  // Private Use Area (plane 0)
  {
    begin: 12736,
    end: 12783
  },
  // CJK Strokes
  {
    begin: 64256,
    end: 64335
  },
  // Alphabetic Presentation Forms
  {
    begin: 64336,
    end: 65023
  },
  // Arabic Presentation Forms-A
  {
    begin: 65056,
    end: 65071
  },
  // Combining Half Marks
  {
    begin: 65040,
    end: 65055
  },
  // Vertical Forms
  {
    begin: 65104,
    end: 65135
  },
  // Small Form Variants
  {
    begin: 65136,
    end: 65279
  },
  // Arabic Presentation Forms-B
  {
    begin: 65280,
    end: 65519
  },
  // Halfwidth And Fullwidth Forms
  {
    begin: 65520,
    end: 65535
  },
  // Specials
  {
    begin: 3840,
    end: 4095
  },
  // Tibetan
  {
    begin: 1792,
    end: 1871
  },
  // Syriac
  {
    begin: 1920,
    end: 1983
  },
  // Thaana
  {
    begin: 3456,
    end: 3583
  },
  // Sinhala
  {
    begin: 4096,
    end: 4255
  },
  // Myanmar
  {
    begin: 4608,
    end: 4991
  },
  // Ethiopic
  {
    begin: 5024,
    end: 5119
  },
  // Cherokee
  {
    begin: 5120,
    end: 5759
  },
  // Unified Canadian Aboriginal Syllabics
  {
    begin: 5760,
    end: 5791
  },
  // Ogham
  {
    begin: 5792,
    end: 5887
  },
  // Runic
  {
    begin: 6016,
    end: 6143
  },
  // Khmer
  {
    begin: 6144,
    end: 6319
  },
  // Mongolian
  {
    begin: 10240,
    end: 10495
  },
  // Braille Patterns
  {
    begin: 40960,
    end: 42127
  },
  // Yi Syllables
  {
    begin: 5888,
    end: 5919
  },
  // Tagalog
  {
    begin: 66304,
    end: 66351
  },
  // Old Italic
  {
    begin: 66352,
    end: 66383
  },
  // Gothic
  {
    begin: 66560,
    end: 66639
  },
  // Deseret
  {
    begin: 118784,
    end: 119039
  },
  // Byzantine Musical Symbols
  {
    begin: 119808,
    end: 120831
  },
  // Mathematical Alphanumeric Symbols
  {
    begin: 1044480,
    end: 1048573
  },
  // Private Use (plane 15)
  {
    begin: 65024,
    end: 65039
  },
  // Variation Selectors
  {
    begin: 917504,
    end: 917631
  },
  // Tags
  {
    begin: 6400,
    end: 6479
  },
  // Limbu
  {
    begin: 6480,
    end: 6527
  },
  // Tai Le
  {
    begin: 6528,
    end: 6623
  },
  // New Tai Lue
  {
    begin: 6656,
    end: 6687
  },
  // Buginese
  {
    begin: 11264,
    end: 11359
  },
  // Glagolitic
  {
    begin: 11568,
    end: 11647
  },
  // Tifinagh
  {
    begin: 19904,
    end: 19967
  },
  // Yijing Hexagram Symbols
  {
    begin: 43008,
    end: 43055
  },
  // Syloti Nagri
  {
    begin: 65536,
    end: 65663
  },
  // Linear B Syllabary
  {
    begin: 65856,
    end: 65935
  },
  // Ancient Greek Numbers
  {
    begin: 66432,
    end: 66463
  },
  // Ugaritic
  {
    begin: 66464,
    end: 66527
  },
  // Old Persian
  {
    begin: 66640,
    end: 66687
  },
  // Shavian
  {
    begin: 66688,
    end: 66735
  },
  // Osmanya
  {
    begin: 67584,
    end: 67647
  },
  // Cypriot Syllabary
  {
    begin: 68096,
    end: 68191
  },
  // Kharoshthi
  {
    begin: 119552,
    end: 119647
  },
  // Tai Xuan Jing Symbols
  {
    begin: 73728,
    end: 74751
  },
  // Cuneiform
  {
    begin: 119648,
    end: 119679
  },
  // Counting Rod Numerals
  {
    begin: 7040,
    end: 7103
  },
  // Sundanese
  {
    begin: 7168,
    end: 7247
  },
  // Lepcha
  {
    begin: 7248,
    end: 7295
  },
  // Ol Chiki
  {
    begin: 43136,
    end: 43231
  },
  // Saurashtra
  {
    begin: 43264,
    end: 43311
  },
  // Kayah Li
  {
    begin: 43312,
    end: 43359
  },
  // Rejang
  {
    begin: 43520,
    end: 43615
  },
  // Cham
  {
    begin: 65936,
    end: 65999
  },
  // Ancient Symbols
  {
    begin: 66e3,
    end: 66047
  },
  // Phaistos Disc
  {
    begin: 66208,
    end: 66271
  },
  // Carian
  {
    begin: 127024,
    end: 127135
  }
  // Domino Tiles
];
function getUnicodeRangeFor(value) {
  for (let i = 0, ii = UnicodeRanges.length; i < ii; i++) {
    const range = UnicodeRanges[i];
    if (value >= range.begin && value < range.end) {
      return i;
    }
  }
  return -1;
}
function isRTLRangeFor(value) {
  let range = UnicodeRanges[13];
  if (value >= range.begin && value < range.end) {
    return true;
  }
  range = UnicodeRanges[11];
  if (value >= range.begin && value < range.end) {
    return true;
  }
  return false;
}
var getNormalizedUnicodes = getArrayLookupTableFactory(function() {
  return ["", " ", "", " ", "", " ", "", "", "", " ", "", "IJ", "", "ij", "", "L", "", "l", "", "n", "", "s", "", "D", "", "D", "", "d", "", "LJ", "", "Lj", "", "lj", "", "NJ", "", "Nj", "", "nj", "", "DZ", "", "Dz", "", "dz", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", ".", "", "..", "", "...", "", "", "", "", "", "", "", "", "", "!!", "", " ", "", "??", "", "?!", "", "!?", "", "", "", " ", "", "Rs", "", "a/c", "", "a/s", "", "C", "", "c/o", "", "c/u", "", "", "", "F", "", "No", "", "TEL", "", "", "", "", "", "", "", "", "", "FAX", "", "I", "", "II", "", "III", "", "IV", "", "V", "", "VI", "", "VII", "", "VIII", "", "IX", "", "X", "", "XI", "", "XII", "", "L", "", "C", "", "D", "", "M", "", "i", "", "ii", "", "iii", "", "iv", "", "v", "", "vi", "", "vii", "", "viii", "", "ix", "", "x", "", "xi", "", "xii", "", "l", "", "c", "", "d", "", "m", "", "", "", "", "", "", "", "", "", "(1)", "", "(2)", "", "(3)", "", "(4)", "", "(5)", "", "(6)", "", "(7)", "", "(8)", "", "(9)", "", "(10)", "", "(11)", "", "(12)", "", "(13)", "", "(14)", "", "(15)", "", "(16)", "", "(17)", "", "(18)", "", "(19)", "", "(20)", "", "1.", "", "2.", "", "3.", "", "4.", "", "5.", "", "6.", "", "7.", "", "8.", "", "9.", "", "10.", "", "11.", "", "12.", "", "13.", "", "14.", "", "15.", "", "16.", "", "17.", "", "18.", "", "19.", "", "20.", "", "(a)", "", "(b)", "", "(c)", "", "(d)", "", "(e)", "", "(f)", "", "(g)", "", "(h)", "", "(i)", "", "(j)", "", "(k)", "", "(l)", "", "(m)", "", "(n)", "", "(o)", "", "(p)", "", "(q)", "", "(r)", "", "(s)", "", "(t)", "", "(u)", "", "(v)", "", "(w)", "", "(x)", "", "(y)", "", "(z)", "", "", "", "::=", "", "==", "", "===", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", " ", "", " ", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "()", "", "1", "", "2", "", "3", "", "4", "", "5", "", "6", "", "7", "", "8", "", "9", "", "10", "", "11", "", "12", "", "0", "", "1", "", "2", "", "3", "", "4", "", "5", "", "6", "", "7", "", "8", "", "9", "", "10", "", "11", "", "12", "", "13", "", "14", "", "15", "", "16", "", "17", "", "18", "", "19", "", "20", "", "21", "", "22", "", "23", "", "24", "", "1", "", "2", "", "3", "", "4", "", "5", "", "6", "", "7", "", "8", "", "9", "", "10", "", "11", "", "12", "", "13", "", "14", "", "15", "", "16", "", "17", "", "18", "", "19", "", "20", "", "21", "", "22", "", "23", "", "24", "", "25", "", "26", "", "27", "", "28", "", "29", "", "30", "", "31", "", "ff", "", "fi", "", "fl", "", "ffi", "", "ffl", "", "t", "", "st", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", " ", "", " ", "", " ", "", " ", "", " ", "", " ", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "_", "", "_", "", "_", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
});
function reverseIfRtl(chars2) {
  const charsLength = chars2.length;
  if (charsLength <= 1 || !isRTLRangeFor(chars2.charCodeAt(0))) {
    return chars2;
  }
  const buf = [];
  for (let ii = charsLength - 1; ii >= 0; ii--) {
    buf.push(chars2[ii]);
  }
  return buf.join("");
}
var SEAC_ANALYSIS_ENABLED = true;
var FontFlags = {
  FixedPitch: 1,
  Serif: 2,
  Symbolic: 4,
  Script: 8,
  Nonsymbolic: 32,
  Italic: 64,
  AllCap: 65536,
  SmallCap: 131072,
  ForceBold: 262144
};
var MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function getFontType(type, subtype, isStandardFont = false) {
  switch (type) {
    case "Type1":
      if (isStandardFont) {
        return FontType.TYPE1STANDARD;
      }
      return subtype === "Type1C" ? FontType.TYPE1C : FontType.TYPE1;
    case "CIDFontType0":
      return subtype === "CIDFontType0C" ? FontType.CIDFONTTYPE0C : FontType.CIDFONTTYPE0;
    case "OpenType":
      return FontType.OPENTYPE;
    case "TrueType":
      return FontType.TRUETYPE;
    case "CIDFontType2":
      return FontType.CIDFONTTYPE2;
    case "MMType1":
      return FontType.MMTYPE1;
    case "Type0":
      return FontType.TYPE0;
    default:
      return FontType.UNKNOWN;
  }
}
function recoverGlyphName(name, glyphsUnicodeMap) {
  if (glyphsUnicodeMap[name] !== void 0) {
    return name;
  }
  const unicode = getUnicodeForGlyph(name, glyphsUnicodeMap);
  if (unicode !== -1) {
    for (const key in glyphsUnicodeMap) {
      if (glyphsUnicodeMap[key] === unicode) {
        return key;
      }
    }
  }
  info("Unable to recover a standard glyph name for: " + name);
  return name;
}
function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
  const charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
  let glyphId, charCode, baseEncoding;
  const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
  if (properties.isInternalFont) {
    baseEncoding = builtInEncoding;
    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  } else if (properties.baseEncodingName) {
    baseEncoding = getEncoding(properties.baseEncodingName);
    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  } else if (isSymbolicFont) {
    for (charCode in builtInEncoding) {
      charCodeToGlyphId[charCode] = builtInEncoding[charCode];
    }
  } else {
    baseEncoding = StandardEncoding;
    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  }
  const differences = properties.differences;
  let glyphsUnicodeMap;
  if (differences) {
    for (charCode in differences) {
      const glyphName = differences[charCode];
      glyphId = glyphNames.indexOf(glyphName);
      if (glyphId === -1) {
        if (!glyphsUnicodeMap) {
          glyphsUnicodeMap = getGlyphsUnicode();
        }
        const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
        if (standardGlyphName !== glyphName) {
          glyphId = glyphNames.indexOf(standardGlyphName);
        }
      }
      if (glyphId >= 0) {
        charCodeToGlyphId[charCode] = glyphId;
      } else {
        charCodeToGlyphId[charCode] = 0;
      }
    }
  }
  return charCodeToGlyphId;
}
function normalizeFontName(name) {
  return name.replace(/[,_]/g, "-").replace(/\s/g, "");
}
var getStdFontMap = getLookupTableFactory(function(t) {
  t["Times-Roman"] = "Times-Roman";
  t.Helvetica = "Helvetica";
  t.Courier = "Courier";
  t.Symbol = "Symbol";
  t["Times-Bold"] = "Times-Bold";
  t["Helvetica-Bold"] = "Helvetica-Bold";
  t["Courier-Bold"] = "Courier-Bold";
  t.ZapfDingbats = "ZapfDingbats";
  t["Times-Italic"] = "Times-Italic";
  t["Helvetica-Oblique"] = "Helvetica-Oblique";
  t["Courier-Oblique"] = "Courier-Oblique";
  t["Times-BoldItalic"] = "Times-BoldItalic";
  t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
  t["Courier-BoldOblique"] = "Courier-BoldOblique";
  t.ArialNarrow = "Helvetica";
  t["ArialNarrow-Bold"] = "Helvetica-Bold";
  t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialNarrow-Italic"] = "Helvetica-Oblique";
  t.ArialBlack = "Helvetica";
  t["ArialBlack-Bold"] = "Helvetica-Bold";
  t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
  t["ArialBlack-Italic"] = "Helvetica-Oblique";
  t["Arial-Black"] = "Helvetica";
  t["Arial-Black-Bold"] = "Helvetica-Bold";
  t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Black-Italic"] = "Helvetica-Oblique";
  t.Arial = "Helvetica";
  t["Arial-Bold"] = "Helvetica-Bold";
  t["Arial-BoldItalic"] = "Helvetica-BoldOblique";
  t["Arial-Italic"] = "Helvetica-Oblique";
  t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
  t["Arial-BoldMT"] = "Helvetica-Bold";
  t["Arial-ItalicMT"] = "Helvetica-Oblique";
  t.ArialMT = "Helvetica";
  t["Courier-BoldItalic"] = "Courier-BoldOblique";
  t["Courier-Italic"] = "Courier-Oblique";
  t.CourierNew = "Courier";
  t["CourierNew-Bold"] = "Courier-Bold";
  t["CourierNew-BoldItalic"] = "Courier-BoldOblique";
  t["CourierNew-Italic"] = "Courier-Oblique";
  t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
  t["CourierNewPS-BoldMT"] = "Courier-Bold";
  t["CourierNewPS-ItalicMT"] = "Courier-Oblique";
  t.CourierNewPSMT = "Courier";
  t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
  t["Helvetica-Italic"] = "Helvetica-Oblique";
  t["Symbol-Bold"] = "Symbol";
  t["Symbol-BoldItalic"] = "Symbol";
  t["Symbol-Italic"] = "Symbol";
  t.TimesNewRoman = "Times-Roman";
  t["TimesNewRoman-Bold"] = "Times-Bold";
  t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRoman-Italic"] = "Times-Italic";
  t.TimesNewRomanPS = "Times-Roman";
  t["TimesNewRomanPS-Bold"] = "Times-Bold";
  t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
  t["TimesNewRomanPS-BoldMT"] = "Times-Bold";
  t["TimesNewRomanPS-Italic"] = "Times-Italic";
  t["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
  t.TimesNewRomanPSMT = "Times-Roman";
  t["TimesNewRomanPSMT-Bold"] = "Times-Bold";
  t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
  t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
});
var getFontNameToFileMap = getLookupTableFactory(function(t) {
  t.Courier = "FoxitFixed.pfb";
  t["Courier-Bold"] = "FoxitFixedBold.pfb";
  t["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
  t["Courier-Oblique"] = "FoxitFixedItalic.pfb";
  t.Helvetica = "FoxitSans.pfb";
  t["Helvetica-Bold"] = "FoxitSansBold.pfb";
  t["Helvetica-BoldOblique"] = "FoxitSansBoldItalic.pfb";
  t["Helvetica-Oblique"] = "FoxitSansItalic.pfb";
  t["Times-Roman"] = "FoxitSerif.pfb";
  t["Times-Bold"] = "FoxitSerifBold.pfb";
  t["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
  t["Times-Italic"] = "FoxitSerifItalic.pfb";
  t.Symbol = "FoxitSymbol.pfb";
  t.ZapfDingbats = "FoxitDingbats.pfb";
  t["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
  t["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
  t["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
  t["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
});
var getNonStdFontMap = getLookupTableFactory(function(t) {
  t.Calibri = "Helvetica";
  t["Calibri-Bold"] = "Helvetica-Bold";
  t["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
  t["Calibri-Italic"] = "Helvetica-Oblique";
  t.CenturyGothic = "Helvetica";
  t["CenturyGothic-Bold"] = "Helvetica-Bold";
  t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
  t["CenturyGothic-Italic"] = "Helvetica-Oblique";
  t.ComicSansMS = "Comic Sans MS";
  t["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
  t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
  t["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
  t.LucidaConsole = "Courier";
  t["LucidaConsole-Bold"] = "Courier-Bold";
  t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
  t["LucidaConsole-Italic"] = "Courier-Oblique";
  t["LucidaSans-Demi"] = "Helvetica-Bold";
  t["MS-Gothic"] = "MS Gothic";
  t["MS-Gothic-Bold"] = "MS Gothic-Bold";
  t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
  t["MS-Gothic-Italic"] = "MS Gothic-Italic";
  t["MS-Mincho"] = "MS Mincho";
  t["MS-Mincho-Bold"] = "MS Mincho-Bold";
  t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
  t["MS-Mincho-Italic"] = "MS Mincho-Italic";
  t["MS-PGothic"] = "MS PGothic";
  t["MS-PGothic-Bold"] = "MS PGothic-Bold";
  t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
  t["MS-PGothic-Italic"] = "MS PGothic-Italic";
  t["MS-PMincho"] = "MS PMincho";
  t["MS-PMincho-Bold"] = "MS PMincho-Bold";
  t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
  t["MS-PMincho-Italic"] = "MS PMincho-Italic";
  t.NuptialScript = "Times-Italic";
  t.SegoeUISymbol = "Helvetica";
  t.Wingdings = "ZapfDingbats";
  t["Wingdings-Regular"] = "ZapfDingbats";
});
var getSerifFonts = getLookupTableFactory(function(t) {
  t["Adobe Jenson"] = true;
  t["Adobe Text"] = true;
  t.Albertus = true;
  t.Aldus = true;
  t.Alexandria = true;
  t.Algerian = true;
  t["American Typewriter"] = true;
  t.Antiqua = true;
  t.Apex = true;
  t.Arno = true;
  t.Aster = true;
  t.Aurora = true;
  t.Baskerville = true;
  t.Bell = true;
  t.Bembo = true;
  t["Bembo Schoolbook"] = true;
  t.Benguiat = true;
  t["Berkeley Old Style"] = true;
  t["Bernhard Modern"] = true;
  t["Berthold City"] = true;
  t.Bodoni = true;
  t["Bauer Bodoni"] = true;
  t["Book Antiqua"] = true;
  t.Bookman = true;
  t["Bordeaux Roman"] = true;
  t["Californian FB"] = true;
  t.Calisto = true;
  t.Calvert = true;
  t.Capitals = true;
  t.Cambria = true;
  t.Cartier = true;
  t.Caslon = true;
  t.Catull = true;
  t.Centaur = true;
  t["Century Old Style"] = true;
  t["Century Schoolbook"] = true;
  t.Chaparral = true;
  t["Charis SIL"] = true;
  t.Cheltenham = true;
  t["Cholla Slab"] = true;
  t.Clarendon = true;
  t.Clearface = true;
  t.Cochin = true;
  t.Colonna = true;
  t["Computer Modern"] = true;
  t["Concrete Roman"] = true;
  t.Constantia = true;
  t["Cooper Black"] = true;
  t.Corona = true;
  t.Ecotype = true;
  t.Egyptienne = true;
  t.Elephant = true;
  t.Excelsior = true;
  t.Fairfield = true;
  t["FF Scala"] = true;
  t.Folkard = true;
  t.Footlight = true;
  t.FreeSerif = true;
  t["Friz Quadrata"] = true;
  t.Garamond = true;
  t.Gentium = true;
  t.Georgia = true;
  t.Gloucester = true;
  t["Goudy Old Style"] = true;
  t["Goudy Schoolbook"] = true;
  t["Goudy Pro Font"] = true;
  t.Granjon = true;
  t["Guardian Egyptian"] = true;
  t.Heather = true;
  t.Hercules = true;
  t["High Tower Text"] = true;
  t.Hiroshige = true;
  t["Hoefler Text"] = true;
  t["Humana Serif"] = true;
  t.Imprint = true;
  t["Ionic No. 5"] = true;
  t.Janson = true;
  t.Joanna = true;
  t.Korinna = true;
  t.Lexicon = true;
  t["Liberation Serif"] = true;
  t["Linux Libertine"] = true;
  t.Literaturnaya = true;
  t.Lucida = true;
  t["Lucida Bright"] = true;
  t.Melior = true;
  t.Memphis = true;
  t.Miller = true;
  t.Minion = true;
  t.Modern = true;
  t["Mona Lisa"] = true;
  t["Mrs Eaves"] = true;
  t["MS Serif"] = true;
  t["Museo Slab"] = true;
  t["New York"] = true;
  t["Nimbus Roman"] = true;
  t["NPS Rawlinson Roadway"] = true;
  t.NuptialScript = true;
  t.Palatino = true;
  t.Perpetua = true;
  t.Plantin = true;
  t["Plantin Schoolbook"] = true;
  t.Playbill = true;
  t["Poor Richard"] = true;
  t["Rawlinson Roadway"] = true;
  t.Renault = true;
  t.Requiem = true;
  t.Rockwell = true;
  t.Roman = true;
  t["Rotis Serif"] = true;
  t.Sabon = true;
  t.Scala = true;
  t.Seagull = true;
  t.Sistina = true;
  t.Souvenir = true;
  t.STIX = true;
  t["Stone Informal"] = true;
  t["Stone Serif"] = true;
  t.Sylfaen = true;
  t.Times = true;
  t.Trajan = true;
  t["Trinit"] = true;
  t["Trump Mediaeval"] = true;
  t.Utopia = true;
  t["Vale Type"] = true;
  t["Bitstream Vera"] = true;
  t["Vera Serif"] = true;
  t.Versailles = true;
  t.Wanted = true;
  t.Weiss = true;
  t["Wide Latin"] = true;
  t.Windsor = true;
  t.XITS = true;
});
var getSymbolsFonts = getLookupTableFactory(function(t) {
  t.Dingbats = true;
  t.Symbol = true;
  t.ZapfDingbats = true;
});
var getGlyphMapForStandardFonts = getLookupTableFactory(function(t) {
  t[2] = 10;
  t[3] = 32;
  t[4] = 33;
  t[5] = 34;
  t[6] = 35;
  t[7] = 36;
  t[8] = 37;
  t[9] = 38;
  t[10] = 39;
  t[11] = 40;
  t[12] = 41;
  t[13] = 42;
  t[14] = 43;
  t[15] = 44;
  t[16] = 45;
  t[17] = 46;
  t[18] = 47;
  t[19] = 48;
  t[20] = 49;
  t[21] = 50;
  t[22] = 51;
  t[23] = 52;
  t[24] = 53;
  t[25] = 54;
  t[26] = 55;
  t[27] = 56;
  t[28] = 57;
  t[29] = 58;
  t[30] = 894;
  t[31] = 60;
  t[32] = 61;
  t[33] = 62;
  t[34] = 63;
  t[35] = 64;
  t[36] = 65;
  t[37] = 66;
  t[38] = 67;
  t[39] = 68;
  t[40] = 69;
  t[41] = 70;
  t[42] = 71;
  t[43] = 72;
  t[44] = 73;
  t[45] = 74;
  t[46] = 75;
  t[47] = 76;
  t[48] = 77;
  t[49] = 78;
  t[50] = 79;
  t[51] = 80;
  t[52] = 81;
  t[53] = 82;
  t[54] = 83;
  t[55] = 84;
  t[56] = 85;
  t[57] = 86;
  t[58] = 87;
  t[59] = 88;
  t[60] = 89;
  t[61] = 90;
  t[62] = 91;
  t[63] = 92;
  t[64] = 93;
  t[65] = 94;
  t[66] = 95;
  t[67] = 96;
  t[68] = 97;
  t[69] = 98;
  t[70] = 99;
  t[71] = 100;
  t[72] = 101;
  t[73] = 102;
  t[74] = 103;
  t[75] = 104;
  t[76] = 105;
  t[77] = 106;
  t[78] = 107;
  t[79] = 108;
  t[80] = 109;
  t[81] = 110;
  t[82] = 111;
  t[83] = 112;
  t[84] = 113;
  t[85] = 114;
  t[86] = 115;
  t[87] = 116;
  t[88] = 117;
  t[89] = 118;
  t[90] = 119;
  t[91] = 120;
  t[92] = 121;
  t[93] = 122;
  t[94] = 123;
  t[95] = 124;
  t[96] = 125;
  t[97] = 126;
  t[98] = 196;
  t[99] = 197;
  t[100] = 199;
  t[101] = 201;
  t[102] = 209;
  t[103] = 214;
  t[104] = 220;
  t[105] = 225;
  t[106] = 224;
  t[107] = 226;
  t[108] = 228;
  t[109] = 227;
  t[110] = 229;
  t[111] = 231;
  t[112] = 233;
  t[113] = 232;
  t[114] = 234;
  t[115] = 235;
  t[116] = 237;
  t[117] = 236;
  t[118] = 238;
  t[119] = 239;
  t[120] = 241;
  t[121] = 243;
  t[122] = 242;
  t[123] = 244;
  t[124] = 246;
  t[125] = 245;
  t[126] = 250;
  t[127] = 249;
  t[128] = 251;
  t[129] = 252;
  t[130] = 8224;
  t[131] = 176;
  t[132] = 162;
  t[133] = 163;
  t[134] = 167;
  t[135] = 8226;
  t[136] = 182;
  t[137] = 223;
  t[138] = 174;
  t[139] = 169;
  t[140] = 8482;
  t[141] = 180;
  t[142] = 168;
  t[143] = 8800;
  t[144] = 198;
  t[145] = 216;
  t[146] = 8734;
  t[147] = 177;
  t[148] = 8804;
  t[149] = 8805;
  t[150] = 165;
  t[151] = 181;
  t[152] = 8706;
  t[153] = 8721;
  t[154] = 8719;
  t[156] = 8747;
  t[157] = 170;
  t[158] = 186;
  t[159] = 8486;
  t[160] = 230;
  t[161] = 248;
  t[162] = 191;
  t[163] = 161;
  t[164] = 172;
  t[165] = 8730;
  t[166] = 402;
  t[167] = 8776;
  t[168] = 8710;
  t[169] = 171;
  t[170] = 187;
  t[171] = 8230;
  t[210] = 218;
  t[223] = 711;
  t[224] = 321;
  t[225] = 322;
  t[227] = 353;
  t[229] = 382;
  t[234] = 253;
  t[252] = 263;
  t[253] = 268;
  t[254] = 269;
  t[258] = 258;
  t[260] = 260;
  t[261] = 261;
  t[265] = 280;
  t[266] = 281;
  t[268] = 283;
  t[269] = 313;
  t[275] = 323;
  t[276] = 324;
  t[278] = 328;
  t[284] = 345;
  t[285] = 346;
  t[286] = 347;
  t[292] = 367;
  t[295] = 377;
  t[296] = 378;
  t[298] = 380;
  t[305] = 963;
  t[306] = 964;
  t[307] = 966;
  t[308] = 8215;
  t[309] = 8252;
  t[310] = 8319;
  t[311] = 8359;
  t[312] = 8592;
  t[313] = 8593;
  t[337] = 9552;
  t[493] = 1039;
  t[494] = 1040;
  t[705] = 1524;
  t[706] = 8362;
  t[710] = 64288;
  t[711] = 64298;
  t[759] = 1617;
  t[761] = 1776;
  t[763] = 1778;
  t[775] = 1652;
  t[777] = 1764;
  t[778] = 1780;
  t[779] = 1781;
  t[780] = 1782;
  t[782] = 771;
  t[783] = 64726;
  t[786] = 8363;
  t[788] = 8532;
  t[790] = 768;
  t[791] = 769;
  t[792] = 768;
  t[795] = 803;
  t[797] = 64336;
  t[798] = 64337;
  t[799] = 64342;
  t[800] = 64343;
  t[801] = 64344;
  t[802] = 64345;
  t[803] = 64362;
  t[804] = 64363;
  t[805] = 64364;
  t[2424] = 7821;
  t[2425] = 7822;
  t[2426] = 7823;
  t[2427] = 7824;
  t[2428] = 7825;
  t[2429] = 7826;
  t[2430] = 7827;
  t[2433] = 7682;
  t[2678] = 8045;
  t[2679] = 8046;
  t[2830] = 1552;
  t[2838] = 686;
  t[2840] = 751;
  t[2842] = 753;
  t[2843] = 754;
  t[2844] = 755;
  t[2846] = 757;
  t[2856] = 767;
  t[2857] = 848;
  t[2858] = 849;
  t[2862] = 853;
  t[2863] = 854;
  t[2864] = 855;
  t[2865] = 861;
  t[2866] = 862;
  t[2906] = 7460;
  t[2908] = 7462;
  t[2909] = 7463;
  t[2910] = 7464;
  t[2912] = 7466;
  t[2913] = 7467;
  t[2914] = 7468;
  t[2916] = 7470;
  t[2917] = 7471;
  t[2918] = 7472;
  t[2920] = 7474;
  t[2921] = 7475;
  t[2922] = 7476;
  t[2924] = 7478;
  t[2925] = 7479;
  t[2926] = 7480;
  t[2928] = 7482;
  t[2929] = 7483;
  t[2930] = 7484;
  t[2932] = 7486;
  t[2933] = 7487;
  t[2934] = 7488;
  t[2936] = 7490;
  t[2937] = 7491;
  t[2938] = 7492;
  t[2940] = 7494;
  t[2941] = 7495;
  t[2942] = 7496;
  t[2944] = 7498;
  t[2946] = 7500;
  t[2948] = 7502;
  t[2950] = 7504;
  t[2951] = 7505;
  t[2952] = 7506;
  t[2954] = 7508;
  t[2955] = 7509;
  t[2956] = 7510;
  t[2958] = 7512;
  t[2959] = 7513;
  t[2960] = 7514;
  t[2962] = 7516;
  t[2963] = 7517;
  t[2964] = 7518;
  t[2966] = 7520;
  t[2967] = 7521;
  t[2968] = 7522;
  t[2970] = 7524;
  t[2971] = 7525;
  t[2972] = 7526;
  t[2974] = 7528;
  t[2975] = 7529;
  t[2976] = 7530;
  t[2978] = 1537;
  t[2979] = 1538;
  t[2980] = 1539;
  t[2982] = 1549;
  t[2983] = 1551;
  t[2984] = 1552;
  t[2986] = 1554;
  t[2987] = 1555;
  t[2988] = 1556;
  t[2990] = 1623;
  t[2991] = 1624;
  t[2995] = 1775;
  t[2999] = 1791;
  t[3002] = 64290;
  t[3003] = 64291;
  t[3004] = 64292;
  t[3006] = 64294;
  t[3007] = 64295;
  t[3008] = 64296;
  t[3011] = 1900;
  t[3014] = 8223;
  t[3015] = 8244;
  t[3017] = 7532;
  t[3018] = 7533;
  t[3019] = 7534;
  t[3075] = 7590;
  t[3076] = 7591;
  t[3079] = 7594;
  t[3080] = 7595;
  t[3083] = 7598;
  t[3084] = 7599;
  t[3087] = 7602;
  t[3088] = 7603;
  t[3091] = 7606;
  t[3092] = 7607;
  t[3095] = 7610;
  t[3096] = 7611;
  t[3099] = 7614;
  t[3100] = 7615;
  t[3103] = 7618;
  t[3104] = 7619;
  t[3107] = 8337;
  t[3108] = 8338;
  t[3116] = 1884;
  t[3119] = 1885;
  t[3120] = 1885;
  t[3123] = 1886;
  t[3124] = 1886;
  t[3127] = 1887;
  t[3128] = 1887;
  t[3131] = 1888;
  t[3132] = 1888;
  t[3135] = 1889;
  t[3136] = 1889;
  t[3139] = 1890;
  t[3140] = 1890;
  t[3143] = 1891;
  t[3144] = 1891;
  t[3147] = 1892;
  t[3148] = 1892;
  t[3153] = 580;
  t[3154] = 581;
  t[3157] = 584;
  t[3158] = 585;
  t[3161] = 588;
  t[3162] = 589;
  t[3165] = 891;
  t[3166] = 892;
  t[3169] = 1274;
  t[3170] = 1275;
  t[3173] = 1278;
  t[3174] = 1279;
  t[3181] = 7622;
  t[3182] = 7623;
  t[3282] = 11799;
  t[3316] = 578;
  t[3379] = 42785;
  t[3393] = 1159;
  t[3416] = 8377;
});
var getSupplementalGlyphMapForArialBlack = getLookupTableFactory(function(t) {
  t[227] = 322;
  t[264] = 261;
  t[291] = 346;
});
var getSupplementalGlyphMapForCalibri = getLookupTableFactory(function(t) {
  t[1] = 32;
  t[4] = 65;
  t[17] = 66;
  t[18] = 67;
  t[24] = 68;
  t[28] = 69;
  t[38] = 70;
  t[39] = 71;
  t[44] = 72;
  t[47] = 73;
  t[58] = 74;
  t[60] = 75;
  t[62] = 76;
  t[68] = 77;
  t[69] = 78;
  t[75] = 79;
  t[87] = 80;
  t[89] = 81;
  t[90] = 82;
  t[94] = 83;
  t[100] = 84;
  t[104] = 85;
  t[115] = 86;
  t[116] = 87;
  t[121] = 88;
  t[122] = 89;
  t[127] = 90;
  t[258] = 97;
  t[268] = 261;
  t[271] = 98;
  t[272] = 99;
  t[273] = 263;
  t[282] = 100;
  t[286] = 101;
  t[295] = 281;
  t[296] = 102;
  t[336] = 103;
  t[346] = 104;
  t[349] = 105;
  t[361] = 106;
  t[364] = 107;
  t[367] = 108;
  t[371] = 322;
  t[373] = 109;
  t[374] = 110;
  t[381] = 111;
  t[383] = 243;
  t[393] = 112;
  t[395] = 113;
  t[396] = 114;
  t[400] = 115;
  t[401] = 347;
  t[410] = 116;
  t[437] = 117;
  t[448] = 118;
  t[449] = 119;
  t[454] = 120;
  t[455] = 121;
  t[460] = 122;
  t[463] = 380;
  t[853] = 44;
  t[855] = 58;
  t[856] = 46;
  t[876] = 47;
  t[878] = 45;
  t[882] = 45;
  t[894] = 40;
  t[895] = 41;
  t[896] = 91;
  t[897] = 93;
  t[923] = 64;
  t[1004] = 48;
  t[1005] = 49;
  t[1006] = 50;
  t[1007] = 51;
  t[1008] = 52;
  t[1009] = 53;
  t[1010] = 54;
  t[1011] = 55;
  t[1012] = 56;
  t[1013] = 57;
  t[1081] = 37;
  t[1085] = 43;
  t[1086] = 45;
});
function getStandardFontName(name) {
  const fontName = normalizeFontName(name);
  const stdFontMap = getStdFontMap();
  return stdFontMap[fontName];
}
var ToUnicodeMap = class {
  constructor(cmap = []) {
    this._map = cmap;
  }
  get length() {
    return this._map.length;
  }
  forEach(callback) {
    for (const charCode in this._map) {
      callback(charCode, this._map[charCode].charCodeAt(0));
    }
  }
  has(i) {
    return this._map[i] !== void 0;
  }
  get(i) {
    return this._map[i];
  }
  charCodeOf(value) {
    const map = this._map;
    if (map.length <= 65536) {
      return map.indexOf(value);
    }
    for (const charCode in map) {
      if (map[charCode] === value) {
        return charCode | 0;
      }
    }
    return -1;
  }
  amend(map) {
    for (const charCode in map) {
      this._map[charCode] = map[charCode];
    }
  }
};
var IdentityToUnicodeMap = class {
  constructor(firstChar, lastChar) {
    this.firstChar = firstChar;
    this.lastChar = lastChar;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(callback) {
    for (let i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
      callback(i, i);
    }
  }
  has(i) {
    return this.firstChar <= i && i <= this.lastChar;
  }
  get(i) {
    if (this.firstChar <= i && i <= this.lastChar) {
      return String.fromCharCode(i);
    }
    return void 0;
  }
  charCodeOf(v) {
    return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
  }
  amend(map) {
    unreachable("Should not call amend()");
  }
};
var CFFFont = class {
  constructor(file, properties) {
    this.properties = properties;
    const parser = new CFFParser(file, properties, SEAC_ANALYSIS_ENABLED);
    this.cff = parser.parse();
    this.cff.duplicateFirstGlyph();
    const compiler = new CFFCompiler(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = compiler.compile();
    } catch (e) {
      warn("Failed to compile font " + properties.loadedName);
      this.data = file;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const cff = this.cff;
    const properties = this.properties;
    const charsets = cff.charset.charset;
    let charCodeToGlyphId;
    let glyphId;
    if (properties.composite) {
      charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
      let charCode;
      if (cff.isCIDFont) {
        for (glyphId = 0; glyphId < charsets.length; glyphId++) {
          const cid = charsets[glyphId];
          charCode = properties.cMap.charCodeOf(cid);
          charCodeToGlyphId[charCode] = glyphId;
        }
      } else {
        for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
          charCode = properties.cMap.charCodeOf(glyphId);
          charCodeToGlyphId[charCode] = glyphId;
        }
      }
      return charCodeToGlyphId;
    }
    let encoding = cff.encoding ? cff.encoding.encoding : null;
    if (properties.isInternalFont) {
      encoding = properties.defaultEncoding;
    }
    charCodeToGlyphId = type1FontGlyphMapping(properties, encoding, charsets);
    return charCodeToGlyphId;
  }
  hasGlyphId(id) {
    return this.cff.hasGlyphId(id);
  }
  /**
   * @private
   */
  _createBuiltInEncoding() {
    const {
      charset,
      encoding
    } = this.cff;
    if (!charset || !encoding) {
      return;
    }
    const charsets = charset.charset, encodings = encoding.encoding;
    const map = [];
    for (const charCode in encodings) {
      const glyphId = encodings[charCode];
      if (glyphId >= 0) {
        const glyphName = charsets[glyphId];
        if (glyphName) {
          map[charCode] = glyphName;
        }
      }
    }
    if (map.length > 0) {
      this.properties.builtInEncoding = map;
    }
  }
};
function getLong(data, offset) {
  return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
}
function getUshort(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}
function getSubroutineBias(subrs) {
  const numSubrs = subrs.length;
  let bias = 32768;
  if (numSubrs < 1240) {
    bias = 107;
  } else if (numSubrs < 33900) {
    bias = 1131;
  }
  return bias;
}
function parseCmap(data, start, end) {
  const offset = getUshort(data, start + 2) === 1 ? getLong(data, start + 8) : getLong(data, start + 16);
  const format = getUshort(data, start + offset);
  let ranges, p, i;
  if (format === 4) {
    getUshort(data, start + offset + 2);
    const segCount = getUshort(data, start + offset + 6) >> 1;
    p = start + offset + 14;
    ranges = [];
    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i] = {
        end: getUshort(data, p)
      };
    }
    p += 2;
    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i].start = getUshort(data, p);
    }
    for (i = 0; i < segCount; i++, p += 2) {
      ranges[i].idDelta = getUshort(data, p);
    }
    for (i = 0; i < segCount; i++, p += 2) {
      let idOffset = getUshort(data, p);
      if (idOffset === 0) {
        continue;
      }
      ranges[i].ids = [];
      for (let j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
        ranges[i].ids[j] = getUshort(data, p + idOffset);
        idOffset += 2;
      }
    }
    return ranges;
  } else if (format === 12) {
    getLong(data, start + offset + 4);
    const groups = getLong(data, start + offset + 12);
    p = start + offset + 16;
    ranges = [];
    for (i = 0; i < groups; i++) {
      ranges.push({
        start: getLong(data, p),
        end: getLong(data, p + 4),
        idDelta: getLong(data, p + 8) - getLong(data, p)
      });
      p += 12;
    }
    return ranges;
  }
  throw new FormatError(`unsupported cmap: ${format}`);
}
function parseCff(data, start, end, seacAnalysisEnabled) {
  const properties = {};
  const parser = new CFFParser(new Stream(data, start, end - start), properties, seacAnalysisEnabled);
  const cff = parser.parse();
  return {
    glyphs: cff.charStrings.objects,
    subrs: cff.topDict.privateDict && cff.topDict.privateDict.subrsIndex && cff.topDict.privateDict.subrsIndex.objects,
    gsubrs: cff.globalSubrIndex && cff.globalSubrIndex.objects,
    isCFFCIDFont: cff.isCIDFont,
    fdSelect: cff.fdSelect,
    fdArray: cff.fdArray
  };
}
function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
  let itemSize, itemDecode;
  if (isGlyphLocationsLong) {
    itemSize = 4;
    itemDecode = function fontItemDecodeLong(data, offset) {
      return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
    };
  } else {
    itemSize = 2;
    itemDecode = function fontItemDecode(data, offset) {
      return data[offset] << 9 | data[offset + 1] << 1;
    };
  }
  const glyphs = [];
  let startOffset = itemDecode(loca, 0);
  for (let j = itemSize; j < loca.length; j += itemSize) {
    const endOffset = itemDecode(loca, j);
    glyphs.push(glyf.subarray(startOffset, endOffset));
    startOffset = endOffset;
  }
  return glyphs;
}
function lookupCmap(ranges, unicode) {
  const code = unicode.codePointAt(0);
  let gid = 0, l = 0, r = ranges.length - 1;
  while (l < r) {
    const c = l + r + 1 >> 1;
    if (code < ranges[c].start) {
      r = c - 1;
    } else {
      l = c;
    }
  }
  if (ranges[l].start <= code && code <= ranges[l].end) {
    gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 65535;
  }
  return {
    charCode: code,
    glyphId: gid
  };
}
function compileGlyf(code, cmds, font) {
  function moveTo(x2, y2) {
    cmds.push({
      cmd: "moveTo",
      args: [x2, y2]
    });
  }
  function lineTo(x2, y2) {
    cmds.push({
      cmd: "lineTo",
      args: [x2, y2]
    });
  }
  function quadraticCurveTo(xa, ya, x2, y2) {
    cmds.push({
      cmd: "quadraticCurveTo",
      args: [xa, ya, x2, y2]
    });
  }
  let i = 0;
  const numberOfContours = (code[i] << 24 | code[i + 1] << 16) >> 16;
  let flags;
  let x = 0, y = 0;
  i += 10;
  if (numberOfContours < 0) {
    do {
      flags = code[i] << 8 | code[i + 1];
      const glyphIndex = code[i + 2] << 8 | code[i + 3];
      i += 4;
      let arg1, arg2;
      if (flags & 1) {
        arg1 = (code[i] << 24 | code[i + 1] << 16) >> 16;
        arg2 = (code[i + 2] << 24 | code[i + 3] << 16) >> 16;
        i += 4;
      } else {
        arg1 = code[i++];
        arg2 = code[i++];
      }
      if (flags & 2) {
        x = arg1;
        y = arg2;
      } else {
        x = 0;
        y = 0;
      }
      let scaleX = 1, scaleY = 1, scale01 = 0, scale10 = 0;
      if (flags & 8) {
        scaleX = scaleY = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
        i += 2;
      } else if (flags & 64) {
        scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
        scaleY = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
        i += 4;
      } else if (flags & 128) {
        scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
        scale01 = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
        scale10 = (code[i + 4] << 24 | code[i + 5] << 16) / 1073741824;
        scaleY = (code[i + 6] << 24 | code[i + 7] << 16) / 1073741824;
        i += 8;
      }
      const subglyph = font.glyphs[glyphIndex];
      if (subglyph) {
        cmds.push({
          cmd: "save"
        }, {
          cmd: "transform",
          args: [scaleX, scale01, scale10, scaleY, x, y]
        });
        compileGlyf(subglyph, cmds, font);
        cmds.push({
          cmd: "restore"
        });
      }
    } while (flags & 32);
  } else {
    const endPtsOfContours = [];
    let j, jj;
    for (j = 0; j < numberOfContours; j++) {
      endPtsOfContours.push(code[i] << 8 | code[i + 1]);
      i += 2;
    }
    const instructionLength = code[i] << 8 | code[i + 1];
    i += 2 + instructionLength;
    const numberOfPoints = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    const points = [];
    while (points.length < numberOfPoints) {
      flags = code[i++];
      let repeat = 1;
      if (flags & 8) {
        repeat += code[i++];
      }
      while (repeat-- > 0) {
        points.push({
          flags
        });
      }
    }
    for (j = 0; j < numberOfPoints; j++) {
      switch (points[j].flags & 18) {
        case 0:
          x += (code[i] << 24 | code[i + 1] << 16) >> 16;
          i += 2;
          break;
        case 2:
          x -= code[i++];
          break;
        case 18:
          x += code[i++];
          break;
      }
      points[j].x = x;
    }
    for (j = 0; j < numberOfPoints; j++) {
      switch (points[j].flags & 36) {
        case 0:
          y += (code[i] << 24 | code[i + 1] << 16) >> 16;
          i += 2;
          break;
        case 4:
          y -= code[i++];
          break;
        case 36:
          y += code[i++];
          break;
      }
      points[j].y = y;
    }
    let startPoint = 0;
    for (i = 0; i < numberOfContours; i++) {
      const endPoint = endPtsOfContours[i];
      const contour = points.slice(startPoint, endPoint + 1);
      if (contour[0].flags & 1) {
        contour.push(contour[0]);
      } else if (contour[contour.length - 1].flags & 1) {
        contour.unshift(contour[contour.length - 1]);
      } else {
        const p = {
          flags: 1,
          x: (contour[0].x + contour[contour.length - 1].x) / 2,
          y: (contour[0].y + contour[contour.length - 1].y) / 2
        };
        contour.unshift(p);
        contour.push(p);
      }
      moveTo(contour[0].x, contour[0].y);
      for (j = 1, jj = contour.length; j < jj; j++) {
        if (contour[j].flags & 1) {
          lineTo(contour[j].x, contour[j].y);
        } else if (contour[j + 1].flags & 1) {
          quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
          j++;
        } else {
          quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
        }
      }
      startPoint = endPoint + 1;
    }
  }
}
function compileCharString(charStringCode, cmds, font, glyphId) {
  function moveTo(x2, y2) {
    cmds.push({
      cmd: "moveTo",
      args: [x2, y2]
    });
  }
  function lineTo(x2, y2) {
    cmds.push({
      cmd: "lineTo",
      args: [x2, y2]
    });
  }
  function bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    cmds.push({
      cmd: "bezierCurveTo",
      args: [x1, y1, x2, y2, x3, y3]
    });
  }
  const stack = [];
  let x = 0, y = 0;
  let stems = 0;
  function parse(code) {
    let i = 0;
    while (i < code.length) {
      let stackClean = false;
      let v = code[i++];
      let xa, xb, ya, yb, y1, y2, y3, n, subrCode;
      switch (v) {
        case 1:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 3:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 4:
          y += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;
        case 5:
          while (stack.length > 0) {
            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
          }
          break;
        case 6:
          while (stack.length > 0) {
            x += stack.shift();
            lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            y += stack.shift();
            lineTo(x, y);
          }
          break;
        case 7:
          while (stack.length > 0) {
            y += stack.shift();
            lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            x += stack.shift();
            lineTo(x, y);
          }
          break;
        case 8:
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 10:
          n = stack.pop();
          subrCode = null;
          if (font.isCFFCIDFont) {
            const fdIndex = font.fdSelect.getFDIndex(glyphId);
            if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
              const fontDict = font.fdArray[fdIndex];
              let subrs;
              if (fontDict.privateDict && fontDict.privateDict.subrsIndex) {
                subrs = fontDict.privateDict.subrsIndex.objects;
              }
              if (subrs) {
                n += getSubroutineBias(subrs);
                subrCode = subrs[n];
              }
            } else {
              warn("Invalid fd index for glyph index.");
            }
          } else {
            subrCode = font.subrs[n + font.subrsBias];
          }
          if (subrCode) {
            parse(subrCode);
          }
          break;
        case 11:
          return;
        case 12:
          v = code[i++];
          switch (v) {
            case 34:
              xa = x + stack.shift();
              xb = xa + stack.shift();
              y1 = y + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y, xb, y1, x, y1);
              xa = x + stack.shift();
              xb = xa + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y1, xb, y, x, y);
              break;
            case 35:
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              stack.pop();
              break;
            case 36:
              xa = x + stack.shift();
              y1 = y + stack.shift();
              xb = xa + stack.shift();
              y2 = y1 + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y1, xb, y2, x, y2);
              xa = x + stack.shift();
              xb = xa + stack.shift();
              y3 = y2 + stack.shift();
              x = xb + stack.shift();
              bezierCurveTo(xa, y2, xb, y3, x, y);
              break;
            case 37:
              const x0 = x, y0 = y;
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb + stack.shift();
              y = yb + stack.shift();
              bezierCurveTo(xa, ya, xb, yb, x, y);
              xa = x + stack.shift();
              ya = y + stack.shift();
              xb = xa + stack.shift();
              yb = ya + stack.shift();
              x = xb;
              y = yb;
              if (Math.abs(x - x0) > Math.abs(y - y0)) {
                x += stack.shift();
              } else {
                y += stack.shift();
              }
              bezierCurveTo(xa, ya, xb, yb, x, y);
              break;
            default:
              throw new FormatError(`unknown operator: 12 ${v}`);
          }
          break;
        case 14:
          if (stack.length >= 4) {
            const achar = stack.pop();
            const bchar = stack.pop();
            y = stack.pop();
            x = stack.pop();
            cmds.push({
              cmd: "save"
            }, {
              cmd: "translate",
              args: [x, y]
            });
            let cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[StandardEncoding[achar]]));
            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
            cmds.push({
              cmd: "restore"
            });
            cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[StandardEncoding[bchar]]));
            compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
          }
          return;
        case 18:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 19:
          stems += stack.length >> 1;
          i += stems + 7 >> 3;
          stackClean = true;
          break;
        case 20:
          stems += stack.length >> 1;
          i += stems + 7 >> 3;
          stackClean = true;
          break;
        case 21:
          y += stack.pop();
          x += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;
        case 22:
          x += stack.pop();
          moveTo(x, y);
          stackClean = true;
          break;
        case 23:
          stems += stack.length >> 1;
          stackClean = true;
          break;
        case 24:
          while (stack.length > 2) {
            xa = x + stack.shift();
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          x += stack.shift();
          y += stack.shift();
          lineTo(x, y);
          break;
        case 25:
          while (stack.length > 6) {
            x += stack.shift();
            y += stack.shift();
            lineTo(x, y);
          }
          xa = x + stack.shift();
          ya = y + stack.shift();
          xb = xa + stack.shift();
          yb = ya + stack.shift();
          x = xb + stack.shift();
          y = yb + stack.shift();
          bezierCurveTo(xa, ya, xb, yb, x, y);
          break;
        case 26:
          if (stack.length % 2) {
            x += stack.shift();
          }
          while (stack.length > 0) {
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb;
            y = yb + stack.shift();
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 27:
          if (stack.length % 2) {
            y += stack.shift();
          }
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb;
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 28:
          stack.push((code[i] << 24 | code[i + 1] << 16) >> 16);
          i += 2;
          break;
        case 29:
          n = stack.pop() + font.gsubrsBias;
          subrCode = font.gsubrs[n];
          if (subrCode) {
            parse(subrCode);
          }
          break;
        case 30:
          while (stack.length > 0) {
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
            if (stack.length === 0) {
              break;
            }
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            y = yb + stack.shift();
            x = xb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        case 31:
          while (stack.length > 0) {
            xa = x + stack.shift();
            ya = y;
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            y = yb + stack.shift();
            x = xb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
            if (stack.length === 0) {
              break;
            }
            xa = x;
            ya = y + stack.shift();
            xb = xa + stack.shift();
            yb = ya + stack.shift();
            x = xb + stack.shift();
            y = yb + (stack.length === 1 ? stack.shift() : 0);
            bezierCurveTo(xa, ya, xb, yb, x, y);
          }
          break;
        default:
          if (v < 32) {
            throw new FormatError(`unknown operator: ${v}`);
          }
          if (v < 247) {
            stack.push(v - 139);
          } else if (v < 251) {
            stack.push((v - 247) * 256 + code[i++] + 108);
          } else if (v < 255) {
            stack.push(-(v - 251) * 256 - code[i++] - 108);
          } else {
            stack.push((code[i] << 24 | code[i + 1] << 16 | code[i + 2] << 8 | code[i + 3]) / 65536);
            i += 4;
          }
          break;
      }
      if (stackClean) {
        stack.length = 0;
      }
    }
  }
  parse(charStringCode);
}
var NOOP = [];
var CompiledFont = class _CompiledFont {
  constructor(fontMatrix) {
    if (this.constructor === _CompiledFont) {
      unreachable("Cannot initialize CompiledFont.");
    }
    this.fontMatrix = fontMatrix;
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
  }
  getPathJs(unicode) {
    const {
      charCode,
      glyphId
    } = lookupCmap(this.cmap, unicode);
    let fn = this.compiledGlyphs[glyphId];
    if (!fn) {
      try {
        fn = this.compileGlyph(this.glyphs[glyphId], glyphId);
        this.compiledGlyphs[glyphId] = fn;
      } catch (ex) {
        this.compiledGlyphs[glyphId] = NOOP;
        if (this.compiledCharCodeToGlyphId[charCode] === void 0) {
          this.compiledCharCodeToGlyphId[charCode] = glyphId;
        }
        throw ex;
      }
    }
    if (this.compiledCharCodeToGlyphId[charCode] === void 0) {
      this.compiledCharCodeToGlyphId[charCode] = glyphId;
    }
    return fn;
  }
  compileGlyph(code, glyphId) {
    if (!code || code.length === 0 || code[0] === 14) {
      return NOOP;
    }
    let fontMatrix = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const fdIndex = this.fdSelect.getFDIndex(glyphId);
      if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
        const fontDict = this.fdArray[fdIndex];
        fontMatrix = fontDict.getByName("FontMatrix") || FONT_IDENTITY_MATRIX;
      } else {
        warn("Invalid fd index for glyph index.");
      }
    }
    const cmds = [{
      cmd: "save"
    }, {
      cmd: "transform",
      args: fontMatrix.slice()
    }, {
      cmd: "scale",
      args: ["size", "-size"]
    }];
    this.compileGlyphImpl(code, cmds, glyphId);
    cmds.push({
      cmd: "restore"
    });
    return cmds;
  }
  compileGlyphImpl() {
    unreachable("Children classes should implement this.");
  }
  hasBuiltPath(unicode) {
    const {
      charCode,
      glyphId
    } = lookupCmap(this.cmap, unicode);
    return this.compiledGlyphs[glyphId] !== void 0 && this.compiledCharCodeToGlyphId[charCode] !== void 0;
  }
};
var TrueTypeCompiled = class extends CompiledFont {
  constructor(glyphs, cmap, fontMatrix) {
    super(fontMatrix || [488e-6, 0, 0, 488e-6, 0, 0]);
    this.glyphs = glyphs;
    this.cmap = cmap;
  }
  compileGlyphImpl(code, cmds) {
    compileGlyf(code, cmds, this);
  }
};
var Type2Compiled = class extends CompiledFont {
  constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {
    super(fontMatrix || [1e-3, 0, 0, 1e-3, 0, 0]);
    this.glyphs = cffInfo.glyphs;
    this.gsubrs = cffInfo.gsubrs || [];
    this.subrs = cffInfo.subrs || [];
    this.cmap = cmap;
    this.glyphNameMap = glyphNameMap || getGlyphsUnicode();
    this.gsubrsBias = getSubroutineBias(this.gsubrs);
    this.subrsBias = getSubroutineBias(this.subrs);
    this.isCFFCIDFont = cffInfo.isCFFCIDFont;
    this.fdSelect = cffInfo.fdSelect;
    this.fdArray = cffInfo.fdArray;
  }
  compileGlyphImpl(code, cmds, glyphId) {
    compileCharString(code, cmds, this, glyphId);
  }
};
var FontRendererFactory = class {
  static create(font, seacAnalysisEnabled) {
    const data = new Uint8Array(font.data);
    let cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
    const numTables = getUshort(data, 4);
    for (let i = 0, p = 12; i < numTables; i++, p += 16) {
      const tag = bytesToString(data.subarray(p, p + 4));
      const offset = getLong(data, p + 8);
      const length = getLong(data, p + 12);
      switch (tag) {
        case "cmap":
          cmap = parseCmap(data, offset);
          break;
        case "glyf":
          glyf = data.subarray(offset, offset + length);
          break;
        case "loca":
          loca = data.subarray(offset, offset + length);
          break;
        case "head":
          unitsPerEm = getUshort(data, offset + 18);
          indexToLocFormat = getUshort(data, offset + 50);
          break;
        case "CFF ":
          cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
          break;
      }
    }
    if (glyf) {
      const fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
      return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
    }
    return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
  }
};
var ON_CURVE_POINT = 1 << 0;
var X_SHORT_VECTOR = 1 << 1;
var Y_SHORT_VECTOR = 1 << 2;
var REPEAT_FLAG = 1 << 3;
var X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR = 1 << 4;
var Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR = 1 << 5;
var OVERLAP_SIMPLE = 1 << 6;
var ARG_1_AND_2_ARE_WORDS = 1 << 0;
var ARGS_ARE_XY_VALUES = 1 << 1;
var WE_HAVE_A_SCALE = 1 << 3;
var MORE_COMPONENTS = 1 << 5;
var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
var WE_HAVE_INSTRUCTIONS = 1 << 8;
var GlyfTable = class {
  constructor({
    glyfTable,
    isGlyphLocationsLong,
    locaTable,
    numGlyphs
  }) {
    this.glyphs = [];
    const loca = new DataView(locaTable.buffer, locaTable.byteOffset, locaTable.byteLength);
    const glyf = new DataView(glyfTable.buffer, glyfTable.byteOffset, glyfTable.byteLength);
    const offsetSize = isGlyphLocationsLong ? 4 : 2;
    let prev = isGlyphLocationsLong ? loca.getUint32(0) : 2 * loca.getUint16(0);
    let pos = 0;
    for (let i = 0; i < numGlyphs; i++) {
      pos += offsetSize;
      const next = isGlyphLocationsLong ? loca.getUint32(pos) : 2 * loca.getUint16(pos);
      if (next === prev) {
        this.glyphs.push(new Glyph$1({}));
        continue;
      }
      const glyph = Glyph$1.parse(prev, glyf);
      this.glyphs.push(glyph);
      prev = next;
    }
  }
  getSize() {
    return this.glyphs.reduce((a, g) => {
      const size = g.getSize();
      return a + (size + 3 & ~3);
    }, 0);
  }
  write() {
    const totalSize = this.getSize();
    const glyfTable = new DataView(new ArrayBuffer(totalSize));
    const isLocationLong = totalSize > /* 0xffff * 2 */
    131070;
    const offsetSize = isLocationLong ? 4 : 2;
    const locaTable = new DataView(new ArrayBuffer((this.glyphs.length + 1) * offsetSize));
    if (isLocationLong) {
      locaTable.setUint32(0, 0);
    } else {
      locaTable.setUint16(0, 0);
    }
    let pos = 0;
    let locaIndex = 0;
    for (const glyph of this.glyphs) {
      pos += glyph.write(pos, glyfTable);
      pos = pos + 3 & ~3;
      locaIndex += offsetSize;
      if (isLocationLong) {
        locaTable.setUint32(locaIndex, pos);
      } else {
        locaTable.setUint16(locaIndex, pos >> 1);
      }
    }
    return {
      isLocationLong,
      loca: new Uint8Array(locaTable.buffer),
      glyf: new Uint8Array(glyfTable.buffer)
    };
  }
  scale(factors) {
    for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
      this.glyphs[i].scale(factors[i]);
    }
  }
};
var Glyph$1 = class _Glyph$1 {
  constructor({
    header = null,
    simple = null,
    composites = null
  }) {
    this.header = header;
    this.simple = simple;
    this.composites = composites;
  }
  static parse(pos, glyf) {
    const [read, header] = GlyphHeader.parse(pos, glyf);
    pos += read;
    if (header.numberOfContours < 0) {
      const composites = [];
      while (true) {
        const [n, composite] = CompositeGlyph.parse(pos, glyf);
        pos += n;
        composites.push(composite);
        if (!(composite.flags & MORE_COMPONENTS)) {
          break;
        }
      }
      return new _Glyph$1({
        header,
        composites
      });
    }
    const simple = SimpleGlyph.parse(pos, glyf, header.numberOfContours);
    return new _Glyph$1({
      header,
      simple
    });
  }
  getSize() {
    if (!this.header) {
      return 0;
    }
    const size = this.simple ? this.simple.getSize() : this.composites.reduce((a, c) => a + c.getSize(), 0);
    return this.header.getSize() + size;
  }
  write(pos, buf) {
    if (!this.header) {
      return 0;
    }
    const spos = pos;
    pos += this.header.write(pos, buf);
    if (this.simple) {
      pos += this.simple.write(pos, buf);
    } else {
      for (const composite of this.composites) {
        pos += composite.write(pos, buf);
      }
    }
    return pos - spos;
  }
  scale(factor) {
    if (!this.header) {
      return;
    }
    const xMiddle = (this.header.xMin + this.header.xMax) / 2;
    this.header.scale(xMiddle, factor);
    if (this.simple) {
      this.simple.scale(xMiddle, factor);
    } else {
      for (const composite of this.composites) {
        composite.scale(xMiddle, factor);
      }
    }
  }
};
var GlyphHeader = class _GlyphHeader {
  constructor({
    numberOfContours,
    xMin,
    yMin,
    xMax,
    yMax
  }) {
    this.numberOfContours = numberOfContours;
    this.xMin = xMin;
    this.yMin = yMin;
    this.xMax = xMax;
    this.yMax = yMax;
  }
  static parse(pos, glyf) {
    return [10, new _GlyphHeader({
      numberOfContours: glyf.getInt16(pos),
      xMin: glyf.getInt16(pos + 2),
      yMin: glyf.getInt16(pos + 4),
      xMax: glyf.getInt16(pos + 6),
      yMax: glyf.getInt16(pos + 8)
    })];
  }
  getSize() {
    return 10;
  }
  write(pos, buf) {
    buf.setInt16(pos, this.numberOfContours);
    buf.setInt16(pos + 2, this.xMin);
    buf.setInt16(pos + 4, this.yMin);
    buf.setInt16(pos + 6, this.xMax);
    buf.setInt16(pos + 8, this.yMax);
    return 10;
  }
  scale(x, factor) {
    this.xMin = Math.round(x + (this.xMin - x) * factor);
    this.xMax = Math.round(x + (this.xMax - x) * factor);
  }
};
var Contour = class {
  constructor({
    flags,
    xCoordinates,
    yCoordinates
  }) {
    this.xCoordinates = xCoordinates;
    this.yCoordinates = yCoordinates;
    this.flags = flags;
  }
};
var SimpleGlyph = class _SimpleGlyph {
  constructor({
    contours,
    instructions
  }) {
    this.contours = contours;
    this.instructions = instructions;
  }
  static parse(pos, glyf, numberOfContours) {
    const endPtsOfContours = [];
    for (let i = 0; i < numberOfContours; i++) {
      const endPt = glyf.getUint16(pos);
      pos += 2;
      endPtsOfContours.push(endPt);
    }
    const numberOfPt = endPtsOfContours[numberOfContours - 1] + 1;
    const instructionLength = glyf.getUint16(pos);
    pos += 2;
    const instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
    pos += instructionLength;
    const flags = [];
    for (let i = 0; i < numberOfPt; pos++, i++) {
      let flag = glyf.getUint8(pos);
      flags.push(flag);
      if (flag & REPEAT_FLAG) {
        const count = glyf.getUint8(++pos);
        flag ^= REPEAT_FLAG;
        for (let m = 0; m < count; m++) {
          flags.push(flag);
        }
        i += count;
      }
    }
    const allXCoordinates = [];
    let xCoordinates = [];
    let yCoordinates = [];
    let pointFlags = [];
    const contours = [];
    let endPtsOfContoursIndex = 0;
    let lastCoordinate = 0;
    for (let i = 0; i < numberOfPt; i++) {
      const flag = flags[i];
      if (flag & X_SHORT_VECTOR) {
        const x = glyf.getUint8(pos++);
        lastCoordinate += flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR ? x : -x;
        xCoordinates.push(lastCoordinate);
      } else if (flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR) {
        xCoordinates.push(lastCoordinate);
      } else {
        lastCoordinate += glyf.getInt16(pos);
        pos += 2;
        xCoordinates.push(lastCoordinate);
      }
      if (endPtsOfContours[endPtsOfContoursIndex] === i) {
        endPtsOfContoursIndex++;
        allXCoordinates.push(xCoordinates);
        xCoordinates = [];
      }
    }
    lastCoordinate = 0;
    endPtsOfContoursIndex = 0;
    for (let i = 0; i < numberOfPt; i++) {
      const flag = flags[i];
      if (flag & Y_SHORT_VECTOR) {
        const y = glyf.getUint8(pos++);
        lastCoordinate += flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR ? y : -y;
        yCoordinates.push(lastCoordinate);
      } else if (flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR) {
        yCoordinates.push(lastCoordinate);
      } else {
        lastCoordinate += glyf.getInt16(pos);
        pos += 2;
        yCoordinates.push(lastCoordinate);
      }
      pointFlags.push(flag & ON_CURVE_POINT | flag & OVERLAP_SIMPLE);
      if (endPtsOfContours[endPtsOfContoursIndex] === i) {
        xCoordinates = allXCoordinates[endPtsOfContoursIndex];
        endPtsOfContoursIndex++;
        contours.push(new Contour({
          flags: pointFlags,
          xCoordinates,
          yCoordinates
        }));
        yCoordinates = [];
        pointFlags = [];
      }
    }
    return new _SimpleGlyph({
      contours,
      instructions
    });
  }
  getSize() {
    let size = this.contours.length * 2 + 2 + this.instructions.length;
    let lastX = 0;
    let lastY = 0;
    for (const contour of this.contours) {
      size += contour.flags.length;
      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
        const x = contour.xCoordinates[i];
        const y = contour.yCoordinates[i];
        let abs = Math.abs(x - lastX);
        if (abs > 255) {
          size += 2;
        } else if (abs > 0) {
          size += 1;
        }
        lastX = x;
        abs = Math.abs(y - lastY);
        if (abs > 255) {
          size += 2;
        } else if (abs > 0) {
          size += 1;
        }
        lastY = y;
      }
    }
    return size;
  }
  write(pos, buf) {
    const spos = pos;
    const xCoordinates = [];
    const yCoordinates = [];
    const flags = [];
    let lastX = 0;
    let lastY = 0;
    for (const contour of this.contours) {
      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
        let flag = contour.flags[i];
        const x = contour.xCoordinates[i];
        let delta = x - lastX;
        if (delta === 0) {
          flag |= X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR;
          xCoordinates.push(0);
        } else {
          const abs = Math.abs(delta);
          if (abs <= 255) {
            flag |= delta >= 0 ? X_SHORT_VECTOR | X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR : X_SHORT_VECTOR;
            xCoordinates.push(abs);
          } else {
            xCoordinates.push(delta);
          }
        }
        lastX = x;
        const y = contour.yCoordinates[i];
        delta = y - lastY;
        if (delta === 0) {
          flag |= Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR;
          yCoordinates.push(0);
        } else {
          const abs = Math.abs(delta);
          if (abs <= 255) {
            flag |= delta >= 0 ? Y_SHORT_VECTOR | Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR : Y_SHORT_VECTOR;
            yCoordinates.push(abs);
          } else {
            yCoordinates.push(delta);
          }
        }
        lastY = y;
        flags.push(flag);
      }
      buf.setUint16(pos, xCoordinates.length - 1);
      pos += 2;
    }
    buf.setUint16(pos, this.instructions.length);
    pos += 2;
    if (this.instructions.length) {
      new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
      pos += this.instructions.length;
    }
    for (const flag of flags) {
      buf.setUint8(pos++, flag);
    }
    for (let i = 0, ii = xCoordinates.length; i < ii; i++) {
      const x = xCoordinates[i];
      const flag = flags[i];
      if (flag & X_SHORT_VECTOR) {
        buf.setUint8(pos++, x);
      } else if (!(flag & X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR)) {
        buf.setInt16(pos, x);
        pos += 2;
      }
    }
    for (let i = 0, ii = yCoordinates.length; i < ii; i++) {
      const y = yCoordinates[i];
      const flag = flags[i];
      if (flag & Y_SHORT_VECTOR) {
        buf.setUint8(pos++, y);
      } else if (!(flag & Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR)) {
        buf.setInt16(pos, y);
        pos += 2;
      }
    }
    return pos - spos;
  }
  scale(x, factor) {
    for (const contour of this.contours) {
      if (contour.xCoordinates.length === 0) {
        continue;
      }
      for (let i = 0, ii = contour.xCoordinates.length; i < ii; i++) {
        contour.xCoordinates[i] = Math.round(x + (contour.xCoordinates[i] - x) * factor);
      }
    }
  }
};
var CompositeGlyph = class _CompositeGlyph {
  constructor({
    flags,
    glyphIndex,
    argument1,
    argument2,
    transf,
    instructions
  }) {
    this.flags = flags;
    this.glyphIndex = glyphIndex;
    this.argument1 = argument1;
    this.argument2 = argument2;
    this.transf = transf;
    this.instructions = instructions;
  }
  static parse(pos, glyf) {
    const spos = pos;
    const transf = [];
    let flags = glyf.getUint16(pos);
    const glyphIndex = glyf.getUint16(pos + 2);
    pos += 4;
    let argument1, argument2;
    if (flags & ARG_1_AND_2_ARE_WORDS) {
      if (flags & ARGS_ARE_XY_VALUES) {
        argument1 = glyf.getInt16(pos);
        argument2 = glyf.getInt16(pos + 2);
      } else {
        argument1 = glyf.getUint16(pos);
        argument2 = glyf.getUint16(pos + 2);
      }
      pos += 4;
      flags ^= ARG_1_AND_2_ARE_WORDS;
    } else {
      argument1 = glyf.getUint8(pos);
      argument2 = glyf.getUint8(pos + 1);
      if (flags & ARGS_ARE_XY_VALUES) {
        const abs1 = argument1 & 127;
        argument1 = argument1 & 128 ? -abs1 : abs1;
        const abs2 = argument2 & 127;
        argument2 = argument2 & 128 ? -abs2 : abs2;
      }
      pos += 2;
    }
    if (flags & WE_HAVE_A_SCALE) {
      transf.push(glyf.getUint16(pos));
      pos += 2;
    } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
      transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2));
      pos += 4;
    } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
      transf.push(glyf.getUint16(pos), glyf.getUint16(pos + 2), glyf.getUint16(pos + 4), glyf.getUint16(pos + 6));
      pos += 8;
    }
    let instructions = null;
    if (flags & WE_HAVE_INSTRUCTIONS) {
      const instructionLength = glyf.getUint16(pos);
      pos += 2;
      instructions = new Uint8Array(glyf).slice(pos, pos + instructionLength);
      pos += instructionLength;
    }
    return [pos - spos, new _CompositeGlyph({
      flags,
      glyphIndex,
      argument1,
      argument2,
      transf,
      instructions
    })];
  }
  getSize() {
    let size = 2 + 2 + this.transf.length * 2;
    if (this.flags & WE_HAVE_INSTRUCTIONS) {
      size += 2 + this.instructions.length;
    }
    size += 2;
    if (this.flags & 2) {
      if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
        size += 2;
      }
    } else {
      if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
        size += 2;
      }
    }
    return size;
  }
  write(pos, buf) {
    const spos = pos;
    if (this.flags & ARGS_ARE_XY_VALUES) {
      if (!(this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127)) {
        this.flags |= ARG_1_AND_2_ARE_WORDS;
      }
    } else {
      if (!(this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255)) {
        this.flags |= ARG_1_AND_2_ARE_WORDS;
      }
    }
    buf.setUint16(pos, this.flags);
    buf.setUint16(pos + 2, this.glyphIndex);
    pos += 4;
    if (this.flags & ARG_1_AND_2_ARE_WORDS) {
      if (this.flags & ARGS_ARE_XY_VALUES) {
        buf.setInt16(pos, this.argument1);
        buf.setInt16(pos + 2, this.argument2);
      } else {
        buf.setUint16(pos, this.argument1);
        buf.setUint16(pos + 2, this.argument2);
      }
      pos += 4;
    } else {
      buf.setUint8(pos, this.argument1);
      buf.setUint8(pos + 1, this.argument2);
      pos += 2;
    }
    if (this.flags & WE_HAVE_INSTRUCTIONS) {
      buf.setUint16(pos, this.instructions.length);
      pos += 2;
      if (this.instructions.length) {
        new Uint8Array(buf.buffer, 0, buf.buffer.byteLength).set(this.instructions, pos);
        pos += this.instructions.length;
      }
    }
    return pos - spos;
  }
  scale(x, factor) {
  }
};
function writeInt16(dest, offset, num) {
  dest[offset] = num >> 8 & 255;
  dest[offset + 1] = num & 255;
}
function writeInt32(dest, offset, num) {
  dest[offset] = num >> 24 & 255;
  dest[offset + 1] = num >> 16 & 255;
  dest[offset + 2] = num >> 8 & 255;
  dest[offset + 3] = num & 255;
}
function writeData(dest, offset, data) {
  if (data instanceof Uint8Array) {
    dest.set(data, offset);
  } else if (typeof data === "string") {
    for (let i = 0, ii = data.length; i < ii; i++) {
      dest[offset++] = data.charCodeAt(i) & 255;
    }
  } else {
    for (let i = 0, ii = data.length; i < ii; i++) {
      dest[offset++] = data[i] & 255;
    }
  }
}
var OTF_HEADER_SIZE = 12;
var OTF_TABLE_ENTRY_SIZE = 16;
var OpenTypeFileBuilder = class _OpenTypeFileBuilder {
  constructor(sfnt) {
    this.sfnt = sfnt;
    this.tables = /* @__PURE__ */ Object.create(null);
  }
  static getSearchParams(entriesCount, entrySize) {
    let maxPower2 = 1, log22 = 0;
    while ((maxPower2 ^ entriesCount) > maxPower2) {
      maxPower2 <<= 1;
      log22++;
    }
    const searchRange = maxPower2 * entrySize;
    return {
      range: searchRange,
      entry: log22,
      rangeShift: entrySize * entriesCount - searchRange
    };
  }
  toArray() {
    let sfnt = this.sfnt;
    const tables = this.tables;
    const tablesNames = Object.keys(tables);
    tablesNames.sort();
    const numTables = tablesNames.length;
    let i, j, jj, table, tableName;
    let offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
    const tableOffsets = [offset];
    for (i = 0; i < numTables; i++) {
      table = tables[tablesNames[i]];
      const paddedLength = (table.length + 3 & ~3) >>> 0;
      offset += paddedLength;
      tableOffsets.push(offset);
    }
    const file = new Uint8Array(offset);
    for (i = 0; i < numTables; i++) {
      table = tables[tablesNames[i]];
      writeData(file, tableOffsets[i], table);
    }
    if (sfnt === "true") {
      sfnt = string32(65536);
    }
    file[0] = sfnt.charCodeAt(0) & 255;
    file[1] = sfnt.charCodeAt(1) & 255;
    file[2] = sfnt.charCodeAt(2) & 255;
    file[3] = sfnt.charCodeAt(3) & 255;
    writeInt16(file, 4, numTables);
    const searchParams = _OpenTypeFileBuilder.getSearchParams(numTables, 16);
    writeInt16(file, 6, searchParams.range);
    writeInt16(file, 8, searchParams.entry);
    writeInt16(file, 10, searchParams.rangeShift);
    offset = OTF_HEADER_SIZE;
    for (i = 0; i < numTables; i++) {
      tableName = tablesNames[i];
      file[offset] = tableName.charCodeAt(0) & 255;
      file[offset + 1] = tableName.charCodeAt(1) & 255;
      file[offset + 2] = tableName.charCodeAt(2) & 255;
      file[offset + 3] = tableName.charCodeAt(3) & 255;
      let checksum = 0;
      for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
        const quad = readUint32(file, j);
        checksum = checksum + quad >>> 0;
      }
      writeInt32(file, offset + 4, checksum);
      writeInt32(file, offset + 8, tableOffsets[i]);
      writeInt32(file, offset + 12, tables[tableName].length);
      offset += OTF_TABLE_ENTRY_SIZE;
    }
    return file;
  }
  addTable(tag, data) {
    if (tag in this.tables) {
      throw new Error("Table " + tag + " already exists");
    }
    this.tables[tag] = data;
  }
};
var HINTING_ENABLED = false;
var Type1CharString = /* @__PURE__ */ function Type1CharStringClosure() {
  const COMMAND_MAP = {
    hstem: [1],
    vstem: [3],
    vmoveto: [4],
    rlineto: [5],
    hlineto: [6],
    vlineto: [7],
    rrcurveto: [8],
    callsubr: [10],
    flex: [12, 35],
    drop: [12, 18],
    endchar: [14],
    rmoveto: [21],
    hmoveto: [22],
    vhcurveto: [30],
    hvcurveto: [31]
  };
  class Type1CharString2 {
    constructor() {
      this.width = 0;
      this.lsb = 0;
      this.flexing = false;
      this.output = [];
      this.stack = [];
    }
    convert(encoded, subrs, seacAnalysisEnabled) {
      const count = encoded.length;
      let error = false;
      let wx, sbx, subrNumber;
      for (let i = 0; i < count; i++) {
        let value = encoded[i];
        if (value < 32) {
          if (value === 12) {
            value = (value << 8) + encoded[++i];
          }
          switch (value) {
            case 1: {
              this.stack = [];
              break;
            }
            case 3: {
              this.stack = [];
              break;
            }
            case 4:
              if (this.flexing) {
                if (this.stack.length < 1) {
                  error = true;
                  break;
                }
                const dy = this.stack.pop();
                this.stack.push(0, dy);
                break;
              }
              error = this.executeCommand(1, COMMAND_MAP.vmoveto);
              break;
            case 5:
              error = this.executeCommand(2, COMMAND_MAP.rlineto);
              break;
            case 6:
              error = this.executeCommand(1, COMMAND_MAP.hlineto);
              break;
            case 7:
              error = this.executeCommand(1, COMMAND_MAP.vlineto);
              break;
            case 8:
              error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
              break;
            case 9:
              this.stack = [];
              break;
            case 10:
              if (this.stack.length < 1) {
                error = true;
                break;
              }
              subrNumber = this.stack.pop();
              if (!subrs[subrNumber]) {
                error = true;
                break;
              }
              error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
              break;
            case 11:
              return error;
            case 13:
              if (this.stack.length < 2) {
                error = true;
                break;
              }
              wx = this.stack.pop();
              sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(wx, sbx);
              error = this.executeCommand(2, COMMAND_MAP.hmoveto);
              break;
            case 14:
              this.output.push(COMMAND_MAP.endchar[0]);
              break;
            case 21:
              if (this.flexing) {
                break;
              }
              error = this.executeCommand(2, COMMAND_MAP.rmoveto);
              break;
            case 22:
              if (this.flexing) {
                this.stack.push(0);
                break;
              }
              error = this.executeCommand(1, COMMAND_MAP.hmoveto);
              break;
            case 30:
              error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
              break;
            case 31:
              error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
              break;
            case (12 << 8) + 0:
              this.stack = [];
              break;
            case (12 << 8) + 1: {
              this.stack = [];
              break;
            }
            case (12 << 8) + 2: {
              this.stack = [];
              break;
            }
            case (12 << 8) + 6:
              if (seacAnalysisEnabled) {
                const asb = this.stack[this.stack.length - 5];
                this.seac = this.stack.splice(-4, 4);
                this.seac[0] += this.lsb - asb;
                error = this.executeCommand(0, COMMAND_MAP.endchar);
              } else {
                error = this.executeCommand(4, COMMAND_MAP.endchar);
              }
              break;
            case (12 << 8) + 7:
              if (this.stack.length < 4) {
                error = true;
                break;
              }
              this.stack.pop();
              wx = this.stack.pop();
              const sby = this.stack.pop();
              sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(wx, sbx, sby);
              error = this.executeCommand(3, COMMAND_MAP.rmoveto);
              break;
            case (12 << 8) + 12:
              if (this.stack.length < 2) {
                error = true;
                break;
              }
              const num2 = this.stack.pop();
              const num1 = this.stack.pop();
              this.stack.push(num1 / num2);
              break;
            case (12 << 8) + 16:
              if (this.stack.length < 2) {
                error = true;
                break;
              }
              subrNumber = this.stack.pop();
              const numArgs = this.stack.pop();
              if (subrNumber === 0 && numArgs === 3) {
                const flexArgs = this.stack.splice(this.stack.length - 17, 17);
                this.stack.push(
                  flexArgs[2] + flexArgs[0],
                  // bcp1x + rpx
                  flexArgs[3] + flexArgs[1],
                  // bcp1y + rpy
                  flexArgs[4],
                  // bcp2x
                  flexArgs[5],
                  // bcp2y
                  flexArgs[6],
                  // p2x
                  flexArgs[7],
                  // p2y
                  flexArgs[8],
                  // bcp3x
                  flexArgs[9],
                  // bcp3y
                  flexArgs[10],
                  // bcp4x
                  flexArgs[11],
                  // bcp4y
                  flexArgs[12],
                  // p3x
                  flexArgs[13],
                  // p3y
                  flexArgs[14]
                  // flexDepth
                  // 15 = finalx unused by flex
                  // 16 = finaly unused by flex
                );
                error = this.executeCommand(13, COMMAND_MAP.flex, true);
                this.flexing = false;
                this.stack.push(flexArgs[15], flexArgs[16]);
              } else if (subrNumber === 1 && numArgs === 0) {
                this.flexing = true;
              }
              break;
            case (12 << 8) + 17:
              break;
            case (12 << 8) + 33:
              this.stack = [];
              break;
            default:
              warn('Unknown type 1 charstring command of "' + value + '"');
              break;
          }
          if (error) {
            break;
          }
          continue;
        } else if (value <= 246) {
          value -= 139;
        } else if (value <= 250) {
          value = (value - 247) * 256 + encoded[++i] + 108;
        } else if (value <= 254) {
          value = -((value - 251) * 256) - encoded[++i] - 108;
        } else {
          value = (encoded[++i] & 255) << 24 | (encoded[++i] & 255) << 16 | (encoded[++i] & 255) << 8 | (encoded[++i] & 255) << 0;
        }
        this.stack.push(value);
      }
      return error;
    }
    executeCommand(howManyArgs, command, keepStack) {
      const stackLength = this.stack.length;
      if (howManyArgs > stackLength) {
        return true;
      }
      const start = stackLength - howManyArgs;
      for (let i = start; i < stackLength; i++) {
        let value = this.stack[i];
        if (Number.isInteger(value)) {
          this.output.push(28, value >> 8 & 255, value & 255);
        } else {
          value = 65536 * value | 0;
          this.output.push(255, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
        }
      }
      this.output.push.apply(this.output, command);
      if (keepStack) {
        this.stack.splice(start, howManyArgs);
      } else {
        this.stack.length = 0;
      }
      return false;
    }
  }
  return Type1CharString2;
}();
var Type1Parser = /* @__PURE__ */ function Type1ParserClosure() {
  const EEXEC_ENCRYPT_KEY = 55665;
  const CHAR_STRS_ENCRYPT_KEY = 4330;
  function isHexDigit(code) {
    return code >= 48 && code <= 57 || // '0'-'9'
    code >= 65 && code <= 70 || // 'A'-'F'
    code >= 97 && code <= 102;
  }
  function decrypt(data, key, discardNumber) {
    if (discardNumber >= data.length) {
      return new Uint8Array(0);
    }
    const c1 = 52845, c2 = 22719;
    let r = key | 0, i, j;
    for (i = 0; i < discardNumber; i++) {
      r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
    }
    const count = data.length - discardNumber;
    const decrypted = new Uint8Array(count);
    for (i = discardNumber, j = 0; j < count; i++, j++) {
      const value = data[i];
      decrypted[j] = value ^ r >> 8;
      r = (value + r) * c1 + c2 & (1 << 16) - 1;
    }
    return decrypted;
  }
  function decryptAscii(data, key, discardNumber) {
    const c1 = 52845, c2 = 22719;
    let r = key | 0;
    const count = data.length, maybeLength = count >>> 1;
    const decrypted = new Uint8Array(maybeLength);
    let i, j;
    for (i = 0, j = 0; i < count; i++) {
      const digit1 = data[i];
      if (!isHexDigit(digit1)) {
        continue;
      }
      i++;
      let digit2;
      while (i < count && !isHexDigit(digit2 = data[i])) {
        i++;
      }
      if (i < count) {
        const value = parseInt(String.fromCharCode(digit1, digit2), 16);
        decrypted[j++] = value ^ r >> 8;
        r = (value + r) * c1 + c2 & (1 << 16) - 1;
      }
    }
    return decrypted.slice(discardNumber, j);
  }
  function isSpecial(c) {
    return c === /* '/' = */
    47 || c === /* '[' = */
    91 || c === /* ']' = */
    93 || c === /* '{' = */
    123 || c === /* '}' = */
    125 || c === /* '(' = */
    40 || c === /* ')' = */
    41;
  }
  class Type1Parser2 {
    constructor(stream, encrypted, seacAnalysisEnabled) {
      if (encrypted) {
        const data = stream.getBytes();
        const isBinary = !((isHexDigit(data[0]) || isWhiteSpace(data[0])) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]) && isHexDigit(data[4]) && isHexDigit(data[5]) && isHexDigit(data[6]) && isHexDigit(data[7]));
        stream = new Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
      }
      this.seacAnalysisEnabled = !!seacAnalysisEnabled;
      this.stream = stream;
      this.nextChar();
    }
    readNumberArray() {
      this.getToken();
      const array = [];
      while (true) {
        const token = this.getToken();
        if (token === null || token === "]" || token === "}") {
          break;
        }
        array.push(parseFloat(token || 0));
      }
      return array;
    }
    readNumber() {
      const token = this.getToken();
      return parseFloat(token || 0);
    }
    readInt() {
      const token = this.getToken();
      return parseInt(token || 0, 10) | 0;
    }
    readBoolean() {
      const token = this.getToken();
      return token === "true" ? 1 : 0;
    }
    nextChar() {
      return this.currentChar = this.stream.getByte();
    }
    getToken() {
      let comment = false;
      let ch = this.currentChar;
      while (true) {
        if (ch === -1) {
          return null;
        }
        if (comment) {
          if (ch === 10 || ch === 13) {
            comment = false;
          }
        } else if (ch === /* '%' = */
        37) {
          comment = true;
        } else if (!isWhiteSpace(ch)) {
          break;
        }
        ch = this.nextChar();
      }
      if (isSpecial(ch)) {
        this.nextChar();
        return String.fromCharCode(ch);
      }
      let token = "";
      do {
        token += String.fromCharCode(ch);
        ch = this.nextChar();
      } while (ch >= 0 && !isWhiteSpace(ch) && !isSpecial(ch));
      return token;
    }
    readCharStrings(bytes, lenIV) {
      if (lenIV === -1) {
        return bytes;
      }
      return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
    }
    /*
     * Returns an object containing a Subrs array and a CharStrings
     * array extracted from and eexec encrypted block of data
     */
    extractFontProgram(properties) {
      const stream = this.stream;
      const subrs = [], charstrings = [];
      const privateData = /* @__PURE__ */ Object.create(null);
      privateData.lenIV = 4;
      const program = {
        subrs: [],
        charstrings: [],
        properties: {
          privateData
        }
      };
      let token, length, data, lenIV, encoded;
      while ((token = this.getToken()) !== null) {
        if (token !== "/") {
          continue;
        }
        token = this.getToken();
        switch (token) {
          case "CharStrings":
            this.getToken();
            this.getToken();
            this.getToken();
            this.getToken();
            while (true) {
              token = this.getToken();
              if (token === null || token === "end") {
                break;
              }
              if (token !== "/") {
                continue;
              }
              const glyph = this.getToken();
              length = this.readInt();
              this.getToken();
              data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
              lenIV = program.properties.privateData.lenIV;
              encoded = this.readCharStrings(data, lenIV);
              this.nextChar();
              token = this.getToken();
              if (token === "noaccess") {
                this.getToken();
              }
              charstrings.push({
                glyph,
                encoded
              });
            }
            break;
          case "Subrs":
            this.readInt();
            this.getToken();
            while (this.getToken() === "dup") {
              const index = this.readInt();
              length = this.readInt();
              this.getToken();
              data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
              lenIV = program.properties.privateData.lenIV;
              encoded = this.readCharStrings(data, lenIV);
              this.nextChar();
              token = this.getToken();
              if (token === "noaccess") {
                this.getToken();
              }
              subrs[index] = encoded;
            }
            break;
          case "BlueValues":
          case "OtherBlues":
          case "FamilyBlues":
          case "FamilyOtherBlues":
            const blueArray = this.readNumberArray();
            if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
              program.properties.privateData[token] = blueArray;
            }
            break;
          case "StemSnapH":
          case "StemSnapV":
            program.properties.privateData[token] = this.readNumberArray();
            break;
          case "StdHW":
          case "StdVW":
            program.properties.privateData[token] = this.readNumberArray()[0];
            break;
          case "BlueShift":
          case "lenIV":
          case "BlueFuzz":
          case "BlueScale":
          case "LanguageGroup":
          case "ExpansionFactor":
            program.properties.privateData[token] = this.readNumber();
            break;
          case "ForceBold":
            program.properties.privateData[token] = this.readBoolean();
            break;
        }
      }
      for (let i = 0; i < charstrings.length; i++) {
        const glyph = charstrings[i].glyph;
        encoded = charstrings[i].encoded;
        const charString = new Type1CharString();
        const error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
        let output = charString.output;
        if (error) {
          output = [14];
        }
        const charStringObject = {
          glyphName: glyph,
          charstring: output,
          width: charString.width,
          lsb: charString.lsb,
          seac: charString.seac
        };
        if (glyph === ".notdef") {
          program.charstrings.unshift(charStringObject);
        } else {
          program.charstrings.push(charStringObject);
        }
        if (properties.builtInEncoding) {
          const index = properties.builtInEncoding.indexOf(glyph);
          if (index > -1 && properties.widths[index] === void 0 && index >= properties.firstChar && index <= properties.lastChar) {
            properties.widths[index] = charString.width;
          }
        }
      }
      return program;
    }
    extractFontHeader(properties) {
      let token;
      while ((token = this.getToken()) !== null) {
        if (token !== "/") {
          continue;
        }
        token = this.getToken();
        switch (token) {
          case "FontMatrix":
            const matrix = this.readNumberArray();
            properties.fontMatrix = matrix;
            break;
          case "Encoding":
            const encodingArg = this.getToken();
            let encoding;
            if (!/^\d+$/.test(encodingArg)) {
              encoding = getEncoding(encodingArg);
            } else {
              encoding = [];
              const size = parseInt(encodingArg, 10) | 0;
              this.getToken();
              for (let j = 0; j < size; j++) {
                token = this.getToken();
                while (token !== "dup" && token !== "def") {
                  token = this.getToken();
                  if (token === null) {
                    return;
                  }
                }
                if (token === "def") {
                  break;
                }
                const index = this.readInt();
                this.getToken();
                const glyph = this.getToken();
                encoding[index] = glyph;
                this.getToken();
              }
            }
            properties.builtInEncoding = encoding;
            break;
          case "FontBBox":
            const fontBBox = this.readNumberArray();
            properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
            properties.descent = Math.min(fontBBox[1], fontBBox[3]);
            properties.ascentScaled = true;
            break;
        }
      }
    }
  }
  return Type1Parser2;
}();
function findBlock(streamBytes, signature, startIndex) {
  const streamBytesLength = streamBytes.length;
  const signatureLength = signature.length;
  const scanLength = streamBytesLength - signatureLength;
  let i = startIndex, found = false;
  while (i < scanLength) {
    let j = 0;
    while (j < signatureLength && streamBytes[i + j] === signature[j]) {
      j++;
    }
    if (j >= signatureLength) {
      i += j;
      while (i < streamBytesLength && isWhiteSpace(streamBytes[i])) {
        i++;
      }
      found = true;
      break;
    }
    i++;
  }
  return {
    found,
    length: i
  };
}
function getHeaderBlock(stream, suggestedLength) {
  const EEXEC_SIGNATURE = [101, 101, 120, 101, 99];
  const streamStartPos = stream.pos;
  let headerBytes, headerBytesLength, block;
  try {
    headerBytes = stream.getBytes(suggestedLength);
    headerBytesLength = headerBytes.length;
  } catch (ex) {
  }
  if (headerBytesLength === suggestedLength) {
    block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);
    if (block.found && block.length === suggestedLength) {
      return {
        stream: new Stream(headerBytes),
        length: suggestedLength
      };
    }
  }
  warn('Invalid "Length1" property in Type1 font -- trying to recover.');
  stream.pos = streamStartPos;
  const SCAN_BLOCK_LENGTH = 2048;
  let actualLength;
  while (true) {
    const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
    block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);
    if (block.length === 0) {
      break;
    }
    stream.pos += block.length;
    if (block.found) {
      actualLength = stream.pos - streamStartPos;
      break;
    }
  }
  stream.pos = streamStartPos;
  if (actualLength) {
    return {
      stream: new Stream(stream.getBytes(actualLength)),
      length: actualLength
    };
  }
  warn('Unable to recover "Length1" property in Type1 font -- using as is.');
  return {
    stream: new Stream(stream.getBytes(suggestedLength)),
    length: suggestedLength
  };
}
function getEexecBlock(stream, suggestedLength) {
  const eexecBytes = stream.getBytes();
  return {
    stream: new Stream(eexecBytes),
    length: eexecBytes.length
  };
}
var Type1Font = class {
  constructor(name, file, properties) {
    const PFB_HEADER_SIZE = 6;
    let headerBlockLength = properties.length1;
    properties.length2;
    let pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
    const pfbHeaderPresent = pfbHeader[0] === 128 && pfbHeader[1] === 1;
    if (pfbHeaderPresent) {
      file.skip(PFB_HEADER_SIZE);
      headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }
    const headerBlock = getHeaderBlock(file, headerBlockLength);
    const headerBlockParser = new Type1Parser(headerBlock.stream, false, SEAC_ANALYSIS_ENABLED);
    headerBlockParser.extractFontHeader(properties);
    if (pfbHeaderPresent) {
      pfbHeader = file.getBytes(PFB_HEADER_SIZE);
      pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
    }
    const eexecBlock = getEexecBlock(file);
    const eexecBlockParser = new Type1Parser(eexecBlock.stream, true, SEAC_ANALYSIS_ENABLED);
    const data = eexecBlockParser.extractFontProgram(properties);
    for (const key in data.properties) {
      properties[key] = data.properties[key];
    }
    const charstrings = data.charstrings;
    const type2Charstrings = this.getType2Charstrings(charstrings);
    const subrs = this.getType2Subrs(data.subrs);
    this.charstrings = charstrings;
    this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
    this.seacs = this.getSeacs(data.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const charset = [".notdef"];
    const charstrings = this.charstrings;
    for (let glyphId = 0; glyphId < charstrings.length; glyphId++) {
      charset.push(charstrings[glyphId].glyphName);
    }
    return charset;
  }
  getGlyphMapping(properties) {
    const charstrings = this.charstrings;
    if (properties.composite) {
      const charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
      for (let glyphId2 = 0, charstringsLen = charstrings.length; glyphId2 < charstringsLen; glyphId2++) {
        const charCode = properties.cMap.charCodeOf(glyphId2);
        charCodeToGlyphId[charCode] = glyphId2 + 1;
      }
      return charCodeToGlyphId;
    }
    const glyphNames = [".notdef"];
    let builtInEncoding, glyphId;
    for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
      glyphNames.push(charstrings[glyphId].glyphName);
    }
    const encoding = properties.builtInEncoding;
    if (encoding) {
      builtInEncoding = /* @__PURE__ */ Object.create(null);
      for (const charCode in encoding) {
        glyphId = glyphNames.indexOf(encoding[charCode]);
        if (glyphId >= 0) {
          builtInEncoding[charCode] = glyphId;
        }
      }
    }
    return type1FontGlyphMapping(properties, builtInEncoding, glyphNames);
  }
  hasGlyphId(id) {
    if (id < 0 || id >= this.numGlyphs) {
      return false;
    }
    if (id === 0) {
      return true;
    }
    const glyph = this.charstrings[id - 1];
    return glyph.charstring.length > 0;
  }
  getSeacs(charstrings) {
    const seacMap = [];
    for (let i = 0, ii = charstrings.length; i < ii; i++) {
      const charstring = charstrings[i];
      if (charstring.seac) {
        seacMap[i + 1] = charstring.seac;
      }
    }
    return seacMap;
  }
  getType2Charstrings(type1Charstrings) {
    const type2Charstrings = [];
    for (let i = 0, ii = type1Charstrings.length; i < ii; i++) {
      type2Charstrings.push(type1Charstrings[i].charstring);
    }
    return type2Charstrings;
  }
  getType2Subrs(type1Subrs) {
    let bias = 0;
    const count = type1Subrs.length;
    if (count < 1133) {
      bias = 107;
    } else if (count < 33769) {
      bias = 1131;
    } else {
      bias = 32768;
    }
    const type2Subrs = [];
    let i;
    for (i = 0; i < bias; i++) {
      type2Subrs.push([11]);
    }
    for (i = 0; i < count; i++) {
      type2Subrs.push(type1Subrs[i]);
    }
    return type2Subrs;
  }
  wrap(name, glyphs, charstrings, subrs, properties) {
    const cff = new CFF();
    cff.header = new CFFHeader(1, 0, 4, 4);
    cff.names = [name];
    const topDict = new CFFTopDict();
    topDict.setByName("version", 391);
    topDict.setByName("Notice", 392);
    topDict.setByName("FullName", 393);
    topDict.setByName("FamilyName", 394);
    topDict.setByName("Weight", 395);
    topDict.setByName("Encoding", null);
    topDict.setByName("FontMatrix", properties.fontMatrix);
    topDict.setByName("FontBBox", properties.bbox);
    topDict.setByName("charset", null);
    topDict.setByName("CharStrings", null);
    topDict.setByName("Private", null);
    cff.topDict = topDict;
    const strings = new CFFStrings();
    strings.add("Version 0.11");
    strings.add("See original notice");
    strings.add(name);
    strings.add(name);
    strings.add("Medium");
    cff.strings = strings;
    cff.globalSubrIndex = new CFFIndex();
    const count = glyphs.length;
    const charsetArray = [".notdef"];
    let i, ii;
    for (i = 0; i < count; i++) {
      const glyphName = charstrings[i].glyphName;
      const index = CFFStandardStrings.indexOf(glyphName);
      if (index === -1) {
        strings.add(glyphName);
      }
      charsetArray.push(glyphName);
    }
    cff.charset = new CFFCharset(false, 0, charsetArray);
    const charStringsIndex = new CFFIndex();
    charStringsIndex.add([139, 14]);
    for (i = 0; i < count; i++) {
      charStringsIndex.add(glyphs[i]);
    }
    cff.charStrings = charStringsIndex;
    const privateDict = new CFFPrivateDict();
    privateDict.setByName("Subrs", null);
    const fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (i = 0, ii = fields.length; i < ii; i++) {
      const field = fields[i];
      if (!(field in properties.privateData)) {
        continue;
      }
      const value = properties.privateData[field];
      if (Array.isArray(value)) {
        for (let j = value.length - 1; j > 0; j--) {
          value[j] -= value[j - 1];
        }
      }
      privateDict.setByName(field, value);
    }
    cff.topDict.privateDict = privateDict;
    const subrIndex = new CFFIndex();
    for (i = 0, ii = subrs.length; i < ii; i++) {
      subrIndex.add(subrs[i]);
    }
    privateDict.subrsIndex = subrIndex;
    const compiler = new CFFCompiler(cff);
    return compiler.compile();
  }
};
var PRIVATE_USE_AREAS = [
  [57344, 63743],
  // BMP (0)
  [1048576, 1114109]
  // PUP (16)
];
var PDF_GLYPH_SPACE_UNITS = 1e3;
var EXPORT_DATA_PROPERTIES = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "fontType", "isMonospace", "isSerifFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "type", "vertical"];
var EXPORT_DATA_EXTRA_PROPERTIES = ["cMap", "defaultEncoding", "differences", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
function adjustWidths(properties) {
  if (!properties.fontMatrix) {
    return;
  }
  if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {
    return;
  }
  const scale = 1e-3 / properties.fontMatrix[0];
  const glyphsWidths = properties.widths;
  for (const glyph in glyphsWidths) {
    glyphsWidths[glyph] *= scale;
  }
  properties.defaultWidth *= scale;
}
function adjustToUnicode(properties, builtInEncoding) {
  if (properties.isInternalFont) {
    return;
  }
  if (builtInEncoding === properties.defaultEncoding) {
    return;
  }
  if (properties.toUnicode instanceof IdentityToUnicodeMap) {
    return;
  }
  const toUnicode = [], glyphsUnicodeMap = getGlyphsUnicode();
  for (const charCode in builtInEncoding) {
    if (properties.hasIncludedToUnicodeMap) {
      if (properties.toUnicode.has(charCode)) {
        continue;
      }
    } else {
      if (properties.hasEncoding && properties.differences[charCode] !== void 0) {
        continue;
      }
    }
    const glyphName = builtInEncoding[charCode];
    const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
    if (unicode !== -1) {
      toUnicode[charCode] = String.fromCharCode(unicode);
    }
  }
  if (toUnicode.length > 0) {
    properties.toUnicode.amend(toUnicode);
  }
}
function amendFallbackToUnicode(properties) {
  if (!properties.fallbackToUnicode) {
    return;
  }
  if (properties.toUnicode instanceof IdentityToUnicodeMap) {
    return;
  }
  const toUnicode = [];
  for (const charCode in properties.fallbackToUnicode) {
    if (properties.toUnicode.has(charCode)) {
      continue;
    }
    toUnicode[charCode] = properties.fallbackToUnicode[charCode];
  }
  if (toUnicode.length > 0) {
    properties.toUnicode.amend(toUnicode);
  }
}
var Glyph = class {
  constructor(originalCharCode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    this.originalCharCode = originalCharCode;
    this.fontChar = fontChar;
    this.unicode = unicode;
    this.accent = accent;
    this.width = width;
    this.vmetric = vmetric;
    this.operatorListId = operatorListId;
    this.isSpace = isSpace;
    this.isInFont = isInFont;
  }
  matchesForCache(originalCharCode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
    return this.originalCharCode === originalCharCode && this.fontChar === fontChar && this.unicode === unicode && this.accent === accent && this.width === width && this.vmetric === vmetric && this.operatorListId === operatorListId && this.isSpace === isSpace && this.isInFont === isInFont;
  }
};
function int16(b0, b1) {
  return (b0 << 8) + b1;
}
function writeSignedInt16(bytes, index, value) {
  bytes[index + 1] = value;
  bytes[index] = value >>> 8;
}
function signedInt16(b0, b1) {
  const value = (b0 << 8) + b1;
  return value & 1 << 15 ? value - 65536 : value;
}
function int32(b0, b1, b2, b3) {
  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
}
function string16(value) {
  if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
    assert(typeof value === "number" && Math.abs(value) < 2 ** 16, `string16: Unexpected input "${value}".`);
  }
  return String.fromCharCode(value >> 8 & 255, value & 255);
}
function safeString16(value) {
  if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
    assert(typeof value === "number" && !Number.isNaN(value), `safeString16: Unexpected input "${value}".`);
  }
  if (value > 32767) {
    value = 32767;
  } else if (value < -32768) {
    value = -32768;
  }
  return String.fromCharCode(value >> 8 & 255, value & 255);
}
function isTrueTypeFile(file) {
  const header = file.peekBytes(4);
  return readUint32(header, 0) === 65536 || bytesToString(header) === "true";
}
function isTrueTypeCollectionFile(file) {
  const header = file.peekBytes(4);
  return bytesToString(header) === "ttcf";
}
function isOpenTypeFile(file) {
  const header = file.peekBytes(4);
  return bytesToString(header) === "OTTO";
}
function isType1File(file) {
  const header = file.peekBytes(2);
  if (header[0] === 37 && header[1] === 33) {
    return true;
  }
  if (header[0] === 128 && header[1] === 1) {
    return true;
  }
  return false;
}
function isCFFFile(file) {
  const header = file.peekBytes(4);
  if (
    /* major version, [1, 255] */
    header[0] >= 1 && /* minor version, [0, 255]; header[1] */
    /* header size, [0, 255]; header[2] */
    /* offset(0) size, [1, 4] */
    header[3] >= 1 && header[3] <= 4
  ) {
    return true;
  }
  return false;
}
function getFontFileType(file, {
  type,
  subtype,
  composite
}) {
  let fileType, fileSubtype;
  if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
    if (composite) {
      fileType = "CIDFontType2";
    } else {
      fileType = "TrueType";
    }
  } else if (isOpenTypeFile(file)) {
    if (composite) {
      fileType = "CIDFontType2";
    } else {
      fileType = "OpenType";
    }
  } else if (isType1File(file)) {
    if (composite) {
      fileType = "CIDFontType0";
    } else {
      fileType = type === "MMType1" ? "MMType1" : "Type1";
    }
  } else if (isCFFFile(file)) {
    if (composite) {
      fileType = "CIDFontType0";
      fileSubtype = "CIDFontType0C";
    } else {
      fileType = type === "MMType1" ? "MMType1" : "Type1";
      fileSubtype = "Type1C";
    }
  } else {
    warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
    fileType = type;
    fileSubtype = subtype;
  }
  return [fileType, fileSubtype];
}
function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
  const toFontChar = [];
  let unicode;
  for (let i = 0, ii = encoding.length; i < ii; i++) {
    unicode = getUnicodeForGlyph(encoding[i], glyphsUnicodeMap);
    if (unicode !== -1) {
      toFontChar[i] = unicode;
    }
  }
  for (const charCode in differences) {
    unicode = getUnicodeForGlyph(differences[charCode], glyphsUnicodeMap);
    if (unicode !== -1) {
      toFontChar[+charCode] = unicode;
    }
  }
  return toFontChar;
}
function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId) {
  const newMap = /* @__PURE__ */ Object.create(null);
  const toFontChar = [];
  let privateUseAreaIndex = 0;
  let nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
  let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
  for (let originalCharCode in charCodeToGlyphId) {
    originalCharCode |= 0;
    let glyphId = charCodeToGlyphId[originalCharCode];
    if (!hasGlyph(glyphId)) {
      continue;
    }
    if (nextAvailableFontCharCode > privateUseOffetEnd) {
      privateUseAreaIndex++;
      if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
        warn("Ran out of space in font private use area.");
        break;
      }
      nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
      privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
    }
    const fontCharCode = nextAvailableFontCharCode++;
    if (glyphId === 0) {
      glyphId = newGlyphZeroId;
    }
    newMap[fontCharCode] = glyphId;
    toFontChar[originalCharCode] = fontCharCode;
  }
  return {
    toFontChar,
    charCodeToGlyphId: newMap,
    nextAvailableFontCharCode
  };
}
function getRanges(glyphs, numGlyphs) {
  const codes = [];
  for (const charCode in glyphs) {
    if (glyphs[charCode] >= numGlyphs) {
      continue;
    }
    codes.push({
      fontCharCode: charCode | 0,
      glyphId: glyphs[charCode]
    });
  }
  if (codes.length === 0) {
    codes.push({
      fontCharCode: 0,
      glyphId: 0
    });
  }
  codes.sort(function fontGetRangesSort(a, b) {
    return a.fontCharCode - b.fontCharCode;
  });
  const ranges = [];
  const length = codes.length;
  for (let n = 0; n < length; ) {
    const start = codes[n].fontCharCode;
    const codeIndices = [codes[n].glyphId];
    ++n;
    let end = start;
    while (n < length && end + 1 === codes[n].fontCharCode) {
      codeIndices.push(codes[n].glyphId);
      ++end;
      ++n;
      if (end === 65535) {
        break;
      }
    }
    ranges.push([start, end, codeIndices]);
  }
  return ranges;
}
function createCmapTable(glyphs, numGlyphs) {
  const ranges = getRanges(glyphs, numGlyphs);
  const numTables = ranges[ranges.length - 1][1] > 65535 ? 2 : 1;
  let cmap = "\0\0" + // version
  string16(numTables) + // numTables
  "\0\0" + // encodingID
  string32(4 + numTables * 8);
  let i, ii, j, jj;
  for (i = ranges.length - 1; i >= 0; --i) {
    if (ranges[i][0] <= 65535) {
      break;
    }
  }
  const bmpLength = i + 1;
  if (ranges[i][0] < 65535 && ranges[i][1] === 65535) {
    ranges[i][1] = 65534;
  }
  const trailingRangesCount = ranges[i][1] < 65535 ? 1 : 0;
  const segCount = bmpLength + trailingRangesCount;
  const searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
  let startCount = "";
  let endCount = "";
  let idDeltas = "";
  let idRangeOffsets = "";
  let glyphsIds = "";
  let bias = 0;
  let range, start, end, codes;
  for (i = 0, ii = bmpLength; i < ii; i++) {
    range = ranges[i];
    start = range[0];
    end = range[1];
    startCount += string16(start);
    endCount += string16(end);
    codes = range[2];
    let contiguous = true;
    for (j = 1, jj = codes.length; j < jj; ++j) {
      if (codes[j] !== codes[j - 1] + 1) {
        contiguous = false;
        break;
      }
    }
    if (!contiguous) {
      const offset = (segCount - i) * 2 + bias * 2;
      bias += end - start + 1;
      idDeltas += string16(0);
      idRangeOffsets += string16(offset);
      for (j = 0, jj = codes.length; j < jj; ++j) {
        glyphsIds += string16(codes[j]);
      }
    } else {
      const startCode = codes[0];
      idDeltas += string16(startCode - start & 65535);
      idRangeOffsets += string16(0);
    }
  }
  if (trailingRangesCount > 0) {
    endCount += "";
    startCount += "";
    idDeltas += "\0";
    idRangeOffsets += "\0\0";
  }
  const format314 = "\0\0" + // language
  string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\0\0" + startCount + idDeltas + idRangeOffsets + glyphsIds;
  let format31012 = "";
  let header31012 = "";
  if (numTables > 1) {
    cmap += "\0\0\n" + // encodingID
    string32(4 + numTables * 8 + 4 + format314.length);
    format31012 = "";
    for (i = 0, ii = ranges.length; i < ii; i++) {
      range = ranges[i];
      start = range[0];
      codes = range[2];
      let code = codes[0];
      for (j = 1, jj = codes.length; j < jj; ++j) {
        if (codes[j] !== codes[j - 1] + 1) {
          end = range[0] + j - 1;
          format31012 += string32(start) + // startCharCode
          string32(end) + // endCharCode
          string32(code);
          start = end + 1;
          code = codes[j];
        }
      }
      format31012 += string32(start) + // startCharCode
      string32(range[1]) + // endCharCode
      string32(code);
    }
    header31012 = "\0\f\0\0" + // reserved
    string32(format31012.length + 16) + // length
    "\0\0\0\0" + // language
    string32(format31012.length / 12);
  }
  return cmap + "\0" + // format
  string16(format314.length + 4) + // length
  format314 + header31012 + format31012;
}
function validateOS2Table(os2, file) {
  file.pos = (file.start || 0) + os2.offset;
  const version = file.getUint16();
  file.skip(60);
  const selection = file.getUint16();
  if (version < 4 && selection & 768) {
    return false;
  }
  const firstChar = file.getUint16();
  const lastChar = file.getUint16();
  if (firstChar > lastChar) {
    return false;
  }
  file.skip(6);
  const usWinAscent = file.getUint16();
  if (usWinAscent === 0) {
    return false;
  }
  os2.data[8] = os2.data[9] = 0;
  return true;
}
function createOS2Table(properties, charstrings, override) {
  override = override || {
    unitsPerEm: 0,
    yMax: 0,
    yMin: 0,
    ascent: 0,
    descent: 0
  };
  let ulUnicodeRange1 = 0;
  let ulUnicodeRange2 = 0;
  let ulUnicodeRange3 = 0;
  let ulUnicodeRange4 = 0;
  let firstCharIndex = null;
  let lastCharIndex = 0;
  if (charstrings) {
    for (let code in charstrings) {
      code |= 0;
      if (firstCharIndex > code || !firstCharIndex) {
        firstCharIndex = code;
      }
      if (lastCharIndex < code) {
        lastCharIndex = code;
      }
      const position = getUnicodeRangeFor(code);
      if (position < 32) {
        ulUnicodeRange1 |= 1 << position;
      } else if (position < 64) {
        ulUnicodeRange2 |= 1 << position - 32;
      } else if (position < 96) {
        ulUnicodeRange3 |= 1 << position - 64;
      } else if (position < 123) {
        ulUnicodeRange4 |= 1 << position - 96;
      } else {
        throw new FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
      }
    }
    if (lastCharIndex > 65535) {
      lastCharIndex = 65535;
    }
  } else {
    firstCharIndex = 0;
    lastCharIndex = 255;
  }
  const bbox = properties.bbox || [0, 0, 0, 0];
  const unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
  const scale = properties.ascentScaled ? 1 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
  const typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
  let typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));
  if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
    typoDescent = -typoDescent;
  }
  const winAscent = override.yMax || typoAscent;
  const winDescent = -override.yMin || -typoDescent;
  return "\0$\0\0\0\0\0\0\0\0\x001\0\0\0\0" + String.fromCharCode(properties.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + // Panose
  string32(ulUnicodeRange1) + // ulUnicodeRange1 (Bits 0-31)
  string32(ulUnicodeRange2) + // ulUnicodeRange2 (Bits 32-63)
  string32(ulUnicodeRange3) + // ulUnicodeRange3 (Bits 64-95)
  string32(ulUnicodeRange4) + // ulUnicodeRange4 (Bits 96-127)
  "*21*" + // achVendID
  string16(properties.italicAngle ? 1 : 0) + // fsSelection
  string16(firstCharIndex || properties.firstChar) + // usFirstCharIndex
  string16(lastCharIndex || properties.lastChar) + // usLastCharIndex
  string16(typoAscent) + // sTypoAscender
  string16(typoDescent) + // sTypoDescender
  "\0d" + // sTypoLineGap (7%-10% of the unitsPerEM value)
  string16(winAscent) + // usWinAscent
  string16(winDescent) + // usWinDescent
  "\0\0\0\0\0\0\0\0" + // ulCodePageRange2 (Bits 32-63)
  string16(properties.xHeight) + // sxHeight
  string16(properties.capHeight) + // sCapHeight
  string16(0) + // usDefaultChar
  string16(firstCharIndex || properties.firstChar) + // usBreakChar
  "\0";
}
function createPostTable(properties) {
  const angle = Math.floor(properties.italicAngle * 2 ** 16);
  return "\0\0\0" + // Version number
  string32(angle) + // italicAngle
  "\0\0\0\0" + // underlineThickness
  string32(properties.fixedPitch ? 1 : 0) + // isFixedPitch
  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(name) {
  return name.replace(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(name, proto) {
  if (!proto) {
    proto = [[], []];
  }
  const strings = [
    proto[0][0] || "Original licence",
    // 0.Copyright
    proto[0][1] || name,
    // 1.Font family
    proto[0][2] || "Unknown",
    // 2.Font subfamily (font weight)
    proto[0][3] || "uniqueID",
    // 3.Unique ID
    proto[0][4] || name,
    // 4.Full font name
    proto[0][5] || "Version 0.11",
    // 5.Version
    proto[0][6] || createPostscriptName(name),
    // 6.Postscript name
    proto[0][7] || "Unknown",
    // 7.Trademark
    proto[0][8] || "Unknown",
    // 8.Manufacturer
    proto[0][9] || "Unknown"
    // 9.Designer
  ];
  const stringsUnicode = [];
  let i, ii, j, jj, str;
  for (i = 0, ii = strings.length; i < ii; i++) {
    str = proto[1][i] || strings[i];
    const strBufUnicode = [];
    for (j = 0, jj = str.length; j < jj; j++) {
      strBufUnicode.push(string16(str.charCodeAt(j)));
    }
    stringsUnicode.push(strBufUnicode.join(""));
  }
  const names = [strings, stringsUnicode];
  const platforms = ["\0", "\0"];
  const encodings = ["\0\0", "\0"];
  const languages = ["\0\0", "	"];
  const namesRecordCount = strings.length * platforms.length;
  let nameTable = "\0\0" + // format
  string16(namesRecordCount) + // Number of names Record
  string16(namesRecordCount * 12 + 6);
  let strOffset = 0;
  for (i = 0, ii = platforms.length; i < ii; i++) {
    const strs = names[i];
    for (j = 0, jj = strs.length; j < jj; j++) {
      str = strs[j];
      const nameRecord = platforms[i] + // platform ID
      encodings[i] + // encoding ID
      languages[i] + // language ID
      string16(j) + // name ID
      string16(str.length) + string16(strOffset);
      nameTable += nameRecord;
      strOffset += str.length;
    }
  }
  nameTable += strings.join("") + stringsUnicode.join("");
  return nameTable;
}
var Font$1 = class {
  constructor(name, file, properties) {
    this.name = name;
    this.psName = null;
    this.mimetype = null;
    this.disableFontFace = false;
    this.loadedName = properties.loadedName;
    this.isType3Font = properties.isType3Font;
    this.missingFile = false;
    this.cssFontInfo = properties.cssFontInfo;
    this._charsCache = /* @__PURE__ */ Object.create(null);
    this._glyphCache = /* @__PURE__ */ Object.create(null);
    this.isSerifFont = !!(properties.flags & FontFlags.Serif);
    this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
    this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
    let type = properties.type;
    let subtype = properties.subtype;
    this.type = type;
    this.subtype = subtype;
    let fallbackName = "sans-serif";
    if (this.isMonospace) {
      fallbackName = "monospace";
    } else if (this.isSerifFont) {
      fallbackName = "serif";
    }
    this.fallbackName = fallbackName;
    this.differences = properties.differences;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.composite = properties.composite;
    this.cMap = properties.cMap;
    this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
    this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
    this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
    this.lineHeight = this.ascent - this.descent;
    this.fontMatrix = properties.fontMatrix;
    this.bbox = properties.bbox;
    this.defaultEncoding = properties.defaultEncoding;
    this.toUnicode = properties.toUnicode;
    this.toFontChar = [];
    if (properties.type === "Type3") {
      for (let charCode = 0; charCode < 256; charCode++) {
        this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
      }
      this.fontType = FontType.TYPE3;
      return;
    }
    this.cidEncoding = properties.cidEncoding;
    this.vertical = !!properties.vertical;
    if (this.vertical) {
      this.vmetrics = properties.vmetrics;
      this.defaultVMetrics = properties.defaultVMetrics;
    }
    if (!file || file.isEmpty) {
      if (file) {
        warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
      }
      this.fallbackToSystemFont(properties);
      return;
    }
    [type, subtype] = getFontFileType(file, properties);
    if (type !== this.type || subtype !== this.subtype) {
      info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${type}/${subtype}.`);
    }
    let data;
    try {
      switch (type) {
        case "MMType1":
          info("MMType1 font (" + name + "), falling back to Type1.");
        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const cff = subtype === "Type1C" || subtype === "CIDFontType0C" ? new CFFFont(file, properties) : new Type1Font(name, file, properties);
          adjustWidths(properties);
          data = this.convert(name, cff, properties);
          break;
        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype";
          data = this.checkAndRepair(name, file, properties);
          if (this.isOpenType) {
            adjustWidths(properties);
            type = "OpenType";
          }
          break;
        default:
          throw new FormatError(`Font ${type} is not supported`);
      }
    } catch (e) {
      warn(e);
      this.fallbackToSystemFont(properties);
      return;
    }
    amendFallbackToUnicode(properties);
    this.data = data;
    this.fontType = getFontType(type, subtype, properties.isStandardFont);
    this.fontMatrix = properties.fontMatrix;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.toUnicode = properties.toUnicode;
    this.seacMap = properties.seacMap;
  }
  get renderer() {
    const renderer = FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
    return shadow(this, "renderer", renderer);
  }
  exportData(extraProperties = false) {
    const exportDataProperties = extraProperties ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES] : EXPORT_DATA_PROPERTIES;
    const data = /* @__PURE__ */ Object.create(null);
    let property, value;
    for (property of exportDataProperties) {
      value = this[property];
      if (value !== void 0) {
        data[property] = value;
      }
    }
    return data;
  }
  fallbackToSystemFont(properties) {
    this.missingFile = true;
    const name = this.name;
    const type = this.type;
    const subtype = this.subtype;
    let fontName = normalizeFontName(name);
    const stdFontMap = getStdFontMap(), nonStdFontMap = getNonStdFontMap();
    const isStandardFont = !!stdFontMap[fontName];
    const isMappedToStandardFont = !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
    fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
    this.bold = fontName.search(/bold/gi) !== -1;
    this.italic = fontName.search(/oblique/gi) !== -1 || fontName.search(/italic/gi) !== -1;
    this.black = name.search(/Black/g) !== -1;
    const isNarrow = name.search(/Narrow/g) !== -1;
    this.remeasure = (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
    if ((isStandardFont || isMappedToStandardFont) && type === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
      const GlyphMapForStandardFonts = getGlyphMapForStandardFonts(), cidToGidMap = properties.cidToGidMap;
      const map = [];
      for (const charCode in GlyphMapForStandardFonts) {
        map[+charCode] = GlyphMapForStandardFonts[charCode];
      }
      if (/Arial-?Black/i.test(name)) {
        const SupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack();
        for (const charCode in SupplementalGlyphMapForArialBlack) {
          map[+charCode] = SupplementalGlyphMapForArialBlack[charCode];
        }
      } else if (/Calibri/i.test(name)) {
        const SupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri();
        for (const charCode in SupplementalGlyphMapForCalibri) {
          map[+charCode] = SupplementalGlyphMapForCalibri[charCode];
        }
      }
      if (cidToGidMap) {
        for (const charCode in map) {
          const cid = map[charCode];
          if (cidToGidMap[cid] !== void 0) {
            map[+charCode] = cidToGidMap[cid];
          }
        }
      }
      const isIdentityUnicode = this.toUnicode instanceof IdentityToUnicodeMap;
      if (!isIdentityUnicode) {
        this.toUnicode.forEach(function(charCode, unicodeCharCode) {
          map[+charCode] = unicodeCharCode;
        });
      }
      this.toFontChar = map;
      this.toUnicode = new ToUnicodeMap(map);
    } else if (/Symbol/i.test(fontName)) {
      this.toFontChar = buildToFontChar(SymbolSetEncoding, getGlyphsUnicode(), this.differences);
    } else if (/Dingbats/i.test(fontName)) {
      if (/Wingdings/i.test(name)) {
        warn("Non-embedded Wingdings font, falling back to ZapfDingbats.");
      }
      this.toFontChar = buildToFontChar(ZapfDingbatsEncoding, getDingbatsGlyphsUnicode(), this.differences);
    } else if (isStandardFont) {
      this.toFontChar = buildToFontChar(this.defaultEncoding, getGlyphsUnicode(), this.differences);
    } else {
      const glyphsUnicodeMap = getGlyphsUnicode();
      const map = [];
      this.toUnicode.forEach((charCode, unicodeCharCode) => {
        if (!this.composite) {
          const glyphName = this.differences[charCode] || this.defaultEncoding[charCode];
          const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
          if (unicode !== -1) {
            unicodeCharCode = unicode;
          }
        }
        map[+charCode] = unicodeCharCode;
      });
      if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {
        if (/Verdana/i.test(name)) {
          const GlyphMapForStandardFonts = getGlyphMapForStandardFonts();
          for (const charCode in GlyphMapForStandardFonts) {
            map[+charCode] = GlyphMapForStandardFonts[charCode];
          }
        }
      }
      this.toFontChar = map;
    }
    amendFallbackToUnicode(properties);
    this.loadedName = fontName.split("-")[0];
    this.fontType = getFontType(type, subtype, properties.isStandardFont);
  }
  checkAndRepair(name, font, properties) {
    const VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    function readTables(file, numTables) {
      const tables2 = /* @__PURE__ */ Object.create(null);
      tables2["OS/2"] = null;
      tables2.cmap = null;
      tables2.head = null;
      tables2.hhea = null;
      tables2.hmtx = null;
      tables2.maxp = null;
      tables2.name = null;
      tables2.post = null;
      for (let i = 0; i < numTables; i++) {
        const table = readTableEntry(file);
        if (!VALID_TABLES.includes(table.tag)) {
          continue;
        }
        if (table.length === 0) {
          continue;
        }
        tables2[table.tag] = table;
      }
      return tables2;
    }
    function readTableEntry(file) {
      const tag = file.getString(4);
      const checksum = file.getInt32() >>> 0;
      const offset = file.getInt32() >>> 0;
      const length = file.getInt32() >>> 0;
      const previousPosition = file.pos;
      file.pos = file.start ? file.start : 0;
      file.skip(offset);
      const data = file.getBytes(length);
      file.pos = previousPosition;
      if (tag === "head") {
        data[8] = data[9] = data[10] = data[11] = 0;
        data[17] |= 32;
      }
      return {
        tag,
        checksum,
        length,
        offset,
        data
      };
    }
    function readOpenTypeHeader(ttf) {
      return {
        version: ttf.getString(4),
        numTables: ttf.getUint16(),
        searchRange: ttf.getUint16(),
        entrySelector: ttf.getUint16(),
        rangeShift: ttf.getUint16()
      };
    }
    function readTrueTypeCollectionHeader(ttc) {
      const ttcTag = ttc.getString(4);
      assert(ttcTag === "ttcf", "Must be a TrueType Collection font.");
      const majorVersion = ttc.getUint16();
      const minorVersion = ttc.getUint16();
      const numFonts = ttc.getInt32() >>> 0;
      const offsetTable = [];
      for (let i = 0; i < numFonts; i++) {
        offsetTable.push(ttc.getInt32() >>> 0);
      }
      const header2 = {
        ttcTag,
        majorVersion,
        minorVersion,
        numFonts,
        offsetTable
      };
      switch (majorVersion) {
        case 1:
          return header2;
        case 2:
          header2.dsigTag = ttc.getInt32() >>> 0;
          header2.dsigLength = ttc.getInt32() >>> 0;
          header2.dsigOffset = ttc.getInt32() >>> 0;
          return header2;
      }
      throw new FormatError(`Invalid TrueType Collection majorVersion: ${majorVersion}.`);
    }
    function readTrueTypeCollectionData(ttc, fontName) {
      const {
        numFonts,
        offsetTable
      } = readTrueTypeCollectionHeader(ttc);
      const fontNameParts = fontName.split("+");
      let fallbackData;
      for (let i = 0; i < numFonts; i++) {
        ttc.pos = (ttc.start || 0) + offsetTable[i];
        const potentialHeader = readOpenTypeHeader(ttc);
        const potentialTables = readTables(ttc, potentialHeader.numTables);
        if (!potentialTables.name) {
          throw new FormatError('TrueType Collection font must contain a "name" table.');
        }
        const nameTable = readNameTable(potentialTables.name);
        for (let j = 0, jj = nameTable.length; j < jj; j++) {
          for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
            const nameEntry = nameTable[j][k] && nameTable[j][k].replace(/\s/g, "");
            if (!nameEntry) {
              continue;
            }
            if (nameEntry === fontName) {
              return {
                header: potentialHeader,
                tables: potentialTables
              };
            }
            if (fontNameParts.length < 2) {
              continue;
            }
            for (const part of fontNameParts) {
              if (nameEntry === part) {
                fallbackData = {
                  name: part,
                  header: potentialHeader,
                  tables: potentialTables
                };
              }
            }
          }
        }
      }
      if (fallbackData) {
        warn(`TrueType Collection does not contain "${fontName}" font, falling back to "${fallbackData.name}" font instead.`);
        return {
          header: fallbackData.header,
          tables: fallbackData.tables
        };
      }
      throw new FormatError(`TrueType Collection does not contain "${fontName}" font.`);
    }
    function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
      if (!cmap) {
        warn("No cmap table available.");
        return {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: false
        };
      }
      let segment;
      let start = (file.start ? file.start : 0) + cmap.offset;
      file.pos = start;
      file.skip(2);
      const numTables = file.getUint16();
      let potentialTable;
      let canBreak = false;
      for (let i = 0; i < numTables; i++) {
        const platformId = file.getUint16();
        const encodingId = file.getUint16();
        const offset = file.getInt32() >>> 0;
        let useTable = false;
        if (potentialTable && potentialTable.platformId === platformId && potentialTable.encodingId === encodingId) {
          continue;
        }
        if (platformId === 0 && (encodingId === /* Unicode Default */
        0 || encodingId === /* Unicode 1.1 */
        1 || encodingId === /* Unicode BMP */
        3)) {
          useTable = true;
        } else if (platformId === 1 && encodingId === 0) {
          useTable = true;
        } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
          useTable = true;
          if (!isSymbolicFont) {
            canBreak = true;
          }
        } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
          useTable = true;
          let correctlySorted = true;
          if (i < numTables - 1) {
            const nextBytes = file.peekBytes(2), nextPlatformId = int16(nextBytes[0], nextBytes[1]);
            if (nextPlatformId < platformId) {
              correctlySorted = false;
            }
          }
          if (correctlySorted) {
            canBreak = true;
          }
        }
        if (useTable) {
          potentialTable = {
            platformId,
            encodingId,
            offset
          };
        }
        if (canBreak) {
          break;
        }
      }
      if (potentialTable) {
        file.pos = start + potentialTable.offset;
      }
      if (!potentialTable || file.peekByte() === -1) {
        warn("Could not find a preferred cmap table.");
        return {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: false
        };
      }
      const format = file.getUint16();
      file.skip(2 + 2);
      let hasShortCmap = false;
      const mappings = [];
      let j, glyphId;
      if (format === 0) {
        for (j = 0; j < 256; j++) {
          const index = file.getByte();
          if (!index) {
            continue;
          }
          mappings.push({
            charCode: j,
            glyphId: index
          });
        }
        hasShortCmap = true;
      } else if (format === 4) {
        const segCount = file.getUint16() >> 1;
        file.skip(6);
        const segments = [];
        let segIndex;
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segments.push({
            end: file.getUint16()
          });
        }
        file.skip(2);
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segments[segIndex].start = file.getUint16();
        }
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segments[segIndex].delta = file.getUint16();
        }
        let offsetsCount = 0, offsetIndex;
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segment = segments[segIndex];
          const rangeOffset = file.getUint16();
          if (!rangeOffset) {
            segment.offsetIndex = -1;
            continue;
          }
          offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
          segment.offsetIndex = offsetIndex;
          offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
        }
        const offsets = [];
        for (j = 0; j < offsetsCount; j++) {
          offsets.push(file.getUint16());
        }
        for (segIndex = 0; segIndex < segCount; segIndex++) {
          segment = segments[segIndex];
          start = segment.start;
          const end = segment.end;
          const delta = segment.delta;
          offsetIndex = segment.offsetIndex;
          for (j = start; j <= end; j++) {
            if (j === 65535) {
              continue;
            }
            glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
            glyphId = glyphId + delta & 65535;
            mappings.push({
              charCode: j,
              glyphId
            });
          }
        }
      } else if (format === 6) {
        const firstCode = file.getUint16();
        const entryCount = file.getUint16();
        for (j = 0; j < entryCount; j++) {
          glyphId = file.getUint16();
          const charCode = firstCode + j;
          mappings.push({
            charCode,
            glyphId
          });
        }
      } else {
        warn("cmap table has unsupported format: " + format);
        return {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: false
        };
      }
      mappings.sort(function(a, b) {
        return a.charCode - b.charCode;
      });
      for (let i = 1; i < mappings.length; i++) {
        if (mappings[i - 1].charCode === mappings[i].charCode) {
          mappings.splice(i, 1);
          i--;
        }
      }
      return {
        platformId: potentialTable.platformId,
        encodingId: potentialTable.encodingId,
        mappings,
        hasShortCmap
      };
    }
    function sanitizeMetrics(file, header2, metrics, headTable, numGlyphs2, dupFirstEntry2) {
      if (!header2) {
        if (metrics) {
          metrics.data = null;
        }
        return;
      }
      file.pos = (file.start ? file.start : 0) + header2.offset;
      file.pos += 4;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      file.pos += 2;
      const caretOffset = file.getUint16();
      file.pos += 8;
      file.pos += 2;
      let numOfMetrics = file.getUint16();
      if (caretOffset !== 0) {
        const macStyle = int16(headTable.data[44], headTable.data[45]);
        if (!(macStyle & 2)) {
          header2.data[22] = 0;
          header2.data[23] = 0;
        }
      }
      if (numOfMetrics > numGlyphs2) {
        info(`The numOfMetrics (${numOfMetrics}) should not be greater than the numGlyphs (${numGlyphs2}).`);
        numOfMetrics = numGlyphs2;
        header2.data[34] = (numOfMetrics & 65280) >> 8;
        header2.data[35] = numOfMetrics & 255;
      }
      const numOfSidebearings = numGlyphs2 - numOfMetrics;
      const numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);
      if (numMissing > 0) {
        const entries = new Uint8Array(metrics.length + numMissing * 2);
        entries.set(metrics.data);
        if (dupFirstEntry2) {
          entries[metrics.length] = metrics.data[2];
          entries[metrics.length + 1] = metrics.data[3];
        }
        metrics.data = entries;
      }
    }
    function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid2) {
      const glyphProfile = {
        length: 0,
        sizeOfInstructions: 0
      };
      if (sourceEnd - sourceStart <= 12) {
        return glyphProfile;
      }
      const glyf = source.subarray(sourceStart, sourceEnd);
      let contoursCount = signedInt16(glyf[0], glyf[1]);
      if (contoursCount < 0) {
        contoursCount = -1;
        writeSignedInt16(glyf, 0, contoursCount);
        dest.set(glyf, destStart);
        glyphProfile.length = glyf.length;
        return glyphProfile;
      }
      let i, j = 10, flagsCount = 0;
      for (i = 0; i < contoursCount; i++) {
        const endPoint = glyf[j] << 8 | glyf[j + 1];
        flagsCount = endPoint + 1;
        j += 2;
      }
      const instructionsStart = j;
      const instructionsLength = glyf[j] << 8 | glyf[j + 1];
      glyphProfile.sizeOfInstructions = instructionsLength;
      j += 2 + instructionsLength;
      const instructionsEnd = j;
      let coordinatesLength = 0;
      for (i = 0; i < flagsCount; i++) {
        const flag = glyf[j++];
        if (flag & 192) {
          glyf[j - 1] = flag & 63;
        }
        let xLength = 2;
        if (flag & 2) {
          xLength = 1;
        } else if (flag & 16) {
          xLength = 0;
        }
        let yLength = 2;
        if (flag & 4) {
          yLength = 1;
        } else if (flag & 32) {
          yLength = 0;
        }
        const xyLength = xLength + yLength;
        coordinatesLength += xyLength;
        if (flag & 8) {
          const repeat = glyf[j++];
          i += repeat;
          coordinatesLength += repeat * xyLength;
        }
      }
      if (coordinatesLength === 0) {
        return glyphProfile;
      }
      let glyphDataLength = j + coordinatesLength;
      if (glyphDataLength > glyf.length) {
        return glyphProfile;
      }
      if (!hintsValid2 && instructionsLength > 0) {
        dest.set(glyf.subarray(0, instructionsStart), destStart);
        dest.set([0, 0], destStart + instructionsStart);
        dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
        glyphDataLength -= instructionsLength;
        if (glyf.length - glyphDataLength > 3) {
          glyphDataLength = glyphDataLength + 3 & ~3;
        }
        glyphProfile.length = glyphDataLength;
        return glyphProfile;
      }
      if (glyf.length - glyphDataLength > 3) {
        glyphDataLength = glyphDataLength + 3 & ~3;
        dest.set(glyf.subarray(0, glyphDataLength), destStart);
        glyphProfile.length = glyphDataLength;
        return glyphProfile;
      }
      dest.set(glyf, destStart);
      glyphProfile.length = glyf.length;
      return glyphProfile;
    }
    function sanitizeHead(head, numGlyphs2, locaLength) {
      const data = head.data;
      const version2 = int32(data[0], data[1], data[2], data[3]);
      if (version2 >> 16 !== 1) {
        info("Attempting to fix invalid version in head table: " + version2);
        data[0] = 0;
        data[1] = 1;
        data[2] = 0;
        data[3] = 0;
      }
      const indexToLocFormat = int16(data[50], data[51]);
      if (indexToLocFormat < 0 || indexToLocFormat > 1) {
        info("Attempting to fix invalid indexToLocFormat in head table: " + indexToLocFormat);
        const numGlyphsPlusOne = numGlyphs2 + 1;
        if (locaLength === numGlyphsPlusOne << 1) {
          data[50] = 0;
          data[51] = 0;
        } else if (locaLength === numGlyphsPlusOne << 2) {
          data[50] = 0;
          data[51] = 1;
        } else {
          throw new FormatError("Could not fix indexToLocFormat: " + indexToLocFormat);
        }
      }
    }
    function sanitizeGlyphLocations(loca, glyf, numGlyphs2, isGlyphLocationsLong, hintsValid2, dupFirstEntry2, maxSizeOfInstructions2) {
      let itemSize, itemDecode, itemEncode;
      if (isGlyphLocationsLong) {
        itemSize = 4;
        itemDecode = function fontItemDecodeLong(data, offset) {
          return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
        };
        itemEncode = function fontItemEncodeLong(data, offset, value) {
          data[offset] = value >>> 24 & 255;
          data[offset + 1] = value >> 16 & 255;
          data[offset + 2] = value >> 8 & 255;
          data[offset + 3] = value & 255;
        };
      } else {
        itemSize = 2;
        itemDecode = function fontItemDecode(data, offset) {
          return data[offset] << 9 | data[offset + 1] << 1;
        };
        itemEncode = function fontItemEncode(data, offset, value) {
          data[offset] = value >> 9 & 255;
          data[offset + 1] = value >> 1 & 255;
        };
      }
      const numGlyphsOut2 = dupFirstEntry2 ? numGlyphs2 + 1 : numGlyphs2;
      const locaDataSize = itemSize * (1 + numGlyphsOut2);
      const locaData = new Uint8Array(locaDataSize);
      locaData.set(loca.data.subarray(0, locaDataSize));
      loca.data = locaData;
      const oldGlyfData = glyf.data;
      const oldGlyfDataLength = oldGlyfData.length;
      const newGlyfData = new Uint8Array(oldGlyfDataLength);
      let i, j;
      const locaEntries = [];
      for (i = 0, j = 0; i < numGlyphs2 + 1; i++, j += itemSize) {
        let offset = itemDecode(locaData, j);
        if (offset > oldGlyfDataLength) {
          offset = oldGlyfDataLength;
        }
        locaEntries.push({
          index: i,
          offset,
          endOffset: 0
        });
      }
      locaEntries.sort((a, b) => {
        return a.offset - b.offset;
      });
      for (i = 0; i < numGlyphs2; i++) {
        locaEntries[i].endOffset = locaEntries[i + 1].offset;
      }
      locaEntries.sort((a, b) => {
        return a.index - b.index;
      });
      const missingGlyphs2 = /* @__PURE__ */ Object.create(null);
      let writeOffset = 0;
      itemEncode(locaData, 0, writeOffset);
      for (i = 0, j = itemSize; i < numGlyphs2; i++, j += itemSize) {
        const glyphProfile = sanitizeGlyph(oldGlyfData, locaEntries[i].offset, locaEntries[i].endOffset, newGlyfData, writeOffset, hintsValid2);
        const newLength = glyphProfile.length;
        if (newLength === 0) {
          missingGlyphs2[i] = true;
        }
        if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions2) {
          maxSizeOfInstructions2 = glyphProfile.sizeOfInstructions;
        }
        writeOffset += newLength;
        itemEncode(locaData, j, writeOffset);
      }
      if (writeOffset === 0) {
        const simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
        for (i = 0, j = itemSize; i < numGlyphsOut2; i++, j += itemSize) {
          itemEncode(locaData, j, simpleGlyph.length);
        }
        glyf.data = simpleGlyph;
      } else if (dupFirstEntry2) {
        const firstEntryLength = itemDecode(locaData, itemSize);
        if (newGlyfData.length > firstEntryLength + writeOffset) {
          glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
        } else {
          glyf.data = new Uint8Array(firstEntryLength + writeOffset);
          glyf.data.set(newGlyfData.subarray(0, writeOffset));
        }
        glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
        itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
      } else {
        glyf.data = newGlyfData.subarray(0, writeOffset);
      }
      return {
        missingGlyphs: missingGlyphs2,
        maxSizeOfInstructions: maxSizeOfInstructions2
      };
    }
    function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
      const start = (font.start ? font.start : 0) + post.offset;
      font.pos = start;
      const length = post.length, end = start + length;
      const version2 = font.getInt32();
      font.skip(28);
      let glyphNames;
      let valid = true;
      let i;
      switch (version2) {
        case 65536:
          glyphNames = MacStandardGlyphOrdering;
          break;
        case 131072:
          const numGlyphs2 = font.getUint16();
          if (numGlyphs2 !== maxpNumGlyphs) {
            valid = false;
            break;
          }
          const glyphNameIndexes = [];
          for (i = 0; i < numGlyphs2; ++i) {
            const index = font.getUint16();
            if (index >= 32768) {
              valid = false;
              break;
            }
            glyphNameIndexes.push(index);
          }
          if (!valid) {
            break;
          }
          const customNames = [], strBuf = [];
          while (font.pos < end) {
            const stringLength = font.getByte();
            strBuf.length = stringLength;
            for (i = 0; i < stringLength; ++i) {
              strBuf[i] = String.fromCharCode(font.getByte());
            }
            customNames.push(strBuf.join(""));
          }
          glyphNames = [];
          for (i = 0; i < numGlyphs2; ++i) {
            const j = glyphNameIndexes[i];
            if (j < 258) {
              glyphNames.push(MacStandardGlyphOrdering[j]);
              continue;
            }
            glyphNames.push(customNames[j - 258]);
          }
          break;
        case 196608:
          break;
        default:
          warn("Unknown/unsupported post table version " + version2);
          valid = false;
          if (propertiesObj.defaultEncoding) {
            glyphNames = propertiesObj.defaultEncoding;
          }
          break;
      }
      propertiesObj.glyphNames = glyphNames;
      return valid;
    }
    function readNameTable(nameTable) {
      const start = (font.start ? font.start : 0) + nameTable.offset;
      font.pos = start;
      const names = [[], []];
      const length = nameTable.length, end = start + length;
      const format = font.getUint16();
      const FORMAT_0_HEADER_LENGTH = 6;
      if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
        return names;
      }
      const numRecords = font.getUint16();
      const stringsStart = font.getUint16();
      const records = [];
      const NAME_RECORD_LENGTH = 12;
      let i, ii;
      for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
        const r = {
          platform: font.getUint16(),
          encoding: font.getUint16(),
          language: font.getUint16(),
          name: font.getUint16(),
          length: font.getUint16(),
          offset: font.getUint16()
        };
        if (r.platform === 1 && r.encoding === 0 && r.language === 0 || r.platform === 3 && r.encoding === 1 && r.language === 1033) {
          records.push(r);
        }
      }
      for (i = 0, ii = records.length; i < ii; i++) {
        const record = records[i];
        if (record.length <= 0) {
          continue;
        }
        const pos = start + stringsStart + record.offset;
        if (pos + record.length > end) {
          continue;
        }
        font.pos = pos;
        const nameIndex = record.name;
        if (record.encoding) {
          let str = "";
          for (let j = 0, jj = record.length; j < jj; j += 2) {
            str += String.fromCharCode(font.getUint16());
          }
          names[1][nameIndex] = str;
        } else {
          names[0][nameIndex] = font.getString(record.length);
        }
      }
      return names;
    }
    const TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
    function sanitizeTTProgram(table, ttContext) {
      let data = table.data;
      let i = 0, j, n, b, funcId, pc, lastEndf = 0, lastDeff = 0;
      const stack = [];
      const callstack = [];
      const functionsCalled = [];
      let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
      let inFDEF = false, ifLevel = 0, inELSE = 0;
      for (let ii = data.length; i < ii; ) {
        const op = data[i++];
        if (op === 64) {
          n = data[i++];
          if (inFDEF || inELSE) {
            i += n;
          } else {
            for (j = 0; j < n; j++) {
              stack.push(data[i++]);
            }
          }
        } else if (op === 65) {
          n = data[i++];
          if (inFDEF || inELSE) {
            i += n * 2;
          } else {
            for (j = 0; j < n; j++) {
              b = data[i++];
              stack.push(b << 8 | data[i++]);
            }
          }
        } else if ((op & 248) === 176) {
          n = op - 176 + 1;
          if (inFDEF || inELSE) {
            i += n;
          } else {
            for (j = 0; j < n; j++) {
              stack.push(data[i++]);
            }
          }
        } else if ((op & 248) === 184) {
          n = op - 184 + 1;
          if (inFDEF || inELSE) {
            i += n * 2;
          } else {
            for (j = 0; j < n; j++) {
              b = data[i++];
              stack.push(b << 8 | data[i++]);
            }
          }
        } else if (op === 43 && !tooComplexToFollowFunctions) {
          if (!inFDEF && !inELSE) {
            funcId = stack[stack.length - 1];
            if (isNaN(funcId)) {
              info("TT: CALL empty stack (or invalid entry).");
            } else {
              ttContext.functionsUsed[funcId] = true;
              if (funcId in ttContext.functionsStackDeltas) {
                const newStackLength = stack.length + ttContext.functionsStackDeltas[funcId];
                if (newStackLength < 0) {
                  warn("TT: CALL invalid functions stack delta.");
                  ttContext.hintsValid = false;
                  return;
                }
                stack.length = newStackLength;
              } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                callstack.push({
                  data,
                  i,
                  stackTop: stack.length - 1
                });
                functionsCalled.push(funcId);
                pc = ttContext.functionsDefined[funcId];
                if (!pc) {
                  warn("TT: CALL non-existent function");
                  ttContext.hintsValid = false;
                  return;
                }
                data = pc.data;
                i = pc.i;
              }
            }
          }
        } else if (op === 44 && !tooComplexToFollowFunctions) {
          if (inFDEF || inELSE) {
            warn("TT: nested FDEFs not allowed");
            tooComplexToFollowFunctions = true;
          }
          inFDEF = true;
          lastDeff = i;
          funcId = stack.pop();
          ttContext.functionsDefined[funcId] = {
            data,
            i
          };
        } else if (op === 45) {
          if (inFDEF) {
            inFDEF = false;
            lastEndf = i;
          } else {
            pc = callstack.pop();
            if (!pc) {
              warn("TT: ENDF bad stack");
              ttContext.hintsValid = false;
              return;
            }
            funcId = functionsCalled.pop();
            data = pc.data;
            i = pc.i;
            ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
          }
        } else if (op === 137) {
          if (inFDEF || inELSE) {
            warn("TT: nested IDEFs not allowed");
            tooComplexToFollowFunctions = true;
          }
          inFDEF = true;
          lastDeff = i;
        } else if (op === 88) {
          ++ifLevel;
        } else if (op === 27) {
          inELSE = ifLevel;
        } else if (op === 89) {
          if (inELSE === ifLevel) {
            inELSE = 0;
          }
          --ifLevel;
        } else if (op === 28) {
          if (!inFDEF && !inELSE) {
            const offset = stack[stack.length - 1];
            if (offset > 0) {
              i += offset - 1;
            }
          }
        }
        if (!inFDEF && !inELSE) {
          let stackDelta = 0;
          if (op <= 142) {
            stackDelta = TTOpsStackDeltas[op];
          } else if (op >= 192 && op <= 223) {
            stackDelta = -1;
          } else if (op >= 224) {
            stackDelta = -2;
          }
          if (op >= 113 && op <= 117) {
            n = stack.pop();
            if (!isNaN(n)) {
              stackDelta = -n * 2;
            }
          }
          while (stackDelta < 0 && stack.length > 0) {
            stack.pop();
            stackDelta++;
          }
          while (stackDelta > 0) {
            stack.push(NaN);
            stackDelta--;
          }
        }
      }
      ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
      const content = [data];
      if (i > data.length) {
        content.push(new Uint8Array(i - data.length));
      }
      if (lastDeff > lastEndf) {
        warn("TT: complementing a missing function tail");
        content.push(new Uint8Array([34, 45]));
      }
      foldTTTable(table, content);
    }
    function checkInvalidFunctions(ttContext, maxFunctionDefs2) {
      if (ttContext.tooComplexToFollowFunctions) {
        return;
      }
      if (ttContext.functionsDefined.length > maxFunctionDefs2) {
        warn("TT: more functions defined than expected");
        ttContext.hintsValid = false;
        return;
      }
      for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
        if (j > maxFunctionDefs2) {
          warn("TT: invalid function id: " + j);
          ttContext.hintsValid = false;
          return;
        }
        if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
          warn("TT: undefined function: " + j);
          ttContext.hintsValid = false;
          return;
        }
      }
    }
    function foldTTTable(table, content) {
      if (content.length > 1) {
        let newLength = 0;
        let j, jj;
        for (j = 0, jj = content.length; j < jj; j++) {
          newLength += content[j].length;
        }
        newLength = newLength + 3 & ~3;
        const result = new Uint8Array(newLength);
        let pos = 0;
        for (j = 0, jj = content.length; j < jj; j++) {
          result.set(content[j], pos);
          pos += content[j].length;
        }
        table.data = result;
        table.length = newLength;
      }
    }
    function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs2) {
      const ttContext = {
        functionsDefined: [],
        functionsUsed: [],
        functionsStackDeltas: [],
        tooComplexToFollowFunctions: false,
        hintsValid: true
      };
      if (fpgm) {
        sanitizeTTProgram(fpgm, ttContext);
      }
      if (prep) {
        sanitizeTTProgram(prep, ttContext);
      }
      if (fpgm) {
        checkInvalidFunctions(ttContext, maxFunctionDefs2);
      }
      if (cvt && cvt.length & 1) {
        const cvtData = new Uint8Array(cvt.length + 1);
        cvtData.set(cvt.data);
        cvt.data = cvtData;
      }
      return ttContext.hintsValid;
    }
    font = new Stream(new Uint8Array(font.getBytes()));
    let header, tables;
    if (isTrueTypeCollectionFile(font)) {
      const ttcData = readTrueTypeCollectionData(font, this.name);
      header = ttcData.header;
      tables = ttcData.tables;
    } else {
      header = readOpenTypeHeader(font);
      tables = readTables(font, header.numTables);
    }
    let cff, cffFile;
    const isTrueType = !tables["CFF "];
    if (!isTrueType) {
      const isComposite = properties.composite && ((properties.cidToGidMap || []).length > 0 || !(properties.cMap instanceof IdentityCMap));
      if (header.version === "OTTO" && !isComposite || !tables.head || !tables.hhea || !tables.maxp || !tables.post) {
        cffFile = new Stream(tables["CFF "].data);
        cff = new CFFFont(cffFile, properties);
        adjustWidths(properties);
        return this.convert(name, cff, properties);
      }
      delete tables.glyf;
      delete tables.loca;
      delete tables.fpgm;
      delete tables.prep;
      delete tables["cvt "];
      this.isOpenType = true;
    } else {
      if (!tables.loca) {
        throw new FormatError('Required "loca" table is not found');
      }
      if (!tables.glyf) {
        warn('Required "glyf" table is not found -- trying to recover.');
        tables.glyf = {
          tag: "glyf",
          data: new Uint8Array(0)
        };
      }
      this.isOpenType = false;
    }
    if (!tables.maxp) {
      throw new FormatError('Required "maxp" table is not found');
    }
    font.pos = (font.start || 0) + tables.maxp.offset;
    const version = font.getInt32();
    const numGlyphs = font.getUint16();
    if (properties.scaleFactors && properties.scaleFactors.length === numGlyphs && isTrueType) {
      const {
        scaleFactors
      } = properties;
      const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
      const glyphs = new GlyfTable({
        glyfTable: tables.glyf.data,
        isGlyphLocationsLong,
        locaTable: tables.loca.data,
        numGlyphs
      });
      glyphs.scale(scaleFactors);
      const {
        glyf,
        loca,
        isLocationLong
      } = glyphs.write();
      tables.glyf.data = glyf;
      tables.loca.data = loca;
      if (isLocationLong !== !!isGlyphLocationsLong) {
        tables.head.data[50] = 0;
        tables.head.data[51] = isLocationLong ? 1 : 0;
      }
      const metrics = tables.hmtx.data;
      for (let i = 0; i < numGlyphs; i++) {
        const j = 4 * i;
        const advanceWidth = Math.round(scaleFactors[i] * int16(metrics[j], metrics[j + 1]));
        metrics[j] = advanceWidth >> 8 & 255;
        metrics[j + 1] = advanceWidth & 255;
        const lsb = Math.round(scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3]));
        writeSignedInt16(metrics, j + 2, lsb);
      }
    }
    let numGlyphsOut = numGlyphs + 1;
    let dupFirstEntry = true;
    if (numGlyphsOut > 65535) {
      dupFirstEntry = false;
      numGlyphsOut = numGlyphs;
      warn("Not enough space in glyfs to duplicate first glyph.");
    }
    let maxFunctionDefs = 0;
    let maxSizeOfInstructions = 0;
    if (version >= 65536 && tables.maxp.length >= 22) {
      font.pos += 8;
      const maxZones = font.getUint16();
      if (maxZones > 2) {
        tables.maxp.data[14] = 0;
        tables.maxp.data[15] = 2;
      }
      font.pos += 4;
      maxFunctionDefs = font.getUint16();
      font.pos += 4;
      maxSizeOfInstructions = font.getUint16();
    }
    tables.maxp.data[4] = numGlyphsOut >> 8;
    tables.maxp.data[5] = numGlyphsOut & 255;
    const hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep, tables["cvt "], maxFunctionDefs);
    if (!hintsValid) {
      delete tables.fpgm;
      delete tables.prep;
      delete tables["cvt "];
    }
    sanitizeMetrics(font, tables.hhea, tables.hmtx, tables.head, numGlyphsOut, dupFirstEntry);
    if (!tables.head) {
      throw new FormatError('Required "head" table is not found');
    }
    sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
    let missingGlyphs = /* @__PURE__ */ Object.create(null);
    if (isTrueType) {
      const isGlyphLocationsLong = int16(tables.head.data[50], tables.head.data[51]);
      const glyphsInfo = sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
      missingGlyphs = glyphsInfo.missingGlyphs;
      if (version >= 65536 && tables.maxp.length >= 22) {
        tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
        tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
      }
    }
    if (!tables.hhea) {
      throw new FormatError('Required "hhea" table is not found');
    }
    if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
      tables.hhea.data[10] = 255;
      tables.hhea.data[11] = 255;
    }
    const metricsOverride = {
      unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
      yMax: int16(tables.head.data[42], tables.head.data[43]),
      yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
      ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
      descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
      lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9])
    };
    this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
    this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
    this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
    if (this.cssFontInfo && this.cssFontInfo.lineHeight) {
      this.lineHeight = this.cssFontInfo.lineHeight;
    } else {
      this.lineHeight = this.ascent - this.descent + this.lineGap;
    }
    if (tables.post) {
      readPostScriptTable(tables.post, properties, numGlyphs);
    }
    tables.post = {
      tag: "post",
      data: createPostTable(properties)
    };
    const charCodeToGlyphId = [];
    function hasGlyph(glyphId) {
      return !missingGlyphs[glyphId];
    }
    if (properties.composite) {
      const cidToGidMap = properties.cidToGidMap || [];
      const isCidToGidMapEmpty = cidToGidMap.length === 0;
      properties.cMap.forEach(function(charCode, cid) {
        if (cid > 65535) {
          throw new FormatError("Max size of CID is 65,535");
        }
        let glyphId = -1;
        if (isCidToGidMapEmpty) {
          glyphId = cid;
        } else if (cidToGidMap[cid] !== void 0) {
          glyphId = cidToGidMap[cid];
        }
        if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
          charCodeToGlyphId[charCode] = glyphId;
        }
      });
    } else {
      const cmapTable = readCmapTable(tables.cmap, font, this.isSymbolicFont, properties.hasEncoding);
      const cmapPlatformId = cmapTable.platformId;
      const cmapEncodingId = cmapTable.encodingId;
      const cmapMappings = cmapTable.mappings;
      const cmapMappingsLength = cmapMappings.length;
      let baseEncoding = [];
      if (properties.hasEncoding && (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding")) {
        baseEncoding = getEncoding(properties.baseEncodingName);
      }
      if (properties.hasEncoding && !this.isSymbolicFont && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0)) {
        const glyphsUnicodeMap = getGlyphsUnicode();
        for (let charCode = 0; charCode < 256; charCode++) {
          let glyphName;
          if (this.differences[charCode] !== void 0) {
            glyphName = this.differences[charCode];
          } else if (baseEncoding[charCode] !== "") {
            glyphName = baseEncoding[charCode];
          } else {
            glyphName = StandardEncoding[charCode];
          }
          if (!glyphName) {
            continue;
          }
          const standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
          let unicodeOrCharCode;
          if (cmapPlatformId === 3 && cmapEncodingId === 1) {
            unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
          } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
            unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
          }
          for (let i = 0; i < cmapMappingsLength; ++i) {
            if (cmapMappings[i].charCode !== unicodeOrCharCode) {
              continue;
            }
            charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
            break;
          }
        }
      } else if (cmapPlatformId === 0) {
        for (let i = 0; i < cmapMappingsLength; ++i) {
          charCodeToGlyphId[cmapMappings[i].charCode] = cmapMappings[i].glyphId;
        }
      } else {
        for (let i = 0; i < cmapMappingsLength; ++i) {
          let charCode = cmapMappings[i].charCode;
          if (cmapPlatformId === 3 && charCode >= 61440 && charCode <= 61695) {
            charCode &= 255;
          }
          charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
        }
      }
      if (properties.glyphNames && (baseEncoding.length || this.differences.length)) {
        for (let i = 0; i < 256; ++i) {
          if (charCodeToGlyphId[i] !== void 0) {
            continue;
          }
          const glyphName = this.differences[i] || baseEncoding[i];
          if (!glyphName) {
            continue;
          }
          const glyphId = properties.glyphNames.indexOf(glyphName);
          if (glyphId > 0 && hasGlyph(glyphId)) {
            charCodeToGlyphId[i] = glyphId;
          }
        }
      }
    }
    if (charCodeToGlyphId.length === 0) {
      charCodeToGlyphId[0] = 0;
    }
    let glyphZeroId = numGlyphsOut - 1;
    if (!dupFirstEntry) {
      glyphZeroId = 0;
    }
    if (!properties.cssFontInfo) {
      const newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId);
      this.toFontChar = newMapping.toFontChar;
      tables.cmap = {
        tag: "cmap",
        data: createCmapTable(newMapping.charCodeToGlyphId, numGlyphsOut)
      };
      if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
        tables["OS/2"] = {
          tag: "OS/2",
          data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride)
        };
      }
    }
    if (!isTrueType) {
      try {
        cffFile = new Stream(tables["CFF "].data);
        const parser = new CFFParser(cffFile, properties, SEAC_ANALYSIS_ENABLED);
        cff = parser.parse();
        cff.duplicateFirstGlyph();
        const compiler = new CFFCompiler(cff);
        tables["CFF "].data = compiler.compile();
      } catch (e) {
        warn("Failed to compile font " + properties.loadedName);
      }
    }
    if (!tables.name) {
      tables.name = {
        tag: "name",
        data: createNameTable(this.name)
      };
    } else {
      const namePrototype = readNameTable(tables.name);
      tables.name.data = createNameTable(name, namePrototype);
      this.psName = namePrototype[0][6] || null;
    }
    const builder = new OpenTypeFileBuilder(header.version);
    for (const tableTag in tables) {
      builder.addTable(tableTag, tables[tableTag].data);
    }
    return builder.toArray();
  }
  convert(fontName, font, properties) {
    properties.fixedPitch = false;
    if (properties.builtInEncoding) {
      adjustToUnicode(properties, properties.builtInEncoding);
    }
    let glyphZeroId = 1;
    if (font instanceof CFFFont) {
      glyphZeroId = font.numGlyphs - 1;
    }
    const mapping = font.getGlyphMapping(properties);
    let newMapping = null;
    let newCharCodeToGlyphId = mapping;
    if (!properties.cssFontInfo) {
      newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId);
      this.toFontChar = newMapping.toFontChar;
      newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
    }
    const numGlyphs = font.numGlyphs;
    function getCharCodes(charCodeToGlyphId, glyphId) {
      let charCodes = null;
      for (const charCode in charCodeToGlyphId) {
        if (glyphId === charCodeToGlyphId[charCode]) {
          if (!charCodes) {
            charCodes = [];
          }
          charCodes.push(charCode | 0);
        }
      }
      return charCodes;
    }
    function createCharCode(charCodeToGlyphId, glyphId) {
      for (const charCode in charCodeToGlyphId) {
        if (glyphId === charCodeToGlyphId[charCode]) {
          return charCode | 0;
        }
      }
      newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId;
      return newMapping.nextAvailableFontCharCode++;
    }
    const seacs = font.seacs;
    if (newMapping && SEAC_ANALYSIS_ENABLED && seacs && seacs.length) {
      const matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
      const charset = font.getCharset();
      const seacMap = /* @__PURE__ */ Object.create(null);
      for (let glyphId in seacs) {
        glyphId |= 0;
        const seac = seacs[glyphId];
        const baseGlyphName = StandardEncoding[seac[2]];
        const accentGlyphName = StandardEncoding[seac[3]];
        const baseGlyphId = charset.indexOf(baseGlyphName);
        const accentGlyphId = charset.indexOf(accentGlyphName);
        if (baseGlyphId < 0 || accentGlyphId < 0) {
          continue;
        }
        const accentOffset = {
          x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
          y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
        };
        const charCodes = getCharCodes(mapping, glyphId);
        if (!charCodes) {
          continue;
        }
        for (let i = 0, ii = charCodes.length; i < ii; i++) {
          const charCode = charCodes[i];
          const charCodeToGlyphId = newMapping.charCodeToGlyphId;
          const baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
          const accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
          seacMap[charCode] = {
            baseFontCharCode,
            accentFontCharCode,
            accentOffset
          };
        }
      }
      properties.seacMap = seacMap;
    }
    const unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
    const builder = new OpenTypeFileBuilder("OTTO");
    builder.addTable("CFF ", font.data);
    builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
    builder.addTable("cmap", createCmapTable(newCharCodeToGlyphId, numGlyphs));
    builder.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<\0\0" + // Flags
    safeString16(unitsPerEm) + // unitsPerEM
    "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + // xMin
    safeString16(properties.descent) + // yMin
    "" + // xMax
    safeString16(properties.ascent) + // yMax
    string16(properties.italicAngle ? 2 : 0) + // macStyle
    "\0\0\0\0\0\0\0");
    builder.addTable("hhea", "\0\0\0" + // Version number
    safeString16(properties.ascent) + // Typographic Ascent
    safeString16(properties.descent) + // Typographic Descent
    "\0\0\0\0\0\0\0\0" + // xMaxExtent
    safeString16(properties.capHeight) + // caretSlopeRise
    safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + // caretSlopeRun
    "\0\0\0\0\0\0\0\0\0\0\0\0" + // metricDataFormat
    string16(numGlyphs));
    builder.addTable("hmtx", function fontFieldsHmtx() {
      const charstrings = font.charstrings;
      const cffWidths = font.cff ? font.cff.widths : null;
      let hmtx = "\0\0\0\0";
      for (let i = 1, ii = numGlyphs; i < ii; i++) {
        let width = 0;
        if (charstrings) {
          const charstring = charstrings[i - 1];
          width = "width" in charstring ? charstring.width : 0;
        } else if (cffWidths) {
          width = Math.ceil(cffWidths[i] || 0);
        }
        hmtx += string16(width) + string16(0);
      }
      return hmtx;
    }());
    builder.addTable(
      "maxp",
      "\0\0P\0" + string16(numGlyphs)
      // Version number
    );
    builder.addTable("name", createNameTable(fontName));
    builder.addTable("post", createPostTable(properties));
    return builder.toArray();
  }
  get spaceWidth() {
    const possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
    let width;
    for (let i = 0, ii = possibleSpaceReplacements.length; i < ii; i++) {
      const glyphName = possibleSpaceReplacements[i];
      if (glyphName in this.widths) {
        width = this.widths[glyphName];
        break;
      }
      const glyphsUnicodeMap = getGlyphsUnicode();
      const glyphUnicode = glyphsUnicodeMap[glyphName];
      let charcode = 0;
      if (this.composite && this.cMap.contains(glyphUnicode)) {
        charcode = this.cMap.lookup(glyphUnicode);
      }
      if (!charcode && this.toUnicode) {
        charcode = this.toUnicode.charCodeOf(glyphUnicode);
      }
      if (charcode <= 0) {
        charcode = glyphUnicode;
      }
      width = this.widths[charcode];
      if (width) {
        break;
      }
    }
    width = width || this.defaultWidth;
    return shadow(this, "spaceWidth", width);
  }
  /**
   * @private
   */
  _charToGlyph(charcode, isSpace = false) {
    let fontCharCode, width, operatorListId;
    let widthCode = charcode;
    if (this.cMap && this.cMap.contains(charcode)) {
      widthCode = this.cMap.lookup(charcode);
    }
    width = this.widths[widthCode];
    width = isNum(width) ? width : this.defaultWidth;
    const vmetric = this.vmetrics && this.vmetrics[widthCode];
    let unicode = this.toUnicode.get(charcode) || charcode;
    if (typeof unicode === "number") {
      unicode = String.fromCharCode(unicode);
    }
    let isInFont = this.toFontChar[charcode] !== void 0;
    fontCharCode = this.toFontChar[charcode] || charcode;
    if (this.missingFile) {
      const glyphName = this.differences[charcode] || this.defaultEncoding[charcode];
      if ((glyphName === ".notdef" || glyphName === "") && this.type === "Type1") {
        fontCharCode = 32;
      }
      fontCharCode = mapSpecialUnicodeValues(fontCharCode);
    }
    if (this.isType3Font) {
      operatorListId = fontCharCode;
    }
    let accent = null;
    if (this.seacMap && this.seacMap[charcode]) {
      isInFont = true;
      const seac = this.seacMap[charcode];
      fontCharCode = seac.baseFontCharCode;
      accent = {
        fontChar: String.fromCodePoint(seac.accentFontCharCode),
        offset: seac.accentOffset
      };
    }
    let fontChar = "";
    if (typeof fontCharCode === "number") {
      if (fontCharCode <= 1114111) {
        fontChar = String.fromCodePoint(fontCharCode);
      } else {
        warn(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
      }
    }
    let glyph = this._glyphCache[charcode];
    if (!glyph || !glyph.matchesForCache(charcode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont)) {
      glyph = new Glyph(charcode, fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
      this._glyphCache[charcode] = glyph;
    }
    return glyph;
  }
  charsToGlyphs(chars2) {
    let glyphs = this._charsCache[chars2];
    if (glyphs) {
      return glyphs;
    }
    glyphs = [];
    if (this.cMap) {
      const c = /* @__PURE__ */ Object.create(null), ii = chars2.length;
      let i = 0;
      while (i < ii) {
        this.cMap.readCharCode(chars2, i, c);
        const {
          charcode,
          length
        } = c;
        i += length;
        const glyph = this._charToGlyph(charcode, length === 1 && chars2.charCodeAt(i - 1) === 32);
        glyphs.push(glyph);
      }
    } else {
      for (let i = 0, ii = chars2.length; i < ii; ++i) {
        const charcode = chars2.charCodeAt(i);
        const glyph = this._charToGlyph(charcode, charcode === 32);
        glyphs.push(glyph);
      }
    }
    return this._charsCache[chars2] = glyphs;
  }
  /**
   * Chars can have different sizes (depends on the encoding).
   * @param {String} a string encoded with font encoding.
   * @returns {Array<Array<number>>} the positions of each char in the string.
   */
  getCharPositions(chars2) {
    const positions = [];
    if (this.cMap) {
      const c = /* @__PURE__ */ Object.create(null);
      let i = 0;
      while (i < chars2.length) {
        this.cMap.readCharCode(chars2, i, c);
        const length = c.length;
        positions.push([i, i + length]);
        i += length;
      }
    } else {
      for (let i = 0, ii = chars2.length; i < ii; ++i) {
        positions.push([i, i + 1]);
      }
    }
    return positions;
  }
  get glyphCacheValues() {
    return Object.values(this._glyphCache);
  }
  /**
   * Encode a js string using font encoding.
   * The resulting array contains an encoded string at even positions
   * (can be empty) and a non-encoded one at odd positions.
   * @param {String} a js string.
   * @returns {Array<String>} an array of encoded strings or non-encoded ones.
   */
  encodeString(str) {
    const buffers = [];
    const currentBuf = [];
    const hasCurrentBufErrors = () => buffers.length % 2 === 1;
    for (let i = 0, ii = str.length; i < ii; i++) {
      const unicode = str.codePointAt(i);
      if (unicode > 55295 && (unicode < 57344 || unicode > 65533)) {
        i++;
      }
      if (this.toUnicode) {
        const char = String.fromCodePoint(unicode);
        const charCode = this.toUnicode.charCodeOf(char);
        if (charCode !== -1) {
          if (hasCurrentBufErrors()) {
            buffers.push(currentBuf.join(""));
            currentBuf.length = 0;
          }
          const charCodeLength = this.cMap ? this.cMap.getCharCodeLength(charCode) : 1;
          for (let j = charCodeLength - 1; j >= 0; j--) {
            currentBuf.push(String.fromCharCode(charCode >> 8 * j & 255));
          }
          continue;
        }
      }
      if (!hasCurrentBufErrors()) {
        buffers.push(currentBuf.join(""));
        currentBuf.length = 0;
      }
      currentBuf.push(String.fromCodePoint(unicode));
    }
    buffers.push(currentBuf.join(""));
    return buffers;
  }
};
var ErrorFont = class {
  constructor(error) {
    this.error = error;
    this.loadedName = "g_font_error";
    this.missingFile = true;
  }
  charsToGlyphs() {
    return [];
  }
  encodeString(chars2) {
    return [chars2];
  }
  exportData(extraProperties = false) {
    return {
      error: this.error
    };
  }
};
var ShadingType = {
  FUNCTION_BASED: 1,
  AXIAL: 2,
  RADIAL: 3,
  FREE_FORM_MESH: 4,
  LATTICE_FORM_MESH: 5,
  COONS_PATCH_MESH: 6,
  TENSOR_PATCH_MESH: 7
};
var Pattern$1 = class {
  constructor() {
    unreachable("Cannot initialize Pattern.");
  }
  static parseShading(shading, matrix, xref, res, handler, pdfFunctionFactory, localColorSpaceCache) {
    const dict = isStream(shading) ? shading.dict : shading;
    const type = dict.get("ShadingType");
    try {
      switch (type) {
        case ShadingType.AXIAL:
        case ShadingType.RADIAL:
          return new RadialAxialShading(dict, matrix, xref, res, pdfFunctionFactory, localColorSpaceCache);
        case ShadingType.FREE_FORM_MESH:
        case ShadingType.LATTICE_FORM_MESH:
        case ShadingType.COONS_PATCH_MESH:
        case ShadingType.TENSOR_PATCH_MESH:
          return new MeshShading(shading, matrix, xref, res, pdfFunctionFactory, localColorSpaceCache);
        default:
          throw new FormatError("Unsupported ShadingType: " + type);
      }
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      handler.send("UnsupportedFeature", {
        featureId: UNSUPPORTED_FEATURES.shadingPattern
      });
      warn(ex);
      return new DummyShading();
    }
  }
};
var BaseShading = class _BaseShading {
  // A small number to offset the first/last color stops so we can insert ones
  // to support extend. Number.MIN_VALUE is too small and breaks the extend.
  static get SMALL_NUMBER() {
    return shadow(this, "SMALL_NUMBER", 1e-6);
  }
  constructor() {
    if (this.constructor === _BaseShading) {
      unreachable("Cannot initialize BaseShading.");
    }
  }
  getIR() {
    unreachable("Abstract method `getIR` called.");
  }
};
var RadialAxialShading = class extends BaseShading {
  constructor(dict, matrix, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    super();
    this.matrix = matrix;
    this.coordsArr = dict.getArray("Coords");
    this.shadingType = dict.get("ShadingType");
    const cs = ColorSpace.parse({
      cs: dict.getRaw("ColorSpace") || dict.getRaw("CS"),
      xref,
      resources,
      pdfFunctionFactory,
      localColorSpaceCache
    });
    const bbox = dict.getArray("BBox");
    if (Array.isArray(bbox) && bbox.length === 4) {
      this.bbox = Util.normalizeRect(bbox);
    } else {
      this.bbox = null;
    }
    let t0 = 0, t1 = 1;
    if (dict.has("Domain")) {
      const domainArr = dict.getArray("Domain");
      t0 = domainArr[0];
      t1 = domainArr[1];
    }
    let extendStart = false, extendEnd = false;
    if (dict.has("Extend")) {
      const extendArr = dict.getArray("Extend");
      extendStart = extendArr[0];
      extendEnd = extendArr[1];
    }
    if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
      const [x1, y1, r1, x2, y2, r2] = this.coordsArr;
      const distance = Math.hypot(x1 - x2, y1 - y2);
      if (r1 <= r2 + distance && r2 <= r1 + distance) {
        warn("Unsupported radial gradient.");
      }
    }
    this.extendStart = extendStart;
    this.extendEnd = extendEnd;
    const fnObj = dict.getRaw("Function");
    const fn = pdfFunctionFactory.createFromArray(fnObj);
    const NUMBER_OF_SAMPLES = 10;
    const step = (t1 - t0) / NUMBER_OF_SAMPLES;
    const colorStops = this.colorStops = [];
    if (t0 >= t1 || step <= 0) {
      info("Bad shading domain.");
      return;
    }
    const color = new Float32Array(cs.numComps), ratio = new Float32Array(1);
    let rgbColor;
    for (let i = 0; i <= NUMBER_OF_SAMPLES; i++) {
      ratio[0] = t0 + i * step;
      fn(ratio, 0, color, 0);
      rgbColor = cs.getRgb(color, 0);
      const cssColor = Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);
      colorStops.push([i / NUMBER_OF_SAMPLES, cssColor]);
    }
    let background = "transparent";
    if (dict.has("Background")) {
      rgbColor = cs.getRgb(dict.get("Background"), 0);
      background = Util.makeHexColor(rgbColor[0], rgbColor[1], rgbColor[2]);
    }
    if (!extendStart) {
      colorStops.unshift([0, background]);
      colorStops[1][0] += BaseShading.SMALL_NUMBER;
    }
    if (!extendEnd) {
      colorStops[colorStops.length - 1][0] -= BaseShading.SMALL_NUMBER;
      colorStops.push([1, background]);
    }
    this.colorStops = colorStops;
  }
  getIR() {
    const coordsArr = this.coordsArr;
    const shadingType = this.shadingType;
    let type, p0, p1, r0, r1;
    if (shadingType === ShadingType.AXIAL) {
      p0 = [coordsArr[0], coordsArr[1]];
      p1 = [coordsArr[2], coordsArr[3]];
      r0 = null;
      r1 = null;
      type = "axial";
    } else if (shadingType === ShadingType.RADIAL) {
      p0 = [coordsArr[0], coordsArr[1]];
      p1 = [coordsArr[3], coordsArr[4]];
      r0 = coordsArr[2];
      r1 = coordsArr[5];
      type = "radial";
    } else {
      unreachable(`getPattern type unknown: ${shadingType}`);
    }
    return ["RadialAxial", type, this.bbox, this.colorStops, p0, p1, r0, r1, this.matrix];
  }
};
var MeshStreamReader = class {
  constructor(stream, context) {
    this.stream = stream;
    this.context = context;
    this.buffer = 0;
    this.bufferLength = 0;
    const numComps = context.numComps;
    this.tmpCompsBuf = new Float32Array(numComps);
    const csNumComps = context.colorSpace.numComps;
    this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end) {
      return this.stream.pos < this.stream.end;
    }
    if (this.bufferLength > 0) {
      return true;
    }
    const nextByte = this.stream.getByte();
    if (nextByte < 0) {
      return false;
    }
    this.buffer = nextByte;
    this.bufferLength = 8;
    return true;
  }
  readBits(n) {
    let buffer = this.buffer;
    let bufferLength = this.bufferLength;
    if (n === 32) {
      if (bufferLength === 0) {
        return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
      }
      buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
      const nextByte = this.stream.getByte();
      this.buffer = nextByte & (1 << bufferLength) - 1;
      return (buffer << 8 - bufferLength | (nextByte & 255) >> bufferLength) >>> 0;
    }
    if (n === 8 && bufferLength === 0) {
      return this.stream.getByte();
    }
    while (bufferLength < n) {
      buffer = buffer << 8 | this.stream.getByte();
      bufferLength += 8;
    }
    bufferLength -= n;
    this.bufferLength = bufferLength;
    this.buffer = buffer & (1 << bufferLength) - 1;
    return buffer >> bufferLength;
  }
  align() {
    this.buffer = 0;
    this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const bitsPerCoordinate = this.context.bitsPerCoordinate;
    const xi = this.readBits(bitsPerCoordinate);
    const yi = this.readBits(bitsPerCoordinate);
    const decode = this.context.decode;
    const scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 23283064365386963e-26;
    return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
  }
  readComponents() {
    const numComps = this.context.numComps;
    const bitsPerComponent = this.context.bitsPerComponent;
    const scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 23283064365386963e-26;
    const decode = this.context.decode;
    const components = this.tmpCompsBuf;
    for (let i = 0, j = 4; i < numComps; i++, j += 2) {
      const ci = this.readBits(bitsPerComponent);
      components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
    }
    const color = this.tmpCsCompsBuf;
    if (this.context.colorFn) {
      this.context.colorFn(components, 0, color, 0);
    }
    return this.context.colorSpace.getRgb(color, 0);
  }
};
var getB = /* @__PURE__ */ function getBClosure() {
  function buildB(count) {
    const lut = [];
    for (let i = 0; i <= count; i++) {
      const t = i / count, t_ = 1 - t;
      lut.push(new Float32Array([t_ * t_ * t_, 3 * t * t_ * t_, 3 * t * t * t_, t * t * t]));
    }
    return lut;
  }
  const cache = [];
  return function(count) {
    if (!cache[count]) {
      cache[count] = buildB(count);
    }
    return cache[count];
  };
}();
var MeshShading = class _MeshShading extends BaseShading {
  static get MIN_SPLIT_PATCH_CHUNKS_AMOUNT() {
    return shadow(this, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
  }
  static get MAX_SPLIT_PATCH_CHUNKS_AMOUNT() {
    return shadow(this, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
  }
  // Count of triangles per entire mesh bounds.
  static get TRIANGLE_DENSITY() {
    return shadow(this, "TRIANGLE_DENSITY", 20);
  }
  constructor(stream, matrix, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
    super();
    if (!isStream(stream)) {
      throw new FormatError("Mesh data is not a stream");
    }
    const dict = stream.dict;
    this.matrix = matrix;
    this.shadingType = dict.get("ShadingType");
    const bbox = dict.getArray("BBox");
    if (Array.isArray(bbox) && bbox.length === 4) {
      this.bbox = Util.normalizeRect(bbox);
    } else {
      this.bbox = null;
    }
    const cs = ColorSpace.parse({
      cs: dict.getRaw("ColorSpace") || dict.getRaw("CS"),
      xref,
      resources,
      pdfFunctionFactory,
      localColorSpaceCache
    });
    this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
    const fnObj = dict.getRaw("Function");
    const fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
    this.coords = [];
    this.colors = [];
    this.figures = [];
    const decodeContext = {
      bitsPerCoordinate: dict.get("BitsPerCoordinate"),
      bitsPerComponent: dict.get("BitsPerComponent"),
      bitsPerFlag: dict.get("BitsPerFlag"),
      decode: dict.getArray("Decode"),
      colorFn: fn,
      colorSpace: cs,
      numComps: fn ? 1 : cs.numComps
    };
    const reader = new MeshStreamReader(stream, decodeContext);
    let patchMesh = false;
    switch (this.shadingType) {
      case ShadingType.FREE_FORM_MESH:
        this._decodeType4Shading(reader);
        break;
      case ShadingType.LATTICE_FORM_MESH:
        const verticesPerRow = dict.get("VerticesPerRow") | 0;
        if (verticesPerRow < 2) {
          throw new FormatError("Invalid VerticesPerRow");
        }
        this._decodeType5Shading(reader, verticesPerRow);
        break;
      case ShadingType.COONS_PATCH_MESH:
        this._decodeType6Shading(reader);
        patchMesh = true;
        break;
      case ShadingType.TENSOR_PATCH_MESH:
        this._decodeType7Shading(reader);
        patchMesh = true;
        break;
      default:
        unreachable("Unsupported mesh type.");
        break;
    }
    if (patchMesh) {
      this._updateBounds();
      for (let i = 0, ii = this.figures.length; i < ii; i++) {
        this._buildFigureFromPatch(i);
      }
    }
    this._updateBounds();
    this._packData();
  }
  _decodeType4Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = [];
    let verticesLeft = 0;
    while (reader.hasData) {
      const f = reader.readFlag();
      const coord = reader.readCoordinate();
      const color = reader.readComponents();
      if (verticesLeft === 0) {
        if (!(0 <= f && f <= 2)) {
          throw new FormatError("Unknown type4 flag");
        }
        switch (f) {
          case 0:
            verticesLeft = 3;
            break;
          case 1:
            ps.push(ps[ps.length - 2], ps[ps.length - 1]);
            verticesLeft = 1;
            break;
          case 2:
            ps.push(ps[ps.length - 3], ps[ps.length - 1]);
            verticesLeft = 1;
            break;
        }
      }
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
      verticesLeft--;
      reader.align();
    }
    this.figures.push({
      type: "triangles",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps)
    });
  }
  _decodeType5Shading(reader, verticesPerRow) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = [];
    while (reader.hasData) {
      const coord = reader.readCoordinate();
      const color = reader.readComponents();
      ps.push(coords.length);
      coords.push(coord);
      colors.push(color);
    }
    this.figures.push({
      type: "lattice",
      coords: new Int32Array(ps),
      colors: new Int32Array(ps),
      verticesPerRow
    });
  }
  _decodeType6Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = new Int32Array(16);
    const cs = new Int32Array(4);
    while (reader.hasData) {
      const f = reader.readFlag();
      if (!(0 <= f && f <= 3)) {
        throw new FormatError("Unknown type6 flag");
      }
      const pi = coords.length;
      for (let i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }
      const ci = colors.length;
      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }
      let tmp1, tmp2, tmp3, tmp4;
      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;
        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }
      ps[5] = coords.length;
      coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
      ps[6] = coords.length;
      coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
      ps[9] = coords.length;
      coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
      ps[10] = coords.length;
      coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
      this.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        // making copies of ps and cs
        colors: new Int32Array(cs)
      });
    }
  }
  _decodeType7Shading(reader) {
    const coords = this.coords;
    const colors = this.colors;
    const ps = new Int32Array(16);
    const cs = new Int32Array(4);
    while (reader.hasData) {
      const f = reader.readFlag();
      if (!(0 <= f && f <= 3)) {
        throw new FormatError("Unknown type7 flag");
      }
      const pi = coords.length;
      for (let i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
        coords.push(reader.readCoordinate());
      }
      const ci = colors.length;
      for (let i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
        colors.push(reader.readComponents());
      }
      let tmp1, tmp2, tmp3, tmp4;
      switch (f) {
        case 0:
          ps[12] = pi + 3;
          ps[13] = pi + 4;
          ps[14] = pi + 5;
          ps[15] = pi + 6;
          ps[8] = pi + 2;
          ps[9] = pi + 13;
          ps[10] = pi + 14;
          ps[11] = pi + 7;
          ps[4] = pi + 1;
          ps[5] = pi + 12;
          ps[6] = pi + 15;
          ps[7] = pi + 8;
          ps[0] = pi;
          ps[1] = pi + 11;
          ps[2] = pi + 10;
          ps[3] = pi + 9;
          cs[2] = ci + 1;
          cs[3] = ci + 2;
          cs[0] = ci;
          cs[1] = ci + 3;
          break;
        case 1:
          tmp1 = ps[12];
          tmp2 = ps[13];
          tmp3 = ps[14];
          tmp4 = ps[15];
          ps[12] = tmp4;
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = tmp3;
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[2];
          tmp2 = cs[3];
          cs[2] = tmp2;
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 2:
          tmp1 = ps[15];
          tmp2 = ps[11];
          ps[12] = ps[3];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[7];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = tmp2;
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = tmp1;
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          tmp1 = cs[3];
          cs[2] = cs[1];
          cs[3] = ci;
          cs[0] = tmp1;
          cs[1] = ci + 1;
          break;
        case 3:
          ps[12] = ps[0];
          ps[13] = pi + 0;
          ps[14] = pi + 1;
          ps[15] = pi + 2;
          ps[8] = ps[1];
          ps[9] = pi + 9;
          ps[10] = pi + 10;
          ps[11] = pi + 3;
          ps[4] = ps[2];
          ps[5] = pi + 8;
          ps[6] = pi + 11;
          ps[7] = pi + 4;
          ps[0] = ps[3];
          ps[1] = pi + 7;
          ps[2] = pi + 6;
          ps[3] = pi + 5;
          cs[2] = cs[0];
          cs[3] = ci;
          cs[0] = cs[1];
          cs[1] = ci + 1;
          break;
      }
      this.figures.push({
        type: "patch",
        coords: new Int32Array(ps),
        // making copies of ps and cs
        colors: new Int32Array(cs)
      });
    }
  }
  _buildFigureFromPatch(index) {
    const figure = this.figures[index];
    assert(figure.type === "patch", "Unexpected patch mesh figure");
    const coords = this.coords, colors = this.colors;
    const pi = figure.coords;
    const ci = figure.colors;
    const figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    const figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    const figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
    const figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
    let splitXBy = Math.ceil((figureMaxX - figureMinX) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    splitXBy = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
    let splitYBy = Math.ceil((figureMaxY - figureMinY) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    splitYBy = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
    const verticesPerRow = splitXBy + 1;
    const figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
    const figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
    let k = 0;
    const cl = new Uint8Array(3), cr = new Uint8Array(3);
    const c0 = colors[ci[0]], c1 = colors[ci[1]], c2 = colors[ci[2]], c3 = colors[ci[3]];
    const bRow = getB(splitYBy), bCol = getB(splitXBy);
    for (let row = 0; row <= splitYBy; row++) {
      cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
      cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
      cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
      cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
      cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
      cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;
      for (let col = 0; col <= splitXBy; col++, k++) {
        if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
          continue;
        }
        let x = 0, y = 0;
        let q = 0;
        for (let i = 0; i <= 3; i++) {
          for (let j = 0; j <= 3; j++, q++) {
            const m = bRow[row][i] * bCol[col][j];
            x += coords[pi[q]][0] * m;
            y += coords[pi[q]][1] * m;
          }
        }
        figureCoords[k] = coords.length;
        coords.push([x, y]);
        figureColors[k] = colors.length;
        const newColor = new Uint8Array(3);
        newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
        newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
        newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
        colors.push(newColor);
      }
    }
    figureCoords[0] = pi[0];
    figureColors[0] = ci[0];
    figureCoords[splitXBy] = pi[3];
    figureColors[splitXBy] = ci[1];
    figureCoords[verticesPerRow * splitYBy] = pi[12];
    figureColors[verticesPerRow * splitYBy] = ci[2];
    figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
    figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
    this.figures[index] = {
      type: "lattice",
      coords: figureCoords,
      colors: figureColors,
      verticesPerRow
    };
  }
  _updateBounds() {
    let minX = this.coords[0][0], minY = this.coords[0][1], maxX = minX, maxY = minY;
    for (let i = 1, ii = this.coords.length; i < ii; i++) {
      const x = this.coords[i][0], y = this.coords[i][1];
      minX = minX > x ? x : minX;
      minY = minY > y ? y : minY;
      maxX = maxX < x ? x : maxX;
      maxY = maxY < y ? y : maxY;
    }
    this.bounds = [minX, minY, maxX, maxY];
  }
  _packData() {
    let i, ii, j, jj;
    const coords = this.coords;
    const coordsPacked = new Float32Array(coords.length * 2);
    for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
      const xy = coords[i];
      coordsPacked[j++] = xy[0];
      coordsPacked[j++] = xy[1];
    }
    this.coords = coordsPacked;
    const colors = this.colors;
    const colorsPacked = new Uint8Array(colors.length * 3);
    for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
      const c = colors[i];
      colorsPacked[j++] = c[0];
      colorsPacked[j++] = c[1];
      colorsPacked[j++] = c[2];
    }
    this.colors = colorsPacked;
    const figures = this.figures;
    for (i = 0, ii = figures.length; i < ii; i++) {
      const figure = figures[i], ps = figure.coords, cs = figure.colors;
      for (j = 0, jj = ps.length; j < jj; j++) {
        ps[j] *= 2;
        cs[j] *= 3;
      }
    }
  }
  getIR() {
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.matrix, this.bbox, this.background];
  }
};
var DummyShading = class extends BaseShading {
  getIR() {
    return ["Dummy"];
  }
};
function getTilingPatternIR(operatorList, dict, color) {
  const matrix = dict.getArray("Matrix");
  const bbox = Util.normalizeRect(dict.getArray("BBox"));
  const xstep = dict.get("XStep");
  const ystep = dict.get("YStep");
  const paintType = dict.get("PaintType");
  const tilingType = dict.get("TilingType");
  if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
    throw new FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`);
  }
  return ["TilingPattern", color, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
}
var PostScriptParser = class {
  constructor(lexer) {
    this.lexer = lexer;
    this.operators = [];
    this.token = null;
    this.prev = null;
  }
  nextToken() {
    this.prev = this.token;
    this.token = this.lexer.getToken();
  }
  accept(type) {
    if (this.token.type === type) {
      this.nextToken();
      return true;
    }
    return false;
  }
  expect(type) {
    if (this.accept(type)) {
      return true;
    }
    throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`);
  }
  parse() {
    this.nextToken();
    this.expect(PostScriptTokenTypes.LBRACE);
    this.parseBlock();
    this.expect(PostScriptTokenTypes.RBRACE);
    return this.operators;
  }
  parseBlock() {
    while (true) {
      if (this.accept(PostScriptTokenTypes.NUMBER)) {
        this.operators.push(this.prev.value);
      } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
        this.operators.push(this.prev.value);
      } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
        this.parseCondition();
      } else {
        return;
      }
    }
  }
  parseCondition() {
    const conditionLocation = this.operators.length;
    this.operators.push(null, null);
    this.parseBlock();
    this.expect(PostScriptTokenTypes.RBRACE);
    if (this.accept(PostScriptTokenTypes.IF)) {
      this.operators[conditionLocation] = this.operators.length;
      this.operators[conditionLocation + 1] = "jz";
    } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
      const jumpLocation = this.operators.length;
      this.operators.push(null, null);
      const endOfTrue = this.operators.length;
      this.parseBlock();
      this.expect(PostScriptTokenTypes.RBRACE);
      this.expect(PostScriptTokenTypes.IFELSE);
      this.operators[jumpLocation] = this.operators.length;
      this.operators[jumpLocation + 1] = "j";
      this.operators[conditionLocation] = endOfTrue;
      this.operators[conditionLocation + 1] = "jz";
    } else {
      throw new FormatError("PS Function: error parsing conditional.");
    }
  }
};
var PostScriptTokenTypes = {
  LBRACE: 0,
  RBRACE: 1,
  NUMBER: 2,
  OPERATOR: 3,
  IF: 4,
  IFELSE: 5
};
var PostScriptToken = class _PostScriptToken {
  static get opCache() {
    return shadow(this, "opCache", /* @__PURE__ */ Object.create(null));
  }
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static getOperator(op) {
    const opValue = _PostScriptToken.opCache[op];
    if (opValue) {
      return opValue;
    }
    return _PostScriptToken.opCache[op] = new _PostScriptToken(PostScriptTokenTypes.OPERATOR, op);
  }
  static get LBRACE() {
    return shadow(this, "LBRACE", new _PostScriptToken(PostScriptTokenTypes.LBRACE, "{"));
  }
  static get RBRACE() {
    return shadow(this, "RBRACE", new _PostScriptToken(PostScriptTokenTypes.RBRACE, "}"));
  }
  static get IF() {
    return shadow(this, "IF", new _PostScriptToken(PostScriptTokenTypes.IF, "IF"));
  }
  static get IFELSE() {
    return shadow(this, "IFELSE", new _PostScriptToken(PostScriptTokenTypes.IFELSE, "IFELSE"));
  }
};
var PostScriptLexer = class {
  constructor(stream) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let comment = false;
    let ch = this.currentChar;
    while (true) {
      if (ch < 0) {
        return EOF;
      }
      if (comment) {
        if (ch === 10 || ch === 13) {
          comment = false;
        }
      } else if (ch === /* '%' = */
      37) {
        comment = true;
      } else if (!isWhiteSpace(ch)) {
        break;
      }
      ch = this.nextChar();
    }
    switch (ch | 0) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
      case 123:
        this.nextChar();
        return PostScriptToken.LBRACE;
      case 125:
        this.nextChar();
        return PostScriptToken.RBRACE;
    }
    const strBuf = this.strBuf;
    strBuf.length = 0;
    strBuf[0] = String.fromCharCode(ch);
    while ((ch = this.nextChar()) >= 0 && (ch >= /* 'A' = */
    65 && ch <= /* 'Z' = */
    90 || ch >= /* 'a' = */
    97 && ch <= /* 'z' = */
    122)) {
      strBuf.push(String.fromCharCode(ch));
    }
    const str = strBuf.join("");
    switch (str.toLowerCase()) {
      case "if":
        return PostScriptToken.IF;
      case "ifelse":
        return PostScriptToken.IFELSE;
      default:
        return PostScriptToken.getOperator(str);
    }
  }
  getNumber() {
    let ch = this.currentChar;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    strBuf[0] = String.fromCharCode(ch);
    while ((ch = this.nextChar()) >= 0) {
      if (ch >= /* '0' = */
      48 && ch <= /* '9' = */
      57 || ch === /* '-' = */
      45 || ch === /* '.' = */
      46) {
        strBuf.push(String.fromCharCode(ch));
      } else {
        break;
      }
    }
    const value = parseFloat(strBuf.join(""));
    if (isNaN(value)) {
      throw new FormatError(`Invalid floating point number: ${value}`);
    }
    return value;
  }
};
var BaseLocalCache = class _BaseLocalCache {
  constructor(options) {
    if (this.constructor === _BaseLocalCache) {
      unreachable("Cannot initialize BaseLocalCache.");
    }
    if (!options || !options.onlyRefs) {
      this._nameRefMap = /* @__PURE__ */ new Map();
      this._imageMap = /* @__PURE__ */ new Map();
    }
    this._imageCache = new RefSetCache();
  }
  getByName(name) {
    const ref = this._nameRefMap.get(name);
    if (ref) {
      return this.getByRef(ref);
    }
    return this._imageMap.get(name) || null;
  }
  getByRef(ref) {
    return this._imageCache.get(ref) || null;
  }
  set(name, ref, data) {
    unreachable("Abstract method `set` called.");
  }
};
var LocalImageCache = class extends BaseLocalCache {
  set(name, ref = null, data) {
    if (typeof name !== "string") {
      throw new Error('LocalImageCache.set - expected "name" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      this._nameRefMap.set(name, ref);
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
};
var LocalColorSpaceCache = class extends BaseLocalCache {
  set(name = null, ref = null, data) {
    if (typeof name !== "string" && !ref) {
      throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      if (name !== null) {
        this._nameRefMap.set(name, ref);
      }
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
};
var LocalFunctionCache = class extends BaseLocalCache {
  constructor(options) {
    super({
      onlyRefs: true
    });
  }
  getByName(name) {
    unreachable("Should not call `getByName` method.");
  }
  set(name = null, ref, data) {
    if (!ref) {
      throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    this._imageCache.put(ref, data);
  }
};
var LocalGStateCache = class extends BaseLocalCache {
  set(name, ref = null, data) {
    if (typeof name !== "string") {
      throw new Error('LocalGStateCache.set - expected "name" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      this._nameRefMap.set(name, ref);
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
};
var LocalTilingPatternCache = class extends BaseLocalCache {
  set(name, ref = null, data) {
    if (typeof name !== "string") {
      throw new Error('LocalTilingPatternCache.set - expected "name" argument.');
    }
    if (ref) {
      if (this._imageCache.has(ref)) {
        return;
      }
      this._nameRefMap.set(name, ref);
      this._imageCache.put(ref, data);
      return;
    }
    if (this._imageMap.has(name)) {
      return;
    }
    this._imageMap.set(name, data);
  }
};
var GlobalImageCache = class _GlobalImageCache {
  static get NUM_PAGES_THRESHOLD() {
    return shadow(this, "NUM_PAGES_THRESHOLD", 2);
  }
  static get MIN_IMAGES_TO_CACHE() {
    return shadow(this, "MIN_IMAGES_TO_CACHE", 10);
  }
  static get MAX_BYTE_SIZE() {
    return shadow(
      this,
      "MAX_BYTE_SIZE",
      /* Forty megabytes = */
      4e7
    );
  }
  constructor() {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(_GlobalImageCache.NUM_PAGES_THRESHOLD > 1, "GlobalImageCache - invalid NUM_PAGES_THRESHOLD constant.");
    }
    this._refCache = new RefSetCache();
    this._imageCache = new RefSetCache();
  }
  get _byteSize() {
    let byteSize = 0;
    this._imageCache.forEach((imageData) => {
      byteSize += imageData.byteSize;
    });
    return byteSize;
  }
  get _cacheLimitReached() {
    if (this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) {
      return false;
    }
    if (this._byteSize < _GlobalImageCache.MAX_BYTE_SIZE) {
      return false;
    }
    return true;
  }
  shouldCache(ref, pageIndex) {
    const pageIndexSet = this._refCache.get(ref);
    const numPages = pageIndexSet ? pageIndexSet.size + (pageIndexSet.has(pageIndex) ? 0 : 1) : 1;
    if (numPages < _GlobalImageCache.NUM_PAGES_THRESHOLD) {
      return false;
    }
    if (!this._imageCache.has(ref) && this._cacheLimitReached) {
      return false;
    }
    return true;
  }
  addPageIndex(ref, pageIndex) {
    let pageIndexSet = this._refCache.get(ref);
    if (!pageIndexSet) {
      pageIndexSet = /* @__PURE__ */ new Set();
      this._refCache.put(ref, pageIndexSet);
    }
    pageIndexSet.add(pageIndex);
  }
  /**
   * PLEASE NOTE: Must be called *after* the `setData` method.
   */
  addByteSize(ref, byteSize) {
    const imageData = this._imageCache.get(ref);
    if (!imageData) {
      return;
    }
    if (imageData.byteSize) {
      return;
    }
    imageData.byteSize = byteSize;
  }
  getData(ref, pageIndex) {
    const pageIndexSet = this._refCache.get(ref);
    if (!pageIndexSet) {
      return null;
    }
    if (pageIndexSet.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) {
      return null;
    }
    const imageData = this._imageCache.get(ref);
    if (!imageData) {
      return null;
    }
    pageIndexSet.add(pageIndex);
    return imageData;
  }
  setData(ref, data) {
    if (!this._refCache.has(ref)) {
      throw new Error('GlobalImageCache.setData - expected "addPageIndex" to have been called.');
    }
    if (this._imageCache.has(ref)) {
      return;
    }
    if (this._cacheLimitReached) {
      warn("GlobalImageCache.setData - cache limit reached.");
      return;
    }
    this._imageCache.put(ref, data);
  }
  clear(onlyData = false) {
    if (!onlyData) {
      this._refCache.clear();
    }
    this._imageCache.clear();
  }
};
var PDFFunctionFactory = class {
  constructor({
    xref,
    isEvalSupported = true
  }) {
    this.xref = xref;
    this.isEvalSupported = isEvalSupported !== false;
  }
  create(fn) {
    const cachedFunction = this.getCached(fn);
    if (cachedFunction) {
      return cachedFunction;
    }
    const parsedFunction = PDFFunction.parse({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fn: fn instanceof Ref ? this.xref.fetch(fn) : fn
    });
    this._cache(fn, parsedFunction);
    return parsedFunction;
  }
  createFromArray(fnObj) {
    const cachedFunction = this.getCached(fnObj);
    if (cachedFunction) {
      return cachedFunction;
    }
    const parsedFunction = PDFFunction.parseArray({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fnObj: fnObj instanceof Ref ? this.xref.fetch(fnObj) : fnObj
    });
    this._cache(fnObj, parsedFunction);
    return parsedFunction;
  }
  getCached(cacheKey) {
    let fnRef;
    if (cacheKey instanceof Ref) {
      fnRef = cacheKey;
    } else if (cacheKey instanceof Dict) {
      fnRef = cacheKey.objId;
    } else if (isStream(cacheKey)) {
      fnRef = cacheKey.dict && cacheKey.dict.objId;
    }
    if (fnRef) {
      const localFunction = this._localFunctionCache.getByRef(fnRef);
      if (localFunction) {
        return localFunction;
      }
    }
    return null;
  }
  /**
   * @private
   */
  _cache(cacheKey, parsedFunction) {
    if (!parsedFunction) {
      throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
    }
    let fnRef;
    if (cacheKey instanceof Ref) {
      fnRef = cacheKey;
    } else if (cacheKey instanceof Dict) {
      fnRef = cacheKey.objId;
    } else if (isStream(cacheKey)) {
      fnRef = cacheKey.dict && cacheKey.dict.objId;
    }
    if (fnRef) {
      this._localFunctionCache.set(
        /* name = */
        null,
        fnRef,
        parsedFunction
      );
    }
  }
  /**
   * @private
   */
  get _localFunctionCache() {
    return shadow(this, "_localFunctionCache", new LocalFunctionCache());
  }
};
function toNumberArray(arr) {
  if (!Array.isArray(arr)) {
    return null;
  }
  const length = arr.length;
  for (let i = 0; i < length; i++) {
    if (typeof arr[i] !== "number") {
      const result = new Array(length);
      for (let j = 0; j < length; j++) {
        result[j] = +arr[j];
      }
      return result;
    }
  }
  return arr;
}
var PDFFunction = class {
  static getSampleArray(size, outputSize, bps, stream) {
    let i, ii;
    let length = 1;
    for (i = 0, ii = size.length; i < ii; i++) {
      length *= size[i];
    }
    length *= outputSize;
    const array = new Array(length);
    let codeSize = 0;
    let codeBuf = 0;
    const sampleMul = 1 / (2 ** bps - 1);
    const strBytes = stream.getBytes((length * bps + 7) / 8);
    let strIdx = 0;
    for (i = 0; i < length; i++) {
      while (codeSize < bps) {
        codeBuf <<= 8;
        codeBuf |= strBytes[strIdx++];
        codeSize += 8;
      }
      codeSize -= bps;
      array[i] = (codeBuf >> codeSize) * sampleMul;
      codeBuf &= (1 << codeSize) - 1;
    }
    return array;
  }
  static parse({
    xref,
    isEvalSupported,
    fn
  }) {
    const dict = fn.dict || fn;
    const typeNum = dict.get("FunctionType");
    switch (typeNum) {
      case 0:
        return this.constructSampled({
          xref,
          isEvalSupported,
          fn,
          dict
        });
      case 1:
        break;
      case 2:
        return this.constructInterpolated({
          xref,
          isEvalSupported,
          dict
        });
      case 3:
        return this.constructStiched({
          xref,
          isEvalSupported,
          dict
        });
      case 4:
        return this.constructPostScript({
          xref,
          isEvalSupported,
          fn,
          dict
        });
    }
    throw new FormatError("Unknown type of function");
  }
  static parseArray({
    xref,
    isEvalSupported,
    fnObj
  }) {
    if (!Array.isArray(fnObj)) {
      return this.parse({
        xref,
        isEvalSupported,
        fn: fnObj
      });
    }
    const fnArray = [];
    for (let j = 0, jj = fnObj.length; j < jj; j++) {
      fnArray.push(this.parse({
        xref,
        isEvalSupported,
        fn: xref.fetchIfRef(fnObj[j])
      }));
    }
    return function(src, srcOffset, dest, destOffset) {
      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        fnArray[i](src, srcOffset, dest, destOffset + i);
      }
    };
  }
  static constructSampled({
    xref,
    isEvalSupported,
    fn,
    dict
  }) {
    function toMultiArray(arr) {
      const inputLength = arr.length;
      const out = [];
      let index = 0;
      for (let i = 0; i < inputLength; i += 2) {
        out[index++] = [arr[i], arr[i + 1]];
      }
      return out;
    }
    function interpolate(x, xmin, xmax, ymin, ymax) {
      return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
    }
    let domain = toNumberArray(dict.getArray("Domain"));
    let range = toNumberArray(dict.getArray("Range"));
    if (!domain || !range) {
      throw new FormatError("No domain or range");
    }
    const inputSize = domain.length / 2;
    const outputSize = range.length / 2;
    domain = toMultiArray(domain);
    range = toMultiArray(range);
    const size = toNumberArray(dict.getArray("Size"));
    const bps = dict.get("BitsPerSample");
    const order = dict.get("Order") || 1;
    if (order !== 1) {
      info("No support for cubic spline interpolation: " + order);
    }
    let encode = toNumberArray(dict.getArray("Encode"));
    if (!encode) {
      encode = [];
      for (let i = 0; i < inputSize; ++i) {
        encode.push([0, size[i] - 1]);
      }
    } else {
      encode = toMultiArray(encode);
    }
    let decode = toNumberArray(dict.getArray("Decode"));
    if (!decode) {
      decode = range;
    } else {
      decode = toMultiArray(decode);
    }
    const samples = this.getSampleArray(size, outputSize, bps, fn);
    return function constructSampledFn(src, srcOffset, dest, destOffset) {
      const cubeVertices = 1 << inputSize;
      const cubeN = new Float64Array(cubeVertices);
      const cubeVertex = new Uint32Array(cubeVertices);
      let i, j;
      for (j = 0; j < cubeVertices; j++) {
        cubeN[j] = 1;
      }
      let k = outputSize, pos = 1;
      for (i = 0; i < inputSize; ++i) {
        const domain_2i = domain[i][0];
        const domain_2i_1 = domain[i][1];
        const xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
        let e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
        const size_i = size[i];
        e = Math.min(Math.max(e, 0), size_i - 1);
        const e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
        const n0 = e0 + 1 - e;
        const n1 = e - e0;
        const offset0 = e0 * k;
        const offset1 = offset0 + k;
        for (j = 0; j < cubeVertices; j++) {
          if (j & pos) {
            cubeN[j] *= n1;
            cubeVertex[j] += offset1;
          } else {
            cubeN[j] *= n0;
            cubeVertex[j] += offset0;
          }
        }
        k *= size_i;
        pos <<= 1;
      }
      for (j = 0; j < outputSize; ++j) {
        let rj = 0;
        for (i = 0; i < cubeVertices; i++) {
          rj += samples[cubeVertex[i] + j] * cubeN[i];
        }
        rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
        dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
      }
    };
  }
  static constructInterpolated({
    xref,
    isEvalSupported,
    dict
  }) {
    const c0 = toNumberArray(dict.getArray("C0")) || [0];
    const c1 = toNumberArray(dict.getArray("C1")) || [1];
    const n = dict.get("N");
    const diff = [];
    for (let i = 0, ii = c0.length; i < ii; ++i) {
      diff.push(c1[i] - c0[i]);
    }
    const length = diff.length;
    return function constructInterpolatedFn(src, srcOffset, dest, destOffset) {
      const x = n === 1 ? src[srcOffset] : src[srcOffset] ** n;
      for (let j = 0; j < length; ++j) {
        dest[destOffset + j] = c0[j] + x * diff[j];
      }
    };
  }
  static constructStiched({
    xref,
    isEvalSupported,
    dict
  }) {
    const domain = toNumberArray(dict.getArray("Domain"));
    if (!domain) {
      throw new FormatError("No domain");
    }
    const inputSize = domain.length / 2;
    if (inputSize !== 1) {
      throw new FormatError("Bad domain for stiched function");
    }
    const fnRefs = dict.get("Functions");
    const fns = [];
    for (let i = 0, ii = fnRefs.length; i < ii; ++i) {
      fns.push(this.parse({
        xref,
        isEvalSupported,
        fn: xref.fetchIfRef(fnRefs[i])
      }));
    }
    const bounds = toNumberArray(dict.getArray("Bounds"));
    const encode = toNumberArray(dict.getArray("Encode"));
    const tmpBuf = new Float32Array(1);
    return function constructStichedFn(src, srcOffset, dest, destOffset) {
      const clip = function constructStichedFromIRClip(v2, min, max) {
        if (v2 > max) {
          v2 = max;
        } else if (v2 < min) {
          v2 = min;
        }
        return v2;
      };
      const v = clip(src[srcOffset], domain[0], domain[1]);
      const length = bounds.length;
      let i;
      for (i = 0; i < length; ++i) {
        if (v < bounds[i]) {
          break;
        }
      }
      let dmin = domain[0];
      if (i > 0) {
        dmin = bounds[i - 1];
      }
      let dmax = domain[1];
      if (i < bounds.length) {
        dmax = bounds[i];
      }
      const rmin = encode[2 * i];
      const rmax = encode[2 * i + 1];
      tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
      fns[i](tmpBuf, 0, dest, destOffset);
    };
  }
  static constructPostScript({
    xref,
    isEvalSupported,
    fn,
    dict
  }) {
    const domain = toNumberArray(dict.getArray("Domain"));
    const range = toNumberArray(dict.getArray("Range"));
    if (!domain) {
      throw new FormatError("No domain.");
    }
    if (!range) {
      throw new FormatError("No range.");
    }
    const lexer = new PostScriptLexer(fn);
    const parser = new PostScriptParser(lexer);
    const code = parser.parse();
    if (isEvalSupported && IsEvalSupportedCached.value) {
      const compiled = new PostScriptCompiler().compile(code, domain, range);
      if (compiled) {
        return new Function("src", "srcOffset", "dest", "destOffset", compiled);
      }
    }
    info("Unable to compile PS function");
    const numOutputs = range.length >> 1;
    const numInputs = domain.length >> 1;
    const evaluator = new PostScriptEvaluator(code);
    const cache = /* @__PURE__ */ Object.create(null);
    const MAX_CACHE_SIZE = 2048 * 4;
    let cache_available = MAX_CACHE_SIZE;
    const tmpBuf = new Float32Array(numInputs);
    return function constructPostScriptFn(src, srcOffset, dest, destOffset) {
      let i, value;
      let key = "";
      const input = tmpBuf;
      for (i = 0; i < numInputs; i++) {
        value = src[srcOffset + i];
        input[i] = value;
        key += value + "_";
      }
      const cachedValue = cache[key];
      if (cachedValue !== void 0) {
        dest.set(cachedValue, destOffset);
        return;
      }
      const output = new Float32Array(numOutputs);
      const stack = evaluator.execute(input);
      const stackIndex = stack.length - numOutputs;
      for (i = 0; i < numOutputs; i++) {
        value = stack[stackIndex + i];
        let bound = range[i * 2];
        if (value < bound) {
          value = bound;
        } else {
          bound = range[i * 2 + 1];
          if (value > bound) {
            value = bound;
          }
        }
        output[i] = value;
      }
      if (cache_available > 0) {
        cache_available--;
        cache[key] = output;
      }
      dest.set(output, destOffset);
    };
  }
};
function isPDFFunction(v) {
  let fnDict;
  if (typeof v !== "object") {
    return false;
  } else if (isDict(v)) {
    fnDict = v;
  } else if (isStream(v)) {
    fnDict = v.dict;
  } else {
    return false;
  }
  return fnDict.has("FunctionType");
}
var PostScriptStack = class _PostScriptStack {
  static get MAX_STACK_SIZE() {
    return shadow(this, "MAX_STACK_SIZE", 100);
  }
  constructor(initialStack) {
    this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
  }
  push(value) {
    if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE) {
      throw new Error("PostScript function stack overflow.");
    }
    this.stack.push(value);
  }
  pop() {
    if (this.stack.length <= 0) {
      throw new Error("PostScript function stack underflow.");
    }
    return this.stack.pop();
  }
  copy(n) {
    if (this.stack.length + n >= _PostScriptStack.MAX_STACK_SIZE) {
      throw new Error("PostScript function stack overflow.");
    }
    const stack = this.stack;
    for (let i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
      stack.push(stack[i]);
    }
  }
  index(n) {
    this.push(this.stack[this.stack.length - n - 1]);
  }
  // rotate the last n stack elements p times
  roll(n, p) {
    const stack = this.stack;
    const l = stack.length - n;
    const r = stack.length - 1;
    const c = l + (p - Math.floor(p / n) * n);
    for (let i = l, j = r; i < j; i++, j--) {
      const t = stack[i];
      stack[i] = stack[j];
      stack[j] = t;
    }
    for (let i = l, j = c - 1; i < j; i++, j--) {
      const t = stack[i];
      stack[i] = stack[j];
      stack[j] = t;
    }
    for (let i = c, j = r; i < j; i++, j--) {
      const t = stack[i];
      stack[i] = stack[j];
      stack[j] = t;
    }
  }
};
var PostScriptEvaluator = class {
  constructor(operators2) {
    this.operators = operators2;
  }
  execute(initialStack) {
    const stack = new PostScriptStack(initialStack);
    let counter = 0;
    const operators2 = this.operators;
    const length = operators2.length;
    let operator, a, b;
    while (counter < length) {
      operator = operators2[counter++];
      if (typeof operator === "number") {
        stack.push(operator);
        continue;
      }
      switch (operator) {
        case "jz":
          b = stack.pop();
          a = stack.pop();
          if (!a) {
            counter = b;
          }
          break;
        case "j":
          a = stack.pop();
          counter = a;
          break;
        case "abs":
          a = stack.pop();
          stack.push(Math.abs(a));
          break;
        case "add":
          b = stack.pop();
          a = stack.pop();
          stack.push(a + b);
          break;
        case "and":
          b = stack.pop();
          a = stack.pop();
          if (isBool(a) && isBool(b)) {
            stack.push(a && b);
          } else {
            stack.push(a & b);
          }
          break;
        case "atan":
          a = stack.pop();
          stack.push(Math.atan(a));
          break;
        case "bitshift":
          b = stack.pop();
          a = stack.pop();
          if (a > 0) {
            stack.push(a << b);
          } else {
            stack.push(a >> b);
          }
          break;
        case "ceiling":
          a = stack.pop();
          stack.push(Math.ceil(a));
          break;
        case "copy":
          a = stack.pop();
          stack.copy(a);
          break;
        case "cos":
          a = stack.pop();
          stack.push(Math.cos(a));
          break;
        case "cvi":
          a = stack.pop() | 0;
          stack.push(a);
          break;
        case "cvr":
          break;
        case "div":
          b = stack.pop();
          a = stack.pop();
          stack.push(a / b);
          break;
        case "dup":
          stack.copy(1);
          break;
        case "eq":
          b = stack.pop();
          a = stack.pop();
          stack.push(a === b);
          break;
        case "exch":
          stack.roll(2, 1);
          break;
        case "exp":
          b = stack.pop();
          a = stack.pop();
          stack.push(a ** b);
          break;
        case "false":
          stack.push(false);
          break;
        case "floor":
          a = stack.pop();
          stack.push(Math.floor(a));
          break;
        case "ge":
          b = stack.pop();
          a = stack.pop();
          stack.push(a >= b);
          break;
        case "gt":
          b = stack.pop();
          a = stack.pop();
          stack.push(a > b);
          break;
        case "idiv":
          b = stack.pop();
          a = stack.pop();
          stack.push(a / b | 0);
          break;
        case "index":
          a = stack.pop();
          stack.index(a);
          break;
        case "le":
          b = stack.pop();
          a = stack.pop();
          stack.push(a <= b);
          break;
        case "ln":
          a = stack.pop();
          stack.push(Math.log(a));
          break;
        case "log":
          a = stack.pop();
          stack.push(Math.log(a) / Math.LN10);
          break;
        case "lt":
          b = stack.pop();
          a = stack.pop();
          stack.push(a < b);
          break;
        case "mod":
          b = stack.pop();
          a = stack.pop();
          stack.push(a % b);
          break;
        case "mul":
          b = stack.pop();
          a = stack.pop();
          stack.push(a * b);
          break;
        case "ne":
          b = stack.pop();
          a = stack.pop();
          stack.push(a !== b);
          break;
        case "neg":
          a = stack.pop();
          stack.push(-a);
          break;
        case "not":
          a = stack.pop();
          if (isBool(a)) {
            stack.push(!a);
          } else {
            stack.push(~a);
          }
          break;
        case "or":
          b = stack.pop();
          a = stack.pop();
          if (isBool(a) && isBool(b)) {
            stack.push(a || b);
          } else {
            stack.push(a | b);
          }
          break;
        case "pop":
          stack.pop();
          break;
        case "roll":
          b = stack.pop();
          a = stack.pop();
          stack.roll(a, b);
          break;
        case "round":
          a = stack.pop();
          stack.push(Math.round(a));
          break;
        case "sin":
          a = stack.pop();
          stack.push(Math.sin(a));
          break;
        case "sqrt":
          a = stack.pop();
          stack.push(Math.sqrt(a));
          break;
        case "sub":
          b = stack.pop();
          a = stack.pop();
          stack.push(a - b);
          break;
        case "true":
          stack.push(true);
          break;
        case "truncate":
          a = stack.pop();
          a = a < 0 ? Math.ceil(a) : Math.floor(a);
          stack.push(a);
          break;
        case "xor":
          b = stack.pop();
          a = stack.pop();
          if (isBool(a) && isBool(b)) {
            stack.push(a !== b);
          } else {
            stack.push(a ^ b);
          }
          break;
        default:
          throw new FormatError(`Unknown operator ${operator}`);
      }
    }
    return stack.stack;
  }
};
var PostScriptCompiler = /* @__PURE__ */ function PostScriptCompilerClosure() {
  class AstNode {
    constructor(type) {
      this.type = type;
    }
    visit(visitor) {
      unreachable("abstract method");
    }
  }
  class AstArgument extends AstNode {
    constructor(index, min, max) {
      super("args");
      this.index = index;
      this.min = min;
      this.max = max;
    }
    visit(visitor) {
      visitor.visitArgument(this);
    }
  }
  class AstLiteral extends AstNode {
    constructor(number) {
      super("literal");
      this.number = number;
      this.min = number;
      this.max = number;
    }
    visit(visitor) {
      visitor.visitLiteral(this);
    }
  }
  class AstBinaryOperation extends AstNode {
    constructor(op, arg1, arg2, min, max) {
      super("binary");
      this.op = op;
      this.arg1 = arg1;
      this.arg2 = arg2;
      this.min = min;
      this.max = max;
    }
    visit(visitor) {
      visitor.visitBinaryOperation(this);
    }
  }
  class AstMin extends AstNode {
    constructor(arg, max) {
      super("max");
      this.arg = arg;
      this.min = arg.min;
      this.max = max;
    }
    visit(visitor) {
      visitor.visitMin(this);
    }
  }
  class AstVariable extends AstNode {
    constructor(index, min, max) {
      super("var");
      this.index = index;
      this.min = min;
      this.max = max;
    }
    visit(visitor) {
      visitor.visitVariable(this);
    }
  }
  class AstVariableDefinition extends AstNode {
    constructor(variable, arg) {
      super("definition");
      this.variable = variable;
      this.arg = arg;
    }
    visit(visitor) {
      visitor.visitVariableDefinition(this);
    }
  }
  class ExpressionBuilderVisitor {
    constructor() {
      this.parts = [];
    }
    visitArgument(arg) {
      this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
    }
    visitVariable(variable) {
      this.parts.push("v", variable.index);
    }
    visitLiteral(literal) {
      this.parts.push(literal.number);
    }
    visitBinaryOperation(operation) {
      this.parts.push("(");
      operation.arg1.visit(this);
      this.parts.push(" ", operation.op, " ");
      operation.arg2.visit(this);
      this.parts.push(")");
    }
    visitVariableDefinition(definition) {
      this.parts.push("var ");
      definition.variable.visit(this);
      this.parts.push(" = ");
      definition.arg.visit(this);
      this.parts.push(";");
    }
    visitMin(max) {
      this.parts.push("Math.min(");
      max.arg.visit(this);
      this.parts.push(", ", max.max, ")");
    }
    toString() {
      return this.parts.join("");
    }
  }
  function buildAddOperation(num1, num2) {
    if (num2.type === "literal" && num2.number === 0) {
      return num1;
    }
    if (num1.type === "literal" && num1.number === 0) {
      return num2;
    }
    if (num2.type === "literal" && num1.type === "literal") {
      return new AstLiteral(num1.number + num2.number);
    }
    return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
  }
  function buildMulOperation(num1, num2) {
    if (num2.type === "literal") {
      if (num2.number === 0) {
        return new AstLiteral(0);
      } else if (num2.number === 1) {
        return num1;
      } else if (num1.type === "literal") {
        return new AstLiteral(num1.number * num2.number);
      }
    }
    if (num1.type === "literal") {
      if (num1.number === 0) {
        return new AstLiteral(0);
      } else if (num1.number === 1) {
        return num2;
      }
    }
    const min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
    const max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
    return new AstBinaryOperation("*", num1, num2, min, max);
  }
  function buildSubOperation(num1, num2) {
    if (num2.type === "literal") {
      if (num2.number === 0) {
        return num1;
      } else if (num1.type === "literal") {
        return new AstLiteral(num1.number - num2.number);
      }
    }
    if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
      return num2.arg2;
    }
    return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
  }
  function buildMinOperation(num1, max) {
    if (num1.min >= max) {
      return new AstLiteral(max);
    } else if (num1.max <= max) {
      return num1;
    }
    return new AstMin(num1, max);
  }
  class PostScriptCompiler2 {
    compile(code, domain, range) {
      const stack = [];
      const instructions = [];
      const inputSize = domain.length >> 1, outputSize = range.length >> 1;
      let lastRegister = 0;
      let n, j;
      let num1, num2, ast1, ast2, tmpVar, item;
      for (let i = 0; i < inputSize; i++) {
        stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
      }
      for (let i = 0, ii = code.length; i < ii; i++) {
        item = code[i];
        if (typeof item === "number") {
          stack.push(new AstLiteral(item));
          continue;
        }
        switch (item) {
          case "add":
            if (stack.length < 2) {
              return null;
            }
            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildAddOperation(num1, num2));
            break;
          case "cvr":
            if (stack.length < 1) {
              return null;
            }
            break;
          case "mul":
            if (stack.length < 2) {
              return null;
            }
            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildMulOperation(num1, num2));
            break;
          case "sub":
            if (stack.length < 2) {
              return null;
            }
            num2 = stack.pop();
            num1 = stack.pop();
            stack.push(buildSubOperation(num1, num2));
            break;
          case "exch":
            if (stack.length < 2) {
              return null;
            }
            ast1 = stack.pop();
            ast2 = stack.pop();
            stack.push(ast1, ast2);
            break;
          case "pop":
            if (stack.length < 1) {
              return null;
            }
            stack.pop();
            break;
          case "index":
            if (stack.length < 1) {
              return null;
            }
            num1 = stack.pop();
            if (num1.type !== "literal") {
              return null;
            }
            n = num1.number;
            if (n < 0 || !Number.isInteger(n) || stack.length < n) {
              return null;
            }
            ast1 = stack[stack.length - n - 1];
            if (ast1.type === "literal" || ast1.type === "var") {
              stack.push(ast1);
              break;
            }
            tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
            stack[stack.length - n - 1] = tmpVar;
            stack.push(tmpVar);
            instructions.push(new AstVariableDefinition(tmpVar, ast1));
            break;
          case "dup":
            if (stack.length < 1) {
              return null;
            }
            if (typeof code[i + 1] === "number" && code[i + 2] === "gt" && code[i + 3] === i + 7 && code[i + 4] === "jz" && code[i + 5] === "pop" && code[i + 6] === code[i + 1]) {
              num1 = stack.pop();
              stack.push(buildMinOperation(num1, code[i + 1]));
              i += 6;
              break;
            }
            ast1 = stack[stack.length - 1];
            if (ast1.type === "literal" || ast1.type === "var") {
              stack.push(ast1);
              break;
            }
            tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
            stack[stack.length - 1] = tmpVar;
            stack.push(tmpVar);
            instructions.push(new AstVariableDefinition(tmpVar, ast1));
            break;
          case "roll":
            if (stack.length < 2) {
              return null;
            }
            num2 = stack.pop();
            num1 = stack.pop();
            if (num2.type !== "literal" || num1.type !== "literal") {
              return null;
            }
            j = num2.number;
            n = num1.number;
            if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {
              return null;
            }
            j = (j % n + n) % n;
            if (j === 0) {
              break;
            }
            Array.prototype.push.apply(stack, stack.splice(stack.length - n, n - j));
            break;
          default:
            return null;
        }
      }
      if (stack.length !== outputSize) {
        return null;
      }
      const result = [];
      for (const instruction of instructions) {
        const statementBuilder = new ExpressionBuilderVisitor();
        instruction.visit(statementBuilder);
        result.push(statementBuilder.toString());
      }
      for (let i = 0, ii = stack.length; i < ii; i++) {
        const expr = stack[i], statementBuilder = new ExpressionBuilderVisitor();
        expr.visit(statementBuilder);
        const min = range[i * 2], max = range[i * 2 + 1];
        const out = [statementBuilder.toString()];
        if (min > expr.min) {
          out.unshift("Math.max(", min, ", ");
          out.push(")");
        }
        if (max < expr.max) {
          out.unshift("Math.min(", max, ", ");
          out.push(")");
        }
        out.unshift("dest[destOffset + ", i, "] = ");
        out.push(";");
        result.push(out.join(""));
      }
      return result.join("\n");
    }
  }
  return PostScriptCompiler2;
}();
var baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
var arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function isOdd(i) {
  return (i & 1) !== 0;
}
function isEven(i) {
  return (i & 1) === 0;
}
function findUnequal(arr, start, value) {
  let j, jj;
  for (j = start, jj = arr.length; j < jj; ++j) {
    if (arr[j] !== value) {
      return j;
    }
  }
  return j;
}
function setValues(arr, start, end, value) {
  for (let j = start; j < end; ++j) {
    arr[j] = value;
  }
}
function reverseValues(arr, start, end) {
  for (let i = start, j = end - 1; i < j; ++i, --j) {
    const temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}
function createBidiText(str, isLTR, vertical = false) {
  let dir = "ltr";
  if (vertical) {
    dir = "ttb";
  } else if (!isLTR) {
    dir = "rtl";
  }
  return {
    str,
    dir
  };
}
var chars = [];
var types = [];
function bidi(str, startLevel, vertical) {
  let isLTR = true;
  const strLength = str.length;
  if (strLength === 0 || vertical) {
    return createBidiText(str, isLTR, vertical);
  }
  chars.length = strLength;
  types.length = strLength;
  let numBidi = 0;
  let i, ii;
  for (i = 0; i < strLength; ++i) {
    chars[i] = str.charAt(i);
    const charCode = str.charCodeAt(i);
    let charType = "L";
    if (charCode <= 255) {
      charType = baseTypes[charCode];
    } else if (1424 <= charCode && charCode <= 1524) {
      charType = "R";
    } else if (1536 <= charCode && charCode <= 1791) {
      charType = arabicTypes[charCode & 255];
      if (!charType) {
        warn("Bidi: invalid Unicode character " + charCode.toString(16));
      }
    } else if (1792 <= charCode && charCode <= 2220) {
      charType = "AL";
    }
    if (charType === "R" || charType === "AL" || charType === "AN") {
      numBidi++;
    }
    types[i] = charType;
  }
  if (numBidi === 0) {
    isLTR = true;
    return createBidiText(str, isLTR);
  }
  if (startLevel === -1) {
    if (numBidi / strLength < 0.3) {
      isLTR = true;
      startLevel = 0;
    } else {
      isLTR = false;
      startLevel = 1;
    }
  }
  const levels = [];
  for (i = 0; i < strLength; ++i) {
    levels[i] = startLevel;
  }
  const e = isOdd(startLevel) ? "R" : "L";
  const sor = e;
  const eor = sor;
  let lastType = sor;
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "NSM") {
      types[i] = lastType;
    } else {
      lastType = types[i];
    }
  }
  lastType = sor;
  let t;
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "EN") {
      types[i] = lastType === "AL" ? "AN" : "EN";
    } else if (t === "R" || t === "L" || t === "AL") {
      lastType = t;
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "AL") {
      types[i] = "R";
    }
  }
  for (i = 1; i < strLength - 1; ++i) {
    if (types[i] === "ES" && types[i - 1] === "EN" && types[i + 1] === "EN") {
      types[i] = "EN";
    }
    if (types[i] === "CS" && (types[i - 1] === "EN" || types[i - 1] === "AN") && types[i + 1] === types[i - 1]) {
      types[i] = types[i - 1];
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "EN") {
      for (let j = i - 1; j >= 0; --j) {
        if (types[j] !== "ET") {
          break;
        }
        types[j] = "EN";
      }
      for (let j = i + 1; j < strLength; ++j) {
        if (types[j] !== "ET") {
          break;
        }
        types[j] = "EN";
      }
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "WS" || t === "ES" || t === "ET" || t === "CS") {
      types[i] = "ON";
    }
  }
  lastType = sor;
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (t === "EN") {
      types[i] = lastType === "L" ? "L" : "EN";
    } else if (t === "R" || t === "L") {
      lastType = t;
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      const end = findUnequal(types, i + 1, "ON");
      let before = sor;
      if (i > 0) {
        before = types[i - 1];
      }
      let after = eor;
      if (end + 1 < strLength) {
        after = types[end + 1];
      }
      if (before !== "L") {
        before = "R";
      }
      if (after !== "L") {
        after = "R";
      }
      if (before === after) {
        setValues(types, i, end, before);
      }
      i = end - 1;
    }
  }
  for (i = 0; i < strLength; ++i) {
    if (types[i] === "ON") {
      types[i] = e;
    }
  }
  for (i = 0; i < strLength; ++i) {
    t = types[i];
    if (isEven(levels[i])) {
      if (t === "R") {
        levels[i] += 1;
      } else if (t === "AN" || t === "EN") {
        levels[i] += 2;
      }
    } else {
      if (t === "L" || t === "AN" || t === "EN") {
        levels[i] += 1;
      }
    }
  }
  let highestLevel = -1;
  let lowestOddLevel = 99;
  let level;
  for (i = 0, ii = levels.length; i < ii; ++i) {
    level = levels[i];
    if (highestLevel < level) {
      highestLevel = level;
    }
    if (lowestOddLevel > level && isOdd(level)) {
      lowestOddLevel = level;
    }
  }
  for (level = highestLevel; level >= lowestOddLevel; --level) {
    let start = -1;
    for (i = 0, ii = levels.length; i < ii; ++i) {
      if (levels[i] < level) {
        if (start >= 0) {
          reverseValues(chars, start, i);
          start = -1;
        }
      } else if (start < 0) {
        start = i;
      }
    }
    if (start >= 0) {
      reverseValues(chars, start, levels.length);
    }
  }
  for (i = 0, ii = chars.length; i < ii; ++i) {
    const ch = chars[i];
    if (ch === "<" || ch === ">") {
      chars[i] = "";
    }
  }
  return createBidiText(chars.join(""), isLTR);
}
var getMetrics = getLookupTableFactory(function(t) {
  t.Courier = 600;
  t["Courier-Bold"] = 600;
  t["Courier-BoldOblique"] = 600;
  t["Courier-Oblique"] = 600;
  t.Helvetica = getLookupTableFactory(function(t2) {
    t2.space = 278;
    t2.exclam = 278;
    t2.quotedbl = 355;
    t2.numbersign = 556;
    t2.dollar = 556;
    t2.percent = 889;
    t2.ampersand = 667;
    t2.quoteright = 222;
    t2.parenleft = 333;
    t2.parenright = 333;
    t2.asterisk = 389;
    t2.plus = 584;
    t2.comma = 278;
    t2.hyphen = 333;
    t2.period = 278;
    t2.slash = 278;
    t2.zero = 556;
    t2.one = 556;
    t2.two = 556;
    t2.three = 556;
    t2.four = 556;
    t2.five = 556;
    t2.six = 556;
    t2.seven = 556;
    t2.eight = 556;
    t2.nine = 556;
    t2.colon = 278;
    t2.semicolon = 278;
    t2.less = 584;
    t2.equal = 584;
    t2.greater = 584;
    t2.question = 556;
    t2.at = 1015;
    t2.A = 667;
    t2.B = 667;
    t2.C = 722;
    t2.D = 722;
    t2.E = 667;
    t2.F = 611;
    t2.G = 778;
    t2.H = 722;
    t2.I = 278;
    t2.J = 500;
    t2.K = 667;
    t2.L = 556;
    t2.M = 833;
    t2.N = 722;
    t2.O = 778;
    t2.P = 667;
    t2.Q = 778;
    t2.R = 722;
    t2.S = 667;
    t2.T = 611;
    t2.U = 722;
    t2.V = 667;
    t2.W = 944;
    t2.X = 667;
    t2.Y = 667;
    t2.Z = 611;
    t2.bracketleft = 278;
    t2.backslash = 278;
    t2.bracketright = 278;
    t2.asciicircum = 469;
    t2.underscore = 556;
    t2.quoteleft = 222;
    t2.a = 556;
    t2.b = 556;
    t2.c = 500;
    t2.d = 556;
    t2.e = 556;
    t2.f = 278;
    t2.g = 556;
    t2.h = 556;
    t2.i = 222;
    t2.j = 222;
    t2.k = 500;
    t2.l = 222;
    t2.m = 833;
    t2.n = 556;
    t2.o = 556;
    t2.p = 556;
    t2.q = 556;
    t2.r = 333;
    t2.s = 500;
    t2.t = 278;
    t2.u = 556;
    t2.v = 500;
    t2.w = 722;
    t2.x = 500;
    t2.y = 500;
    t2.z = 500;
    t2.braceleft = 334;
    t2.bar = 260;
    t2.braceright = 334;
    t2.asciitilde = 584;
    t2.exclamdown = 333;
    t2.cent = 556;
    t2.sterling = 556;
    t2.fraction = 167;
    t2.yen = 556;
    t2.florin = 556;
    t2.section = 556;
    t2.currency = 556;
    t2.quotesingle = 191;
    t2.quotedblleft = 333;
    t2.guillemotleft = 556;
    t2.guilsinglleft = 333;
    t2.guilsinglright = 333;
    t2.fi = 500;
    t2.fl = 500;
    t2.endash = 556;
    t2.dagger = 556;
    t2.daggerdbl = 556;
    t2.periodcentered = 278;
    t2.paragraph = 537;
    t2.bullet = 350;
    t2.quotesinglbase = 222;
    t2.quotedblbase = 333;
    t2.quotedblright = 333;
    t2.guillemotright = 556;
    t2.ellipsis = 1e3;
    t2.perthousand = 1e3;
    t2.questiondown = 611;
    t2.grave = 333;
    t2.acute = 333;
    t2.circumflex = 333;
    t2.tilde = 333;
    t2.macron = 333;
    t2.breve = 333;
    t2.dotaccent = 333;
    t2.dieresis = 333;
    t2.ring = 333;
    t2.cedilla = 333;
    t2.hungarumlaut = 333;
    t2.ogonek = 333;
    t2.caron = 333;
    t2.emdash = 1e3;
    t2.AE = 1e3;
    t2.ordfeminine = 370;
    t2.Lslash = 556;
    t2.Oslash = 778;
    t2.OE = 1e3;
    t2.ordmasculine = 365;
    t2.ae = 889;
    t2.dotlessi = 278;
    t2.lslash = 222;
    t2.oslash = 611;
    t2.oe = 944;
    t2.germandbls = 611;
    t2.Idieresis = 278;
    t2.eacute = 556;
    t2.abreve = 556;
    t2.uhungarumlaut = 556;
    t2.ecaron = 556;
    t2.Ydieresis = 667;
    t2.divide = 584;
    t2.Yacute = 667;
    t2.Acircumflex = 667;
    t2.aacute = 556;
    t2.Ucircumflex = 722;
    t2.yacute = 500;
    t2.scommaaccent = 500;
    t2.ecircumflex = 556;
    t2.Uring = 722;
    t2.Udieresis = 722;
    t2.aogonek = 556;
    t2.Uacute = 722;
    t2.uogonek = 556;
    t2.Edieresis = 667;
    t2.Dcroat = 722;
    t2.commaaccent = 250;
    t2.copyright = 737;
    t2.Emacron = 667;
    t2.ccaron = 500;
    t2.aring = 556;
    t2.Ncommaaccent = 722;
    t2.lacute = 222;
    t2.agrave = 556;
    t2.Tcommaaccent = 611;
    t2.Cacute = 722;
    t2.atilde = 556;
    t2.Edotaccent = 667;
    t2.scaron = 500;
    t2.scedilla = 500;
    t2.iacute = 278;
    t2.lozenge = 471;
    t2.Rcaron = 722;
    t2.Gcommaaccent = 778;
    t2.ucircumflex = 556;
    t2.acircumflex = 556;
    t2.Amacron = 667;
    t2.rcaron = 333;
    t2.ccedilla = 500;
    t2.Zdotaccent = 611;
    t2.Thorn = 667;
    t2.Omacron = 778;
    t2.Racute = 722;
    t2.Sacute = 667;
    t2.dcaron = 643;
    t2.Umacron = 722;
    t2.uring = 556;
    t2.threesuperior = 333;
    t2.Ograve = 778;
    t2.Agrave = 667;
    t2.Abreve = 667;
    t2.multiply = 584;
    t2.uacute = 556;
    t2.Tcaron = 611;
    t2.partialdiff = 476;
    t2.ydieresis = 500;
    t2.Nacute = 722;
    t2.icircumflex = 278;
    t2.Ecircumflex = 667;
    t2.adieresis = 556;
    t2.edieresis = 556;
    t2.cacute = 500;
    t2.nacute = 556;
    t2.umacron = 556;
    t2.Ncaron = 722;
    t2.Iacute = 278;
    t2.plusminus = 584;
    t2.brokenbar = 260;
    t2.registered = 737;
    t2.Gbreve = 778;
    t2.Idotaccent = 278;
    t2.summation = 600;
    t2.Egrave = 667;
    t2.racute = 333;
    t2.omacron = 556;
    t2.Zacute = 611;
    t2.Zcaron = 611;
    t2.greaterequal = 549;
    t2.Eth = 722;
    t2.Ccedilla = 722;
    t2.lcommaaccent = 222;
    t2.tcaron = 317;
    t2.eogonek = 556;
    t2.Uogonek = 722;
    t2.Aacute = 667;
    t2.Adieresis = 667;
    t2.egrave = 556;
    t2.zacute = 500;
    t2.iogonek = 222;
    t2.Oacute = 778;
    t2.oacute = 556;
    t2.amacron = 556;
    t2.sacute = 500;
    t2.idieresis = 278;
    t2.Ocircumflex = 778;
    t2.Ugrave = 722;
    t2.Delta = 612;
    t2.thorn = 556;
    t2.twosuperior = 333;
    t2.Odieresis = 778;
    t2.mu = 556;
    t2.igrave = 278;
    t2.ohungarumlaut = 556;
    t2.Eogonek = 667;
    t2.dcroat = 556;
    t2.threequarters = 834;
    t2.Scedilla = 667;
    t2.lcaron = 299;
    t2.Kcommaaccent = 667;
    t2.Lacute = 556;
    t2.trademark = 1e3;
    t2.edotaccent = 556;
    t2.Igrave = 278;
    t2.Imacron = 278;
    t2.Lcaron = 556;
    t2.onehalf = 834;
    t2.lessequal = 549;
    t2.ocircumflex = 556;
    t2.ntilde = 556;
    t2.Uhungarumlaut = 722;
    t2.Eacute = 667;
    t2.emacron = 556;
    t2.gbreve = 556;
    t2.onequarter = 834;
    t2.Scaron = 667;
    t2.Scommaaccent = 667;
    t2.Ohungarumlaut = 778;
    t2.degree = 400;
    t2.ograve = 556;
    t2.Ccaron = 722;
    t2.ugrave = 556;
    t2.radical = 453;
    t2.Dcaron = 722;
    t2.rcommaaccent = 333;
    t2.Ntilde = 722;
    t2.otilde = 556;
    t2.Rcommaaccent = 722;
    t2.Lcommaaccent = 556;
    t2.Atilde = 667;
    t2.Aogonek = 667;
    t2.Aring = 667;
    t2.Otilde = 778;
    t2.zdotaccent = 500;
    t2.Ecaron = 667;
    t2.Iogonek = 278;
    t2.kcommaaccent = 500;
    t2.minus = 584;
    t2.Icircumflex = 278;
    t2.ncaron = 556;
    t2.tcommaaccent = 278;
    t2.logicalnot = 584;
    t2.odieresis = 556;
    t2.udieresis = 556;
    t2.notequal = 549;
    t2.gcommaaccent = 556;
    t2.eth = 556;
    t2.zcaron = 500;
    t2.ncommaaccent = 556;
    t2.onesuperior = 333;
    t2.imacron = 278;
    t2.Euro = 556;
  });
  t["Helvetica-Bold"] = getLookupTableFactory(function(t2) {
    t2.space = 278;
    t2.exclam = 333;
    t2.quotedbl = 474;
    t2.numbersign = 556;
    t2.dollar = 556;
    t2.percent = 889;
    t2.ampersand = 722;
    t2.quoteright = 278;
    t2.parenleft = 333;
    t2.parenright = 333;
    t2.asterisk = 389;
    t2.plus = 584;
    t2.comma = 278;
    t2.hyphen = 333;
    t2.period = 278;
    t2.slash = 278;
    t2.zero = 556;
    t2.one = 556;
    t2.two = 556;
    t2.three = 556;
    t2.four = 556;
    t2.five = 556;
    t2.six = 556;
    t2.seven = 556;
    t2.eight = 556;
    t2.nine = 556;
    t2.colon = 333;
    t2.semicolon = 333;
    t2.less = 584;
    t2.equal = 584;
    t2.greater = 584;
    t2.question = 611;
    t2.at = 975;
    t2.A = 722;
    t2.B = 722;
    t2.C = 722;
    t2.D = 722;
    t2.E = 667;
    t2.F = 611;
    t2.G = 778;
    t2.H = 722;
    t2.I = 278;
    t2.J = 556;
    t2.K = 722;
    t2.L = 611;
    t2.M = 833;
    t2.N = 722;
    t2.O = 778;
    t2.P = 667;
    t2.Q = 778;
    t2.R = 722;
    t2.S = 667;
    t2.T = 611;
    t2.U = 722;
    t2.V = 667;
    t2.W = 944;
    t2.X = 667;
    t2.Y = 667;
    t2.Z = 611;
    t2.bracketleft = 333;
    t2.backslash = 278;
    t2.bracketright = 333;
    t2.asciicircum = 584;
    t2.underscore = 556;
    t2.quoteleft = 278;
    t2.a = 556;
    t2.b = 611;
    t2.c = 556;
    t2.d = 611;
    t2.e = 556;
    t2.f = 333;
    t2.g = 611;
    t2.h = 611;
    t2.i = 278;
    t2.j = 278;
    t2.k = 556;
    t2.l = 278;
    t2.m = 889;
    t2.n = 611;
    t2.o = 611;
    t2.p = 611;
    t2.q = 611;
    t2.r = 389;
    t2.s = 556;
    t2.t = 333;
    t2.u = 611;
    t2.v = 556;
    t2.w = 778;
    t2.x = 556;
    t2.y = 556;
    t2.z = 500;
    t2.braceleft = 389;
    t2.bar = 280;
    t2.braceright = 389;
    t2.asciitilde = 584;
    t2.exclamdown = 333;
    t2.cent = 556;
    t2.sterling = 556;
    t2.fraction = 167;
    t2.yen = 556;
    t2.florin = 556;
    t2.section = 556;
    t2.currency = 556;
    t2.quotesingle = 238;
    t2.quotedblleft = 500;
    t2.guillemotleft = 556;
    t2.guilsinglleft = 333;
    t2.guilsinglright = 333;
    t2.fi = 611;
    t2.fl = 611;
    t2.endash = 556;
    t2.dagger = 556;
    t2.daggerdbl = 556;
    t2.periodcentered = 278;
    t2.paragraph = 556;
    t2.bullet = 350;
    t2.quotesinglbase = 278;
    t2.quotedblbase = 500;
    t2.quotedblright = 500;
    t2.guillemotright = 556;
    t2.ellipsis = 1e3;
    t2.perthousand = 1e3;
    t2.questiondown = 611;
    t2.grave = 333;
    t2.acute = 333;
    t2.circumflex = 333;
    t2.tilde = 333;
    t2.macron = 333;
    t2.breve = 333;
    t2.dotaccent = 333;
    t2.dieresis = 333;
    t2.ring = 333;
    t2.cedilla = 333;
    t2.hungarumlaut = 333;
    t2.ogonek = 333;
    t2.caron = 333;
    t2.emdash = 1e3;
    t2.AE = 1e3;
    t2.ordfeminine = 370;
    t2.Lslash = 611;
    t2.Oslash = 778;
    t2.OE = 1e3;
    t2.ordmasculine = 365;
    t2.ae = 889;
    t2.dotlessi = 278;
    t2.lslash = 278;
    t2.oslash = 611;
    t2.oe = 944;
    t2.germandbls = 611;
    t2.Idieresis = 278;
    t2.eacute = 556;
    t2.abreve = 556;
    t2.uhungarumlaut = 611;
    t2.ecaron = 556;
    t2.Ydieresis = 667;
    t2.divide = 584;
    t2.Yacute = 667;
    t2.Acircumflex = 722;
    t2.aacute = 556;
    t2.Ucircumflex = 722;
    t2.yacute = 556;
    t2.scommaaccent = 556;
    t2.ecircumflex = 556;
    t2.Uring = 722;
    t2.Udieresis = 722;
    t2.aogonek = 556;
    t2.Uacute = 722;
    t2.uogonek = 611;
    t2.Edieresis = 667;
    t2.Dcroat = 722;
    t2.commaaccent = 250;
    t2.copyright = 737;
    t2.Emacron = 667;
    t2.ccaron = 556;
    t2.aring = 556;
    t2.Ncommaaccent = 722;
    t2.lacute = 278;
    t2.agrave = 556;
    t2.Tcommaaccent = 611;
    t2.Cacute = 722;
    t2.atilde = 556;
    t2.Edotaccent = 667;
    t2.scaron = 556;
    t2.scedilla = 556;
    t2.iacute = 278;
    t2.lozenge = 494;
    t2.Rcaron = 722;
    t2.Gcommaaccent = 778;
    t2.ucircumflex = 611;
    t2.acircumflex = 556;
    t2.Amacron = 722;
    t2.rcaron = 389;
    t2.ccedilla = 556;
    t2.Zdotaccent = 611;
    t2.Thorn = 667;
    t2.Omacron = 778;
    t2.Racute = 722;
    t2.Sacute = 667;
    t2.dcaron = 743;
    t2.Umacron = 722;
    t2.uring = 611;
    t2.threesuperior = 333;
    t2.Ograve = 778;
    t2.Agrave = 722;
    t2.Abreve = 722;
    t2.multiply = 584;
    t2.uacute = 611;
    t2.Tcaron = 611;
    t2.partialdiff = 494;
    t2.ydieresis = 556;
    t2.Nacute = 722;
    t2.icircumflex = 278;
    t2.Ecircumflex = 667;
    t2.adieresis = 556;
    t2.edieresis = 556;
    t2.cacute = 556;
    t2.nacute = 611;
    t2.umacron = 611;
    t2.Ncaron = 722;
    t2.Iacute = 278;
    t2.plusminus = 584;
    t2.brokenbar = 280;
    t2.registered = 737;
    t2.Gbreve = 778;
    t2.Idotaccent = 278;
    t2.summation = 600;
    t2.Egrave = 667;
    t2.racute = 389;
    t2.omacron = 611;
    t2.Zacute = 611;
    t2.Zcaron = 611;
    t2.greaterequal = 549;
    t2.Eth = 722;
    t2.Ccedilla = 722;
    t2.lcommaaccent = 278;
    t2.tcaron = 389;
    t2.eogonek = 556;
    t2.Uogonek = 722;
    t2.Aacute = 722;
    t2.Adieresis = 722;
    t2.egrave = 556;
    t2.zacute = 500;
    t2.iogonek = 278;
    t2.Oacute = 778;
    t2.oacute = 611;
    t2.amacron = 556;
    t2.sacute = 556;
    t2.idieresis = 278;
    t2.Ocircumflex = 778;
    t2.Ugrave = 722;
    t2.Delta = 612;
    t2.thorn = 611;
    t2.twosuperior = 333;
    t2.Odieresis = 778;
    t2.mu = 611;
    t2.igrave = 278;
    t2.ohungarumlaut = 611;
    t2.Eogonek = 667;
    t2.dcroat = 611;
    t2.threequarters = 834;
    t2.Scedilla = 667;
    t2.lcaron = 400;
    t2.Kcommaaccent = 722;
    t2.Lacute = 611;
    t2.trademark = 1e3;
    t2.edotaccent = 556;
    t2.Igrave = 278;
    t2.Imacron = 278;
    t2.Lcaron = 611;
    t2.onehalf = 834;
    t2.lessequal = 549;
    t2.ocircumflex = 611;
    t2.ntilde = 611;
    t2.Uhungarumlaut = 722;
    t2.Eacute = 667;
    t2.emacron = 556;
    t2.gbreve = 611;
    t2.onequarter = 834;
    t2.Scaron = 667;
    t2.Scommaaccent = 667;
    t2.Ohungarumlaut = 778;
    t2.degree = 400;
    t2.ograve = 611;
    t2.Ccaron = 722;
    t2.ugrave = 611;
    t2.radical = 549;
    t2.Dcaron = 722;
    t2.rcommaaccent = 389;
    t2.Ntilde = 722;
    t2.otilde = 611;
    t2.Rcommaaccent = 722;
    t2.Lcommaaccent = 611;
    t2.Atilde = 722;
    t2.Aogonek = 722;
    t2.Aring = 722;
    t2.Otilde = 778;
    t2.zdotaccent = 500;
    t2.Ecaron = 667;
    t2.Iogonek = 278;
    t2.kcommaaccent = 556;
    t2.minus = 584;
    t2.Icircumflex = 278;
    t2.ncaron = 611;
    t2.tcommaaccent = 333;
    t2.logicalnot = 584;
    t2.odieresis = 611;
    t2.udieresis = 611;
    t2.notequal = 549;
    t2.gcommaaccent = 611;
    t2.eth = 611;
    t2.zcaron = 500;
    t2.ncommaaccent = 611;
    t2.onesuperior = 333;
    t2.imacron = 278;
    t2.Euro = 556;
  });
  t["Helvetica-BoldOblique"] = getLookupTableFactory(function(t2) {
    t2.space = 278;
    t2.exclam = 333;
    t2.quotedbl = 474;
    t2.numbersign = 556;
    t2.dollar = 556;
    t2.percent = 889;
    t2.ampersand = 722;
    t2.quoteright = 278;
    t2.parenleft = 333;
    t2.parenright = 333;
    t2.asterisk = 389;
    t2.plus = 584;
    t2.comma = 278;
    t2.hyphen = 333;
    t2.period = 278;
    t2.slash = 278;
    t2.zero = 556;
    t2.one = 556;
    t2.two = 556;
    t2.three = 556;
    t2.four = 556;
    t2.five = 556;
    t2.six = 556;
    t2.seven = 556;
    t2.eight = 556;
    t2.nine = 556;
    t2.colon = 333;
    t2.semicolon = 333;
    t2.less = 584;
    t2.equal = 584;
    t2.greater = 584;
    t2.question = 611;
    t2.at = 975;
    t2.A = 722;
    t2.B = 722;
    t2.C = 722;
    t2.D = 722;
    t2.E = 667;
    t2.F = 611;
    t2.G = 778;
    t2.H = 722;
    t2.I = 278;
    t2.J = 556;
    t2.K = 722;
    t2.L = 611;
    t2.M = 833;
    t2.N = 722;
    t2.O = 778;
    t2.P = 667;
    t2.Q = 778;
    t2.R = 722;
    t2.S = 667;
    t2.T = 611;
    t2.U = 722;
    t2.V = 667;
    t2.W = 944;
    t2.X = 667;
    t2.Y = 667;
    t2.Z = 611;
    t2.bracketleft = 333;
    t2.backslash = 278;
    t2.bracketright = 333;
    t2.asciicircum = 584;
    t2.underscore = 556;
    t2.quoteleft = 278;
    t2.a = 556;
    t2.b = 611;
    t2.c = 556;
    t2.d = 611;
    t2.e = 556;
    t2.f = 333;
    t2.g = 611;
    t2.h = 611;
    t2.i = 278;
    t2.j = 278;
    t2.k = 556;
    t2.l = 278;
    t2.m = 889;
    t2.n = 611;
    t2.o = 611;
    t2.p = 611;
    t2.q = 611;
    t2.r = 389;
    t2.s = 556;
    t2.t = 333;
    t2.u = 611;
    t2.v = 556;
    t2.w = 778;
    t2.x = 556;
    t2.y = 556;
    t2.z = 500;
    t2.braceleft = 389;
    t2.bar = 280;
    t2.braceright = 389;
    t2.asciitilde = 584;
    t2.exclamdown = 333;
    t2.cent = 556;
    t2.sterling = 556;
    t2.fraction = 167;
    t2.yen = 556;
    t2.florin = 556;
    t2.section = 556;
    t2.currency = 556;
    t2.quotesingle = 238;
    t2.quotedblleft = 500;
    t2.guillemotleft = 556;
    t2.guilsinglleft = 333;
    t2.guilsinglright = 333;
    t2.fi = 611;
    t2.fl = 611;
    t2.endash = 556;
    t2.dagger = 556;
    t2.daggerdbl = 556;
    t2.periodcentered = 278;
    t2.paragraph = 556;
    t2.bullet = 350;
    t2.quotesinglbase = 278;
    t2.quotedblbase = 500;
    t2.quotedblright = 500;
    t2.guillemotright = 556;
    t2.ellipsis = 1e3;
    t2.perthousand = 1e3;
    t2.questiondown = 611;
    t2.grave = 333;
    t2.acute = 333;
    t2.circumflex = 333;
    t2.tilde = 333;
    t2.macron = 333;
    t2.breve = 333;
    t2.dotaccent = 333;
    t2.dieresis = 333;
    t2.ring = 333;
    t2.cedilla = 333;
    t2.hungarumlaut = 333;
    t2.ogonek = 333;
    t2.caron = 333;
    t2.emdash = 1e3;
    t2.AE = 1e3;
    t2.ordfeminine = 370;
    t2.Lslash = 611;
    t2.Oslash = 778;
    t2.OE = 1e3;
    t2.ordmasculine = 365;
    t2.ae = 889;
    t2.dotlessi = 278;
    t2.lslash = 278;
    t2.oslash = 611;
    t2.oe = 944;
    t2.germandbls = 611;
    t2.Idieresis = 278;
    t2.eacute = 556;
    t2.abreve = 556;
    t2.uhungarumlaut = 611;
    t2.ecaron = 556;
    t2.Ydieresis = 667;
    t2.divide = 584;
    t2.Yacute = 667;
    t2.Acircumflex = 722;
    t2.aacute = 556;
    t2.Ucircumflex = 722;
    t2.yacute = 556;
    t2.scommaaccent = 556;
    t2.ecircumflex = 556;
    t2.Uring = 722;
    t2.Udieresis = 722;
    t2.aogonek = 556;
    t2.Uacute = 722;
    t2.uogonek = 611;
    t2.Edieresis = 667;
    t2.Dcroat = 722;
    t2.commaaccent = 250;
    t2.copyright = 737;
    t2.Emacron = 667;
    t2.ccaron = 556;
    t2.aring = 556;
    t2.Ncommaaccent = 722;
    t2.lacute = 278;
    t2.agrave = 556;
    t2.Tcommaaccent = 611;
    t2.Cacute = 722;
    t2.atilde = 556;
    t2.Edotaccent = 667;
    t2.scaron = 556;
    t2.scedilla = 556;
    t2.iacute = 278;
    t2.lozenge = 494;
    t2.Rcaron = 722;
    t2.Gcommaaccent = 778;
    t2.ucircumflex = 611;
    t2.acircumflex = 556;
    t2.Amacron = 722;
    t2.rcaron = 389;
    t2.ccedilla = 556;
    t2.Zdotaccent = 611;
    t2.Thorn = 667;
    t2.Omacron = 778;
    t2.Racute = 722;
    t2.Sacute = 667;
    t2.dcaron = 743;
    t2.Umacron = 722;
    t2.uring = 611;
    t2.threesuperior = 333;
    t2.Ograve = 778;
    t2.Agrave = 722;
    t2.Abreve = 722;
    t2.multiply = 584;
    t2.uacute = 611;
    t2.Tcaron = 611;
    t2.partialdiff = 494;
    t2.ydieresis = 556;
    t2.Nacute = 722;
    t2.icircumflex = 278;
    t2.Ecircumflex = 667;
    t2.adieresis = 556;
    t2.edieresis = 556;
    t2.cacute = 556;
    t2.nacute = 611;
    t2.umacron = 611;
    t2.Ncaron = 722;
    t2.Iacute = 278;
    t2.plusminus = 584;
    t2.brokenbar = 280;
    t2.registered = 737;
    t2.Gbreve = 778;
    t2.Idotaccent = 278;
    t2.summation = 600;
    t2.Egrave = 667;
    t2.racute = 389;
    t2.omacron = 611;
    t2.Zacute = 611;
    t2.Zcaron = 611;
    t2.greaterequal = 549;
    t2.Eth = 722;
    t2.Ccedilla = 722;
    t2.lcommaaccent = 278;
    t2.tcaron = 389;
    t2.eogonek = 556;
    t2.Uogonek = 722;
    t2.Aacute = 722;
    t2.Adieresis = 722;
    t2.egrave = 556;
    t2.zacute = 500;
    t2.iogonek = 278;
    t2.Oacute = 778;
    t2.oacute = 611;
    t2.amacron = 556;
    t2.sacute = 556;
    t2.idieresis = 278;
    t2.Ocircumflex = 778;
    t2.Ugrave = 722;
    t2.Delta = 612;
    t2.thorn = 611;
    t2.twosuperior = 333;
    t2.Odieresis = 778;
    t2.mu = 611;
    t2.igrave = 278;
    t2.ohungarumlaut = 611;
    t2.Eogonek = 667;
    t2.dcroat = 611;
    t2.threequarters = 834;
    t2.Scedilla = 667;
    t2.lcaron = 400;
    t2.Kcommaaccent = 722;
    t2.Lacute = 611;
    t2.trademark = 1e3;
    t2.edotaccent = 556;
    t2.Igrave = 278;
    t2.Imacron = 278;
    t2.Lcaron = 611;
    t2.onehalf = 834;
    t2.lessequal = 549;
    t2.ocircumflex = 611;
    t2.ntilde = 611;
    t2.Uhungarumlaut = 722;
    t2.Eacute = 667;
    t2.emacron = 556;
    t2.gbreve = 611;
    t2.onequarter = 834;
    t2.Scaron = 667;
    t2.Scommaaccent = 667;
    t2.Ohungarumlaut = 778;
    t2.degree = 400;
    t2.ograve = 611;
    t2.Ccaron = 722;
    t2.ugrave = 611;
    t2.radical = 549;
    t2.Dcaron = 722;
    t2.rcommaaccent = 389;
    t2.Ntilde = 722;
    t2.otilde = 611;
    t2.Rcommaaccent = 722;
    t2.Lcommaaccent = 611;
    t2.Atilde = 722;
    t2.Aogonek = 722;
    t2.Aring = 722;
    t2.Otilde = 778;
    t2.zdotaccent = 500;
    t2.Ecaron = 667;
    t2.Iogonek = 278;
    t2.kcommaaccent = 556;
    t2.minus = 584;
    t2.Icircumflex = 278;
    t2.ncaron = 611;
    t2.tcommaaccent = 333;
    t2.logicalnot = 584;
    t2.odieresis = 611;
    t2.udieresis = 611;
    t2.notequal = 549;
    t2.gcommaaccent = 611;
    t2.eth = 611;
    t2.zcaron = 500;
    t2.ncommaaccent = 611;
    t2.onesuperior = 333;
    t2.imacron = 278;
    t2.Euro = 556;
  });
  t["Helvetica-Oblique"] = getLookupTableFactory(function(t2) {
    t2.space = 278;
    t2.exclam = 278;
    t2.quotedbl = 355;
    t2.numbersign = 556;
    t2.dollar = 556;
    t2.percent = 889;
    t2.ampersand = 667;
    t2.quoteright = 222;
    t2.parenleft = 333;
    t2.parenright = 333;
    t2.asterisk = 389;
    t2.plus = 584;
    t2.comma = 278;
    t2.hyphen = 333;
    t2.period = 278;
    t2.slash = 278;
    t2.zero = 556;
    t2.one = 556;
    t2.two = 556;
    t2.three = 556;
    t2.four = 556;
    t2.five = 556;
    t2.six = 556;
    t2.seven = 556;
    t2.eight = 556;
    t2.nine = 556;
    t2.colon = 278;
    t2.semicolon = 278;
    t2.less = 584;
    t2.equal = 584;
    t2.greater = 584;
    t2.question = 556;
    t2.at = 1015;
    t2.A = 667;
    t2.B = 667;
    t2.C = 722;
    t2.D = 722;
    t2.E = 667;
    t2.F = 611;
    t2.G = 778;
    t2.H = 722;
    t2.I = 278;
    t2.J = 500;
    t2.K = 667;
    t2.L = 556;
    t2.M = 833;
    t2.N = 722;
    t2.O = 778;
    t2.P = 667;
    t2.Q = 778;
    t2.R = 722;
    t2.S = 667;
    t2.T = 611;
    t2.U = 722;
    t2.V = 667;
    t2.W = 944;
    t2.X = 667;
    t2.Y = 667;
    t2.Z = 611;
    t2.bracketleft = 278;
    t2.backslash = 278;
    t2.bracketright = 278;
    t2.asciicircum = 469;
    t2.underscore = 556;
    t2.quoteleft = 222;
    t2.a = 556;
    t2.b = 556;
    t2.c = 500;
    t2.d = 556;
    t2.e = 556;
    t2.f = 278;
    t2.g = 556;
    t2.h = 556;
    t2.i = 222;
    t2.j = 222;
    t2.k = 500;
    t2.l = 222;
    t2.m = 833;
    t2.n = 556;
    t2.o = 556;
    t2.p = 556;
    t2.q = 556;
    t2.r = 333;
    t2.s = 500;
    t2.t = 278;
    t2.u = 556;
    t2.v = 500;
    t2.w = 722;
    t2.x = 500;
    t2.y = 500;
    t2.z = 500;
    t2.braceleft = 334;
    t2.bar = 260;
    t2.braceright = 334;
    t2.asciitilde = 584;
    t2.exclamdown = 333;
    t2.cent = 556;
    t2.sterling = 556;
    t2.fraction = 167;
    t2.yen = 556;
    t2.florin = 556;
    t2.section = 556;
    t2.currency = 556;
    t2.quotesingle = 191;
    t2.quotedblleft = 333;
    t2.guillemotleft = 556;
    t2.guilsinglleft = 333;
    t2.guilsinglright = 333;
    t2.fi = 500;
    t2.fl = 500;
    t2.endash = 556;
    t2.dagger = 556;
    t2.daggerdbl = 556;
    t2.periodcentered = 278;
    t2.paragraph = 537;
    t2.bullet = 350;
    t2.quotesinglbase = 222;
    t2.quotedblbase = 333;
    t2.quotedblright = 333;
    t2.guillemotright = 556;
    t2.ellipsis = 1e3;
    t2.perthousand = 1e3;
    t2.questiondown = 611;
    t2.grave = 333;
    t2.acute = 333;
    t2.circumflex = 333;
    t2.tilde = 333;
    t2.macron = 333;
    t2.breve = 333;
    t2.dotaccent = 333;
    t2.dieresis = 333;
    t2.ring = 333;
    t2.cedilla = 333;
    t2.hungarumlaut = 333;
    t2.ogonek = 333;
    t2.caron = 333;
    t2.emdash = 1e3;
    t2.AE = 1e3;
    t2.ordfeminine = 370;
    t2.Lslash = 556;
    t2.Oslash = 778;
    t2.OE = 1e3;
    t2.ordmasculine = 365;
    t2.ae = 889;
    t2.dotlessi = 278;
    t2.lslash = 222;
    t2.oslash = 611;
    t2.oe = 944;
    t2.germandbls = 611;
    t2.Idieresis = 278;
    t2.eacute = 556;
    t2.abreve = 556;
    t2.uhungarumlaut = 556;
    t2.ecaron = 556;
    t2.Ydieresis = 667;
    t2.divide = 584;
    t2.Yacute = 667;
    t2.Acircumflex = 667;
    t2.aacute = 556;
    t2.Ucircumflex = 722;
    t2.yacute = 500;
    t2.scommaaccent = 500;
    t2.ecircumflex = 556;
    t2.Uring = 722;
    t2.Udieresis = 722;
    t2.aogonek = 556;
    t2.Uacute = 722;
    t2.uogonek = 556;
    t2.Edieresis = 667;
    t2.Dcroat = 722;
    t2.commaaccent = 250;
    t2.copyright = 737;
    t2.Emacron = 667;
    t2.ccaron = 500;
    t2.aring = 556;
    t2.Ncommaaccent = 722;
    t2.lacute = 222;
    t2.agrave = 556;
    t2.Tcommaaccent = 611;
    t2.Cacute = 722;
    t2.atilde = 556;
    t2.Edotaccent = 667;
    t2.scaron = 500;
    t2.scedilla = 500;
    t2.iacute = 278;
    t2.lozenge = 471;
    t2.Rcaron = 722;
    t2.Gcommaaccent = 778;
    t2.ucircumflex = 556;
    t2.acircumflex = 556;
    t2.Amacron = 667;
    t2.rcaron = 333;
    t2.ccedilla = 500;
    t2.Zdotaccent = 611;
    t2.Thorn = 667;
    t2.Omacron = 778;
    t2.Racute = 722;
    t2.Sacute = 667;
    t2.dcaron = 643;
    t2.Umacron = 722;
    t2.uring = 556;
    t2.threesuperior = 333;
    t2.Ograve = 778;
    t2.Agrave = 667;
    t2.Abreve = 667;
    t2.multiply = 584;
    t2.uacute = 556;
    t2.Tcaron = 611;
    t2.partialdiff = 476;
    t2.ydieresis = 500;
    t2.Nacute = 722;
    t2.icircumflex = 278;
    t2.Ecircumflex = 667;
    t2.adieresis = 556;
    t2.edieresis = 556;
    t2.cacute = 500;
    t2.nacute = 556;
    t2.umacron = 556;
    t2.Ncaron = 722;
    t2.Iacute = 278;
    t2.plusminus = 584;
    t2.brokenbar = 260;
    t2.registered = 737;
    t2.Gbreve = 778;
    t2.Idotaccent = 278;
    t2.summation = 600;
    t2.Egrave = 667;
    t2.racute = 333;
    t2.omacron = 556;
    t2.Zacute = 611;
    t2.Zcaron = 611;
    t2.greaterequal = 549;
    t2.Eth = 722;
    t2.Ccedilla = 722;
    t2.lcommaaccent = 222;
    t2.tcaron = 317;
    t2.eogonek = 556;
    t2.Uogonek = 722;
    t2.Aacute = 667;
    t2.Adieresis = 667;
    t2.egrave = 556;
    t2.zacute = 500;
    t2.iogonek = 222;
    t2.Oacute = 778;
    t2.oacute = 556;
    t2.amacron = 556;
    t2.sacute = 500;
    t2.idieresis = 278;
    t2.Ocircumflex = 778;
    t2.Ugrave = 722;
    t2.Delta = 612;
    t2.thorn = 556;
    t2.twosuperior = 333;
    t2.Odieresis = 778;
    t2.mu = 556;
    t2.igrave = 278;
    t2.ohungarumlaut = 556;
    t2.Eogonek = 667;
    t2.dcroat = 556;
    t2.threequarters = 834;
    t2.Scedilla = 667;
    t2.lcaron = 299;
    t2.Kcommaaccent = 667;
    t2.Lacute = 556;
    t2.trademark = 1e3;
    t2.edotaccent = 556;
    t2.Igrave = 278;
    t2.Imacron = 278;
    t2.Lcaron = 556;
    t2.onehalf = 834;
    t2.lessequal = 549;
    t2.ocircumflex = 556;
    t2.ntilde = 556;
    t2.Uhungarumlaut = 722;
    t2.Eacute = 667;
    t2.emacron = 556;
    t2.gbreve = 556;
    t2.onequarter = 834;
    t2.Scaron = 667;
    t2.Scommaaccent = 667;
    t2.Ohungarumlaut = 778;
    t2.degree = 400;
    t2.ograve = 556;
    t2.Ccaron = 722;
    t2.ugrave = 556;
    t2.radical = 453;
    t2.Dcaron = 722;
    t2.rcommaaccent = 333;
    t2.Ntilde = 722;
    t2.otilde = 556;
    t2.Rcommaaccent = 722;
    t2.Lcommaaccent = 556;
    t2.Atilde = 667;
    t2.Aogonek = 667;
    t2.Aring = 667;
    t2.Otilde = 778;
    t2.zdotaccent = 500;
    t2.Ecaron = 667;
    t2.Iogonek = 278;
    t2.kcommaaccent = 500;
    t2.minus = 584;
    t2.Icircumflex = 278;
    t2.ncaron = 556;
    t2.tcommaaccent = 278;
    t2.logicalnot = 584;
    t2.odieresis = 556;
    t2.udieresis = 556;
    t2.notequal = 549;
    t2.gcommaaccent = 556;
    t2.eth = 556;
    t2.zcaron = 500;
    t2.ncommaaccent = 556;
    t2.onesuperior = 333;
    t2.imacron = 278;
    t2.Euro = 556;
  });
  t.Symbol = getLookupTableFactory(function(t2) {
    t2.space = 250;
    t2.exclam = 333;
    t2.universal = 713;
    t2.numbersign = 500;
    t2.existential = 549;
    t2.percent = 833;
    t2.ampersand = 778;
    t2.suchthat = 439;
    t2.parenleft = 333;
    t2.parenright = 333;
    t2.asteriskmath = 500;
    t2.plus = 549;
    t2.comma = 250;
    t2.minus = 549;
    t2.period = 250;
    t2.slash = 278;
    t2.zero = 500;
    t2.one = 500;
    t2.two = 500;
    t2.three = 500;
    t2.four = 500;
    t2.five = 500;
    t2.six = 500;
    t2.seven = 500;
    t2.eight = 500;
    t2.nine = 500;
    t2.colon = 278;
    t2.semicolon = 278;
    t2.less = 549;
    t2.equal = 549;
    t2.greater = 549;
    t2.question = 444;
    t2.congruent = 549;
    t2.Alpha = 722;
    t2.Beta = 667;
    t2.Chi = 722;
    t2.Delta = 612;
    t2.Epsilon = 611;
    t2.Phi = 763;
    t2.Gamma = 603;
    t2.Eta = 722;
    t2.Iota = 333;
    t2.theta1 = 631;
    t2.Kappa = 722;
    t2.Lambda = 686;
    t2.Mu = 889;
    t2.Nu = 722;
    t2.Omicron = 722;
    t2.Pi = 768;
    t2.Theta = 741;
    t2.Rho = 556;
    t2.Sigma = 592;
    t2.Tau = 611;
    t2.Upsilon = 690;
    t2.sigma1 = 439;
    t2.Omega = 768;
    t2.Xi = 645;
    t2.Psi = 795;
    t2.Zeta = 611;
    t2.bracketleft = 333;
    t2.therefore = 863;
    t2.bracketright = 333;
    t2.perpendicular = 658;
    t2.underscore = 500;
    t2.radicalex = 500;
    t2.alpha = 631;
    t2.beta = 549;
    t2.chi = 549;
    t2.delta = 494;
    t2.epsilon = 439;
    t2.phi = 521;
    t2.gamma = 411;
    t2.eta = 603;
    t2.iota = 329;
    t2.phi1 = 603;
    t2.kappa = 549;
    t2.lambda = 549;
    t2.mu = 576;
    t2.nu = 521;
    t2.omicron = 549;
    t2.pi = 549;
    t2.theta = 521;
    t2.rho = 549;
    t2.sigma = 603;
    t2.tau = 439;
    t2.upsilon = 576;
    t2.omega1 = 713;
    t2.omega = 686;
    t2.xi = 493;
    t2.psi = 686;
    t2.zeta = 494;
    t2.braceleft = 480;
    t2.bar = 200;
    t2.braceright = 480;
    t2.similar = 549;
    t2.Euro = 750;
    t2.Upsilon1 = 620;
    t2.minute = 247;
    t2.lessequal = 549;
    t2.fraction = 167;
    t2.infinity = 713;
    t2.florin = 500;
    t2.club = 753;
    t2.diamond = 753;
    t2.heart = 753;
    t2.spade = 753;
    t2.arrowboth = 1042;
    t2.arrowleft = 987;
    t2.arrowup = 603;
    t2.arrowright = 987;
    t2.arrowdown = 603;
    t2.degree = 400;
    t2.plusminus = 549;
    t2.second = 411;
    t2.greaterequal = 549;
    t2.multiply = 549;
    t2.proportional = 713;
    t2.partialdiff = 494;
    t2.bullet = 460;
    t2.divide = 549;
    t2.notequal = 549;
    t2.equivalence = 549;
    t2.approxequal = 549;
    t2.ellipsis = 1e3;
    t2.arrowvertex = 603;
    t2.arrowhorizex = 1e3;
    t2.carriagereturn = 658;
    t2.aleph = 823;
    t2.Ifraktur = 686;
    t2.Rfraktur = 795;
    t2.weierstrass = 987;
    t2.circlemultiply = 768;
    t2.circleplus = 768;
    t2.emptyset = 823;
    t2.intersection = 768;
    t2.union = 768;
    t2.propersuperset = 713;
    t2.reflexsuperset = 713;
    t2.notsubset = 713;
    t2.propersubset = 713;
    t2.reflexsubset = 713;
    t2.element = 713;
    t2.notelement = 713;
    t2.angle = 768;
    t2.gradient = 713;
    t2.registerserif = 790;
    t2.copyrightserif = 790;
    t2.trademarkserif = 890;
    t2.product = 823;
    t2.radical = 549;
    t2.dotmath = 250;
    t2.logicalnot = 713;
    t2.logicaland = 603;
    t2.logicalor = 603;
    t2.arrowdblboth = 1042;
    t2.arrowdblleft = 987;
    t2.arrowdblup = 603;
    t2.arrowdblright = 987;
    t2.arrowdbldown = 603;
    t2.lozenge = 494;
    t2.angleleft = 329;
    t2.registersans = 790;
    t2.copyrightsans = 790;
    t2.trademarksans = 786;
    t2.summation = 713;
    t2.parenlefttp = 384;
    t2.parenleftex = 384;
    t2.parenleftbt = 384;
    t2.bracketlefttp = 384;
    t2.bracketleftex = 384;
    t2.bracketleftbt = 384;
    t2.bracelefttp = 494;
    t2.braceleftmid = 494;
    t2.braceleftbt = 494;
    t2.braceex = 494;
    t2.angleright = 329;
    t2.integral = 274;
    t2.integraltp = 686;
    t2.integralex = 686;
    t2.integralbt = 686;
    t2.parenrighttp = 384;
    t2.parenrightex = 384;
    t2.parenrightbt = 384;
    t2.bracketrighttp = 384;
    t2.bracketrightex = 384;
    t2.bracketrightbt = 384;
    t2.bracerighttp = 494;
    t2.bracerightmid = 494;
    t2.bracerightbt = 494;
    t2.apple = 790;
  });
  t["Times-Roman"] = getLookupTableFactory(function(t2) {
    t2.space = 250;
    t2.exclam = 333;
    t2.quotedbl = 408;
    t2.numbersign = 500;
    t2.dollar = 500;
    t2.percent = 833;
    t2.ampersand = 778;
    t2.quoteright = 333;
    t2.parenleft = 333;
    t2.parenright = 333;
    t2.asterisk = 500;
    t2.plus = 564;
    t2.comma = 250;
    t2.hyphen = 333;
    t2.period = 250;
    t2.slash = 278;
    t2.zero = 500;
    t2.one = 500;
    t2.two = 500;
    t2.three = 500;
    t2.four = 500;
    t2.five = 500;
    t2.six = 500;
    t2.seven = 500;
    t2.eight = 500;
    t2.nine = 500;
    t2.colon = 278;
    t2.semicolon = 278;
    t2.less = 564;
    t2.equal = 564;
    t2.greater = 564;
    t2.question = 444;
    t2.at = 921;
    t2.A = 722;
    t2.B = 667;
    t2.C = 667;
    t2.D = 722;
    t2.E = 611;
    t2.F = 556;
    t2.G = 722;
    t2.H = 722;
    t2.I = 333;
    t2.J = 389;
    t2.K = 722;
    t2.L = 611;
    t2.M = 889;
    t2.N = 722;
    t2.O = 722;
    t2.P = 556;
    t2.Q = 722;
    t2.R = 667;
    t2.S = 556;
    t2.T = 611;
    t2.U = 722;
    t2.V = 722;
    t2.W = 944;
    t2.X = 722;
    t2.Y = 722;
    t2.Z = 611;
    t2.bracketleft = 333;
    t2.backslash = 278;
    t2.bracketright = 333;
    t2.asciicircum = 469;
    t2.underscore = 500;
    t2.quoteleft = 333;
    t2.a = 444;
    t2.b = 500;
    t2.c = 444;
    t2.d = 500;
    t2.e = 444;
    t2.f = 333;
    t2.g = 500;
    t2.h = 500;
    t2.i = 278;
    t2.j = 278;
    t2.k = 500;
    t2.l = 278;
    t2.m = 778;
    t2.n = 500;
    t2.o = 500;
    t2.p = 500;
    t2.q = 500;
    t2.r = 333;
    t2.s = 389;
    t2.t = 278;
    t2.u = 500;
    t2.v = 500;
    t2.w = 722;
    t2.x = 500;
    t2.y = 500;
    t2.z = 444;
    t2.braceleft = 480;
    t2.bar = 200;
    t2.braceright = 480;
    t2.asciitilde = 541;
    t2.exclamdown = 333;
    t2.cent = 500;
    t2.sterling = 500;
    t2.fraction = 167;
    t2.yen = 500;
    t2.florin = 500;
    t2.section = 500;
    t2.currency = 500;
    t2.quotesingle = 180;
    t2.quotedblleft = 444;
    t2.guillemotleft = 500;
    t2.guilsinglleft = 333;
    t2.guilsinglright = 333;
    t2.fi = 556;
    t2.fl = 556;
    t2.endash = 500;
    t2.dagger = 500;
    t2.daggerdbl = 500;
    t2.periodcentered = 250;
    t2.paragraph = 453;
    t2.bullet = 350;
    t2.quotesinglbase = 333;
    t2.quotedblbase = 444;
    t2.quotedblright = 444;
    t2.guillemotright = 500;
    t2.ellipsis = 1e3;
    t2.perthousand = 1e3;
    t2.questiondown = 444;
    t2.grave = 333;
    t2.acute = 333;
    t2.circumflex = 333;
    t2.tilde = 333;
    t2.macron = 333;
    t2.breve = 333;
    t2.dotaccent = 333;
    t2.dieresis = 333;
    t2.ring = 333;
    t2.cedilla = 333;
    t2.hungarumlaut = 333;
    t2.ogonek = 333;
    t2.caron = 333;
    t2.emdash = 1e3;
    t2.AE = 889;
    t2.ordfeminine = 276;
    t2.Lslash = 611;
    t2.Oslash = 722;
    t2.OE = 889;
    t2.ordmasculine = 310;
    t2.ae = 667;
    t2.dotlessi = 278;
    t2.lslash = 278;
    t2.oslash = 500;
    t2.oe = 722;
    t2.germandbls = 500;
    t2.Idieresis = 333;
    t2.eacute = 444;
    t2.abreve = 444;
    t2.uhungarumlaut = 500;
    t2.ecaron = 444;
    t2.Ydieresis = 722;
    t2.divide = 564;
    t2.Yacute = 722;
    t2.Acircumflex = 722;
    t2.aacute = 444;
    t2.Ucircumflex = 722;
    t2.yacute = 500;
    t2.scommaaccent = 389;
    t2.ecircumflex = 444;
    t2.Uring = 722;
    t2.Udieresis = 722;
    t2.aogonek = 444;
    t2.Uacute = 722;
    t2.uogonek = 500;
    t2.Edieresis = 611;
    t2.Dcroat = 722;
    t2.commaaccent = 250;
    t2.copyright = 760;
    t2.Emacron = 611;
    t2.ccaron = 444;
    t2.aring = 444;
    t2.Ncommaaccent = 722;
    t2.lacute = 278;
    t2.agrave = 444;
    t2.Tcommaaccent = 611;
    t2.Cacute = 667;
    t2.atilde = 444;
    t2.Edotaccent = 611;
    t2.scaron = 389;
    t2.scedilla = 389;
    t2.iacute = 278;
    t2.lozenge = 471;
    t2.Rcaron = 667;
    t2.Gcommaaccent = 722;
    t2.ucircumflex = 500;
    t2.acircumflex = 444;
    t2.Amacron = 722;
    t2.rcaron = 333;
    t2.ccedilla = 444;
    t2.Zdotaccent = 611;
    t2.Thorn = 556;
    t2.Omacron = 722;
    t2.Racute = 667;
    t2.Sacute = 556;
    t2.dcaron = 588;
    t2.Umacron = 722;
    t2.uring = 500;
    t2.threesuperior = 300;
    t2.Ograve = 722;
    t2.Agrave = 722;
    t2.Abreve = 722;
    t2.multiply = 564;
    t2.uacute = 500;
    t2.Tcaron = 611;
    t2.partialdiff = 476;
    t2.ydieresis = 500;
    t2.Nacute = 722;
    t2.icircumflex = 278;
    t2.Ecircumflex = 611;
    t2.adieresis = 444;
    t2.edieresis = 444;
    t2.cacute = 444;
    t2.nacute = 500;
    t2.umacron = 500;
    t2.Ncaron = 722;
    t2.Iacute = 333;
    t2.plusminus = 564;
    t2.brokenbar = 200;
    t2.registered = 760;
    t2.Gbreve = 722;
    t2.Idotaccent = 333;
    t2.summation = 600;
    t2.Egrave = 611;
    t2.racute = 333;
    t2.omacron = 500;
    t2.Zacute = 611;
    t2.Zcaron = 611;
    t2.greaterequal = 549;
    t2.Eth = 722;
    t2.Ccedilla = 667;
    t2.lcommaaccent = 278;
    t2.tcaron = 326;
    t2.eogonek = 444;
    t2.Uogonek = 722;
    t2.Aacute = 722;
    t2.Adieresis = 722;
    t2.egrave = 444;
    t2.zacute = 444;
    t2.iogonek = 278;
    t2.Oacute = 722;
    t2.oacute = 500;
    t2.amacron = 444;
    t2.sacute = 389;
    t2.idieresis = 278;
    t2.Ocircumflex = 722;
    t2.Ugrave = 722;
    t2.Delta = 612;
    t2.thorn = 500;
    t2.twosuperior = 300;
    t2.Odieresis = 722;
    t2.mu = 500;
    t2.igrave = 278;
    t2.ohungarumlaut = 500;
    t2.Eogonek = 611;
    t2.dcroat = 500;
    t2.threequarters = 750;
    t2.Scedilla = 556;
    t2.lcaron = 344;
    t2.Kcommaaccent = 722;
    t2.Lacute = 611;
    t2.trademark = 980;
    t2.edotaccent = 444;
    t2.Igrave = 333;
    t2.Imacron = 333;
    t2.Lcaron = 611;
    t2.onehalf = 750;
    t2.lessequal = 549;
    t2.ocircumflex = 500;
    t2.ntilde = 500;
    t2.Uhungarumlaut = 722;
    t2.Eacute = 611;
    t2.emacron = 444;
    t2.gbreve = 500;
    t2.onequarter = 750;
    t2.Scaron = 556;
    t2.Scommaaccent = 556;
    t2.Ohungarumlaut = 722;
    t2.degree = 400;
    t2.ograve = 500;
    t2.Ccaron = 667;
    t2.ugrave = 500;
    t2.radical = 453;
    t2.Dcaron = 722;
    t2.rcommaaccent = 333;
    t2.Ntilde = 722;
    t2.otilde = 500;
    t2.Rcommaaccent = 667;
    t2.Lcommaaccent = 611;
    t2.Atilde = 722;
    t2.Aogonek = 722;
    t2.Aring = 722;
    t2.Otilde = 722;
    t2.zdotaccent = 444;
    t2.Ecaron = 611;
    t2.Iogonek = 333;
    t2.kcommaaccent = 500;
    t2.minus = 564;
    t2.Icircumflex = 333;
    t2.ncaron = 500;
    t2.tcommaaccent = 278;
    t2.logicalnot = 564;
    t2.odieresis = 500;
    t2.udieresis = 500;
    t2.notequal = 549;
    t2.gcommaaccent = 500;
    t2.eth = 500;
    t2.zcaron = 444;
    t2.ncommaaccent = 500;
    t2.onesuperior = 300;
    t2.imacron = 278;
    t2.Euro = 500;
  });
  t["Times-Bold"] = getLookupTableFactory(function(t2) {
    t2.space = 250;
    t2.exclam = 333;
    t2.quotedbl = 555;
    t2.numbersign = 500;
    t2.dollar = 500;
    t2.percent = 1e3;
    t2.ampersand = 833;
    t2.quoteright = 333;
    t2.parenleft = 333;
    t2.parenright = 333;
    t2.asterisk = 500;
    t2.plus = 570;
    t2.comma = 250;
    t2.hyphen = 333;
    t2.period = 250;
    t2.slash = 278;
    t2.zero = 500;
    t2.one = 500;
    t2.two = 500;
    t2.three = 500;
    t2.four = 500;
    t2.five = 500;
    t2.six = 500;
    t2.seven = 500;
    t2.eight = 500;
    t2.nine = 500;
    t2.colon = 333;
    t2.semicolon = 333;
    t2.less = 570;
    t2.equal = 570;
    t2.greater = 570;
    t2.question = 500;
    t2.at = 930;
    t2.A = 722;
    t2.B = 667;
    t2.C = 722;
    t2.D = 722;
    t2.E = 667;
    t2.F = 611;
    t2.G = 778;
    t2.H = 778;
    t2.I = 389;
    t2.J = 500;
    t2.K = 778;
    t2.L = 667;
    t2.M = 944;
    t2.N = 722;
    t2.O = 778;
    t2.P = 611;
    t2.Q = 778;
    t2.R = 722;
    t2.S = 556;
    t2.T = 667;
    t2.U = 722;
    t2.V = 722;
    t2.W = 1e3;
    t2.X = 722;
    t2.Y = 722;
    t2.Z = 667;
    t2.bracketleft = 333;
    t2.backslash = 278;
    t2.bracketright = 333;
    t2.asciicircum = 581;
    t2.underscore = 500;
    t2.quoteleft = 333;
    t2.a = 500;
    t2.b = 556;
    t2.c = 444;
    t2.d = 556;
    t2.e = 444;
    t2.f = 333;
    t2.g = 500;
    t2.h = 556;
    t2.i = 278;
    t2.j = 333;
    t2.k = 556;
    t2.l = 278;
    t2.m = 833;
    t2.n = 556;
    t2.o = 500;
    t2.p = 556;
    t2.q = 556;
    t2.r = 444;
    t2.s = 389;
    t2.t = 333;
    t2.u = 556;
    t2.v = 500;
    t2.w = 722;
    t2.x = 500;
    t2.y = 500;
    t2.z = 444;
    t2.braceleft = 394;
    t2.bar = 220;
    t2.braceright = 394;
    t2.asciitilde = 520;
    t2.exclamdown = 333;
    t2.cent = 500;
    t2.sterling = 500;
    t2.fraction = 167;
    t2.yen = 500;
    t2.florin = 500;
    t2.section = 500;
    t2.currency = 500;
    t2.quotesingle = 278;
    t2.quotedblleft = 500;
    t2.guillemotleft = 500;
    t2.guilsinglleft = 333;
    t2.guilsinglright = 333;
    t2.fi = 556;
    t2.fl = 556;
    t2.endash = 500;
    t2.dagger = 500;
    t2.daggerdbl = 500;
    t2.periodcentered = 250;
    t2.paragraph = 540;
    t2.bullet = 350;
    t2.quotesinglbase = 333;
    t2.quotedblbase = 500;
    t2.quotedblright = 500;
    t2.guillemotright = 500;
    t2.ellipsis = 1e3;
    t2.perthousand = 1e3;
    t2.questiondown = 500;
    t2.grave = 333;
    t2.acute = 333;
    t2.circumflex = 333;
    t2.tilde = 333;
    t2.macron = 333;
    t2.breve = 333;
    t2.dotaccent = 333;
    t2.dieresis = 333;
    t2.ring = 333;
    t2.cedilla = 333;
    t2.hungarumlaut = 333;
    t2.ogonek = 333;
    t2.caron = 333;
    t2.emdash = 1e3;
    t2.AE = 1e3;
    t2.ordfeminine = 300;
    t2.Lslash = 667;
    t2.Oslash = 778;
    t2.OE = 1e3;
    t2.ordmasculine = 330;
    t2.ae = 722;
    t2.dotlessi = 278;
    t2.lslash = 278;
    t2.oslash = 500;
    t2.oe = 722;
    t2.germandbls = 556;
    t2.Idieresis = 389;
    t2.eacute = 444;
    t2.abreve = 500;
    t2.uhungarumlaut = 556;
    t2.ecaron = 444;
    t2.Ydieresis = 722;
    t2.divide = 570;
    t2.Yacute = 722;
    t2.Acircumflex = 722;
    t2.aacute = 500;
    t2.Ucircumflex = 722;
    t2.yacute = 500;
    t2.scommaaccent = 389;
    t2.ecircumflex = 444;
    t2.Uring = 722;
    t2.Udieresis = 722;
    t2.aogonek = 500;
    t2.Uacute = 722;
    t2.uogonek = 556;
    t2.Edieresis = 667;
    t2.Dcroat = 722;
    t2.commaaccent = 250;
    t2.copyright = 747;
    t2.Emacron = 667;
    t2.ccaron = 444;
    t2.aring = 500;
    t2.Ncommaaccent = 722;
    t2.lacute = 278;
    t2.agrave = 500;
    t2.Tcommaaccent = 667;
    t2.Cacute = 722;
    t2.atilde = 500;
    t2.Edotaccent = 667;
    t2.scaron = 389;
    t2.scedilla = 389;
    t2.iacute = 278;
    t2.lozenge = 494;
    t2.Rcaron = 722;
    t2.Gcommaaccent = 778;
    t2.ucircumflex = 556;
    t2.acircumflex = 500;
    t2.Amacron = 722;
    t2.rcaron = 444;
    t2.ccedilla = 444;
    t2.Zdotaccent = 667;
    t2.Thorn = 611;
    t2.Omacron = 778;
    t2.Racute = 722;
    t2.Sacute = 556;
    t2.dcaron = 672;
    t2.Umacron = 722;
    t2.uring = 556;
    t2.threesuperior = 300;
    t2.Ograve = 778;
    t2.Agrave = 722;
    t2.Abreve = 722;
    t2.multiply = 570;
    t2.uacute = 556;
    t2.Tcaron = 667;
    t2.partialdiff = 494;
    t2.ydieresis = 500;
    t2.Nacute = 722;
    t2.icircumflex = 278;
    t2.Ecircumflex = 667;
    t2.adieresis = 500;
    t2.edieresis = 444;
    t2.cacute = 444;
    t2.nacute = 556;
    t2.umacron = 556;
    t2.Ncaron = 722;
    t2.Iacute = 389;
    t2.plusminus = 570;
    t2.brokenbar = 220;
    t2.registered = 747;
    t2.Gbreve = 778;
    t2.Idotaccent = 389;
    t2.summation = 600;
    t2.Egrave = 667;
    t2.racute = 444;
    t2.omacron = 500;
    t2.Zacute = 667;
    t2.Zcaron = 667;
    t2.greaterequal = 549;
    t2.Eth = 722;
    t2.Ccedilla = 722;
    t2.lcommaaccent = 278;
    t2.tcaron = 416;
    t2.eogonek = 444;
    t2.Uogonek = 722;
    t2.Aacute = 722;
    t2.Adieresis = 722;
    t2.egrave = 444;
    t2.zacute = 444;
    t2.iogonek = 278;
    t2.Oacute = 778;
    t2.oacute = 500;
    t2.amacron = 500;
    t2.sacute = 389;
    t2.idieresis = 278;
    t2.Ocircumflex = 778;
    t2.Ugrave = 722;
    t2.Delta = 612;
    t2.thorn = 556;
    t2.twosuperior = 300;
    t2.Odieresis = 778;
    t2.mu = 556;
    t2.igrave = 278;
    t2.ohungarumlaut = 500;
    t2.Eogonek = 667;
    t2.dcroat = 556;
    t2.threequarters = 750;
    t2.Scedilla = 556;
    t2.lcaron = 394;
    t2.Kcommaaccent = 778;
    t2.Lacute = 667;
    t2.trademark = 1e3;
    t2.edotaccent = 444;
    t2.Igrave = 389;
    t2.Imacron = 389;
    t2.Lcaron = 667;
    t2.onehalf = 750;
    t2.lessequal = 549;
    t2.ocircumflex = 500;
    t2.ntilde = 556;
    t2.Uhungarumlaut = 722;
    t2.Eacute = 667;
    t2.emacron = 444;
    t2.gbreve = 500;
    t2.onequarter = 750;
    t2.Scaron = 556;
    t2.Scommaaccent = 556;
    t2.Ohungarumlaut = 778;
    t2.degree = 400;
    t2.ograve = 500;
    t2.Ccaron = 722;
    t2.ugrave = 556;
    t2.radical = 549;
    t2.Dcaron = 722;
    t2.rcommaaccent = 444;
    t2.Ntilde = 722;
    t2.otilde = 500;
    t2.Rcommaaccent = 722;
    t2.Lcommaaccent = 667;
    t2.Atilde = 722;
    t2.Aogonek = 722;
    t2.Aring = 722;
    t2.Otilde = 778;
    t2.zdotaccent = 444;
    t2.Ecaron = 667;
    t2.Iogonek = 389;
    t2.kcommaaccent = 556;
    t2.minus = 570;
    t2.Icircumflex = 389;
    t2.ncaron = 556;
    t2.tcommaaccent = 333;
    t2.logicalnot = 570;
    t2.odieresis = 500;
    t2.udieresis = 556;
    t2.notequal = 549;
    t2.gcommaaccent = 500;
    t2.eth = 500;
    t2.zcaron = 444;
    t2.ncommaaccent = 556;
    t2.onesuperior = 300;
    t2.imacron = 278;
    t2.Euro = 500;
  });
  t["Times-BoldItalic"] = getLookupTableFactory(function(t2) {
    t2.space = 250;
    t2.exclam = 389;
    t2.quotedbl = 555;
    t2.numbersign = 500;
    t2.dollar = 500;
    t2.percent = 833;
    t2.ampersand = 778;
    t2.quoteright = 333;
    t2.parenleft = 333;
    t2.parenright = 333;
    t2.asterisk = 500;
    t2.plus = 570;
    t2.comma = 250;
    t2.hyphen = 333;
    t2.period = 250;
    t2.slash = 278;
    t2.zero = 500;
    t2.one = 500;
    t2.two = 500;
    t2.three = 500;
    t2.four = 500;
    t2.five = 500;
    t2.six = 500;
    t2.seven = 500;
    t2.eight = 500;
    t2.nine = 500;
    t2.colon = 333;
    t2.semicolon = 333;
    t2.less = 570;
    t2.equal = 570;
    t2.greater = 570;
    t2.question = 500;
    t2.at = 832;
    t2.A = 667;
    t2.B = 667;
    t2.C = 667;
    t2.D = 722;
    t2.E = 667;
    t2.F = 667;
    t2.G = 722;
    t2.H = 778;
    t2.I = 389;
    t2.J = 500;
    t2.K = 667;
    t2.L = 611;
    t2.M = 889;
    t2.N = 722;
    t2.O = 722;
    t2.P = 611;
    t2.Q = 722;
    t2.R = 667;
    t2.S = 556;
    t2.T = 611;
    t2.U = 722;
    t2.V = 667;
    t2.W = 889;
    t2.X = 667;
    t2.Y = 611;
    t2.Z = 611;
    t2.bracketleft = 333;
    t2.backslash = 278;
    t2.bracketright = 333;
    t2.asciicircum = 570;
    t2.underscore = 500;
    t2.quoteleft = 333;
    t2.a = 500;
    t2.b = 500;
    t2.c = 444;
    t2.d = 500;
    t2.e = 444;
    t2.f = 333;
    t2.g = 500;
    t2.h = 556;
    t2.i = 278;
    t2.j = 278;
    t2.k = 500;
    t2.l = 278;
    t2.m = 778;
    t2.n = 556;
    t2.o = 500;
    t2.p = 500;
    t2.q = 500;
    t2.r = 389;
    t2.s = 389;
    t2.t = 278;
    t2.u = 556;
    t2.v = 444;
    t2.w = 667;
    t2.x = 500;
    t2.y = 444;
    t2.z = 389;
    t2.braceleft = 348;
    t2.bar = 220;
    t2.braceright = 348;
    t2.asciitilde = 570;
    t2.exclamdown = 389;
    t2.cent = 500;
    t2.sterling = 500;
    t2.fraction = 167;
    t2.yen = 500;
    t2.florin = 500;
    t2.section = 500;
    t2.currency = 500;
    t2.quotesingle = 278;
    t2.quotedblleft = 500;
    t2.guillemotleft = 500;
    t2.guilsinglleft = 333;
    t2.guilsinglright = 333;
    t2.fi = 556;
    t2.fl = 556;
    t2.endash = 500;
    t2.dagger = 500;
    t2.daggerdbl = 500;
    t2.periodcentered = 250;
    t2.paragraph = 500;
    t2.bullet = 350;
    t2.quotesinglbase = 333;
    t2.quotedblbase = 500;
    t2.quotedblright = 500;
    t2.guillemotright = 500;
    t2.ellipsis = 1e3;
    t2.perthousand = 1e3;
    t2.questiondown = 500;
    t2.grave = 333;
    t2.acute = 333;
    t2.circumflex = 333;
    t2.tilde = 333;
    t2.macron = 333;
    t2.breve = 333;
    t2.dotaccent = 333;
    t2.dieresis = 333;
    t2.ring = 333;
    t2.cedilla = 333;
    t2.hungarumlaut = 333;
    t2.ogonek = 333;
    t2.caron = 333;
    t2.emdash = 1e3;
    t2.AE = 944;
    t2.ordfeminine = 266;
    t2.Lslash = 611;
    t2.Oslash = 722;
    t2.OE = 944;
    t2.ordmasculine = 300;
    t2.ae = 722;
    t2.dotlessi = 278;
    t2.lslash = 278;
    t2.oslash = 500;
    t2.oe = 722;
    t2.germandbls = 500;
    t2.Idieresis = 389;
    t2.eacute = 444;
    t2.abreve = 500;
    t2.uhungarumlaut = 556;
    t2.ecaron = 444;
    t2.Ydieresis = 611;
    t2.divide = 570;
    t2.Yacute = 611;
    t2.Acircumflex = 667;
    t2.aacute = 500;
    t2.Ucircumflex = 722;
    t2.yacute = 444;
    t2.scommaaccent = 389;
    t2.ecircumflex = 444;
    t2.Uring = 722;
    t2.Udieresis = 722;
    t2.aogonek = 500;
    t2.Uacute = 722;
    t2.uogonek = 556;
    t2.Edieresis = 667;
    t2.Dcroat = 722;
    t2.commaaccent = 250;
    t2.copyright = 747;
    t2.Emacron = 667;
    t2.ccaron = 444;
    t2.aring = 500;
    t2.Ncommaaccent = 722;
    t2.lacute = 278;
    t2.agrave = 500;
    t2.Tcommaaccent = 611;
    t2.Cacute = 667;
    t2.atilde = 500;
    t2.Edotaccent = 667;
    t2.scaron = 389;
    t2.scedilla = 389;
    t2.iacute = 278;
    t2.lozenge = 494;
    t2.Rcaron = 667;
    t2.Gcommaaccent = 722;
    t2.ucircumflex = 556;
    t2.acircumflex = 500;
    t2.Amacron = 667;
    t2.rcaron = 389;
    t2.ccedilla = 444;
    t2.Zdotaccent = 611;
    t2.Thorn = 611;
    t2.Omacron = 722;
    t2.Racute = 667;
    t2.Sacute = 556;
    t2.dcaron = 608;
    t2.Umacron = 722;
    t2.uring = 556;
    t2.threesuperior = 300;
    t2.Ograve = 722;
    t2.Agrave = 667;
    t2.Abreve = 667;
    t2.multiply = 570;
    t2.uacute = 556;
    t2.Tcaron = 611;
    t2.partialdiff = 494;
    t2.ydieresis = 444;
    t2.Nacute = 722;
    t2.icircumflex = 278;
    t2.Ecircumflex = 667;
    t2.adieresis = 500;
    t2.edieresis = 444;
    t2.cacute = 444;
    t2.nacute = 556;
    t2.umacron = 556;
    t2.Ncaron = 722;
    t2.Iacute = 389;
    t2.plusminus = 570;
    t2.brokenbar = 220;
    t2.registered = 747;
    t2.Gbreve = 722;
    t2.Idotaccent = 389;
    t2.summation = 600;
    t2.Egrave = 667;
    t2.racute = 389;
    t2.omacron = 500;
    t2.Zacute = 611;
    t2.Zcaron = 611;
    t2.greaterequal = 549;
    t2.Eth = 722;
    t2.Ccedilla = 667;
    t2.lcommaaccent = 278;
    t2.tcaron = 366;
    t2.eogonek = 444;
    t2.Uogonek = 722;
    t2.Aacute = 667;
    t2.Adieresis = 667;
    t2.egrave = 444;
    t2.zacute = 389;
    t2.iogonek = 278;
    t2.Oacute = 722;
    t2.oacute = 500;
    t2.amacron = 500;
    t2.sacute = 389;
    t2.idieresis = 278;
    t2.Ocircumflex = 722;
    t2.Ugrave = 722;
    t2.Delta = 612;
    t2.thorn = 500;
    t2.twosuperior = 300;
    t2.Odieresis = 722;
    t2.mu = 576;
    t2.igrave = 278;
    t2.ohungarumlaut = 500;
    t2.Eogonek = 667;
    t2.dcroat = 500;
    t2.threequarters = 750;
    t2.Scedilla = 556;
    t2.lcaron = 382;
    t2.Kcommaaccent = 667;
    t2.Lacute = 611;
    t2.trademark = 1e3;
    t2.edotaccent = 444;
    t2.Igrave = 389;
    t2.Imacron = 389;
    t2.Lcaron = 611;
    t2.onehalf = 750;
    t2.lessequal = 549;
    t2.ocircumflex = 500;
    t2.ntilde = 556;
    t2.Uhungarumlaut = 722;
    t2.Eacute = 667;
    t2.emacron = 444;
    t2.gbreve = 500;
    t2.onequarter = 750;
    t2.Scaron = 556;
    t2.Scommaaccent = 556;
    t2.Ohungarumlaut = 722;
    t2.degree = 400;
    t2.ograve = 500;
    t2.Ccaron = 667;
    t2.ugrave = 556;
    t2.radical = 549;
    t2.Dcaron = 722;
    t2.rcommaaccent = 389;
    t2.Ntilde = 722;
    t2.otilde = 500;
    t2.Rcommaaccent = 667;
    t2.Lcommaaccent = 611;
    t2.Atilde = 667;
    t2.Aogonek = 667;
    t2.Aring = 667;
    t2.Otilde = 722;
    t2.zdotaccent = 389;
    t2.Ecaron = 667;
    t2.Iogonek = 389;
    t2.kcommaaccent = 500;
    t2.minus = 606;
    t2.Icircumflex = 389;
    t2.ncaron = 556;
    t2.tcommaaccent = 278;
    t2.logicalnot = 606;
    t2.odieresis = 500;
    t2.udieresis = 556;
    t2.notequal = 549;
    t2.gcommaaccent = 500;
    t2.eth = 500;
    t2.zcaron = 389;
    t2.ncommaaccent = 556;
    t2.onesuperior = 300;
    t2.imacron = 278;
    t2.Euro = 500;
  });
  t["Times-Italic"] = getLookupTableFactory(function(t2) {
    t2.space = 250;
    t2.exclam = 333;
    t2.quotedbl = 420;
    t2.numbersign = 500;
    t2.dollar = 500;
    t2.percent = 833;
    t2.ampersand = 778;
    t2.quoteright = 333;
    t2.parenleft = 333;
    t2.parenright = 333;
    t2.asterisk = 500;
    t2.plus = 675;
    t2.comma = 250;
    t2.hyphen = 333;
    t2.period = 250;
    t2.slash = 278;
    t2.zero = 500;
    t2.one = 500;
    t2.two = 500;
    t2.three = 500;
    t2.four = 500;
    t2.five = 500;
    t2.six = 500;
    t2.seven = 500;
    t2.eight = 500;
    t2.nine = 500;
    t2.colon = 333;
    t2.semicolon = 333;
    t2.less = 675;
    t2.equal = 675;
    t2.greater = 675;
    t2.question = 500;
    t2.at = 920;
    t2.A = 611;
    t2.B = 611;
    t2.C = 667;
    t2.D = 722;
    t2.E = 611;
    t2.F = 611;
    t2.G = 722;
    t2.H = 722;
    t2.I = 333;
    t2.J = 444;
    t2.K = 667;
    t2.L = 556;
    t2.M = 833;
    t2.N = 667;
    t2.O = 722;
    t2.P = 611;
    t2.Q = 722;
    t2.R = 611;
    t2.S = 500;
    t2.T = 556;
    t2.U = 722;
    t2.V = 611;
    t2.W = 833;
    t2.X = 611;
    t2.Y = 556;
    t2.Z = 556;
    t2.bracketleft = 389;
    t2.backslash = 278;
    t2.bracketright = 389;
    t2.asciicircum = 422;
    t2.underscore = 500;
    t2.quoteleft = 333;
    t2.a = 500;
    t2.b = 500;
    t2.c = 444;
    t2.d = 500;
    t2.e = 444;
    t2.f = 278;
    t2.g = 500;
    t2.h = 500;
    t2.i = 278;
    t2.j = 278;
    t2.k = 444;
    t2.l = 278;
    t2.m = 722;
    t2.n = 500;
    t2.o = 500;
    t2.p = 500;
    t2.q = 500;
    t2.r = 389;
    t2.s = 389;
    t2.t = 278;
    t2.u = 500;
    t2.v = 444;
    t2.w = 667;
    t2.x = 444;
    t2.y = 444;
    t2.z = 389;
    t2.braceleft = 400;
    t2.bar = 275;
    t2.braceright = 400;
    t2.asciitilde = 541;
    t2.exclamdown = 389;
    t2.cent = 500;
    t2.sterling = 500;
    t2.fraction = 167;
    t2.yen = 500;
    t2.florin = 500;
    t2.section = 500;
    t2.currency = 500;
    t2.quotesingle = 214;
    t2.quotedblleft = 556;
    t2.guillemotleft = 500;
    t2.guilsinglleft = 333;
    t2.guilsinglright = 333;
    t2.fi = 500;
    t2.fl = 500;
    t2.endash = 500;
    t2.dagger = 500;
    t2.daggerdbl = 500;
    t2.periodcentered = 250;
    t2.paragraph = 523;
    t2.bullet = 350;
    t2.quotesinglbase = 333;
    t2.quotedblbase = 556;
    t2.quotedblright = 556;
    t2.guillemotright = 500;
    t2.ellipsis = 889;
    t2.perthousand = 1e3;
    t2.questiondown = 500;
    t2.grave = 333;
    t2.acute = 333;
    t2.circumflex = 333;
    t2.tilde = 333;
    t2.macron = 333;
    t2.breve = 333;
    t2.dotaccent = 333;
    t2.dieresis = 333;
    t2.ring = 333;
    t2.cedilla = 333;
    t2.hungarumlaut = 333;
    t2.ogonek = 333;
    t2.caron = 333;
    t2.emdash = 889;
    t2.AE = 889;
    t2.ordfeminine = 276;
    t2.Lslash = 556;
    t2.Oslash = 722;
    t2.OE = 944;
    t2.ordmasculine = 310;
    t2.ae = 667;
    t2.dotlessi = 278;
    t2.lslash = 278;
    t2.oslash = 500;
    t2.oe = 667;
    t2.germandbls = 500;
    t2.Idieresis = 333;
    t2.eacute = 444;
    t2.abreve = 500;
    t2.uhungarumlaut = 500;
    t2.ecaron = 444;
    t2.Ydieresis = 556;
    t2.divide = 675;
    t2.Yacute = 556;
    t2.Acircumflex = 611;
    t2.aacute = 500;
    t2.Ucircumflex = 722;
    t2.yacute = 444;
    t2.scommaaccent = 389;
    t2.ecircumflex = 444;
    t2.Uring = 722;
    t2.Udieresis = 722;
    t2.aogonek = 500;
    t2.Uacute = 722;
    t2.uogonek = 500;
    t2.Edieresis = 611;
    t2.Dcroat = 722;
    t2.commaaccent = 250;
    t2.copyright = 760;
    t2.Emacron = 611;
    t2.ccaron = 444;
    t2.aring = 500;
    t2.Ncommaaccent = 667;
    t2.lacute = 278;
    t2.agrave = 500;
    t2.Tcommaaccent = 556;
    t2.Cacute = 667;
    t2.atilde = 500;
    t2.Edotaccent = 611;
    t2.scaron = 389;
    t2.scedilla = 389;
    t2.iacute = 278;
    t2.lozenge = 471;
    t2.Rcaron = 611;
    t2.Gcommaaccent = 722;
    t2.ucircumflex = 500;
    t2.acircumflex = 500;
    t2.Amacron = 611;
    t2.rcaron = 389;
    t2.ccedilla = 444;
    t2.Zdotaccent = 556;
    t2.Thorn = 611;
    t2.Omacron = 722;
    t2.Racute = 611;
    t2.Sacute = 500;
    t2.dcaron = 544;
    t2.Umacron = 722;
    t2.uring = 500;
    t2.threesuperior = 300;
    t2.Ograve = 722;
    t2.Agrave = 611;
    t2.Abreve = 611;
    t2.multiply = 675;
    t2.uacute = 500;
    t2.Tcaron = 556;
    t2.partialdiff = 476;
    t2.ydieresis = 444;
    t2.Nacute = 667;
    t2.icircumflex = 278;
    t2.Ecircumflex = 611;
    t2.adieresis = 500;
    t2.edieresis = 444;
    t2.cacute = 444;
    t2.nacute = 500;
    t2.umacron = 500;
    t2.Ncaron = 667;
    t2.Iacute = 333;
    t2.plusminus = 675;
    t2.brokenbar = 275;
    t2.registered = 760;
    t2.Gbreve = 722;
    t2.Idotaccent = 333;
    t2.summation = 600;
    t2.Egrave = 611;
    t2.racute = 389;
    t2.omacron = 500;
    t2.Zacute = 556;
    t2.Zcaron = 556;
    t2.greaterequal = 549;
    t2.Eth = 722;
    t2.Ccedilla = 667;
    t2.lcommaaccent = 278;
    t2.tcaron = 300;
    t2.eogonek = 444;
    t2.Uogonek = 722;
    t2.Aacute = 611;
    t2.Adieresis = 611;
    t2.egrave = 444;
    t2.zacute = 389;
    t2.iogonek = 278;
    t2.Oacute = 722;
    t2.oacute = 500;
    t2.amacron = 500;
    t2.sacute = 389;
    t2.idieresis = 278;
    t2.Ocircumflex = 722;
    t2.Ugrave = 722;
    t2.Delta = 612;
    t2.thorn = 500;
    t2.twosuperior = 300;
    t2.Odieresis = 722;
    t2.mu = 500;
    t2.igrave = 278;
    t2.ohungarumlaut = 500;
    t2.Eogonek = 611;
    t2.dcroat = 500;
    t2.threequarters = 750;
    t2.Scedilla = 500;
    t2.lcaron = 300;
    t2.Kcommaaccent = 667;
    t2.Lacute = 556;
    t2.trademark = 980;
    t2.edotaccent = 444;
    t2.Igrave = 333;
    t2.Imacron = 333;
    t2.Lcaron = 611;
    t2.onehalf = 750;
    t2.lessequal = 549;
    t2.ocircumflex = 500;
    t2.ntilde = 500;
    t2.Uhungarumlaut = 722;
    t2.Eacute = 611;
    t2.emacron = 444;
    t2.gbreve = 500;
    t2.onequarter = 750;
    t2.Scaron = 500;
    t2.Scommaaccent = 500;
    t2.Ohungarumlaut = 722;
    t2.degree = 400;
    t2.ograve = 500;
    t2.Ccaron = 667;
    t2.ugrave = 500;
    t2.radical = 453;
    t2.Dcaron = 722;
    t2.rcommaaccent = 389;
    t2.Ntilde = 667;
    t2.otilde = 500;
    t2.Rcommaaccent = 611;
    t2.Lcommaaccent = 556;
    t2.Atilde = 611;
    t2.Aogonek = 611;
    t2.Aring = 611;
    t2.Otilde = 722;
    t2.zdotaccent = 389;
    t2.Ecaron = 611;
    t2.Iogonek = 333;
    t2.kcommaaccent = 444;
    t2.minus = 675;
    t2.Icircumflex = 333;
    t2.ncaron = 500;
    t2.tcommaaccent = 278;
    t2.logicalnot = 675;
    t2.odieresis = 500;
    t2.udieresis = 500;
    t2.notequal = 549;
    t2.gcommaaccent = 500;
    t2.eth = 500;
    t2.zcaron = 389;
    t2.ncommaaccent = 500;
    t2.onesuperior = 300;
    t2.imacron = 278;
    t2.Euro = 500;
  });
  t.ZapfDingbats = getLookupTableFactory(function(t2) {
    t2.space = 278;
    t2.a1 = 974;
    t2.a2 = 961;
    t2.a202 = 974;
    t2.a3 = 980;
    t2.a4 = 719;
    t2.a5 = 789;
    t2.a119 = 790;
    t2.a118 = 791;
    t2.a117 = 690;
    t2.a11 = 960;
    t2.a12 = 939;
    t2.a13 = 549;
    t2.a14 = 855;
    t2.a15 = 911;
    t2.a16 = 933;
    t2.a105 = 911;
    t2.a17 = 945;
    t2.a18 = 974;
    t2.a19 = 755;
    t2.a20 = 846;
    t2.a21 = 762;
    t2.a22 = 761;
    t2.a23 = 571;
    t2.a24 = 677;
    t2.a25 = 763;
    t2.a26 = 760;
    t2.a27 = 759;
    t2.a28 = 754;
    t2.a6 = 494;
    t2.a7 = 552;
    t2.a8 = 537;
    t2.a9 = 577;
    t2.a10 = 692;
    t2.a29 = 786;
    t2.a30 = 788;
    t2.a31 = 788;
    t2.a32 = 790;
    t2.a33 = 793;
    t2.a34 = 794;
    t2.a35 = 816;
    t2.a36 = 823;
    t2.a37 = 789;
    t2.a38 = 841;
    t2.a39 = 823;
    t2.a40 = 833;
    t2.a41 = 816;
    t2.a42 = 831;
    t2.a43 = 923;
    t2.a44 = 744;
    t2.a45 = 723;
    t2.a46 = 749;
    t2.a47 = 790;
    t2.a48 = 792;
    t2.a49 = 695;
    t2.a50 = 776;
    t2.a51 = 768;
    t2.a52 = 792;
    t2.a53 = 759;
    t2.a54 = 707;
    t2.a55 = 708;
    t2.a56 = 682;
    t2.a57 = 701;
    t2.a58 = 826;
    t2.a59 = 815;
    t2.a60 = 789;
    t2.a61 = 789;
    t2.a62 = 707;
    t2.a63 = 687;
    t2.a64 = 696;
    t2.a65 = 689;
    t2.a66 = 786;
    t2.a67 = 787;
    t2.a68 = 713;
    t2.a69 = 791;
    t2.a70 = 785;
    t2.a71 = 791;
    t2.a72 = 873;
    t2.a73 = 761;
    t2.a74 = 762;
    t2.a203 = 762;
    t2.a75 = 759;
    t2.a204 = 759;
    t2.a76 = 892;
    t2.a77 = 892;
    t2.a78 = 788;
    t2.a79 = 784;
    t2.a81 = 438;
    t2.a82 = 138;
    t2.a83 = 277;
    t2.a84 = 415;
    t2.a97 = 392;
    t2.a98 = 392;
    t2.a99 = 668;
    t2.a100 = 668;
    t2.a89 = 390;
    t2.a90 = 390;
    t2.a93 = 317;
    t2.a94 = 317;
    t2.a91 = 276;
    t2.a92 = 276;
    t2.a205 = 509;
    t2.a85 = 509;
    t2.a206 = 410;
    t2.a86 = 410;
    t2.a87 = 234;
    t2.a88 = 234;
    t2.a95 = 334;
    t2.a96 = 334;
    t2.a101 = 732;
    t2.a102 = 544;
    t2.a103 = 544;
    t2.a104 = 910;
    t2.a106 = 667;
    t2.a107 = 760;
    t2.a108 = 760;
    t2.a112 = 776;
    t2.a111 = 595;
    t2.a110 = 694;
    t2.a109 = 626;
    t2.a120 = 788;
    t2.a121 = 788;
    t2.a122 = 788;
    t2.a123 = 788;
    t2.a124 = 788;
    t2.a125 = 788;
    t2.a126 = 788;
    t2.a127 = 788;
    t2.a128 = 788;
    t2.a129 = 788;
    t2.a130 = 788;
    t2.a131 = 788;
    t2.a132 = 788;
    t2.a133 = 788;
    t2.a134 = 788;
    t2.a135 = 788;
    t2.a136 = 788;
    t2.a137 = 788;
    t2.a138 = 788;
    t2.a139 = 788;
    t2.a140 = 788;
    t2.a141 = 788;
    t2.a142 = 788;
    t2.a143 = 788;
    t2.a144 = 788;
    t2.a145 = 788;
    t2.a146 = 788;
    t2.a147 = 788;
    t2.a148 = 788;
    t2.a149 = 788;
    t2.a150 = 788;
    t2.a151 = 788;
    t2.a152 = 788;
    t2.a153 = 788;
    t2.a154 = 788;
    t2.a155 = 788;
    t2.a156 = 788;
    t2.a157 = 788;
    t2.a158 = 788;
    t2.a159 = 788;
    t2.a160 = 894;
    t2.a161 = 838;
    t2.a163 = 1016;
    t2.a164 = 458;
    t2.a196 = 748;
    t2.a165 = 924;
    t2.a192 = 748;
    t2.a166 = 918;
    t2.a167 = 927;
    t2.a168 = 928;
    t2.a169 = 928;
    t2.a170 = 834;
    t2.a171 = 873;
    t2.a172 = 828;
    t2.a173 = 924;
    t2.a162 = 924;
    t2.a174 = 917;
    t2.a175 = 930;
    t2.a176 = 931;
    t2.a177 = 463;
    t2.a178 = 883;
    t2.a179 = 836;
    t2.a193 = 836;
    t2.a180 = 867;
    t2.a199 = 867;
    t2.a181 = 696;
    t2.a200 = 696;
    t2.a182 = 874;
    t2.a201 = 874;
    t2.a183 = 760;
    t2.a184 = 946;
    t2.a197 = 771;
    t2.a185 = 865;
    t2.a194 = 771;
    t2.a198 = 888;
    t2.a186 = 967;
    t2.a195 = 888;
    t2.a187 = 831;
    t2.a188 = 873;
    t2.a189 = 927;
    t2.a190 = 970;
    t2.a191 = 918;
  });
});
var CalibriBoldFactors = [1.3877, 1, 0.83908, 0.77539, 0.77539, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.7762, 0.7762, 0.73293, 0.73293, 0.73293, 0.73293, 0.73293, 0.73293, 0.82577, 0.87289, 0.87289, 0.88506, 0.80367, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.88656, 0.73133, 0.73133, 0.57184, 0.87356, 0.6965, 0.88506, 0.91133, 0.7514, 0.81921, 0.68156, 0.81921, 0.81921, 1, 0.81921, 0.87356, 1, 0.99862, 0.99862, 1, 0.91075, 0.87356, 0.95958, 0.76229, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.56289, 0.95958, 0.59526, 0.59526, 0.75727, 0.75727, 1, 0.69225, 0.69225, 0.89019, 0.70424, 1, 0.91926, 0.70823, 1.04924, 1.04924, 0.9121, 0.9121, 0.9121, 1, 0.9121, 0.9121, 0.86943, 0.87402, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.84896, 0.81235, 0.86943, 0.82001, 0.87508, 0.87508, 0.86943, 0.79795, 0.9762, 0.87356, 0.99819, 0.88198, 0.77958, 0.77958, 0.77958, 1, 0.79795, 0.70864, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 0.70572, 0.8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.70864, 0.70864, 0.70864, 0.70864, 1, 0.78275, 0.81055, 0.81055, 0.81055, 0.81055, 1, 0.86943, 0.79795, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.77892, 0.56029, 0.90399, 0.90399, 0.88653, 0.96017, 0.96017, 0.96017, 0.96017, 0.96017, 0.82577, 0.7648, 0.77892, 0.77892, 0.77892, 0.77892, 0.77892, 0.78257, 0.78257, 0.78257, 0.78257, 0.78257, 0.88762, 0.88762, 0.88762, 0.88762, 0.90323, 1, 0.88762, 0.8715, 0.8715, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88762, 0.96108, 0.96108, 0.88762, 0.97566, 0.80352, 0.88762, 0.90747, 0.88762, 0.88762, 1.31006, 1.81055, 0.90527, 0.90527, 1.81055, 1.53711, 0.94434, 0.85284, 0.85284, 1.2798, 0.92138, 0.88762, 0.8785, 1.54657, 1.69808, 0.8936, 1, 0.88331, 0.88331, 0.97507, 0.97507, 1.15543, 1, 1.7801, 1.42259, 0.75241, 0.75241, 1.20528, 1, 1, 0.75241, 0.75241, 0.75241, 0.75241, 0.91056, 0.89552, 0.78287, 0.91027, 1.20528, 1, 1, 0.82845, 0.92794, 1, 1, 1.13254, 0.89552, 1, 0.8785, 0.89552, 0.89552, 0.83016, 0.93125, 0.85592, 0.87842, 1, 1.24487, 1, 1.06303, 0.90747, 1, 1, 0.91133, 0.70674, 0.88401, 0.90518, 0.90518, 0.90518, 0.90518, 0.90518, 0.90518, 0.90518, 0.90518, 0.91133, 1, 0.71143, 0.90518, 0.90527, 0.89552, 0.8785, 0.90518, 0.96399, 1.01407, 0.85284, 0.85356, 1.23108, 0.89049, 0.89049, 0.8785, 0.97801, 0.97171, 0.97801, 0.95015, 1, 1, 1, 0.91133, 0.88525, 1, 0.56892, 0.91133, 1, 0.83406, 0.77618, 0.84021, 0.77618, 0.77618, 1, 0.77618, 0.90807, 0.90176, 1, 0.85284, 0.90747, 0.96839, 0.96839, 1.03372, 1.03372, 0.8785, 0.89608, 0.8785, 1, 1.44947, 1.45894, 1, 0.88401, 0.88401, 0.88401, 0.88401, 0.88401, 0.88401, 0.90167, 0.88401, 1.17534, 1.37077, 0.8941, 0.8941, 0.9716, 1, 1, 1, 0.88401, 1.02988, 1.02988, 1.02988, 1.02988, 0.88401, 0.91916, 0.91916, 0.86304, 0.86077, 1, 0.86304, 0.88401, 0.88401, 0.87445, 0.79468, 1, 0.88175, 0.85284, 0.90747, 1, 0.91133, 0.85284, 0.9297, 1.08004, 0.94903, 1, 0.91488, 0.70645, 1, 1, 0.85284, 1, 0.92099, 0.85284, 1, 1, 0.8785, 0.8785, 0.87802, 0.8785, 1, 0.91133, 1, 0.90747, 0.8785, 0.84723, 0.89552, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.89291, 0.94721, 0.8801, 0.8801, 0.8801, 0.84971, 0.84971, 0.8801, 0.8801, 0.91133, 0.83489, 0.82845, 0.78864, 0.99862, 1.12401, 1.19118, 0.69825, 0.89049, 0.89049, 0.8801, 0.8785, 1.07463, 0.93548, 0.93548, 1.08696, 0.81988, 0.96134, 1.06152, 0.84107, 0.97747, 0.75638, 0.85284, 0.90747, 0.95018, 0.97926, 0.8785, 0.75859, 0.75859, 0.92482, 0.87012, 0.87012, 0.87012, 0.92794, 0.92794, 0.92794, 0.92794, 0.98152, 0.91343, 0.91343, 0.90747, 0.91343, 1, 0.68787, 0.85284, 0.85714, 0.98387, 1, 0.7173, 0.7173, 0.7173, 0.7173, 0.7173, 1, 1, 0.89552, 0.91133, 0.81499, 1, 1, 0.79586, 0.78216, 0.91133, 1.54657, 1, 1, 0.91133, 0.77192, 1, 1.04106, 0.87965, 1.06452, 0.75841, 1, 1.00813, 0.8785, 0.91133, 0.88525, 0.84133, 1.33431, 1, 0.95161, 0.72021, 1, 1, 1, 1, 0.91133, 0.8785, 0.8785, 0.8785, 0.8785, 0.8785, 0.8785, 0.8785, 0.8785, 0.89552, 0.90363, 1, 1, 1.01466, 1.0088, 1, 0.75806, 0.81055, 1.04106, 1, 0.82845, 0.73133, 0.90264, 0.90518, 0.90548, 1, 1, 1.4956, 0.93835, 1, 1, 2.2807, 1, 1, 1, 0.90727, 0.90727, 0.8785, 1, 0.94211, 0.94211, 0.94211, 0.94211, 0.8785, 0.8785, 0.85075, 0.95794, 0.95794, 0.95794, 0.95794, 0.95794, 0.82616, 0.86513, 0.85162, 0.85162, 0.85162, 0.85162, 0.91133, 0.85162, 0.79492, 0.79492, 0.79492, 0.79492, 0.91133, 0.79109];
var CalibriBoldLineHeight = 1.2207;
var CalibriBoldItalicFactors = [1.3877, 1, 0.83908, 0.77539, 0.77539, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.7762, 0.7762, 0.71805, 0.71805, 0.71805, 0.71805, 0.71805, 0.71805, 0.82577, 0.87289, 0.87289, 0.88506, 0.86036, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.73133, 0.88116, 0.73133, 0.73133, 0.57118, 0.87356, 0.6965, 0.88506, 0.91133, 0.7514, 0.81921, 0.67174, 0.81921, 0.81921, 1, 0.81921, 0.87356, 1, 0.99862, 0.99862, 1, 0.91075, 0.87356, 0.95958, 0.76467, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.95958, 0.56347, 0.95958, 0.59526, 0.59526, 0.75727, 0.75727, 1, 0.69225, 0.69225, 0.89019, 0.70424, 1, 0.91926, 0.70823, 1.04924, 1.04924, 0.90872, 0.90872, 0.90872, 1, 0.90872, 0.90872, 0.85938, 0.87402, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.87179, 0.80346, 0.85938, 0.79179, 0.87068, 0.87068, 0.85938, 0.79795, 0.97447, 0.87891, 0.97466, 0.87068, 0.77958, 0.77958, 0.77958, 1, 0.79795, 0.69766, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 0.70572, 0.8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.69766, 0.69766, 0.69766, 0.69766, 1, 0.7957, 0.81055, 0.81055, 0.81055, 0.81055, 1, 0.86441, 0.79795, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.77892, 0.55853, 0.90399, 0.90399, 0.88653, 0.96068, 0.96068, 0.96068, 0.96068, 0.96068, 0.82577, 0.74889, 0.77892, 0.77892, 0.77892, 0.77892, 0.77892, 0.78257, 0.78257, 0.78257, 0.78257, 0.78257, 0.94908, 0.94908, 0.94908, 0.94908, 0.90323, 1, 0.94908, 0.85887, 0.85887, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94908, 0.94252, 0.94252, 0.94908, 0.97566, 0.80352, 0.94908, 0.90747, 0.94908, 0.94908, 1.3107, 1.81055, 0.90616, 0.90527, 1.81055, 1.53711, 0.94434, 0.85284, 0.85284, 1.2798, 0.92138, 0.94908, 0.86411, 1.529, 1.69808, 0.87411, 1, 0.88331, 0.88331, 0.97507, 0.97507, 1.15543, 1, 1.7801, 1.42259, 0.74012, 0.74012, 1.20528, 1, 1, 0.74012, 0.74012, 0.74012, 0.74012, 0.91056, 0.89552, 0.78022, 0.91027, 1.20528, 1, 1, 0.82845, 0.92794, 1, 1, 1.13254, 0.89552, 1, 0.86411, 0.89552, 0.89552, 0.79538, 0.92726, 0.85592, 0.8728, 1, 1.24487, 1, 1.48387, 0.90747, 1, 1, 0.91133, 0.70088, 0.88401, 0.88323, 0.88323, 0.88323, 0.88323, 0.88323, 0.88323, 0.88323, 0.88323, 0.91133, 1, 0.71094, 0.88323, 0.90527, 0.89552, 0.86331, 0.88323, 0.95612, 0.95612, 0.85284, 0.85356, 1.23108, 0.8753, 0.8753, 0.8785, 0.97801, 0.97171, 0.97801, 0.95015, 1, 1, 1, 0.91133, 0.88525, 1, 0.56892, 0.91133, 1, 0.83406, 0.86411, 0.84021, 0.86411, 0.86411, 1, 0.86411, 0.90807, 0.90176, 1, 0.85284, 0.90747, 0.96839, 0.96839, 1.03372, 1.03372, 0.86331, 0.8777, 0.86331, 1, 1.44947, 1.45894, 1, 0.88401, 0.88401, 0.88401, 0.88401, 0.88401, 0.88401, 0.90167, 0.88401, 1.17534, 1.37077, 0.8941, 0.8941, 0.9716, 1, 1, 1, 0.88401, 1.02988, 1.02988, 1.02988, 1.02988, 0.88401, 0.91916, 0.91916, 0.86304, 0.84814, 1, 0.86304, 0.88401, 0.88401, 0.87445, 0.77312, 1, 0.88175, 0.85284, 0.90747, 1, 0.91133, 0.85284, 0.9297, 1.08004, 0.94903, 1, 0.9039, 0.70645, 1, 1, 0.85284, 1, 0.91822, 0.85284, 1, 1, 0.86331, 0.86331, 0.86906, 0.86331, 1, 0.91133, 1, 0.90747, 0.86331, 0.84723, 0.89552, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86549, 0.94721, 0.86331, 0.86331, 0.86331, 0.86015, 0.86015, 0.86331, 0.86331, 0.91133, 0.83489, 0.82845, 0.78864, 0.99862, 1.19129, 1.19118, 0.69825, 0.89049, 0.89049, 0.86331, 0.86411, 1.07463, 0.93548, 0.93548, 1.08696, 0.81988, 0.96134, 1.06152, 0.83326, 0.99375, 0.81344, 0.85284, 0.90747, 0.95018, 0.95452, 0.86411, 0.75859, 0.75859, 0.92482, 0.87012, 0.87012, 0.87012, 0.92794, 0.89807, 0.92794, 0.92794, 0.98152, 0.90464, 0.90464, 0.90747, 0.90464, 1, 0.68787, 0.85284, 0.87581, 0.98387, 1, 0.70852, 0.70852, 0.70852, 0.70852, 0.70852, 1, 1, 0.89552, 0.91133, 0.81499, 1, 1, 0.82046, 0.76422, 0.91133, 1.56239, 1, 1, 0.91133, 0.77192, 1, 1.04106, 0.96057, 1.06452, 0.75841, 1, 1.02189, 0.86411, 0.91133, 0.88525, 0.84133, 1.33431, 1, 0.95161, 0.72021, 1, 1, 1, 1, 0.91133, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.89552, 0.90363, 1, 1, 1.01466, 1.0088, 1, 0.75806, 0.81055, 1.04106, 1, 0.82845, 0.73133, 0.90631, 0.88323, 0.85174, 1, 1, 1.4956, 0.92972, 1, 1, 2.2807, 1, 1, 1, 0.90727, 0.90727, 0.86331, 1, 0.92733, 0.92733, 0.92733, 0.92733, 0.86331, 0.86331, 0.84372, 0.95794, 0.95794, 0.95794, 0.95794, 0.95794, 0.82616, 0.85668, 0.84548, 0.84548, 0.84548, 0.84548, 0.91133, 0.84548, 0.79492, 0.79492, 0.79492, 0.79492, 0.91133, 0.74081];
var CalibriBoldItalicLineHeight = 1.2207;
var CalibriItalicFactors = [1.3877, 1, 0.8675, 0.76318, 0.76318, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.81552, 0.81552, 0.72346, 0.72346, 0.72346, 0.72346, 0.72346, 0.72346, 0.77818, 0.85193, 0.85193, 0.86477, 0.84134, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.86698, 0.73206, 0.73206, 0.6192, 0.86275, 0.7363, 0.86477, 0.91133, 0.7522, 0.81105, 0.7286, 0.81105, 0.81105, 1, 0.81105, 0.86275, 1, 0.99862, 0.99862, 1, 0.90872, 0.86275, 0.90685, 0.77896, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.64824, 0.90685, 0.6377, 0.6377, 0.77892, 0.77892, 1, 0.75593, 0.75593, 0.85871, 0.76032, 1, 0.98156, 0.77261, 1.02638, 1.02638, 0.89249, 0.89249, 0.89249, 1, 0.89249, 0.89249, 0.84118, 0.8667, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.87291, 0.85696, 0.84118, 0.82411, 0.84557, 0.84557, 0.84118, 0.77452, 0.90782, 0.85984, 0.903, 0.85374, 0.75186, 0.75186, 0.75186, 1, 0.77452, 0.67789, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 0.70572, 0.8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.67789, 0.67789, 0.67789, 0.67789, 1, 0.76466, 0.79776, 0.79776, 0.79776, 0.79776, 1, 0.84369, 0.77452, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.7306, 0.56321, 0.88844, 0.88844, 0.85066, 0.94309, 0.94309, 0.94309, 0.94309, 0.94309, 0.77818, 0.75828, 0.7306, 0.7306, 0.7306, 0.7306, 0.7306, 0.76659, 0.76659, 0.76659, 0.76659, 0.76659, 0.9245, 0.9245, 0.9245, 0.9245, 0.87683, 1, 0.9245, 0.84843, 0.84843, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9245, 0.99058, 0.99058, 0.9245, 1.02269, 0.90861, 0.9245, 0.90747, 0.9245, 0.9245, 1.28809, 1.81055, 0.90572, 0.90749, 1.81055, 1.55469, 0.94434, 1.06139, 0.85284, 1.2798, 0.88071, 0.9245, 0.9245, 1.38313, 1.77256, 0.92393, 1, 0.94152, 0.94152, 1.10369, 1.10369, 1.1437, 1, 1.91729, 1.42259, 0.83203, 0.83203, 1.18622, 1, 1, 0.83203, 0.83203, 0.83203, 0.83203, 0.92229, 0.89552, 0.78086, 0.91027, 1.18622, 1, 1, 0.96309, 0.89807, 1, 1, 1.13254, 0.89552, 1, 0.9245, 0.89552, 0.89552, 0.8875, 0.99034, 0.84737, 0.942, 1, 1.17889, 1, 1.48387, 0.90747, 1, 1, 0.91133, 0.67009, 0.82601, 0.85865, 0.85865, 0.85865, 0.85865, 0.85865, 0.85865, 0.85865, 0.85865, 0.91133, 1, 0.68994, 0.85865, 0.90527, 0.89552, 0.9245, 0.85865, 1.03667, 1.03667, 0.85284, 0.85284, 1.23108, 0.94635, 0.94635, 0.94469, 1.17223, 1.11523, 0.97801, 1.09842, 1, 1, 1, 0.91133, 0.84426, 1, 0.54873, 0.91133, 1, 0.82616, 0.9245, 0.8916, 0.9245, 0.9245, 1, 0.9245, 0.86331, 0.8739, 1, 0.85284, 0.90747, 0.92098, 0.92098, 1.0176, 1.0176, 0.9245, 0.93591, 0.9245, 1, 1.44947, 1.40909, 1, 1.03297, 0.82601, 0.82601, 0.82601, 0.82601, 0.82601, 1.05611, 0.82601, 1.19658, 1.33512, 0.8941, 0.8941, 0.97622, 1, 1, 1, 1.03297, 1.23516, 1.23516, 1.23516, 1.23516, 0.82601, 1.07692, 1.07692, 0.90918, 0.90918, 1, 0.90918, 1.03297, 1.03297, 0.94048, 0.9375, 1, 0.93407, 0.85284, 0.90747, 1, 0.91133, 0.85284, 1.09231, 1.0336, 1.11429, 1, 0.94959, 0.71353, 1, 1, 0.85284, 1, 0.98217, 0.85284, 1, 1, 0.9245, 0.9245, 0.92534, 0.9245, 1, 0.91133, 1, 0.90747, 0.9245, 0.89746, 0.89552, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.86291, 0.93695, 0.92274, 0.92274, 0.92274, 0.89404, 0.89404, 0.92274, 0.92274, 0.91133, 0.79801, 0.80504, 0.76288, 0.99862, 1.16359, 1.15642, 0.69825, 0.86651, 0.86651, 0.92274, 0.9245, 1.09091, 0.91056, 0.91056, 1.07806, 0.80395, 0.90861, 1.03809, 0.83437, 1.00225, 0.82507, 0.85284, 0.90747, 0.97094, 0.97248, 0.9245, 0.83319, 0.75859, 1.1293, 1.2566, 1.2566, 1.2566, 1.12308, 1.12308, 1.12308, 1.12308, 1.15601, 1.02933, 1.02933, 0.90747, 1.02933, 1, 0.68787, 0.85284, 0.88832, 0.96334, 1, 0.77832, 0.77832, 0.77832, 0.77832, 0.77832, 1, 1, 0.89552, 0.91133, 0.774, 1, 1, 0.88178, 0.84438, 0.91133, 1.39543, 1, 1, 0.91133, 0.7589, 1, 1.20562, 1.03525, 1.23023, 0.97655, 1, 1.0297, 0.9245, 0.91133, 0.84426, 0.80972, 1.35191, 1, 0.95161, 0.70508, 1, 1, 1, 1, 0.91133, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.89552, 0.90186, 1, 1, 1.0088, 1.0044, 1, 0.739, 0.79776, 1.20562, 1, 0.96309, 0.73206, 0.89693, 0.85865, 0.90933, 1, 1, 1.4956, 0.97858, 1, 1, 2.01462, 1, 1, 1, 1.05859, 1.05859, 0.9245, 1, 0.9849, 0.9849, 0.9849, 0.9849, 0.9245, 0.9245, 0.8916, 0.98986, 0.98986, 0.98986, 0.98986, 0.98986, 0.86621, 0.84153, 0.89453, 0.89453, 0.89453, 0.89453, 0.91133, 0.89453, 0.79004, 0.79004, 0.79004, 0.79004, 0.91133, 0.75026];
var CalibriItalicLineHeight = 1.2207;
var CalibriRegularFactors = [1.3877, 1, 0.8675, 0.76318, 0.76318, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.86686, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.81552, 0.81552, 0.73834, 0.73834, 0.73834, 0.73834, 0.73834, 0.73834, 0.77818, 0.85193, 0.85193, 0.86477, 0.84503, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.73206, 0.86901, 0.73206, 0.73206, 0.62267, 0.86275, 0.74359, 0.86477, 0.91133, 0.7522, 0.81105, 0.75443, 0.81105, 0.81105, 1, 0.81105, 0.86275, 1, 0.99862, 0.99862, 1, 0.90872, 0.86275, 0.90685, 0.77741, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.90685, 0.65649, 0.90685, 0.6377, 0.6377, 0.77892, 0.77892, 1, 0.75593, 0.75593, 0.85746, 0.76032, 1, 0.98156, 0.77261, 1.02638, 1.02638, 0.89385, 0.89385, 0.89385, 1, 0.89385, 0.89385, 0.85122, 0.8667, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.88831, 0.88254, 0.85122, 0.85498, 0.85311, 0.85311, 0.85122, 0.77452, 0.95165, 0.86275, 0.89772, 0.86503, 0.75186, 0.75186, 0.75186, 1, 0.77452, 0.68887, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 0.70572, 0.8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.68887, 0.68887, 0.68887, 0.68887, 1, 0.74171, 0.79776, 0.79776, 0.79776, 0.79776, 1, 0.85122, 0.77452, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.7306, 0.56963, 0.88844, 0.88844, 0.85066, 0.94258, 0.94258, 0.94258, 0.94258, 0.94258, 0.77818, 0.75657, 0.7306, 0.7306, 0.7306, 0.7306, 0.7306, 0.76659, 0.76659, 0.76659, 0.76659, 0.76659, 0.86128, 0.86128, 0.86128, 0.86128, 0.87683, 0.86128, 0.8693, 0.8693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.86128, 0.98142, 0.98142, 0.86128, 1.02269, 0.90861, 0.86128, 0.90747, 0.86128, 0.86128, 1.28809, 1.81055, 0.90527, 0.90527, 1.81055, 1.55469, 0.94434, 1.06139, 0.85284, 1.2798, 0.88071, 0.86128, 0.94469, 1.39016, 1.77256, 0.9236, 1, 0.94152, 0.94152, 1.10369, 1.10369, 1.1437, 1.91729, 1.42259, 0.8457, 0.8457, 1.18622, 0.8457, 0.8457, 0.8457, 0.8457, 0.92229, 0.89552, 0.81209, 0.91027, 1.18622, 1, 0.96309, 0.89807, 1.13254, 0.89552, 0.94469, 0.89552, 0.89552, 0.92454, 0.9921, 0.84737, 0.94035, 1, 1.17889, 1.48387, 0.90747, 1, 1, 0.91133, 0.67742, 0.82601, 0.89464, 0.89464, 0.89464, 0.89464, 0.89464, 0.89464, 0.89464, 0.89464, 0.91133, 0.69043, 0.89464, 0.90527, 0.89552, 0.94469, 0.89464, 1.02191, 1.02191, 0.85284, 0.85356, 1.23108, 0.96576, 0.96576, 0.94469, 1.17223, 1.11523, 0.97801, 1.09842, 1, 1, 1, 0.91133, 0.84426, 0.54873, 0.91133, 0.82616, 0.84636, 0.89258, 0.84636, 0.84636, 1, 0.84636, 0.86331, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.8739, 0.85284, 0.90747, 0.92098, 0.92098, 1.0176, 1.0176, 0.94469, 0.95786, 0.94469, 1, 1.44947, 1.40909, 1.03297, 0.82601, 0.82601, 0.82601, 0.82601, 0.82601, 1.05611, 0.82601, 1.19658, 1.33512, 0.8941, 0.8941, 0.97622, 1, 1, 1, 1.03297, 1.23516, 1.23516, 1.23516, 1.23516, 0.82601, 1.07692, 1.07692, 0.90918, 0.90918, 1, 0.90918, 1.03297, 1.03297, 0.92578, 0.90452, 1, 1.11842, 0.85284, 0.90747, 1, 0.91133, 0.85284, 1.09231, 1.0336, 1.11429, 1, 0.95897, 0.71353, 1, 1, 0.85284, 1, 0.95424, 0.85284, 1, 1, 0.94469, 0.94469, 0.95877, 0.94469, 1, 0.91133, 1, 0.90747, 0.94469, 0.89746, 0.89552, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90016, 0.93695, 0.9482, 0.9482, 0.9482, 0.89181, 0.89181, 0.9482, 0.9482, 0.91133, 0.79801, 0.80504, 0.76288, 0.99862, 1.08707, 1.15642, 0.69825, 0.86651, 0.86651, 0.9482, 0.94469, 1.09091, 0.91056, 0.91056, 1.07806, 0.80395, 0.90861, 1.03809, 0.84286, 1.00452, 0.80113, 0.85284, 0.90747, 0.97094, 0.99247, 0.94469, 0.83319, 0.75859, 1.1293, 1.2566, 1.2566, 1.2566, 1.12308, 1.12308, 1.12308, 1.12308, 1.15601, 1.04692, 1.04692, 0.90747, 1.04692, 1, 0.68787, 0.85284, 0.89442, 0.96334, 1, 0.78223, 0.78223, 0.78223, 0.78223, 0.78223, 1, 1, 0.89552, 0.91133, 0.774, 1, 0.86155, 0.85208, 0.91133, 1.39016, 1, 1, 0.91133, 0.7589, 1, 1.20562, 0.98022, 1.23023, 0.92188, 1, 0.9561, 0.94469, 0.91133, 0.84426, 0.80972, 1.35191, 0.95161, 0.70508, 1, 1, 1, 1, 0.91133, 0.94469, 0.94469, 0.94469, 0.94469, 0.94469, 0.94469, 0.94469, 0.94469, 0.89552, 0.90186, 1, 1, 1.0088, 1.0044, 1, 0.739, 0.79776, 1.20562, 1, 0.96309, 0.73206, 0.88844, 0.89464, 0.96766, 1, 1, 1.4956, 1.07185, 0.99413, 0.96334, 1.08065, 0.99331, 1, 1, 2.01462, 1, 1, 1, 1, 1.05859, 1.05859, 0.94469, 1, 0.99018, 0.99018, 0.99018, 0.99018, 0.94469, 0.94469, 0.90332, 0.98986, 0.98986, 0.98986, 0.98986, 0.98986, 0.86621, 0.83969, 0.90527, 0.90527, 0.90527, 0.90527, 0.91133, 0.90527, 0.79004, 0.79004, 0.79004, 0.79004, 0.91133, 0.78848];
var CalibriRegularLineHeight = 1.2207;
var HelveticaBoldFactors = [0.76116, 1, 0.99977, 1, 1, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 0.99977, 0.99977, 0.99977, 0.85148, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.9998, 1.00001, 1.00001, 0.99997, 0.99977, 1.00026, 0.99977, 0.99973, 1.00026, 1.00022, 0.99988, 1.00022, 1.00022, 1.00022, 1.00022, 0.99977, 0.99999, 0.99861, 0.99861, 1, 0.99977, 0.99977, 1.0006, 1.00042, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00078, 1.0006, 0.99973, 0.99973, 0.99977, 0.99977, 0.99977, 1.00026, 1.00026, 1.00001, 1.00026, 1.00026, 1.00026, 1.00026, 0.99999, 0.99999, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00022, 1, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1, 1.00013, 1.00022, 1.00036, 1.00022, 1.00022, 1.00022, 1.00001, 1.00024, 0.99977, 0.9999, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.99984, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00022, 1.00001, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 0.99973, 0.99977, 0.99977, 1.00001, 1.00016, 1.00016, 1.00016, 1.00016, 1.00016, 1.00001, 1.00069, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 0.99973, 0.99982, 0.99982, 1, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00008, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 1.00038, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99989, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 1.0005, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 0.99973, 1.00035, 1, 0.99999, 1, 0.99971, 1.00047, 1.00023, 0.99973, 1.00041, 1.00041, 0.99973, 0.99977, 1, 0.99973, 1.00031, 0.99973, 0.99973, 1, 1, 1, 1, 1, 1, 1, 1.00003, 1.00003, 0.99959, 0.9999, 0.99973, 1.00026, 1.0006, 1.00077, 0.99942, 1.41144, 0.99959, 0.99959, 0.99998, 0.99998, 0.99998, 1, 1.00077, 0.99972, 0.99973, 0.99973, 0.99998, 1, 1, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 0.99973, 1.00055, 0.99999, 0.99998, 1, 0.99962, 0.99998, 1.0006, 1, 1, 1.00025, 0.99973, 1, 1.00026, 0.99973, 0.99973, 1.03374, 1.00026, 1.00024, 0.99927, 0.9995, 0.99998, 1, 1.00034, 1.06409, 1.36625, 1.41144, 0.99973, 0.99998, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 0.99973, 1, 0.99973, 1.00026, 0.99973, 1.00082, 0.99962, 1.00003, 0.99915, 0.99984, 1.00026, 1.00026, 1.00026, 0.99998, 0.99999, 0.99998, 0.99998, 1, 0.99999, 1, 0.99973, 1.00002, 0.99998, 0.99973, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99998, 1, 1.00003, 1.00031, 0.99973, 0.99973, 0.99998, 0.99998, 1.00026, 1.00026, 1.00026, 1.00042, 0.99999, 0.99998, 1, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 1.0006, 1.00015, 1.00027, 0.99999, 0.99999, 0.99561, 0.99999, 0.99999, 0.99977, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 1.00069, 0.99973, 0.99973, 1.0006, 1.0006, 0.99973, 1.03828, 1.0006, 0.99999, 1.00003, 1.00031, 1.41144, 0.99973, 1.00003, 1.0006, 0.99972, 1.0006, 1.40579, 0.99982, 0.60299, 1, 1, 1.00003, 1.00106, 0.99867, 1.00003, 1, 1, 1.00026, 1.00026, 0.9993, 1.00026, 1.00026, 0.99973, 1, 1.00031, 1.00026, 0.99973, 0.99973, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00016, 0.99998, 1.00026, 1.00026, 1.00026, 1.00032, 1.00032, 1.00026, 1.00026, 0.99973, 1.00002, 1.00002, 1.00002, 1.40483, 0.99968, 0.99936, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99998, 0.99998, 0.99972, 0.99982, 1.0006, 1, 1.00023, 0.99954, 1.00049, 1.00003, 1.06409, 1.20985, 0.99945, 1.00026, 1.00026, 1.00026, 0.99974, 1, 1, 1, 1.0006, 1.0006, 1.0006, 1.0006, 1.00087, 0.99959, 0.99959, 1.00031, 0.99959, 0.99959, 1.00025, 1.00003, 1.00056, 0.99998, 1.41144, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99999, 0.99973, 0.99973, 1.00002, 0.99998, 1.40579, 0.99988, 1, 0.99973, 1.0006, 1, 0.99953, 0.99973, 1.39713, 1.00054, 0.99998, 0.99935, 0.99998, 0.8121, 0.99998, 1.00087, 1.00026, 0.99973, 1.00002, 1.00002, 0.99998, 1, 0.99998, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99955, 1.0006, 0.99998, 1, 1, 1, 1, 1.00026, 0.99998, 0.99998, 1, 1.00001, 0.99561, 0.99973, 1.00041, 1, 1, 0.99998, 1, 0.99991, 1, 1.66475, 1.0006, 1, 1, 1, 1, 1.00026, 1.41144, 0.99995, 0.99995, 0.99995, 0.99995, 1.00026, 1.00026, 0.99973, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 0.99973, 0.9993, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1, 1, 1, 1, 0.99973, 0.99902];
var HelveticaBoldLineHeight = 1.2;
var HelveticaBoldItalicFactors = [0.76116, 1, 0.99977, 1, 1, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 0.99977, 0.99977, 0.99977, 0.91155, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.9998, 1.00001, 1.00001, 1, 0.99977, 1.00026, 0.99977, 0.99973, 1.00026, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 0.99977, 0.99999, 0.99861, 0.99861, 1, 0.99977, 0.99977, 1.0006, 0.99971, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99969, 1.0006, 0.99973, 0.99973, 0.99977, 0.99977, 0.99977, 1.00026, 1.00026, 1.00001, 1.00026, 1.00026, 1.00026, 1.00026, 0.99999, 0.99999, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00022, 1, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1, 0.9998, 1.00022, 0.99972, 1.00022, 1.00022, 1.00022, 1.00001, 0.99968, 1.00032, 1.00047, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.99944, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00022, 1.00001, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 0.99981, 0.99977, 0.99977, 1.00001, 1.00016, 1.00016, 1.00016, 1.00016, 1.00016, 1.00001, 0.99966, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 0.99973, 0.99982, 0.99982, 1, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99966, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99964, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 1.00044, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.99973, 0.99967, 1, 1.00026, 1, 0.99971, 0.99978, 1, 0.99973, 0.99981, 0.99981, 0.99973, 0.99977, 1, 0.99973, 1.00031, 0.99973, 0.99973, 1.00049, 1, 1.00098, 1, 1, 1, 1, 1.00003, 1.00003, 0.99959, 0.9999, 0.99973, 1.00026, 1.0006, 1.00077, 1.00064, 1.41144, 0.99959, 0.99959, 0.99998, 0.99998, 0.99998, 1, 1.00077, 0.99972, 0.99973, 0.99973, 0.99998, 1, 1, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 0.99973, 1.00063, 0.99999, 0.99998, 1, 0.99962, 0.99998, 1.0006, 1, 1, 1.00025, 0.99973, 1, 1.00026, 0.99973, 0.99973, 1.0044, 1.00026, 1.00024, 0.99942, 0.9995, 0.99998, 1, 0.99998, 1.06409, 1.36625, 1.41144, 0.99973, 0.99998, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 0.99973, 1, 0.99973, 1.00026, 0.99973, 1.00101, 1.00101, 1.00003, 0.99915, 0.99984, 1.00026, 1.00026, 1.00026, 0.99998, 0.99999, 0.99998, 0.99998, 1, 0.99999, 1, 0.99973, 1.00002, 0.99998, 0.99973, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99998, 1, 1.00003, 1.00031, 0.99973, 0.99973, 0.99998, 0.99998, 1.00026, 1.00026, 1.00026, 1.00042, 0.99999, 0.99998, 1, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 1.0006, 1.00015, 1.00027, 0.99999, 0.99999, 0.99561, 0.99999, 0.99999, 0.99977, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 1.00014, 0.99973, 0.99973, 1.0006, 1.0006, 0.99973, 1.01011, 1.0006, 0.99999, 1.00003, 1.00031, 1.41144, 0.99973, 1.00003, 1.0006, 0.99972, 1.0006, 1.40579, 0.99982, 0.60299, 1, 1, 1.00003, 1.00106, 1.01322, 1.00003, 1, 1, 1.00026, 1.00026, 0.9993, 1.00026, 1.00026, 0.99973, 1, 1.00031, 1.00026, 0.99973, 0.99973, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00016, 0.99998, 1.00026, 1.00026, 1.00026, 0.99943, 0.99943, 1.00026, 1.00026, 0.99973, 1.00002, 1.00002, 1.00002, 1.40483, 0.99968, 0.99936, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99998, 0.99998, 0.99972, 0.99982, 1.0006, 1, 1, 1.00055, 1.00012, 1.00003, 1.06409, 1.20985, 1.00007, 1.00026, 1.00026, 1.00026, 0.99974, 1, 1, 1, 1.0006, 1.0006, 1.0006, 1.0006, 1.00087, 0.99959, 0.99959, 1.00031, 0.99959, 0.99959, 1.00025, 1.00003, 0.99923, 0.99998, 1.41144, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99999, 0.99973, 0.99973, 1.00002, 0.99998, 1.40579, 1.00064, 1, 0.99973, 1.0006, 1, 0.99953, 0.99973, 1.39713, 1.00054, 0.99998, 1.00076, 0.99998, 0.8121, 0.99998, 1.00069, 1.00026, 0.99973, 1.00002, 1.00002, 0.99998, 1, 0.99998, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99955, 1.0006, 0.99998, 1, 1, 1, 1, 1.00026, 0.99998, 0.99998, 1, 1.00001, 0.99967, 0.99973, 0.98685, 1, 1, 0.99998, 1, 0.99991, 1, 1.66475, 1.0006, 1, 1, 1, 1, 1.00026, 1.41144, 0.99948, 0.99948, 0.99948, 0.99948, 1.00026, 1.00026, 0.99973, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 0.99973, 1.00065, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1, 1, 1, 1, 0.99973, 1.00061];
var HelveticaBoldItalicLineHeight = 1.35;
var HelveticaItalicFactors = [0.76116, 1, 1.00001, 1, 1, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 0.99977, 0.99977, 0.99977, 0.91221, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.9998, 1.00001, 1.00001, 1.00054, 0.99977, 0.99977, 0.99977, 0.99973, 1.00026, 1.00022, 0.99945, 1.00022, 1.00022, 1.00022, 1.00022, 0.99977, 0.99999, 0.99861, 0.99861, 1, 0.99977, 0.99977, 1.0006, 0.99946, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00084, 1.0006, 1, 1, 1.00001, 1.00001, 1.00001, 0.99973, 0.99973, 1.00001, 0.99973, 0.99973, 0.99973, 0.99973, 0.99999, 0.99999, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00022, 1, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1, 1.00013, 1.00022, 1.00007, 1.00022, 1.00022, 1.00022, 1.00001, 1.0001, 1.00054, 1.00052, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00065, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00022, 1.00001, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 0.99973, 0.99977, 0.99977, 1.00001, 1.00016, 1.00016, 1.00016, 1.00016, 1.00016, 1.00001, 0.99933, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 0.99973, 0.99982, 0.99982, 1, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99962, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99975, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99895, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 1, 1.00051, 1, 0.99973, 1, 1.00423, 0.99925, 0.99999, 0.99973, 0.99945, 0.99945, 0.99973, 1.00001, 1, 0.99973, 1.00031, 0.99973, 0.99973, 1, 1, 1.00049, 1.00245, 1, 1, 1, 0.99949, 1.00003, 0.99959, 0.99987, 0.99973, 0.99973, 1.0006, 1.0009, 0.99949, 1.41144, 1.00005, 1.00005, 1.0006, 1.0006, 0.99998, 1, 1.0009, 0.99972, 1, 1, 0.99998, 1, 1, 1, 1, 1, 1, 0.99998, 0.99973, 1.00019, 0.99999, 0.99998, 1, 0.99962, 1.0006, 1.0006, 1, 1, 1.00025, 0.99973, 1, 0.99973, 0.99973, 0.99973, 1.0288, 0.99973, 1.00024, 1.0006, 0.9995, 0.99998, 1, 0.99998, 1.06409, 1.36625, 1.41144, 0.99973, 0.99998, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 0.99973, 1, 0.99973, 0.99973, 0.99973, 0.99897, 0.99897, 1.00003, 1.00003, 0.99984, 0.99968, 0.99968, 0.99973, 1.0006, 1, 0.99998, 1.0006, 1, 0.99999, 1, 0.99973, 1.00002, 0.99998, 0.99973, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.00026, 0.99998, 1, 1.00003, 1.00031, 0.99973, 0.99973, 0.99998, 0.99998, 0.99973, 0.99973, 0.99973, 1.00042, 0.99999, 0.99998, 1, 0.99924, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00034, 1.0006, 1.00015, 1.00027, 0.99999, 0.99999, 1.00035, 0.99999, 0.99999, 0.99977, 0.99924, 0.99924, 0.99924, 0.99924, 0.99924, 1.0006, 0.99924, 0.99924, 1, 1, 1, 1, 0.99924, 0.99924, 0.99962, 1.06311, 0.99924, 1.00024, 1.00003, 1.00031, 1.41144, 0.99973, 1.00003, 0.99924, 0.95317, 0.99924, 1.40579, 0.99999, 0.60299, 1, 1, 1.00003, 1.00267, 1.01487, 1.00003, 1, 1, 0.99973, 0.99973, 1.00041, 0.99973, 0.99973, 0.99973, 1, 1.00031, 0.99973, 1, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.00016, 0.99998, 0.99973, 0.99973, 0.99973, 1.00025, 1.00025, 0.99973, 0.99973, 0.99973, 1.00002, 1.00002, 1.00002, 1.40483, 0.99968, 0.99936, 1, 1.00026, 1.00026, 0.99973, 0.99973, 0.9998, 0.99998, 0.99998, 0.96329, 0.99982, 1.0006, 1, 1.00023, 0.99947, 1.00012, 1.00003, 1.06409, 1.20985, 1.00063, 0.99973, 0.99973, 1.00026, 1.00006, 0.99998, 0.99998, 0.99998, 0.99924, 0.99924, 0.99924, 0.99924, 1.00043, 0.99998, 0.99998, 0.8254, 0.99998, 0.99998, 1.00025, 1.00003, 1.00043, 0.99998, 1.41144, 1, 1, 1, 1, 1, 1, 0.99999, 0.99973, 0.99973, 1.00002, 0.99998, 1.40579, 0.99995, 1, 0.99973, 1.0006, 1, 0.99953, 0.99973, 1.39713, 1.00054, 1.0006, 0.99994, 1.0006, 0.89547, 1.0006, 0.99911, 0.99973, 0.99973, 1.00002, 1.00002, 0.99998, 1, 0.99998, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99955, 1.0006, 0.99998, 1, 1, 1, 1, 1.00026, 1.0006, 0.99998, 1, 1.00001, 0.99954, 0.99973, 0.98332, 1, 1, 0.99998, 1, 0.99991, 1, 1.66475, 1.0006, 1, 1, 1, 1, 0.99973, 1.41144, 1.00036, 1.00036, 1.00036, 1.00036, 0.99973, 0.99973, 1, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 1.0005, 1, 1, 1, 1, 0.99973, 1, 1, 1, 1, 1, 0.99973, 0.99918];
var HelveticaItalicLineHeight = 1.35;
var HelveticaRegularFactors = [0.76116, 1, 1.00001, 1, 1, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.99928, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 0.99977, 0.99977, 0.99977, 0.91621, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.9998, 1.00001, 1.00001, 0.99977, 0.99977, 1.00013, 0.99977, 0.99973, 1.00026, 1.00022, 1.0004, 1.00022, 1.00022, 1.00022, 1.00022, 0.99977, 0.99999, 0.99861, 0.99861, 1, 0.99977, 0.99977, 1.0006, 1.00019, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00055, 1.0006, 1, 1, 1.00001, 1.00001, 1.00001, 0.99973, 0.99973, 1.00005, 0.99973, 0.99973, 0.99973, 0.99973, 0.99999, 0.99999, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00022, 1, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1, 0.99941, 1.00022, 0.99947, 1.00022, 1.00022, 1.00022, 1.00001, 1.00019, 0.99977, 0.99946, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 0.99973, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00022, 1.00001, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 0.99945, 0.99977, 0.99977, 1.00001, 1.00016, 1.00016, 1.00016, 1.00016, 1.00016, 1.00001, 1.00015, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 0.99973, 0.99982, 0.99982, 1, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99928, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 1.00047, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.9996, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99968, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1, 1.00035, 1, 0.99955, 1, 0.99971, 0.99925, 1.00023, 0.99973, 0.99978, 0.99978, 0.99973, 1.00001, 1, 0.99973, 1.00031, 0.99973, 0.99973, 1, 1, 1, 1, 1, 1, 1, 0.99949, 1.00003, 0.99959, 0.99987, 0.99973, 0.99973, 1.0006, 1.0009, 0.99966, 1.41144, 1.00005, 1.00005, 1.0006, 1.0006, 0.99998, 1.0009, 0.99972, 1, 1, 0.99998, 1, 1, 1, 1, 0.99998, 0.99973, 1.00019, 0.99999, 0.99998, 0.99962, 1.0006, 1.0006, 1.00025, 0.99973, 0.99973, 0.99973, 0.99973, 1.04596, 0.99973, 1.00024, 1.00065, 0.9995, 0.99998, 0.99998, 1.06409, 1.36625, 1.41144, 0.99973, 0.99998, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 0.99973, 0.99973, 0.99973, 1.00045, 1.00045, 1.00003, 0.99915, 0.99984, 0.99973, 0.99973, 0.99973, 1.0006, 1, 0.99998, 1.0006, 1, 0.99999, 1, 0.99973, 1.00002, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.00026, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 1.00003, 1.00031, 0.99973, 0.99973, 0.99998, 0.99998, 0.99973, 0.99973, 0.99973, 1.00042, 0.99999, 0.99998, 0.99924, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00034, 1.0006, 1.00015, 1.00027, 0.99999, 0.99999, 1.00035, 0.99999, 0.99999, 0.99977, 0.99924, 0.99924, 0.99924, 0.99924, 0.99924, 1.0006, 0.99924, 0.99924, 1, 1, 1, 1, 0.99924, 0.99924, 1, 1.02572, 0.99924, 1.00005, 1.00003, 1.00031, 1.41144, 0.99973, 1.00003, 0.99924, 0.95317, 0.99924, 1.40579, 0.99999, 0.60299, 1, 1, 1.00003, 1.00267, 0.96499, 1.00003, 1, 1, 0.99973, 0.99973, 0.99999, 0.99973, 0.99973, 0.99973, 1, 1.00031, 0.99973, 1, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.00016, 0.99998, 0.99973, 0.99973, 0.99973, 1.00031, 1.00031, 0.99973, 0.99973, 0.99973, 1.00002, 1.00002, 1.00002, 1.40483, 0.99968, 0.99936, 1, 1.00026, 1.00026, 0.99973, 0.99973, 0.9998, 0.99998, 0.99998, 0.96329, 0.99982, 1.0006, 1, 1.00023, 0.99933, 1.00008, 1.00003, 1.06409, 1.20985, 1.00015, 0.99973, 0.99973, 1.00026, 1.00006, 0.99998, 0.99998, 0.99998, 0.99924, 0.99924, 0.99924, 0.99924, 1.00043, 0.99998, 0.99998, 0.8254, 0.99998, 0.99998, 1.00025, 1.00003, 1.00027, 0.99998, 1.41144, 1, 1, 1, 1, 1, 1, 0.99999, 0.99973, 0.99973, 1.00002, 1.40579, 0.9997, 1, 0.99973, 1.0006, 1, 0.99953, 0.99973, 1.39713, 1.00054, 1.0006, 0.99995, 1.0006, 0.84533, 1.0006, 0.99973, 0.99973, 0.99973, 1.00002, 1.00002, 0.99998, 0.99998, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99955, 1.0006, 0.99998, 1, 1, 1, 1, 1.00026, 1.0006, 0.99998, 1, 1.00001, 0.99561, 0.99973, 1.00073, 1, 1, 0.99998, 1, 1, 1, 1, 1, 0.99991, 1, 1.66475, 1.0006, 1, 1, 1, 1, 1, 0.99973, 1.41144, 1.00023, 1.00023, 1.00023, 1.00023, 0.99973, 0.99973, 1, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 1.00055, 1, 1, 1, 1, 0.99973, 1, 1, 1, 1, 1, 0.99973, 1.00019];
var HelveticaRegularLineHeight = 1.2;
var LiberationSansBoldWidths = [365, 0, 722, 1e3, 1e3, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 722, 722, 722, 719, 667, 667, 667, 667, 667, 667, 667, 667, 667, 723, 667, 667, 853, 722, 906, 722, 556, 611, 778, 601, 778, 778, 778, 778, 722, 604, 354, 354, 604, 722, 722, 278, 785, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 474, 278, 556, 556, 722, 722, 722, 611, 611, 667, 611, 611, 611, 611, 833, 833, 722, 722, 722, 722, 722, 722, 778, 1e3, 778, 778, 778, 778, 778, 778, 778, 802, 838, 778, 825, 778, 778, 778, 667, 821, 722, 809, 778, 722, 722, 722, 722, 667, 667, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 667, 667, 667, 667, 667, 600, 611, 611, 611, 611, 611, 778, 667, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 667, 927, 722, 722, 667, 944, 944, 944, 944, 944, 667, 644, 667, 667, 667, 667, 667, 611, 611, 611, 611, 611, 556, 556, 556, 556, 333, 333, 556, 889, 889, 1e3, 722, 719, 722, 567, 712, 667, 669, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 487, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 622, 556, 618, 615, 417, 635, 556, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 447, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 556, 719, 778, 604, 611, 885, 489, 1115, 556, 615, 615, 556, 722, 333, 556, 549, 556, 556, 1e3, 500, 1e3, 1e3, 500, 500, 500, 584, 584, 389, 975, 556, 611, 278, 280, 610, 708, 389, 389, 333, 333, 333, 333, 280, 350, 556, 556, 333, 333, 222, 556, 556, 556, 556, 333, 556, 576, 604, 333, 333, 656, 333, 278, 333, 222, 737, 556, 333, 611, 556, 556, 719, 611, 400, 606, 510, 333, 333, 465, 549, 729, 708, 556, 333, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 1e3, 556, 1e3, 556, 611, 556, 475, 451, 584, 583, 600, 611, 611, 611, 333, 604, 333, 333, 750, 604, 1e3, 556, 834, 333, 556, 556, 333, 556, 611, 556, 611, 611, 611, 611, 611, 333, 333, 584, 549, 556, 556, 333, 333, 611, 611, 611, 594, 604, 333, 333, 278, 278, 278, 278, 278, 278, 556, 278, 713, 274, 604, 604, 722, 604, 604, 1052, 278, 278, 278, 278, 278, 278, 278, 278, 556, 558, 556, 556, 278, 278, 556, 385, 278, 479, 584, 549, 708, 556, 584, 278, 494, 278, 708, 889, 552, 750, 333, 584, 240, 612, 584, 500, 750, 611, 611, 708, 611, 611, 556, 333, 549, 611, 556, 556, 611, 611, 611, 611, 611, 944, 333, 611, 611, 611, 845, 845, 611, 611, 556, 834, 834, 834, 354, 370, 365, 979, 611, 611, 611, 611, 556, 333, 333, 494, 889, 278, 1e3, 1094, 715, 766, 584, 549, 823, 753, 611, 611, 611, 474, 500, 500, 500, 278, 278, 278, 278, 238, 389, 389, 549, 389, 389, 737, 584, 619, 333, 708, 556, 556, 556, 556, 556, 556, 479, 556, 556, 834, 333, 708, 684, 520, 556, 278, 1021, 531, 556, 713, 917, 333, 446, 333, 479, 333, 541, 611, 556, 834, 834, 333, 333, 333, 1e3, 990, 990, 990, 990, 556, 611, 611, 611, 611, 611, 611, 611, 611, 556, 552, 278, 333, 333, 333, 576, 333, 611, 333, 333, 333, 667, 722, 556, 615, 333, 333, 333, 396, 768, 612, 167, 278, 750, 333, 611, 611, 611, 708, 582, 582, 582, 582, 611, 611, 556, 778, 778, 778, 778, 778, 556, 445, 556, 556, 556, 556, 556, 556, 500, 500, 500, 500, 556, 460];
var LiberationSansBoldItalicWidths = [365, 0, 722, 1e3, 1e3, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 722, 722, 722, 671, 667, 667, 667, 667, 667, 667, 667, 667, 667, 723, 667, 667, 854, 722, 906, 722, 556, 611, 778, 610, 778, 778, 778, 778, 722, 604, 354, 354, 604, 722, 722, 278, 782, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 473, 278, 556, 556, 722, 722, 722, 611, 611, 667, 611, 611, 611, 611, 833, 833, 722, 722, 722, 722, 722, 722, 778, 1e3, 778, 778, 778, 778, 778, 778, 778, 781, 847, 778, 844, 778, 778, 778, 667, 822, 718, 829, 778, 722, 722, 722, 722, 667, 667, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 667, 667, 667, 667, 667, 590, 611, 611, 611, 611, 611, 778, 667, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 667, 930, 722, 722, 667, 944, 944, 944, 944, 944, 667, 657, 667, 667, 667, 667, 667, 611, 611, 611, 611, 611, 556, 556, 556, 556, 333, 333, 556, 889, 889, 1e3, 722, 708, 722, 614, 722, 667, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 575, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 677, 556, 619, 604, 534, 618, 556, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 467, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 556, 719, 778, 611, 611, 885, 516, 1146, 556, 620, 620, 556, 722, 333, 556, 549, 556, 556, 1e3, 500, 999, 1e3, 500, 500, 500, 584, 584, 389, 975, 556, 611, 278, 280, 621, 708, 389, 389, 333, 333, 333, 333, 280, 350, 556, 556, 333, 333, 222, 556, 556, 556, 556, 333, 556, 578, 604, 333, 333, 656, 333, 278, 333, 222, 737, 556, 333, 611, 556, 556, 740, 611, 400, 610, 510, 333, 333, 333, 549, 729, 708, 556, 333, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 1e3, 556, 1e3, 556, 611, 556, 479, 479, 584, 583, 600, 611, 611, 611, 333, 604, 333, 333, 750, 604, 1e3, 556, 834, 333, 556, 556, 333, 556, 611, 556, 611, 611, 611, 611, 611, 333, 333, 584, 549, 556, 556, 333, 333, 611, 611, 611, 594, 604, 333, 333, 278, 278, 278, 278, 278, 278, 556, 278, 713, 274, 604, 604, 722, 604, 604, 1052, 278, 278, 278, 278, 278, 278, 278, 278, 556, 566, 556, 556, 278, 278, 556, 396, 278, 479, 584, 549, 708, 556, 584, 278, 494, 278, 708, 889, 552, 750, 333, 584, 240, 603, 584, 500, 750, 611, 611, 708, 611, 611, 556, 333, 549, 611, 556, 556, 611, 611, 611, 611, 611, 944, 333, 611, 611, 611, 834, 834, 611, 611, 556, 834, 834, 834, 354, 370, 365, 979, 611, 611, 611, 611, 556, 333, 333, 494, 889, 278, 1e3, 1104, 704, 712, 584, 549, 823, 773, 611, 611, 611, 474, 500, 500, 500, 278, 278, 278, 278, 238, 389, 389, 549, 389, 389, 737, 584, 605, 333, 708, 556, 556, 556, 556, 556, 556, 479, 556, 556, 834, 333, 708, 664, 532, 556, 278, 1021, 531, 556, 713, 917, 333, 409, 333, 479, 333, 558, 611, 556, 834, 834, 333, 333, 333, 1e3, 990, 990, 990, 990, 556, 611, 611, 611, 611, 611, 611, 611, 611, 556, 552, 278, 333, 333, 333, 576, 333, 611, 333, 333, 333, 667, 719, 556, 619, 333, 333, 333, 396, 768, 612, 167, 278, 750, 333, 611, 611, 611, 708, 591, 591, 591, 591, 611, 611, 556, 778, 778, 778, 778, 778, 556, 450, 556, 556, 556, 556, 556, 556, 500, 500, 500, 500, 556, 492];
var LiberationSansItalicWidths = [365, 0, 667, 1e3, 1e3, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 722, 722, 722, 722, 722, 722, 667, 722, 722, 722, 671, 667, 667, 667, 667, 667, 667, 667, 667, 667, 723, 667, 667, 789, 722, 846, 722, 556, 611, 778, 570, 778, 778, 778, 778, 722, 604, 354, 354, 604, 722, 722, 278, 733, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 389, 278, 500, 500, 667, 667, 667, 556, 556, 667, 556, 556, 556, 556, 833, 833, 722, 722, 722, 722, 722, 722, 778, 1e3, 778, 778, 778, 778, 778, 778, 778, 761, 775, 778, 794, 778, 778, 778, 667, 837, 725, 831, 778, 722, 722, 722, 722, 667, 667, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 667, 667, 667, 667, 667, 600, 611, 611, 611, 611, 611, 778, 667, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 667, 865, 722, 722, 667, 944, 944, 944, 944, 944, 667, 648, 667, 667, 667, 667, 667, 611, 611, 611, 611, 611, 556, 556, 556, 556, 333, 294, 556, 889, 889, 1e3, 667, 651, 667, 544, 704, 667, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 492, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 639, 556, 562, 522, 493, 553, 556, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 339, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 500, 724, 778, 556, 556, 885, 323, 1083, 556, 570, 570, 556, 667, 278, 556, 549, 556, 556, 1e3, 500, 1e3, 998, 500, 500, 500, 469, 584, 389, 1015, 556, 556, 278, 260, 571, 708, 334, 334, 278, 278, 333, 285, 260, 350, 500, 500, 333, 324, 222, 500, 500, 500, 500, 333, 556, 546, 604, 333, 324, 656, 278, 278, 333, 222, 737, 556, 333, 556, 556, 556, 625, 556, 400, 556, 510, 333, 316, 333, 549, 729, 708, 556, 333, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 1e3, 556, 1e3, 556, 556, 556, 439, 439, 584, 584, 600, 555, 555, 556, 278, 500, 333, 278, 750, 604, 1e3, 556, 834, 333, 556, 556, 333, 556, 556, 500, 556, 556, 556, 556, 611, 333, 294, 584, 549, 556, 556, 333, 333, 556, 556, 556, 594, 604, 333, 398, 222, 278, 278, 278, 278, 278, 444, 278, 713, 274, 604, 604, 719, 604, 604, 1052, 222, 222, 222, 222, 222, 278, 222, 222, 500, 500, 500, 500, 222, 222, 492, 281, 222, 400, 584, 549, 708, 556, 584, 222, 494, 222, 708, 833, 552, 750, 333, 584, 188, 548, 584, 500, 750, 556, 556, 615, 556, 556, 556, 333, 549, 556, 500, 556, 556, 556, 556, 556, 556, 944, 333, 556, 556, 556, 779, 779, 556, 556, 556, 834, 834, 834, 354, 370, 365, 979, 611, 611, 556, 556, 537, 333, 333, 494, 889, 278, 1e3, 1094, 652, 670, 584, 549, 823, 728, 556, 556, 611, 355, 333, 333, 333, 222, 222, 222, 222, 191, 333, 333, 549, 333, 333, 737, 584, 573, 333, 708, 500, 500, 500, 500, 500, 500, 354, 556, 556, 834, 333, 708, 603, 486, 556, 278, 1021, 531, 556, 713, 917, 278, 374, 278, 354, 278, 542, 556, 556, 834, 834, 333, 328, 333, 1e3, 990, 990, 990, 990, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 552, 278, 333, 333, 333, 576, 333, 611, 278, 333, 278, 667, 715, 556, 565, 333, 333, 333, 365, 768, 612, 167, 278, 750, 333, 500, 500, 556, 708, 550, 550, 550, 550, 556, 556, 500, 722, 722, 722, 722, 722, 500, 447, 500, 500, 500, 500, 556, 500, 500, 500, 500, 500, 556, 463];
var LiberationSansRegularWidths = [365, 0, 667, 1e3, 1e3, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 667, 722, 722, 722, 722, 722, 722, 667, 722, 722, 722, 668, 667, 667, 667, 667, 667, 667, 667, 667, 667, 723, 667, 667, 784, 722, 838, 722, 556, 611, 778, 551, 778, 778, 778, 778, 722, 604, 354, 354, 604, 722, 722, 278, 735, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 384, 278, 500, 500, 667, 667, 667, 556, 556, 668, 556, 556, 556, 556, 833, 833, 722, 722, 722, 722, 722, 722, 778, 1e3, 778, 778, 778, 778, 778, 778, 778, 748, 752, 778, 774, 778, 778, 778, 667, 798, 722, 835, 778, 722, 722, 722, 722, 667, 667, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 667, 667, 667, 667, 667, 618, 611, 611, 611, 611, 611, 778, 667, 722, 722, 722, 722, 722, 722, 722, 722, 722, 667, 667, 855, 722, 722, 667, 944, 944, 944, 944, 944, 667, 650, 667, 667, 667, 667, 667, 611, 611, 611, 611, 611, 556, 556, 556, 556, 333, 556, 889, 889, 1e3, 667, 656, 667, 542, 677, 667, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 489, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 635, 556, 573, 531, 365, 583, 556, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 411, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 500, 719, 778, 552, 556, 885, 323, 1073, 556, 578, 578, 556, 667, 278, 556, 549, 556, 556, 1e3, 500, 1e3, 1e3, 500, 500, 500, 469, 584, 389, 1015, 556, 556, 278, 260, 575, 708, 334, 334, 278, 278, 333, 260, 350, 500, 500, 333, 500, 500, 500, 500, 333, 556, 525, 604, 333, 656, 278, 278, 737, 556, 556, 556, 556, 615, 556, 400, 557, 510, 333, 333, 549, 729, 708, 556, 333, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 1e3, 556, 1e3, 556, 556, 556, 446, 446, 584, 583, 600, 556, 556, 556, 278, 500, 333, 278, 750, 604, 1e3, 556, 834, 556, 556, 556, 556, 500, 556, 556, 556, 556, 611, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285, 333, 584, 549, 556, 556, 333, 333, 556, 556, 556, 594, 604, 333, 222, 278, 278, 278, 278, 278, 444, 278, 713, 274, 604, 604, 719, 604, 604, 1052, 222, 222, 222, 222, 222, 278, 222, 222, 500, 500, 500, 500, 222, 222, 500, 292, 222, 334, 584, 549, 708, 556, 584, 222, 494, 222, 708, 833, 552, 750, 333, 584, 188, 576, 584, 500, 750, 556, 556, 604, 556, 556, 556, 333, 549, 556, 500, 556, 556, 556, 556, 556, 556, 944, 333, 556, 556, 556, 781, 781, 556, 556, 556, 834, 834, 834, 354, 370, 365, 979, 611, 611, 556, 556, 537, 333, 333, 494, 889, 278, 1e3, 1094, 648, 690, 584, 549, 823, 713, 556, 556, 611, 355, 333, 333, 333, 222, 222, 222, 222, 191, 333, 333, 549, 333, 333, 737, 584, 569, 333, 708, 500, 500, 500, 500, 500, 500, 354, 556, 556, 834, 708, 617, 482, 556, 278, 1021, 531, 556, 713, 917, 278, 395, 278, 375, 278, 556, 556, 556, 834, 834, 333, 333, 1e3, 990, 990, 990, 990, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 552, 278, 333, 333, 333, 576, 333, 611, 278, 333, 278, 667, 722, 556, 559, 333, 333, 333, 333, 333, 333, 333, 365, 768, 612, 167, 278, 750, 333, 333, 500, 500, 556, 708, 547, 547, 547, 547, 556, 556, 500, 722, 722, 722, 722, 722, 500, 448, 500, 500, 500, 500, 556, 500, 500, 500, 500, 500, 556, 441];
var MyriadProBoldFactors = [1.36898, 1, 0.90838, 0.868, 0.868, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.91945, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.83637, 0.83637, 0.82391, 0.82391, 0.82391, 0.82391, 0.82391, 0.82391, 0.91905, 0.96376, 0.96376, 0.97484, 0.90157, 0.80061, 0.80061, 0.80061, 0.80061, 0.80061, 0.80061, 0.80061, 0.80061, 0.80061, 0.95417, 0.80061, 0.80061, 0.75261, 0.95407, 0.87992, 0.97484, 0.99793, 0.86275, 0.8768, 0.8019, 0.8768, 0.8768, 1, 0.8768, 0.95407, 1, 1, 1, 1, 0.97069, 0.95407, 1.0258, 0.887, 1.0258, 1.0258, 1.0258, 1.0258, 1.0258, 1.0258, 1.0258, 1.0258, 1.0258, 1.0258, 0.82976, 1.0258, 0.73901, 0.73901, 0.85022, 0.85022, 1, 0.83655, 0.83655, 0.97153, 0.83655, 1, 0.83655, 0.84638, 1.0156, 1.0156, 0.95546, 0.95546, 0.95546, 1, 0.95546, 0.95546, 0.92179, 0.936, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 0.92796, 0.97268, 0.92179, 0.96034, 0.92179, 0.92179, 0.92179, 0.87107, 0.95638, 0.92361, 0.91709, 0.92179, 0.82114, 0.82114, 0.82114, 1, 0.87107, 0.8096, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.8096, 0.8096, 1, 0.8096, 1, 0.96318, 0.89713, 0.89713, 0.89713, 0.89713, 1, 0.92436, 0.86958, 0.94438, 0.94438, 0.94438, 0.94438, 0.94438, 0.94438, 0.94438, 0.94438, 0.94438, 0.93704, 0.93704, 0.83689, 0.94438, 0.94438, 0.95353, 0.94083, 0.94083, 0.94083, 0.94083, 0.94083, 0.91905, 0.89192, 0.90406, 0.90406, 0.90406, 0.90406, 0.90406, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 0.94938, 0.94938, 0.94938, 0.94938, 0.90088, 1, 0.94938, 0.9031, 0.9031, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94938, 0.94836, 0.94836, 0.94938, 0.93884, 0.83181, 0.94938, 1.08595, 0.94938, 0.94938, 1, 1, 1, 1, 1, 1, 1, 1.02058, 1.02058, 1.16661, 0.78966, 0.94938, 0.97898, 1.18777, 1.01149, 0.96174, 1, 0.80687, 0.80687, 0.94292, 0.94292, 0.90088, 1, 1.01149, 0.96544, 0.81093, 0.81093, 0.90088, 1, 1, 0.81093, 0.81093, 0.81093, 0.81093, 0.90088, 0.99793, 0.87548, 1, 0.90088, 1, 1, 0.78076, 0.93582, 1, 1, 0.91882, 0.99793, 1, 0.97571, 0.94219, 0.94219, 0.84313, 0.97571, 0.89022, 0.9498, 1, 0.90088, 1, 0.9358, 1.08595, 1, 1, 0.99793, 0.90088, 0.98621, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.99793, 1, 1, 0.94938, 1, 0.89903, 0.95933, 0.94938, 0.98607, 1.0373, 1.02058, 1, 1.36145, 0.95933, 0.95933, 0.93969, 0.80479, 1, 0.80479, 1.024, 1, 1, 1, 0.99793, 1, 1, 0.99793, 0.99793, 1, 1, 0.9577, 0.92601, 0.9577, 0.9577, 1, 0.9577, 0.98225, 0.90088, 1, 1.02058, 1.08595, 0.8361, 0.8361, 0.81079, 0.81079, 0.95933, 0.95933, 0.95933, 1, 1, 0.90088, 1, 0.98621, 0.98621, 0.98621, 0.98621, 0.98621, 0.98621, 1.01591, 0.98621, 1.05486, 1.30692, 1, 1, 1, 1, 1, 1, 0.98621, 1.0078, 1.0078, 1.0078, 1.0078, 0.98621, 1.0474, 1.0474, 0.97455, 0.98275, 1, 0.97455, 0.98981, 0.98981, 0.9314, 0.73977, 1, 0.73903, 1.02058, 1.08595, 1, 1, 1.02058, 1, 1.16161, 1.033, 1, 0.9672, 0.54324, 1, 1, 1.02058, 1, 0.95617, 1.02058, 1, 1, 0.95933, 0.95933, 0.8271, 0.95933, 1, 0.99793, 1, 1.08595, 0.95933, 0.91701, 0.98894, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 0.91964, 0.90088, 0.9446, 0.9446, 0.9446, 0.86774, 0.86774, 0.9446, 0.9446, 0.99793, 1, 0.99642, 0.99642, 1, 1.0213, 1.05686, 1, 0.9446, 0.9446, 0.9446, 0.97898, 0.97455, 0.94292, 0.94292, 1.17173, 0.9897, 0.93582, 1.285, 1, 0.99394, 0.78367, 1.02058, 1.08595, 0.80535, 0.96361, 0.97407, 0.72851, 0.72851, 0.83734, 0.918, 0.908, 0.908, 0.93582, 1, 0.93582, 0.93582, 0.86209, 0.97646, 0.97646, 1.0732, 0.97646, 1, 0.62295, 1, 0.9553, 0.90088, 1, 0.78036, 0.78036, 0.78036, 1, 0.78036, 1, 1, 1.00872, 0.99793, 1, 1, 1, 0.86832, 1, 0.99793, 1.19137, 1, 1, 0.99793, 0.76169, 1, 1.10208, 1.0128, 1.10208, 0.77452, 1, 1.05453, 0.97898, 0.99793, 1, 0.99642, 0.90088, 1, 0.90989, 0.65, 1, 1, 1, 1, 0.99793, 0.95442, 0.95442, 0.95442, 0.95442, 0.95442, 0.95442, 0.95442, 0.95442, 0.89903, 1, 0.72706, 0.96694, 1, 1, 1, 1, 0.89713, 1.10208, 0.90088, 0.78076, 1, 1, 1, 1, 0.96694, 1, 1, 1, 1, 1, 0.74854, 0.93582, 1, 1, 1, 1, 0.95442, 1, 0.95871, 0.95871, 0.95871, 0.95871, 0.95442, 0.95442, 0.95298, 0.97579, 0.97579, 0.97579, 0.97579, 0.97579, 0.9332, 1.05993, 0.94039, 0.94039, 0.94039, 0.94039, 0.99793, 0.94039, 0.938, 0.938, 0.938, 0.938, 0.99793, 0.95776];
var MyriadProBoldLineHeight = 1.2;
var MyriadProBoldItalicFactors = [1.36898, 1, 0.85576, 0.845, 0.845, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.80591, 0.80591, 0.80729, 0.80729, 0.80729, 0.80729, 0.80729, 0.80729, 0.85308, 0.94299, 0.94299, 0.95961, 0.94729, 0.77512, 0.77512, 0.77512, 0.77512, 0.77512, 0.77512, 0.77512, 0.77512, 0.77512, 0.92098, 0.77512, 0.77512, 0.66862, 0.92222, 0.7927, 0.95961, 0.97276, 0.83655, 0.86523, 0.7805, 0.86523, 0.86523, 1, 0.86523, 0.92222, 1, 1, 1, 1, 0.92222, 0.92222, 0.98621, 0.86036, 0.98621, 0.98621, 0.98621, 0.98621, 0.98621, 0.98621, 0.98621, 0.98621, 0.98621, 0.98621, 0.69323, 0.98621, 0.71743, 0.71743, 0.81698, 0.81698, 1, 0.79726, 0.79726, 0.92655, 0.79726, 1, 0.79726, 0.81691, 0.98558, 0.98558, 0.92222, 0.92222, 0.92222, 1, 0.92222, 0.92222, 0.90637, 0.909, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 0.92346, 0.89711, 0.90637, 0.88127, 0.90251, 0.90251, 0.90637, 0.83809, 0.93157, 0.90976, 0.83392, 0.90637, 0.80729, 0.80729, 0.80729, 1, 0.83809, 0.76463, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.76463, 0.76463, 1, 0.76463, 1, 0.94523, 0.86275, 0.86275, 0.86275, 0.86275, 1, 0.90637, 0.83659, 0.90699, 0.90699, 0.90699, 0.90699, 0.90699, 0.90699, 0.90699, 0.90699, 0.90699, 0.83509, 0.83509, 0.72459, 0.90699, 0.90699, 0.91605, 0.9154, 0.9154, 0.9154, 0.9154, 0.9154, 0.85308, 0.85359, 0.85458, 0.85458, 0.85458, 0.85458, 0.85458, 0.90531, 0.90531, 0.90531, 0.90531, 0.90531, 0.99613, 0.99613, 0.99613, 0.99613, 1.18616, 1, 0.99613, 0.85811, 0.85811, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99613, 0.92886, 0.92886, 0.99613, 0.92222, 0.80178, 0.99613, 1.08595, 0.99613, 0.99613, 1, 1, 1, 1, 1, 1, 1, 1.02058, 1.02058, 1.16148, 0.76813, 0.99613, 0.91677, 1.21296, 0.8578, 0.90557, 1, 0.80687, 0.80687, 0.94292, 0.94292, 1.18616, 1, 0.8578, 0.95973, 0.78216, 0.78216, 1.18616, 1, 1, 0.78216, 0.78216, 0.78216, 0.78216, 1.18616, 0.97276, 0.81539, 1, 1.18616, 1, 1, 0.78076, 0.93582, 1, 1, 0.91339, 0.97276, 1, 0.91677, 0.9332, 0.9332, 0.76783, 0.91677, 0.89022, 0.90276, 1, 1.18616, 1, 1.30628, 1.08595, 1, 1, 0.97276, 1.18616, 0.95381, 0.90083, 0.90083, 0.90083, 0.90083, 0.90083, 0.90083, 0.90083, 0.90083, 0.97276, 1, 1, 0.90083, 1, 0.89903, 0.92168, 0.90083, 0.91324, 0.91324, 1.02058, 1, 1.36145, 0.92168, 0.92168, 0.9135, 0.80779, 1, 0.80779, 0.98796, 1, 1, 1, 0.97276, 1, 1, 0.97276, 0.97276, 1, 1, 0.9135, 0.86847, 0.9135, 0.9135, 1, 0.9135, 0.94951, 1.18616, 1, 1.02058, 1.08595, 0.82891, 0.82711, 0.80479, 0.80178, 0.92168, 0.92168, 0.92168, 1, 1, 1.18616, 1, 0.95381, 0.95381, 0.95381, 0.95381, 0.95381, 0.95381, 0.97096, 0.95381, 1.05486, 1.23026, 1, 1, 1, 1, 1, 1, 0.95381, 0.95381, 0.95381, 0.95381, 0.95381, 0.95381, 0.98981, 0.98981, 0.95298, 0.9224, 1, 0.95298, 0.95381, 0.95381, 0.85408, 0.6894, 1, 0.74321, 1.02058, 1.08595, 1, 1, 1.02058, 1, 1.20006, 1.0006, 1, 0.93459, 0.71526, 1, 1, 1.02058, 1, 0.92699, 1.02058, 1, 1, 0.92168, 0.92168, 0.79464, 0.92168, 1, 0.97276, 1, 1.08595, 0.92168, 0.86847, 0.97276, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 0.87514, 1.18616, 0.91513, 0.91513, 0.91513, 0.85923, 0.85923, 0.91513, 0.91513, 0.97276, 1, 0.99043, 0.99043, 1, 1.08074, 1.04864, 1, 0.91677, 0.91677, 0.91513, 0.92004, 0.96736, 0.94292, 0.94292, 1.14542, 0.97733, 0.93582, 1.26, 1, 0.97355, 0.80487, 1.02058, 1.08595, 0.79199, 0.89398, 0.91677, 0.71541, 0.71541, 0.81625, 0.896, 0.896, 0.896, 0.91782, 1, 0.91782, 0.91782, 0.83266, 0.95077, 0.95077, 1.03493, 0.95077, 1, 0.55509, 1, 0.93481, 1.18616, 1, 0.748, 0.748, 0.748, 1, 0.748, 1, 1, 0.99973, 0.97276, 1, 1, 1, 0.88159, 1, 0.97276, 1.17337, 1, 1, 0.97276, 0.78694, 1, 1.04502, 1.05214, 1.04502, 0.72651, 1, 0.99531, 0.92332, 0.97276, 1, 0.99043, 1.18616, 1, 1.00899, 0.698, 1, 1, 1, 1, 0.97276, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89903, 1, 0.66227, 0.96694, 1, 1, 1, 1, 0.86275, 1.04502, 1.18616, 0.78076, 1, 1, 1, 1, 0.96694, 1, 1, 1, 1, 1, 0.85633, 0.93582, 1, 1, 1, 1, 0.91677, 1, 0.90646, 0.90646, 0.90646, 0.90646, 0.91677, 0.91677, 0.92061, 0.94236, 0.94236, 0.94236, 0.94236, 0.94236, 0.89544, 1.0051, 0.89364, 0.89364, 0.89364, 0.89364, 0.97276, 0.89364, 0.9, 0.9, 0.9, 0.9, 0.97276, 0.86842];
var MyriadProBoldItalicLineHeight = 1.2;
var MyriadProItalicFactors = [1.36898, 1, 0.85158, 0.773, 0.773, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.77812, 0.77812, 0.76852, 0.76852, 0.76852, 0.76852, 0.76852, 0.76852, 0.78112, 0.89591, 0.89591, 0.90561, 0.88836, 0.70466, 0.70466, 0.70466, 0.70466, 0.70466, 0.70466, 0.70466, 0.70466, 0.70466, 0.87396, 0.70466, 0.70466, 0.62264, 0.86822, 0.7646, 0.90561, 0.88465, 0.76125, 0.80094, 0.76449, 0.80094, 0.80094, 1, 0.80094, 0.86822, 1, 1, 1, 1, 0.86822, 0.86822, 0.83864, 0.81402, 0.83864, 0.83864, 0.83864, 0.83864, 0.83864, 0.83864, 0.83864, 0.83864, 0.83864, 0.83864, 0.65351, 0.83864, 0.728, 0.728, 0.77212, 0.77212, 1, 0.79475, 0.79475, 0.85308, 0.79475, 1, 0.79475, 0.80553, 0.93637, 0.93637, 0.87514, 0.87514, 0.87514, 1, 0.87514, 0.87514, 0.8588, 0.867, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 0.89386, 0.89947, 0.8588, 0.86026, 0.85751, 0.85751, 0.8588, 0.76013, 0.82565, 0.85701, 0.77899, 0.8588, 0.72421, 0.72421, 0.72421, 1, 0.76013, 0.69866, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.69866, 0.69866, 1, 0.69866, 1, 0.89058, 0.77598, 0.77598, 0.77598, 0.77598, 1, 0.8588, 0.76013, 0.85991, 0.85991, 0.85991, 0.85991, 0.85991, 0.85991, 0.85991, 0.85991, 0.85991, 0.8156, 0.8156, 0.69461, 0.85991, 0.85991, 0.80811, 0.87832, 0.87832, 0.87832, 0.87832, 0.87832, 0.78112, 0.82352, 0.77512, 0.77512, 0.77512, 0.77512, 0.77512, 0.8562, 0.8562, 0.8562, 0.8562, 0.8562, 0.93859, 0.93859, 0.93859, 0.93859, 1.15012, 1, 0.93859, 0.8075, 0.8075, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93859, 0.9486, 0.9486, 0.93859, 0.88307, 0.77025, 0.93859, 1.08595, 0.93859, 0.93859, 1, 1, 1, 1, 1, 1, 1, 1.27014, 1.02058, 1.06383, 0.70926, 0.93859, 0.94399, 1.18417, 0.83537, 0.93298, 1, 0.85034, 0.85034, 1.0222, 1.0222, 1.15012, 1, 0.83537, 0.79121, 0.846, 0.846, 1.15012, 1, 1, 0.846, 0.846, 0.846, 0.846, 1.15012, 0.88465, 0.77487, 1, 1.15012, 1, 1, 0.75945, 0.75945, 1, 1, 0.9161, 0.88465, 1, 0.94399, 0.86847, 0.86847, 0.8544, 0.94399, 0.79519, 0.93942, 1, 1.15012, 1, 1.03901, 1.08595, 1, 1, 0.88465, 1.15012, 0.82424, 0.81453, 0.81453, 0.81453, 0.81453, 0.81453, 0.81453, 0.81453, 0.81453, 0.88465, 1, 1, 0.81453, 1, 0.89903, 0.96017, 0.81453, 0.92388, 0.92388, 1.02058, 1, 1.36145, 0.96186, 0.96186, 0.9278, 0.84943, 1, 0.70869, 1.0186, 1, 1, 1, 0.88465, 1, 1, 0.88465, 0.88465, 1, 1, 0.94219, 0.878, 0.94219, 0.94219, 1, 0.94219, 0.88075, 1.15012, 1, 1.02058, 1.08595, 0.73541, 0.73361, 0.73572, 0.73572, 0.96017, 0.96017, 0.96017, 1, 1, 1.15012, 1, 1.03075, 0.82424, 0.82424, 0.82424, 0.82424, 0.82424, 1.02738, 0.82424, 1.02119, 1.06233, 1, 1, 1, 1, 1, 1, 1.03075, 1.03075, 1.03075, 1.03075, 1.03075, 0.82424, 1.02175, 1.02175, 0.912, 0.922, 1, 0.912, 1.03075, 1.03075, 0.88787, 0.83911, 1, 0.66266, 1.02058, 1.08595, 1, 1, 1.02058, 1, 1.05233, 1.06676, 1, 0.96998, 0.69353, 1, 1, 1.02058, 1, 0.95829, 1.02058, 1, 1, 0.96017, 0.96017, 0.86865, 0.96017, 1, 0.88465, 1, 1.08595, 0.96017, 0.88, 0.88465, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.84759, 1.15012, 0.93859, 0.93859, 0.93859, 0.86799, 0.86799, 0.93859, 0.93859, 0.88465, 1, 0.9005, 0.9005, 1, 0.94565, 0.9446, 1, 0.8562, 0.8562, 0.93859, 0.94399, 0.91974, 0.85283, 0.85283, 1.04828, 0.86936, 0.75945, 1.124, 1, 0.93969, 0.78815, 1.02058, 1.08595, 0.74948, 0.85769, 0.94399, 0.69046, 0.62864, 0.85639, 1.027, 1.027, 1.027, 0.87321, 1, 0.87321, 0.87321, 0.86948, 0.95493, 0.95493, 0.98391, 0.95493, 1, 0.53609, 1, 0.93758, 1.15313, 1, 0.746, 0.746, 0.746, 1, 0.746, 1, 1, 0.90083, 0.88465, 1, 1, 1, 0.89217, 1, 0.88465, 1.17337, 1, 1, 0.88465, 0.75187, 1, 1.12658, 1.03737, 1.12658, 0.88417, 1, 0.95119, 0.94578, 0.88465, 1, 0.9005, 1.15012, 1, 1.08106, 0.669, 1, 1, 1, 1, 0.88465, 0.94578, 0.94578, 0.94578, 0.94578, 0.94578, 0.94578, 0.94578, 0.94578, 0.89903, 1, 0.65507, 0.9219, 1, 1, 1, 1, 0.77598, 1.12658, 1.15012, 0.75945, 1, 1, 1, 1, 0.9219, 1, 1, 1, 1, 1, 0.85034, 0.75945, 1, 1, 1, 1, 0.94578, 1, 0.91123, 0.91123, 0.91123, 0.91123, 0.94578, 0.94578, 0.91, 0.979, 0.979, 0.979, 0.979, 0.979, 0.882, 0.93559, 0.882, 0.882, 0.882, 0.882, 0.88465, 0.882, 0.83, 0.83, 0.83, 0.83, 0.88465, 0.84596];
var MyriadProItalicLineHeight = 1.2;
var MyriadProRegularFactors = [1.36898, 1, 0.91755, 0.788, 0.788, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.92138, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.8126, 0.8126, 0.80314, 0.80314, 0.80314, 0.80314, 0.80314, 0.80314, 0.85608, 0.92222, 0.92222, 0.92915, 0.92819, 0.73764, 0.73764, 0.73764, 0.73764, 0.73764, 0.73764, 0.73764, 0.73764, 0.73764, 0.90991, 0.73764, 0.73764, 0.7154, 0.90284, 0.86169, 0.92915, 0.92241, 0.79726, 0.83051, 0.81884, 0.83051, 0.83051, 1, 0.83051, 0.90284, 1, 1, 1, 1, 0.90976, 0.90284, 0.86023, 0.82873, 0.86023, 0.86023, 0.86023, 0.86023, 0.86023, 0.86023, 0.86023, 0.86023, 0.86023, 0.86023, 0.80513, 0.86023, 0.74, 0.74, 0.8126, 0.8126, 1, 0.84869, 0.84869, 0.91172, 0.84869, 1, 0.84869, 0.85588, 0.96518, 0.96518, 0.91115, 0.91115, 0.91115, 1, 0.91115, 0.91115, 0.8858, 0.894, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 0.94307, 0.98612, 0.8858, 0.94007, 0.8858, 0.8858, 0.8858, 0.79761, 0.89992, 0.87791, 0.81992, 0.8858, 0.74498, 0.74498, 0.74498, 1, 0.79761, 0.73914, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.73914, 0.73914, 1, 0.73914, 1, 0.89297, 0.81363, 0.81363, 0.81363, 0.81363, 1, 0.8858, 0.79611, 0.89591, 0.89591, 0.89591, 0.89591, 0.89591, 0.89591, 0.89591, 0.89591, 0.89591, 0.88157, 0.88157, 0.82528, 0.89591, 0.89591, 0.83659, 0.89633, 0.89633, 0.89633, 0.89633, 0.89633, 0.85608, 0.83089, 0.8111, 0.8111, 0.8111, 0.8111, 0.8111, 0.90531, 0.90531, 0.90531, 0.90531, 0.90531, 0.86667, 0.86667, 0.86667, 0.86667, 0.90088, 0.86667, 0.86936, 0.86936, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.86667, 0.95308, 0.95308, 0.86667, 0.90706, 0.78105, 0.86667, 1.08595, 0.86667, 0.86667, 1, 1, 1, 1, 1, 1, 1, 1.27014, 1.02058, 1.0664, 0.72601, 0.86667, 1.0231, 1.22736, 0.92006, 0.97358, 1, 0.85034, 0.85034, 1.0222, 1.0222, 0.90088, 0.92006, 0.80549, 0.896, 0.896, 0.90088, 0.896, 0.896, 0.896, 0.896, 0.90088, 0.92241, 0.87064, 1, 0.90088, 1, 0.74505, 0.74505, 0.91882, 0.92241, 1.01411, 0.89903, 0.89903, 0.93372, 1.01411, 0.79519, 0.98088, 1, 0.90088, 1.03901, 1.08595, 1, 1, 0.92241, 0.90088, 0.84224, 0.90083, 0.90083, 0.90083, 0.90083, 0.90083, 0.90083, 0.90083, 0.90083, 0.92241, 1, 0.90083, 1, 0.89903, 0.99793, 0.90083, 0.98699, 0.98699, 1.02058, 1, 1.36145, 0.99793, 0.99793, 0.97276, 0.82784, 1, 0.69067, 1.05099, 1, 1, 1, 0.92241, 1, 0.92241, 0.92241, 1, 1.00512, 0.928, 1.00512, 1.00512, 1, 1.00512, 0.89713, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90088, 1.02058, 1.08595, 0.75339, 0.75339, 0.76575, 0.76575, 0.99793, 0.99793, 0.99793, 1, 1, 0.90088, 1.05326, 0.84224, 0.84224, 0.84224, 0.84224, 0.84224, 1.07469, 0.84224, 1.02119, 1.1536, 1, 1, 1, 1, 1, 1, 1.05326, 1.06226, 1.06226, 1.06226, 1.06226, 0.84224, 1.09377, 1.09377, 0.938, 0.986, 1, 0.938, 1.06226, 1.06226, 0.944, 0.83704, 1, 0.81441, 1.02058, 1.08595, 1, 1, 1.02058, 1, 1.05638, 1.08927, 1, 1.00119, 0.54324, 1, 1, 1.02058, 1, 0.95978, 1.02058, 1, 1, 0.99793, 0.99793, 0.91887, 0.99793, 1, 0.92241, 1, 1.08595, 0.99793, 0.938, 0.89364, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 0.91434, 0.90088, 0.98714, 0.98714, 0.98714, 0.88888, 0.88888, 0.98714, 0.98714, 0.92241, 1, 0.91009, 0.91009, 1, 0.93484, 0.97198, 1, 0.89876, 0.89876, 0.98714, 1.0231, 0.95325, 0.85283, 0.85283, 1.07257, 0.89073, 0.74505, 1.156, 1, 0.99007, 0.80442, 1.02058, 1.08595, 0.74705, 0.91879, 1.01231, 0.73002, 0.66466, 0.94935, 1.06904, 1.06304, 1.06304, 0.93173, 1, 0.93173, 0.93173, 0.98472, 0.98196, 0.98196, 1.024, 0.98196, 1, 0.56866, 1, 0.98972, 0.90088, 1, 0.792, 0.792, 0.792, 1, 0.792, 1, 1, 0.9332, 0.92241, 1, 1, 0.89762, 1, 0.92241, 1.23456, 1, 1, 0.92241, 0.71119, 1, 1.19137, 1.04552, 1.19137, 0.904, 1, 0.96017, 1.0231, 0.92241, 1, 0.91009, 0.90088, 0.90388, 0.619, 1, 1, 1, 1, 0.92241, 0.99074, 0.99074, 0.99074, 0.99074, 0.99074, 0.99074, 0.99074, 0.99074, 0.89903, 1, 0.76305, 0.9219, 1, 1, 1, 1, 0.81363, 1.19137, 0.90088, 0.74505, 1, 1, 1, 1, 0.9219, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.72458, 0.74505, 1, 1, 1, 1, 1, 0.99074, 1, 0.95817, 0.95817, 0.95817, 0.95817, 0.99074, 0.99074, 0.962, 1.01915, 1.01915, 1.01915, 1.01915, 1.01915, 0.926, 0.96705, 0.942, 0.942, 0.942, 0.942, 0.92241, 0.942, 0.856, 0.856, 0.856, 0.856, 0.92241, 0.92761];
var MyriadProRegularLineHeight = 1.2;
var SegoeuiBoldFactors = [1.76738, 1, 0.97363, 0.93506, 0.93506, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 1.01149, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.88776, 0.88776, 0.8641, 0.8641, 0.8641, 0.8641, 0.8641, 0.8641, 0.98243, 1.02096, 1.02096, 1.02096, 0.97826, 0.79795, 0.79795, 0.79795, 0.79795, 0.79795, 0.79795, 0.79795, 0.79795, 0.79795, 1.09251, 0.79795, 0.79795, 0.7676, 1.06085, 0.98167, 1.02096, 1.03424, 0.85132, 0.914, 0.85134, 0.914, 0.914, 1, 0.914, 1.06085, 1, 0.99862, 0.99862, 1, 1.06085, 1.06085, 1.1406, 0.97138, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.01134, 1.1406, 0.8007, 0.8007, 0.89858, 0.89858, 1, 0.83693, 0.83693, 1.0388, 0.83693, 1, 0.83693, 0.83693, 1.14889, 1.14889, 1.09398, 1.09398, 1.09398, 1, 1.09398, 1.09398, 0.97489, 0.93994, 0.97426, 0.97489, 0.97426, 0.97426, 0.97426, 0.97489, 0.97489, 0.95493, 1.03089, 0.97489, 1.02546, 0.97489, 0.97489, 0.97426, 0.92094, 0.99346, 1.0595, 1.02112, 0.97489, 0.90399, 0.90399, 0.90399, 1, 0.92094, 0.84041, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.84041, 0.84041, 0.84041, 0.84041, 1, 0.94793, 0.95923, 0.95923, 0.95923, 0.95923, 1, 0.97489, 0.92094, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.90996, 0.84097, 1.00135, 1.00135, 1, 1.06467, 1.06467, 1.06467, 1.06467, 1.06467, 0.98243, 0.86039, 0.90996, 0.90996, 0.90996, 0.90996, 0.90996, 0.99361, 0.99361, 0.99361, 0.99361, 0.99361, 0.96752, 0.96752, 0.96752, 0.96752, 0.91056, 1, 0.96752, 0.93136, 0.93136, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96752, 1.03574, 1.03574, 0.96752, 1.17647, 0.81525, 0.96752, 1.29004, 0.96752, 0.96752, 0.86182, 0.94434, 0.86279, 0.86279, 0.94434, 1, 1, 1.2107, 1.2107, 1.16939, 0.97847, 0.96752, 1.01519, 1.56942, 1.16579, 1.0192, 1, 0.94856, 0.94856, 1.1085, 1.1085, 1.03959, 1, 1.16579, 1.20642, 0.86304, 0.86304, 1.15103, 1, 1, 0.86304, 0.86304, 0.86304, 0.86304, 0.64663, 1.03424, 0.96268, 1.42603, 1.15103, 1, 1.04315, 0.81378, 0.9754, 1, 1, 1.18622, 1, 1, 1.01359, 0.73047, 0.73047, 1.03057, 1.03517, 0.94994, 1.00886, 1.34163, 1.3871, 1, 0.87815, 1.28826, 1, 1, 1.03424, 0.75953, 1.02285, 0.97278, 0.97278, 0.97278, 0.97278, 0.97278, 0.97278, 0.97278, 0.97278, 1.03424, 1, 0.91211, 0.97278, 1, 0.89903, 0.99041, 0.97278, 0.97531, 1.02597, 1.2107, 1.21172, 1, 1.0008, 1.0008, 0.97122, 0.9824, 0.96039, 0.9824, 1.15103, 1, 1.42603, 1, 1.03424, 1.15749, 1, 1.03424, 1.03424, 1, 0.93503, 1.01359, 1.01932, 1.01359, 1.01359, 1, 1.01359, 1.02798, 0.94282, 1, 1.2107, 1.29004, 1.04478, 1.04478, 1.03372, 1.03372, 0.98561, 1.00879, 0.98561, 1.15296, 1, 1.21994, 1, 1.02285, 1.02285, 1.02285, 1.02285, 1.02285, 1.02285, 1.08692, 1.02285, 1.13973, 2.10339, 1, 1, 0.9716, 1.42603, 1.42603, 1, 1.02285, 1.18102, 1.18102, 1.18102, 1.18102, 1.02285, 1.02285, 1.02285, 1.00527, 1.02277, 1, 1.00527, 1.02285, 1.02285, 0.98683, 0.9455, 1, 0.90418, 1.2107, 1.29004, 1, 1.03424, 1.2107, 1.07733, 1.18874, 1.13005, 1, 1.0302, 0.75155, 1, 1, 1.2107, 1.222, 1.0016, 1.2107, 1, 1, 0.99041, 0.99041, 0.96692, 0.99041, 1, 1.03424, 1, 1.29004, 0.99041, 0.99561, 1.06497, 1.0008, 1, 1.0008, 1, 1, 0.97931, 0.79912, 1, 1.0008, 1.0008, 0.98439, 0.98439, 1.0008, 1.0008, 1.03424, 1.15749, 1.15749, 1.14169, 0.99862, 1.10818, 1.24866, 0.69825, 1.0008, 1.0008, 1, 1.01519, 0.91572, 1.1085, 1.1085, 1.16897, 0.97529, 0.9754, 1.25635, 1.19687, 1.04983, 0.90434, 1.2107, 1.28826, 0.96085, 1.0499, 1.01359, 0.71703, 0.71703, 1.04016, 0.98633, 0.98633, 0.98633, 1.04394, 1.04394, 1.04394, 1.04394, 1.23203, 1.02258, 1.02258, 1.18416, 1.02258, 1, 1.18622, 1, 0.99921, 0.81378, 1, 0.79104, 0.79104, 0.79104, 0.79104, 0.79104, 1, 1.02956, 0.8727, 1.03424, 1.10948, 1, 1, 0.8965, 0.93803, 1.03424, 1.59578, 1, 1.2886, 1.03424, 0.90137, 1, 1.16862, 1.23085, 1.16862, 1.07034, 1, 1.13189, 1.01519, 1.03424, 1.15749, 1.17389, 1.15103, 1, 0.95161, 0.771, 0.87025, 0.87025, 0.87025, 0.87025, 1.03424, 0.99041, 0.99041, 0.99041, 0.99041, 0.99041, 0.99041, 0.99041, 0.99041, 0.74627, 0.75155, 0.99297, 1.21408, 1.21408, 1.21408, 1, 1.18328, 0.95923, 1.16862, 1.01173, 0.81378, 0.79795, 1.09466, 0.97278, 1.02065, 1, 1.21408, 1.24633, 1.12454, 1, 1, 1, 0.9754, 1, 1, 1.09193, 1.09193, 0.99041, 1, 1.06628, 1.06628, 1.06628, 1.06628, 0.99041, 0.99041, 0.97454, 1.02511, 1.02511, 1.02511, 1.02511, 1.02511, 0.99298, 1.07237, 0.96752, 0.96752, 0.96752, 0.96752, 1.03424, 0.96752, 0.95801, 0.95801, 0.95801, 0.95801, 1.03424, 1.0106];
var SegoeuiBoldLineHeight = 1.33008;
var SegoeuiBoldItalicFactors = [1.76738, 1, 0.97363, 0.94385, 0.94385, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 1.00811, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.89723, 0.89723, 0.87897, 0.87897, 0.87897, 0.87897, 0.87897, 0.87897, 0.9817, 1.0426, 1.0426, 1.0426, 1.09818, 0.79429, 0.79429, 0.79429, 0.79429, 0.79429, 0.79429, 0.79429, 0.79429, 0.79429, 1.10466, 0.79429, 0.79429, 0.77702, 1.05815, 0.99137, 1.0426, 1.036, 0.85292, 0.91149, 0.86869, 0.91149, 0.91149, 1, 0.91149, 1.05815, 1, 0.99862, 0.99862, 1, 1.05815, 1.05815, 1.1406, 0.97441, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 1.1406, 0.95253, 1.1406, 0.79631, 0.79631, 0.90128, 0.90128, 1, 0.83853, 0.83853, 1.06662, 0.83853, 1, 0.83853, 0.83853, 1.04396, 1.04396, 1.10615, 1.10615, 1.10615, 1, 1.10615, 1.10615, 0.97552, 0.91602, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 0.98999, 1.07205, 0.97552, 1.0347, 0.97552, 0.97552, 0.97552, 0.94436, 1.00356, 1.04694, 1.01945, 0.97552, 0.88641, 0.88641, 0.88641, 1, 0.94436, 0.80527, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.80527, 0.80527, 0.80527, 0.80527, 1, 0.98015, 0.96083, 0.96083, 0.95923, 0.96083, 1, 0.97552, 0.94436, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.91142, 0.86142, 1.00135, 1.00135, 1, 1.06777, 1.06777, 1.06777, 1.06777, 1.06777, 0.9817, 0.84918, 0.91142, 0.91142, 0.91142, 0.91142, 0.91142, 0.99361, 0.99361, 0.99361, 0.99361, 0.99361, 1.06585, 1.06585, 1.06585, 1.06585, 1.31818, 1, 1.06585, 0.96705, 0.96705, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.06585, 1.04961, 1.04961, 1.06585, 1.10953, 0.83284, 1.06585, 1.29004, 1.06585, 1.06585, 0.86224, 0.94434, 0.86364, 0.86279, 0.94434, 1, 1, 1.21237, 1.21237, 1.16939, 0.97847, 1.06585, 0.97042, 1.57293, 1.16579, 0.99607, 1, 0.95107, 0.95107, 1.11144, 1.11144, 1.31818, 1, 1.16579, 1.20502, 0.83055, 0.83055, 1.31818, 1, 1, 0.83055, 0.83055, 0.83055, 0.83055, 1.31818, 1.036, 0.93491, 1.42603, 1.31818, 1, 1.04315, 0.81378, 0.9754, 1, 1, 1.18754, 1, 1, 0.97042, 0.72959, 0.72959, 1.0033, 0.97042, 0.94994, 1.008, 1.34163, 1.31818, 1, 1.27126, 1.29004, 1, 1, 1.036, 1.31818, 1.14236, 0.93503, 0.93503, 0.93503, 0.93503, 0.93503, 0.93503, 0.93503, 0.93503, 1.036, 1, 0.91406, 0.93503, 1, 0.89903, 0.97922, 0.93503, 0.9898, 0.9898, 1.21237, 1.21339, 1, 1.00639, 1.00639, 0.93125, 1.03959, 0.96039, 1.03959, 1.1261, 1, 1.42603, 1, 1.036, 1.15574, 1, 1.036, 1.036, 1, 0.93327, 0.97042, 1.02897, 0.97042, 0.97042, 1, 0.97042, 0.98721, 1.31818, 1, 1.21237, 1.29004, 1.05356, 1.05356, 1.03372, 1.03372, 0.97922, 0.97922, 0.97922, 1.15296, 1, 1.31818, 1, 1.14236, 1.14236, 1.14236, 1.14236, 1.14236, 1.14236, 1.04302, 1.14236, 1.13904, 2.10339, 1, 1, 0.9716, 1.42603, 1.42603, 1, 1.14236, 1.14236, 1.14236, 1.14236, 1.14236, 1.14236, 0.94552, 1.01582, 1.01054, 1.00518, 1, 1.01054, 1.14236, 1.14236, 0.97981, 1.09125, 1, 0.90418, 1.21237, 1.29004, 1, 1.03336, 1.21237, 1.23199, 1.18775, 1.19508, 1, 1.02471, 0.79487, 1, 1, 1.21237, 1.222, 1.02186, 1.21237, 1, 1, 0.97922, 0.97922, 1.01034, 0.97922, 1, 1.036, 1, 1.29004, 0.97922, 1, 1.02809, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 0.91981, 1.31818, 0.94165, 0.94165, 0.94165, 1.00351, 1.00351, 0.94165, 0.94165, 1.036, 1.15574, 1.15574, 1.13934, 0.99862, 1.26781, 1.24866, 0.69825, 0.94165, 0.94165, 0.94165, 0.97042, 0.91484, 1.11144, 1.11144, 1.16798, 0.97639, 0.9754, 1.26514, 1.16541, 1.10687, 0.99314, 1.21237, 1.29004, 0.96085, 1.04232, 0.97042, 0.73541, 0.73541, 1.04016, 0.98633, 0.98633, 0.98633, 1.04745, 1.04394, 1.04745, 1.04745, 1.23203, 1.0276, 1.0276, 1.18416, 1.0276, 1, 1.18622, 1, 0.98387, 1.31818, 1, 0.78929, 0.78929, 0.78929, 0.78929, 0.78929, 1, 1.02956, 0.87357, 1.036, 1.15574, 1, 1, 0.93377, 0.93028, 1.036, 1.59754, 1, 1.2886, 1.036, 0.90068, 1, 1.1261, 1.35125, 1.16862, 1.05403, 1, 1.11121, 0.97042, 1.036, 1.15574, 1.17389, 1.31818, 1, 0.95161, 0.771, 0.87025, 0.87025, 0.87025, 0.87025, 1.036, 0.97922, 0.97922, 0.97922, 0.97922, 0.97922, 0.97922, 0.97922, 0.97922, 0.74627, 0.75155, 0.98946, 1.21261, 1.24047, 1.24047, 1, 1.1349, 0.96083, 1.1261, 1.31818, 0.81378, 0.79429, 1.09097, 0.93503, 0.96609, 1, 1.21261, 1.24633, 1.09125, 1, 1, 1, 0.9754, 1, 1, 1.13269, 1.13269, 0.97922, 1, 1.07514, 1.07514, 1.07514, 1.07514, 0.97922, 0.97922, 0.95874, 1.02197, 1.02197, 1.02197, 1.02197, 1.02197, 0.98507, 1.08578, 0.96752, 0.96752, 0.96752, 0.96752, 1.036, 0.96752, 0.97168, 0.97168, 0.97168, 0.97168, 1.036, 0.95134];
var SegoeuiBoldItalicLineHeight = 1.33008;
var SegoeuiItalicFactors = [1.76738, 1, 0.94729, 0.85498, 0.85498, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85944, 0.85944, 0.88506, 0.88506, 0.88506, 0.88506, 0.88506, 0.88506, 0.8858, 0.9858, 0.9858, 0.9858, 0.9607, 0.74817, 0.74817, 0.74817, 0.74817, 0.74817, 0.74817, 0.74817, 0.74817, 0.74817, 1.03849, 0.74817, 0.74817, 0.71022, 0.98039, 0.90883, 0.9858, 0.96927, 0.80016, 0.88449, 0.82791, 0.88449, 0.88449, 1, 0.88449, 0.98039, 1, 0.99862, 0.99862, 1, 0.98039, 0.98039, 0.95782, 0.84421, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.84171, 0.95782, 0.69238, 0.69238, 0.89898, 0.89898, 1, 0.83231, 0.83231, 0.98316, 0.84723, 1, 0.84723, 0.83231, 0.98183, 0.98183, 1.03989, 1.03989, 1.03989, 1, 1.03989, 1.03989, 0.96924, 0.92383, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.01284, 1.05734, 0.96924, 0.99877, 0.96924, 0.96924, 0.96924, 0.86237, 0.90082, 0.97642, 0.97296, 0.96924, 0.80595, 0.80595, 0.80595, 1, 0.86237, 0.74524, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.74524, 0.74524, 0.74524, 0.74524, 1, 0.86075, 0.86091, 0.86091, 0.85771, 0.86091, 1, 0.96924, 0.86237, 0.95402, 0.95402, 0.95402, 0.95402, 0.95402, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.83089, 0.77596, 0.95402, 0.95402, 0.94143, 0.98448, 0.98448, 0.98448, 0.98448, 0.98448, 0.8858, 0.78614, 0.83089, 0.83089, 0.83089, 0.83089, 0.83089, 0.93285, 0.93285, 0.93285, 0.93285, 0.93285, 0.97454, 0.97454, 0.97454, 0.97454, 1.04839, 1, 0.97454, 0.92916, 0.92916, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97454, 1.0976, 1.0976, 0.97454, 1.15373, 0.78032, 0.97454, 1.24822, 0.97454, 0.97454, 0.86182, 0.94434, 0.86321, 0.8649, 0.94434, 1, 1, 1.45994, 1.17308, 1.07403, 0.94565, 0.97454, 0.97454, 1.39016, 0.92481, 0.98205, 1, 0.91082, 0.91082, 1.0949, 1.0949, 1.04839, 1, 0.92481, 1.15621, 0.87207, 0.87207, 1.04839, 1, 1, 0.87207, 0.87207, 0.87207, 0.87207, 1.04839, 0.96927, 0.99821, 1.42603, 1.04839, 1, 1.04315, 0.78383, 0.78383, 1, 1, 1.23393, 1, 1, 0.97454, 0.67603, 0.67603, 0.95391, 0.97454, 0.94261, 1.05097, 1.34163, 1.04839, 1, 0.81965, 1.24822, 1, 1, 0.96927, 1.04839, 0.93146, 0.87533, 0.87533, 0.87533, 0.87533, 0.87533, 0.87533, 0.87533, 0.87533, 0.96927, 1, 0.73584, 0.87533, 1, 0.89903, 1.01054, 0.87533, 1.04, 1.04, 1.17308, 1.17308, 1, 1.03342, 1.03342, 0.93854, 1.14763, 0.95996, 0.95748, 1.06151, 1, 1.42603, 1, 0.96927, 1.09836, 1, 0.96927, 0.96927, 1, 0.87709, 0.97454, 1.03809, 0.97454, 0.97454, 1, 0.97454, 0.88409, 1.04839, 1, 1.17308, 1.24822, 0.9245, 0.9245, 0.94868, 0.94868, 1.00176, 1.00176, 1.00176, 1.15296, 1, 1.04839, 1, 1.16484, 0.93146, 0.93146, 0.93146, 0.93146, 0.93146, 1.12761, 0.93146, 1.14589, 1.96791, 1, 1, 0.97622, 1.42603, 1.42603, 1, 1.16484, 1.2, 1.2, 1.2, 1.2, 0.93146, 1.08132, 1.08132, 0.98047, 1.02148, 1, 0.98047, 1.16484, 1.16484, 1.0119, 1.04861, 1, 0.78755, 1.17308, 1.24822, 1, 0.96927, 1.17308, 1.31868, 1.17984, 1.23736, 1, 1.02989, 0.63218, 1, 1, 1.17308, 1.22135, 1.04724, 1.17308, 1, 1, 1.01054, 1.01054, 0.9857, 1.01054, 1, 0.96927, 1, 1.24822, 1.01054, 1.0127, 1.06234, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 0.90171, 1.04839, 0.96225, 0.96225, 0.96225, 1.0326, 1.0326, 0.96225, 0.96225, 0.96927, 1.09836, 1.13525, 1.09836, 0.99862, 1.1781, 1.22326, 0.69825, 0.8761, 0.8761, 0.96225, 0.97454, 0.85273, 0.91349, 0.91349, 1.083, 0.92586, 0.78383, 1.21191, 1.01473, 1.11826, 0.8965, 1.17308, 1.24822, 0.91578, 1.0557, 0.97454, 0.77349, 0.70424, 1.05365, 1.12317, 1.12317, 1.12317, 0.94945, 0.94945, 0.94945, 0.94945, 1.18414, 1.06598, 1.06598, 1.18416, 1.06598, 1, 1.20808, 1, 0.97783, 1.04839, 1, 0.79004, 0.79004, 0.79004, 0.79004, 0.79004, 1, 1.06483, 0.80597, 0.96927, 1.01522, 1, 1, 0.94818, 0.93574, 0.96927, 1.42531, 1, 1.2886, 0.96927, 0.86438, 1, 1.16344, 1.30679, 1.16344, 1.02759, 1, 1.05401, 0.97454, 0.96927, 1.09836, 1.15222, 1.04839, 1, 0.81965, 0.77295, 0.87025, 0.87025, 0.87025, 0.87025, 0.96927, 1.00351, 1.00351, 1.00351, 1.00351, 1.00351, 1.00351, 1.00351, 1.00351, 0.74627, 0.75155, 0.98946, 1.20088, 1.09971, 1.09971, 1, 1.09971, 0.86091, 1.16344, 1.04839, 0.78383, 0.74817, 1.03754, 0.87533, 0.98705, 1, 1.20088, 1.24633, 1.07497, 1, 1, 1, 0.78032, 1, 1, 1.10742, 1.10742, 1.00351, 1, 1.0675, 1.0675, 1.0675, 1.0675, 1.00351, 1.00351, 0.94629, 0.9973, 0.9973, 0.9973, 0.9973, 0.9973, 0.91016, 1.02732, 0.96777, 0.96777, 0.96777, 0.96777, 0.96927, 0.96777, 0.9043, 0.9043, 0.9043, 0.9043, 0.96927, 0.95364];
var SegoeuiItalicLineHeight = 1.33008;
var SegoeuiRegularFactors = [1.76738, 1, 0.96706, 0.86035, 0.86035, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96635, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.85944, 0.85944, 0.85734, 0.85734, 0.85734, 0.85734, 0.85734, 0.85734, 0.88433, 0.97093, 0.97093, 0.97093, 0.96491, 0.75842, 0.75842, 0.75842, 0.75842, 0.75842, 0.75842, 0.75842, 0.75842, 0.75842, 1.03444, 0.75842, 0.75842, 0.72727, 0.9831, 0.92366, 0.97093, 0.96927, 0.79936, 0.88198, 0.85638, 0.88198, 0.88198, 1, 0.88198, 0.9831, 1, 0.99862, 0.99862, 1, 0.9831, 0.9831, 0.95782, 0.84784, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.95782, 0.98601, 0.95782, 0.71387, 0.71387, 0.86969, 0.86969, 1, 0.84636, 0.84636, 0.94152, 0.84636, 1, 0.84636, 0.84636, 1.07796, 1.07796, 1.03584, 1.03584, 1.03584, 1, 1.03584, 1.03584, 0.96924, 0.93066, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.0098, 1.09799, 0.96924, 1.03405, 0.96924, 0.96924, 0.96924, 0.83968, 0.94492, 0.98715, 0.9287, 0.96924, 0.82826, 0.82826, 0.82826, 1, 0.83968, 0.79649, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.79649, 0.79649, 0.79649, 0.79649, 1, 0.83491, 0.85771, 0.85771, 0.85771, 0.85771, 1, 0.96924, 0.83968, 0.95132, 0.95132, 0.95132, 0.95132, 0.95132, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.8287, 0.77968, 0.95132, 0.95132, 0.93119, 0.98965, 0.98965, 0.98965, 0.98965, 0.98965, 0.88433, 0.78437, 0.8287, 0.8287, 0.8287, 0.8287, 0.8287, 0.93365, 0.93365, 0.93365, 0.93365, 0.93365, 0.91484, 0.91484, 0.91484, 0.91484, 0.84751, 0.91484, 0.93575, 0.93575, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.91484, 1.0625, 1.0625, 0.91484, 1.19985, 0.78032, 0.91484, 1.24822, 0.91484, 0.91484, 0.86182, 0.94434, 0.86279, 0.86279, 0.94434, 1, 1, 1.45786, 1.1714, 1.07152, 0.94084, 0.91484, 1.05707, 1.3638, 0.92105, 0.95246, 1, 0.90351, 0.90351, 1.08612, 1.08612, 0.91202, 0.92105, 1.16039, 0.92383, 0.92383, 1.11437, 0.92383, 0.92383, 0.92383, 0.92383, 0.61584, 0.96927, 1.02512, 1.42603, 1.11437, 1.04315, 0.78032, 0.78032, 1.20808, 0.99912, 1.05882, 0.67428, 0.67428, 1.0969, 1.05882, 0.94261, 1.04912, 1.34163, 1.2434, 0.81818, 1.24644, 1, 1, 0.96927, 0.60411, 0.8717, 0.9403, 0.9403, 0.9403, 0.9403, 0.9403, 0.9403, 0.9403, 0.9403, 0.96927, 0.73291, 0.9403, 1, 0.89903, 1.01756, 0.9403, 0.98248, 0.98248, 1.1714, 1.17238, 1, 1.03424, 1.03424, 1.00527, 1.02285, 0.95996, 0.85337, 1.12654, 1, 1.42603, 1, 0.96927, 1.11358, 0.96927, 0.96927, 0.87796, 1.05882, 1.03809, 1.05882, 1.05882, 1, 1.05882, 0.89049, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.80499, 1.1714, 1.24822, 0.90957, 0.90957, 0.94868, 0.94868, 1.01756, 1.01756, 1.01756, 1.15296, 1, 0.97361, 1.09011, 0.8717, 0.8717, 0.8717, 0.8717, 0.8717, 1.11551, 0.8717, 1.14589, 1.9697, 1, 1, 0.97622, 1.42603, 1.42603, 1, 1.09011, 1.2, 1.2, 1.2, 1.2, 0.8717, 1.09011, 1.09011, 0.99414, 1.04785, 1, 0.99414, 1.09011, 1.09011, 0.99609, 1.0536, 1, 0.94298, 1.1714, 1.24822, 1, 0.96927, 1.1714, 1.08571, 1.18083, 1.23297, 1, 1.034, 0.75155, 1, 1, 1.1714, 1.22135, 1.00169, 1.1714, 1, 1, 1.01756, 1.01756, 1.00323, 1.01756, 1, 0.96927, 1, 1.24822, 1.01756, 1.05176, 1.06234, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 0.98293, 0.55572, 1.05356, 1.05356, 1.05356, 1.03502, 1.03502, 1.05356, 1.05356, 0.96927, 1.10539, 1.11593, 1.08665, 0.99862, 1.05937, 1.17914, 0.69825, 0.95923, 0.95923, 1.05356, 1.05707, 0.85273, 0.90616, 0.90616, 1.083, 0.92037, 0.78032, 1.20996, 1.01518, 1.07831, 0.9087, 1.1714, 1.24644, 0.91578, 1.05205, 1.05882, 0.80597, 0.73381, 1.10454, 1.13196, 1.13196, 1.13196, 1.03077, 1.03077, 1.03077, 1.03077, 1.2046, 1.04399, 1.04399, 1.18416, 1.04399, 1, 1.20808, 1, 1.03004, 0.84164, 1, 0.84863, 0.84863, 0.84863, 0.84863, 0.84863, 1, 1.06483, 0.80597, 0.96927, 1.06967, 1, 0.93117, 0.95542, 0.96927, 1.40246, 1, 1.2886, 0.96927, 0.86507, 1, 1.21968, 1.23362, 1.21968, 1.17318, 1, 1.05443, 1.05707, 0.96927, 1.10539, 1.14169, 1.01173, 0.81818, 0.77295, 0.87025, 0.87025, 0.87025, 0.87025, 0.96927, 1.01756, 1.01756, 1.01756, 1.01756, 1.01756, 1.01756, 1.01756, 1.01756, 0.74627, 0.75155, 0.98594, 1.20088, 1.09971, 1.09971, 1, 1.05425, 0.85771, 1.21968, 0.93109, 0.78032, 0.75842, 1.03719, 0.9403, 1.04021, 1, 1.20088, 1.24633, 1.05425, 1.09971, 1.09971, 1.09971, 1.07497, 1, 1, 1, 0.78032, 1, 1, 1, 1.10938, 1.10938, 1.01756, 1, 1.01071, 1.01071, 1.01071, 1.01071, 1.01756, 1.01756, 0.95801, 1.00068, 1.00068, 1.00068, 1.00068, 1.00068, 0.91797, 0.99346, 0.96777, 0.96777, 0.96777, 0.96777, 0.96927, 0.96777, 0.9043, 0.9043, 0.9043, 0.9043, 0.96927, 1.00221];
var SegoeuiRegularLineHeight = 1.33008;
var getXFAFontMap = getLookupTableFactory(function(t) {
  t["MyriadPro-Regular"] = t["PdfJS-Fallback-Regular"] = {
    name: "LiberationSans-Regular",
    factors: MyriadProRegularFactors,
    baseWidths: LiberationSansRegularWidths,
    lineHeight: MyriadProRegularLineHeight
  };
  t["MyriadPro-Bold"] = t["PdfJS-Fallback-Bold"] = {
    name: "LiberationSans-Bold",
    factors: MyriadProBoldFactors,
    baseWidths: LiberationSansBoldWidths,
    lineHeight: MyriadProBoldLineHeight
  };
  t["MyriadPro-It"] = t["MyriadPro-Italic"] = t["PdfJS-Fallback-Italic"] = {
    name: "LiberationSans-Italic",
    factors: MyriadProItalicFactors,
    baseWidths: LiberationSansItalicWidths,
    lineHeight: MyriadProItalicLineHeight
  };
  t["MyriadPro-BoldIt"] = t["MyriadPro-BoldItalic"] = t["PdfJS-Fallback-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: MyriadProBoldItalicFactors,
    baseWidths: LiberationSansBoldItalicWidths,
    lineHeight: MyriadProBoldItalicLineHeight
  };
  t.ArialMT = t.Arial = t["Arial-Regular"] = {
    name: "LiberationSans-Regular",
    baseWidths: LiberationSansRegularWidths
  };
  t["Arial-BoldMT"] = t["Arial-Bold"] = {
    name: "LiberationSans-Bold",
    baseWidths: LiberationSansBoldWidths
  };
  t["Arial-ItalicMT"] = t["Arial-Italic"] = {
    name: "LiberationSans-Italic",
    baseWidths: LiberationSansItalicWidths
  };
  t["Arial-BoldItalicMT"] = t["Arial-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    baseWidths: LiberationSansBoldItalicWidths
  };
  t["Calibri-Regular"] = {
    name: "LiberationSans-Regular",
    factors: CalibriRegularFactors,
    baseWidths: LiberationSansRegularWidths,
    lineHeight: CalibriRegularLineHeight
  };
  t["Calibri-Bold"] = {
    name: "LiberationSans-Bold",
    factors: CalibriBoldFactors,
    baseWidths: LiberationSansBoldWidths,
    lineHeight: CalibriBoldLineHeight
  };
  t["Calibri-Italic"] = {
    name: "LiberationSans-Italic",
    factors: CalibriItalicFactors,
    baseWidths: LiberationSansItalicWidths,
    lineHeight: CalibriItalicLineHeight
  };
  t["Calibri-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: CalibriBoldItalicFactors,
    baseWidths: LiberationSansBoldItalicWidths,
    lineHeight: CalibriBoldItalicLineHeight
  };
  t["Segoeui-Regular"] = {
    name: "LiberationSans-Regular",
    factors: SegoeuiRegularFactors,
    baseWidths: LiberationSansRegularWidths,
    lineHeight: SegoeuiRegularLineHeight
  };
  t["Segoeui-Bold"] = {
    name: "LiberationSans-Bold",
    factors: SegoeuiBoldFactors,
    baseWidths: LiberationSansBoldWidths,
    lineHeight: SegoeuiBoldLineHeight
  };
  t["Segoeui-Italic"] = {
    name: "LiberationSans-Italic",
    factors: SegoeuiItalicFactors,
    baseWidths: LiberationSansItalicWidths,
    lineHeight: SegoeuiItalicLineHeight
  };
  t["Segoeui-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: SegoeuiBoldItalicFactors,
    baseWidths: LiberationSansBoldItalicWidths,
    lineHeight: SegoeuiBoldItalicLineHeight
  };
  t["Helvetica-Regular"] = t.Helvetica = {
    name: "LiberationSans-Regular",
    factors: HelveticaRegularFactors,
    baseWidths: LiberationSansRegularWidths,
    lineHeight: HelveticaRegularLineHeight
  };
  t["Helvetica-Bold"] = {
    name: "LiberationSans-Bold",
    factors: HelveticaBoldFactors,
    baseWidths: LiberationSansBoldWidths,
    lineHeight: HelveticaBoldLineHeight
  };
  t["Helvetica-Italic"] = {
    name: "LiberationSans-Italic",
    factors: HelveticaItalicFactors,
    baseWidths: LiberationSansItalicWidths,
    lineHeight: HelveticaItalicLineHeight
  };
  t["Helvetica-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: HelveticaBoldItalicFactors,
    baseWidths: LiberationSansBoldItalicWidths,
    lineHeight: HelveticaBoldItalicLineHeight
  };
});
function getXfaFontName(name) {
  const fontName = normalizeFontName(name);
  const fontMap = getXFAFontMap();
  return fontMap[fontName];
}
function getXfaFontWidths(name) {
  const info2 = getXfaFontName(name);
  if (!info2) {
    return null;
  }
  const {
    baseWidths,
    factors
  } = info2;
  if (!factors) {
    return baseWidths;
  }
  return baseWidths.map((w, i) => w * factors[i]);
}
var SEED = 3285377520;
var MASK_HIGH = 4294901760;
var MASK_LOW = 65535;
var MurmurHash3_64 = class {
  constructor(seed) {
    this.h1 = seed ? seed & 4294967295 : SEED;
    this.h2 = seed ? seed & 4294967295 : SEED;
  }
  update(input) {
    let data, length;
    if (isString(input)) {
      data = new Uint8Array(input.length * 2);
      length = 0;
      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);
        if (code <= 255) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 255;
        }
      }
    } else if (isArrayBuffer(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
    }
    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0, k2 = 0;
    let h1 = this.h1, h2 = this.h2;
    const C1 = 3432918353, C2 = 461845907;
    const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 3864292196;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 3864292196;
      }
    }
    k1 = 0;
    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;
      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;
      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }
    }
    this.h1 = h1;
    this.h2 = h2;
  }
  hexdigest() {
    let h1 = this.h1, h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
    h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
    h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    const hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
    return hex1.padStart(8, "0") + hex2.padStart(8, "0");
  }
};
function addState(parentState, pattern, checkFn, iterateFn, processFn) {
  let state = parentState;
  for (let i = 0, ii = pattern.length - 1; i < ii; i++) {
    const item = pattern[i];
    state = state[item] || (state[item] = []);
  }
  state[pattern[pattern.length - 1]] = {
    checkFn,
    iterateFn,
    processFn
  };
}
function handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray) {
  const iFirstPIMXO = iFirstSave + 2;
  let i;
  for (i = 0; i < count; i++) {
    const arg = argsArray[iFirstPIMXO + 4 * i];
    const imageMask = arg.length === 1 && arg[0];
    if (imageMask && imageMask.width === 1 && imageMask.height === 1 && (!imageMask.data.length || imageMask.data.length === 1 && imageMask.data[0] === 0)) {
      fnArray[iFirstPIMXO + 4 * i] = OPS.paintSolidColorImageMask;
      continue;
    }
    break;
  }
  return count - i;
}
var InitialState = [];
addState(InitialState, [OPS.save, OPS.transform, OPS.paintInlineImageXObject, OPS.restore], null, function iterateInlineImageGroup(context, i) {
  const fnArray = context.fnArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;
  switch (pos) {
    case 0:
      return fnArray[i] === OPS.save;
    case 1:
      return fnArray[i] === OPS.transform;
    case 2:
      return fnArray[i] === OPS.paintInlineImageXObject;
    case 3:
      return fnArray[i] === OPS.restore;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
}, function foundInlineImageGroup(context, i) {
  const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
  const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
  const MAX_WIDTH = 1e3;
  const IMAGE_PADDING = 1;
  const fnArray = context.fnArray, argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIIXO = curr - 1;
  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
  if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }
  let maxX = 0;
  const map = [];
  let maxLineHeight = 0;
  let currentX = IMAGE_PADDING, currentY = IMAGE_PADDING;
  for (let q = 0; q < count; q++) {
    const transform = argsArray[iFirstTransform + (q << 2)];
    const img = argsArray[iFirstPIIXO + (q << 2)][0];
    if (currentX + img.width > MAX_WIDTH) {
      maxX = Math.max(maxX, currentX);
      currentY += maxLineHeight + 2 * IMAGE_PADDING;
      currentX = 0;
      maxLineHeight = 0;
    }
    map.push({
      transform,
      x: currentX,
      y: currentY,
      w: img.width,
      h: img.height
    });
    currentX += img.width + 2 * IMAGE_PADDING;
    maxLineHeight = Math.max(maxLineHeight, img.height);
  }
  const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
  const imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
  const imgData = new Uint8ClampedArray(imgWidth * imgHeight * 4);
  const imgRowSize = imgWidth << 2;
  for (let q = 0; q < count; q++) {
    const data = argsArray[iFirstPIIXO + (q << 2)][0].data;
    const rowSize = map[q].w << 2;
    let dataOffset = 0;
    let offset = map[q].x + map[q].y * imgWidth << 2;
    imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
    for (let k = 0, kk = map[q].h; k < kk; k++) {
      imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
      dataOffset += rowSize;
      offset += imgRowSize;
    }
    imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
    while (offset >= 0) {
      data[offset - 4] = data[offset];
      data[offset - 3] = data[offset + 1];
      data[offset - 2] = data[offset + 2];
      data[offset - 1] = data[offset + 3];
      data[offset + rowSize] = data[offset + rowSize - 4];
      data[offset + rowSize + 1] = data[offset + rowSize - 3];
      data[offset + rowSize + 2] = data[offset + rowSize - 2];
      data[offset + rowSize + 3] = data[offset + rowSize - 1];
      offset -= imgRowSize;
    }
  }
  fnArray.splice(iFirstSave, count * 4, OPS.paintInlineImageXObjectGroup);
  argsArray.splice(iFirstSave, count * 4, [{
    width: imgWidth,
    height: imgHeight,
    kind: ImageKind.RGBA_32BPP,
    data: imgData
  }, map]);
  return iFirstSave + 1;
});
addState(InitialState, [OPS.save, OPS.transform, OPS.paintImageMaskXObject, OPS.restore], null, function iterateImageMaskGroup(context, i) {
  const fnArray = context.fnArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;
  switch (pos) {
    case 0:
      return fnArray[i] === OPS.save;
    case 1:
      return fnArray[i] === OPS.transform;
    case 2:
      return fnArray[i] === OPS.paintImageMaskXObject;
    case 3:
      return fnArray[i] === OPS.restore;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
}, function foundImageMaskGroup(context, i) {
  const MIN_IMAGES_IN_MASKS_BLOCK = 10;
  const MAX_IMAGES_IN_MASKS_BLOCK = 100;
  const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1e3;
  const fnArray = context.fnArray, argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIMXO = curr - 1;
  let count = Math.floor((i - iFirstSave) / 4);
  count = handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray);
  if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }
  let isSameImage = false;
  let iTransform, transformArgs;
  const firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
  const firstTransformArg0 = argsArray[iFirstTransform][0], firstTransformArg1 = argsArray[iFirstTransform][1], firstTransformArg2 = argsArray[iFirstTransform][2], firstTransformArg3 = argsArray[iFirstTransform][3];
  if (firstTransformArg1 === firstTransformArg2) {
    isSameImage = true;
    iTransform = iFirstTransform + 4;
    let iPIMXO = iFirstPIMXO + 4;
    for (let q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
      transformArgs = argsArray[iTransform];
      if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== firstTransformArg1 || transformArgs[2] !== firstTransformArg2 || transformArgs[3] !== firstTransformArg3) {
        if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
          isSameImage = false;
        } else {
          count = q;
        }
        break;
      }
    }
  }
  if (isSameImage) {
    count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
    const positions = new Float32Array(count * 2);
    iTransform = iFirstTransform;
    for (let q = 0; q < count; q++, iTransform += 4) {
      transformArgs = argsArray[iTransform];
      positions[q << 1] = transformArgs[4];
      positions[(q << 1) + 1] = transformArgs[5];
    }
    fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectRepeat);
    argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg1, firstTransformArg2, firstTransformArg3, positions]);
  } else {
    count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
    const images = [];
    for (let q = 0; q < count; q++) {
      transformArgs = argsArray[iFirstTransform + (q << 2)];
      const maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
      images.push({
        data: maskParams.data,
        width: maskParams.width,
        height: maskParams.height,
        transform: transformArgs
      });
    }
    fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectGroup);
    argsArray.splice(iFirstSave, count * 4, [images]);
  }
  return iFirstSave + 1;
});
addState(InitialState, [OPS.save, OPS.transform, OPS.paintImageXObject, OPS.restore], function(context) {
  const argsArray = context.argsArray;
  const iFirstTransform = context.iCurr - 2;
  return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
}, function iterateImageGroup(context, i) {
  const fnArray = context.fnArray, argsArray = context.argsArray;
  const iFirstSave = context.iCurr - 3;
  const pos = (i - iFirstSave) % 4;
  switch (pos) {
    case 0:
      return fnArray[i] === OPS.save;
    case 1:
      if (fnArray[i] !== OPS.transform) {
        return false;
      }
      const iFirstTransform = context.iCurr - 2;
      const firstTransformArg0 = argsArray[iFirstTransform][0];
      const firstTransformArg3 = argsArray[iFirstTransform][3];
      if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {
        return false;
      }
      return true;
    case 2:
      if (fnArray[i] !== OPS.paintImageXObject) {
        return false;
      }
      const iFirstPIXO = context.iCurr - 1;
      const firstPIXOArg0 = argsArray[iFirstPIXO][0];
      if (argsArray[i][0] !== firstPIXOArg0) {
        return false;
      }
      return true;
    case 3:
      return fnArray[i] === OPS.restore;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
}, function(context, i) {
  const MIN_IMAGES_IN_BLOCK = 3;
  const MAX_IMAGES_IN_BLOCK = 1e3;
  const fnArray = context.fnArray, argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstSave = curr - 3;
  const iFirstTransform = curr - 2;
  const iFirstPIXO = curr - 1;
  const firstPIXOArg0 = argsArray[iFirstPIXO][0];
  const firstTransformArg0 = argsArray[iFirstTransform][0];
  const firstTransformArg3 = argsArray[iFirstTransform][3];
  const count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);
  if (count < MIN_IMAGES_IN_BLOCK) {
    return i - (i - iFirstSave) % 4;
  }
  const positions = new Float32Array(count * 2);
  let iTransform = iFirstTransform;
  for (let q = 0; q < count; q++, iTransform += 4) {
    const transformArgs = argsArray[iTransform];
    positions[q << 1] = transformArgs[4];
    positions[(q << 1) + 1] = transformArgs[5];
  }
  const args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
  fnArray.splice(iFirstSave, count * 4, OPS.paintImageXObjectRepeat);
  argsArray.splice(iFirstSave, count * 4, args);
  return iFirstSave + 1;
});
addState(InitialState, [OPS.beginText, OPS.setFont, OPS.setTextMatrix, OPS.showText, OPS.endText], null, function iterateShowTextGroup(context, i) {
  const fnArray = context.fnArray, argsArray = context.argsArray;
  const iFirstSave = context.iCurr - 4;
  const pos = (i - iFirstSave) % 5;
  switch (pos) {
    case 0:
      return fnArray[i] === OPS.beginText;
    case 1:
      return fnArray[i] === OPS.setFont;
    case 2:
      return fnArray[i] === OPS.setTextMatrix;
    case 3:
      if (fnArray[i] !== OPS.showText) {
        return false;
      }
      const iFirstSetFont = context.iCurr - 3;
      const firstSetFontArg0 = argsArray[iFirstSetFont][0];
      const firstSetFontArg1 = argsArray[iFirstSetFont][1];
      if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {
        return false;
      }
      return true;
    case 4:
      return fnArray[i] === OPS.endText;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
}, function(context, i) {
  const MIN_CHARS_IN_BLOCK = 3;
  const MAX_CHARS_IN_BLOCK = 1e3;
  const fnArray = context.fnArray, argsArray = context.argsArray;
  const curr = context.iCurr;
  const iFirstBeginText = curr - 4;
  const iFirstSetFont = curr - 3;
  const iFirstSetTextMatrix = curr - 2;
  const iFirstShowText = curr - 1;
  const iFirstEndText = curr;
  const firstSetFontArg0 = argsArray[iFirstSetFont][0];
  const firstSetFontArg1 = argsArray[iFirstSetFont][1];
  let count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);
  if (count < MIN_CHARS_IN_BLOCK) {
    return i - (i - iFirstBeginText) % 5;
  }
  let iFirst = iFirstBeginText;
  if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
    count++;
    iFirst -= 5;
  }
  let iEndText = iFirst + 4;
  for (let q = 1; q < count; q++) {
    fnArray.splice(iEndText, 3);
    argsArray.splice(iEndText, 3);
    iEndText += 2;
  }
  return iEndText + 1;
});
var NullOptimizer = class {
  constructor(queue) {
    this.queue = queue;
  }
  _optimize() {
  }
  push(fn, args) {
    this.queue.fnArray.push(fn);
    this.queue.argsArray.push(args);
    this._optimize();
  }
  flush() {
  }
  reset() {
  }
};
var QueueOptimizer = class extends NullOptimizer {
  constructor(queue) {
    super(queue);
    this.state = null;
    this.context = {
      iCurr: 0,
      fnArray: queue.fnArray,
      argsArray: queue.argsArray
    };
    this.match = null;
    this.lastProcessed = 0;
  }
  _optimize() {
    const fnArray = this.queue.fnArray;
    let i = this.lastProcessed, ii = fnArray.length;
    let state = this.state;
    let match = this.match;
    if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
      this.lastProcessed = ii;
      return;
    }
    const context = this.context;
    while (i < ii) {
      if (match) {
        const iterate = (0, match.iterateFn)(context, i);
        if (iterate) {
          i++;
          continue;
        }
        i = (0, match.processFn)(context, i + 1);
        ii = fnArray.length;
        match = null;
        state = null;
        if (i >= ii) {
          break;
        }
      }
      state = (state || InitialState)[fnArray[i]];
      if (!state || Array.isArray(state)) {
        i++;
        continue;
      }
      context.iCurr = i;
      i++;
      if (state.checkFn && !(0, state.checkFn)(context)) {
        state = null;
        continue;
      }
      match = state;
      state = null;
    }
    this.state = state;
    this.match = match;
    this.lastProcessed = i;
  }
  flush() {
    while (this.match) {
      const length = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, length);
      this.match = null;
      this.state = null;
      this._optimize();
    }
  }
  reset() {
    this.state = null;
    this.match = null;
    this.lastProcessed = 0;
  }
};
var OperatorList = class _OperatorList {
  static get CHUNK_SIZE() {
    return shadow(this, "CHUNK_SIZE", 1e3);
  }
  // Close to chunk size.
  static get CHUNK_SIZE_ABOUT() {
    return shadow(this, "CHUNK_SIZE_ABOUT", this.CHUNK_SIZE - 5);
  }
  constructor(intent, streamSink) {
    this._streamSink = streamSink;
    this.fnArray = [];
    this.argsArray = [];
    if (streamSink && !(intent && intent.startsWith("oplist-"))) {
      this.optimizer = new QueueOptimizer(this);
    } else {
      this.optimizer = new NullOptimizer(this);
    }
    this.dependencies = /* @__PURE__ */ new Set();
    this._totalLength = 0;
    this.weight = 0;
    this._resolved = streamSink ? null : Promise.resolve();
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  /**
   * @type {number} The total length of the entire operator list, since
   *                `this.length === 0` after flushing.
   */
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(fn, args) {
    this.optimizer.push(fn, args);
    this.weight++;
    if (this._streamSink) {
      if (this.weight >= _OperatorList.CHUNK_SIZE) {
        this.flush();
      } else if (this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (fn === OPS.restore || fn === OPS.endText)) {
        this.flush();
      }
    }
  }
  addDependency(dependency) {
    if (this.dependencies.has(dependency)) {
      return;
    }
    this.dependencies.add(dependency);
    this.addOp(OPS.dependency, [dependency]);
  }
  addDependencies(dependencies) {
    for (const dependency of dependencies) {
      this.addDependency(dependency);
    }
  }
  addOpList(opList) {
    if (!(opList instanceof _OperatorList)) {
      warn('addOpList - ignoring invalid "opList" parameter.');
      return;
    }
    for (const dependency of opList.dependencies) {
      this.dependencies.add(dependency);
    }
    for (let i = 0, ii = opList.length; i < ii; i++) {
      this.addOp(opList.fnArray[i], opList.argsArray[i]);
    }
  }
  getIR() {
    return {
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      length: this.length
    };
  }
  get _transfers() {
    const transfers = [];
    const {
      fnArray,
      argsArray,
      length
    } = this;
    for (let i = 0; i < length; i++) {
      switch (fnArray[i]) {
        case OPS.paintInlineImageXObject:
        case OPS.paintInlineImageXObjectGroup:
        case OPS.paintImageMaskXObject:
          const arg = argsArray[i][0];
          if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
            assert(arg.data instanceof Uint8ClampedArray, 'OperatorList._transfers: Unsupported "arg.data" type.');
          }
          if (!arg.cached) {
            transfers.push(arg.data.buffer);
          }
          break;
      }
    }
    return transfers;
  }
  flush(lastChunk = false) {
    this.optimizer.flush();
    const length = this.length;
    this._totalLength += length;
    this._streamSink.enqueue({
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      lastChunk,
      length
    }, 1, this._transfers);
    this.dependencies.clear();
    this.fnArray.length = 0;
    this.argsArray.length = 0;
    this.weight = 0;
    this.optimizer.reset();
  }
};
function decodeAndClamp(value, addend, coefficient, max) {
  value = addend + value * coefficient;
  if (value < 0) {
    value = 0;
  } else if (value > max) {
    value = max;
  }
  return value;
}
function resizeImageMask(src, bpc, w1, h1, w2, h2) {
  const length = w2 * h2;
  let dest;
  if (bpc <= 8) {
    dest = new Uint8Array(length);
  } else if (bpc <= 16) {
    dest = new Uint16Array(length);
  } else {
    dest = new Uint32Array(length);
  }
  const xRatio = w1 / w2;
  const yRatio = h1 / h2;
  let i, j, py, newIndex = 0, oldIndex;
  const xScaled = new Uint16Array(w2);
  const w1Scanline = w1;
  for (i = 0; i < w2; i++) {
    xScaled[i] = Math.floor(i * xRatio);
  }
  for (i = 0; i < h2; i++) {
    py = Math.floor(i * yRatio) * w1Scanline;
    for (j = 0; j < w2; j++) {
      oldIndex = py + xScaled[j];
      dest[newIndex++] = src[oldIndex];
    }
  }
  return dest;
}
var PDFImage = class _PDFImage {
  constructor({
    xref,
    res,
    image,
    isInline = false,
    smask = null,
    mask = null,
    isMask = false,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    this.image = image;
    const dict = image.dict;
    const filter = dict.get("Filter");
    if (isName(filter)) {
      switch (filter.name) {
        case "JPXDecode":
          const jpxImage = new JpxImage();
          jpxImage.parseImageProperties(image.stream);
          image.stream.reset();
          image.width = jpxImage.width;
          image.height = jpxImage.height;
          image.bitsPerComponent = jpxImage.bitsPerComponent;
          image.numComps = jpxImage.componentsCount;
          break;
        case "JBIG2Decode":
          image.bitsPerComponent = 1;
          image.numComps = 1;
          break;
      }
    }
    let width = dict.get("Width", "W");
    let height = dict.get("Height", "H");
    if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {
      warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
      width = image.width;
      height = image.height;
    }
    if (width < 1 || height < 1) {
      throw new FormatError(`Invalid image width: ${width} or height: ${height}`);
    }
    this.width = width;
    this.height = height;
    this.interpolate = dict.get("Interpolate", "I") || false;
    this.imageMask = dict.get("ImageMask", "IM") || false;
    this.matte = dict.get("Matte") || false;
    let bitsPerComponent = image.bitsPerComponent;
    if (!bitsPerComponent) {
      bitsPerComponent = dict.get("BitsPerComponent", "BPC");
      if (!bitsPerComponent) {
        if (this.imageMask) {
          bitsPerComponent = 1;
        } else {
          throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);
        }
      }
    }
    this.bpc = bitsPerComponent;
    if (!this.imageMask) {
      let colorSpace = dict.getRaw("ColorSpace") || dict.getRaw("CS");
      if (!colorSpace) {
        info("JPX images (which do not require color spaces)");
        switch (image.numComps) {
          case 1:
            colorSpace = Name.get("DeviceGray");
            break;
          case 3:
            colorSpace = Name.get("DeviceRGB");
            break;
          case 4:
            colorSpace = Name.get("DeviceCMYK");
            break;
          default:
            throw new Error(`JPX images with ${image.numComps} color components not supported.`);
        }
      }
      this.colorSpace = ColorSpace.parse({
        cs: colorSpace,
        xref,
        resources: isInline ? res : null,
        pdfFunctionFactory,
        localColorSpaceCache
      });
      this.numComps = this.colorSpace.numComps;
    }
    this.decode = dict.getArray("Decode", "D");
    this.needsDecode = false;
    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !ColorSpace.isDefaultDecode(
      this.decode,
      /* numComps = */
      1
    ))) {
      this.needsDecode = true;
      const max = (1 << bitsPerComponent) - 1;
      this.decodeCoefficients = [];
      this.decodeAddends = [];
      const isIndexed = this.colorSpace && this.colorSpace.name === "Indexed";
      for (let i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
        const dmin = this.decode[i];
        const dmax = this.decode[i + 1];
        this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin;
        this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
      }
    }
    if (smask) {
      this.smask = new _PDFImage({
        xref,
        res,
        image: smask,
        isInline,
        pdfFunctionFactory,
        localColorSpaceCache
      });
    } else if (mask) {
      if (isStream(mask)) {
        const maskDict = mask.dict, imageMask = maskDict.get("ImageMask", "IM");
        if (!imageMask) {
          warn("Ignoring /Mask in image without /ImageMask.");
        } else {
          this.mask = new _PDFImage({
            xref,
            res,
            image: mask,
            isInline,
            isMask: true,
            pdfFunctionFactory,
            localColorSpaceCache
          });
        }
      } else {
        this.mask = mask;
      }
    }
  }
  /**
   * Handles processing of image data and returns the Promise that is resolved
   * with a PDFImage when the image is ready to be used.
   */
  static async buildImage({
    xref,
    res,
    image,
    isInline = false,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    const imageData = image;
    let smaskData = null;
    let maskData = null;
    const smask = image.dict.get("SMask");
    const mask = image.dict.get("Mask");
    if (smask) {
      smaskData = smask;
    } else if (mask) {
      if (isStream(mask) || Array.isArray(mask)) {
        maskData = mask;
      } else {
        warn("Unsupported mask format.");
      }
    }
    return new _PDFImage({
      xref,
      res,
      image: imageData,
      isInline,
      smask: smaskData,
      mask: maskData,
      pdfFunctionFactory,
      localColorSpaceCache
    });
  }
  static createMask({
    imgArray,
    width,
    height,
    imageIsFromDecodeStream,
    inverseDecode
  }) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(imgArray instanceof Uint8ClampedArray, 'PDFImage.createMask: Unsupported "imgArray" type.');
    }
    const computedLength = (width + 7 >> 3) * height;
    const actualLength = imgArray.byteLength;
    const haveFullData = computedLength === actualLength;
    let data, i;
    if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
      data = imgArray;
    } else if (!inverseDecode) {
      data = new Uint8ClampedArray(actualLength);
      data.set(imgArray);
    } else {
      data = new Uint8ClampedArray(computedLength);
      data.set(imgArray);
      for (i = actualLength; i < computedLength; i++) {
        data[i] = 255;
      }
    }
    if (inverseDecode) {
      for (i = 0; i < actualLength; i++) {
        data[i] ^= 255;
      }
    }
    return {
      data,
      width,
      height
    };
  }
  get drawWidth() {
    return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
  }
  get drawHeight() {
    return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
  }
  decodeBuffer(buffer) {
    const bpc = this.bpc;
    const numComps = this.numComps;
    const decodeAddends = this.decodeAddends;
    const decodeCoefficients = this.decodeCoefficients;
    const max = (1 << bpc) - 1;
    let i, ii;
    if (bpc === 1) {
      for (i = 0, ii = buffer.length; i < ii; i++) {
        buffer[i] = +!buffer[i];
      }
      return;
    }
    let index = 0;
    for (i = 0, ii = this.width * this.height; i < ii; i++) {
      for (let j = 0; j < numComps; j++) {
        buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
        index++;
      }
    }
  }
  getComponents(buffer) {
    const bpc = this.bpc;
    if (bpc === 8) {
      return buffer;
    }
    const width = this.width;
    const height = this.height;
    const numComps = this.numComps;
    const length = width * height * numComps;
    let bufferPos = 0;
    let output;
    if (bpc <= 8) {
      output = new Uint8Array(length);
    } else if (bpc <= 16) {
      output = new Uint16Array(length);
    } else {
      output = new Uint32Array(length);
    }
    const rowComps = width * numComps;
    const max = (1 << bpc) - 1;
    let i = 0, ii, buf;
    if (bpc === 1) {
      let mask, loop1End, loop2End;
      for (let j = 0; j < height; j++) {
        loop1End = i + (rowComps & ~7);
        loop2End = i + rowComps;
        while (i < loop1End) {
          buf = buffer[bufferPos++];
          output[i] = buf >> 7 & 1;
          output[i + 1] = buf >> 6 & 1;
          output[i + 2] = buf >> 5 & 1;
          output[i + 3] = buf >> 4 & 1;
          output[i + 4] = buf >> 3 & 1;
          output[i + 5] = buf >> 2 & 1;
          output[i + 6] = buf >> 1 & 1;
          output[i + 7] = buf & 1;
          i += 8;
        }
        if (i < loop2End) {
          buf = buffer[bufferPos++];
          mask = 128;
          while (i < loop2End) {
            output[i++] = +!!(buf & mask);
            mask >>= 1;
          }
        }
      }
    } else {
      let bits = 0;
      buf = 0;
      for (i = 0, ii = length; i < ii; ++i) {
        if (i % rowComps === 0) {
          buf = 0;
          bits = 0;
        }
        while (bits < bpc) {
          buf = buf << 8 | buffer[bufferPos++];
          bits += 8;
        }
        const remainingBits = bits - bpc;
        let value = buf >> remainingBits;
        if (value < 0) {
          value = 0;
        } else if (value > max) {
          value = max;
        }
        output[i] = value;
        buf &= (1 << remainingBits) - 1;
        bits = remainingBits;
      }
    }
    return output;
  }
  fillOpacity(rgbaBuf, width, height, actualHeight, image) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(rgbaBuf instanceof Uint8ClampedArray, 'PDFImage.fillOpacity: Unsupported "rgbaBuf" type.');
    }
    const smask = this.smask;
    const mask = this.mask;
    let alphaBuf, sw, sh, i, ii, j;
    if (smask) {
      sw = smask.width;
      sh = smask.height;
      alphaBuf = new Uint8ClampedArray(sw * sh);
      smask.fillGrayBuffer(alphaBuf);
      if (sw !== width || sh !== height) {
        alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
      }
    } else if (mask) {
      if (mask instanceof _PDFImage) {
        sw = mask.width;
        sh = mask.height;
        alphaBuf = new Uint8ClampedArray(sw * sh);
        mask.numComps = 1;
        mask.fillGrayBuffer(alphaBuf);
        for (i = 0, ii = sw * sh; i < ii; ++i) {
          alphaBuf[i] = 255 - alphaBuf[i];
        }
        if (sw !== width || sh !== height) {
          alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
        }
      } else if (Array.isArray(mask)) {
        alphaBuf = new Uint8ClampedArray(width * height);
        const numComps = this.numComps;
        for (i = 0, ii = width * height; i < ii; ++i) {
          let opacity = 0;
          const imageOffset = i * numComps;
          for (j = 0; j < numComps; ++j) {
            const color = image[imageOffset + j];
            const maskOffset = j * 2;
            if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
              opacity = 255;
              break;
            }
          }
          alphaBuf[i] = opacity;
        }
      } else {
        throw new FormatError("Unknown mask format.");
      }
    }
    if (alphaBuf) {
      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
        rgbaBuf[j] = alphaBuf[i];
      }
    } else {
      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
        rgbaBuf[j] = 255;
      }
    }
  }
  undoPreblend(buffer, width, height) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(buffer instanceof Uint8ClampedArray, 'PDFImage.undoPreblend: Unsupported "buffer" type.');
    }
    const matte = this.smask && this.smask.matte;
    if (!matte) {
      return;
    }
    const matteRgb = this.colorSpace.getRgb(matte, 0);
    const matteR = matteRgb[0];
    const matteG = matteRgb[1];
    const matteB = matteRgb[2];
    const length = width * height * 4;
    for (let i = 0; i < length; i += 4) {
      const alpha = buffer[i + 3];
      if (alpha === 0) {
        buffer[i] = 255;
        buffer[i + 1] = 255;
        buffer[i + 2] = 255;
        continue;
      }
      const k = 255 / alpha;
      buffer[i] = (buffer[i] - matteR) * k + matteR;
      buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
      buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
    }
  }
  createImageData(forceRGBA = false) {
    const drawWidth = this.drawWidth;
    const drawHeight = this.drawHeight;
    const imgData = {
      width: drawWidth,
      height: drawHeight,
      kind: 0,
      data: null
      // Other fields are filled in below.
    };
    const numComps = this.numComps;
    const originalWidth = this.width;
    const originalHeight = this.height;
    const bpc = this.bpc;
    const rowBytes = originalWidth * numComps * bpc + 7 >> 3;
    let imgArray;
    if (!forceRGBA) {
      let kind;
      if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
        kind = ImageKind.GRAYSCALE_1BPP;
      } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
        kind = ImageKind.RGB_24BPP;
      }
      if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
        imgData.kind = kind;
        imgArray = this.getImageBytes(originalHeight * rowBytes);
        if (this.image instanceof DecodeStream) {
          imgData.data = imgArray;
        } else {
          const newArray = new Uint8ClampedArray(imgArray.length);
          newArray.set(imgArray);
          imgData.data = newArray;
        }
        if (this.needsDecode) {
          assert(kind === ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
          const buffer = imgData.data;
          for (let i = 0, ii = buffer.length; i < ii; i++) {
            buffer[i] ^= 255;
          }
        }
        return imgData;
      }
      if (this.image instanceof JpegStream && !this.smask && !this.mask) {
        let imageLength = originalHeight * rowBytes;
        switch (this.colorSpace.name) {
          case "DeviceGray":
            imageLength *= 3;
          case "DeviceRGB":
          case "DeviceCMYK":
            imgData.kind = ImageKind.RGB_24BPP;
            imgData.data = this.getImageBytes(
              imageLength,
              drawWidth,
              drawHeight,
              /* forceRGB = */
              true
            );
            return imgData;
        }
      }
    }
    imgArray = this.getImageBytes(originalHeight * rowBytes);
    const actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
    const comps = this.getComponents(imgArray);
    let alpha01, maybeUndoPreblend;
    if (!forceRGBA && !this.smask && !this.mask) {
      imgData.kind = ImageKind.RGB_24BPP;
      imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
      alpha01 = 0;
      maybeUndoPreblend = false;
    } else {
      imgData.kind = ImageKind.RGBA_32BPP;
      imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
      alpha01 = 1;
      maybeUndoPreblend = true;
      this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps);
    }
    if (this.needsDecode) {
      this.decodeBuffer(comps);
    }
    this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
    if (maybeUndoPreblend) {
      this.undoPreblend(imgData.data, drawWidth, actualHeight);
    }
    return imgData;
  }
  fillGrayBuffer(buffer) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(buffer instanceof Uint8ClampedArray, 'PDFImage.fillGrayBuffer: Unsupported "buffer" type.');
    }
    const numComps = this.numComps;
    if (numComps !== 1) {
      throw new FormatError(`Reading gray scale from a color image: ${numComps}`);
    }
    const width = this.width;
    const height = this.height;
    const bpc = this.bpc;
    const rowBytes = width * numComps * bpc + 7 >> 3;
    const imgArray = this.getImageBytes(height * rowBytes);
    const comps = this.getComponents(imgArray);
    let i, length;
    if (bpc === 1) {
      length = width * height;
      if (this.needsDecode) {
        for (i = 0; i < length; ++i) {
          buffer[i] = comps[i] - 1 & 255;
        }
      } else {
        for (i = 0; i < length; ++i) {
          buffer[i] = -comps[i] & 255;
        }
      }
      return;
    }
    if (this.needsDecode) {
      this.decodeBuffer(comps);
    }
    length = width * height;
    const scale = 255 / ((1 << bpc) - 1);
    for (i = 0; i < length; ++i) {
      buffer[i] = scale * comps[i];
    }
  }
  getImageBytes(length, drawWidth, drawHeight, forceRGB = false) {
    this.image.reset();
    this.image.drawWidth = drawWidth || this.width;
    this.image.drawHeight = drawHeight || this.height;
    this.image.forceRGB = !!forceRGB;
    return this.image.getBytes(
      length,
      /* forceClamped = */
      true
    );
  }
};
var DefaultPartialEvaluatorOptions = Object.freeze({
  maxImageSize: -1,
  disableFontFace: false,
  ignoreErrors: false,
  isEvalSupported: true,
  fontExtraProperties: false,
  useSystemFonts: true,
  cMapUrl: null,
  standardFontDataUrl: null
});
var PatternType = {
  TILING: 1,
  SHADING: 2
};
var deferred = Promise.resolve();
function normalizeBlendMode(value, parsingArray = false) {
  if (Array.isArray(value)) {
    for (let i = 0, ii = value.length; i < ii; i++) {
      const maybeBM = normalizeBlendMode(
        value[i],
        /* parsingArray = */
        true
      );
      if (maybeBM) {
        return maybeBM;
      }
    }
    warn(`Unsupported blend mode Array: ${value}`);
    return "source-over";
  }
  if (!isName(value)) {
    if (parsingArray) {
      return null;
    }
    return "source-over";
  }
  switch (value.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  if (parsingArray) {
    return null;
  }
  warn(`Unsupported blend mode: ${value.name}`);
  return "source-over";
}
var TimeSlotManager = class _TimeSlotManager {
  static get TIME_SLOT_DURATION_MS() {
    return shadow(this, "TIME_SLOT_DURATION_MS", 20);
  }
  static get CHECK_TIME_EVERY() {
    return shadow(this, "CHECK_TIME_EVERY", 100);
  }
  constructor() {
    this.reset();
  }
  check() {
    if (++this.checked < _TimeSlotManager.CHECK_TIME_EVERY) {
      return false;
    }
    this.checked = 0;
    return this.endTime <= Date.now();
  }
  reset() {
    this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS;
    this.checked = 0;
  }
};
var PartialEvaluator = class _PartialEvaluator {
  constructor({
    xref,
    handler,
    pageIndex,
    idFactory,
    fontCache,
    builtInCMapCache,
    standardFontDataCache,
    globalImageCache,
    options = null
  }) {
    this.xref = xref;
    this.handler = handler;
    this.pageIndex = pageIndex;
    this.idFactory = idFactory;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.standardFontDataCache = standardFontDataCache;
    this.globalImageCache = globalImageCache;
    this.options = options || DefaultPartialEvaluatorOptions;
    this.parsingType3Font = false;
    this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
  }
  /**
   * Since Functions are only cached (locally) by reference, we can share one
   * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
   */
  get _pdfFunctionFactory() {
    const pdfFunctionFactory = new PDFFunctionFactory({
      xref: this.xref,
      isEvalSupported: this.options.isEvalSupported
    });
    return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
  }
  clone(newOptions = null) {
    const newEvaluator = Object.create(this);
    newEvaluator.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, newOptions);
    return newEvaluator;
  }
  hasBlendModes(resources, nonBlendModesSet) {
    if (!(resources instanceof Dict)) {
      return false;
    }
    if (resources.objId && nonBlendModesSet.has(resources.objId)) {
      return false;
    }
    const processed = new RefSet(nonBlendModesSet);
    if (resources.objId) {
      processed.put(resources.objId);
    }
    const nodes = [resources], xref = this.xref;
    while (nodes.length) {
      const node = nodes.shift();
      const graphicStates = node.get("ExtGState");
      if (graphicStates instanceof Dict) {
        for (let graphicState of graphicStates.getRawValues()) {
          if (graphicState instanceof Ref) {
            if (processed.has(graphicState)) {
              continue;
            }
            try {
              graphicState = xref.fetch(graphicState);
            } catch (ex) {
              processed.put(graphicState);
              info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
              continue;
            }
          }
          if (!(graphicState instanceof Dict)) {
            continue;
          }
          if (graphicState.objId) {
            processed.put(graphicState.objId);
          }
          const bm = graphicState.get("BM");
          if (bm instanceof Name) {
            if (bm.name !== "Normal") {
              return true;
            }
            continue;
          }
          if (bm !== void 0 && Array.isArray(bm)) {
            for (const element of bm) {
              if (element instanceof Name && element.name !== "Normal") {
                return true;
              }
            }
          }
        }
      }
      const xObjects = node.get("XObject");
      if (!(xObjects instanceof Dict)) {
        continue;
      }
      for (let xObject of xObjects.getRawValues()) {
        if (xObject instanceof Ref) {
          if (processed.has(xObject)) {
            continue;
          }
          try {
            xObject = xref.fetch(xObject);
          } catch (ex) {
            processed.put(xObject);
            info(`hasBlendModes - ignoring XObject: "${ex}".`);
            continue;
          }
        }
        if (!isStream(xObject)) {
          continue;
        }
        if (xObject.dict.objId) {
          processed.put(xObject.dict.objId);
        }
        const xResources = xObject.dict.get("Resources");
        if (!(xResources instanceof Dict)) {
          continue;
        }
        if (xResources.objId && processed.has(xResources.objId)) {
          continue;
        }
        nodes.push(xResources);
        if (xResources.objId) {
          processed.put(xResources.objId);
        }
      }
    }
    processed.forEach((ref) => {
      nonBlendModesSet.put(ref);
    });
    return false;
  }
  async fetchBuiltInCMap(name) {
    const cachedData = this.builtInCMapCache.get(name);
    if (cachedData) {
      return cachedData;
    }
    let data;
    if (this.options.cMapUrl !== null) {
      const url = `${this.options.cMapUrl}${name}.bcmap`;
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`);
      }
      data = {
        cMapData: new Uint8Array(await response.arrayBuffer()),
        compressionType: CMapCompressionType.BINARY
      };
    } else {
      data = await this.handler.sendWithPromise("FetchBuiltInCMap", {
        name
      });
    }
    if (data.compressionType !== CMapCompressionType.NONE) {
      this.builtInCMapCache.set(name, data);
    }
    return data;
  }
  async fetchStandardFontData(name) {
    const cachedData = this.standardFontDataCache.get(name);
    if (cachedData) {
      return new Stream(cachedData);
    }
    if (this.options.useSystemFonts && name !== "Symbol" && name !== "ZapfDingbats") {
      return null;
    }
    const standardFontNameToFileName = getFontNameToFileMap(), filename = standardFontNameToFileName[name];
    let data;
    if (this.options.standardFontDataUrl !== null) {
      const url = `${this.options.standardFontDataUrl}${filename}`;
      const response = await fetch(url);
      if (!response.ok) {
        warn(`fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`);
      } else {
        data = await response.arrayBuffer();
      }
    } else {
      try {
        data = await this.handler.sendWithPromise("FetchStandardFontData", {
          filename
        });
      } catch (e) {
        warn(`fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`);
      }
    }
    if (!data) {
      return null;
    }
    this.standardFontDataCache.set(name, data);
    return new Stream(data);
  }
  async buildFormXObject(resources, xobj, smask, operatorList, task, initialState, localColorSpaceCache) {
    const dict = xobj.dict;
    const matrix = dict.getArray("Matrix");
    let bbox = dict.getArray("BBox");
    if (Array.isArray(bbox) && bbox.length === 4) {
      bbox = Util.normalizeRect(bbox);
    } else {
      bbox = null;
    }
    let optionalContent = null, groupOptions;
    if (dict.has("OC")) {
      optionalContent = await this.parseMarkedContentProps(dict.get("OC"), resources);
      operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
    }
    const group = dict.get("Group");
    if (group) {
      groupOptions = {
        matrix,
        bbox,
        smask,
        isolated: false,
        knockout: false
      };
      const groupSubtype = group.get("S");
      let colorSpace = null;
      if (isName(groupSubtype, "Transparency")) {
        groupOptions.isolated = group.get("I") || false;
        groupOptions.knockout = group.get("K") || false;
        if (group.has("CS")) {
          const cs = group.getRaw("CS");
          const cachedColorSpace = ColorSpace.getCached(cs, this.xref, localColorSpaceCache);
          if (cachedColorSpace) {
            colorSpace = cachedColorSpace;
          } else {
            colorSpace = await this.parseColorSpace({
              cs,
              resources,
              localColorSpaceCache
            });
          }
        }
      }
      if (smask && smask.backdrop) {
        colorSpace = colorSpace || ColorSpace.singletons.rgb;
        smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
      }
      operatorList.addOp(OPS.beginGroup, [groupOptions]);
    }
    operatorList.addOp(OPS.paintFormXObjectBegin, [matrix, bbox]);
    return this.getOperatorList({
      stream: xobj,
      task,
      resources: dict.get("Resources") || resources,
      operatorList,
      initialState
    }).then(function() {
      operatorList.addOp(OPS.paintFormXObjectEnd, []);
      if (group) {
        operatorList.addOp(OPS.endGroup, [groupOptions]);
      }
      if (optionalContent) {
        operatorList.addOp(OPS.endMarkedContent, []);
      }
    });
  }
  _sendImgData(objId, imgData, cacheGlobally = false) {
    const transfers = imgData ? [imgData.data.buffer] : null;
    if (this.parsingType3Font || cacheGlobally) {
      return this.handler.send("commonobj", [objId, "Image", imgData], transfers);
    }
    return this.handler.send("obj", [objId, this.pageIndex, "Image", imgData], transfers);
  }
  async buildPaintImageXObject({
    resources,
    image,
    isInline = false,
    operatorList,
    cacheKey,
    localImageCache,
    localColorSpaceCache
  }) {
    const dict = image.dict;
    const imageRef = dict.objId;
    const w = dict.get("Width", "W");
    const h = dict.get("Height", "H");
    if (!(w && isNum(w)) || !(h && isNum(h))) {
      warn("Image dimensions are missing, or not numbers.");
      return void 0;
    }
    const maxImageSize = this.options.maxImageSize;
    if (maxImageSize !== -1 && w * h > maxImageSize) {
      warn("Image exceeded maximum allowed size and was removed.");
      return void 0;
    }
    const imageMask = dict.get("ImageMask", "IM") || false;
    let imgData, args;
    if (imageMask) {
      const width = dict.get("Width", "W");
      const height = dict.get("Height", "H");
      const bitStrideLength = width + 7 >> 3;
      const imgArray = image.getBytes(
        bitStrideLength * height,
        /* forceClamped = */
        true
      );
      const decode = dict.getArray("Decode", "D");
      imgData = PDFImage.createMask({
        imgArray,
        width,
        height,
        imageIsFromDecodeStream: image instanceof DecodeStream,
        inverseDecode: !!decode && decode[0] > 0
      });
      imgData.cached = !!cacheKey;
      args = [imgData];
      operatorList.addOp(OPS.paintImageMaskXObject, args);
      if (cacheKey) {
        localImageCache.set(cacheKey, imageRef, {
          fn: OPS.paintImageMaskXObject,
          args
        });
      }
      return void 0;
    }
    const softMask = dict.get("SMask", "SM") || false;
    const mask = dict.get("Mask") || false;
    const SMALL_IMAGE_DIMENSIONS = 200;
    if (isInline && !softMask && !mask && w + h < SMALL_IMAGE_DIMENSIONS) {
      const imageObj = new PDFImage({
        xref: this.xref,
        res: resources,
        image,
        isInline,
        pdfFunctionFactory: this._pdfFunctionFactory,
        localColorSpaceCache
      });
      imgData = imageObj.createImageData(
        /* forceRGBA = */
        true
      );
      operatorList.addOp(OPS.paintInlineImageXObject, [imgData]);
      return void 0;
    }
    let objId = `img_${this.idFactory.createObjId()}`, cacheGlobally = false;
    if (this.parsingType3Font) {
      objId = `${this.idFactory.getDocId()}_type3_${objId}`;
    } else if (imageRef) {
      cacheGlobally = this.globalImageCache.shouldCache(imageRef, this.pageIndex);
      if (cacheGlobally) {
        objId = `${this.idFactory.getDocId()}_${objId}`;
      }
    }
    operatorList.addDependency(objId);
    args = [objId, w, h];
    PDFImage.buildImage({
      xref: this.xref,
      res: resources,
      image,
      isInline,
      pdfFunctionFactory: this._pdfFunctionFactory,
      localColorSpaceCache
    }).then((imageObj) => {
      imgData = imageObj.createImageData(
        /* forceRGBA = */
        false
      );
      if (cacheKey && imageRef && cacheGlobally) {
        this.globalImageCache.addByteSize(imageRef, imgData.data.length);
      }
      return this._sendImgData(objId, imgData, cacheGlobally);
    }).catch((reason) => {
      warn(`Unable to decode image "${objId}": "${reason}".`);
      return this._sendImgData(
        objId,
        /* imgData = */
        null,
        cacheGlobally
      );
    });
    operatorList.addOp(OPS.paintImageXObject, args);
    if (cacheKey) {
      localImageCache.set(cacheKey, imageRef, {
        fn: OPS.paintImageXObject,
        args
      });
      if (imageRef) {
        assert(!isInline, "Cannot cache an inline image globally.");
        this.globalImageCache.addPageIndex(imageRef, this.pageIndex);
        if (cacheGlobally) {
          this.globalImageCache.setData(imageRef, {
            objId,
            fn: OPS.paintImageXObject,
            args,
            byteSize: 0
            // Temporary entry, note `addByteSize` above.
          });
        }
      }
    }
    return void 0;
  }
  handleSMask(smask, resources, operatorList, task, stateManager, localColorSpaceCache) {
    const smaskContent = smask.get("G");
    const smaskOptions = {
      subtype: smask.get("S").name,
      backdrop: smask.get("BC")
    };
    const transferObj = smask.get("TR");
    if (isPDFFunction(transferObj)) {
      const transferFn = this._pdfFunctionFactory.create(transferObj);
      const transferMap = new Uint8Array(256);
      const tmp = new Float32Array(1);
      for (let i = 0; i < 256; i++) {
        tmp[0] = i / 255;
        transferFn(tmp, 0, tmp, 0);
        transferMap[i] = tmp[0] * 255 | 0;
      }
      smaskOptions.transferMap = transferMap;
    }
    return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone(), localColorSpaceCache);
  }
  handleTransferFunction(tr) {
    let transferArray;
    if (Array.isArray(tr)) {
      transferArray = tr;
    } else if (isPDFFunction(tr)) {
      transferArray = [tr];
    } else {
      return null;
    }
    const transferMaps = [];
    let numFns = 0, numEffectfulFns = 0;
    for (const entry of transferArray) {
      const transferObj = this.xref.fetchIfRef(entry);
      numFns++;
      if (isName(transferObj, "Identity")) {
        transferMaps.push(null);
        continue;
      } else if (!isPDFFunction(transferObj)) {
        return null;
      }
      const transferFn = this._pdfFunctionFactory.create(transferObj);
      const transferMap = new Uint8Array(256), tmp = new Float32Array(1);
      for (let j = 0; j < 256; j++) {
        tmp[0] = j / 255;
        transferFn(tmp, 0, tmp, 0);
        transferMap[j] = tmp[0] * 255 | 0;
      }
      transferMaps.push(transferMap);
      numEffectfulFns++;
    }
    if (!(numFns === 1 || numFns === 4)) {
      return null;
    }
    if (numEffectfulFns === 0) {
      return null;
    }
    return transferMaps;
  }
  handleTilingType(fn, color, resources, pattern, patternDict, operatorList, task, cacheKey, localTilingPatternCache) {
    const tilingOpList = new OperatorList();
    const patternResources = Dict.merge({
      xref: this.xref,
      dictArray: [patternDict.get("Resources"), resources]
    });
    return this.getOperatorList({
      stream: pattern,
      task,
      resources: patternResources,
      operatorList: tilingOpList
    }).then(function() {
      const operatorListIR = tilingOpList.getIR();
      const tilingPatternIR = getTilingPatternIR(operatorListIR, patternDict, color);
      operatorList.addDependencies(tilingOpList.dependencies);
      operatorList.addOp(fn, tilingPatternIR);
      if (cacheKey) {
        localTilingPatternCache.set(cacheKey, patternDict.objId, {
          operatorListIR,
          dict: patternDict
        });
      }
    }).catch((reason) => {
      if (reason instanceof AbortException) {
        return;
      }
      if (this.options.ignoreErrors) {
        this.handler.send("UnsupportedFeature", {
          featureId: UNSUPPORTED_FEATURES.errorTilingPattern
        });
        warn(`handleTilingType - ignoring pattern: "${reason}".`);
        return;
      }
      throw reason;
    });
  }
  handleSetFont(resources, fontArgs, fontRef, operatorList, task, state, fallbackFontDict = null, cssFontInfo = null) {
    const fontName = fontArgs && fontArgs[0] instanceof Name ? fontArgs[0].name : null;
    return this.loadFont(fontName, fontRef, resources, fallbackFontDict, cssFontInfo).then((translated) => {
      if (!translated.font.isType3Font) {
        return translated;
      }
      return translated.loadType3Data(this, resources, task).then(function() {
        operatorList.addDependencies(translated.type3Dependencies);
        return translated;
      }).catch((reason) => {
        this.handler.send("UnsupportedFeature", {
          featureId: UNSUPPORTED_FEATURES.errorFontLoadType3
        });
        return new TranslatedFont({
          loadedName: "g_font_error",
          font: new ErrorFont(`Type3 font load error: ${reason}`),
          dict: translated.font,
          evaluatorOptions: this.options
        });
      });
    }).then((translated) => {
      state.font = translated.font;
      translated.send(this.handler);
      return translated.loadedName;
    });
  }
  handleText(chars2, state) {
    const font = state.font;
    const glyphs = font.charsToGlyphs(chars2);
    if (font.data) {
      const isAddToPathSet = !!(state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
      if (isAddToPathSet || state.fillColorSpace.name === "Pattern" || font.disableFontFace || this.options.disableFontFace) {
        _PartialEvaluator.buildFontPaths(font, glyphs, this.handler, this.options);
      }
    }
    return glyphs;
  }
  ensureStateFont(state) {
    if (state.font) {
      return;
    }
    const reason = new FormatError("Missing setFont (Tf) operator before text rendering operator.");
    if (this.options.ignoreErrors) {
      this.handler.send("UnsupportedFeature", {
        featureId: UNSUPPORTED_FEATURES.errorFontState
      });
      warn(`ensureStateFont: "${reason}".`);
      return;
    }
    throw reason;
  }
  async setGState({
    resources,
    gState,
    operatorList,
    cacheKey,
    task,
    stateManager,
    localGStateCache,
    localColorSpaceCache
  }) {
    const gStateRef = gState.objId;
    let isSimpleGState = true;
    const gStateObj = [];
    const gStateKeys = gState.getKeys();
    let promise = Promise.resolve();
    for (let i = 0, ii = gStateKeys.length; i < ii; i++) {
      const key = gStateKeys[i];
      const value = gState.get(key);
      switch (key) {
        case "Type":
          break;
        case "LW":
        case "LC":
        case "LJ":
        case "ML":
        case "D":
        case "RI":
        case "FL":
        case "CA":
        case "ca":
          gStateObj.push([key, value]);
          break;
        case "Font":
          isSimpleGState = false;
          promise = promise.then(() => {
            return this.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function(loadedName) {
              operatorList.addDependency(loadedName);
              gStateObj.push([key, [loadedName, value[1]]]);
            });
          });
          break;
        case "BM":
          gStateObj.push([key, normalizeBlendMode(value)]);
          break;
        case "SMask":
          if (isName(value, "None")) {
            gStateObj.push([key, false]);
            break;
          }
          if (isDict(value)) {
            isSimpleGState = false;
            promise = promise.then(() => {
              return this.handleSMask(value, resources, operatorList, task, stateManager, localColorSpaceCache);
            });
            gStateObj.push([key, true]);
          } else {
            warn("Unsupported SMask type");
          }
          break;
        case "TR":
          const transferMaps = this.handleTransferFunction(value);
          gStateObj.push([key, transferMaps]);
          break;
        case "OP":
        case "op":
        case "OPM":
        case "BG":
        case "BG2":
        case "UCR":
        case "UCR2":
        case "TR2":
        case "HT":
        case "SM":
        case "SA":
        case "AIS":
        case "TK":
          info("graphic state operator " + key);
          break;
        default:
          info("Unknown graphic state operator " + key);
          break;
      }
    }
    return promise.then(function() {
      if (gStateObj.length > 0) {
        operatorList.addOp(OPS.setGState, [gStateObj]);
      }
      if (isSimpleGState) {
        localGStateCache.set(cacheKey, gStateRef, gStateObj);
      }
    });
  }
  loadFont(fontName, font, resources, fallbackFontDict = null, cssFontInfo = null) {
    const errorFont = async () => {
      return new TranslatedFont({
        loadedName: "g_font_error",
        font: new ErrorFont(`Font "${fontName}" is not available.`),
        dict: font,
        evaluatorOptions: this.options
      });
    };
    const xref = this.xref;
    let fontRef;
    if (font) {
      if (!isRef(font)) {
        throw new FormatError('The "font" object should be a reference.');
      }
      fontRef = font;
    } else {
      const fontRes = resources.get("Font");
      if (fontRes) {
        fontRef = fontRes.getRaw(fontName);
      }
    }
    if (!fontRef) {
      const partialMsg = `Font "${fontName || font && font.toString()}" is not available`;
      if (!this.options.ignoreErrors && !this.parsingType3Font) {
        warn(`${partialMsg}.`);
        return errorFont();
      }
      this.handler.send("UnsupportedFeature", {
        featureId: UNSUPPORTED_FEATURES.errorFontMissing
      });
      warn(`${partialMsg} -- attempting to fallback to a default font.`);
      if (fallbackFontDict) {
        fontRef = fallbackFontDict;
      } else {
        fontRef = _PartialEvaluator.fallbackFontDict;
      }
    }
    if (this.fontCache.has(fontRef)) {
      return this.fontCache.get(fontRef);
    }
    font = xref.fetchIfRef(fontRef);
    if (!isDict(font)) {
      return errorFont();
    }
    if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
      return this.fontCache.get(font.cacheKey);
    }
    const fontCapability = createPromiseCapability();
    let preEvaluatedFont;
    try {
      preEvaluatedFont = this.preEvaluateFont(font);
      preEvaluatedFont.cssFontInfo = cssFontInfo;
    } catch (reason) {
      warn(`loadFont - preEvaluateFont failed: "${reason}".`);
      return errorFont();
    }
    const {
      descriptor,
      hash
    } = preEvaluatedFont;
    const fontRefIsRef = isRef(fontRef);
    let fontID;
    if (fontRefIsRef) {
      fontID = `f${fontRef.toString()}`;
    }
    if (hash && isDict(descriptor)) {
      if (!descriptor.fontAliases) {
        descriptor.fontAliases = /* @__PURE__ */ Object.create(null);
      }
      const fontAliases = descriptor.fontAliases;
      if (fontAliases[hash]) {
        const aliasFontRef = fontAliases[hash].aliasRef;
        if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
          this.fontCache.putAlias(fontRef, aliasFontRef);
          return this.fontCache.get(fontRef);
        }
      } else {
        fontAliases[hash] = {
          fontID: this.idFactory.createFontId()
        };
      }
      if (fontRefIsRef) {
        fontAliases[hash].aliasRef = fontRef;
      }
      fontID = fontAliases[hash].fontID;
    }
    if (fontRefIsRef) {
      this.fontCache.put(fontRef, fontCapability.promise);
    } else {
      if (!fontID) {
        fontID = this.idFactory.createFontId();
      }
      font.cacheKey = `cacheKey_${fontID}`;
      this.fontCache.put(font.cacheKey, fontCapability.promise);
    }
    assert(fontID && fontID.startsWith("f"), 'The "fontID" must be (correctly) defined.');
    font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
    this.translateFont(preEvaluatedFont).then((translatedFont) => {
      if (translatedFont.fontType !== void 0) {
        const xrefFontStats = xref.stats.fontTypes;
        xrefFontStats[translatedFont.fontType] = true;
      }
      fontCapability.resolve(new TranslatedFont({
        loadedName: font.loadedName,
        font: translatedFont,
        dict: font,
        evaluatorOptions: this.options
      }));
    }).catch((reason) => {
      this.handler.send("UnsupportedFeature", {
        featureId: UNSUPPORTED_FEATURES.errorFontTranslate
      });
      warn(`loadFont - translateFont failed: "${reason}".`);
      try {
        const fontFile3 = descriptor && descriptor.get("FontFile3");
        const subtype = fontFile3 && fontFile3.get("Subtype");
        const fontType = getFontType(preEvaluatedFont.type, subtype && subtype.name);
        const xrefFontStats = xref.stats.fontTypes;
        xrefFontStats[fontType] = true;
      } catch (ex) {
      }
      fontCapability.resolve(new TranslatedFont({
        loadedName: font.loadedName,
        font: new ErrorFont(reason instanceof Error ? reason.message : reason),
        dict: font,
        evaluatorOptions: this.options
      }));
    });
    return fontCapability.promise;
  }
  buildPath(operatorList, fn, args, parsingText = false) {
    const lastIndex = operatorList.length - 1;
    if (!args) {
      args = [];
    }
    if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== OPS.constructPath) {
      if (parsingText) {
        warn(`Encountered path operator "${fn}" inside of a text object.`);
        operatorList.addOp(OPS.save, null);
      }
      operatorList.addOp(OPS.constructPath, [[fn], args]);
      if (parsingText) {
        operatorList.addOp(OPS.restore, null);
      }
    } else {
      const opArgs = operatorList.argsArray[lastIndex];
      opArgs[0].push(fn);
      Array.prototype.push.apply(opArgs[1], args);
    }
  }
  parseColorSpace({
    cs,
    resources,
    localColorSpaceCache
  }) {
    return ColorSpace.parseAsync({
      cs,
      xref: this.xref,
      resources,
      pdfFunctionFactory: this._pdfFunctionFactory,
      localColorSpaceCache
    }).catch((reason) => {
      if (reason instanceof AbortException) {
        return null;
      }
      if (this.options.ignoreErrors) {
        this.handler.send("UnsupportedFeature", {
          featureId: UNSUPPORTED_FEATURES.errorColorSpace
        });
        warn(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
        return null;
      }
      throw reason;
    });
  }
  parseShading({
    keyObj,
    shading,
    resources,
    localColorSpaceCache,
    localShadingPatternCache,
    matrix = null
  }) {
    let id = localShadingPatternCache.get(keyObj);
    if (!id) {
      var shadingFill = Pattern$1.parseShading(shading, matrix, this.xref, resources, this.handler, this._pdfFunctionFactory, localColorSpaceCache);
      const patternIR = shadingFill.getIR();
      id = `pattern_${this.idFactory.createObjId()}`;
      localShadingPatternCache.set(keyObj, id);
      this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
    }
    return id;
  }
  handleColorN(operatorList, fn, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache) {
    const patternName = args.pop();
    if (patternName instanceof Name) {
      const name = patternName.name;
      const localTilingPattern = localTilingPatternCache.getByName(name);
      if (localTilingPattern) {
        try {
          const color = cs.base ? cs.base.getRgb(args, 0) : null;
          const tilingPatternIR = getTilingPatternIR(localTilingPattern.operatorListIR, localTilingPattern.dict, color);
          operatorList.addOp(fn, tilingPatternIR);
          return void 0;
        } catch (ex) {
        }
      }
      const pattern = patterns.get(name);
      if (pattern) {
        const dict = isStream(pattern) ? pattern.dict : pattern;
        const typeNum = dict.get("PatternType");
        if (typeNum === PatternType.TILING) {
          const color = cs.base ? cs.base.getRgb(args, 0) : null;
          return this.handleTilingType(
            fn,
            color,
            resources,
            pattern,
            dict,
            operatorList,
            task,
            /* cacheKey = */
            name,
            localTilingPatternCache
          );
        } else if (typeNum === PatternType.SHADING) {
          const shading = dict.get("Shading");
          const matrix = dict.getArray("Matrix");
          const objId = this.parseShading({
            keyObj: pattern,
            shading,
            matrix,
            resources,
            localColorSpaceCache,
            localShadingPatternCache
          });
          operatorList.addOp(fn, ["Shading", objId]);
          return void 0;
        }
        throw new FormatError(`Unknown PatternType: ${typeNum}`);
      }
    }
    throw new FormatError(`Unknown PatternName: ${patternName}`);
  }
  _parseVisibilityExpression(array, nestingCounter, currentResult) {
    const MAX_NESTING = 10;
    if (++nestingCounter > MAX_NESTING) {
      warn("Visibility expression is too deeply nested");
      return;
    }
    const length = array.length;
    const operator = this.xref.fetchIfRef(array[0]);
    if (length < 2 || !isName(operator)) {
      warn("Invalid visibility expression");
      return;
    }
    switch (operator.name) {
      case "And":
      case "Or":
      case "Not":
        currentResult.push(operator.name);
        break;
      default:
        warn(`Invalid operator ${operator.name} in visibility expression`);
        return;
    }
    for (let i = 1; i < length; i++) {
      const raw = array[i];
      const object = this.xref.fetchIfRef(raw);
      if (Array.isArray(object)) {
        const nestedResult = [];
        currentResult.push(nestedResult);
        this._parseVisibilityExpression(object, nestingCounter, nestedResult);
      } else if (isRef(raw)) {
        currentResult.push(raw.toString());
      }
    }
  }
  async parseMarkedContentProps(contentProperties, resources) {
    let optionalContent;
    if (isName(contentProperties)) {
      const properties = resources.get("Properties");
      optionalContent = properties.get(contentProperties.name);
    } else if (isDict(contentProperties)) {
      optionalContent = contentProperties;
    } else {
      throw new FormatError("Optional content properties malformed.");
    }
    const optionalContentType = optionalContent.get("Type").name;
    if (optionalContentType === "OCG") {
      return {
        type: optionalContentType,
        id: optionalContent.objId
      };
    } else if (optionalContentType === "OCMD") {
      const expression = optionalContent.get("VE");
      if (Array.isArray(expression)) {
        const result = [];
        this._parseVisibilityExpression(expression, 0, result);
        if (result.length > 0) {
          return {
            type: "OCMD",
            expression: result
          };
        }
      }
      const optionalContentGroups = optionalContent.get("OCGs");
      if (Array.isArray(optionalContentGroups) || isDict(optionalContentGroups)) {
        const groupIds = [];
        if (Array.isArray(optionalContentGroups)) {
          for (const ocg of optionalContentGroups) {
            groupIds.push(ocg.toString());
          }
        } else {
          groupIds.push(optionalContentGroups.objId);
        }
        return {
          type: optionalContentType,
          ids: groupIds,
          policy: isName(optionalContent.get("P")) ? optionalContent.get("P").name : null,
          expression: null
        };
      } else if (isRef(optionalContentGroups)) {
        return {
          type: optionalContentType,
          id: optionalContentGroups.toString()
        };
      }
    }
    return null;
  }
  getOperatorList({
    stream,
    task,
    resources,
    operatorList,
    initialState = null,
    fallbackFontDict = null
  }) {
    resources = resources || Dict.empty;
    initialState = initialState || new EvalState();
    if (!operatorList) {
      throw new Error('getOperatorList: missing "operatorList" parameter');
    }
    const self2 = this;
    const xref = this.xref;
    let parsingText = false;
    const localImageCache = new LocalImageCache();
    const localColorSpaceCache = new LocalColorSpaceCache();
    const localGStateCache = new LocalGStateCache();
    const localTilingPatternCache = new LocalTilingPatternCache();
    const localShadingPatternCache = /* @__PURE__ */ new Map();
    const xobjs = resources.get("XObject") || Dict.empty;
    const patterns = resources.get("Pattern") || Dict.empty;
    const stateManager = new StateManager(initialState);
    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
    const timeSlotManager = new TimeSlotManager();
    function closePendingRestoreOPS(argument) {
      for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
        operatorList.addOp(OPS.restore, []);
      }
    }
    return new Promise(function promiseBody(resolve, reject) {
      const next = function(promise) {
        Promise.all([promise, operatorList.ready]).then(function() {
          try {
            promiseBody(resolve, reject);
          } catch (ex) {
            reject(ex);
          }
        }, reject);
      };
      task.ensureNotTerminated();
      timeSlotManager.reset();
      const operation = {};
      let stop, i, ii, cs, name, isValidName;
      while (!(stop = timeSlotManager.check())) {
        operation.args = null;
        if (!preprocessor.read(operation)) {
          break;
        }
        let args = operation.args;
        let fn = operation.fn;
        switch (fn | 0) {
          case OPS.paintXObject:
            isValidName = args[0] instanceof Name;
            name = args[0].name;
            if (isValidName) {
              const localImage = localImageCache.getByName(name);
              if (localImage) {
                operatorList.addOp(localImage.fn, localImage.args);
                args = null;
                continue;
              }
            }
            next(new Promise(function(resolveXObject, rejectXObject) {
              if (!isValidName) {
                throw new FormatError("XObject must be referred to by name.");
              }
              let xobj = xobjs.getRaw(name);
              if (xobj instanceof Ref) {
                const localImage = localImageCache.getByRef(xobj);
                if (localImage) {
                  operatorList.addOp(localImage.fn, localImage.args);
                  resolveXObject();
                  return;
                }
                const globalImage = self2.globalImageCache.getData(xobj, self2.pageIndex);
                if (globalImage) {
                  operatorList.addDependency(globalImage.objId);
                  operatorList.addOp(globalImage.fn, globalImage.args);
                  resolveXObject();
                  return;
                }
                xobj = xref.fetch(xobj);
              }
              if (!isStream(xobj)) {
                throw new FormatError("XObject should be a stream");
              }
              const type = xobj.dict.get("Subtype");
              if (!isName(type)) {
                throw new FormatError("XObject should have a Name subtype");
              }
              if (type.name === "Form") {
                stateManager.save();
                self2.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone(), localColorSpaceCache).then(function() {
                  stateManager.restore();
                  resolveXObject();
                }, rejectXObject);
                return;
              } else if (type.name === "Image") {
                self2.buildPaintImageXObject({
                  resources,
                  image: xobj,
                  operatorList,
                  cacheKey: name,
                  localImageCache,
                  localColorSpaceCache
                }).then(resolveXObject, rejectXObject);
                return;
              } else if (type.name === "PS") {
                info("Ignored XObject subtype PS");
              } else {
                throw new FormatError(`Unhandled XObject subtype ${type.name}`);
              }
              resolveXObject();
            }).catch(function(reason) {
              if (reason instanceof AbortException) {
                return;
              }
              if (self2.options.ignoreErrors) {
                self2.handler.send("UnsupportedFeature", {
                  featureId: UNSUPPORTED_FEATURES.errorXObject
                });
                warn(`getOperatorList - ignoring XObject: "${reason}".`);
                return;
              }
              throw reason;
            }));
            return;
          case OPS.setFont:
            var fontSize = args[1];
            next(self2.handleSetFont(resources, args, null, operatorList, task, stateManager.state, fallbackFontDict).then(function(loadedName) {
              operatorList.addDependency(loadedName);
              operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
            }));
            return;
          case OPS.beginText:
            parsingText = true;
            break;
          case OPS.endText:
            parsingText = false;
            break;
          case OPS.endInlineImage:
            var cacheKey = args[0].cacheKey;
            if (cacheKey) {
              const localImage = localImageCache.getByName(cacheKey);
              if (localImage) {
                operatorList.addOp(localImage.fn, localImage.args);
                args = null;
                continue;
              }
            }
            next(self2.buildPaintImageXObject({
              resources,
              image: args[0],
              isInline: true,
              operatorList,
              cacheKey,
              localImageCache,
              localColorSpaceCache
            }));
            return;
          case OPS.showText:
            if (!stateManager.state.font) {
              self2.ensureStateFont(stateManager.state);
              continue;
            }
            args[0] = self2.handleText(args[0], stateManager.state);
            break;
          case OPS.showSpacedText:
            if (!stateManager.state.font) {
              self2.ensureStateFont(stateManager.state);
              continue;
            }
            var arr = args[0];
            var combinedGlyphs = [];
            var arrLength = arr.length;
            var state = stateManager.state;
            for (i = 0; i < arrLength; ++i) {
              const arrItem = arr[i];
              if (isString(arrItem)) {
                Array.prototype.push.apply(combinedGlyphs, self2.handleText(arrItem, state));
              } else if (isNum(arrItem)) {
                combinedGlyphs.push(arrItem);
              }
            }
            args[0] = combinedGlyphs;
            fn = OPS.showText;
            break;
          case OPS.nextLineShowText:
            if (!stateManager.state.font) {
              self2.ensureStateFont(stateManager.state);
              continue;
            }
            operatorList.addOp(OPS.nextLine);
            args[0] = self2.handleText(args[0], stateManager.state);
            fn = OPS.showText;
            break;
          case OPS.nextLineSetSpacingShowText:
            if (!stateManager.state.font) {
              self2.ensureStateFont(stateManager.state);
              continue;
            }
            operatorList.addOp(OPS.nextLine);
            operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
            operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
            args[0] = self2.handleText(args[0], stateManager.state);
            fn = OPS.showText;
            break;
          case OPS.setTextRenderingMode:
            stateManager.state.textRenderingMode = args[0];
            break;
          case OPS.setFillColorSpace: {
            const cachedColorSpace = ColorSpace.getCached(args[0], xref, localColorSpaceCache);
            if (cachedColorSpace) {
              stateManager.state.fillColorSpace = cachedColorSpace;
              continue;
            }
            next(self2.parseColorSpace({
              cs: args[0],
              resources,
              localColorSpaceCache
            }).then(function(colorSpace) {
              if (colorSpace) {
                stateManager.state.fillColorSpace = colorSpace;
              }
            }));
            return;
          }
          case OPS.setStrokeColorSpace: {
            const cachedColorSpace = ColorSpace.getCached(args[0], xref, localColorSpaceCache);
            if (cachedColorSpace) {
              stateManager.state.strokeColorSpace = cachedColorSpace;
              continue;
            }
            next(self2.parseColorSpace({
              cs: args[0],
              resources,
              localColorSpaceCache
            }).then(function(colorSpace) {
              if (colorSpace) {
                stateManager.state.strokeColorSpace = colorSpace;
              }
            }));
            return;
          }
          case OPS.setFillColor:
            cs = stateManager.state.fillColorSpace;
            args = cs.getRgb(args, 0);
            fn = OPS.setFillRGBColor;
            break;
          case OPS.setStrokeColor:
            cs = stateManager.state.strokeColorSpace;
            args = cs.getRgb(args, 0);
            fn = OPS.setStrokeRGBColor;
            break;
          case OPS.setFillGray:
            stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
            args = ColorSpace.singletons.gray.getRgb(args, 0);
            fn = OPS.setFillRGBColor;
            break;
          case OPS.setStrokeGray:
            stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
            args = ColorSpace.singletons.gray.getRgb(args, 0);
            fn = OPS.setStrokeRGBColor;
            break;
          case OPS.setFillCMYKColor:
            stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
            args = ColorSpace.singletons.cmyk.getRgb(args, 0);
            fn = OPS.setFillRGBColor;
            break;
          case OPS.setStrokeCMYKColor:
            stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
            args = ColorSpace.singletons.cmyk.getRgb(args, 0);
            fn = OPS.setStrokeRGBColor;
            break;
          case OPS.setFillRGBColor:
            stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
            args = ColorSpace.singletons.rgb.getRgb(args, 0);
            break;
          case OPS.setStrokeRGBColor:
            stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
            args = ColorSpace.singletons.rgb.getRgb(args, 0);
            break;
          case OPS.setFillColorN:
            cs = stateManager.state.fillColorSpace;
            if (cs.name === "Pattern") {
              next(self2.handleColorN(operatorList, OPS.setFillColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
              return;
            }
            args = cs.getRgb(args, 0);
            fn = OPS.setFillRGBColor;
            break;
          case OPS.setStrokeColorN:
            cs = stateManager.state.strokeColorSpace;
            if (cs.name === "Pattern") {
              next(self2.handleColorN(operatorList, OPS.setStrokeColorN, args, cs, patterns, resources, task, localColorSpaceCache, localTilingPatternCache, localShadingPatternCache));
              return;
            }
            args = cs.getRgb(args, 0);
            fn = OPS.setStrokeRGBColor;
            break;
          case OPS.shadingFill:
            var shadingRes = resources.get("Shading");
            if (!shadingRes) {
              throw new FormatError("No shading resource found");
            }
            var shading = shadingRes.get(args[0].name);
            if (!shading) {
              throw new FormatError("No shading object found");
            }
            const patternId = self2.parseShading({
              keyObj: shading,
              shading,
              resources,
              localColorSpaceCache,
              localShadingPatternCache
            });
            args = [patternId];
            fn = OPS.shadingFill;
            break;
          case OPS.setGState:
            isValidName = args[0] instanceof Name;
            name = args[0].name;
            if (isValidName) {
              const localGStateObj = localGStateCache.getByName(name);
              if (localGStateObj) {
                if (localGStateObj.length > 0) {
                  operatorList.addOp(OPS.setGState, [localGStateObj]);
                }
                args = null;
                continue;
              }
            }
            next(new Promise(function(resolveGState, rejectGState) {
              if (!isValidName) {
                throw new FormatError("GState must be referred to by name.");
              }
              const extGState = resources.get("ExtGState");
              if (!(extGState instanceof Dict)) {
                throw new FormatError("ExtGState should be a dictionary.");
              }
              const gState = extGState.get(name);
              if (!(gState instanceof Dict)) {
                throw new FormatError("GState should be a dictionary.");
              }
              self2.setGState({
                resources,
                gState,
                operatorList,
                cacheKey: name,
                task,
                stateManager,
                localGStateCache,
                localColorSpaceCache
              }).then(resolveGState, rejectGState);
            }).catch(function(reason) {
              if (reason instanceof AbortException) {
                return;
              }
              if (self2.options.ignoreErrors) {
                self2.handler.send("UnsupportedFeature", {
                  featureId: UNSUPPORTED_FEATURES.errorExtGState
                });
                warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
                return;
              }
              throw reason;
            }));
            return;
          case OPS.moveTo:
          case OPS.lineTo:
          case OPS.curveTo:
          case OPS.curveTo2:
          case OPS.curveTo3:
          case OPS.closePath:
          case OPS.rectangle:
            self2.buildPath(operatorList, fn, args, parsingText);
            continue;
          case OPS.markPoint:
          case OPS.markPointProps:
          case OPS.beginCompat:
          case OPS.endCompat:
            continue;
          case OPS.beginMarkedContentProps:
            if (!isName(args[0])) {
              warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
              continue;
            }
            if (args[0].name === "OC") {
              next(self2.parseMarkedContentProps(args[1], resources).then((data) => {
                operatorList.addOp(OPS.beginMarkedContentProps, ["OC", data]);
              }).catch((reason) => {
                if (reason instanceof AbortException) {
                  return;
                }
                if (self2.options.ignoreErrors) {
                  self2.handler.send("UnsupportedFeature", {
                    featureId: UNSUPPORTED_FEATURES.errorMarkedContent
                  });
                  warn(`getOperatorList - ignoring beginMarkedContentProps: "${reason}".`);
                  return;
                }
                throw reason;
              }));
              return;
            }
            args = [args[0].name, args[1] instanceof Dict ? args[1].get("MCID") : null];
            break;
          case OPS.beginMarkedContent:
          case OPS.endMarkedContent:
          default:
            if (args !== null) {
              for (i = 0, ii = args.length; i < ii; i++) {
                if (args[i] instanceof Dict) {
                  break;
                }
              }
              if (i < ii) {
                warn("getOperatorList - ignoring operator: " + fn);
                continue;
              }
            }
        }
        operatorList.addOp(fn, args);
      }
      if (stop) {
        next(deferred);
        return;
      }
      closePendingRestoreOPS();
      resolve();
    }).catch((reason) => {
      if (reason instanceof AbortException) {
        return;
      }
      if (this.options.ignoreErrors) {
        this.handler.send("UnsupportedFeature", {
          featureId: UNSUPPORTED_FEATURES.errorOperatorList
        });
        warn(`getOperatorList - ignoring errors during "${task.name}" task: "${reason}".`);
        closePendingRestoreOPS();
        return;
      }
      throw reason;
    });
  }
  getTextContent({
    stream,
    task,
    resources,
    stateManager = null,
    normalizeWhitespace = false,
    combineTextItems = false,
    includeMarkedContent = false,
    sink,
    seenStyles = /* @__PURE__ */ new Set()
  }) {
    resources = resources || Dict.empty;
    stateManager = stateManager || new StateManager(new TextState());
    const WhitespaceRegexp = /\s/g;
    const textContent = {
      items: [],
      styles: /* @__PURE__ */ Object.create(null)
    };
    const textContentItem = {
      initialized: false,
      str: [],
      totalWidth: 0,
      totalHeight: 0,
      width: 0,
      height: 0,
      vertical: false,
      lastCharSize: 0,
      prevTransform: null,
      textAdvanceScale: 0,
      spaceWidth: 0,
      spaceInFlowMin: 0,
      spaceInFlowMax: 0,
      trackingSpaceMin: Infinity,
      transform: null,
      fontName: null,
      hasEOL: false,
      isLastCharWhiteSpace: false
    };
    const TRACKING_SPACE_FACTOR = 0.3;
    const SPACE_IN_FLOW_MIN_FACTOR = 0.3;
    const SPACE_IN_FLOW_MAX_FACTOR = 1.3;
    const self2 = this;
    const xref = this.xref;
    const showSpacedTextBuffer = [];
    let xobjs = null;
    const emptyXObjectCache = new LocalImageCache();
    const emptyGStateCache = new LocalGStateCache();
    const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
    let textState;
    function getCurrentTextTransform() {
      const font = textState.font;
      const tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
      if (font.isType3Font && (textState.fontSize <= 1 || font.isCharBBox) && !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)) {
        const glyphHeight = font.bbox[3] - font.bbox[1];
        if (glyphHeight > 0) {
          tsm[3] *= glyphHeight * textState.fontMatrix[3];
        }
      }
      return Util.transform(textState.ctm, Util.transform(textState.textMatrix, tsm));
    }
    function ensureTextContentItem() {
      if (textContentItem.initialized) {
        return textContentItem;
      }
      const font = textState.font, loadedName = font.loadedName;
      if (!seenStyles.has(loadedName)) {
        seenStyles.add(loadedName);
        textContent.styles[loadedName] = {
          fontFamily: font.fallbackName,
          ascent: font.ascent,
          descent: font.descent,
          vertical: font.vertical
        };
      }
      textContentItem.fontName = loadedName;
      const trm = textContentItem.transform = getCurrentTextTransform();
      if (!font.vertical) {
        textContentItem.width = textContentItem.totalWidth = 0;
        textContentItem.height = textContentItem.totalHeight = Math.hypot(trm[2], trm[3]);
        textContentItem.vertical = false;
      } else {
        textContentItem.width = textContentItem.totalWidth = Math.hypot(trm[0], trm[1]);
        textContentItem.height = textContentItem.totalHeight = 0;
        textContentItem.vertical = true;
      }
      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
      textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
      textContentItem.lastCharSize = textContentItem.lastCharSize || 0;
      const spaceWidth = font.spaceWidth / 1e3 * textState.fontSize;
      if (spaceWidth) {
        textContentItem.spaceWidth = spaceWidth;
        textContentItem.trackingSpaceMin = spaceWidth * TRACKING_SPACE_FACTOR;
        textContentItem.spaceInFlowMin = spaceWidth * SPACE_IN_FLOW_MIN_FACTOR;
        textContentItem.spaceInFlowMax = spaceWidth * SPACE_IN_FLOW_MAX_FACTOR;
      } else {
        textContentItem.spaceWidth = 0;
        textContentItem.trackingSpaceMin = Infinity;
      }
      textContentItem.hasEOL = false;
      textContentItem.initialized = true;
      return textContentItem;
    }
    function updateAdvanceScale() {
      if (!textContentItem.initialized) {
        return;
      }
      const scaleLineX = Math.hypot(textState.textLineMatrix[0], textState.textLineMatrix[1]);
      const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
      const scaleFactor = scaleCtmX * scaleLineX;
      if (scaleFactor === textContentItem.textAdvanceScale) {
        return;
      }
      if (!textContentItem.vertical) {
        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
        textContentItem.width = 0;
      } else {
        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
        textContentItem.height = 0;
      }
      textContentItem.textAdvanceScale = scaleFactor;
    }
    function replaceWhitespace(str) {
      const ii = str.length;
      let i = 0, code;
      while (i < ii && (code = str.charCodeAt(i)) >= 32 && code <= 127) {
        i++;
      }
      return i < ii ? str.replace(WhitespaceRegexp, " ") : str;
    }
    function runBidiTransform(textChunk) {
      const text = textChunk.str.join("");
      const bidiResult = bidi(text, -1, textChunk.vertical);
      const str = normalizeWhitespace ? replaceWhitespace(bidiResult.str) : bidiResult.str;
      return {
        str,
        dir: bidiResult.dir,
        width: textChunk.totalWidth,
        height: textChunk.totalHeight,
        transform: textChunk.transform,
        fontName: textChunk.fontName,
        hasEOL: textChunk.hasEOL
      };
    }
    function handleSetFont(fontName, fontRef) {
      return self2.loadFont(fontName, fontRef, resources).then(function(translated) {
        if (!translated.font.isType3Font) {
          return translated;
        }
        return translated.loadType3Data(self2, resources, task).catch(function() {
        }).then(function() {
          return translated;
        });
      }).then(function(translated) {
        textState.font = translated.font;
        textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
      });
    }
    function compareWithLastPosition(fontSize) {
      if (!combineTextItems || !textState.font || !textContentItem.prevTransform) {
        return;
      }
      const currentTransform = getCurrentTextTransform();
      const posX = currentTransform[4];
      const posY = currentTransform[5];
      const lastPosX = textContentItem.prevTransform[4];
      const lastPosY = textContentItem.prevTransform[5];
      if (lastPosX === posX && lastPosY === posY) {
        return;
      }
      const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
      const advanceY = (posY - lastPosY) / textContentItem.textAdvanceScale;
      const HALF_LAST_CHAR = -0.5 * textContentItem.lastCharSize;
      if (textState.font.vertical) {
        if (Math.abs(advanceX) > textContentItem.width / textContentItem.textAdvanceScale) {
          appendEOL();
          return;
        }
        if (HALF_LAST_CHAR > advanceY) {
          return;
        }
        if (advanceY > textContentItem.trackingSpaceMin) {
          textContentItem.height += advanceY;
        } else if (!addFakeSpaces(advanceY, 0, textContentItem.prevTransform)) {
          if (textContentItem.str.length === 0) {
            textContent.items.push({
              str: " ",
              dir: "ltr",
              width: 0,
              height: advanceY,
              transform: textContentItem.prevTransform,
              fontName: textContentItem.fontName,
              hasEOL: false
            });
            textContentItem.isLastCharWhiteSpace = true;
          } else {
            textContentItem.height += advanceY;
          }
        }
        return;
      }
      if (Math.abs(advanceY) > textContentItem.height / textContentItem.textAdvanceScale) {
        appendEOL();
        return;
      }
      if (HALF_LAST_CHAR > advanceX) {
        return;
      }
      if (advanceX <= textContentItem.trackingSpaceMin) {
        textContentItem.width += advanceX;
      } else if (!addFakeSpaces(advanceX, 0, textContentItem.prevTransform)) {
        if (textContentItem.str.length === 0) {
          textContent.items.push({
            str: " ",
            dir: "ltr",
            width: advanceX,
            height: 0,
            transform: textContentItem.prevTransform,
            fontName: textContentItem.fontName,
            hasEOL: false
          });
          textContentItem.isLastCharWhiteSpace = true;
        } else {
          textContentItem.width += advanceX;
        }
      }
    }
    function buildTextContentItem({
      chars: chars2,
      extraSpacing,
      isFirstChunk
    }) {
      const font = textState.font;
      if (!chars2) {
        const charSpacing = textState.charSpacing + extraSpacing;
        if (charSpacing) {
          if (!font.vertical) {
            textState.translateTextMatrix(charSpacing * textState.textHScale, 0);
          } else {
            textState.translateTextMatrix(0, charSpacing);
          }
        }
        return;
      }
      const NormalizedUnicodes = getNormalizedUnicodes();
      const glyphs = font.charsToGlyphs(chars2);
      const scale = textState.fontMatrix[0] * textState.fontSize;
      if (isFirstChunk) {
        compareWithLastPosition();
      }
      let textChunk = ensureTextContentItem();
      let size = 0;
      let lastCharSize = 0;
      for (let i = 0, ii = glyphs.length; i < ii; i++) {
        const glyph = glyphs[i];
        let charSpacing = textState.charSpacing + (i === ii - 1 ? extraSpacing : 0);
        let glyphUnicode = glyph.unicode;
        if (glyph.isSpace) {
          charSpacing += textState.wordSpacing;
          textChunk.isLastCharWhiteSpace = true;
        } else {
          glyphUnicode = NormalizedUnicodes[glyphUnicode] || glyphUnicode;
          glyphUnicode = reverseIfRtl(glyphUnicode);
          textChunk.isLastCharWhiteSpace = false;
        }
        textChunk.str.push(glyphUnicode);
        const glyphWidth = font.vertical && glyph.vmetric ? glyph.vmetric[0] : glyph.width;
        let scaledDim = glyphWidth * scale;
        if (!font.vertical) {
          scaledDim *= textState.textHScale;
          textState.translateTextMatrix(scaledDim, 0);
        } else {
          textState.translateTextMatrix(0, scaledDim);
          scaledDim = Math.abs(scaledDim);
        }
        size += scaledDim;
        if (charSpacing) {
          if (!font.vertical) {
            charSpacing *= textState.textHScale;
          }
          scaledDim += charSpacing;
          const wasSplit = charSpacing > textContentItem.trackingSpaceMin && addFakeSpaces(charSpacing, size);
          if (!font.vertical) {
            textState.translateTextMatrix(charSpacing, 0);
          } else {
            textState.translateTextMatrix(0, charSpacing);
          }
          if (wasSplit) {
            textChunk = ensureTextContentItem();
            size = 0;
          } else {
            size += charSpacing;
          }
        }
        lastCharSize = scaledDim;
      }
      textChunk.lastCharSize = lastCharSize;
      if (!font.vertical) {
        textChunk.width += size;
      } else {
        textChunk.height += size;
      }
      textChunk.prevTransform = getCurrentTextTransform();
    }
    function appendEOL() {
      if (textContentItem.initialized) {
        textContentItem.hasEOL = true;
        flushTextContentItem();
      } else if (textContent.items.length > 0) {
        textContent.items[textContent.items.length - 1].hasEOL = true;
      } else {
        textContent.items.push({
          str: "",
          dir: "ltr",
          width: 0,
          height: 0,
          transform: getCurrentTextTransform(),
          fontName: textState.font.loadedName,
          hasEOL: true
        });
      }
      textContentItem.isLastCharWhiteSpace = false;
      textContentItem.lastCharSize = 0;
    }
    function addFakeSpaces(width, size, transf = null) {
      if (textContentItem.spaceInFlowMin <= width && width <= textContentItem.spaceInFlowMax) {
        if (textContentItem.initialized) {
          textContentItem.str.push(" ");
          textContentItem.isLastCharWhiteSpace = true;
        }
        return false;
      }
      const fontName = textContentItem.fontName;
      let height = 0;
      width *= textContentItem.textAdvanceScale;
      if (!textContentItem.vertical) {
        textContentItem.width += size;
      } else {
        textContentItem.height += size;
        height = width;
        width = 0;
      }
      flushTextContentItem();
      if (textContentItem.isLastCharWhiteSpace) {
        return true;
      }
      textContentItem.isLastCharWhiteSpace = true;
      textContent.items.push({
        str: " ",
        // TODO: check if using the orientation from last chunk is
        // better or not.
        dir: "ltr",
        width,
        height,
        transform: transf ? transf : getCurrentTextTransform(),
        fontName,
        hasEOL: false
      });
      return true;
    }
    function flushTextContentItem() {
      if (!textContentItem.initialized || !textContentItem.str) {
        return;
      }
      if (!textContentItem.vertical) {
        textContentItem.totalWidth += textContentItem.width * textContentItem.textAdvanceScale;
      } else {
        textContentItem.totalHeight += textContentItem.height * textContentItem.textAdvanceScale;
      }
      textContent.items.push(runBidiTransform(textContentItem));
      textContentItem.initialized = false;
      textContentItem.str.length = 0;
    }
    function enqueueChunk() {
      const length = textContent.items.length;
      if (length > 0) {
        sink.enqueue(textContent, length);
        textContent.items = [];
        textContent.styles = /* @__PURE__ */ Object.create(null);
      }
    }
    const timeSlotManager = new TimeSlotManager();
    return new Promise(function promiseBody(resolve, reject) {
      const next = function(promise) {
        enqueueChunk();
        Promise.all([promise, sink.ready]).then(function() {
          try {
            promiseBody(resolve, reject);
          } catch (ex) {
            reject(ex);
          }
        }, reject);
      };
      task.ensureNotTerminated();
      timeSlotManager.reset();
      const operation = {};
      let stop, args = [];
      while (!(stop = timeSlotManager.check())) {
        args.length = 0;
        operation.args = args;
        if (!preprocessor.read(operation)) {
          break;
        }
        textState = stateManager.state;
        const fn = operation.fn;
        args = operation.args;
        switch (fn | 0) {
          case OPS.setFont:
            var fontNameArg = args[0].name, fontSizeArg = args[1];
            if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
              break;
            }
            flushTextContentItem();
            textState.fontName = fontNameArg;
            textState.fontSize = fontSizeArg;
            next(handleSetFont(fontNameArg, null));
            return;
          case OPS.setTextRise:
            flushTextContentItem();
            textState.textRise = args[0];
            break;
          case OPS.setHScale:
            flushTextContentItem();
            textState.textHScale = args[0] / 100;
            break;
          case OPS.setLeading:
            flushTextContentItem();
            textState.leading = args[0];
            break;
          case OPS.moveText:
            textState.translateTextLineMatrix(args[0], args[1]);
            textState.textMatrix = textState.textLineMatrix.slice();
            break;
          case OPS.setLeadingMoveText:
            flushTextContentItem();
            textState.leading = -args[1];
            textState.translateTextLineMatrix(args[0], args[1]);
            textState.textMatrix = textState.textLineMatrix.slice();
            break;
          case OPS.nextLine:
            appendEOL();
            textState.carriageReturn();
            break;
          case OPS.setTextMatrix:
            textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            updateAdvanceScale();
            break;
          case OPS.setCharSpacing:
            textState.charSpacing = args[0];
            break;
          case OPS.setWordSpacing:
            textState.wordSpacing = args[0];
            break;
          case OPS.beginText:
            flushTextContentItem();
            textState.textMatrix = IDENTITY_MATRIX.slice();
            textState.textLineMatrix = IDENTITY_MATRIX.slice();
            break;
          case OPS.showSpacedText:
            if (!stateManager.state.font) {
              self2.ensureStateFont(stateManager.state);
              continue;
            }
            const spaceFactor = (textState.font.vertical ? 1 : -1) * textState.fontSize / 1e3;
            const elements = args[0];
            let isFirstChunk = true;
            for (let i = 0, ii = elements.length; i < ii - 1; i++) {
              const item2 = elements[i];
              if (typeof item2 === "string") {
                showSpacedTextBuffer.push(item2);
              } else if (typeof item2 === "number" && item2 !== 0) {
                const str = showSpacedTextBuffer.join("");
                showSpacedTextBuffer.length = 0;
                buildTextContentItem({
                  chars: str,
                  extraSpacing: item2 * spaceFactor,
                  isFirstChunk
                });
                if (str && isFirstChunk) {
                  isFirstChunk = false;
                }
              }
            }
            const item = elements[elements.length - 1];
            if (typeof item === "string") {
              showSpacedTextBuffer.push(item);
            }
            if (showSpacedTextBuffer.length > 0) {
              const str = showSpacedTextBuffer.join("");
              showSpacedTextBuffer.length = 0;
              buildTextContentItem({
                chars: str,
                extraSpacing: 0,
                isFirstChunk
              });
            }
            break;
          case OPS.showText:
            if (!stateManager.state.font) {
              self2.ensureStateFont(stateManager.state);
              continue;
            }
            buildTextContentItem({
              chars: args[0],
              extraSpacing: 0,
              isFirstChunk: true
            });
            break;
          case OPS.nextLineShowText:
            if (!stateManager.state.font) {
              self2.ensureStateFont(stateManager.state);
              continue;
            }
            textContentItem.hasEOL = true;
            flushTextContentItem();
            textState.carriageReturn();
            buildTextContentItem({
              chars: args[0],
              extraSpacing: 0,
              isFirstChunk: true
            });
            break;
          case OPS.nextLineSetSpacingShowText:
            if (!stateManager.state.font) {
              self2.ensureStateFont(stateManager.state);
              continue;
            }
            textContentItem.hasEOL = true;
            flushTextContentItem();
            textState.wordSpacing = args[0];
            textState.charSpacing = args[1];
            textState.carriageReturn();
            buildTextContentItem({
              chars: args[2],
              extraSpacing: 0,
              isFirstChunk: true
            });
            break;
          case OPS.paintXObject:
            flushTextContentItem();
            if (!xobjs) {
              xobjs = resources.get("XObject") || Dict.empty;
            }
            var isValidName = args[0] instanceof Name;
            var name = args[0].name;
            if (isValidName && emptyXObjectCache.getByName(name)) {
              break;
            }
            next(new Promise(function(resolveXObject, rejectXObject) {
              if (!isValidName) {
                throw new FormatError("XObject must be referred to by name.");
              }
              let xobj = xobjs.getRaw(name);
              if (xobj instanceof Ref) {
                if (emptyXObjectCache.getByRef(xobj)) {
                  resolveXObject();
                  return;
                }
                const globalImage = self2.globalImageCache.getData(xobj, self2.pageIndex);
                if (globalImage) {
                  resolveXObject();
                  return;
                }
                xobj = xref.fetch(xobj);
              }
              if (!isStream(xobj)) {
                throw new FormatError("XObject should be a stream");
              }
              const type = xobj.dict.get("Subtype");
              if (!isName(type)) {
                throw new FormatError("XObject should have a Name subtype");
              }
              if (type.name !== "Form") {
                emptyXObjectCache.set(name, xobj.dict.objId, true);
                resolveXObject();
                return;
              }
              const currentState = stateManager.state.clone();
              const xObjStateManager = new StateManager(currentState);
              const matrix = xobj.dict.getArray("Matrix");
              if (Array.isArray(matrix) && matrix.length === 6) {
                xObjStateManager.transform(matrix);
              }
              enqueueChunk();
              const sinkWrapper = {
                enqueueInvoked: false,
                enqueue(chunk, size) {
                  this.enqueueInvoked = true;
                  sink.enqueue(chunk, size);
                },
                get desiredSize() {
                  return sink.desiredSize;
                },
                get ready() {
                  return sink.ready;
                }
              };
              self2.getTextContent({
                stream: xobj,
                task,
                resources: xobj.dict.get("Resources") || resources,
                stateManager: xObjStateManager,
                normalizeWhitespace,
                combineTextItems,
                includeMarkedContent,
                sink: sinkWrapper,
                seenStyles
              }).then(function() {
                if (!sinkWrapper.enqueueInvoked) {
                  emptyXObjectCache.set(name, xobj.dict.objId, true);
                }
                resolveXObject();
              }, rejectXObject);
            }).catch(function(reason) {
              if (reason instanceof AbortException) {
                return;
              }
              if (self2.options.ignoreErrors) {
                warn(`getTextContent - ignoring XObject: "${reason}".`);
                return;
              }
              throw reason;
            }));
            return;
          case OPS.setGState:
            isValidName = args[0] instanceof Name;
            name = args[0].name;
            if (isValidName && emptyGStateCache.getByName(name)) {
              break;
            }
            next(new Promise(function(resolveGState, rejectGState) {
              if (!isValidName) {
                throw new FormatError("GState must be referred to by name.");
              }
              const extGState = resources.get("ExtGState");
              if (!(extGState instanceof Dict)) {
                throw new FormatError("ExtGState should be a dictionary.");
              }
              const gState = extGState.get(name);
              if (!(gState instanceof Dict)) {
                throw new FormatError("GState should be a dictionary.");
              }
              const gStateFont = gState.get("Font");
              if (!gStateFont) {
                emptyGStateCache.set(name, gState.objId, true);
                resolveGState();
                return;
              }
              flushTextContentItem();
              textState.fontName = null;
              textState.fontSize = gStateFont[1];
              handleSetFont(null, gStateFont[0]).then(resolveGState, rejectGState);
            }).catch(function(reason) {
              if (reason instanceof AbortException) {
                return;
              }
              if (self2.options.ignoreErrors) {
                warn(`getTextContent - ignoring ExtGState: "${reason}".`);
                return;
              }
              throw reason;
            }));
            return;
          case OPS.beginMarkedContent:
            if (includeMarkedContent) {
              textContent.items.push({
                type: "beginMarkedContent",
                tag: isName(args[0]) ? args[0].name : null
              });
            }
            break;
          case OPS.beginMarkedContentProps:
            if (includeMarkedContent) {
              flushTextContentItem();
              let mcid = null;
              if (isDict(args[1])) {
                mcid = args[1].get("MCID");
              }
              textContent.items.push({
                type: "beginMarkedContentProps",
                id: Number.isInteger(mcid) ? `${self2.idFactory.getPageObjId()}_mcid${mcid}` : null,
                tag: isName(args[0]) ? args[0].name : null
              });
            }
            break;
          case OPS.endMarkedContent:
            if (includeMarkedContent) {
              flushTextContentItem();
              textContent.items.push({
                type: "endMarkedContent"
              });
            }
            break;
        }
        if (textContent.items.length >= sink.desiredSize) {
          stop = true;
          break;
        }
      }
      if (stop) {
        next(deferred);
        return;
      }
      flushTextContentItem();
      enqueueChunk();
      resolve();
    }).catch((reason) => {
      if (reason instanceof AbortException) {
        return;
      }
      if (this.options.ignoreErrors) {
        warn(`getTextContent - ignoring errors during "${task.name}" task: "${reason}".`);
        flushTextContentItem();
        enqueueChunk();
        return;
      }
      throw reason;
    });
  }
  extractDataStructures(dict, baseDict, properties) {
    const xref = this.xref;
    let cidToGidBytes;
    const toUnicodePromise = this.readToUnicode(properties.toUnicode || dict.get("ToUnicode") || baseDict.get("ToUnicode"));
    if (properties.composite) {
      const cidSystemInfo = dict.get("CIDSystemInfo");
      if (isDict(cidSystemInfo)) {
        properties.cidSystemInfo = {
          registry: stringToPDFString(cidSystemInfo.get("Registry")),
          ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
          supplement: cidSystemInfo.get("Supplement")
        };
      }
      const cidToGidMap = dict.get("CIDToGIDMap");
      if (isStream(cidToGidMap)) {
        cidToGidBytes = cidToGidMap.getBytes();
      }
    }
    const differences = [];
    let baseEncodingName = null;
    let encoding;
    if (dict.has("Encoding")) {
      encoding = dict.get("Encoding");
      if (isDict(encoding)) {
        baseEncodingName = encoding.get("BaseEncoding");
        baseEncodingName = isName(baseEncodingName) ? baseEncodingName.name : null;
        if (encoding.has("Differences")) {
          const diffEncoding = encoding.get("Differences");
          let index = 0;
          for (let j = 0, jj = diffEncoding.length; j < jj; j++) {
            const data = xref.fetchIfRef(diffEncoding[j]);
            if (isNum(data)) {
              index = data;
            } else if (isName(data)) {
              differences[index++] = data.name;
            } else {
              throw new FormatError(`Invalid entry in 'Differences' array: ${data}`);
            }
          }
        }
      } else if (isName(encoding)) {
        baseEncodingName = encoding.name;
      } else {
        throw new FormatError("Encoding is not a Name nor a Dict");
      }
      if (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
        baseEncodingName = null;
      }
    }
    if (baseEncodingName) {
      properties.defaultEncoding = getEncoding(baseEncodingName);
    } else {
      const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
      const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
      encoding = StandardEncoding;
      if (properties.type === "TrueType" && !isNonsymbolicFont) {
        encoding = WinAnsiEncoding;
      }
      if (isSymbolicFont) {
        encoding = MacRomanEncoding;
        if (!properties.file || properties.isInternalFont) {
          if (/Symbol/i.test(properties.name)) {
            encoding = SymbolSetEncoding;
          } else if (/Dingbats|Wingdings/i.test(properties.name)) {
            encoding = ZapfDingbatsEncoding;
          }
        }
      }
      properties.defaultEncoding = encoding;
    }
    properties.differences = differences;
    properties.baseEncodingName = baseEncodingName;
    properties.hasEncoding = !!baseEncodingName || differences.length > 0;
    properties.dict = dict;
    return toUnicodePromise.then((readToUnicode) => {
      properties.toUnicode = readToUnicode;
      return this.buildToUnicode(properties);
    }).then((builtToUnicode) => {
      properties.toUnicode = builtToUnicode;
      if (cidToGidBytes) {
        properties.cidToGidMap = this.readCidToGidMap(cidToGidBytes, builtToUnicode);
      }
      return properties;
    });
  }
  /**
   * @returns {Array}
   * @private
   */
  _simpleFontToUnicode(properties, forceGlyphs = false) {
    assert(!properties.composite, "Must be a simple font.");
    const toUnicode = [];
    const encoding = properties.defaultEncoding.slice();
    const baseEncodingName = properties.baseEncodingName;
    const differences = properties.differences;
    for (const charcode in differences) {
      const glyphName = differences[charcode];
      if (glyphName === ".notdef") {
        continue;
      }
      encoding[charcode] = glyphName;
    }
    const glyphsUnicodeMap = getGlyphsUnicode();
    for (const charcode in encoding) {
      let glyphName = encoding[charcode];
      if (glyphName === "") {
        continue;
      } else if (glyphsUnicodeMap[glyphName] === void 0) {
        let code = 0;
        switch (glyphName[0]) {
          case "G":
            if (glyphName.length === 3) {
              code = parseInt(glyphName.substring(1), 16);
            }
            break;
          case "g":
            if (glyphName.length === 5) {
              code = parseInt(glyphName.substring(1), 16);
            }
            break;
          case "C":
          case "c":
            if (glyphName.length >= 3 && glyphName.length <= 4) {
              const codeStr = glyphName.substring(1);
              if (forceGlyphs) {
                code = parseInt(codeStr, 16);
                break;
              }
              code = +codeStr;
              if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
                return this._simpleFontToUnicode(
                  properties,
                  /* forceGlyphs */
                  true
                );
              }
            }
            break;
          default:
            const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
            if (unicode !== -1) {
              code = unicode;
            }
        }
        if (code > 0 && code <= 1114111 && Number.isInteger(code)) {
          if (baseEncodingName && code === +charcode) {
            const baseEncoding = getEncoding(baseEncodingName);
            if (baseEncoding && (glyphName = baseEncoding[charcode])) {
              toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
              continue;
            }
          }
          toUnicode[charcode] = String.fromCodePoint(code);
        }
        continue;
      }
      toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
    }
    return toUnicode;
  }
  /**
   * Builds a char code to unicode map based on section 9.10 of the spec.
   * @param {Object} properties Font properties object.
   * @returns {Promise} A Promise that is resolved with a
   *   {ToUnicodeMap|IdentityToUnicodeMap} object.
   */
  async buildToUnicode(properties) {
    properties.hasIncludedToUnicodeMap = !!properties.toUnicode && properties.toUnicode.length > 0;
    if (properties.hasIncludedToUnicodeMap) {
      if (!properties.composite && properties.hasEncoding) {
        properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
      }
      return properties.toUnicode;
    }
    if (!properties.composite) {
      return new ToUnicodeMap(this._simpleFontToUnicode(properties));
    }
    if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Japan1" || properties.cidSystemInfo.ordering === "Korea1"))) {
      const {
        registry,
        ordering
      } = properties.cidSystemInfo;
      const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
      const ucs2CMap = await CMapFactory.create({
        encoding: ucs2CMapName,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      const toUnicode = [];
      properties.cMap.forEach(function(charcode, cid) {
        if (cid > 65535) {
          throw new FormatError("Max size of CID is 65,535");
        }
        const ucs2 = ucs2CMap.lookup(cid);
        if (ucs2) {
          toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
        }
      });
      return new ToUnicodeMap(toUnicode);
    }
    return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
  }
  readToUnicode(cmapObj) {
    if (!cmapObj) {
      return Promise.resolve(null);
    }
    if (isName(cmapObj)) {
      return CMapFactory.create({
        encoding: cmapObj,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }).then(function(cmap) {
        if (cmap instanceof IdentityCMap) {
          return new IdentityToUnicodeMap(0, 65535);
        }
        return new ToUnicodeMap(cmap.getMap());
      });
    } else if (isStream(cmapObj)) {
      return CMapFactory.create({
        encoding: cmapObj,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }).then(function(cmap) {
        if (cmap instanceof IdentityCMap) {
          return new IdentityToUnicodeMap(0, 65535);
        }
        const map = new Array(cmap.length);
        cmap.forEach(function(charCode, token) {
          const str = [];
          for (let k = 0; k < token.length; k += 2) {
            const w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
            if ((w1 & 63488) !== 55296) {
              str.push(w1);
              continue;
            }
            k += 2;
            const w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
            str.push(((w1 & 1023) << 10) + (w2 & 1023) + 65536);
          }
          map[charCode] = String.fromCodePoint.apply(String, str);
        });
        return new ToUnicodeMap(map);
      }, (reason) => {
        if (reason instanceof AbortException) {
          return null;
        }
        if (this.options.ignoreErrors) {
          this.handler.send("UnsupportedFeature", {
            featureId: UNSUPPORTED_FEATURES.errorFontToUnicode
          });
          warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
          return null;
        }
        throw reason;
      });
    }
    return Promise.resolve(null);
  }
  readCidToGidMap(glyphsData, toUnicode) {
    const result = [];
    for (let j = 0, jj = glyphsData.length; j < jj; j++) {
      const glyphID = glyphsData[j++] << 8 | glyphsData[j];
      const code = j >> 1;
      if (glyphID === 0 && !toUnicode.has(code)) {
        continue;
      }
      result[code] = glyphID;
    }
    return result;
  }
  extractWidths(dict, descriptor, properties) {
    const xref = this.xref;
    let glyphsWidths = [];
    let defaultWidth = 0;
    const glyphsVMetrics = [];
    let defaultVMetrics;
    let i, ii, j, jj, start, code, widths;
    if (properties.composite) {
      defaultWidth = dict.has("DW") ? dict.get("DW") : 1e3;
      widths = dict.get("W");
      if (widths) {
        for (i = 0, ii = widths.length; i < ii; i++) {
          start = xref.fetchIfRef(widths[i++]);
          code = xref.fetchIfRef(widths[i]);
          if (Array.isArray(code)) {
            for (j = 0, jj = code.length; j < jj; j++) {
              glyphsWidths[start++] = xref.fetchIfRef(code[j]);
            }
          } else {
            const width = xref.fetchIfRef(widths[++i]);
            for (j = start; j <= code; j++) {
              glyphsWidths[j] = width;
            }
          }
        }
      }
      if (properties.vertical) {
        let vmetrics = dict.getArray("DW2") || [880, -1e3];
        defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
        vmetrics = dict.get("W2");
        if (vmetrics) {
          for (i = 0, ii = vmetrics.length; i < ii; i++) {
            start = xref.fetchIfRef(vmetrics[i++]);
            code = xref.fetchIfRef(vmetrics[i]);
            if (Array.isArray(code)) {
              for (j = 0, jj = code.length; j < jj; j++) {
                glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
              }
            } else {
              const vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];
              for (j = start; j <= code; j++) {
                glyphsVMetrics[j] = vmetric;
              }
            }
          }
        }
      }
    } else {
      const firstChar = properties.firstChar;
      widths = dict.get("Widths");
      if (widths) {
        j = firstChar;
        for (i = 0, ii = widths.length; i < ii; i++) {
          glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
        }
        defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
      } else {
        const baseFontName = dict.get("BaseFont");
        if (isName(baseFontName)) {
          const metrics = this.getBaseFontMetrics(baseFontName.name);
          glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
          defaultWidth = metrics.defaultWidth;
        }
      }
    }
    let isMonospace = true;
    let firstWidth = defaultWidth;
    for (const glyph in glyphsWidths) {
      const glyphWidth = glyphsWidths[glyph];
      if (!glyphWidth) {
        continue;
      }
      if (!firstWidth) {
        firstWidth = glyphWidth;
        continue;
      }
      if (firstWidth !== glyphWidth) {
        isMonospace = false;
        break;
      }
    }
    if (isMonospace) {
      properties.flags |= FontFlags.FixedPitch;
    }
    properties.defaultWidth = defaultWidth;
    properties.widths = glyphsWidths;
    properties.defaultVMetrics = defaultVMetrics;
    properties.vmetrics = glyphsVMetrics;
  }
  isSerifFont(baseFontName) {
    const fontNameWoStyle = baseFontName.split("-")[0];
    return fontNameWoStyle in getSerifFonts() || fontNameWoStyle.search(/serif/gi) !== -1;
  }
  getBaseFontMetrics(name) {
    let defaultWidth = 0;
    let widths = /* @__PURE__ */ Object.create(null);
    let monospace = false;
    const stdFontMap = getStdFontMap();
    let lookupName = stdFontMap[name] || name;
    const Metrics = getMetrics();
    if (!(lookupName in Metrics)) {
      if (this.isSerifFont(name)) {
        lookupName = "Times-Roman";
      } else {
        lookupName = "Helvetica";
      }
    }
    const glyphWidths = Metrics[lookupName];
    if (isNum(glyphWidths)) {
      defaultWidth = glyphWidths;
      monospace = true;
    } else {
      widths = glyphWidths();
    }
    return {
      defaultWidth,
      monospace,
      widths
    };
  }
  buildCharCodeToWidth(widthsByGlyphName, properties) {
    const widths = /* @__PURE__ */ Object.create(null);
    const differences = properties.differences;
    const encoding = properties.defaultEncoding;
    for (let charCode = 0; charCode < 256; charCode++) {
      if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
        widths[charCode] = widthsByGlyphName[differences[charCode]];
        continue;
      }
      if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
        widths[charCode] = widthsByGlyphName[encoding[charCode]];
        continue;
      }
    }
    return widths;
  }
  preEvaluateFont(dict) {
    const baseDict = dict;
    let type = dict.get("Subtype");
    if (!isName(type)) {
      throw new FormatError("invalid font Subtype");
    }
    let composite = false;
    let hash, toUnicode;
    if (type.name === "Type0") {
      const df = dict.get("DescendantFonts");
      if (!df) {
        throw new FormatError("Descendant fonts are not specified");
      }
      dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
      if (!(dict instanceof Dict)) {
        throw new FormatError("Descendant font is not a dictionary.");
      }
      type = dict.get("Subtype");
      if (!isName(type)) {
        throw new FormatError("invalid font Subtype");
      }
      composite = true;
    }
    const firstChar = dict.get("FirstChar") || 0, lastChar = dict.get("LastChar") || (composite ? 65535 : 255);
    const descriptor = dict.get("FontDescriptor");
    if (descriptor) {
      hash = new MurmurHash3_64();
      const encoding = baseDict.getRaw("Encoding");
      if (isName(encoding)) {
        hash.update(encoding.name);
      } else if (isRef(encoding)) {
        hash.update(encoding.toString());
      } else if (isDict(encoding)) {
        for (const entry of encoding.getRawValues()) {
          if (isName(entry)) {
            hash.update(entry.name);
          } else if (isRef(entry)) {
            hash.update(entry.toString());
          } else if (Array.isArray(entry)) {
            const diffLength = entry.length, diffBuf = new Array(diffLength);
            for (let j = 0; j < diffLength; j++) {
              const diffEntry = entry[j];
              if (isName(diffEntry)) {
                diffBuf[j] = diffEntry.name;
              } else if (isNum(diffEntry) || isRef(diffEntry)) {
                diffBuf[j] = diffEntry.toString();
              }
            }
            hash.update(diffBuf.join());
          }
        }
      }
      hash.update(`${firstChar}-${lastChar}`);
      toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
      if (isStream(toUnicode)) {
        const stream = toUnicode.str || toUnicode;
        const uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
        hash.update(uint8array);
      } else if (isName(toUnicode)) {
        hash.update(toUnicode.name);
      }
      const widths = dict.get("Widths") || baseDict.get("Widths");
      if (Array.isArray(widths)) {
        const widthsBuf = [];
        for (const entry of widths) {
          if (isNum(entry) || isRef(entry)) {
            widthsBuf.push(entry.toString());
          }
        }
        hash.update(widthsBuf.join());
      }
      if (composite) {
        hash.update("compositeFont");
        const compositeWidths = dict.get("W") || baseDict.get("W");
        if (Array.isArray(compositeWidths)) {
          const widthsBuf = [];
          for (const entry of compositeWidths) {
            if (isNum(entry) || isRef(entry)) {
              widthsBuf.push(entry.toString());
            } else if (Array.isArray(entry)) {
              const subWidthsBuf = [];
              for (const element of entry) {
                if (isNum(element) || isRef(element)) {
                  subWidthsBuf.push(element.toString());
                }
              }
              widthsBuf.push(`[${subWidthsBuf.join()}]`);
            }
          }
          hash.update(widthsBuf.join());
        }
      }
    }
    return {
      descriptor,
      dict,
      baseDict,
      composite,
      type: type.name,
      firstChar,
      lastChar,
      toUnicode,
      hash: hash ? hash.hexdigest() : ""
    };
  }
  async translateFont({
    descriptor,
    dict,
    baseDict,
    composite,
    type,
    firstChar,
    lastChar,
    toUnicode,
    cssFontInfo
  }) {
    const isType3Font = type === "Type3";
    let properties;
    if (!descriptor) {
      if (isType3Font) {
        descriptor = new Dict(null);
        descriptor.set("FontName", Name.get(type));
        descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
      } else {
        let baseFontName = dict.get("BaseFont");
        if (!isName(baseFontName)) {
          throw new FormatError("Base font is not specified");
        }
        baseFontName = baseFontName.name.replace(/[,_]/g, "-");
        const metrics = this.getBaseFontMetrics(baseFontName);
        const fontNameWoStyle = baseFontName.split("-")[0];
        const flags = (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) | (metrics.monospace ? FontFlags.FixedPitch : 0) | (getSymbolsFonts()[fontNameWoStyle] ? FontFlags.Symbolic : FontFlags.Nonsymbolic);
        properties = {
          type,
          name: baseFontName,
          loadedName: baseDict.loadedName,
          widths: metrics.widths,
          defaultWidth: metrics.defaultWidth,
          flags,
          firstChar,
          lastChar,
          toUnicode,
          xHeight: 0,
          capHeight: 0,
          italicAngle: 0,
          isType3Font
        };
        const widths = dict.get("Widths");
        const standardFontName = getStandardFontName(baseFontName);
        let file = null;
        if (standardFontName) {
          properties.isStandardFont = true;
          file = await this.fetchStandardFontData(standardFontName);
          properties.isInternalFont = !!file;
        }
        return this.extractDataStructures(dict, dict, properties).then((newProperties) => {
          if (widths) {
            const glyphWidths = [];
            let j = firstChar;
            for (let i = 0, ii = widths.length; i < ii; i++) {
              glyphWidths[j++] = this.xref.fetchIfRef(widths[i]);
            }
            newProperties.widths = glyphWidths;
          } else {
            newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties);
          }
          return new Font$1(baseFontName, file, newProperties);
        });
      }
    }
    let fontName = descriptor.get("FontName");
    let baseFont = dict.get("BaseFont");
    if (isString(fontName)) {
      fontName = Name.get(fontName);
    }
    if (isString(baseFont)) {
      baseFont = Name.get(baseFont);
    }
    if (!isType3Font) {
      const fontNameStr = fontName && fontName.name;
      const baseFontStr = baseFont && baseFont.name;
      if (fontNameStr !== baseFontStr) {
        info(`The FontDescriptor's FontName is "${fontNameStr}" but should be the same as the Font's BaseFont "${baseFontStr}".`);
        if (fontNameStr && baseFontStr && baseFontStr.startsWith(fontNameStr)) {
          fontName = baseFont;
        }
      }
    }
    fontName = fontName || baseFont;
    if (!isName(fontName)) {
      throw new FormatError("invalid font name");
    }
    let fontFile, subtype, length1, length2, length3;
    try {
      fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
    } catch (ex) {
      if (!this.options.ignoreErrors) {
        throw ex;
      }
      warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
      fontFile = new NullStream();
    }
    let isStandardFont = false;
    let isInternalFont = false;
    let glyphScaleFactors = null;
    if (fontFile) {
      if (fontFile.dict) {
        const subtypeEntry = fontFile.dict.get("Subtype");
        if (subtypeEntry instanceof Name) {
          subtype = subtypeEntry.name;
        }
        length1 = fontFile.dict.get("Length1");
        length2 = fontFile.dict.get("Length2");
        length3 = fontFile.dict.get("Length3");
      }
    } else if (cssFontInfo) {
      const standardFontName = getXfaFontName(fontName.name);
      if (standardFontName) {
        cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
        cssFontInfo.lineHeight = standardFontName.lineHeight || null;
        glyphScaleFactors = standardFontName.factors || null;
        fontFile = await this.fetchStandardFontData(standardFontName.name);
        isInternalFont = !!fontFile;
        type = "TrueType";
      }
    } else if (!isType3Font) {
      const standardFontName = getStandardFontName(fontName.name);
      if (standardFontName) {
        isStandardFont = true;
        fontFile = await this.fetchStandardFontData(standardFontName);
        isInternalFont = !!fontFile;
      }
    }
    properties = {
      type,
      name: fontName.name,
      subtype,
      file: fontFile,
      length1,
      length2,
      length3,
      isStandardFont,
      isInternalFont,
      loadedName: baseDict.loadedName,
      composite,
      fixedPitch: false,
      fontMatrix: dict.getArray("FontMatrix") || FONT_IDENTITY_MATRIX,
      firstChar,
      lastChar,
      toUnicode,
      bbox: descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
      ascent: descriptor.get("Ascent"),
      descent: descriptor.get("Descent"),
      xHeight: descriptor.get("XHeight") || 0,
      capHeight: descriptor.get("CapHeight") || 0,
      flags: descriptor.get("Flags"),
      italicAngle: descriptor.get("ItalicAngle") || 0,
      isType3Font,
      cssFontInfo,
      scaleFactors: glyphScaleFactors
    };
    if (composite) {
      const cidEncoding = baseDict.get("Encoding");
      if (isName(cidEncoding)) {
        properties.cidEncoding = cidEncoding.name;
      }
      const cMap = await CMapFactory.create({
        encoding: cidEncoding,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      properties.cMap = cMap;
      properties.vertical = properties.cMap.vertical;
    }
    return this.extractDataStructures(dict, baseDict, properties).then((newProperties) => {
      this.extractWidths(dict, descriptor, newProperties);
      return new Font$1(fontName.name, fontFile, newProperties);
    });
  }
  static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
    function buildPath(fontChar) {
      const glyphName = `${font.loadedName}_path_${fontChar}`;
      try {
        if (font.renderer.hasBuiltPath(fontChar)) {
          return;
        }
        handler.send("commonobj", [glyphName, "FontPath", font.renderer.getPathJs(fontChar)]);
      } catch (reason) {
        if (evaluatorOptions.ignoreErrors) {
          handler.send("UnsupportedFeature", {
            featureId: UNSUPPORTED_FEATURES.errorFontBuildPath
          });
          warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
          return;
        }
        throw reason;
      }
    }
    for (const glyph of glyphs) {
      buildPath(glyph.fontChar);
      const accent = glyph.accent;
      if (accent && accent.fontChar) {
        buildPath(accent.fontChar);
      }
    }
  }
  static get fallbackFontDict() {
    const dict = new Dict();
    dict.set("BaseFont", Name.get("PDFJS-FallbackFont"));
    dict.set("Type", Name.get("FallbackType"));
    dict.set("Subtype", Name.get("FallbackType"));
    dict.set("Encoding", Name.get("WinAnsiEncoding"));
    return shadow(this, "fallbackFontDict", dict);
  }
};
var TranslatedFont = class {
  constructor({
    loadedName,
    font,
    dict,
    evaluatorOptions
  }) {
    this.loadedName = loadedName;
    this.font = font;
    this.dict = dict;
    this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
    this.type3Loaded = null;
    this.type3Dependencies = font.isType3Font ? /* @__PURE__ */ new Set() : null;
    this.sent = false;
  }
  send(handler) {
    if (this.sent) {
      return;
    }
    this.sent = true;
    handler.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);
  }
  fallback(handler) {
    if (!this.font.data) {
      return;
    }
    this.font.disableFontFace = true;
    PartialEvaluator.buildFontPaths(
      this.font,
      /* glyphs = */
      this.font.glyphCacheValues,
      handler,
      this._evaluatorOptions
    );
  }
  loadType3Data(evaluator, resources, task) {
    if (this.type3Loaded) {
      return this.type3Loaded;
    }
    if (!this.font.isType3Font) {
      throw new Error("Must be a Type3 font.");
    }
    const type3Evaluator = evaluator.clone({
      ignoreErrors: false
    });
    type3Evaluator.parsingType3Font = true;
    const translatedFont = this.font, type3Dependencies = this.type3Dependencies;
    let loadCharProcsPromise = Promise.resolve();
    const charProcs = this.dict.get("CharProcs");
    const fontResources = this.dict.get("Resources") || resources;
    const charProcOperatorList = /* @__PURE__ */ Object.create(null);
    const isEmptyBBox = !translatedFont.bbox || isArrayEqual(translatedFont.bbox, [0, 0, 0, 0]);
    for (const key of charProcs.getKeys()) {
      loadCharProcsPromise = loadCharProcsPromise.then(() => {
        const glyphStream = charProcs.get(key);
        const operatorList = new OperatorList();
        return type3Evaluator.getOperatorList({
          stream: glyphStream,
          task,
          resources: fontResources,
          operatorList
        }).then(() => {
          if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
            this._removeType3ColorOperators(operatorList, isEmptyBBox);
          }
          charProcOperatorList[key] = operatorList.getIR();
          for (const dependency of operatorList.dependencies) {
            type3Dependencies.add(dependency);
          }
        }).catch(function(reason) {
          warn(`Type3 font resource "${key}" is not available.`);
          const dummyOperatorList = new OperatorList();
          charProcOperatorList[key] = dummyOperatorList.getIR();
        });
      });
    }
    this.type3Loaded = loadCharProcsPromise.then(() => {
      translatedFont.charProcOperatorList = charProcOperatorList;
      if (this._bbox) {
        translatedFont.isCharBBox = true;
        translatedFont.bbox = this._bbox;
      }
    });
    return this.type3Loaded;
  }
  /**
   * @private
   */
  _removeType3ColorOperators(operatorList, isEmptyBBox = false) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(operatorList.fnArray[0] === OPS.setCharWidthAndBounds, "Type3 glyph shall start with the d1 operator.");
    }
    if (isEmptyBBox) {
      if (!this._bbox) {
        this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
      }
      const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2));
      this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
      this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
      this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
      this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
    }
    let i = 1, ii = operatorList.length;
    while (i < ii) {
      switch (operatorList.fnArray[i]) {
        case OPS.setStrokeColorSpace:
        case OPS.setFillColorSpace:
        case OPS.setStrokeColor:
        case OPS.setStrokeColorN:
        case OPS.setFillColor:
        case OPS.setFillColorN:
        case OPS.setStrokeGray:
        case OPS.setFillGray:
        case OPS.setStrokeRGBColor:
        case OPS.setFillRGBColor:
        case OPS.setStrokeCMYKColor:
        case OPS.setFillCMYKColor:
        case OPS.shadingFill:
        case OPS.setRenderingIntent:
          operatorList.fnArray.splice(i, 1);
          operatorList.argsArray.splice(i, 1);
          ii--;
          continue;
        case OPS.setGState:
          const [gStateObj] = operatorList.argsArray[i];
          let j = 0, jj = gStateObj.length;
          while (j < jj) {
            const [gStateKey] = gStateObj[j];
            switch (gStateKey) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                gStateObj.splice(j, 1);
                jj--;
                continue;
            }
            j++;
          }
          break;
      }
      i++;
    }
  }
};
var StateManager = class {
  constructor(initialState = new EvalState()) {
    this.state = initialState;
    this.stateStack = [];
  }
  save() {
    const old = this.state;
    this.stateStack.push(this.state);
    this.state = old.clone();
  }
  restore() {
    const prev = this.stateStack.pop();
    if (prev) {
      this.state = prev;
    }
  }
  transform(args) {
    this.state.ctm = Util.transform(this.state.ctm, args);
  }
};
var TextState = class {
  constructor() {
    this.ctm = new Float32Array(IDENTITY_MATRIX);
    this.fontName = null;
    this.fontSize = 0;
    this.font = null;
    this.fontMatrix = FONT_IDENTITY_MATRIX;
    this.textMatrix = IDENTITY_MATRIX.slice();
    this.textLineMatrix = IDENTITY_MATRIX.slice();
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.leading = 0;
    this.textHScale = 1;
    this.textRise = 0;
  }
  setTextMatrix(a, b, c, d, e, f) {
    const m = this.textMatrix;
    m[0] = a;
    m[1] = b;
    m[2] = c;
    m[3] = d;
    m[4] = e;
    m[5] = f;
  }
  setTextLineMatrix(a, b, c, d, e, f) {
    const m = this.textLineMatrix;
    m[0] = a;
    m[1] = b;
    m[2] = c;
    m[3] = d;
    m[4] = e;
    m[5] = f;
  }
  translateTextMatrix(x, y) {
    const m = this.textMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];
  }
  translateTextLineMatrix(x, y) {
    const m = this.textLineMatrix;
    m[4] = m[0] * x + m[2] * y + m[4];
    m[5] = m[1] * x + m[3] * y + m[5];
  }
  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading);
    this.textMatrix = this.textLineMatrix.slice();
  }
  clone() {
    const clone = Object.create(this);
    clone.textMatrix = this.textMatrix.slice();
    clone.textLineMatrix = this.textLineMatrix.slice();
    clone.fontMatrix = this.fontMatrix.slice();
    return clone;
  }
};
var EvalState = class {
  constructor() {
    this.ctm = new Float32Array(IDENTITY_MATRIX);
    this.font = null;
    this.textRenderingMode = TextRenderingMode.FILL;
    this.fillColorSpace = ColorSpace.singletons.gray;
    this.strokeColorSpace = ColorSpace.singletons.gray;
  }
  clone() {
    return Object.create(this);
  }
};
var EvaluatorPreprocessor = class _EvaluatorPreprocessor {
  static get opMap() {
    const getOPMap = getLookupTableFactory(function(t) {
      t.w = {
        id: OPS.setLineWidth,
        numArgs: 1,
        variableArgs: false
      };
      t.J = {
        id: OPS.setLineCap,
        numArgs: 1,
        variableArgs: false
      };
      t.j = {
        id: OPS.setLineJoin,
        numArgs: 1,
        variableArgs: false
      };
      t.M = {
        id: OPS.setMiterLimit,
        numArgs: 1,
        variableArgs: false
      };
      t.d = {
        id: OPS.setDash,
        numArgs: 2,
        variableArgs: false
      };
      t.ri = {
        id: OPS.setRenderingIntent,
        numArgs: 1,
        variableArgs: false
      };
      t.i = {
        id: OPS.setFlatness,
        numArgs: 1,
        variableArgs: false
      };
      t.gs = {
        id: OPS.setGState,
        numArgs: 1,
        variableArgs: false
      };
      t.q = {
        id: OPS.save,
        numArgs: 0,
        variableArgs: false
      };
      t.Q = {
        id: OPS.restore,
        numArgs: 0,
        variableArgs: false
      };
      t.cm = {
        id: OPS.transform,
        numArgs: 6,
        variableArgs: false
      };
      t.m = {
        id: OPS.moveTo,
        numArgs: 2,
        variableArgs: false
      };
      t.l = {
        id: OPS.lineTo,
        numArgs: 2,
        variableArgs: false
      };
      t.c = {
        id: OPS.curveTo,
        numArgs: 6,
        variableArgs: false
      };
      t.v = {
        id: OPS.curveTo2,
        numArgs: 4,
        variableArgs: false
      };
      t.y = {
        id: OPS.curveTo3,
        numArgs: 4,
        variableArgs: false
      };
      t.h = {
        id: OPS.closePath,
        numArgs: 0,
        variableArgs: false
      };
      t.re = {
        id: OPS.rectangle,
        numArgs: 4,
        variableArgs: false
      };
      t.S = {
        id: OPS.stroke,
        numArgs: 0,
        variableArgs: false
      };
      t.s = {
        id: OPS.closeStroke,
        numArgs: 0,
        variableArgs: false
      };
      t.f = {
        id: OPS.fill,
        numArgs: 0,
        variableArgs: false
      };
      t.F = {
        id: OPS.fill,
        numArgs: 0,
        variableArgs: false
      };
      t["f*"] = {
        id: OPS.eoFill,
        numArgs: 0,
        variableArgs: false
      };
      t.B = {
        id: OPS.fillStroke,
        numArgs: 0,
        variableArgs: false
      };
      t["B*"] = {
        id: OPS.eoFillStroke,
        numArgs: 0,
        variableArgs: false
      };
      t.b = {
        id: OPS.closeFillStroke,
        numArgs: 0,
        variableArgs: false
      };
      t["b*"] = {
        id: OPS.closeEOFillStroke,
        numArgs: 0,
        variableArgs: false
      };
      t.n = {
        id: OPS.endPath,
        numArgs: 0,
        variableArgs: false
      };
      t.W = {
        id: OPS.clip,
        numArgs: 0,
        variableArgs: false
      };
      t["W*"] = {
        id: OPS.eoClip,
        numArgs: 0,
        variableArgs: false
      };
      t.BT = {
        id: OPS.beginText,
        numArgs: 0,
        variableArgs: false
      };
      t.ET = {
        id: OPS.endText,
        numArgs: 0,
        variableArgs: false
      };
      t.Tc = {
        id: OPS.setCharSpacing,
        numArgs: 1,
        variableArgs: false
      };
      t.Tw = {
        id: OPS.setWordSpacing,
        numArgs: 1,
        variableArgs: false
      };
      t.Tz = {
        id: OPS.setHScale,
        numArgs: 1,
        variableArgs: false
      };
      t.TL = {
        id: OPS.setLeading,
        numArgs: 1,
        variableArgs: false
      };
      t.Tf = {
        id: OPS.setFont,
        numArgs: 2,
        variableArgs: false
      };
      t.Tr = {
        id: OPS.setTextRenderingMode,
        numArgs: 1,
        variableArgs: false
      };
      t.Ts = {
        id: OPS.setTextRise,
        numArgs: 1,
        variableArgs: false
      };
      t.Td = {
        id: OPS.moveText,
        numArgs: 2,
        variableArgs: false
      };
      t.TD = {
        id: OPS.setLeadingMoveText,
        numArgs: 2,
        variableArgs: false
      };
      t.Tm = {
        id: OPS.setTextMatrix,
        numArgs: 6,
        variableArgs: false
      };
      t["T*"] = {
        id: OPS.nextLine,
        numArgs: 0,
        variableArgs: false
      };
      t.Tj = {
        id: OPS.showText,
        numArgs: 1,
        variableArgs: false
      };
      t.TJ = {
        id: OPS.showSpacedText,
        numArgs: 1,
        variableArgs: false
      };
      t["'"] = {
        id: OPS.nextLineShowText,
        numArgs: 1,
        variableArgs: false
      };
      t['"'] = {
        id: OPS.nextLineSetSpacingShowText,
        numArgs: 3,
        variableArgs: false
      };
      t.d0 = {
        id: OPS.setCharWidth,
        numArgs: 2,
        variableArgs: false
      };
      t.d1 = {
        id: OPS.setCharWidthAndBounds,
        numArgs: 6,
        variableArgs: false
      };
      t.CS = {
        id: OPS.setStrokeColorSpace,
        numArgs: 1,
        variableArgs: false
      };
      t.cs = {
        id: OPS.setFillColorSpace,
        numArgs: 1,
        variableArgs: false
      };
      t.SC = {
        id: OPS.setStrokeColor,
        numArgs: 4,
        variableArgs: true
      };
      t.SCN = {
        id: OPS.setStrokeColorN,
        numArgs: 33,
        variableArgs: true
      };
      t.sc = {
        id: OPS.setFillColor,
        numArgs: 4,
        variableArgs: true
      };
      t.scn = {
        id: OPS.setFillColorN,
        numArgs: 33,
        variableArgs: true
      };
      t.G = {
        id: OPS.setStrokeGray,
        numArgs: 1,
        variableArgs: false
      };
      t.g = {
        id: OPS.setFillGray,
        numArgs: 1,
        variableArgs: false
      };
      t.RG = {
        id: OPS.setStrokeRGBColor,
        numArgs: 3,
        variableArgs: false
      };
      t.rg = {
        id: OPS.setFillRGBColor,
        numArgs: 3,
        variableArgs: false
      };
      t.K = {
        id: OPS.setStrokeCMYKColor,
        numArgs: 4,
        variableArgs: false
      };
      t.k = {
        id: OPS.setFillCMYKColor,
        numArgs: 4,
        variableArgs: false
      };
      t.sh = {
        id: OPS.shadingFill,
        numArgs: 1,
        variableArgs: false
      };
      t.BI = {
        id: OPS.beginInlineImage,
        numArgs: 0,
        variableArgs: false
      };
      t.ID = {
        id: OPS.beginImageData,
        numArgs: 0,
        variableArgs: false
      };
      t.EI = {
        id: OPS.endInlineImage,
        numArgs: 1,
        variableArgs: false
      };
      t.Do = {
        id: OPS.paintXObject,
        numArgs: 1,
        variableArgs: false
      };
      t.MP = {
        id: OPS.markPoint,
        numArgs: 1,
        variableArgs: false
      };
      t.DP = {
        id: OPS.markPointProps,
        numArgs: 2,
        variableArgs: false
      };
      t.BMC = {
        id: OPS.beginMarkedContent,
        numArgs: 1,
        variableArgs: false
      };
      t.BDC = {
        id: OPS.beginMarkedContentProps,
        numArgs: 2,
        variableArgs: false
      };
      t.EMC = {
        id: OPS.endMarkedContent,
        numArgs: 0,
        variableArgs: false
      };
      t.BX = {
        id: OPS.beginCompat,
        numArgs: 0,
        variableArgs: false
      };
      t.EX = {
        id: OPS.endCompat,
        numArgs: 0,
        variableArgs: false
      };
      t.BM = null;
      t.BD = null;
      t.true = null;
      t.fa = null;
      t.fal = null;
      t.fals = null;
      t.false = null;
      t.nu = null;
      t.nul = null;
      t.null = null;
    });
    return shadow(this, "opMap", getOPMap());
  }
  static get MAX_INVALID_PATH_OPS() {
    return shadow(this, "MAX_INVALID_PATH_OPS", 20);
  }
  constructor(stream, xref, stateManager = new StateManager()) {
    this.parser = new Parser({
      lexer: new Lexer(stream, _EvaluatorPreprocessor.opMap),
      xref
    });
    this.stateManager = stateManager;
    this.nonProcessedArgs = [];
    this._numInvalidPathOPS = 0;
  }
  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }
  // |operation| is an object with two fields:
  //
  // - |fn| is an out param.
  //
  // - |args| is an inout param. On entry, it should have one of two values.
  //
  //   - An empty array. This indicates that the caller is providing the
  //     array in which the args will be stored in. The caller should use
  //     this value if it can reuse a single array for each call to read().
  //
  //   - |null|. This indicates that the caller needs this function to create
  //     the array in which any args are stored in. If there are zero args,
  //     this function will leave |operation.args| as |null| (thus avoiding
  //     allocations that would occur if we used an empty array to represent
  //     zero arguments). Otherwise, it will replace |null| with a new array
  //     containing the arguments. The caller should use this value if it
  //     cannot reuse an array for each call to read().
  //
  // These two modes are present because this function is very hot and so
  // avoiding allocations where possible is worthwhile.
  //
  read(operation) {
    let args = operation.args;
    while (true) {
      const obj = this.parser.getObj();
      if (obj instanceof Cmd) {
        const cmd = obj.cmd;
        const opSpec = _EvaluatorPreprocessor.opMap[cmd];
        if (!opSpec) {
          warn(`Unknown command "${cmd}".`);
          continue;
        }
        const fn = opSpec.id;
        const numArgs = opSpec.numArgs;
        let argsLength = args !== null ? args.length : 0;
        if (!opSpec.variableArgs) {
          if (argsLength !== numArgs) {
            const nonProcessedArgs = this.nonProcessedArgs;
            while (argsLength > numArgs) {
              nonProcessedArgs.push(args.shift());
              argsLength--;
            }
            while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
              if (args === null) {
                args = [];
              }
              args.unshift(nonProcessedArgs.pop());
              argsLength++;
            }
          }
          if (argsLength < numArgs) {
            const partialMsg = `command ${cmd}: expected ${numArgs} args, but received ${argsLength} args.`;
            if (fn >= OPS.moveTo && fn <= OPS.endPath && // Path operator
            ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) {
              throw new FormatError(`Invalid ${partialMsg}`);
            }
            warn(`Skipping ${partialMsg}`);
            if (args !== null) {
              args.length = 0;
            }
            continue;
          }
        } else if (argsLength > numArgs) {
          info(`Command ${cmd}: expected [0, ${numArgs}] args, but received ${argsLength} args.`);
        }
        this.preprocessCommand(fn, args);
        operation.fn = fn;
        operation.args = args;
        return true;
      }
      if (obj === EOF) {
        return false;
      }
      if (obj !== null) {
        if (args === null) {
          args = [];
        }
        args.push(obj);
        if (args.length > 33) {
          throw new FormatError("Too many arguments");
        }
      }
    }
  }
  preprocessCommand(fn, args) {
    switch (fn | 0) {
      case OPS.save:
        this.stateManager.save();
        break;
      case OPS.restore:
        this.stateManager.restore();
        break;
      case OPS.transform:
        this.stateManager.transform(args);
        break;
    }
  }
};
var DefaultAppearanceEvaluator = class extends EvaluatorPreprocessor {
  constructor(str) {
    super(new StringStream(str));
  }
  parse() {
    const operation = {
      fn: 0,
      args: []
    };
    const result = {
      fontSize: 0,
      fontName: "",
      fontColor: (
        /* black = */
        new Uint8ClampedArray(3)
      )
    };
    try {
      while (true) {
        operation.args.length = 0;
        if (!this.read(operation)) {
          break;
        }
        if (this.savedStatesDepth !== 0) {
          continue;
        }
        const {
          fn,
          args
        } = operation;
        switch (fn | 0) {
          case OPS.setFont:
            const [fontName, fontSize] = args;
            if (fontName instanceof Name) {
              result.fontName = fontName.name;
            }
            if (typeof fontSize === "number" && fontSize > 0) {
              result.fontSize = fontSize;
            }
            break;
          case OPS.setFillRGBColor:
            ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
            break;
          case OPS.setFillGray:
            ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
            break;
          case OPS.setFillColorSpace:
            ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
            break;
        }
      }
    } catch (reason) {
      warn(`parseDefaultAppearance - ignoring errors: "${reason}".`);
    }
    return result;
  }
};
function parseDefaultAppearance(str) {
  return new DefaultAppearanceEvaluator(str).parse();
}
function createDefaultAppearance({
  fontSize,
  fontName,
  fontColor
}) {
  let colorCmd;
  if (fontColor.every((c) => c === 0)) {
    colorCmd = "0 g";
  } else {
    colorCmd = Array.from(fontColor).map((c) => (c / 255).toFixed(2)).join(" ") + " rg";
  }
  return `/${escapePDFName(fontName)} ${fontSize} Tf ${colorCmd}`;
}
var NameOrNumberTree = class _NameOrNumberTree {
  constructor(root, xref, type) {
    if (this.constructor === _NameOrNumberTree) {
      unreachable("Cannot initialize NameOrNumberTree.");
    }
    this.root = root;
    this.xref = xref;
    this._type = type;
  }
  getAll() {
    const map = /* @__PURE__ */ new Map();
    if (!this.root) {
      return map;
    }
    const xref = this.xref;
    const processed = new RefSet();
    processed.put(this.root);
    const queue = [this.root];
    while (queue.length > 0) {
      const obj = xref.fetchIfRef(queue.shift());
      if (!isDict(obj)) {
        continue;
      }
      if (obj.has("Kids")) {
        const kids = obj.get("Kids");
        for (let i = 0, ii = kids.length; i < ii; i++) {
          const kid = kids[i];
          if (processed.has(kid)) {
            throw new FormatError(`Duplicate entry in "${this._type}" tree.`);
          }
          queue.push(kid);
          processed.put(kid);
        }
        continue;
      }
      const entries = obj.get(this._type);
      if (!Array.isArray(entries)) {
        continue;
      }
      for (let i = 0, ii = entries.length; i < ii; i += 2) {
        map.set(xref.fetchIfRef(entries[i]), xref.fetchIfRef(entries[i + 1]));
      }
    }
    return map;
  }
  get(key) {
    if (!this.root) {
      return null;
    }
    const xref = this.xref;
    let kidsOrEntries = xref.fetchIfRef(this.root);
    let loopCount = 0;
    const MAX_LEVELS = 10;
    while (kidsOrEntries.has("Kids")) {
      if (++loopCount > MAX_LEVELS) {
        warn(`Search depth limit reached for "${this._type}" tree.`);
        return null;
      }
      const kids = kidsOrEntries.get("Kids");
      if (!Array.isArray(kids)) {
        return null;
      }
      let l = 0, r = kids.length - 1;
      while (l <= r) {
        const m = l + r >> 1;
        const kid = xref.fetchIfRef(kids[m]);
        const limits = kid.get("Limits");
        if (key < xref.fetchIfRef(limits[0])) {
          r = m - 1;
        } else if (key > xref.fetchIfRef(limits[1])) {
          l = m + 1;
        } else {
          kidsOrEntries = xref.fetchIfRef(kids[m]);
          break;
        }
      }
      if (l > r) {
        return null;
      }
    }
    const entries = kidsOrEntries.get(this._type);
    if (Array.isArray(entries)) {
      let l = 0, r = entries.length - 2;
      while (l <= r) {
        const tmp = l + r >> 1, m = tmp + (tmp & 1);
        const currentKey = xref.fetchIfRef(entries[m]);
        if (key < currentKey) {
          r = m - 2;
        } else if (key > currentKey) {
          l = m + 2;
        } else {
          return xref.fetchIfRef(entries[m + 1]);
        }
      }
    }
    return null;
  }
};
var NameTree = class extends NameOrNumberTree {
  constructor(root, xref) {
    super(root, xref, "Names");
  }
};
var NumberTree = class extends NameOrNumberTree {
  constructor(root, xref) {
    super(root, xref, "Nums");
  }
};
function pickPlatformItem(dict) {
  if (dict.has("UF")) {
    return dict.get("UF");
  } else if (dict.has("F")) {
    return dict.get("F");
  } else if (dict.has("Unix")) {
    return dict.get("Unix");
  } else if (dict.has("Mac")) {
    return dict.get("Mac");
  } else if (dict.has("DOS")) {
    return dict.get("DOS");
  }
  return null;
}
var FileSpec = class {
  constructor(root, xref) {
    if (!root || !isDict(root)) {
      return;
    }
    this.xref = xref;
    this.root = root;
    if (root.has("FS")) {
      this.fs = root.get("FS");
    }
    this.description = root.has("Desc") ? stringToPDFString(root.get("Desc")) : "";
    if (root.has("RF")) {
      warn("Related file specifications are not supported");
    }
    this.contentAvailable = true;
    if (!root.has("EF")) {
      this.contentAvailable = false;
      warn("Non-embedded file specifications are not supported");
    }
  }
  get filename() {
    if (!this._filename && this.root) {
      const filename = pickPlatformItem(this.root) || "unnamed";
      this._filename = stringToPDFString(filename).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
    }
    return this._filename;
  }
  get content() {
    if (!this.contentAvailable) {
      return null;
    }
    if (!this.contentRef && this.root) {
      this.contentRef = pickPlatformItem(this.root.get("EF"));
    }
    let content = null;
    if (this.contentRef) {
      const fileObj = this.xref.fetchIfRef(this.contentRef);
      if (fileObj && isStream(fileObj)) {
        content = fileObj.getBytes();
      } else {
        warn("Embedded file specification points to non-existing/invalid content");
      }
    } else {
      warn("Embedded file specification does not have a content");
    }
    return content;
  }
  get serializable() {
    return {
      filename: this.filename,
      content: this.content
    };
  }
};
var XMLParserErrorCode = {
  NoError: 0,
  EndOfDocument: -1,
  UnterminatedCdat: -2,
  UnterminatedXmlDeclaration: -3,
  UnterminatedDoctypeDeclaration: -4,
  UnterminatedComment: -5,
  MalformedElement: -6,
  OutOfMemory: -7,
  UnterminatedAttributeValue: -8,
  UnterminatedElement: -9,
  ElementNeverBegun: -10
};
function isWhitespace(s, index) {
  const ch = s[index];
  return ch === " " || ch === "\n" || ch === "\r" || ch === "	";
}
function isWhitespaceString(s) {
  for (let i = 0, ii = s.length; i < ii; i++) {
    if (!isWhitespace(s, i)) {
      return false;
    }
  }
  return true;
}
var XMLParserBase = class {
  _resolveEntities(s) {
    return s.replace(/&([^;]+);/g, (all, entity) => {
      if (entity.substring(0, 2) === "#x") {
        return String.fromCodePoint(parseInt(entity.substring(2), 16));
      } else if (entity.substring(0, 1) === "#") {
        return String.fromCodePoint(parseInt(entity.substring(1), 10));
      }
      switch (entity) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(entity);
    });
  }
  _parseContent(s, start) {
    const attributes = [];
    let pos = start;
    function skipWs() {
      while (pos < s.length && isWhitespace(s, pos)) {
        ++pos;
      }
    }
    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
      ++pos;
    }
    const name = s.substring(start, pos);
    skipWs();
    while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
      skipWs();
      let attrName = "", attrValue = "";
      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
        attrName += s[pos];
        ++pos;
      }
      skipWs();
      if (s[pos] !== "=") {
        return null;
      }
      ++pos;
      skipWs();
      const attrEndChar = s[pos];
      if (attrEndChar !== '"' && attrEndChar !== "'") {
        return null;
      }
      const attrEndIndex = s.indexOf(attrEndChar, ++pos);
      if (attrEndIndex < 0) {
        return null;
      }
      attrValue = s.substring(pos, attrEndIndex);
      attributes.push({
        name: attrName,
        value: this._resolveEntities(attrValue)
      });
      pos = attrEndIndex + 1;
      skipWs();
    }
    return {
      name,
      attributes,
      parsed: pos - start
    };
  }
  _parseProcessingInstruction(s, start) {
    let pos = start;
    function skipWs() {
      while (pos < s.length && isWhitespace(s, pos)) {
        ++pos;
      }
    }
    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "?" && s[pos] !== "/") {
      ++pos;
    }
    const name = s.substring(start, pos);
    skipWs();
    const attrStart = pos;
    while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
      ++pos;
    }
    const value = s.substring(attrStart, pos);
    return {
      name,
      value,
      parsed: pos - start
    };
  }
  parseXml(s) {
    let i = 0;
    while (i < s.length) {
      const ch = s[i];
      let j = i;
      if (ch === "<") {
        ++j;
        const ch2 = s[j];
        let q;
        switch (ch2) {
          case "/":
            ++j;
            q = s.indexOf(">", j);
            if (q < 0) {
              this.onError(XMLParserErrorCode.UnterminatedElement);
              return;
            }
            this.onEndElement(s.substring(j, q));
            j = q + 1;
            break;
          case "?":
            ++j;
            const pi = this._parseProcessingInstruction(s, j);
            if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
              this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
              return;
            }
            this.onPi(pi.name, pi.value);
            j += pi.parsed + 2;
            break;
          case "!":
            if (s.substring(j + 1, j + 3) === "--") {
              q = s.indexOf("-->", j + 3);
              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedComment);
                return;
              }
              this.onComment(s.substring(j + 3, q));
              j = q + 3;
            } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
              q = s.indexOf("]]>", j + 8);
              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedCdat);
                return;
              }
              this.onCdata(s.substring(j + 8, q));
              j = q + 3;
            } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
              const q2 = s.indexOf("[", j + 8);
              let complexDoctype = false;
              q = s.indexOf(">", j + 8);
              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                return;
              }
              if (q2 > 0 && q > q2) {
                q = s.indexOf("]>", j + 8);
                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                  return;
                }
                complexDoctype = true;
              }
              const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
              this.onDoctype(doctypeContent);
              j = q + (complexDoctype ? 2 : 1);
            } else {
              this.onError(XMLParserErrorCode.MalformedElement);
              return;
            }
            break;
          default:
            const content = this._parseContent(s, j);
            if (content === null) {
              this.onError(XMLParserErrorCode.MalformedElement);
              return;
            }
            let isClosed = false;
            if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
              isClosed = true;
            } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
              this.onError(XMLParserErrorCode.UnterminatedElement);
              return;
            }
            this.onBeginElement(content.name, content.attributes, isClosed);
            j += content.parsed + (isClosed ? 2 : 1);
            break;
        }
      } else {
        while (j < s.length && s[j] !== "<") {
          j++;
        }
        const text = s.substring(i, j);
        this.onText(this._resolveEntities(text));
      }
      i = j;
    }
  }
  onResolveEntity(name) {
    return `&${name};`;
  }
  onPi(name, value) {
  }
  onComment(text) {
  }
  onCdata(text) {
  }
  onDoctype(doctypeContent) {
  }
  onText(text) {
  }
  onBeginElement(name, attributes, isEmpty) {
  }
  onEndElement(name) {
  }
  onError(code) {
  }
};
var SimpleDOMNode = class {
  constructor(nodeName, nodeValue) {
    this.nodeName = nodeName;
    this.nodeValue = nodeValue;
    Object.defineProperty(this, "parentNode", {
      value: null,
      writable: true
    });
  }
  get firstChild() {
    return this.childNodes && this.childNodes[0];
  }
  get nextSibling() {
    const childNodes = this.parentNode.childNodes;
    if (!childNodes) {
      return void 0;
    }
    const index = childNodes.indexOf(this);
    if (index === -1) {
      return void 0;
    }
    return childNodes[index + 1];
  }
  get textContent() {
    if (!this.childNodes) {
      return this.nodeValue || "";
    }
    return this.childNodes.map(function(child) {
      return child.textContent;
    }).join("");
  }
  hasChildNodes() {
    return this.childNodes && this.childNodes.length > 0;
  }
  /**
   * Search a node in the tree with the given path
   * foo.bar[nnn], i.e. find the nnn-th node named
   * bar under a node named foo.
   *
   * @param {Array} paths - an array of objects as
   * returned by {parseXFAPath}.
   * @param {number} pos - the current position in
   * the paths array.
   * @returns {SimpleDOMNode} The node corresponding
   * to the path or null if not found.
   */
  searchNode(paths, pos) {
    if (pos >= paths.length) {
      return this;
    }
    const component = paths[pos];
    const stack = [];
    let node = this;
    while (true) {
      if (component.name === node.nodeName) {
        if (component.pos === 0) {
          const res = node.searchNode(paths, pos + 1);
          if (res !== null) {
            return res;
          }
        } else if (stack.length === 0) {
          return null;
        } else {
          const [parent] = stack.pop();
          let siblingPos = 0;
          for (const child of parent.childNodes) {
            if (component.name === child.nodeName) {
              if (siblingPos === component.pos) {
                return child.searchNode(paths, pos + 1);
              }
              siblingPos++;
            }
          }
          return node.searchNode(paths, pos + 1);
        }
      }
      if (node.childNodes && node.childNodes.length !== 0) {
        stack.push([node, 0]);
        node = node.childNodes[0];
      } else if (stack.length === 0) {
        return null;
      } else {
        while (stack.length !== 0) {
          const [parent, currentPos] = stack.pop();
          const newPos = currentPos + 1;
          if (newPos < parent.childNodes.length) {
            stack.push([parent, newPos]);
            node = parent.childNodes[newPos];
            break;
          }
        }
        if (stack.length === 0) {
          return null;
        }
      }
    }
  }
  dump(buffer) {
    if (this.nodeName === "#text") {
      buffer.push(encodeToXmlString(this.nodeValue));
      return;
    }
    buffer.push(`<${this.nodeName}`);
    if (this.attributes) {
      for (const attribute of this.attributes) {
        buffer.push(` ${attribute.name}="${encodeToXmlString(attribute.value)}"`);
      }
    }
    if (this.hasChildNodes()) {
      buffer.push(">");
      for (const child of this.childNodes) {
        child.dump(buffer);
      }
      buffer.push(`</${this.nodeName}>`);
    } else if (this.nodeValue) {
      buffer.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`);
    } else {
      buffer.push("/>");
    }
  }
};
var SimpleXMLParser = class extends XMLParserBase {
  constructor({
    hasAttributes = false,
    lowerCaseName = false
  }) {
    super();
    this._currentFragment = null;
    this._stack = null;
    this._errorCode = XMLParserErrorCode.NoError;
    this._hasAttributes = hasAttributes;
    this._lowerCaseName = lowerCaseName;
  }
  parseFromString(data) {
    this._currentFragment = [];
    this._stack = [];
    this._errorCode = XMLParserErrorCode.NoError;
    this.parseXml(data);
    if (this._errorCode !== XMLParserErrorCode.NoError) {
      return void 0;
    }
    const [documentElement] = this._currentFragment;
    if (!documentElement) {
      return void 0;
    }
    return {
      documentElement
    };
  }
  onText(text) {
    if (isWhitespaceString(text)) {
      return;
    }
    const node = new SimpleDOMNode("#text", text);
    this._currentFragment.push(node);
  }
  onCdata(text) {
    const node = new SimpleDOMNode("#text", text);
    this._currentFragment.push(node);
  }
  onBeginElement(name, attributes, isEmpty) {
    if (this._lowerCaseName) {
      name = name.toLowerCase();
    }
    const node = new SimpleDOMNode(name);
    node.childNodes = [];
    if (this._hasAttributes) {
      node.attributes = attributes;
    }
    this._currentFragment.push(node);
    if (isEmpty) {
      return;
    }
    this._stack.push(this._currentFragment);
    this._currentFragment = node.childNodes;
  }
  onEndElement(name) {
    this._currentFragment = this._stack.pop() || [];
    const lastElement = this._currentFragment[this._currentFragment.length - 1];
    if (!lastElement) {
      return;
    }
    for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
      lastElement.childNodes[i].parentNode = lastElement;
    }
  }
  onError(code) {
    this._errorCode = code;
  }
};
var MetadataParser = class {
  constructor(data) {
    data = this._repair(data);
    const parser = new SimpleXMLParser({
      lowerCaseName: true
    });
    const xmlDocument = parser.parseFromString(data);
    this._metadataMap = /* @__PURE__ */ new Map();
    this._data = data;
    if (xmlDocument) {
      this._parse(xmlDocument);
    }
  }
  _repair(data) {
    return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function(all, codes) {
      const bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function(code, d1, d2, d3) {
        return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
      }).replace(/&(amp|apos|gt|lt|quot);/g, function(str, name) {
        switch (name) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${name} isn't defined.`);
      });
      const charBuf = [];
      for (let i = 0, ii = bytes.length; i < ii; i += 2) {
        const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
        if (code >= /* Space = */
        32 && code < /* Delete = */
        127 && code !== /* '<' = */
        60 && code !== /* '>' = */
        62 && code !== /* '&' = */
        38) {
          charBuf.push(String.fromCharCode(code));
        } else {
          charBuf.push("&#x" + (65536 + code).toString(16).substring(1) + ";");
        }
      }
      return ">" + charBuf.join("");
    });
  }
  _getSequence(entry) {
    const name = entry.nodeName;
    if (name !== "rdf:bag" && name !== "rdf:seq" && name !== "rdf:alt") {
      return null;
    }
    return entry.childNodes.filter((node) => node.nodeName === "rdf:li");
  }
  _parseArray(entry) {
    if (!entry.hasChildNodes()) {
      return;
    }
    const [seqNode] = entry.childNodes;
    const sequence = this._getSequence(seqNode) || [];
    this._metadataMap.set(entry.nodeName, sequence.map((node) => node.textContent.trim()));
  }
  _parse(xmlDocument) {
    let rdf = xmlDocument.documentElement;
    if (rdf.nodeName !== "rdf:rdf") {
      rdf = rdf.firstChild;
      while (rdf && rdf.nodeName !== "rdf:rdf") {
        rdf = rdf.nextSibling;
      }
    }
    if (!rdf || rdf.nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
      return;
    }
    for (const desc of rdf.childNodes) {
      if (desc.nodeName !== "rdf:description") {
        continue;
      }
      for (const entry of desc.childNodes) {
        const name = entry.nodeName;
        switch (name) {
          case "#text":
            continue;
          case "dc:creator":
          case "dc:subject":
            this._parseArray(entry);
            continue;
        }
        this._metadataMap.set(name, entry.textContent.trim());
      }
    }
  }
  get serializable() {
    return {
      parsedData: this._metadataMap,
      rawData: this._data
    };
  }
};
var MAX_DEPTH = 40;
var StructElementType = {
  PAGE_CONTENT: "PAGE_CONTENT",
  STREAM_CONTENT: "STREAM_CONTENT",
  OBJECT: "OBJECT",
  ELEMENT: "ELEMENT"
};
var StructTreeRoot = class {
  constructor(rootDict) {
    this.dict = rootDict;
    this.roleMap = /* @__PURE__ */ new Map();
  }
  init() {
    this.readRoleMap();
  }
  readRoleMap() {
    const roleMapDict = this.dict.get("RoleMap");
    if (!isDict(roleMapDict)) {
      return;
    }
    roleMapDict.forEach((key, value) => {
      if (!isName(value)) {
        return;
      }
      this.roleMap.set(key, value.name);
    });
  }
};
var StructElementNode = class {
  constructor(tree, dict) {
    this.tree = tree;
    this.dict = dict;
    this.kids = [];
    this.parseKids();
  }
  get role() {
    const nameObj = this.dict.get("S");
    const name = isName(nameObj) ? nameObj.name : "";
    const {
      root
    } = this.tree;
    if (root.roleMap.has(name)) {
      return root.roleMap.get(name);
    }
    return name;
  }
  parseKids() {
    let pageObjId = null;
    const objRef = this.dict.getRaw("Pg");
    if (isRef(objRef)) {
      pageObjId = objRef.toString();
    }
    const kids = this.dict.get("K");
    if (Array.isArray(kids)) {
      for (const kid of kids) {
        const element = this.parseKid(pageObjId, kid);
        if (element) {
          this.kids.push(element);
        }
      }
    } else {
      const element = this.parseKid(pageObjId, kids);
      if (element) {
        this.kids.push(element);
      }
    }
  }
  parseKid(pageObjId, kid) {
    if (Number.isInteger(kid)) {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }
      return new StructElement({
        type: StructElementType.PAGE_CONTENT,
        mcid: kid,
        pageObjId
      });
    }
    let kidDict = null;
    if (isRef(kid)) {
      kidDict = this.dict.xref.fetch(kid);
    } else if (isDict(kid)) {
      kidDict = kid;
    }
    if (!kidDict) {
      return null;
    }
    const pageRef = kidDict.getRaw("Pg");
    if (isRef(pageRef)) {
      pageObjId = pageRef.toString();
    }
    const type = isName(kidDict.get("Type")) ? kidDict.get("Type").name : null;
    if (type === "MCR") {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }
      return new StructElement({
        type: StructElementType.STREAM_CONTENT,
        refObjId: isRef(kidDict.getRaw("Stm")) ? kidDict.getRaw("Stm").toString() : null,
        pageObjId,
        mcid: kidDict.get("MCID")
      });
    }
    if (type === "OBJR") {
      if (this.tree.pageDict.objId !== pageObjId) {
        return null;
      }
      return new StructElement({
        type: StructElementType.OBJECT,
        refObjId: isRef(kidDict.getRaw("Obj")) ? kidDict.getRaw("Obj").toString() : null,
        pageObjId
      });
    }
    return new StructElement({
      type: StructElementType.ELEMENT,
      dict: kidDict
    });
  }
};
var StructElement = class {
  constructor({
    type,
    dict = null,
    mcid = null,
    pageObjId = null,
    refObjId = null
  }) {
    this.type = type;
    this.dict = dict;
    this.mcid = mcid;
    this.pageObjId = pageObjId;
    this.refObjId = refObjId;
    this.parentNode = null;
  }
};
var StructTreePage = class {
  constructor(structTreeRoot, pageDict) {
    this.root = structTreeRoot;
    this.rootDict = structTreeRoot ? structTreeRoot.dict : null;
    this.pageDict = pageDict;
    this.nodes = [];
  }
  parse() {
    if (!this.root || !this.rootDict) {
      return;
    }
    const parentTree = this.rootDict.get("ParentTree");
    if (!parentTree) {
      return;
    }
    const id = this.pageDict.get("StructParents");
    if (!Number.isInteger(id)) {
      return;
    }
    const numberTree = new NumberTree(parentTree, this.rootDict.xref);
    const parentArray = numberTree.get(id);
    if (!Array.isArray(parentArray)) {
      return;
    }
    const map = /* @__PURE__ */ new Map();
    for (const ref of parentArray) {
      if (isRef(ref)) {
        this.addNode(this.rootDict.xref.fetch(ref), map);
      }
    }
  }
  addNode(dict, map, level = 0) {
    if (level > MAX_DEPTH) {
      warn("StructTree MAX_DEPTH reached.");
      return null;
    }
    if (map.has(dict)) {
      return map.get(dict);
    }
    const element = new StructElementNode(this, dict);
    map.set(dict, element);
    const parent = dict.get("P");
    if (!parent || isName(parent.get("Type"), "StructTreeRoot")) {
      if (!this.addTopLevelNode(dict, element)) {
        map.delete(dict);
      }
      return element;
    }
    const parentNode = this.addNode(parent, map, level + 1);
    if (!parentNode) {
      return element;
    }
    let save = false;
    for (const kid of parentNode.kids) {
      if (kid.type === StructElementType.ELEMENT && kid.dict === dict) {
        kid.parentNode = element;
        save = true;
      }
    }
    if (!save) {
      map.delete(dict);
    }
    return element;
  }
  addTopLevelNode(dict, element) {
    const obj = this.rootDict.get("K");
    if (!obj) {
      return false;
    }
    if (isDict(obj)) {
      if (obj.objId !== dict.objId) {
        return false;
      }
      this.nodes[0] = element;
      return true;
    }
    if (!Array.isArray(obj)) {
      return true;
    }
    let save = false;
    for (let i = 0; i < obj.length; i++) {
      const kidRef = obj[i];
      if (kidRef && kidRef.toString() === dict.objId) {
        this.nodes[i] = element;
        save = true;
      }
    }
    return save;
  }
  /**
   * Convert the tree structure into a simplifed object literal that can
   * be sent to the main thread.
   * @returns {Object}
   */
  get serializable() {
    function nodeToSerializable(node, parent, level = 0) {
      if (level > MAX_DEPTH) {
        warn("StructTree too deep to be fully serialized.");
        return;
      }
      const obj = /* @__PURE__ */ Object.create(null);
      obj.role = node.role;
      obj.children = [];
      parent.children.push(obj);
      const alt = node.dict.get("Alt");
      if (isString(alt)) {
        obj.alt = stringToPDFString(alt);
      }
      for (const kid of node.kids) {
        const kidElement = kid.type === StructElementType.ELEMENT ? kid.parentNode : null;
        if (kidElement) {
          nodeToSerializable(kidElement, obj, level + 1);
          continue;
        } else if (kid.type === StructElementType.PAGE_CONTENT || kid.type === StructElementType.STREAM_CONTENT) {
          obj.children.push({
            type: "content",
            id: `page${kid.pageObjId}_mcid${kid.mcid}`
          });
        } else if (kid.type === StructElementType.OBJECT) {
          obj.children.push({
            type: "object",
            id: kid.refObjId
          });
        }
      }
    }
    const root = /* @__PURE__ */ Object.create(null);
    root.children = [];
    root.role = "Root";
    for (const child of this.nodes) {
      if (!child) {
        continue;
      }
      nodeToSerializable(child, root);
    }
    return root;
  }
};
function fetchDestination(dest) {
  if (dest instanceof Dict) {
    dest = dest.get("D");
  }
  return Array.isArray(dest) ? dest : null;
}
var Catalog = class _Catalog {
  constructor(pdfManager, xref) {
    this.pdfManager = pdfManager;
    this.xref = xref;
    this._catDict = xref.getCatalogObj();
    if (!isDict(this._catDict)) {
      throw new FormatError("Catalog object is not a dictionary.");
    }
    this.fontCache = new RefSetCache();
    this.builtInCMapCache = /* @__PURE__ */ new Map();
    this.standardFontDataCache = /* @__PURE__ */ new Map();
    this.globalImageCache = new GlobalImageCache();
    this.pageKidsCountCache = new RefSetCache();
    this.pageIndexCache = new RefSetCache();
    this.nonBlendModesSet = new RefSet();
  }
  get version() {
    const version = this._catDict.get("Version");
    if (!isName(version)) {
      return shadow(this, "version", null);
    }
    return shadow(this, "version", version.name);
  }
  get collection() {
    let collection = null;
    try {
      const obj = this._catDict.get("Collection");
      if (isDict(obj) && obj.size > 0) {
        collection = obj;
      }
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      info("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return shadow(this, "collection", collection);
  }
  get acroForm() {
    let acroForm = null;
    try {
      const obj = this._catDict.get("AcroForm");
      if (isDict(obj) && obj.size > 0) {
        acroForm = obj;
      }
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      info("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return shadow(this, "acroForm", acroForm);
  }
  get metadata() {
    const streamRef = this._catDict.getRaw("Metadata");
    if (!isRef(streamRef)) {
      return shadow(this, "metadata", null);
    }
    const suppressEncryption = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata);
    const stream = this.xref.fetch(streamRef, suppressEncryption);
    let metadata = null;
    if (isStream(stream) && isDict(stream.dict)) {
      const type = stream.dict.get("Type");
      const subtype = stream.dict.get("Subtype");
      if (isName(type, "Metadata") && isName(subtype, "XML")) {
        try {
          const data = stringToUTF8String(stream.getString());
          if (data) {
            metadata = new MetadataParser(data).serializable;
          }
        } catch (e) {
          if (e instanceof MissingDataException) {
            throw e;
          }
          info("Skipping invalid metadata.");
        }
      }
    }
    return shadow(this, "metadata", metadata);
  }
  get markInfo() {
    let markInfo = null;
    try {
      markInfo = this._readMarkInfo();
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn("Unable to read mark info.");
    }
    return shadow(this, "markInfo", markInfo);
  }
  /**
   * @private
   */
  _readMarkInfo() {
    const obj = this._catDict.get("MarkInfo");
    if (!isDict(obj)) {
      return null;
    }
    const markInfo = Object.assign(/* @__PURE__ */ Object.create(null), {
      Marked: false,
      UserProperties: false,
      Suspects: false
    });
    for (const key in markInfo) {
      if (!obj.has(key)) {
        continue;
      }
      const value = obj.get(key);
      if (!isBool(value)) {
        continue;
      }
      markInfo[key] = value;
    }
    return markInfo;
  }
  get structTreeRoot() {
    let structTree = null;
    try {
      structTree = this._readStructTreeRoot();
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn("Unable read to structTreeRoot info.");
    }
    return shadow(this, "structTreeRoot", structTree);
  }
  /**
   * @private
   */
  _readStructTreeRoot() {
    const obj = this._catDict.get("StructTreeRoot");
    if (!isDict(obj)) {
      return null;
    }
    const root = new StructTreeRoot(obj);
    root.init();
    return root;
  }
  get toplevelPagesDict() {
    const pagesObj = this._catDict.get("Pages");
    if (!isDict(pagesObj)) {
      throw new FormatError("Invalid top-level pages dictionary.");
    }
    return shadow(this, "toplevelPagesDict", pagesObj);
  }
  get documentOutline() {
    let obj = null;
    try {
      obj = this._readDocumentOutline();
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn("Unable to read document outline.");
    }
    return shadow(this, "documentOutline", obj);
  }
  /**
   * @private
   */
  _readDocumentOutline() {
    let obj = this._catDict.get("Outlines");
    if (!isDict(obj)) {
      return null;
    }
    obj = obj.getRaw("First");
    if (!isRef(obj)) {
      return null;
    }
    const root = {
      items: []
    };
    const queue = [{
      obj,
      parent: root
    }];
    const processed = new RefSet();
    processed.put(obj);
    const xref = this.xref, blackColor = new Uint8ClampedArray(3);
    while (queue.length > 0) {
      const i = queue.shift();
      const outlineDict = xref.fetchIfRef(i.obj);
      if (outlineDict === null) {
        continue;
      }
      if (!outlineDict.has("Title")) {
        throw new FormatError("Invalid outline item encountered.");
      }
      const data = {
        url: null,
        dest: null
      };
      _Catalog.parseDestDictionary({
        destDict: outlineDict,
        resultObj: data,
        docBaseUrl: this.pdfManager.docBaseUrl
      });
      const title = outlineDict.get("Title");
      const flags = outlineDict.get("F") || 0;
      const color = outlineDict.getArray("C");
      const count = outlineDict.get("Count");
      let rgbColor = blackColor;
      if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
        rgbColor = ColorSpace.singletons.rgb.getRgb(color, 0);
      }
      const outlineItem = {
        dest: data.dest,
        url: data.url,
        unsafeUrl: data.unsafeUrl,
        newWindow: data.newWindow,
        title: stringToPDFString(title),
        color: rgbColor,
        count: Number.isInteger(count) ? count : void 0,
        bold: !!(flags & 2),
        italic: !!(flags & 1),
        items: []
      };
      i.parent.items.push(outlineItem);
      obj = outlineDict.getRaw("First");
      if (isRef(obj) && !processed.has(obj)) {
        queue.push({
          obj,
          parent: outlineItem
        });
        processed.put(obj);
      }
      obj = outlineDict.getRaw("Next");
      if (isRef(obj) && !processed.has(obj)) {
        queue.push({
          obj,
          parent: i.parent
        });
        processed.put(obj);
      }
    }
    return root.items.length > 0 ? root.items : null;
  }
  get permissions() {
    let permissions = null;
    try {
      permissions = this._readPermissions();
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn("Unable to read permissions.");
    }
    return shadow(this, "permissions", permissions);
  }
  /**
   * @private
   */
  _readPermissions() {
    const encrypt = this.xref.trailer.get("Encrypt");
    if (!isDict(encrypt)) {
      return null;
    }
    let flags = encrypt.get("P");
    if (!isNum(flags)) {
      return null;
    }
    flags += 2 ** 32;
    const permissions = [];
    for (const key in PermissionFlag) {
      const value = PermissionFlag[key];
      if (flags & value) {
        permissions.push(value);
      }
    }
    return permissions;
  }
  get optionalContentConfig() {
    let config = null;
    try {
      const properties = this._catDict.get("OCProperties");
      if (!properties) {
        return shadow(this, "optionalContentConfig", null);
      }
      const defaultConfig = properties.get("D");
      if (!defaultConfig) {
        return shadow(this, "optionalContentConfig", null);
      }
      const groupsData = properties.get("OCGs");
      if (!Array.isArray(groupsData)) {
        return shadow(this, "optionalContentConfig", null);
      }
      const groups = [];
      const groupRefs = [];
      for (const groupRef of groupsData) {
        if (!isRef(groupRef)) {
          continue;
        }
        groupRefs.push(groupRef);
        const group = this.xref.fetchIfRef(groupRef);
        groups.push({
          id: groupRef.toString(),
          name: isString(group.get("Name")) ? stringToPDFString(group.get("Name")) : null,
          intent: isString(group.get("Intent")) ? stringToPDFString(group.get("Intent")) : null
        });
      }
      config = this._readOptionalContentConfig(defaultConfig, groupRefs);
      config.groups = groups;
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn(`Unable to read optional content config: ${ex}`);
    }
    return shadow(this, "optionalContentConfig", config);
  }
  _readOptionalContentConfig(config, contentGroupRefs) {
    function parseOnOff(refs) {
      const onParsed = [];
      if (Array.isArray(refs)) {
        for (const value of refs) {
          if (!isRef(value)) {
            continue;
          }
          if (contentGroupRefs.includes(value)) {
            onParsed.push(value.toString());
          }
        }
      }
      return onParsed;
    }
    function parseOrder(refs, nestedLevels = 0) {
      if (!Array.isArray(refs)) {
        return null;
      }
      const order = [];
      for (const value of refs) {
        if (isRef(value) && contentGroupRefs.includes(value)) {
          parsedOrderRefs.put(value);
          order.push(value.toString());
          continue;
        }
        const nestedOrder = parseNestedOrder(value, nestedLevels);
        if (nestedOrder) {
          order.push(nestedOrder);
        }
      }
      if (nestedLevels > 0) {
        return order;
      }
      const hiddenGroups = [];
      for (const groupRef of contentGroupRefs) {
        if (parsedOrderRefs.has(groupRef)) {
          continue;
        }
        hiddenGroups.push(groupRef.toString());
      }
      if (hiddenGroups.length) {
        order.push({
          name: null,
          order: hiddenGroups
        });
      }
      return order;
    }
    function parseNestedOrder(ref, nestedLevels) {
      if (++nestedLevels > MAX_NESTED_LEVELS) {
        warn("parseNestedOrder - reached MAX_NESTED_LEVELS.");
        return null;
      }
      const value = xref.fetchIfRef(ref);
      if (!Array.isArray(value)) {
        return null;
      }
      const nestedName = xref.fetchIfRef(value[0]);
      if (typeof nestedName !== "string") {
        return null;
      }
      const nestedOrder = parseOrder(value.slice(1), nestedLevels);
      if (!nestedOrder || !nestedOrder.length) {
        return null;
      }
      return {
        name: stringToPDFString(nestedName),
        order: nestedOrder
      };
    }
    const xref = this.xref, parsedOrderRefs = new RefSet(), MAX_NESTED_LEVELS = 10;
    return {
      name: isString(config.get("Name")) ? stringToPDFString(config.get("Name")) : null,
      creator: isString(config.get("Creator")) ? stringToPDFString(config.get("Creator")) : null,
      baseState: isName(config.get("BaseState")) ? config.get("BaseState").name : null,
      on: parseOnOff(config.get("ON")),
      off: parseOnOff(config.get("OFF")),
      order: parseOrder(config.get("Order")),
      groups: null
    };
  }
  get numPages() {
    const obj = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(obj)) {
      throw new FormatError("Page count in top-level pages dictionary is not an integer.");
    }
    return shadow(this, "numPages", obj);
  }
  get destinations() {
    const obj = this._readDests(), dests = /* @__PURE__ */ Object.create(null);
    if (obj instanceof NameTree) {
      for (const [key, value] of obj.getAll()) {
        const dest = fetchDestination(value);
        if (dest) {
          dests[key] = dest;
        }
      }
    } else if (obj instanceof Dict) {
      obj.forEach(function(key, value) {
        const dest = fetchDestination(value);
        if (dest) {
          dests[key] = dest;
        }
      });
    }
    return shadow(this, "destinations", dests);
  }
  getDestination(id) {
    const obj = this._readDests();
    if (obj instanceof NameTree) {
      const dest = fetchDestination(obj.get(id));
      if (dest) {
        return dest;
      }
      const allDest = this.destinations[id];
      if (allDest) {
        warn(`Found "${id}" at an incorrect position in the NameTree.`);
        return allDest;
      }
    } else if (obj instanceof Dict) {
      const dest = fetchDestination(obj.get(id));
      if (dest) {
        return dest;
      }
    }
    return null;
  }
  /**
   * @private
   */
  _readDests() {
    const obj = this._catDict.get("Names");
    if (obj && obj.has("Dests")) {
      return new NameTree(obj.getRaw("Dests"), this.xref);
    } else if (this._catDict.has("Dests")) {
      return this._catDict.get("Dests");
    }
    return void 0;
  }
  get pageLabels() {
    let obj = null;
    try {
      obj = this._readPageLabels();
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn("Unable to read page labels.");
    }
    return shadow(this, "pageLabels", obj);
  }
  /**
   * @private
   */
  _readPageLabels() {
    const obj = this._catDict.getRaw("PageLabels");
    if (!obj) {
      return null;
    }
    const pageLabels = new Array(this.numPages);
    let style = null, prefix = "";
    const numberTree = new NumberTree(obj, this.xref);
    const nums = numberTree.getAll();
    let currentLabel = "", currentIndex = 1;
    for (let i = 0, ii = this.numPages; i < ii; i++) {
      const labelDict = nums.get(i);
      if (labelDict !== void 0) {
        if (!isDict(labelDict)) {
          throw new FormatError("PageLabel is not a dictionary.");
        }
        if (labelDict.has("Type") && !isName(labelDict.get("Type"), "PageLabel")) {
          throw new FormatError("Invalid type in PageLabel dictionary.");
        }
        if (labelDict.has("S")) {
          const s = labelDict.get("S");
          if (!isName(s)) {
            throw new FormatError("Invalid style in PageLabel dictionary.");
          }
          style = s.name;
        } else {
          style = null;
        }
        if (labelDict.has("P")) {
          const p = labelDict.get("P");
          if (!isString(p)) {
            throw new FormatError("Invalid prefix in PageLabel dictionary.");
          }
          prefix = stringToPDFString(p);
        } else {
          prefix = "";
        }
        if (labelDict.has("St")) {
          const st = labelDict.get("St");
          if (!(Number.isInteger(st) && st >= 1)) {
            throw new FormatError("Invalid start in PageLabel dictionary.");
          }
          currentIndex = st;
        } else {
          currentIndex = 1;
        }
      }
      switch (style) {
        case "D":
          currentLabel = currentIndex;
          break;
        case "R":
        case "r":
          currentLabel = toRomanNumerals(currentIndex, style === "r");
          break;
        case "A":
        case "a":
          const LIMIT = 26;
          const A_UPPER_CASE = 65, A_LOWER_CASE = 97;
          const baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
          const letterIndex = currentIndex - 1;
          const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
          const charBuf = [];
          for (let j = 0, jj = letterIndex / LIMIT | 0; j <= jj; j++) {
            charBuf.push(character);
          }
          currentLabel = charBuf.join("");
          break;
        default:
          if (style) {
            throw new FormatError(`Invalid style "${style}" in PageLabel dictionary.`);
          }
          currentLabel = "";
      }
      pageLabels[i] = prefix + currentLabel;
      currentIndex++;
    }
    return pageLabels;
  }
  get pageLayout() {
    const obj = this._catDict.get("PageLayout");
    let pageLayout = "";
    if (isName(obj)) {
      switch (obj.name) {
        case "SinglePage":
        case "OneColumn":
        case "TwoColumnLeft":
        case "TwoColumnRight":
        case "TwoPageLeft":
        case "TwoPageRight":
          pageLayout = obj.name;
      }
    }
    return shadow(this, "pageLayout", pageLayout);
  }
  get pageMode() {
    const obj = this._catDict.get("PageMode");
    let pageMode = "UseNone";
    if (isName(obj)) {
      switch (obj.name) {
        case "UseNone":
        case "UseOutlines":
        case "UseThumbs":
        case "FullScreen":
        case "UseOC":
        case "UseAttachments":
          pageMode = obj.name;
      }
    }
    return shadow(this, "pageMode", pageMode);
  }
  get viewerPreferences() {
    const ViewerPreferencesValidators = {
      HideToolbar: isBool,
      HideMenubar: isBool,
      HideWindowUI: isBool,
      FitWindow: isBool,
      CenterWindow: isBool,
      DisplayDocTitle: isBool,
      NonFullScreenPageMode: isName,
      Direction: isName,
      ViewArea: isName,
      ViewClip: isName,
      PrintArea: isName,
      PrintClip: isName,
      PrintScaling: isName,
      Duplex: isName,
      PickTrayByPDFSize: isBool,
      PrintPageRange: Array.isArray,
      NumCopies: Number.isInteger
    };
    const obj = this._catDict.get("ViewerPreferences");
    let prefs = null;
    if (isDict(obj)) {
      for (const key in ViewerPreferencesValidators) {
        if (!obj.has(key)) {
          continue;
        }
        const value = obj.get(key);
        if (!ViewerPreferencesValidators[key](value)) {
          info(`Bad value in ViewerPreferences for "${key}".`);
          continue;
        }
        let prefValue;
        switch (key) {
          case "NonFullScreenPageMode":
            switch (value.name) {
              case "UseNone":
              case "UseOutlines":
              case "UseThumbs":
              case "UseOC":
                prefValue = value.name;
                break;
              default:
                prefValue = "UseNone";
            }
            break;
          case "Direction":
            switch (value.name) {
              case "L2R":
              case "R2L":
                prefValue = value.name;
                break;
              default:
                prefValue = "L2R";
            }
            break;
          case "ViewArea":
          case "ViewClip":
          case "PrintArea":
          case "PrintClip":
            switch (value.name) {
              case "MediaBox":
              case "CropBox":
              case "BleedBox":
              case "TrimBox":
              case "ArtBox":
                prefValue = value.name;
                break;
              default:
                prefValue = "CropBox";
            }
            break;
          case "PrintScaling":
            switch (value.name) {
              case "None":
              case "AppDefault":
                prefValue = value.name;
                break;
              default:
                prefValue = "AppDefault";
            }
            break;
          case "Duplex":
            switch (value.name) {
              case "Simplex":
              case "DuplexFlipShortEdge":
              case "DuplexFlipLongEdge":
                prefValue = value.name;
                break;
              default:
                prefValue = "None";
            }
            break;
          case "PrintPageRange":
            const length = value.length;
            if (length % 2 !== 0) {
              break;
            }
            const isValid = value.every((page, i, arr) => {
              return Number.isInteger(page) && page > 0 && (i === 0 || page >= arr[i - 1]) && page <= this.numPages;
            });
            if (isValid) {
              prefValue = value;
            }
            break;
          case "NumCopies":
            if (value > 0) {
              prefValue = value;
            }
            break;
          default:
            if (typeof value !== "boolean") {
              throw new FormatError(`viewerPreferences - expected a boolean value for: ${key}`);
            }
            prefValue = value;
        }
        if (prefValue !== void 0) {
          if (!prefs) {
            prefs = /* @__PURE__ */ Object.create(null);
          }
          prefs[key] = prefValue;
        } else {
          info(`Bad value in ViewerPreferences for "${key}".`);
        }
      }
    }
    return shadow(this, "viewerPreferences", prefs);
  }
  get openAction() {
    const obj = this._catDict.get("OpenAction");
    const openAction = /* @__PURE__ */ Object.create(null);
    if (isDict(obj)) {
      const destDict = new Dict(this.xref);
      destDict.set("A", obj);
      const resultObj = {
        url: null,
        dest: null,
        action: null
      };
      _Catalog.parseDestDictionary({
        destDict,
        resultObj
      });
      if (Array.isArray(resultObj.dest)) {
        openAction.dest = resultObj.dest;
      } else if (resultObj.action) {
        openAction.action = resultObj.action;
      }
    } else if (Array.isArray(obj)) {
      openAction.dest = obj;
    }
    return shadow(this, "openAction", objectSize(openAction) > 0 ? openAction : null);
  }
  get attachments() {
    const obj = this._catDict.get("Names");
    let attachments = null;
    if (obj instanceof Dict && obj.has("EmbeddedFiles")) {
      const nameTree = new NameTree(obj.getRaw("EmbeddedFiles"), this.xref);
      for (const [key, value] of nameTree.getAll()) {
        const fs = new FileSpec(value, this.xref);
        if (!attachments) {
          attachments = /* @__PURE__ */ Object.create(null);
        }
        attachments[stringToPDFString(key)] = fs.serializable;
      }
    }
    return shadow(this, "attachments", attachments);
  }
  get xfaImages() {
    const obj = this._catDict.get("Names");
    let xfaImages = null;
    if (obj instanceof Dict && obj.has("XFAImages")) {
      const nameTree = new NameTree(obj.getRaw("XFAImages"), this.xref);
      for (const [key, value] of nameTree.getAll()) {
        if (!xfaImages) {
          xfaImages = new Dict(this.xref);
        }
        xfaImages.set(key, value);
      }
    }
    return shadow(this, "xfaImages", xfaImages);
  }
  _collectJavaScript() {
    const obj = this._catDict.get("Names");
    let javaScript = null;
    function appendIfJavaScriptDict(name, jsDict) {
      if (!(jsDict instanceof Dict)) {
        return;
      }
      if (!isName(jsDict.get("S"), "JavaScript")) {
        return;
      }
      let js = jsDict.get("JS");
      if (isStream(js)) {
        js = js.getString();
      } else if (typeof js !== "string") {
        return;
      }
      if (javaScript === null) {
        javaScript = /* @__PURE__ */ new Map();
      }
      javaScript.set(name, stringToPDFString(js));
    }
    if (obj instanceof Dict && obj.has("JavaScript")) {
      const nameTree = new NameTree(obj.getRaw("JavaScript"), this.xref);
      for (const [key, value] of nameTree.getAll()) {
        appendIfJavaScriptDict(key, value);
      }
    }
    const openAction = this._catDict.get("OpenAction");
    if (openAction) {
      appendIfJavaScriptDict("OpenAction", openAction);
    }
    return javaScript;
  }
  get javaScript() {
    const javaScript = this._collectJavaScript();
    return shadow(this, "javaScript", javaScript ? [...javaScript.values()] : null);
  }
  get jsActions() {
    const javaScript = this._collectJavaScript();
    let actions = collectActions(this.xref, this._catDict, DocumentActionEventType);
    if (javaScript) {
      if (!actions) {
        actions = /* @__PURE__ */ Object.create(null);
      }
      for (const [key, val] of javaScript) {
        if (key in actions) {
          actions[key].push(val);
        } else {
          actions[key] = [val];
        }
      }
    }
    return shadow(this, "jsActions", actions);
  }
  fontFallback(id, handler) {
    const promises = [];
    this.fontCache.forEach(function(promise) {
      promises.push(promise);
    });
    return Promise.all(promises).then((translatedFonts) => {
      for (const translatedFont of translatedFonts) {
        if (translatedFont.loadedName === id) {
          translatedFont.fallback(handler);
          return;
        }
      }
    });
  }
  cleanup(manuallyTriggered = false) {
    clearPrimitiveCaches();
    this.globalImageCache.clear(
      /* onlyData = */
      manuallyTriggered
    );
    this.pageKidsCountCache.clear();
    this.pageIndexCache.clear();
    this.nonBlendModesSet.clear();
    const promises = [];
    this.fontCache.forEach(function(promise) {
      promises.push(promise);
    });
    return Promise.all(promises).then((translatedFonts) => {
      for (const {
        dict
      } of translatedFonts) {
        delete dict.cacheKey;
      }
      this.fontCache.clear();
      this.builtInCMapCache.clear();
      this.standardFontDataCache.clear();
    });
  }
  getPageDict(pageIndex) {
    const capability = createPromiseCapability();
    const nodesToVisit = [this._catDict.getRaw("Pages")];
    const visitedNodes = new RefSet();
    const xref = this.xref, pageKidsCountCache = this.pageKidsCountCache;
    let count, currentPageIndex = 0;
    function next() {
      while (nodesToVisit.length) {
        const currentNode = nodesToVisit.pop();
        if (isRef(currentNode)) {
          count = pageKidsCountCache.get(currentNode);
          if (count > 0 && currentPageIndex + count < pageIndex) {
            currentPageIndex += count;
            continue;
          }
          if (visitedNodes.has(currentNode)) {
            capability.reject(new FormatError("Pages tree contains circular reference."));
            return;
          }
          visitedNodes.put(currentNode);
          xref.fetchAsync(currentNode).then(function(obj) {
            if (isDict(obj, "Page") || isDict(obj) && !obj.has("Kids")) {
              if (pageIndex === currentPageIndex) {
                if (currentNode && !pageKidsCountCache.has(currentNode)) {
                  pageKidsCountCache.put(currentNode, 1);
                }
                capability.resolve([obj, currentNode]);
              } else {
                currentPageIndex++;
                next();
              }
              return;
            }
            nodesToVisit.push(obj);
            next();
          }, capability.reject);
          return;
        }
        if (!isDict(currentNode)) {
          capability.reject(new FormatError("Page dictionary kid reference points to wrong type of object."));
          return;
        }
        count = currentNode.get("Count");
        if (Number.isInteger(count) && count >= 0) {
          const objId = currentNode.objId;
          if (objId && !pageKidsCountCache.has(objId)) {
            pageKidsCountCache.put(objId, count);
          }
          if (currentPageIndex + count <= pageIndex) {
            currentPageIndex += count;
            continue;
          }
        }
        const kids = currentNode.get("Kids");
        if (!Array.isArray(kids)) {
          if (isName(currentNode.get("Type"), "Page") || !currentNode.has("Type") && currentNode.has("Contents")) {
            if (currentPageIndex === pageIndex) {
              capability.resolve([currentNode, null]);
              return;
            }
            currentPageIndex++;
            continue;
          }
          capability.reject(new FormatError("Page dictionary kids object is not an array."));
          return;
        }
        for (let last = kids.length - 1; last >= 0; last--) {
          nodesToVisit.push(kids[last]);
        }
      }
      capability.reject(new Error(`Page index ${pageIndex} not found.`));
    }
    next();
    return capability.promise;
  }
  getPageIndex(pageRef) {
    const cachedPageIndex = this.pageIndexCache.get(pageRef);
    if (cachedPageIndex !== void 0) {
      return Promise.resolve(cachedPageIndex);
    }
    const xref = this.xref;
    function pagesBeforeRef(kidRef) {
      let total2 = 0, parentRef;
      return xref.fetchAsync(kidRef).then(function(node) {
        if (isRefsEqual(kidRef, pageRef) && !isDict(node, "Page") && !(isDict(node) && !node.has("Type") && node.has("Contents"))) {
          throw new FormatError("The reference does not point to a /Page dictionary.");
        }
        if (!node) {
          return null;
        }
        if (!isDict(node)) {
          throw new FormatError("Node must be a dictionary.");
        }
        parentRef = node.getRaw("Parent");
        return node.getAsync("Parent");
      }).then(function(parent) {
        if (!parent) {
          return null;
        }
        if (!isDict(parent)) {
          throw new FormatError("Parent must be a dictionary.");
        }
        return parent.getAsync("Kids");
      }).then(function(kids) {
        if (!kids) {
          return null;
        }
        const kidPromises = [];
        let found = false;
        for (let i = 0, ii = kids.length; i < ii; i++) {
          const kid = kids[i];
          if (!isRef(kid)) {
            throw new FormatError("Kid must be a reference.");
          }
          if (isRefsEqual(kid, kidRef)) {
            found = true;
            break;
          }
          kidPromises.push(xref.fetchAsync(kid).then(function(obj) {
            if (!isDict(obj)) {
              throw new FormatError("Kid node must be a dictionary.");
            }
            if (obj.has("Count")) {
              total2 += obj.get("Count");
            } else {
              total2++;
            }
          }));
        }
        if (!found) {
          throw new FormatError("Kid reference not found in parent's kids.");
        }
        return Promise.all(kidPromises).then(function() {
          return [total2, parentRef];
        });
      });
    }
    let total = 0;
    const next = (ref) => pagesBeforeRef(ref).then((args) => {
      if (!args) {
        this.pageIndexCache.put(pageRef, total);
        return total;
      }
      const [count, parentRef] = args;
      total += count;
      return next(parentRef);
    });
    return next(pageRef);
  }
  /**
   * @typedef ParseDestDictionaryParameters
   * @property {Dict} destDict - The dictionary containing the destination.
   * @property {Object} resultObj - The object where the parsed destination
   *   properties will be placed.
   * @property {string} [docBaseUrl] - The document base URL that is used when
   *   attempting to recover valid absolute URLs from relative ones.
   */
  /**
   * Helper function used to parse the contents of destination dictionaries.
   * @param {ParseDestDictionaryParameters} params
   */
  static parseDestDictionary(params) {
    function addDefaultProtocolToUrl(url2) {
      return url2.startsWith("www.") ? `http://${url2}` : url2;
    }
    function tryConvertUrlEncoding(url2) {
      try {
        return stringToUTF8String(url2);
      } catch (e) {
        return url2;
      }
    }
    const destDict = params.destDict;
    if (!isDict(destDict)) {
      warn("parseDestDictionary: `destDict` must be a dictionary.");
      return;
    }
    const resultObj = params.resultObj;
    if (typeof resultObj !== "object") {
      warn("parseDestDictionary: `resultObj` must be an object.");
      return;
    }
    const docBaseUrl = params.docBaseUrl || null;
    let action = destDict.get("A"), url, dest;
    if (!isDict(action)) {
      if (destDict.has("Dest")) {
        action = destDict.get("Dest");
      } else {
        action = destDict.get("AA");
        if (isDict(action)) {
          if (action.has("D")) {
            action = action.get("D");
          } else if (action.has("U")) {
            action = action.get("U");
          }
        }
      }
    }
    if (isDict(action)) {
      const actionType = action.get("S");
      if (!isName(actionType)) {
        warn("parseDestDictionary: Invalid type in Action dictionary.");
        return;
      }
      const actionName = actionType.name;
      switch (actionName) {
        case "URI":
          url = action.get("URI");
          if (isName(url)) {
            url = "/" + url.name;
          } else if (isString(url)) {
            url = addDefaultProtocolToUrl(url);
          }
          break;
        case "GoTo":
          dest = action.get("D");
          break;
        case "Launch":
        case "GoToR":
          const urlDict = action.get("F");
          if (isDict(urlDict)) {
            url = urlDict.get("F") || null;
          } else if (isString(urlDict)) {
            url = urlDict;
          }
          let remoteDest = action.get("D");
          if (remoteDest) {
            if (isName(remoteDest)) {
              remoteDest = remoteDest.name;
            }
            if (isString(url)) {
              const baseUrl = url.split("#")[0];
              if (isString(remoteDest)) {
                url = baseUrl + "#" + remoteDest;
              } else if (Array.isArray(remoteDest)) {
                url = baseUrl + "#" + JSON.stringify(remoteDest);
              }
            }
          }
          const newWindow = action.get("NewWindow");
          if (isBool(newWindow)) {
            resultObj.newWindow = newWindow;
          }
          break;
        case "Named":
          const namedAction = action.get("N");
          if (isName(namedAction)) {
            resultObj.action = namedAction.name;
          }
          break;
        case "JavaScript":
          const jsAction = action.get("JS");
          let js;
          if (isStream(jsAction)) {
            js = jsAction.getString();
          } else if (isString(jsAction)) {
            js = jsAction;
          }
          if (js) {
            const URL_OPEN_METHODS = ["app.launchURL", "window.open"];
            const regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").split(".").join("\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i");
            const jsUrl = regex.exec(stringToPDFString(js));
            if (jsUrl && jsUrl[2]) {
              url = jsUrl[2];
              if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
                resultObj.newWindow = true;
              }
              break;
            }
          }
        default:
          if (actionName === "JavaScript" || actionName === "ResetForm" || actionName === "SubmitForm") {
            break;
          }
          warn(`parseDestDictionary - unsupported action: "${actionName}".`);
          break;
      }
    } else if (destDict.has("Dest")) {
      dest = destDict.get("Dest");
    }
    if (isString(url)) {
      url = tryConvertUrlEncoding(url);
      const absoluteUrl = createValidAbsoluteUrl(url, docBaseUrl);
      if (absoluteUrl) {
        resultObj.url = absoluteUrl.href;
      }
      resultObj.unsafeUrl = url;
    }
    if (dest) {
      if (isName(dest)) {
        dest = dest.name;
      }
      if (isString(dest) || Array.isArray(dest)) {
        resultObj.dest = dest;
      }
    }
  }
};
function mayHaveChildren(value) {
  return value instanceof Ref || value instanceof Dict || Array.isArray(value) || isStream(value);
}
function addChildren(node, nodesToVisit) {
  if (node instanceof Dict) {
    node = node.getRawValues();
  } else if (isStream(node)) {
    node = node.dict.getRawValues();
  } else if (!Array.isArray(node)) {
    return;
  }
  for (const rawValue of node) {
    if (mayHaveChildren(rawValue)) {
      nodesToVisit.push(rawValue);
    }
  }
}
var ObjectLoader = class {
  constructor(dict, keys, xref) {
    this.dict = dict;
    this.keys = keys;
    this.xref = xref;
    this.refSet = null;
  }
  async load() {
    if (this.xref.stream.isDataLoaded) {
      return void 0;
    }
    const {
      keys,
      dict
    } = this;
    this.refSet = new RefSet();
    const nodesToVisit = [];
    for (let i = 0, ii = keys.length; i < ii; i++) {
      const rawValue = dict.getRaw(keys[i]);
      if (rawValue !== void 0) {
        nodesToVisit.push(rawValue);
      }
    }
    return this._walk(nodesToVisit);
  }
  async _walk(nodesToVisit) {
    const nodesToRevisit = [];
    const pendingRequests = [];
    while (nodesToVisit.length) {
      let currentNode = nodesToVisit.pop();
      if (currentNode instanceof Ref) {
        if (this.refSet.has(currentNode)) {
          continue;
        }
        try {
          this.refSet.put(currentNode);
          currentNode = this.xref.fetch(currentNode);
        } catch (ex) {
          if (!(ex instanceof MissingDataException)) {
            warn(`ObjectLoader._walk - requesting all data: "${ex}".`);
            this.refSet = null;
            const {
              manager
            } = this.xref.stream;
            return manager.requestAllChunks();
          }
          nodesToRevisit.push(currentNode);
          pendingRequests.push({
            begin: ex.begin,
            end: ex.end
          });
        }
      }
      if (isStream(currentNode)) {
        const baseStreams = currentNode.getBaseStreams();
        if (baseStreams) {
          let foundMissingData = false;
          for (const stream of baseStreams) {
            if (stream.isDataLoaded) {
              continue;
            }
            foundMissingData = true;
            pendingRequests.push({
              begin: stream.start,
              end: stream.end
            });
          }
          if (foundMissingData) {
            nodesToRevisit.push(currentNode);
          }
        }
      }
      addChildren(currentNode, nodesToVisit);
    }
    if (pendingRequests.length) {
      await this.xref.stream.manager.requestRanges(pendingRequests);
      for (const node of nodesToRevisit) {
        if (node instanceof Ref) {
          this.refSet.remove(node);
        }
      }
      return this._walk(nodesToRevisit);
    }
    this.refSet = null;
    return void 0;
  }
};
var chunkSize = 512;
var DecryptStream = class extends DecodeStream {
  constructor(str, maybeLength, decrypt) {
    super(maybeLength);
    this.str = str;
    this.dict = str.dict;
    this.decrypt = decrypt;
    this.nextChunk = null;
    this.initialized = false;
  }
  readBlock() {
    let chunk;
    if (this.initialized) {
      chunk = this.nextChunk;
    } else {
      chunk = this.str.getBytes(chunkSize);
      this.initialized = true;
    }
    if (!chunk || chunk.length === 0) {
      this.eof = true;
      return;
    }
    this.nextChunk = this.str.getBytes(chunkSize);
    const hasMoreData = this.nextChunk && this.nextChunk.length > 0;
    const decrypt = this.decrypt;
    chunk = decrypt(chunk, !hasMoreData);
    let bufferLength = this.bufferLength;
    const n = chunk.length, buffer = this.ensureBuffer(bufferLength + n);
    for (let i = 0; i < n; i++) {
      buffer[bufferLength++] = chunk[i];
    }
    this.bufferLength = bufferLength;
  }
};
var ARCFourCipher = class {
  constructor(key) {
    this.a = 0;
    this.b = 0;
    const s = new Uint8Array(256);
    const keyLength = key.length;
    for (let i = 0; i < 256; ++i) {
      s[i] = i;
    }
    for (let i = 0, j = 0; i < 256; ++i) {
      const tmp = s[i];
      j = j + tmp + key[i % keyLength] & 255;
      s[i] = s[j];
      s[j] = tmp;
    }
    this.s = s;
  }
  encryptBlock(data) {
    let a = this.a, b = this.b;
    const s = this.s;
    const n = data.length;
    const output = new Uint8Array(n);
    for (let i = 0; i < n; ++i) {
      a = a + 1 & 255;
      const tmp = s[a];
      b = b + tmp & 255;
      const tmp2 = s[b];
      s[a] = tmp2;
      s[b] = tmp;
      output[i] = data[i] ^ s[tmp + tmp2 & 255];
    }
    this.a = a;
    this.b = b;
    return output;
  }
  decryptBlock(data) {
    return this.encryptBlock(data);
  }
  encrypt(data) {
    return this.encryptBlock(data);
  }
};
var calculateMD5 = function calculateMD5Closure() {
  const r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
  const k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
  function hash(data, offset, length) {
    let h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
    const paddedLength = length + 72 & ~63;
    const padded = new Uint8Array(paddedLength);
    let i, j;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 128;
    const n = paddedLength - 8;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = length << 3 & 255;
    padded[i++] = length >> 5 & 255;
    padded[i++] = length >> 13 & 255;
    padded[i++] = length >> 21 & 255;
    padded[i++] = length >>> 29 & 255;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    const w = new Int32Array(16);
    for (i = 0; i < paddedLength; ) {
      for (j = 0; j < 16; ++j, i += 4) {
        w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
      }
      let a = h0, b = h1, c = h2, d = h3, f, g;
      for (j = 0; j < 64; ++j) {
        if (j < 16) {
          f = b & c | ~b & d;
          g = j;
        } else if (j < 32) {
          f = d & b | ~d & c;
          g = 5 * j + 1 & 15;
        } else if (j < 48) {
          f = b ^ c ^ d;
          g = 3 * j + 5 & 15;
        } else {
          f = c ^ (b | ~d);
          g = 7 * j & 15;
        }
        const tmp = d, rotateArg = a + f + k[j] + w[g] | 0, rotate = r[j];
        d = c;
        c = b;
        b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
        a = tmp;
      }
      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
    }
    return new Uint8Array([h0 & 255, h0 >> 8 & 255, h0 >> 16 & 255, h0 >>> 24 & 255, h1 & 255, h1 >> 8 & 255, h1 >> 16 & 255, h1 >>> 24 & 255, h2 & 255, h2 >> 8 & 255, h2 >> 16 & 255, h2 >>> 24 & 255, h3 & 255, h3 >> 8 & 255, h3 >> 16 & 255, h3 >>> 24 & 255]);
  }
  return hash;
}();
var Word64 = class {
  constructor(highInteger, lowInteger) {
    this.high = highInteger | 0;
    this.low = lowInteger | 0;
  }
  and(word) {
    this.high &= word.high;
    this.low &= word.low;
  }
  xor(word) {
    this.high ^= word.high;
    this.low ^= word.low;
  }
  or(word) {
    this.high |= word.high;
    this.low |= word.low;
  }
  shiftRight(places) {
    if (places >= 32) {
      this.low = this.high >>> places - 32 | 0;
      this.high = 0;
    } else {
      this.low = this.low >>> places | this.high << 32 - places;
      this.high = this.high >>> places | 0;
    }
  }
  shiftLeft(places) {
    if (places >= 32) {
      this.high = this.low << places - 32;
      this.low = 0;
    } else {
      this.high = this.high << places | this.low >>> 32 - places;
      this.low <<= places;
    }
  }
  rotateRight(places) {
    let low, high;
    if (places & 32) {
      high = this.low;
      low = this.high;
    } else {
      low = this.low;
      high = this.high;
    }
    places &= 31;
    this.low = low >>> places | high << 32 - places;
    this.high = high >>> places | low << 32 - places;
  }
  not() {
    this.high = ~this.high;
    this.low = ~this.low;
  }
  add(word) {
    const lowAdd = (this.low >>> 0) + (word.low >>> 0);
    let highAdd = (this.high >>> 0) + (word.high >>> 0);
    if (lowAdd > 4294967295) {
      highAdd += 1;
    }
    this.low = lowAdd | 0;
    this.high = highAdd | 0;
  }
  copyTo(bytes, offset) {
    bytes[offset] = this.high >>> 24 & 255;
    bytes[offset + 1] = this.high >> 16 & 255;
    bytes[offset + 2] = this.high >> 8 & 255;
    bytes[offset + 3] = this.high & 255;
    bytes[offset + 4] = this.low >>> 24 & 255;
    bytes[offset + 5] = this.low >> 16 & 255;
    bytes[offset + 6] = this.low >> 8 & 255;
    bytes[offset + 7] = this.low & 255;
  }
  assign(word) {
    this.high = word.high;
    this.low = word.low;
  }
};
var calculateSHA256 = /* @__PURE__ */ function calculateSHA256Closure() {
  function rotr(x, n) {
    return x >>> n | x << 32 - n;
  }
  function ch(x, y, z) {
    return x & y ^ ~x & z;
  }
  function maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  function sigma(x) {
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
  }
  function sigmaPrime(x) {
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
  }
  function littleSigma(x) {
    return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
  }
  function littleSigmaPrime(x) {
    return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
  }
  const k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  function hash(data, offset, length) {
    let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
    const paddedLength = Math.ceil((length + 9) / 64) * 64;
    const padded = new Uint8Array(paddedLength);
    let i, j;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 128;
    const n = paddedLength - 8;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 255;
    padded[i++] = length >> 21 & 255;
    padded[i++] = length >> 13 & 255;
    padded[i++] = length >> 5 & 255;
    padded[i++] = length << 3 & 255;
    const w = new Uint32Array(64);
    for (i = 0; i < paddedLength; ) {
      for (j = 0; j < 16; ++j) {
        w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        i += 4;
      }
      for (j = 16; j < 64; ++j) {
        w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
      }
      let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, t1, t2;
      for (j = 0; j < 64; ++j) {
        t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
        t2 = sigma(a) + maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1 | 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 | 0;
      }
      h0 = h0 + a | 0;
      h1 = h1 + b | 0;
      h2 = h2 + c | 0;
      h3 = h3 + d | 0;
      h4 = h4 + e | 0;
      h5 = h5 + f | 0;
      h6 = h6 + g | 0;
      h7 = h7 + h | 0;
    }
    return new Uint8Array([h0 >> 24 & 255, h0 >> 16 & 255, h0 >> 8 & 255, h0 & 255, h1 >> 24 & 255, h1 >> 16 & 255, h1 >> 8 & 255, h1 & 255, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, h3 & 255, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, h4 & 255, h5 >> 24 & 255, h5 >> 16 & 255, h5 >> 8 & 255, h5 & 255, h6 >> 24 & 255, h6 >> 16 & 255, h6 >> 8 & 255, h6 & 255, h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255]);
  }
  return hash;
}();
var calculateSHA512 = function calculateSHA512Closure() {
  function ch(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.not();
    tmp.and(z);
    result.xor(tmp);
  }
  function maj(result, x, y, z, tmp) {
    result.assign(x);
    result.and(y);
    tmp.assign(x);
    tmp.and(z);
    result.xor(tmp);
    tmp.assign(y);
    tmp.and(z);
    result.xor(tmp);
  }
  function sigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(28);
    tmp.assign(x);
    tmp.rotateRight(34);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(39);
    result.xor(tmp);
  }
  function sigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(14);
    tmp.assign(x);
    tmp.rotateRight(18);
    result.xor(tmp);
    tmp.assign(x);
    tmp.rotateRight(41);
    result.xor(tmp);
  }
  function littleSigma(result, x, tmp) {
    result.assign(x);
    result.rotateRight(1);
    tmp.assign(x);
    tmp.rotateRight(8);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(7);
    result.xor(tmp);
  }
  function littleSigmaPrime(result, x, tmp) {
    result.assign(x);
    result.rotateRight(19);
    tmp.assign(x);
    tmp.rotateRight(61);
    result.xor(tmp);
    tmp.assign(x);
    tmp.shiftRight(6);
    result.xor(tmp);
  }
  const k = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
  function hash(data, offset, length, mode384 = false) {
    let h0, h1, h2, h3, h4, h5, h6, h7;
    if (!mode384) {
      h0 = new Word64(1779033703, 4089235720);
      h1 = new Word64(3144134277, 2227873595);
      h2 = new Word64(1013904242, 4271175723);
      h3 = new Word64(2773480762, 1595750129);
      h4 = new Word64(1359893119, 2917565137);
      h5 = new Word64(2600822924, 725511199);
      h6 = new Word64(528734635, 4215389547);
      h7 = new Word64(1541459225, 327033209);
    } else {
      h0 = new Word64(3418070365, 3238371032);
      h1 = new Word64(1654270250, 914150663);
      h2 = new Word64(2438529370, 812702999);
      h3 = new Word64(355462360, 4144912697);
      h4 = new Word64(1731405415, 4290775857);
      h5 = new Word64(2394180231, 1750603025);
      h6 = new Word64(3675008525, 1694076839);
      h7 = new Word64(1203062813, 3204075428);
    }
    const paddedLength = Math.ceil((length + 17) / 128) * 128;
    const padded = new Uint8Array(paddedLength);
    let i, j;
    for (i = 0; i < length; ++i) {
      padded[i] = data[offset++];
    }
    padded[i++] = 128;
    const n = paddedLength - 16;
    while (i < n) {
      padded[i++] = 0;
    }
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = 0;
    padded[i++] = length >>> 29 & 255;
    padded[i++] = length >> 21 & 255;
    padded[i++] = length >> 13 & 255;
    padded[i++] = length >> 5 & 255;
    padded[i++] = length << 3 & 255;
    const w = new Array(80);
    for (i = 0; i < 80; i++) {
      w[i] = new Word64(0, 0);
    }
    let a = new Word64(0, 0), b = new Word64(0, 0), c = new Word64(0, 0);
    let d = new Word64(0, 0), e = new Word64(0, 0), f = new Word64(0, 0);
    let g = new Word64(0, 0), h = new Word64(0, 0);
    const t1 = new Word64(0, 0), t2 = new Word64(0, 0);
    const tmp1 = new Word64(0, 0), tmp2 = new Word64(0, 0);
    let tmp3;
    for (i = 0; i < paddedLength; ) {
      for (j = 0; j < 16; ++j) {
        w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
        w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
        i += 8;
      }
      for (j = 16; j < 80; ++j) {
        tmp3 = w[j];
        littleSigmaPrime(tmp3, w[j - 2], tmp2);
        tmp3.add(w[j - 7]);
        littleSigma(tmp1, w[j - 15], tmp2);
        tmp3.add(tmp1);
        tmp3.add(w[j - 16]);
      }
      a.assign(h0);
      b.assign(h1);
      c.assign(h2);
      d.assign(h3);
      e.assign(h4);
      f.assign(h5);
      g.assign(h6);
      h.assign(h7);
      for (j = 0; j < 80; ++j) {
        t1.assign(h);
        sigmaPrime(tmp1, e, tmp2);
        t1.add(tmp1);
        ch(tmp1, e, f, g, tmp2);
        t1.add(tmp1);
        t1.add(k[j]);
        t1.add(w[j]);
        sigma(t2, a, tmp2);
        maj(tmp1, a, b, c, tmp2);
        t2.add(tmp1);
        tmp3 = h;
        h = g;
        g = f;
        f = e;
        d.add(t1);
        e = d;
        d = c;
        c = b;
        b = a;
        tmp3.assign(t1);
        tmp3.add(t2);
        a = tmp3;
      }
      h0.add(a);
      h1.add(b);
      h2.add(c);
      h3.add(d);
      h4.add(e);
      h5.add(f);
      h6.add(g);
      h7.add(h);
    }
    let result;
    if (!mode384) {
      result = new Uint8Array(64);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
      h6.copyTo(result, 48);
      h7.copyTo(result, 56);
    } else {
      result = new Uint8Array(48);
      h0.copyTo(result, 0);
      h1.copyTo(result, 8);
      h2.copyTo(result, 16);
      h3.copyTo(result, 24);
      h4.copyTo(result, 32);
      h5.copyTo(result, 40);
    }
    return result;
  }
  return hash;
}();
function calculateSHA384(data, offset, length) {
  return calculateSHA512(
    data,
    offset,
    length,
    /* mode384 = */
    true
  );
}
var NullCipher = class {
  decryptBlock(data) {
    return data;
  }
  encrypt(data) {
    return data;
  }
};
var AESBaseCipher = class _AESBaseCipher {
  constructor() {
    if (this.constructor === _AESBaseCipher) {
      unreachable("Cannot initialize AESBaseCipher.");
    }
    this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
    this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
    this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
    this._mixCol = new Uint8Array(256);
    for (let i = 0; i < 256; i++) {
      if (i < 128) {
        this._mixCol[i] = i << 1;
      } else {
        this._mixCol[i] = i << 1 ^ 27;
      }
    }
    this.buffer = new Uint8Array(16);
    this.bufferPosition = 0;
  }
  _expandKey(cipherKey) {
    unreachable("Cannot call `_expandKey` on the base class");
  }
  _decrypt(input, key) {
    let t, u, v;
    const state = new Uint8Array(16);
    state.set(input);
    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    for (let i = this._cyclesOfRepetition - 1; i >= 1; --i) {
      t = state[13];
      state[13] = state[9];
      state[9] = state[5];
      state[5] = state[1];
      state[1] = t;
      t = state[14];
      u = state[10];
      state[14] = state[6];
      state[10] = state[2];
      state[6] = t;
      state[2] = u;
      t = state[15];
      u = state[11];
      v = state[7];
      state[15] = state[3];
      state[11] = t;
      state[7] = u;
      state[3] = v;
      for (let j = 0; j < 16; ++j) {
        state[j] = this._inv_s[state[j]];
      }
      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
      for (let j = 0; j < 16; j += 4) {
        const s0 = this._mix[state[j]];
        const s1 = this._mix[state[j + 1]];
        const s2 = this._mix[state[j + 2]];
        const s3 = this._mix[state[j + 3]];
        t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
        state[j] = t >>> 24 & 255;
        state[j + 1] = t >> 16 & 255;
        state[j + 2] = t >> 8 & 255;
        state[j + 3] = t & 255;
      }
    }
    t = state[13];
    state[13] = state[9];
    state[9] = state[5];
    state[5] = state[1];
    state[1] = t;
    t = state[14];
    u = state[10];
    state[14] = state[6];
    state[10] = state[2];
    state[6] = t;
    state[2] = u;
    t = state[15];
    u = state[11];
    v = state[7];
    state[15] = state[3];
    state[11] = t;
    state[7] = u;
    state[3] = v;
    for (let j = 0; j < 16; ++j) {
      state[j] = this._inv_s[state[j]];
      state[j] ^= key[j];
    }
    return state;
  }
  _encrypt(input, key) {
    const s = this._s;
    let t, u, v;
    const state = new Uint8Array(16);
    state.set(input);
    for (let j = 0; j < 16; ++j) {
      state[j] ^= key[j];
    }
    for (let i = 1; i < this._cyclesOfRepetition; i++) {
      for (let j = 0; j < 16; ++j) {
        state[j] = s[state[j]];
      }
      v = state[1];
      state[1] = state[5];
      state[5] = state[9];
      state[9] = state[13];
      state[13] = v;
      v = state[2];
      u = state[6];
      state[2] = state[10];
      state[6] = state[14];
      state[10] = v;
      state[14] = u;
      v = state[3];
      u = state[7];
      t = state[11];
      state[3] = state[15];
      state[7] = v;
      state[11] = u;
      state[15] = t;
      for (let j = 0; j < 16; j += 4) {
        const s0 = state[j + 0];
        const s1 = state[j + 1];
        const s2 = state[j + 2];
        const s3 = state[j + 3];
        t = s0 ^ s1 ^ s2 ^ s3;
        state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];
        state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];
        state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];
        state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];
      }
      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
        state[j] ^= key[k];
      }
    }
    for (let j = 0; j < 16; ++j) {
      state[j] = s[state[j]];
    }
    v = state[1];
    state[1] = state[5];
    state[5] = state[9];
    state[9] = state[13];
    state[13] = v;
    v = state[2];
    u = state[6];
    state[2] = state[10];
    state[6] = state[14];
    state[10] = v;
    state[14] = u;
    v = state[3];
    u = state[7];
    t = state[11];
    state[3] = state[15];
    state[7] = v;
    state[11] = u;
    state[15] = t;
    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
      state[j] ^= key[k];
    }
    return state;
  }
  _decryptBlock2(data, finalize) {
    const sourceLength = data.length;
    let buffer = this.buffer, bufferLength = this.bufferPosition;
    const result = [];
    let iv = this.iv;
    for (let i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;
      if (bufferLength < 16) {
        continue;
      }
      const plain = this._decrypt(buffer, this._key);
      for (let j = 0; j < 16; ++j) {
        plain[j] ^= iv[j];
      }
      iv = buffer;
      result.push(plain);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }
    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;
    if (result.length === 0) {
      return new Uint8Array(0);
    }
    let outputLength = 16 * result.length;
    if (finalize) {
      const lastBlock = result[result.length - 1];
      let psLen = lastBlock[15];
      if (psLen <= 16) {
        for (let i = 15, ii = 16 - psLen; i >= ii; --i) {
          if (lastBlock[i] !== psLen) {
            psLen = 0;
            break;
          }
        }
        outputLength -= psLen;
        result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
      }
    }
    const output = new Uint8Array(outputLength);
    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }
    return output;
  }
  decryptBlock(data, finalize, iv = null) {
    const sourceLength = data.length;
    const buffer = this.buffer;
    let bufferLength = this.bufferPosition;
    if (iv) {
      this.iv = iv;
    } else {
      for (let i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
        buffer[bufferLength] = data[i];
      }
      if (bufferLength < 16) {
        this.bufferLength = bufferLength;
        return new Uint8Array(0);
      }
      this.iv = buffer;
      data = data.subarray(16);
    }
    this.buffer = new Uint8Array(16);
    this.bufferLength = 0;
    this.decryptBlock = this._decryptBlock2;
    return this.decryptBlock(data, finalize);
  }
  encrypt(data, iv) {
    const sourceLength = data.length;
    let buffer = this.buffer, bufferLength = this.bufferPosition;
    const result = [];
    if (!iv) {
      iv = new Uint8Array(16);
    }
    for (let i = 0; i < sourceLength; ++i) {
      buffer[bufferLength] = data[i];
      ++bufferLength;
      if (bufferLength < 16) {
        continue;
      }
      for (let j = 0; j < 16; ++j) {
        buffer[j] ^= iv[j];
      }
      const cipher = this._encrypt(buffer, this._key);
      iv = cipher;
      result.push(cipher);
      buffer = new Uint8Array(16);
      bufferLength = 0;
    }
    this.buffer = buffer;
    this.bufferLength = bufferLength;
    this.iv = iv;
    if (result.length === 0) {
      return new Uint8Array(0);
    }
    const outputLength = 16 * result.length;
    const output = new Uint8Array(outputLength);
    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
      output.set(result[i], j);
    }
    return output;
  }
};
var AES128Cipher = class extends AESBaseCipher {
  constructor(key) {
    super();
    this._cyclesOfRepetition = 10;
    this._keySize = 160;
    this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
    this._key = this._expandKey(key);
  }
  _expandKey(cipherKey) {
    const b = 176;
    const s = this._s;
    const rcon = this._rcon;
    const result = new Uint8Array(b);
    result.set(cipherKey);
    for (let j = 16, i = 1; j < b; ++i) {
      let t1 = result[j - 3];
      let t2 = result[j - 2];
      let t3 = result[j - 1];
      let t4 = result[j - 4];
      t1 = s[t1];
      t2 = s[t2];
      t3 = s[t3];
      t4 = s[t4];
      t1 ^= rcon[i];
      for (let n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 16];
        j++;
        result[j] = t2 ^= result[j - 16];
        j++;
        result[j] = t3 ^= result[j - 16];
        j++;
        result[j] = t4 ^= result[j - 16];
        j++;
      }
    }
    return result;
  }
};
var AES256Cipher = class extends AESBaseCipher {
  constructor(key) {
    super();
    this._cyclesOfRepetition = 14;
    this._keySize = 224;
    this._key = this._expandKey(key);
  }
  _expandKey(cipherKey) {
    const b = 240;
    const s = this._s;
    const result = new Uint8Array(b);
    result.set(cipherKey);
    let r = 1;
    let t1, t2, t3, t4;
    for (let j = 32, i = 1; j < b; ++i) {
      if (j % 32 === 16) {
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
      } else if (j % 32 === 0) {
        t1 = result[j - 3];
        t2 = result[j - 2];
        t3 = result[j - 1];
        t4 = result[j - 4];
        t1 = s[t1];
        t2 = s[t2];
        t3 = s[t3];
        t4 = s[t4];
        t1 ^= r;
        if ((r <<= 1) >= 256) {
          r = (r ^ 27) & 255;
        }
      }
      for (let n = 0; n < 4; ++n) {
        result[j] = t1 ^= result[j - 32];
        j++;
        result[j] = t2 ^= result[j - 32];
        j++;
        result[j] = t3 ^= result[j - 32];
        j++;
        result[j] = t4 ^= result[j - 32];
        j++;
      }
    }
    return result;
  }
};
var PDF17 = class {
  checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerValidationSalt, password.length);
    hashData.set(userBytes, password.length + ownerValidationSalt.length);
    const result = calculateSHA256(hashData, 0, hashData.length);
    return isArrayEqual(result, ownerPassword);
  }
  checkUserPassword(password, userValidationSalt, userPassword) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userValidationSalt, password.length);
    const result = calculateSHA256(hashData, 0, hashData.length);
    return isArrayEqual(result, userPassword);
  }
  getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
    const hashData = new Uint8Array(password.length + 56);
    hashData.set(password, 0);
    hashData.set(ownerKeySalt, password.length);
    hashData.set(userBytes, password.length + ownerKeySalt.length);
    const key = calculateSHA256(hashData, 0, hashData.length);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
  }
  getUserKey(password, userKeySalt, userEncryption) {
    const hashData = new Uint8Array(password.length + 8);
    hashData.set(password, 0);
    hashData.set(userKeySalt, password.length);
    const key = calculateSHA256(hashData, 0, hashData.length);
    const cipher = new AES256Cipher(key);
    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
  }
};
var PDF20 = /* @__PURE__ */ function PDF20Closure() {
  function calculatePDF20Hash(password, input, userBytes) {
    let k = calculateSHA256(input, 0, input.length).subarray(0, 32);
    let e = [0];
    let i = 0;
    while (i < 64 || e[e.length - 1] > i - 32) {
      const combinedLength = password.length + k.length + userBytes.length, combinedArray = new Uint8Array(combinedLength);
      let writeOffset = 0;
      combinedArray.set(password, writeOffset);
      writeOffset += password.length;
      combinedArray.set(k, writeOffset);
      writeOffset += k.length;
      combinedArray.set(userBytes, writeOffset);
      const k1 = new Uint8Array(combinedLength * 64);
      for (let j = 0, pos = 0; j < 64; j++, pos += combinedLength) {
        k1.set(combinedArray, pos);
      }
      const cipher = new AES128Cipher(k.subarray(0, 16));
      e = cipher.encrypt(k1, k.subarray(16, 32));
      let remainder = 0;
      for (let z = 0; z < 16; z++) {
        remainder *= 256 % 3;
        remainder %= 3;
        remainder += (e[z] >>> 0) % 3;
        remainder %= 3;
      }
      if (remainder === 0) {
        k = calculateSHA256(e, 0, e.length);
      } else if (remainder === 1) {
        k = calculateSHA384(e, 0, e.length);
      } else if (remainder === 2) {
        k = calculateSHA512(e, 0, e.length);
      }
      i++;
    }
    return k.subarray(0, 32);
  }
  class PDF202 {
    hash(password, concatBytes, userBytes) {
      return calculatePDF20Hash(password, concatBytes, userBytes);
    }
    checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
      const hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerValidationSalt, password.length);
      hashData.set(userBytes, password.length + ownerValidationSalt.length);
      const result = calculatePDF20Hash(password, hashData, userBytes);
      return isArrayEqual(result, ownerPassword);
    }
    checkUserPassword(password, userValidationSalt, userPassword) {
      const hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userValidationSalt, password.length);
      const result = calculatePDF20Hash(password, hashData, []);
      return isArrayEqual(result, userPassword);
    }
    getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
      const hashData = new Uint8Array(password.length + 56);
      hashData.set(password, 0);
      hashData.set(ownerKeySalt, password.length);
      hashData.set(userBytes, password.length + ownerKeySalt.length);
      const key = calculatePDF20Hash(password, hashData, userBytes);
      const cipher = new AES256Cipher(key);
      return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
    }
    getUserKey(password, userKeySalt, userEncryption) {
      const hashData = new Uint8Array(password.length + 8);
      hashData.set(password, 0);
      hashData.set(userKeySalt, password.length);
      const key = calculatePDF20Hash(password, hashData, []);
      const cipher = new AES256Cipher(key);
      return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
    }
  }
  return PDF202;
}();
var CipherTransform = class {
  constructor(stringCipherConstructor, streamCipherConstructor) {
    this.StringCipherConstructor = stringCipherConstructor;
    this.StreamCipherConstructor = streamCipherConstructor;
  }
  createStream(stream, length) {
    const cipher = new this.StreamCipherConstructor();
    return new DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
      return cipher.decryptBlock(data, finalize);
    });
  }
  decryptString(s) {
    const cipher = new this.StringCipherConstructor();
    let data = stringToBytes(s);
    data = cipher.decryptBlock(data, true);
    return bytesToString(data);
  }
  encryptString(s) {
    const cipher = new this.StringCipherConstructor();
    if (cipher instanceof AESBaseCipher) {
      const strLen = s.length;
      const pad = 16 - strLen % 16;
      if (pad !== 16) {
        s = s.padEnd(16 * Math.ceil(strLen / 16), String.fromCharCode(pad));
      }
      const iv = new Uint8Array(16);
      if (typeof crypto !== "undefined") {
        crypto.getRandomValues(iv);
      } else {
        for (let i = 0; i < 16; i++) {
          iv[i] = Math.floor(256 * Math.random());
        }
      }
      let data2 = stringToBytes(s);
      data2 = cipher.encrypt(data2, iv);
      const buf = new Uint8Array(16 + data2.length);
      buf.set(iv);
      buf.set(data2, 16);
      return bytesToString(buf);
    }
    let data = stringToBytes(s);
    data = cipher.encrypt(data);
    return bytesToString(data);
  }
};
var CipherTransformFactory = function CipherTransformFactoryClosure() {
  const defaultPasswordBytes = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
  function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
    if (password) {
      const passwordLength = Math.min(127, password.length);
      password = password.subarray(0, passwordLength);
    } else {
      password = [];
    }
    let pdfAlgorithm;
    if (revision === 6) {
      pdfAlgorithm = new PDF20();
    } else {
      pdfAlgorithm = new PDF17();
    }
    if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
      return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
    } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
      return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
    }
    return null;
  }
  function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
    const hashDataSize = 40 + ownerPassword.length + fileId.length;
    const hashData = new Uint8Array(hashDataSize);
    let i = 0, j, n;
    if (password) {
      n = Math.min(32, password.length);
      for (; i < n; ++i) {
        hashData[i] = password[i];
      }
    }
    j = 0;
    while (i < 32) {
      hashData[i++] = defaultPasswordBytes[j++];
    }
    for (j = 0, n = ownerPassword.length; j < n; ++j) {
      hashData[i++] = ownerPassword[j];
    }
    hashData[i++] = flags & 255;
    hashData[i++] = flags >> 8 & 255;
    hashData[i++] = flags >> 16 & 255;
    hashData[i++] = flags >>> 24 & 255;
    for (j = 0, n = fileId.length; j < n; ++j) {
      hashData[i++] = fileId[j];
    }
    if (revision >= 4 && !encryptMetadata) {
      hashData[i++] = 255;
      hashData[i++] = 255;
      hashData[i++] = 255;
      hashData[i++] = 255;
    }
    let hash = calculateMD5(hashData, 0, i);
    const keyLengthInBytes = keyLength >> 3;
    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, keyLengthInBytes);
      }
    }
    const encryptionKey = hash.subarray(0, keyLengthInBytes);
    let cipher, checkData;
    if (revision >= 3) {
      for (i = 0; i < 32; ++i) {
        hashData[i] = defaultPasswordBytes[i];
      }
      for (j = 0, n = fileId.length; j < n; ++j) {
        hashData[i++] = fileId[j];
      }
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
      n = encryptionKey.length;
      const derivedKey = new Uint8Array(n);
      for (j = 1; j <= 19; ++j) {
        for (let k = 0; k < n; ++k) {
          derivedKey[k] = encryptionKey[k] ^ j;
        }
        cipher = new ARCFourCipher(derivedKey);
        checkData = cipher.encryptBlock(checkData);
      }
      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    } else {
      cipher = new ARCFourCipher(encryptionKey);
      checkData = cipher.encryptBlock(defaultPasswordBytes);
      for (j = 0, n = checkData.length; j < n; ++j) {
        if (userPassword[j] !== checkData[j]) {
          return null;
        }
      }
    }
    return encryptionKey;
  }
  function decodeUserPassword(password, ownerPassword, revision, keyLength) {
    const hashData = new Uint8Array(32);
    let i = 0;
    const n = Math.min(32, password.length);
    for (; i < n; ++i) {
      hashData[i] = password[i];
    }
    let j = 0;
    while (i < 32) {
      hashData[i++] = defaultPasswordBytes[j++];
    }
    let hash = calculateMD5(hashData, 0, i);
    const keyLengthInBytes = keyLength >> 3;
    if (revision >= 3) {
      for (j = 0; j < 50; ++j) {
        hash = calculateMD5(hash, 0, hash.length);
      }
    }
    let cipher, userPassword;
    if (revision >= 3) {
      userPassword = ownerPassword;
      const derivedKey = new Uint8Array(keyLengthInBytes);
      for (j = 19; j >= 0; j--) {
        for (let k = 0; k < keyLengthInBytes; ++k) {
          derivedKey[k] = hash[k] ^ j;
        }
        cipher = new ARCFourCipher(derivedKey);
        userPassword = cipher.encryptBlock(userPassword);
      }
    } else {
      cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
      userPassword = cipher.encryptBlock(ownerPassword);
    }
    return userPassword;
  }
  const identityName = Name.get("Identity");
  function buildObjectKey(num, gen, encryptionKey, isAes = false) {
    const key = new Uint8Array(encryptionKey.length + 9);
    const n = encryptionKey.length;
    let i;
    for (i = 0; i < n; ++i) {
      key[i] = encryptionKey[i];
    }
    key[i++] = num & 255;
    key[i++] = num >> 8 & 255;
    key[i++] = num >> 16 & 255;
    key[i++] = gen & 255;
    key[i++] = gen >> 8 & 255;
    if (isAes) {
      key[i++] = 115;
      key[i++] = 65;
      key[i++] = 108;
      key[i++] = 84;
    }
    const hash = calculateMD5(key, 0, i);
    return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
  }
  function buildCipherConstructor(cf, name, num, gen, key) {
    if (!isName(name)) {
      throw new FormatError("Invalid crypt filter name.");
    }
    const cryptFilter = cf.get(name.name);
    let cfm;
    if (cryptFilter !== null && cryptFilter !== void 0) {
      cfm = cryptFilter.get("CFM");
    }
    if (!cfm || cfm.name === "None") {
      return function cipherTransformFactoryBuildCipherConstructorNone() {
        return new NullCipher();
      };
    }
    if (cfm.name === "V2") {
      return function cipherTransformFactoryBuildCipherConstructorV2() {
        return new ARCFourCipher(buildObjectKey(
          num,
          gen,
          key,
          /* isAes = */
          false
        ));
      };
    }
    if (cfm.name === "AESV2") {
      return function cipherTransformFactoryBuildCipherConstructorAESV2() {
        return new AES128Cipher(buildObjectKey(
          num,
          gen,
          key,
          /* isAes = */
          true
        ));
      };
    }
    if (cfm.name === "AESV3") {
      return function cipherTransformFactoryBuildCipherConstructorAESV3() {
        return new AES256Cipher(key);
      };
    }
    throw new FormatError("Unknown crypto method");
  }
  class CipherTransformFactory2 {
    constructor(dict, fileId, password) {
      const filter = dict.get("Filter");
      if (!isName(filter, "Standard")) {
        throw new FormatError("unknown encryption method");
      }
      this.dict = dict;
      const algorithm = dict.get("V");
      if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
        throw new FormatError("unsupported encryption algorithm");
      }
      this.algorithm = algorithm;
      let keyLength = dict.get("Length");
      if (!keyLength) {
        if (algorithm <= 3) {
          keyLength = 40;
        } else {
          const cfDict = dict.get("CF");
          const streamCryptoName = dict.get("StmF");
          if (isDict(cfDict) && isName(streamCryptoName)) {
            cfDict.suppressEncryption = true;
            const handlerDict = cfDict.get(streamCryptoName.name);
            keyLength = handlerDict && handlerDict.get("Length") || 128;
            if (keyLength < 40) {
              keyLength <<= 3;
            }
          }
        }
      }
      if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
        throw new FormatError("invalid key length");
      }
      const ownerPassword = stringToBytes(dict.get("O")).subarray(0, 32);
      const userPassword = stringToBytes(dict.get("U")).subarray(0, 32);
      const flags = dict.get("P");
      const revision = dict.get("R");
      const encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
      this.encryptMetadata = encryptMetadata;
      const fileIdBytes = stringToBytes(fileId);
      let passwordBytes;
      if (password) {
        if (revision === 6) {
          try {
            password = utf8StringToString(password);
          } catch (ex) {
            warn("CipherTransformFactory: Unable to convert UTF8 encoded password.");
          }
        }
        passwordBytes = stringToBytes(password);
      }
      let encryptionKey;
      if (algorithm !== 5) {
        encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
      } else {
        const ownerValidationSalt = stringToBytes(dict.get("O")).subarray(32, 40);
        const ownerKeySalt = stringToBytes(dict.get("O")).subarray(40, 48);
        const uBytes = stringToBytes(dict.get("U")).subarray(0, 48);
        const userValidationSalt = stringToBytes(dict.get("U")).subarray(32, 40);
        const userKeySalt = stringToBytes(dict.get("U")).subarray(40, 48);
        const ownerEncryption = stringToBytes(dict.get("OE"));
        const userEncryption = stringToBytes(dict.get("UE"));
        stringToBytes(dict.get("Perms"));
        encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption);
      }
      if (!encryptionKey && !password) {
        throw new PasswordException("No password given", PasswordResponses.NEED_PASSWORD);
      } else if (!encryptionKey && password) {
        const decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
        encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
      }
      if (!encryptionKey) {
        throw new PasswordException("Incorrect Password", PasswordResponses.INCORRECT_PASSWORD);
      }
      this.encryptionKey = encryptionKey;
      if (algorithm >= 4) {
        const cf = dict.get("CF");
        if (isDict(cf)) {
          cf.suppressEncryption = true;
        }
        this.cf = cf;
        this.stmf = dict.get("StmF") || identityName;
        this.strf = dict.get("StrF") || identityName;
        this.eff = dict.get("EFF") || this.stmf;
      }
    }
    createCipherTransform(num, gen) {
      if (this.algorithm === 4 || this.algorithm === 5) {
        return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
      }
      const key = buildObjectKey(
        num,
        gen,
        this.encryptionKey,
        /* isAes = */
        false
      );
      const cipherConstructor = function buildCipherCipherConstructor() {
        return new ARCFourCipher(key);
      };
      return new CipherTransform(cipherConstructor, cipherConstructor);
    }
  }
  return CipherTransformFactory2;
}();
function writeDict(dict, buffer, transform) {
  buffer.push("<<");
  for (const key of dict.getKeys()) {
    buffer.push(` /${escapePDFName(key)} `);
    writeValue(dict.getRaw(key), buffer, transform);
  }
  buffer.push(">>");
}
function writeStream(stream, buffer, transform) {
  writeDict(stream.dict, buffer, transform);
  buffer.push(" stream\n");
  let string = stream.getString();
  if (transform !== null) {
    string = transform.encryptString(string);
  }
  buffer.push(string, "\nendstream\n");
}
function writeArray(array, buffer, transform) {
  buffer.push("[");
  let first = true;
  for (const val of array) {
    if (!first) {
      buffer.push(" ");
    } else {
      first = false;
    }
    writeValue(val, buffer, transform);
  }
  buffer.push("]");
}
function numberToString(value) {
  if (Number.isInteger(value)) {
    return value.toString();
  }
  const roundedValue = Math.round(value * 100);
  if (roundedValue % 100 === 0) {
    return (roundedValue / 100).toString();
  }
  if (roundedValue % 10 === 0) {
    return value.toFixed(1);
  }
  return value.toFixed(2);
}
function writeValue(value, buffer, transform) {
  if (isName(value)) {
    buffer.push(`/${escapePDFName(value.name)}`);
  } else if (isRef(value)) {
    buffer.push(`${value.num} ${value.gen} R`);
  } else if (Array.isArray(value)) {
    writeArray(value, buffer, transform);
  } else if (typeof value === "string") {
    if (transform !== null) {
      value = transform.encryptString(value);
    }
    buffer.push(`(${escapeString(value)})`);
  } else if (typeof value === "number") {
    buffer.push(numberToString(value));
  } else if (isDict(value)) {
    writeDict(value, buffer, transform);
  } else if (isStream(value)) {
    writeStream(value, buffer, transform);
  }
}
function writeInt(number, size, offset, buffer) {
  for (let i = size + offset - 1; i > offset - 1; i--) {
    buffer[i] = number & 255;
    number >>= 8;
  }
  return offset + size;
}
function writeString(string, offset, buffer) {
  for (let i = 0, len = string.length; i < len; i++) {
    buffer[offset + i] = string.charCodeAt(i) & 255;
  }
}
function computeMD5(filesize, xrefInfo) {
  const time = Math.floor(Date.now() / 1e3);
  const filename = xrefInfo.filename || "";
  const md5Buffer = [time.toString(), filename, filesize.toString()];
  let md5BufferLen = md5Buffer.reduce((a, str) => a + str.length, 0);
  for (const value of Object.values(xrefInfo.info)) {
    md5Buffer.push(value);
    md5BufferLen += value.length;
  }
  const array = new Uint8Array(md5BufferLen);
  let offset = 0;
  for (const str of md5Buffer) {
    writeString(str, offset, array);
    offset += str.length;
  }
  return bytesToString(calculateMD5(array));
}
function writeXFADataForAcroform(str, newRefs) {
  const xml = new SimpleXMLParser({
    hasAttributes: true
  }).parseFromString(str);
  for (const {
    xfa
  } of newRefs) {
    if (!xfa) {
      continue;
    }
    const {
      path,
      value
    } = xfa;
    if (!path) {
      continue;
    }
    const node = xml.documentElement.searchNode(parseXFAPath(path), 0);
    if (node) {
      node.childNodes = [new SimpleDOMNode("#text", value)];
    } else {
      warn(`Node not found for path: ${path}`);
    }
  }
  const buffer = [];
  xml.documentElement.dump(buffer);
  return buffer.join("");
}
function updateXFA(xfaData, datasetsRef, newRefs, xref) {
  if (datasetsRef === null || xref === null) {
    return;
  }
  if (xfaData === null) {
    const datasets = xref.fetchIfRef(datasetsRef);
    xfaData = writeXFADataForAcroform(datasets.getString(), newRefs);
  }
  const encrypt = xref.encrypt;
  if (encrypt) {
    const transform = encrypt.createCipherTransform(datasetsRef.num, datasetsRef.gen);
    xfaData = transform.encryptString(xfaData);
  }
  const data = `${datasetsRef.num} ${datasetsRef.gen} obj
<< /Type /EmbeddedFile /Length ${xfaData.length}>>
stream
` + xfaData + "\nendstream\nendobj\n";
  newRefs.push({
    ref: datasetsRef,
    data
  });
}
function incrementalUpdate({
  originalData,
  xrefInfo,
  newRefs,
  xref = null,
  datasetsRef = null,
  xfaData = null
}) {
  updateXFA(xfaData, datasetsRef, newRefs, xref);
  const newXref = new Dict(null);
  const refForXrefTable = xrefInfo.newRef;
  let buffer, baseOffset;
  const lastByte = originalData[originalData.length - 1];
  if (lastByte === /* \n */
  10 || lastByte === /* \r */
  13) {
    buffer = [];
    baseOffset = originalData.length;
  } else {
    buffer = ["\n"];
    baseOffset = originalData.length + 1;
  }
  newXref.set("Size", refForXrefTable.num + 1);
  newXref.set("Prev", xrefInfo.startXRef);
  newXref.set("Type", Name.get("XRef"));
  if (xrefInfo.rootRef !== null) {
    newXref.set("Root", xrefInfo.rootRef);
  }
  if (xrefInfo.infoRef !== null) {
    newXref.set("Info", xrefInfo.infoRef);
  }
  if (xrefInfo.encryptRef !== null) {
    newXref.set("Encrypt", xrefInfo.encryptRef);
  }
  newRefs.push({
    ref: refForXrefTable,
    data: ""
  });
  newRefs = newRefs.sort((a, b) => {
    return a.ref.num - b.ref.num;
  });
  const xrefTableData = [[0, 1, 65535]];
  const indexes = [0, 1];
  let maxOffset = 0;
  for (const {
    ref,
    data
  } of newRefs) {
    maxOffset = Math.max(maxOffset, baseOffset);
    xrefTableData.push([1, baseOffset, Math.min(ref.gen, 65535)]);
    baseOffset += data.length;
    indexes.push(ref.num, 1);
    buffer.push(data);
  }
  newXref.set("Index", indexes);
  if (Array.isArray(xrefInfo.fileIds) && xrefInfo.fileIds.length > 0) {
    const md5 = computeMD5(baseOffset, xrefInfo);
    newXref.set("ID", [xrefInfo.fileIds[0], md5]);
  }
  const offsetSize = Math.ceil(Math.log2(maxOffset) / 8);
  const sizes = [1, offsetSize, 2];
  const structSize = sizes[0] + sizes[1] + sizes[2];
  const tableLength = structSize * xrefTableData.length;
  newXref.set("W", sizes);
  newXref.set("Length", tableLength);
  buffer.push(`${refForXrefTable.num} ${refForXrefTable.gen} obj
`);
  writeDict(newXref, buffer, null);
  buffer.push(" stream\n");
  const bufferLen = buffer.reduce((a, str) => a + str.length, 0);
  const footer = `
endstream
endobj
startxref
${baseOffset}
%%EOF
`;
  const array = new Uint8Array(originalData.length + bufferLen + tableLength + footer.length);
  array.set(originalData);
  let offset = originalData.length;
  for (const str of buffer) {
    writeString(str, offset, array);
    offset += str.length;
  }
  for (const [type, objOffset, gen] of xrefTableData) {
    offset = writeInt(type, sizes[0], offset, array);
    offset = writeInt(objOffset, sizes[1], offset, array);
    offset = writeInt(gen, sizes[2], offset, array);
  }
  writeString(footer, offset, array);
  return array;
}
var AnnotationFactory = class {
  /**
   * Create an `Annotation` object of the correct type for the given reference
   * to an annotation dictionary. This yields a promise that is resolved when
   * the `Annotation` object is constructed.
   *
   * @param {XRef} xref
   * @param {Object} ref
   * @param {PDFManager} pdfManager
   * @param {Object} idFactory
   * @param {boolean} collectFields
   * @returns {Promise} A promise that is resolved with an {Annotation}
   *   instance.
   */
  static create(xref, ref, pdfManager, idFactory, collectFields) {
    return Promise.all([pdfManager.ensureCatalog("acroForm"), collectFields ? this._getPageIndex(xref, ref, pdfManager) : -1]).then(([acroForm, pageIndex]) => pdfManager.ensure(this, "_create", [xref, ref, pdfManager, idFactory, acroForm, collectFields, pageIndex]));
  }
  /**
   * @private
   */
  static _create(xref, ref, pdfManager, idFactory, acroForm, collectFields, pageIndex = -1) {
    const dict = xref.fetchIfRef(ref);
    if (!isDict(dict)) {
      return void 0;
    }
    const id = isRef(ref) ? ref.toString() : `annot_${idFactory.createObjId()}`;
    let subtype = dict.get("Subtype");
    subtype = isName(subtype) ? subtype.name : null;
    const parameters = {
      xref,
      ref,
      dict,
      subtype,
      id,
      pdfManager,
      acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,
      collectFields,
      pageIndex
    };
    switch (subtype) {
      case "Link":
        return new LinkAnnotation(parameters);
      case "Text":
        return new TextAnnotation(parameters);
      case "Widget":
        let fieldType = getInheritableProperty({
          dict,
          key: "FT"
        });
        fieldType = isName(fieldType) ? fieldType.name : null;
        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotation(parameters);
          case "Btn":
            return new ButtonWidgetAnnotation(parameters);
          case "Ch":
            return new ChoiceWidgetAnnotation(parameters);
          case "Sig":
            return new SignatureWidgetAnnotation(parameters);
        }
        warn(`Unimplemented widget field type "${fieldType}", falling back to base field type.`);
        return new WidgetAnnotation(parameters);
      case "Popup":
        return new PopupAnnotation(parameters);
      case "FreeText":
        return new FreeTextAnnotation(parameters);
      case "Line":
        return new LineAnnotation(parameters);
      case "Square":
        return new SquareAnnotation(parameters);
      case "Circle":
        return new CircleAnnotation(parameters);
      case "PolyLine":
        return new PolylineAnnotation(parameters);
      case "Polygon":
        return new PolygonAnnotation(parameters);
      case "Caret":
        return new CaretAnnotation(parameters);
      case "Ink":
        return new InkAnnotation(parameters);
      case "Highlight":
        return new HighlightAnnotation(parameters);
      case "Underline":
        return new UnderlineAnnotation(parameters);
      case "Squiggly":
        return new SquigglyAnnotation(parameters);
      case "StrikeOut":
        return new StrikeOutAnnotation(parameters);
      case "Stamp":
        return new StampAnnotation(parameters);
      case "FileAttachment":
        return new FileAttachmentAnnotation(parameters);
      default:
        if (!collectFields) {
          if (!subtype) {
            warn("Annotation is missing the required /Subtype.");
          } else {
            warn(`Unimplemented annotation type "${subtype}", falling back to base annotation.`);
          }
        }
        return new Annotation(parameters);
    }
  }
  static async _getPageIndex(xref, ref, pdfManager) {
    try {
      const annotDict = await xref.fetchIfRefAsync(ref);
      if (!isDict(annotDict)) {
        return -1;
      }
      const pageRef = annotDict.getRaw("P");
      if (!isRef(pageRef)) {
        return -1;
      }
      const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [pageRef]);
      return pageIndex;
    } catch (ex) {
      warn(`_getPageIndex: "${ex}".`);
      return -1;
    }
  }
};
function getRgbColor(color) {
  const rgbColor = new Uint8ClampedArray(3);
  if (!Array.isArray(color)) {
    return rgbColor;
  }
  switch (color.length) {
    case 0:
      return null;
    case 1:
      ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
      return rgbColor;
    case 3:
      ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
      return rgbColor;
    case 4:
      ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
      return rgbColor;
    default:
      return rgbColor;
  }
}
function getQuadPoints(dict, rect) {
  if (!dict.has("QuadPoints")) {
    return null;
  }
  const quadPoints = dict.getArray("QuadPoints");
  if (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 > 0) {
    return null;
  }
  const quadPointsLists = [];
  for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {
    quadPointsLists.push([]);
    for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
      const x = quadPoints[j];
      const y = quadPoints[j + 1];
      if (rect !== null && (x < rect[0] || x > rect[2] || y < rect[1] || y > rect[3])) {
        return null;
      }
      quadPointsLists[i].push({
        x,
        y
      });
    }
  }
  return quadPointsLists.map((quadPointsList) => {
    const [minX, maxX, minY, maxY] = quadPointsList.reduce(([mX, MX, mY, MY], quadPoint) => [Math.min(mX, quadPoint.x), Math.max(MX, quadPoint.x), Math.min(mY, quadPoint.y), Math.max(MY, quadPoint.y)], [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE]);
    return [{
      x: minX,
      y: maxY
    }, {
      x: maxX,
      y: maxY
    }, {
      x: minX,
      y: minY
    }, {
      x: maxX,
      y: minY
    }];
  });
}
function getTransformMatrix(rect, bbox, matrix) {
  const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(bbox, matrix);
  if (minX === maxX || minY === maxY) {
    return [1, 0, 0, 1, rect[0], rect[1]];
  }
  const xRatio = (rect[2] - rect[0]) / (maxX - minX);
  const yRatio = (rect[3] - rect[1]) / (maxY - minY);
  return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
}
var Annotation = class {
  constructor(params) {
    const dict = params.dict;
    this.setContents(dict.get("Contents"));
    this.setModificationDate(dict.get("M"));
    this.setFlags(dict.get("F"));
    this.setRectangle(dict.getArray("Rect"));
    this.setColor(dict.getArray("C"));
    this.setBorderStyle(dict);
    this.setAppearance(dict);
    this._streams = [];
    if (this.appearance) {
      this._streams.push(this.appearance);
    }
    this.data = {
      annotationFlags: this.flags,
      borderStyle: this.borderStyle,
      color: this.color,
      contents: this.contents,
      hasAppearance: !!this.appearance,
      id: params.id,
      modificationDate: this.modificationDate,
      rect: this.rectangle,
      subtype: params.subtype
    };
    if (params.collectFields) {
      const kids = dict.get("Kids");
      if (Array.isArray(kids)) {
        const kidIds = [];
        for (const kid of kids) {
          if (isRef(kid)) {
            kidIds.push(kid.toString());
          }
        }
        if (kidIds.length !== 0) {
          this.data.kidIds = kidIds;
        }
      }
      this.data.actions = collectActions(params.xref, dict, AnnotationActionEventType);
      this.data.fieldName = this._constructFieldName(dict);
      this.data.pageIndex = params.pageIndex;
    }
    this._fallbackFontDict = null;
  }
  /**
   * @private
   */
  _hasFlag(flags, flag) {
    return !!(flags & flag);
  }
  /**
   * @private
   */
  _isViewable(flags) {
    return !this._hasFlag(flags, AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, AnnotationFlag.NOVIEW);
  }
  /**
   * @private
   */
  _isPrintable(flags) {
    return this._hasFlag(flags, AnnotationFlag.PRINT) && !this._hasFlag(flags, AnnotationFlag.INVISIBLE);
  }
  /**
   * Check if the annotation must be displayed by taking into account
   * the value found in the annotationStorage which may have been set
   * through JS.
   *
   * @public
   * @memberof Annotation
   * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
   */
  mustBeViewed(annotationStorage) {
    const storageEntry = annotationStorage && annotationStorage.get(this.data.id);
    if (storageEntry && storageEntry.hidden !== void 0) {
      return !storageEntry.hidden;
    }
    return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
  }
  /**
   * Check if the annotation must be printed by taking into account
   * the value found in the annotationStorage which may have been set
   * through JS.
   *
   * @public
   * @memberof Annotation
   * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
   */
  mustBePrinted(annotationStorage) {
    const storageEntry = annotationStorage && annotationStorage.get(this.data.id);
    if (storageEntry && storageEntry.print !== void 0) {
      return storageEntry.print;
    }
    return this.printable;
  }
  /**
   * @type {boolean}
   */
  get viewable() {
    if (this.data.quadPoints === null) {
      return false;
    }
    if (this.flags === 0) {
      return true;
    }
    return this._isViewable(this.flags);
  }
  /**
   * @type {boolean}
   */
  get printable() {
    if (this.data.quadPoints === null) {
      return false;
    }
    if (this.flags === 0) {
      return false;
    }
    return this._isPrintable(this.flags);
  }
  /**
   * Set the contents.
   *
   * @public
   * @memberof Annotation
   * @param {string} contents - Text to display for the annotation or, if the
   *                            type of annotation does not display text, a
   *                            description of the annotation's contents
   */
  setContents(contents) {
    this.contents = stringToPDFString(contents || "");
  }
  /**
   * Set the modification date.
   *
   * @public
   * @memberof Annotation
   * @param {string} modificationDate - PDF date string that indicates when the
   *                                    annotation was last modified
   */
  setModificationDate(modificationDate) {
    this.modificationDate = isString(modificationDate) ? modificationDate : null;
  }
  /**
   * Set the flags.
   *
   * @public
   * @memberof Annotation
   * @param {number} flags - Unsigned 32-bit integer specifying annotation
   *                         characteristics
   * @see {@link shared/util.js}
   */
  setFlags(flags) {
    this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
  }
  /**
   * Check if a provided flag is set.
   *
   * @public
   * @memberof Annotation
   * @param {number} flag - Hexadecimal representation for an annotation
   *                        characteristic
   * @returns {boolean}
   * @see {@link shared/util.js}
   */
  hasFlag(flag) {
    return this._hasFlag(this.flags, flag);
  }
  /**
   * Set the rectangle.
   *
   * @public
   * @memberof Annotation
   * @param {Array} rectangle - The rectangle array with exactly four entries
   */
  setRectangle(rectangle) {
    if (Array.isArray(rectangle) && rectangle.length === 4) {
      this.rectangle = Util.normalizeRect(rectangle);
    } else {
      this.rectangle = [0, 0, 0, 0];
    }
  }
  /**
   * Set the color and take care of color space conversion.
   * The default value is black, in RGB color space.
   *
   * @public
   * @memberof Annotation
   * @param {Array} color - The color array containing either 0
   *                        (transparent), 1 (grayscale), 3 (RGB) or
   *                        4 (CMYK) elements
   */
  setColor(color) {
    this.color = getRgbColor(color);
  }
  /**
   * Set the border style (as AnnotationBorderStyle object).
   *
   * @public
   * @memberof Annotation
   * @param {Dict} borderStyle - The border style dictionary
   */
  setBorderStyle(borderStyle) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(this.rectangle, "setRectangle must have been called previously.");
    }
    this.borderStyle = new AnnotationBorderStyle();
    if (!isDict(borderStyle)) {
      return;
    }
    if (borderStyle.has("BS")) {
      const dict = borderStyle.get("BS");
      const dictType = dict.get("Type");
      if (!dictType || isName(dictType, "Border")) {
        this.borderStyle.setWidth(dict.get("W"), this.rectangle);
        this.borderStyle.setStyle(dict.get("S"));
        this.borderStyle.setDashArray(dict.getArray("D"));
      }
    } else if (borderStyle.has("Border")) {
      const array = borderStyle.getArray("Border");
      if (Array.isArray(array) && array.length >= 3) {
        this.borderStyle.setHorizontalCornerRadius(array[0]);
        this.borderStyle.setVerticalCornerRadius(array[1]);
        this.borderStyle.setWidth(array[2], this.rectangle);
        if (array.length === 4) {
          this.borderStyle.setDashArray(array[3]);
        }
      }
    } else {
      this.borderStyle.setWidth(0);
    }
  }
  /**
   * Set the (normal) appearance.
   *
   * @public
   * @memberof Annotation
   * @param {Dict} dict - The annotation's data dictionary
   */
  setAppearance(dict) {
    this.appearance = null;
    const appearanceStates = dict.get("AP");
    if (!isDict(appearanceStates)) {
      return;
    }
    const normalAppearanceState = appearanceStates.get("N");
    if (isStream(normalAppearanceState)) {
      this.appearance = normalAppearanceState;
      return;
    }
    if (!isDict(normalAppearanceState)) {
      return;
    }
    const as = dict.get("AS");
    if (!isName(as) || !normalAppearanceState.has(as.name)) {
      return;
    }
    this.appearance = normalAppearanceState.get(as.name);
  }
  loadResources(keys) {
    return this.appearance.dict.getAsync("Resources").then((resources) => {
      if (!resources) {
        return void 0;
      }
      const objectLoader = new ObjectLoader(resources, keys, resources.xref);
      return objectLoader.load().then(function() {
        return resources;
      });
    });
  }
  getOperatorList(evaluator, task, renderForms, annotationStorage) {
    if (!this.appearance) {
      return Promise.resolve(new OperatorList());
    }
    const appearance = this.appearance;
    const data = this.data;
    const appearanceDict = appearance.dict;
    const resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
    const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
    const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
    const transform = getTransformMatrix(data.rect, bbox, matrix);
    return resourcesPromise.then((resources) => {
      const opList = new OperatorList();
      opList.addOp(OPS.beginAnnotation, [data.id, data.rect, transform, matrix]);
      return evaluator.getOperatorList({
        stream: appearance,
        task,
        resources,
        operatorList: opList,
        fallbackFontDict: this._fallbackFontDict
      }).then(() => {
        opList.addOp(OPS.endAnnotation, []);
        this.reset();
        return opList;
      });
    });
  }
  async save(evaluator, task, annotationStorage) {
    return null;
  }
  /**
   * Get field data for usage in JS sandbox.
   *
   * Field object is defined here:
   * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
   *
   * @public
   * @memberof Annotation
   * @returns {Object | null}
   */
  getFieldObject() {
    if (this.data.kidIds) {
      return {
        id: this.data.id,
        actions: this.data.actions,
        name: this.data.fieldName,
        type: "",
        kidIds: this.data.kidIds,
        page: this.data.pageIndex
      };
    }
    return null;
  }
  /**
   * Reset the annotation.
   *
   * This involves resetting the various streams that are either cached on the
   * annotation instance or created during its construction.
   *
   * @public
   * @memberof Annotation
   */
  reset() {
    if ((typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) && this.appearance && !this._streams.includes(this.appearance)) {
      unreachable("The appearance stream should always be reset.");
    }
    for (const stream of this._streams) {
      stream.reset();
    }
  }
  /**
   * Construct the (fully qualified) field name from the (partial) field
   * names of the field and its ancestors.
   *
   * @private
   * @memberof Annotation
   * @param {Dict} dict - Complete widget annotation dictionary
   * @returns {string}
   */
  _constructFieldName(dict) {
    if (!dict.has("T") && !dict.has("Parent")) {
      warn("Unknown field name, falling back to empty field name.");
      return "";
    }
    if (!dict.has("Parent")) {
      return stringToPDFString(dict.get("T"));
    }
    const fieldName = [];
    if (dict.has("T")) {
      fieldName.unshift(stringToPDFString(dict.get("T")));
    }
    let loopDict = dict;
    const visited = new RefSet();
    if (dict.objId) {
      visited.put(dict.objId);
    }
    while (loopDict.has("Parent")) {
      loopDict = loopDict.get("Parent");
      if (!(loopDict instanceof Dict) || loopDict.objId && visited.has(loopDict.objId)) {
        break;
      }
      if (loopDict.objId) {
        visited.put(loopDict.objId);
      }
      if (loopDict.has("T")) {
        fieldName.unshift(stringToPDFString(loopDict.get("T")));
      }
    }
    return fieldName.join(".");
  }
};
var AnnotationBorderStyle = class {
  constructor() {
    this.width = 1;
    this.style = AnnotationBorderStyleType.SOLID;
    this.dashArray = [3];
    this.horizontalCornerRadius = 0;
    this.verticalCornerRadius = 0;
  }
  /**
   * Set the width.
   *
   * @public
   * @memberof AnnotationBorderStyle
   * @param {number} width - The width.
   * @param {Array} rect - The annotation `Rect` entry.
   */
  setWidth(width, rect = [0, 0, 0, 0]) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(Array.isArray(rect) && rect.length === 4, "A valid `rect` parameter must be provided.");
    }
    if (isName(width)) {
      this.width = 0;
      return;
    }
    if (Number.isInteger(width)) {
      if (width > 0) {
        const maxWidth = (rect[2] - rect[0]) / 2;
        const maxHeight = (rect[3] - rect[1]) / 2;
        if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {
          warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
          width = 1;
        }
      }
      this.width = width;
    }
  }
  /**
   * Set the style.
   *
   * @public
   * @memberof AnnotationBorderStyle
   * @param {Name} style - The annotation style.
   * @see {@link shared/util.js}
   */
  setStyle(style) {
    if (!isName(style)) {
      return;
    }
    switch (style.name) {
      case "S":
        this.style = AnnotationBorderStyleType.SOLID;
        break;
      case "D":
        this.style = AnnotationBorderStyleType.DASHED;
        break;
      case "B":
        this.style = AnnotationBorderStyleType.BEVELED;
        break;
      case "I":
        this.style = AnnotationBorderStyleType.INSET;
        break;
      case "U":
        this.style = AnnotationBorderStyleType.UNDERLINE;
        break;
    }
  }
  /**
   * Set the dash array.
   *
   * @public
   * @memberof AnnotationBorderStyle
   * @param {Array} dashArray - The dash array with at least one element
   */
  setDashArray(dashArray) {
    if (Array.isArray(dashArray) && dashArray.length > 0) {
      let isValid = true;
      let allZeros = true;
      for (const element of dashArray) {
        const validNumber = +element >= 0;
        if (!validNumber) {
          isValid = false;
          break;
        } else if (element > 0) {
          allZeros = false;
        }
      }
      if (isValid && !allZeros) {
        this.dashArray = dashArray;
      } else {
        this.width = 0;
      }
    } else if (dashArray) {
      this.width = 0;
    }
  }
  /**
   * Set the horizontal corner radius (from a Border dictionary).
   *
   * @public
   * @memberof AnnotationBorderStyle
   * @param {number} radius - The horizontal corner radius.
   */
  setHorizontalCornerRadius(radius) {
    if (Number.isInteger(radius)) {
      this.horizontalCornerRadius = radius;
    }
  }
  /**
   * Set the vertical corner radius (from a Border dictionary).
   *
   * @public
   * @memberof AnnotationBorderStyle
   * @param {number} radius - The vertical corner radius.
   */
  setVerticalCornerRadius(radius) {
    if (Number.isInteger(radius)) {
      this.verticalCornerRadius = radius;
    }
  }
};
var MarkupAnnotation = class extends Annotation {
  constructor(parameters) {
    super(parameters);
    const dict = parameters.dict;
    if (dict.has("IRT")) {
      const rawIRT = dict.getRaw("IRT");
      this.data.inReplyTo = isRef(rawIRT) ? rawIRT.toString() : null;
      const rt = dict.get("RT");
      this.data.replyType = isName(rt) ? rt.name : AnnotationReplyType.REPLY;
    }
    if (this.data.replyType === AnnotationReplyType.GROUP) {
      const parent = dict.get("IRT");
      this.data.title = stringToPDFString(parent.get("T") || "");
      this.setContents(parent.get("Contents"));
      this.data.contents = this.contents;
      if (!parent.has("CreationDate")) {
        this.data.creationDate = null;
      } else {
        this.setCreationDate(parent.get("CreationDate"));
        this.data.creationDate = this.creationDate;
      }
      if (!parent.has("M")) {
        this.data.modificationDate = null;
      } else {
        this.setModificationDate(parent.get("M"));
        this.data.modificationDate = this.modificationDate;
      }
      this.data.hasPopup = parent.has("Popup");
      if (!parent.has("C")) {
        this.data.color = null;
      } else {
        this.setColor(parent.getArray("C"));
        this.data.color = this.color;
      }
    } else {
      this.data.title = stringToPDFString(dict.get("T") || "");
      this.setCreationDate(dict.get("CreationDate"));
      this.data.creationDate = this.creationDate;
      this.data.hasPopup = dict.has("Popup");
      if (!dict.has("C")) {
        this.data.color = null;
      }
    }
  }
  /**
   * Set the creation date.
   *
   * @public
   * @memberof MarkupAnnotation
   * @param {string} creationDate - PDF date string that indicates when the
   *                                annotation was originally created
   */
  setCreationDate(creationDate) {
    this.creationDate = isString(creationDate) ? creationDate : null;
  }
  _setDefaultAppearance({
    xref,
    extra,
    strokeColor,
    fillColor,
    blendMode,
    strokeAlpha,
    fillAlpha,
    pointsCallback
  }) {
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = Number.MIN_VALUE;
    let maxY = Number.MIN_VALUE;
    const buffer = ["q"];
    if (extra) {
      buffer.push(extra);
    }
    if (strokeColor) {
      buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
    }
    if (fillColor) {
      buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
    }
    let pointsArray = this.data.quadPoints;
    if (!pointsArray) {
      pointsArray = [[{
        x: this.rectangle[0],
        y: this.rectangle[3]
      }, {
        x: this.rectangle[2],
        y: this.rectangle[3]
      }, {
        x: this.rectangle[0],
        y: this.rectangle[1]
      }, {
        x: this.rectangle[2],
        y: this.rectangle[1]
      }]];
    }
    for (const points of pointsArray) {
      const [mX, MX, mY, MY] = pointsCallback(buffer, points);
      minX = Math.min(minX, mX);
      maxX = Math.max(maxX, MX);
      minY = Math.min(minY, mY);
      maxY = Math.max(maxY, MY);
    }
    buffer.push("Q");
    const formDict = new Dict(xref);
    const appearanceStreamDict = new Dict(xref);
    appearanceStreamDict.set("Subtype", Name.get("Form"));
    const appearanceStream = new StringStream(buffer.join(" "));
    appearanceStream.dict = appearanceStreamDict;
    formDict.set("Fm0", appearanceStream);
    const gsDict = new Dict(xref);
    if (blendMode) {
      gsDict.set("BM", Name.get(blendMode));
    }
    if (typeof strokeAlpha === "number") {
      gsDict.set("CA", strokeAlpha);
    }
    if (typeof fillAlpha === "number") {
      gsDict.set("ca", fillAlpha);
    }
    const stateDict = new Dict(xref);
    stateDict.set("GS0", gsDict);
    const resources = new Dict(xref);
    resources.set("ExtGState", stateDict);
    resources.set("XObject", formDict);
    const appearanceDict = new Dict(xref);
    appearanceDict.set("Resources", resources);
    const bbox = this.data.rect = [minX, minY, maxX, maxY];
    appearanceDict.set("BBox", bbox);
    this.appearance = new StringStream("/GS0 gs /Fm0 Do");
    this.appearance.dict = appearanceDict;
    this._streams.push(this.appearance, appearanceStream);
  }
};
var WidgetAnnotation = class extends Annotation {
  constructor(params) {
    super(params);
    const dict = params.dict;
    const data = this.data;
    this.ref = params.ref;
    data.annotationType = AnnotationType.WIDGET;
    if (data.fieldName === void 0) {
      data.fieldName = this._constructFieldName(dict);
    }
    if (data.actions === void 0) {
      data.actions = collectActions(params.xref, dict, AnnotationActionEventType);
    }
    const fieldValue = getInheritableProperty({
      dict,
      key: "V",
      getArray: true
    });
    data.fieldValue = this._decodeFormValue(fieldValue);
    const defaultFieldValue = getInheritableProperty({
      dict,
      key: "DV",
      getArray: true
    });
    data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
    data.alternativeText = stringToPDFString(dict.get("TU") || "");
    const defaultAppearance = getInheritableProperty({
      dict,
      key: "DA"
    }) || params.acroForm.get("DA");
    this._defaultAppearance = isString(defaultAppearance) ? defaultAppearance : "";
    data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
    const fieldType = getInheritableProperty({
      dict,
      key: "FT"
    });
    data.fieldType = isName(fieldType) ? fieldType.name : null;
    const localResources = getInheritableProperty({
      dict,
      key: "DR"
    });
    const acroFormResources = params.acroForm.get("DR");
    const appearanceResources = this.appearance && this.appearance.dict.get("Resources");
    this._fieldResources = {
      localResources,
      acroFormResources,
      appearanceResources,
      mergedResources: Dict.merge({
        xref: params.xref,
        dictArray: [localResources, appearanceResources, acroFormResources],
        mergeSubDicts: true
      })
    };
    data.fieldFlags = getInheritableProperty({
      dict,
      key: "Ff"
    });
    if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
      data.fieldFlags = 0;
    }
    data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
    data.hidden = this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN);
  }
  /**
   * Decode the given form value.
   *
   * @private
   * @memberof WidgetAnnotation
   * @param {Array<string>|Name|string} formValue - The (possibly encoded)
   *   form value.
   * @returns {Array<string>|string|null}
   */
  _decodeFormValue(formValue) {
    if (Array.isArray(formValue)) {
      return formValue.filter((item) => isString(item)).map((item) => stringToPDFString(item));
    } else if (isName(formValue)) {
      return stringToPDFString(formValue.name);
    } else if (isString(formValue)) {
      return stringToPDFString(formValue);
    }
    return null;
  }
  /**
   * Check if a provided field flag is set.
   *
   * @public
   * @memberof WidgetAnnotation
   * @param {number} flag - Hexadecimal representation for an annotation
   *                        field characteristic
   * @returns {boolean}
   * @see {@link shared/util.js}
   */
  hasFieldFlag(flag) {
    return !!(this.data.fieldFlags & flag);
  }
  getOperatorList(evaluator, task, renderForms, annotationStorage) {
    if (renderForms && !(this instanceof SignatureWidgetAnnotation)) {
      return Promise.resolve(new OperatorList());
    }
    if (!this._hasText) {
      return super.getOperatorList(evaluator, task, renderForms, annotationStorage);
    }
    return this._getAppearance(evaluator, task, annotationStorage).then((content) => {
      if (this.appearance && content === null) {
        return super.getOperatorList(evaluator, task, renderForms, annotationStorage);
      }
      const operatorList = new OperatorList();
      if (!this._defaultAppearance || content === null) {
        return operatorList;
      }
      const matrix = [1, 0, 0, 1, 0, 0];
      const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
      const transform = getTransformMatrix(this.data.rect, bbox, matrix);
      operatorList.addOp(OPS.beginAnnotation, [this.data.id, this.data.rect, transform, matrix]);
      const stream = new StringStream(content);
      return evaluator.getOperatorList({
        stream,
        task,
        resources: this._fieldResources.mergedResources,
        operatorList
      }).then(function() {
        operatorList.addOp(OPS.endAnnotation, []);
        return operatorList;
      });
    });
  }
  async save(evaluator, task, annotationStorage) {
    if (!annotationStorage) {
      return null;
    }
    const storageEntry = annotationStorage.get(this.data.id);
    const value = storageEntry && storageEntry.value;
    if (value === this.data.fieldValue || value === void 0) {
      return null;
    }
    let appearance = await this._getAppearance(evaluator, task, annotationStorage);
    if (appearance === null) {
      return null;
    }
    const {
      xref
    } = evaluator;
    const dict = xref.fetchIfRef(this.ref);
    if (!isDict(dict)) {
      return null;
    }
    const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
    const xfa = {
      path: stringToPDFString(dict.get("T") || ""),
      value
    };
    const newRef = xref.getNewRef();
    const AP = new Dict(xref);
    AP.set("N", newRef);
    const encrypt = xref.encrypt;
    let originalTransform = null;
    let newTransform = null;
    if (encrypt) {
      originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
      newTransform = encrypt.createCipherTransform(newRef.num, newRef.gen);
      appearance = newTransform.encryptString(appearance);
    }
    dict.set("V", isAscii(value) ? value : stringToUTF16BEString(value));
    dict.set("AP", AP);
    dict.set("M", `D:${getModificationDate()}`);
    const appearanceDict = new Dict(xref);
    appearanceDict.set("Length", appearance.length);
    appearanceDict.set("Subtype", Name.get("Form"));
    appearanceDict.set("Resources", this._getSaveFieldResources(xref));
    appearanceDict.set("BBox", bbox);
    const bufferOriginal = [`${this.ref.num} ${this.ref.gen} obj
`];
    writeDict(dict, bufferOriginal, originalTransform);
    bufferOriginal.push("\nendobj\n");
    const bufferNew = [`${newRef.num} ${newRef.gen} obj
`];
    writeDict(appearanceDict, bufferNew, newTransform);
    bufferNew.push(" stream\n", appearance, "\nendstream\nendobj\n");
    return [
      // data for the original object
      // V field changed + reference for new AP
      {
        ref: this.ref,
        data: bufferOriginal.join(""),
        xfa
      },
      // data for the new AP
      {
        ref: newRef,
        data: bufferNew.join(""),
        xfa: null
      }
    ];
  }
  async _getAppearance(evaluator, task, annotationStorage) {
    const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
    if (!annotationStorage || isPassword) {
      return null;
    }
    const storageEntry = annotationStorage.get(this.data.id);
    let value = storageEntry && storageEntry.value;
    if (value === void 0) {
      return null;
    }
    value = value.trim();
    if (value === "") {
      return "";
    }
    let lineCount = -1;
    if (this.data.multiLine) {
      lineCount = value.split(/\r\n|\r|\n/).length;
    }
    const defaultPadding = 2;
    const hPadding = defaultPadding;
    const totalHeight = this.data.rect[3] - this.data.rect[1];
    const totalWidth = this.data.rect[2] - this.data.rect[0];
    if (!this._defaultAppearance) {
      this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g");
    }
    const [defaultAppearance, fontSize] = this._computeFontSize(totalHeight, lineCount);
    const font = await this._getFontData(evaluator, task);
    let descent = font.descent;
    if (isNaN(descent)) {
      descent = 0;
    }
    const vPadding = defaultPadding + Math.abs(descent) * fontSize;
    const alignment = this.data.textAlignment;
    if (this.data.multiLine) {
      return this._getMultilineAppearance(defaultAppearance, value, font, fontSize, totalWidth, totalHeight, alignment, hPadding, vPadding);
    }
    const encodedString = font.encodeString(value).join("");
    if (this.data.comb) {
      return this._getCombAppearance(defaultAppearance, font, encodedString, totalWidth, hPadding, vPadding);
    }
    if (alignment === 0 || alignment > 2) {
      return "/Tx BMC q BT " + defaultAppearance + ` 1 0 0 1 ${hPadding} ${vPadding} Tm (${escapeString(encodedString)}) Tj ET Q EMC`;
    }
    const renderedText = this._renderText(encodedString, font, fontSize, totalWidth, alignment, hPadding, vPadding);
    return "/Tx BMC q BT " + defaultAppearance + ` 1 0 0 1 0 0 Tm ${renderedText} ET Q EMC`;
  }
  async _getFontData(evaluator, task) {
    const operatorList = new OperatorList();
    const initialState = {
      font: null,
      clone() {
        return this;
      }
    };
    const {
      fontName,
      fontSize
    } = this.data.defaultAppearanceData;
    await evaluator.handleSetFont(
      this._fieldResources.mergedResources,
      [fontName && Name.get(fontName), fontSize],
      /* fontRef = */
      null,
      operatorList,
      task,
      initialState,
      /* fallbackFontDict = */
      null
    );
    return initialState.font;
  }
  _computeFontSize(height, lineCount) {
    let {
      fontSize
    } = this.data.defaultAppearanceData;
    if (!fontSize) {
      const roundWithOneDigit = (x) => Math.round(x * 10) / 10;
      const FONT_FACTOR = 0.8;
      if (lineCount === -1) {
        fontSize = roundWithOneDigit(FONT_FACTOR * height);
      } else {
        fontSize = 10;
        let lineHeight = fontSize / FONT_FACTOR;
        let numberOfLines = Math.round(height / lineHeight);
        numberOfLines = Math.max(numberOfLines, lineCount);
        lineHeight = height / numberOfLines;
        fontSize = roundWithOneDigit(FONT_FACTOR * lineHeight);
      }
      const {
        fontName,
        fontColor
      } = this.data.defaultAppearanceData;
      this._defaultAppearance = createDefaultAppearance({
        fontSize,
        fontName,
        fontColor
      });
    }
    return [this._defaultAppearance, fontSize];
  }
  _renderText(text, font, fontSize, totalWidth, alignment, hPadding, vPadding) {
    const glyphs = font.charsToGlyphs(text);
    const scale = fontSize / 1e3;
    let width = 0;
    for (const glyph of glyphs) {
      width += glyph.width * scale;
    }
    let shift;
    if (alignment === 1) {
      shift = (totalWidth - width) / 2;
    } else if (alignment === 2) {
      shift = totalWidth - width - hPadding;
    } else {
      shift = hPadding;
    }
    shift = shift.toFixed(2);
    vPadding = vPadding.toFixed(2);
    return `${shift} ${vPadding} Td (${escapeString(text)}) Tj`;
  }
  /**
   * @private
   */
  _getSaveFieldResources(xref) {
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(this.data.defaultAppearanceData, "Expected `_defaultAppearanceData` to have been set.");
    }
    const {
      localResources,
      appearanceResources,
      acroFormResources
    } = this._fieldResources;
    const fontName = this.data.defaultAppearanceData && this.data.defaultAppearanceData.fontName;
    if (!fontName) {
      return localResources || Dict.empty;
    }
    for (const resources of [localResources, appearanceResources]) {
      if (resources instanceof Dict) {
        const localFont = resources.get("Font");
        if (localFont instanceof Dict && localFont.has(fontName)) {
          return resources;
        }
      }
    }
    if (acroFormResources instanceof Dict) {
      const acroFormFont = acroFormResources.get("Font");
      if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
        const subFontDict = new Dict(xref);
        subFontDict.set(fontName, acroFormFont.getRaw(fontName));
        const subResourcesDict = new Dict(xref);
        subResourcesDict.set("Font", subFontDict);
        return Dict.merge({
          xref,
          dictArray: [subResourcesDict, localResources],
          mergeSubDicts: true
        });
      }
    }
    return localResources || Dict.empty;
  }
  getFieldObject() {
    return null;
  }
};
var TextWidgetAnnotation = class extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this._hasText = true;
    const dict = params.dict;
    if (!isString(this.data.fieldValue)) {
      this.data.fieldValue = "";
    }
    let alignment = getInheritableProperty({
      dict,
      key: "Q"
    });
    if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
      alignment = null;
    }
    this.data.textAlignment = alignment;
    let maximumLength = getInheritableProperty({
      dict,
      key: "MaxLen"
    });
    if (!Number.isInteger(maximumLength) || maximumLength < 0) {
      maximumLength = null;
    }
    this.data.maxLen = maximumLength;
    this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
    this.data.comb = this.hasFieldFlag(AnnotationFieldFlag.COMB) && !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== null;
  }
  _getCombAppearance(defaultAppearance, font, text, width, hPadding, vPadding) {
    const combWidth = (width / this.data.maxLen).toFixed(2);
    const buf = [];
    const positions = font.getCharPositions(text);
    for (const [start, end] of positions) {
      buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
    }
    const renderedComb = buf.join(` ${combWidth} 0 Td `);
    return "/Tx BMC q BT " + defaultAppearance + ` 1 0 0 1 ${hPadding} ${vPadding} Tm ${renderedComb} ET Q EMC`;
  }
  _getMultilineAppearance(defaultAppearance, text, font, fontSize, width, height, alignment, hPadding, vPadding) {
    const lines = text.split(/\r\n|\r|\n/);
    const buf = [];
    const totalWidth = width - 2 * hPadding;
    for (const line of lines) {
      const chunks = this._splitLine(line, font, fontSize, totalWidth);
      for (const chunk of chunks) {
        const padding = buf.length === 0 ? hPadding : 0;
        buf.push(this._renderText(
          chunk,
          font,
          fontSize,
          width,
          alignment,
          padding,
          -fontSize
          // <0 because a line is below the previous one
        ));
      }
    }
    const renderedText = buf.join("\n");
    return "/Tx BMC q BT " + defaultAppearance + ` 1 0 0 1 0 ${height} Tm ${renderedText} ET Q EMC`;
  }
  _splitLine(line, font, fontSize, width) {
    line = font.encodeString(line).join("");
    const glyphs = font.charsToGlyphs(line);
    if (glyphs.length <= 1) {
      return [line];
    }
    const positions = font.getCharPositions(line);
    const scale = fontSize / 1e3;
    const chunks = [];
    let lastSpacePosInStringStart = -1, lastSpacePosInStringEnd = -1, lastSpacePos = -1, startChunk = 0, currentWidth = 0;
    for (let i = 0, ii = glyphs.length; i < ii; i++) {
      const [start, end] = positions[i];
      const glyph = glyphs[i];
      const glyphWidth = glyph.width * scale;
      if (glyph.unicode === " ") {
        if (currentWidth + glyphWidth > width) {
          chunks.push(line.substring(startChunk, start));
          startChunk = start;
          currentWidth = glyphWidth;
          lastSpacePosInStringStart = -1;
          lastSpacePos = -1;
        } else {
          currentWidth += glyphWidth;
          lastSpacePosInStringStart = start;
          lastSpacePosInStringEnd = end;
          lastSpacePos = i;
        }
      } else {
        if (currentWidth + glyphWidth > width) {
          if (lastSpacePosInStringStart !== -1) {
            chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
            startChunk = lastSpacePosInStringEnd;
            i = lastSpacePos + 1;
            lastSpacePosInStringStart = -1;
            currentWidth = 0;
          } else {
            chunks.push(line.substring(startChunk, start));
            startChunk = start;
            currentWidth = glyphWidth;
          }
        } else {
          currentWidth += glyphWidth;
        }
      }
    }
    if (startChunk < line.length) {
      chunks.push(line.substring(startChunk, line.length));
    }
    return chunks;
  }
  getFieldObject() {
    return {
      id: this.data.id,
      value: this.data.fieldValue,
      defaultValue: this.data.defaultFieldValue,
      multiline: this.data.multiLine,
      password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
      charLimit: this.data.maxLen,
      comb: this.data.comb,
      editable: !this.data.readOnly,
      hidden: this.data.hidden,
      name: this.data.fieldName,
      rect: this.data.rect,
      actions: this.data.actions,
      page: this.data.pageIndex,
      type: "text"
    };
  }
};
var ButtonWidgetAnnotation = class extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this.checkedAppearance = null;
    this.uncheckedAppearance = null;
    this.data.checkBox = !this.hasFieldFlag(AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
    this.data.radioButton = this.hasFieldFlag(AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
    this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
    this.data.isTooltipOnly = false;
    if (this.data.checkBox) {
      this._processCheckBox(params);
    } else if (this.data.radioButton) {
      this._processRadioButton(params);
    } else if (this.data.pushButton) {
      this._processPushButton(params);
    } else {
      warn("Invalid field flags for button widget annotation");
    }
  }
  getOperatorList(evaluator, task, renderForms, annotationStorage) {
    if (this.data.pushButton) {
      return super.getOperatorList(
        evaluator,
        task,
        false,
        // we use normalAppearance to render the button
        annotationStorage
      );
    }
    if (annotationStorage) {
      const storageEntry = annotationStorage.get(this.data.id);
      const value = storageEntry && storageEntry.value;
      if (value === void 0) {
        return super.getOperatorList(evaluator, task, renderForms, annotationStorage);
      }
      let appearance;
      if (value) {
        appearance = this.checkedAppearance;
      } else {
        appearance = this.uncheckedAppearance;
      }
      if (appearance) {
        const savedAppearance = this.appearance;
        this.appearance = appearance;
        const operatorList = super.getOperatorList(evaluator, task, renderForms, annotationStorage);
        this.appearance = savedAppearance;
        return operatorList;
      }
      return Promise.resolve(new OperatorList());
    }
    return super.getOperatorList(evaluator, task, renderForms, annotationStorage);
  }
  async save(evaluator, task, annotationStorage) {
    if (this.data.checkBox) {
      return this._saveCheckbox(evaluator, task, annotationStorage);
    }
    if (this.data.radioButton) {
      return this._saveRadioButton(evaluator, task, annotationStorage);
    }
    return null;
  }
  async _saveCheckbox(evaluator, task, annotationStorage) {
    if (!annotationStorage) {
      return null;
    }
    const storageEntry = annotationStorage.get(this.data.id);
    const value = storageEntry && storageEntry.value;
    if (value === void 0) {
      return null;
    }
    const defaultValue = this.data.fieldValue && this.data.fieldValue !== "Off";
    if (defaultValue === value) {
      return null;
    }
    const dict = evaluator.xref.fetchIfRef(this.ref);
    if (!isDict(dict)) {
      return null;
    }
    const xfa = {
      path: stringToPDFString(dict.get("T") || ""),
      value: value ? this.data.exportValue : ""
    };
    const name = Name.get(value ? this.data.exportValue : "Off");
    dict.set("V", name);
    dict.set("AS", name);
    dict.set("M", `D:${getModificationDate()}`);
    const encrypt = evaluator.xref.encrypt;
    let originalTransform = null;
    if (encrypt) {
      originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
    }
    const buffer = [`${this.ref.num} ${this.ref.gen} obj
`];
    writeDict(dict, buffer, originalTransform);
    buffer.push("\nendobj\n");
    return [{
      ref: this.ref,
      data: buffer.join(""),
      xfa
    }];
  }
  async _saveRadioButton(evaluator, task, annotationStorage) {
    if (!annotationStorage) {
      return null;
    }
    const storageEntry = annotationStorage.get(this.data.id);
    const value = storageEntry && storageEntry.value;
    if (value === void 0) {
      return null;
    }
    const defaultValue = this.data.fieldValue === this.data.buttonValue;
    if (defaultValue === value) {
      return null;
    }
    const dict = evaluator.xref.fetchIfRef(this.ref);
    if (!isDict(dict)) {
      return null;
    }
    const xfa = {
      path: stringToPDFString(dict.get("T") || ""),
      value: value ? this.data.buttonValue : ""
    };
    const name = Name.get(value ? this.data.buttonValue : "Off");
    let parentBuffer = null;
    const encrypt = evaluator.xref.encrypt;
    if (value) {
      if (isRef(this.parent)) {
        const parent = evaluator.xref.fetch(this.parent);
        let parentTransform = null;
        if (encrypt) {
          parentTransform = encrypt.createCipherTransform(this.parent.num, this.parent.gen);
        }
        parent.set("V", name);
        parentBuffer = [`${this.parent.num} ${this.parent.gen} obj
`];
        writeDict(parent, parentBuffer, parentTransform);
        parentBuffer.push("\nendobj\n");
      } else if (isDict(this.parent)) {
        this.parent.set("V", name);
      }
    }
    dict.set("AS", name);
    dict.set("M", `D:${getModificationDate()}`);
    let originalTransform = null;
    if (encrypt) {
      originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen);
    }
    const buffer = [`${this.ref.num} ${this.ref.gen} obj
`];
    writeDict(dict, buffer, originalTransform);
    buffer.push("\nendobj\n");
    const newRefs = [{
      ref: this.ref,
      data: buffer.join(""),
      xfa
    }];
    if (parentBuffer !== null) {
      newRefs.push({
        ref: this.parent,
        data: parentBuffer.join(""),
        xfa: null
      });
    }
    return newRefs;
  }
  _processCheckBox(params) {
    const customAppearance = params.dict.get("AP");
    if (!isDict(customAppearance)) {
      return;
    }
    const normalAppearance = customAppearance.get("N");
    if (!isDict(normalAppearance)) {
      return;
    }
    const exportValues = normalAppearance.getKeys();
    if (!exportValues.includes("Off")) {
      exportValues.push("Off");
    }
    if (!exportValues.includes(this.data.fieldValue)) {
      this.data.fieldValue = null;
    }
    if (exportValues.length !== 2) {
      return;
    }
    this.data.exportValue = exportValues[0] === "Off" ? exportValues[1] : exportValues[0];
    this.checkedAppearance = normalAppearance.get(this.data.exportValue);
    this.uncheckedAppearance = normalAppearance.get("Off") || null;
    this._streams.push(this.checkedAppearance);
    if (this.uncheckedAppearance) {
      this._streams.push(this.uncheckedAppearance);
    }
    this._fallbackFontDict = this.fallbackFontDict;
  }
  _processRadioButton(params) {
    this.data.fieldValue = this.data.buttonValue = null;
    const fieldParent = params.dict.get("Parent");
    if (isDict(fieldParent)) {
      this.parent = params.dict.getRaw("Parent");
      const fieldParentValue = fieldParent.get("V");
      if (isName(fieldParentValue)) {
        this.data.fieldValue = this._decodeFormValue(fieldParentValue);
      }
    }
    const appearanceStates = params.dict.get("AP");
    if (!isDict(appearanceStates)) {
      return;
    }
    const normalAppearance = appearanceStates.get("N");
    if (!isDict(normalAppearance)) {
      return;
    }
    for (const key of normalAppearance.getKeys()) {
      if (key !== "Off") {
        this.data.buttonValue = this._decodeFormValue(key);
        break;
      }
    }
    this.checkedAppearance = normalAppearance.get(this.data.buttonValue);
    this.uncheckedAppearance = normalAppearance.get("Off") || null;
    this._streams.push(this.checkedAppearance);
    if (this.uncheckedAppearance) {
      this._streams.push(this.uncheckedAppearance);
    }
    this._fallbackFontDict = this.fallbackFontDict;
  }
  _processPushButton(params) {
    if (!params.dict.has("A") && !params.dict.has("AA") && !this.data.alternativeText) {
      warn("Push buttons without action dictionaries are not supported");
      return;
    }
    this.data.isTooltipOnly = !params.dict.has("A") && !params.dict.has("AA");
    Catalog.parseDestDictionary({
      destDict: params.dict,
      resultObj: this.data,
      docBaseUrl: params.pdfManager.docBaseUrl
    });
  }
  getFieldObject() {
    let type = "button";
    let exportValues;
    if (this.data.checkBox) {
      type = "checkbox";
      exportValues = this.data.exportValue;
    } else if (this.data.radioButton) {
      type = "radiobutton";
      exportValues = this.data.buttonValue;
    }
    return {
      id: this.data.id,
      value: this.data.fieldValue || "Off",
      defaultValue: this.data.defaultFieldValue,
      exportValues,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      page: this.data.pageIndex,
      type
    };
  }
  get fallbackFontDict() {
    const dict = new Dict();
    dict.set("BaseFont", Name.get("ZapfDingbats"));
    dict.set("Type", Name.get("FallbackType"));
    dict.set("Subtype", Name.get("FallbackType"));
    dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
    return shadow(this, "fallbackFontDict", dict);
  }
};
var ChoiceWidgetAnnotation = class extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this.data.options = [];
    const options = getInheritableProperty({
      dict: params.dict,
      key: "Opt"
    });
    if (Array.isArray(options)) {
      const xref = params.xref;
      for (let i = 0, ii = options.length; i < ii; i++) {
        const option = xref.fetchIfRef(options[i]);
        const isOptionArray = Array.isArray(option);
        this.data.options[i] = {
          exportValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option),
          displayValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option)
        };
      }
    }
    if (isString(this.data.fieldValue)) {
      this.data.fieldValue = [this.data.fieldValue];
    } else if (!this.data.fieldValue) {
      this.data.fieldValue = [];
    }
    this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
    this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
    this._hasText = true;
  }
  getFieldObject() {
    const type = this.data.combo ? "combobox" : "listbox";
    const value = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return {
      id: this.data.id,
      value,
      defaultValue: this.data.defaultFieldValue,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      numItems: this.data.fieldValue.length,
      multipleSelection: this.data.multiSelect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      items: this.data.options,
      page: this.data.pageIndex,
      type
    };
  }
};
var SignatureWidgetAnnotation = class extends WidgetAnnotation {
  constructor(params) {
    super(params);
    this.data.fieldValue = null;
  }
  getFieldObject() {
    return {
      id: this.data.id,
      value: null,
      page: this.data.pageIndex,
      type: "signature"
    };
  }
};
var TextAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    const DEFAULT_ICON_SIZE = 22;
    super(parameters);
    const dict = parameters.dict;
    this.data.annotationType = AnnotationType.TEXT;
    if (this.data.hasAppearance) {
      this.data.name = "NoIcon";
    } else {
      this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
      this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
      this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
    }
    if (dict.has("State")) {
      this.data.state = dict.get("State") || null;
      this.data.stateModel = dict.get("StateModel") || null;
    } else {
      this.data.state = null;
      this.data.stateModel = null;
    }
  }
};
var LinkAnnotation = class extends Annotation {
  constructor(params) {
    super(params);
    this.data.annotationType = AnnotationType.LINK;
    const quadPoints = getQuadPoints(params.dict, this.rectangle);
    if (quadPoints) {
      this.data.quadPoints = quadPoints;
    }
    Catalog.parseDestDictionary({
      destDict: params.dict,
      resultObj: this.data,
      docBaseUrl: params.pdfManager.docBaseUrl
    });
  }
};
var PopupAnnotation = class extends Annotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.POPUP;
    let parentItem = parameters.dict.get("Parent");
    if (!parentItem) {
      warn("Popup annotation has a missing or invalid parent annotation.");
      return;
    }
    const parentSubtype = parentItem.get("Subtype");
    this.data.parentType = isName(parentSubtype) ? parentSubtype.name : null;
    const rawParent = parameters.dict.getRaw("Parent");
    this.data.parentId = isRef(rawParent) ? rawParent.toString() : null;
    const parentRect = parentItem.getArray("Rect");
    if (Array.isArray(parentRect) && parentRect.length === 4) {
      this.data.parentRect = Util.normalizeRect(parentRect);
    } else {
      this.data.parentRect = [0, 0, 0, 0];
    }
    const rt = parentItem.get("RT");
    if (isName(rt, AnnotationReplyType.GROUP)) {
      parentItem = parentItem.get("IRT");
    }
    if (!parentItem.has("M")) {
      this.data.modificationDate = null;
    } else {
      this.setModificationDate(parentItem.get("M"));
      this.data.modificationDate = this.modificationDate;
    }
    if (!parentItem.has("C")) {
      this.data.color = null;
    } else {
      this.setColor(parentItem.getArray("C"));
      this.data.color = this.color;
    }
    if (!this.viewable) {
      const parentFlags = parentItem.get("F");
      if (this._isViewable(parentFlags)) {
        this.setFlags(parentFlags);
      }
    }
    this.data.title = stringToPDFString(parentItem.get("T") || "");
    this.data.contents = stringToPDFString(parentItem.get("Contents") || "");
  }
};
var FreeTextAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.FREETEXT;
  }
};
var LineAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.LINE;
    const lineCoordinates = parameters.dict.getArray("L");
    this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
      const strokeAlpha = parameters.dict.get("CA");
      let fillColor = null, interiorColor = parameters.dict.getArray("IC");
      if (interiorColor) {
        interiorColor = getRgbColor(interiorColor);
        fillColor = interiorColor ? Array.from(interiorColor).map((c) => c / 255) : null;
      }
      const fillAlpha = fillColor ? strokeAlpha : null;
      const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth;
      const bbox = [this.data.lineCoordinates[0] - borderAdjust, this.data.lineCoordinates[1] - borderAdjust, this.data.lineCoordinates[2] + borderAdjust, this.data.lineCoordinates[3] + borderAdjust];
      if (!Util.intersect(this.rectangle, bbox)) {
        this.rectangle = bbox;
      }
      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${borderWidth} w`,
        strokeColor,
        fillColor,
        strokeAlpha,
        fillAlpha,
        pointsCallback: (buffer, points) => {
          buffer.push(`${lineCoordinates[0]} ${lineCoordinates[1]} m`, `${lineCoordinates[2]} ${lineCoordinates[3]} l`, "S");
          return [points[0].x - borderWidth, points[1].x + borderWidth, points[3].y - borderWidth, points[1].y + borderWidth];
        }
      });
    }
  }
};
var SquareAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.SQUARE;
    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
      const strokeAlpha = parameters.dict.get("CA");
      let fillColor = null, interiorColor = parameters.dict.getArray("IC");
      if (interiorColor) {
        interiorColor = getRgbColor(interiorColor);
        fillColor = interiorColor ? Array.from(interiorColor).map((c) => c / 255) : null;
      }
      const fillAlpha = fillColor ? strokeAlpha : null;
      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${this.borderStyle.width} w`,
        strokeColor,
        fillColor,
        strokeAlpha,
        fillAlpha,
        pointsCallback: (buffer, points) => {
          const x = points[2].x + this.borderStyle.width / 2;
          const y = points[2].y + this.borderStyle.width / 2;
          const width = points[3].x - points[2].x - this.borderStyle.width;
          const height = points[1].y - points[3].y - this.borderStyle.width;
          buffer.push(`${x} ${y} ${width} ${height} re`);
          if (fillColor) {
            buffer.push("B");
          } else {
            buffer.push("S");
          }
          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }
};
var CircleAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.CIRCLE;
    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
      const strokeAlpha = parameters.dict.get("CA");
      let fillColor = null;
      let interiorColor = parameters.dict.getArray("IC");
      if (interiorColor) {
        interiorColor = getRgbColor(interiorColor);
        fillColor = interiorColor ? Array.from(interiorColor).map((c) => c / 255) : null;
      }
      const fillAlpha = fillColor ? strokeAlpha : null;
      const controlPointsDistance = 4 / 3 * Math.tan(Math.PI / (2 * 4));
      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${this.borderStyle.width} w`,
        strokeColor,
        fillColor,
        strokeAlpha,
        fillAlpha,
        pointsCallback: (buffer, points) => {
          const x0 = points[0].x + this.borderStyle.width / 2;
          const y0 = points[0].y - this.borderStyle.width / 2;
          const x1 = points[3].x - this.borderStyle.width / 2;
          const y1 = points[3].y + this.borderStyle.width / 2;
          const xMid = x0 + (x1 - x0) / 2;
          const yMid = y0 + (y1 - y0) / 2;
          const xOffset = (x1 - x0) / 2 * controlPointsDistance;
          const yOffset = (y1 - y0) / 2 * controlPointsDistance;
          buffer.push(`${xMid} ${y1} m`, `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`, `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`, `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`, `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`, "h");
          if (fillColor) {
            buffer.push("B");
          } else {
            buffer.push("S");
          }
          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }
};
var PolylineAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.POLYLINE;
    this.data.vertices = [];
    const rawVertices = parameters.dict.getArray("Vertices");
    if (!Array.isArray(rawVertices)) {
      return;
    }
    for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {
      this.data.vertices.push({
        x: rawVertices[i],
        y: rawVertices[i + 1]
      });
    }
    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
      const strokeAlpha = parameters.dict.get("CA");
      const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth;
      const bbox = [Infinity, Infinity, -Infinity, -Infinity];
      for (const vertex of this.data.vertices) {
        bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
        bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
        bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
        bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
      }
      if (!Util.intersect(this.rectangle, bbox)) {
        this.rectangle = bbox;
      }
      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${borderWidth} w`,
        strokeColor,
        strokeAlpha,
        pointsCallback: (buffer, points) => {
          const vertices = this.data.vertices;
          for (let i = 0, ii = vertices.length; i < ii; i++) {
            buffer.push(`${vertices[i].x} ${vertices[i].y} ${i === 0 ? "m" : "l"}`);
          }
          buffer.push("S");
          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }
};
var PolygonAnnotation = class extends PolylineAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.POLYGON;
  }
};
var CaretAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.CARET;
  }
};
var InkAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.INK;
    this.data.inkLists = [];
    const rawInkLists = parameters.dict.getArray("InkList");
    if (!Array.isArray(rawInkLists)) {
      return;
    }
    const xref = parameters.xref;
    for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
      this.data.inkLists.push([]);
      for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
        this.data.inkLists[i].push({
          x: xref.fetchIfRef(rawInkLists[i][j]),
          y: xref.fetchIfRef(rawInkLists[i][j + 1])
        });
      }
    }
    if (!this.appearance) {
      const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
      const strokeAlpha = parameters.dict.get("CA");
      const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth;
      const bbox = [Infinity, Infinity, -Infinity, -Infinity];
      for (const inkLists of this.data.inkLists) {
        for (const vertex of inkLists) {
          bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
          bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
          bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
          bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
        }
      }
      if (!Util.intersect(this.rectangle, bbox)) {
        this.rectangle = bbox;
      }
      this._setDefaultAppearance({
        xref: parameters.xref,
        extra: `${borderWidth} w`,
        strokeColor,
        strokeAlpha,
        pointsCallback: (buffer, points) => {
          for (const inkList of this.data.inkLists) {
            for (let i = 0, ii = inkList.length; i < ii; i++) {
              buffer.push(`${inkList[i].x} ${inkList[i].y} ${i === 0 ? "m" : "l"}`);
            }
            buffer.push("S");
          }
          return [points[0].x, points[1].x, points[3].y, points[1].y];
        }
      });
    }
  }
};
var HighlightAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.HIGHLIGHT;
    const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);
    if (quadPoints) {
      const resources = this.appearance && this.appearance.dict.get("Resources");
      if (!this.appearance || !(resources && resources.has("ExtGState"))) {
        if (this.appearance) {
          warn("HighlightAnnotation - ignoring built-in appearance stream.");
        }
        const fillColor = this.color ? Array.from(this.color).map((c) => c / 255) : [1, 1, 0];
        const fillAlpha = parameters.dict.get("CA");
        this._setDefaultAppearance({
          xref: parameters.xref,
          fillColor,
          blendMode: "Multiply",
          fillAlpha,
          pointsCallback: (buffer, points) => {
            buffer.push(`${points[0].x} ${points[0].y} m`, `${points[1].x} ${points[1].y} l`, `${points[3].x} ${points[3].y} l`, `${points[2].x} ${points[2].y} l`, "f");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      this.data.hasPopup = false;
    }
  }
};
var UnderlineAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.UNDERLINE;
    const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);
    if (quadPoints) {
      if (!this.appearance) {
        const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
        const strokeAlpha = parameters.dict.get("CA");
        this._setDefaultAppearance({
          xref: parameters.xref,
          extra: "[] 0 d 1 w",
          strokeColor,
          strokeAlpha,
          pointsCallback: (buffer, points) => {
            buffer.push(`${points[2].x} ${points[2].y} m`, `${points[3].x} ${points[3].y} l`, "S");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      this.data.hasPopup = false;
    }
  }
};
var SquigglyAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.SQUIGGLY;
    const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);
    if (quadPoints) {
      if (!this.appearance) {
        const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
        const strokeAlpha = parameters.dict.get("CA");
        this._setDefaultAppearance({
          xref: parameters.xref,
          extra: "[] 0 d 1 w",
          strokeColor,
          strokeAlpha,
          pointsCallback: (buffer, points) => {
            const dy = (points[0].y - points[2].y) / 6;
            let shift = dy;
            let x = points[2].x;
            const y = points[2].y;
            const xEnd = points[3].x;
            buffer.push(`${x} ${y + shift} m`);
            do {
              x += 2;
              shift = shift === 0 ? dy : 0;
              buffer.push(`${x} ${y + shift} l`);
            } while (x < xEnd);
            buffer.push("S");
            return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];
          }
        });
      }
    } else {
      this.data.hasPopup = false;
    }
  }
};
var StrikeOutAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.STRIKEOUT;
    const quadPoints = this.data.quadPoints = getQuadPoints(parameters.dict, null);
    if (quadPoints) {
      if (!this.appearance) {
        const strokeColor = this.color ? Array.from(this.color).map((c) => c / 255) : [0, 0, 0];
        const strokeAlpha = parameters.dict.get("CA");
        this._setDefaultAppearance({
          xref: parameters.xref,
          extra: "[] 0 d 1 w",
          strokeColor,
          strokeAlpha,
          pointsCallback: (buffer, points) => {
            buffer.push(`${(points[0].x + points[2].x) / 2} ${(points[0].y + points[2].y) / 2} m`, `${(points[1].x + points[3].x) / 2} ${(points[1].y + points[3].y) / 2} l`, "S");
            return [points[0].x, points[1].x, points[3].y, points[1].y];
          }
        });
      }
    } else {
      this.data.hasPopup = false;
    }
  }
};
var StampAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    this.data.annotationType = AnnotationType.STAMP;
  }
};
var FileAttachmentAnnotation = class extends MarkupAnnotation {
  constructor(parameters) {
    super(parameters);
    const file = new FileSpec(parameters.dict.get("FS"), parameters.xref);
    this.data.annotationType = AnnotationType.FILEATTACHMENT;
    this.data.file = file.serializable;
  }
};
var dimConverters = {
  pt: (x) => x,
  cm: (x) => x / 2.54 * 72,
  mm: (x) => x / (10 * 2.54) * 72,
  in: (x) => x * 72,
  px: (x) => x
};
var measurementPattern = /([+-]?[0-9]+\.?[0-9]*)(.*)/;
function stripQuotes(str) {
  if (str.startsWith("'") || str.startsWith('"')) {
    return str.slice(1, str.length - 1);
  }
  return str;
}
function getInteger({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }
  data = data.trim();
  const n = parseInt(data, 10);
  if (!isNaN(n) && validate(n)) {
    return n;
  }
  return defaultValue;
}
function getFloat({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }
  data = data.trim();
  const n = parseFloat(data);
  if (!isNaN(n) && validate(n)) {
    return n;
  }
  return defaultValue;
}
function getKeyword({
  data,
  defaultValue,
  validate
}) {
  if (!data) {
    return defaultValue;
  }
  data = data.trim();
  if (validate(data)) {
    return data;
  }
  return defaultValue;
}
function getStringOption(data, options) {
  return getKeyword({
    data,
    defaultValue: options[0],
    validate: (k) => options.includes(k)
  });
}
function getMeasurement(str, def = "0") {
  def = def || "0";
  if (!str) {
    return getMeasurement(def);
  }
  const match = str.trim().match(measurementPattern);
  if (!match) {
    return getMeasurement(def);
  }
  const [, valueStr, unit] = match;
  const value = parseFloat(valueStr);
  if (isNaN(value)) {
    return getMeasurement(def);
  }
  if (value === 0) {
    return 0;
  }
  const conv = dimConverters[unit];
  if (conv) {
    return conv(value);
  }
  return value;
}
function getRatio(data) {
  if (!data) {
    return {
      num: 1,
      den: 1
    };
  }
  const ratio = data.trim().split(/\s*:\s*/).map((x) => parseFloat(x)).filter((x) => !isNaN(x));
  if (ratio.length === 1) {
    ratio.push(1);
  }
  if (ratio.length === 0) {
    return {
      num: 1,
      den: 1
    };
  }
  const [num, den] = ratio;
  return {
    num,
    den
  };
}
function getRelevant(data) {
  if (!data) {
    return [];
  }
  return data.trim().split(/\s+/).map((e) => {
    return {
      excluded: e[0] === "-",
      viewname: e.substring(1)
    };
  });
}
function getColor(data, def = [0, 0, 0]) {
  let [r, g, b] = def;
  if (!data) {
    return {
      r,
      g,
      b
    };
  }
  const color = data.trim().split(/\s*,\s*/).map((c) => Math.min(Math.max(0, parseInt(c.trim(), 10)), 255)).map((c) => isNaN(c) ? 0 : c);
  if (color.length < 3) {
    return {
      r,
      g,
      b
    };
  }
  [r, g, b] = color;
  return {
    r,
    g,
    b
  };
}
function getBBox(data) {
  const def = -1;
  if (!data) {
    return {
      x: def,
      y: def,
      width: def,
      height: def
    };
  }
  const bbox = data.trim().split(/\s*,\s*/).map((m) => getMeasurement(m, "-1"));
  if (bbox.length < 4 || bbox[2] < 0 || bbox[3] < 0) {
    return {
      x: def,
      y: def,
      width: def,
      height: def
    };
  }
  const [x, y, width, height] = bbox;
  return {
    x,
    y,
    width,
    height
  };
}
var HTMLResult = class _HTMLResult {
  static get FAILURE() {
    return shadow(this, "FAILURE", new _HTMLResult(false, null, null, null));
  }
  static get EMPTY() {
    return shadow(this, "EMPTY", new _HTMLResult(true, null, null, null));
  }
  constructor(success, html, bbox, breakNode) {
    this.success = success;
    this.html = html;
    this.bbox = bbox;
    this.breakNode = breakNode;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(node) {
    return new _HTMLResult(false, null, null, node);
  }
  static success(html, bbox = null) {
    return new _HTMLResult(true, html, bbox, null);
  }
};
var $buildXFAObject = Symbol();
var NamespaceIds = {
  config: {
    id: 0,
    check: (ns) => ns.startsWith("http://www.xfa.org/schema/xci/")
  },
  connectionSet: {
    id: 1,
    check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
  },
  datasets: {
    id: 2,
    check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-data/")
  },
  form: {
    id: 3,
    check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-form/")
  },
  localeSet: {
    id: 4,
    check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
  },
  pdf: {
    id: 5,
    check: (ns) => ns === "http://ns.adobe.com/xdp/pdf/"
  },
  signature: {
    id: 6,
    check: (ns) => ns === "http://www.w3.org/2000/09/xmldsig#"
  },
  sourceSet: {
    id: 7,
    check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-source-set/")
  },
  stylesheet: {
    id: 8,
    check: (ns) => ns === "http://www.w3.org/1999/XSL/Transform"
  },
  template: {
    id: 9,
    check: (ns) => ns.startsWith("http://www.xfa.org/schema/xfa-template/")
  },
  xdc: {
    id: 10,
    check: (ns) => ns.startsWith("http://www.xfa.org/schema/xdc/")
  },
  xdp: {
    id: 11,
    check: (ns) => ns === "http://ns.adobe.com/xdp/"
  },
  xfdf: {
    id: 12,
    check: (ns) => ns === "http://ns.adobe.com/xfdf/"
  },
  xhtml: {
    id: 13,
    check: (ns) => ns === "http://www.w3.org/1999/xhtml"
  },
  xmpmeta: {
    id: 14,
    check: (ns) => ns === "http://ns.adobe.com/xmpmeta/"
  }
};
var namePattern = /^[^.[]+/;
var indexPattern = /^[^\]]+/;
var operators = {
  dot: 0,
  dotDot: 1,
  dotHash: 2,
  dotBracket: 3,
  dotParen: 4
};
var shortcuts = /* @__PURE__ */ new Map([["$data", (root, current) => root.datasets.data], ["$template", (root, current) => root.template], ["$connectionSet", (root, current) => root.connectionSet], ["$form", (root, current) => root.form], ["$layout", (root, current) => root.layout], ["$host", (root, current) => root.host], ["$dataWindow", (root, current) => root.dataWindow], ["$event", (root, current) => root.event], ["!", (root, current) => root.datasets], ["$xfa", (root, current) => root], ["xfa", (root, current) => root], ["$", (root, current) => current]]);
var somCache = /* @__PURE__ */ new WeakMap();
function parseIndex(index) {
  index = index.trim();
  if (index === "*") {
    return Infinity;
  }
  return parseInt(index, 10) || 0;
}
function parseExpression(expr, dotDotAllowed, noExpr = true) {
  let match = expr.match(namePattern);
  if (!match) {
    return null;
  }
  let [name] = match;
  const parsed = [{
    name,
    cacheName: "." + name,
    index: 0,
    js: null,
    formCalc: null,
    operator: operators.dot
  }];
  let pos = name.length;
  while (pos < expr.length) {
    const spos = pos;
    const char = expr.charAt(pos++);
    if (char === "[") {
      match = expr.slice(pos).match(indexPattern);
      if (!match) {
        warn("XFA - Invalid index in SOM expression");
        return null;
      }
      parsed[parsed.length - 1].index = parseIndex(match[0]);
      pos += match[0].length + 1;
      continue;
    }
    let operator;
    switch (expr.charAt(pos)) {
      case ".":
        if (!dotDotAllowed) {
          return null;
        }
        pos++;
        operator = operators.dotDot;
        break;
      case "#":
        pos++;
        operator = operators.dotHash;
        break;
      case "[":
        if (noExpr) {
          warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
          return null;
        }
        operator = operators.dotBracket;
        break;
      case "(":
        if (noExpr) {
          warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
          return null;
        }
        operator = operators.dotParen;
        break;
      default:
        operator = operators.dot;
        break;
    }
    match = expr.slice(pos).match(namePattern);
    if (!match) {
      break;
    }
    [name] = match;
    pos += name.length;
    parsed.push({
      name,
      cacheName: expr.slice(spos, pos),
      operator,
      index: 0,
      js: null,
      formCalc: null
    });
  }
  return parsed;
}
function searchNode(root, container, expr, dotDotAllowed = true, useCache = true) {
  const parsed = parseExpression(expr, dotDotAllowed);
  if (!parsed) {
    return null;
  }
  const fn = shortcuts.get(parsed[0].name);
  let i = 0;
  let isQualified;
  if (fn) {
    isQualified = true;
    root = [fn(root, container)];
    i = 1;
  } else {
    isQualified = container === null;
    root = [container || root];
  }
  for (let ii = parsed.length; i < ii; i++) {
    const {
      name,
      cacheName,
      operator,
      index
    } = parsed[i];
    const nodes = [];
    for (const node of root) {
      if (!(node instanceof XFAObject)) {
        continue;
      }
      let children, cached;
      if (useCache) {
        cached = somCache.get(node);
        if (!cached) {
          cached = /* @__PURE__ */ new Map();
          somCache.set(node, cached);
        }
        children = cached.get(cacheName);
      }
      if (!children) {
        switch (operator) {
          case operators.dot:
            children = node[$getChildrenByName](name, false);
            break;
          case operators.dotDot:
            children = node[$getChildrenByName](name, true);
            break;
          case operators.dotHash:
            children = node[$getChildrenByClass](name);
            if (children instanceof XFAObjectArray) {
              children = children.children;
            } else {
              children = [children];
            }
            break;
        }
        if (useCache) {
          cached.set(cacheName, children);
        }
      }
      if (children.length > 0) {
        nodes.push(children);
      }
    }
    if (nodes.length === 0 && !isQualified && i === 0) {
      const parent = container[$getParent]();
      container = parent;
      if (!container) {
        return null;
      }
      i = -1;
      root = [container];
      continue;
    }
    if (isFinite(index)) {
      root = nodes.filter((node) => index < node.length).map((node) => node[index]);
    } else {
      root = nodes.reduce((acc, node) => acc.concat(node), []);
    }
  }
  if (root.length === 0) {
    return null;
  }
  return root;
}
function createNodes(root, path) {
  let node = null;
  for (const {
    name,
    index
  } of path) {
    for (let i = 0, ii = !isFinite(index) ? 0 : index; i <= ii; i++) {
      node = new XmlObject(root[$namespaceId], name);
      root[$appendChild](node);
    }
    root = node;
  }
  return node;
}
function createDataNode(root, container, expr) {
  const parsed = parseExpression(expr);
  if (!parsed) {
    return null;
  }
  if (parsed.some((x) => x.operator === operators.dotDot)) {
    return null;
  }
  const fn = shortcuts.get(parsed[0].name);
  let i = 0;
  if (fn) {
    root = fn(root, container);
    i = 1;
  } else {
    root = container || root;
  }
  for (let ii = parsed.length; i < ii; i++) {
    const {
      name,
      operator,
      index
    } = parsed[i];
    if (!isFinite(index)) {
      parsed[i].index = 0;
      return createNodes(root, parsed.slice(i));
    }
    let children;
    switch (operator) {
      case operators.dot:
        children = root[$getChildrenByName](name, false);
        break;
      case operators.dotDot:
        children = root[$getChildrenByName](name, true);
        break;
      case operators.dotHash:
        children = root[$getChildrenByClass](name);
        if (children instanceof XFAObjectArray) {
          children = children.children;
        } else {
          children = [children];
        }
        break;
    }
    if (children.length === 0) {
      return createNodes(root, parsed.slice(i));
    }
    if (index < children.length) {
      const child = children[index];
      if (!(child instanceof XFAObject)) {
        warn(`XFA - Cannot create a node.`);
        return null;
      }
      root = child;
    } else {
      parsed[i].index = index - children.length;
      return createNodes(root, parsed.slice(i));
    }
  }
  return null;
}
var $acceptWhitespace = Symbol();
var $addHTML = Symbol();
var $appendChild = Symbol();
var $childrenToHTML = Symbol();
var $clean = Symbol();
var $cleanPage = Symbol();
var $cleanup = Symbol();
var $clone = Symbol();
var $consumed = Symbol();
var $content = Symbol("content");
var $data = Symbol("data");
var $dump = Symbol();
var $extra = Symbol("extra");
var $finalize = Symbol();
var $flushHTML = Symbol();
var $getAttributeIt = Symbol();
var $getAttributes = Symbol();
var $getAvailableSpace = Symbol();
var $getChildrenByClass = Symbol();
var $getChildrenByName = Symbol();
var $getChildrenByNameIt = Symbol();
var $getDataValue = Symbol();
var $getExtra = Symbol();
var $getRealChildrenByNameIt = Symbol();
var $getChildren = Symbol();
var $getContainedChildren = Symbol();
var $getNextPage = Symbol();
var $getSubformParent = Symbol();
var $getParent = Symbol();
var $getTemplateRoot = Symbol();
var $globalData = Symbol();
var $hasSettableValue = Symbol();
var $ids = Symbol();
var $indexOf = Symbol();
var $insertAt = Symbol();
var $isCDATAXml = Symbol();
var $isBindable = Symbol();
var $isDataValue = Symbol();
var $isDescendent = Symbol();
var $isNsAgnostic = Symbol();
var $isSplittable = Symbol();
var $isThereMoreWidth = Symbol();
var $isTransparent = Symbol();
var $isUsable = Symbol();
var $lastAttribute = Symbol();
var $namespaceId = Symbol("namespaceId");
var $nodeName = Symbol("nodeName");
var $nsAttributes = Symbol();
var $onChild = Symbol();
var $onChildCheck = Symbol();
var $onText = Symbol();
var $pushGlyphs = Symbol();
var $removeChild = Symbol();
var $root = Symbol("root");
var $resolvePrototypes = Symbol();
var $searchNode = Symbol();
var $setId = Symbol();
var $setSetAttributes = Symbol();
var $setValue = Symbol();
var $tabIndex = Symbol();
var $text = Symbol();
var $toHTML = Symbol();
var $toString = Symbol();
var $toStyle = Symbol();
var $uid = Symbol("uid");
var _applyPrototype = Symbol();
var _attributes = Symbol();
var _attributeNames = Symbol();
var _children = Symbol("_children");
var _cloneAttribute = Symbol();
var _dataValue = Symbol();
var _defaultValue = Symbol();
var _filteredChildrenGenerator = Symbol();
var _getPrototype = Symbol();
var _getUnsetAttributes = Symbol();
var _hasChildren = Symbol();
var _max = Symbol();
var _options = Symbol();
var _parent = Symbol("parent");
var _resolvePrototypesHelper = Symbol();
var _setAttributes = Symbol();
var _validator = Symbol();
var uid = 0;
var NS_DATASETS = NamespaceIds.datasets.id;
var XFAObject = class _XFAObject {
  constructor(nsId, name, hasChildren = false) {
    this[$namespaceId] = nsId;
    this[$nodeName] = name;
    this[_hasChildren] = hasChildren;
    this[_parent] = null;
    this[_children] = [];
    this[$uid] = `${name}${uid++}`;
    this[$globalData] = null;
  }
  [$onChild](child) {
    if (!this[_hasChildren] || !this[$onChildCheck](child)) {
      return false;
    }
    const name = child[$nodeName];
    const node = this[name];
    if (node instanceof XFAObjectArray) {
      if (node.push(child)) {
        this[$appendChild](child);
        return true;
      }
    } else {
      if (node !== null) {
        this[$removeChild](node);
      }
      this[name] = child;
      this[$appendChild](child);
      return true;
    }
    let id = "";
    if (this.id) {
      id = ` (id: ${this.id})`;
    } else if (this.name) {
      id = ` (name: ${this.name} ${this.h.value})`;
    }
    warn(`XFA - node "${this[$nodeName]}"${id} has already enough "${name}"!`);
    return false;
  }
  [$onChildCheck](child) {
    return this.hasOwnProperty(child[$nodeName]) && child[$namespaceId] === this[$namespaceId];
  }
  [$isNsAgnostic]() {
    return false;
  }
  [$acceptWhitespace]() {
    return false;
  }
  [$isCDATAXml]() {
    return false;
  }
  [$isBindable]() {
    return false;
  }
  [$setId](ids) {
    if (this.id && this[$namespaceId] === NamespaceIds.template.id) {
      ids.set(this.id, this);
    }
  }
  [$getTemplateRoot]() {
    return this[$globalData].template;
  }
  [$isSplittable]() {
    return false;
  }
  /**
     Return true if this node (typically a container)
     can provide more width during layout.
     The goal is to help to know what a descendant must
     do in case of horizontal overflow.
   */
  [$isThereMoreWidth]() {
    return false;
  }
  [$appendChild](child) {
    child[_parent] = this;
    this[_children].push(child);
  }
  [$removeChild](child) {
    const i = this[_children].indexOf(child);
    this[_children].splice(i, 1);
  }
  [$hasSettableValue]() {
    return this.hasOwnProperty("value");
  }
  [$setValue](_) {
  }
  [$onText](_) {
  }
  [$finalize]() {
  }
  [$clean](builder) {
    delete this[_hasChildren];
    if (this[$cleanup]) {
      builder.clean(this[$cleanup]);
      delete this[$cleanup];
    }
  }
  [$indexOf](child) {
    return this[_children].indexOf(child);
  }
  [$insertAt](i, child) {
    child[_parent] = this;
    this[_children].splice(i, 0, child);
  }
  /**
   * If true the element is transparent when searching a node using
   * a SOM expression which means that looking for "foo.bar" in
   * <... name="foo"><toto><titi><... name="bar"></titi></toto>...
   * is fine because toto and titi are transparent.
   */
  [$isTransparent]() {
    return !this.name;
  }
  [$lastAttribute]() {
    return "";
  }
  [$text]() {
    if (this[_children].length === 0) {
      return this[$content];
    }
    return this[_children].map((c) => c[$text]()).join("");
  }
  get [_attributeNames]() {
    const proto = Object.getPrototypeOf(this);
    if (!proto._attributes) {
      const attributes = proto._attributes = /* @__PURE__ */ new Set();
      for (const name of Object.getOwnPropertyNames(this)) {
        if (this[name] === null || this[name] instanceof _XFAObject || this[name] instanceof XFAObjectArray) {
          break;
        }
        attributes.add(name);
      }
    }
    return shadow(this, _attributeNames, proto._attributes);
  }
  [$isDescendent](parent) {
    let node = this;
    while (node) {
      if (node === parent) {
        return true;
      }
      node = node[$getParent]();
    }
    return false;
  }
  [$getParent]() {
    return this[_parent];
  }
  [$getSubformParent]() {
    return this[$getParent]();
  }
  [$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }
    return this[name];
  }
  [$dump]() {
    const dumped = /* @__PURE__ */ Object.create(null);
    if (this[$content]) {
      dumped.$content = this[$content];
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      const value = this[name];
      if (value === null) {
        continue;
      }
      if (value instanceof _XFAObject) {
        dumped[name] = value[$dump]();
      } else if (value instanceof XFAObjectArray) {
        if (!value.isEmpty()) {
          dumped[name] = value.dump();
        }
      } else {
        dumped[name] = value;
      }
    }
    return dumped;
  }
  [$toStyle]() {
    return null;
  }
  [$toHTML]() {
    return HTMLResult.EMPTY;
  }
  *[$getContainedChildren]() {
    for (const node of this[$getChildren]()) {
      yield node;
    }
  }
  *[_filteredChildrenGenerator](filter, include) {
    for (const node of this[$getContainedChildren]()) {
      if (!filter || include === filter.has(node[$nodeName])) {
        const availableSpace = this[$getAvailableSpace]();
        const res = node[$toHTML](availableSpace);
        if (!res.success) {
          this[$extra].failingNode = node;
        }
        yield res;
      }
    }
  }
  [$flushHTML]() {
    return null;
  }
  [$addHTML](html, bbox) {
    this[$extra].children.push(html);
  }
  [$getAvailableSpace]() {
  }
  [$childrenToHTML]({
    filter = null,
    include = true
  }) {
    if (!this[$extra].generator) {
      this[$extra].generator = this[_filteredChildrenGenerator](filter, include);
    } else {
      const availableSpace = this[$getAvailableSpace]();
      const res = this[$extra].failingNode[$toHTML](availableSpace);
      if (!res.success) {
        return res;
      }
      if (res.html) {
        this[$addHTML](res.html, res.bbox);
      }
      delete this[$extra].failingNode;
    }
    while (true) {
      const gen = this[$extra].generator.next();
      if (gen.done) {
        break;
      }
      const res = gen.value;
      if (!res.success) {
        return res;
      }
      if (res.html) {
        this[$addHTML](res.html, res.bbox);
      }
    }
    this[$extra].generator = null;
    return HTMLResult.EMPTY;
  }
  [$setSetAttributes](attributes) {
    this[_setAttributes] = new Set(Object.keys(attributes));
  }
  /**
   * Get attribute names which have been set in the proto but not in this.
   */
  [_getUnsetAttributes](protoAttributes) {
    const allAttr = this[_attributeNames];
    const setAttr = this[_setAttributes];
    return [...protoAttributes].filter((x) => allAttr.has(x) && !setAttr.has(x));
  }
  /**
   * Update the node with properties coming from a prototype and apply
   * this function recursivly to all children.
   */
  [$resolvePrototypes](ids, ancestors = /* @__PURE__ */ new Set()) {
    for (const child of this[_children]) {
      child[_resolvePrototypesHelper](ids, ancestors);
    }
  }
  [_resolvePrototypesHelper](ids, ancestors) {
    const proto = this[_getPrototype](ids, ancestors);
    if (proto) {
      this[_applyPrototype](proto, ids, ancestors);
    } else {
      this[$resolvePrototypes](ids, ancestors);
    }
  }
  [_getPrototype](ids, ancestors) {
    const {
      use,
      usehref
    } = this;
    if (!use && !usehref) {
      return null;
    }
    let proto = null;
    let somExpression = null;
    let id = null;
    let ref = use;
    if (usehref) {
      ref = usehref;
      if (usehref.startsWith("#som(") && usehref.endsWith(")")) {
        somExpression = usehref.slice("#som(".length, usehref.length - 1);
      } else if (usehref.startsWith(".#som(") && usehref.endsWith(")")) {
        somExpression = usehref.slice(".#som(".length, usehref.length - 1);
      } else if (usehref.startsWith("#")) {
        id = usehref.slice(1);
      } else if (usehref.startsWith(".#")) {
        id = usehref.slice(2);
      }
    } else if (use.startsWith("#")) {
      id = use.slice(1);
    } else {
      somExpression = use;
    }
    this.use = this.usehref = "";
    if (id) {
      proto = ids.get(id);
    } else {
      proto = searchNode(
        ids.get($root),
        this,
        somExpression,
        true,
        false
        /* = useCache */
      );
      if (proto) {
        proto = proto[0];
      }
    }
    if (!proto) {
      warn(`XFA - Invalid prototype reference: ${ref}.`);
      return null;
    }
    if (proto[$nodeName] !== this[$nodeName]) {
      warn(`XFA - Incompatible prototype: ${proto[$nodeName]} !== ${this[$nodeName]}.`);
      return null;
    }
    if (ancestors.has(proto)) {
      warn(`XFA - Cycle detected in prototypes use.`);
      return null;
    }
    ancestors.add(proto);
    const protoProto = proto[_getPrototype](ids, ancestors);
    if (protoProto) {
      proto[_applyPrototype](protoProto, ids, ancestors);
    }
    proto[$resolvePrototypes](ids, ancestors);
    ancestors.delete(proto);
    return proto;
  }
  [_applyPrototype](proto, ids, ancestors) {
    if (ancestors.has(proto)) {
      warn(`XFA - Cycle detected in prototypes use.`);
      return;
    }
    if (!this[$content] && proto[$content]) {
      this[$content] = proto[$content];
    }
    const newAncestors = new Set(ancestors);
    newAncestors.add(proto);
    for (const unsetAttrName of this[_getUnsetAttributes](proto[_setAttributes])) {
      this[unsetAttrName] = proto[unsetAttrName];
      if (this[_setAttributes]) {
        this[_setAttributes].add(unsetAttrName);
      }
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      if (this[_attributeNames].has(name)) {
        continue;
      }
      const value = this[name];
      const protoValue = proto[name];
      if (value instanceof XFAObjectArray) {
        for (const child of value[_children]) {
          child[_resolvePrototypesHelper](ids, ancestors);
        }
        for (let i = value[_children].length, ii = protoValue[_children].length; i < ii; i++) {
          const child = proto[_children][i][$clone]();
          if (value.push(child)) {
            child[_parent] = this;
            this[_children].push(child);
            child[_resolvePrototypesHelper](ids, ancestors);
          } else {
            break;
          }
        }
        continue;
      }
      if (value !== null) {
        value[$resolvePrototypes](ids, ancestors);
        if (protoValue) {
          value[_applyPrototype](protoValue, ids, ancestors);
        }
        continue;
      }
      if (protoValue !== null) {
        const child = protoValue[$clone]();
        child[_parent] = this;
        this[name] = child;
        this[_children].push(child);
        child[_resolvePrototypesHelper](ids, ancestors);
      }
    }
  }
  static [_cloneAttribute](obj) {
    if (Array.isArray(obj)) {
      return obj.map((x) => _XFAObject[_cloneAttribute](x));
    }
    if (typeof obj === "object" && obj !== null) {
      return Object.assign({}, obj);
    }
    return obj;
  }
  [$clone]() {
    const clone = Object.create(Object.getPrototypeOf(this));
    for (const $symbol of Object.getOwnPropertySymbols(this)) {
      try {
        clone[$symbol] = this[$symbol];
      } catch (_) {
        shadow(clone, $symbol, this[$symbol]);
      }
    }
    clone[$uid] = `${clone[$nodeName]}${uid++}`;
    clone[_children] = [];
    for (const name of Object.getOwnPropertyNames(this)) {
      if (this[_attributeNames].has(name)) {
        clone[name] = _XFAObject[_cloneAttribute](this[name]);
        continue;
      }
      const value = this[name];
      if (value instanceof XFAObjectArray) {
        clone[name] = new XFAObjectArray(value[_max]);
      } else {
        clone[name] = null;
      }
    }
    for (const child of this[_children]) {
      const name = child[$nodeName];
      const clonedChild = child[$clone]();
      clone[_children].push(clonedChild);
      clonedChild[_parent] = clone;
      if (clone[name] === null) {
        clone[name] = clonedChild;
      } else {
        clone[name][_children].push(clonedChild);
      }
    }
    return clone;
  }
  [$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }
    return this[_children].filter((c) => c[$nodeName] === name);
  }
  [$getChildrenByClass](name) {
    return this[name];
  }
  [$getChildrenByName](name, allTransparent, first = true) {
    return Array.from(this[$getChildrenByNameIt](name, allTransparent, first));
  }
  *[$getChildrenByNameIt](name, allTransparent, first = true) {
    if (name === "parent") {
      yield this[_parent];
      return;
    }
    for (const child of this[_children]) {
      if (child[$nodeName] === name) {
        yield child;
      }
      if (child.name === name) {
        yield child;
      }
      if (allTransparent || child[$isTransparent]()) {
        yield* child[$getChildrenByNameIt](name, allTransparent, false);
      }
    }
    if (first && this[_attributeNames].has(name)) {
      yield new XFAAttribute(this, name, this[name]);
    }
  }
};
var XFAObjectArray = class _XFAObjectArray {
  constructor(max = Infinity) {
    this[_max] = max;
    this[_children] = [];
  }
  push(child) {
    const len = this[_children].length;
    if (len <= this[_max]) {
      this[_children].push(child);
      return true;
    }
    warn(`XFA - node "${child[$nodeName]}" accepts no more than ${this[_max]} children`);
    return false;
  }
  isEmpty() {
    return this[_children].length === 0;
  }
  dump() {
    return this[_children].length === 1 ? this[_children][0][$dump]() : this[_children].map((x) => x[$dump]());
  }
  [$clone]() {
    const clone = new _XFAObjectArray(this[_max]);
    clone[_children] = this[_children].map((c) => c[$clone]());
    return clone;
  }
  get children() {
    return this[_children];
  }
  clear() {
    this[_children].length = 0;
  }
};
var XFAAttribute = class {
  constructor(node, name, value) {
    this[_parent] = node;
    this[$nodeName] = name;
    this[$content] = value;
    this[$consumed] = false;
    this[$uid] = `attribute${uid++}`;
  }
  [$getParent]() {
    return this[_parent];
  }
  [$isDataValue]() {
    return true;
  }
  [$getDataValue]() {
    return this[$content].trim();
  }
  [$setValue](value) {
    value = value.value || "";
    this[$content] = value.toString();
  }
  [$text]() {
    return this[$content];
  }
  [$isDescendent](parent) {
    return this[_parent] === parent || this[_parent][$isDescendent](parent);
  }
};
var XmlObject = class _XmlObject extends XFAObject {
  constructor(nsId, name, attributes = {}) {
    super(nsId, name);
    this[$content] = "";
    this[_dataValue] = null;
    if (name !== "#text") {
      const map = /* @__PURE__ */ new Map();
      this[_attributes] = map;
      for (const [attrName, value] of Object.entries(attributes)) {
        map.set(attrName, new XFAAttribute(this, attrName, value));
      }
      if (attributes.hasOwnProperty($nsAttributes)) {
        const dataNode = attributes[$nsAttributes].xfa.dataNode;
        if (dataNode !== void 0) {
          if (dataNode === "dataGroup") {
            this[_dataValue] = false;
          } else if (dataNode === "dataValue") {
            this[_dataValue] = true;
          }
        }
      }
    }
    this[$consumed] = false;
  }
  [$toString](buf) {
    const tagName = this[$nodeName];
    if (tagName === "#text") {
      buf.push(encodeToXmlString(this[$content]));
      return;
    }
    const prefix = this[$namespaceId] === NS_DATASETS ? "xfa:" : "";
    buf.push(`<${prefix}${tagName}`);
    for (const [name, value] of this[_attributes].entries()) {
      buf.push(` ${name}="${encodeToXmlString(value[$content])}"`);
    }
    if (this[_dataValue] !== null) {
      if (this[_dataValue]) {
        buf.push(` xfa:dataNode="dataValue"`);
      } else {
        buf.push(` xfa:dataNode="dataGroup"`);
      }
    }
    if (!this[$content] && this[_children].length === 0) {
      buf.push("/>");
      return;
    }
    buf.push(">");
    if (this[$content]) {
      if (typeof this[$content] === "string") {
        buf.push(encodeToXmlString(this[$content]));
      } else {
        this[$content][$toString](buf);
      }
    } else {
      for (const child of this[_children]) {
        child[$toString](buf);
      }
    }
    buf.push(`</${prefix}${tagName}>`);
  }
  [$onChild](child) {
    if (this[$content]) {
      const node = new _XmlObject(this[$namespaceId], "#text");
      this[$appendChild](node);
      node[$content] = this[$content];
      this[$content] = "";
    }
    this[$appendChild](child);
    return true;
  }
  [$onText](str) {
    this[$content] += str;
  }
  [$finalize]() {
    if (this[$content] && this[_children].length > 0) {
      const node = new _XmlObject(this[$namespaceId], "#text");
      this[$appendChild](node);
      node[$content] = this[$content];
      delete this[$content];
    }
  }
  [$toHTML]() {
    if (this[$nodeName] === "#text") {
      return HTMLResult.success({
        name: "#text",
        value: this[$content]
      });
    }
    return HTMLResult.EMPTY;
  }
  [$getChildren](name = null) {
    if (!name) {
      return this[_children];
    }
    return this[_children].filter((c) => c[$nodeName] === name);
  }
  [$getAttributes]() {
    return this[_attributes];
  }
  [$getChildrenByClass](name) {
    const value = this[_attributes].get(name);
    if (value !== void 0) {
      return value;
    }
    return this[$getChildren](name);
  }
  *[$getChildrenByNameIt](name, allTransparent) {
    const value = this[_attributes].get(name);
    if (value) {
      yield value;
    }
    for (const child of this[_children]) {
      if (child[$nodeName] === name) {
        yield child;
      }
      if (allTransparent) {
        yield* child[$getChildrenByNameIt](name, allTransparent);
      }
    }
  }
  *[$getAttributeIt](name, skipConsumed) {
    const value = this[_attributes].get(name);
    if (value && (!skipConsumed || !value[$consumed])) {
      yield value;
    }
    for (const child of this[_children]) {
      yield* child[$getAttributeIt](name, skipConsumed);
    }
  }
  *[$getRealChildrenByNameIt](name, allTransparent, skipConsumed) {
    for (const child of this[_children]) {
      if (child[$nodeName] === name && (!skipConsumed || !child[$consumed])) {
        yield child;
      }
      if (allTransparent) {
        yield* child[$getRealChildrenByNameIt](name, allTransparent, skipConsumed);
      }
    }
  }
  [$isDataValue]() {
    if (this[_dataValue] === null) {
      return this[_children].length === 0 || this[_children][0][$namespaceId] === NamespaceIds.xhtml.id;
    }
    return this[_dataValue];
  }
  [$getDataValue]() {
    if (this[_dataValue] === null) {
      if (this[_children].length === 0) {
        return this[$content].trim();
      }
      if (this[_children][0][$namespaceId] === NamespaceIds.xhtml.id) {
        return this[_children][0][$text]().trim();
      }
      return null;
    }
    return this[$content].trim();
  }
  [$setValue](value) {
    value = value.value || "";
    this[$content] = value.toString();
  }
  [$dump]() {
    const dumped = /* @__PURE__ */ Object.create(null);
    if (this[$content]) {
      dumped.$content = this[$content];
    }
    dumped.$name = this[$nodeName];
    dumped.children = [];
    for (const child of this[_children]) {
      dumped.children.push(child[$dump]());
    }
    dumped.attributes = /* @__PURE__ */ Object.create(null);
    for (const [name, value] of this[_attributes]) {
      dumped.attributes[name] = value[$content];
    }
    return dumped;
  }
};
var ContentObject = class extends XFAObject {
  constructor(nsId, name) {
    super(nsId, name);
    this[$content] = "";
  }
  [$onText](text) {
    this[$content] += text;
  }
  [$finalize]() {
  }
};
var OptionObject = class extends ContentObject {
  constructor(nsId, name, options) {
    super(nsId, name);
    this[_options] = options;
  }
  [$finalize]() {
    this[$content] = getKeyword({
      data: this[$content],
      defaultValue: this[_options][0],
      validate: (k) => this[_options].includes(k)
    });
  }
  [$clean](builder) {
    super[$clean](builder);
    delete this[_options];
  }
};
var StringObject = class extends ContentObject {
  [$finalize]() {
    this[$content] = this[$content].trim();
  }
};
var IntegerObject = class extends ContentObject {
  constructor(nsId, name, defaultValue, validator) {
    super(nsId, name);
    this[_defaultValue] = defaultValue;
    this[_validator] = validator;
  }
  [$finalize]() {
    this[$content] = getInteger({
      data: this[$content],
      defaultValue: this[_defaultValue],
      validate: this[_validator]
    });
  }
  [$clean](builder) {
    super[$clean](builder);
    delete this[_defaultValue];
    delete this[_validator];
  }
};
var Option01 = class extends IntegerObject {
  constructor(nsId, name) {
    super(nsId, name, 0, (n) => n === 1);
  }
};
var Option10 = class extends IntegerObject {
  constructor(nsId, name) {
    super(nsId, name, 1, (n) => n === 0);
  }
};
var FontFinder = class {
  constructor(pdfFonts) {
    this.fonts = /* @__PURE__ */ new Map();
    this.cache = /* @__PURE__ */ new Map();
    this.warned = /* @__PURE__ */ new Set();
    this.defaultFont = null;
    this.add(pdfFonts);
  }
  add(pdfFonts, reallyMissingFonts = null) {
    for (const pdfFont of pdfFonts) {
      this.addPdfFont(pdfFont);
    }
    for (const pdfFont of this.fonts.values()) {
      if (!pdfFont.regular) {
        pdfFont.regular = pdfFont.italic || pdfFont.bold || pdfFont.bolditalic;
      }
    }
    if (!reallyMissingFonts || reallyMissingFonts.size === 0) {
      return;
    }
    const myriad = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const missing of reallyMissingFonts) {
      this.fonts.set(missing, myriad);
    }
  }
  addPdfFont(pdfFont) {
    const cssFontInfo = pdfFont.cssFontInfo;
    const name = cssFontInfo.fontFamily;
    let font = this.fonts.get(name);
    if (!font) {
      font = /* @__PURE__ */ Object.create(null);
      this.fonts.set(name, font);
      if (!this.defaultFont) {
        this.defaultFont = font;
      }
    }
    let property = "";
    const fontWeight = parseFloat(cssFontInfo.fontWeight);
    if (parseFloat(cssFontInfo.italicAngle) !== 0) {
      property = fontWeight >= 700 ? "bolditalic" : "italic";
    } else if (fontWeight >= 700) {
      property = "bold";
    }
    if (!property) {
      if (pdfFont.name.includes("Bold") || pdfFont.psName && pdfFont.psName.includes("Bold")) {
        property = "bold";
      }
      if (pdfFont.name.includes("Italic") || pdfFont.name.endsWith("It") || pdfFont.psName && (pdfFont.psName.includes("Italic") || pdfFont.psName.endsWith("It"))) {
        property += "italic";
      }
    }
    if (!property) {
      property = "regular";
    }
    font[property] = pdfFont;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(fontName, mustWarn = true) {
    let font = this.fonts.get(fontName) || this.cache.get(fontName);
    if (font) {
      return font;
    }
    const pattern = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let name = fontName.replace(pattern, "");
    font = this.fonts.get(name);
    if (font) {
      this.cache.set(fontName, font);
      return font;
    }
    name = name.toLowerCase();
    const maybe = [];
    for (const [family, pdfFont] of this.fonts.entries()) {
      if (family.replace(pattern, "").toLowerCase().startsWith(name)) {
        maybe.push(pdfFont);
      }
    }
    if (maybe.length === 0) {
      for (const [, pdfFont] of this.fonts.entries()) {
        if (pdfFont.regular.name && pdfFont.regular.name.replace(pattern, "").toLowerCase().startsWith(name)) {
          maybe.push(pdfFont);
        }
      }
    }
    if (maybe.length === 0) {
      name = name.replace(/psmt|mt/gi, "");
      for (const [family, pdfFont] of this.fonts.entries()) {
        if (family.replace(pattern, "").toLowerCase().startsWith(name)) {
          maybe.push(pdfFont);
        }
      }
    }
    if (maybe.length === 0) {
      for (const pdfFont of this.fonts.values()) {
        if (pdfFont.regular.name && pdfFont.regular.name.replace(pattern, "").toLowerCase().startsWith(name)) {
          maybe.push(pdfFont);
        }
      }
    }
    if (maybe.length >= 1) {
      if (maybe.length !== 1 && mustWarn) {
        warn(`XFA - Too many choices to guess the correct font: ${fontName}`);
      }
      this.cache.set(fontName, maybe[0]);
      return maybe[0];
    }
    if (mustWarn && !this.warned.has(fontName)) {
      this.warned.add(fontName);
      warn(`XFA - Cannot find the font: ${fontName}`);
    }
    return null;
  }
};
function selectFont(xfaFont, typeface) {
  if (xfaFont.posture === "italic") {
    if (xfaFont.weight === "bold") {
      return typeface.bolditalic;
    }
    return typeface.italic;
  } else if (xfaFont.weight === "bold") {
    return typeface.bold;
  }
  return typeface.regular;
}
var WIDTH_FACTOR = 1.01;
var FontInfo$1 = class {
  constructor(xfaFont, margin, lineHeight, fontFinder) {
    this.lineHeight = lineHeight;
    this.paraMargin = margin || {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    if (!xfaFont) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
      return;
    }
    this.xfaFont = {
      typeface: xfaFont.typeface,
      posture: xfaFont.posture,
      weight: xfaFont.weight,
      size: xfaFont.size,
      letterSpacing: xfaFont.letterSpacing
    };
    const typeface = fontFinder.find(xfaFont.typeface);
    if (!typeface) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
      return;
    }
    this.pdfFont = selectFont(xfaFont, typeface);
    if (!this.pdfFont) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(fontFinder);
    }
  }
  defaultFont(fontFinder) {
    const font = fontFinder.find("Helvetica", false) || fontFinder.find("Myriad Pro", false) || fontFinder.find("Arial", false) || fontFinder.getDefault();
    if (font && font.regular) {
      const pdfFont = font.regular;
      const info2 = pdfFont.cssFontInfo;
      const xfaFont2 = {
        typeface: info2.fontFamily,
        posture: "normal",
        weight: "normal",
        size: 10,
        letterSpacing: 0
      };
      return [pdfFont, xfaFont2];
    }
    const xfaFont = {
      typeface: "Courier",
      posture: "normal",
      weight: "normal",
      size: 10,
      letterSpacing: 0
    };
    return [null, xfaFont];
  }
};
var FontSelector = class {
  constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder) {
    this.fontFinder = fontFinder;
    this.stack = [new FontInfo$1(defaultXfaFont, defaultParaMargin, defaultLineHeight, fontFinder)];
  }
  pushData(xfaFont, margin, lineHeight) {
    const lastFont = this.stack[this.stack.length - 1];
    for (const name of ["typeface", "posture", "weight", "size", "letterSpacing"]) {
      if (!xfaFont[name]) {
        xfaFont[name] = lastFont.xfaFont[name];
      }
    }
    for (const name of ["top", "bottom", "left", "right"]) {
      if (isNaN(margin[name])) {
        margin[name] = lastFont.paraMargin[name];
      }
    }
    const fontInfo = new FontInfo$1(xfaFont, margin, lineHeight || lastFont.lineHeight, this.fontFinder);
    if (!fontInfo.pdfFont) {
      fontInfo.pdfFont = lastFont.pdfFont;
    }
    this.stack.push(fontInfo);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack[this.stack.length - 1];
  }
};
var TextMeasure = class {
  constructor(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts) {
    this.glyphs = [];
    this.fontSelector = new FontSelector(defaultXfaFont, defaultParaMargin, defaultLineHeight, fonts);
    this.extraHeight = 0;
  }
  pushData(xfaFont, margin, lineHeight) {
    this.fontSelector.pushData(xfaFont, margin, lineHeight);
  }
  popFont(xfaFont) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const lastFont = this.fontSelector.topFont();
    this.extraHeight += lastFont.paraMargin.top + lastFont.paraMargin.bottom;
  }
  addString(str) {
    if (!str) {
      return;
    }
    const lastFont = this.fontSelector.topFont();
    const fontSize = lastFont.xfaFont.size;
    if (lastFont.pdfFont) {
      const letterSpacing = lastFont.xfaFont.letterSpacing;
      const pdfFont = lastFont.pdfFont;
      const lineHeight = lastFont.lineHeight || Math.ceil(Math.max(1.2, pdfFont.lineHeight) * fontSize);
      const scale = fontSize / 1e3;
      for (const line of str.split(/[\u2029\n]/)) {
        const encodedLine = pdfFont.encodeString(line).join("");
        const glyphs = pdfFont.charsToGlyphs(encodedLine);
        for (const glyph of glyphs) {
          this.glyphs.push([glyph.width * scale + letterSpacing, lineHeight, glyph.unicode === " ", false]);
        }
        this.glyphs.push([0, 0, false, true]);
      }
      this.glyphs.pop();
      return;
    }
    for (const line of str.split(/[\u2029\n]/)) {
      for (const char of line.split("")) {
        this.glyphs.push([fontSize, fontSize, char === " ", false]);
      }
      this.glyphs.push([0, 0, false, true]);
    }
    this.glyphs.pop();
  }
  compute(maxWidth) {
    let lastSpacePos = -1, lastSpaceWidth = 0, width = 0, height = 0, currentLineWidth = 0, currentLineHeight = 0;
    let isBroken = false;
    for (let i = 0, ii = this.glyphs.length; i < ii; i++) {
      const [glyphWidth, glyphHeight, isSpace, isEOL] = this.glyphs[i];
      if (isEOL) {
        width = Math.max(width, currentLineWidth);
        currentLineWidth = 0;
        height += currentLineHeight;
        currentLineHeight = glyphHeight;
        lastSpacePos = -1;
        lastSpaceWidth = 0;
        continue;
      }
      if (isSpace) {
        if (currentLineWidth + glyphWidth > maxWidth) {
          width = Math.max(width, currentLineWidth);
          currentLineWidth = 0;
          height += currentLineHeight;
          currentLineHeight = glyphHeight;
          lastSpacePos = -1;
          lastSpaceWidth = 0;
          isBroken = true;
        } else {
          currentLineHeight = Math.max(glyphHeight, currentLineHeight);
          lastSpaceWidth = currentLineWidth;
          currentLineWidth += glyphWidth;
          lastSpacePos = i;
        }
        continue;
      }
      if (currentLineWidth + glyphWidth > maxWidth) {
        height += currentLineHeight;
        currentLineHeight = glyphHeight;
        if (lastSpacePos !== -1) {
          i = lastSpacePos;
          width = Math.max(width, lastSpaceWidth);
          currentLineWidth = 0;
          lastSpacePos = -1;
          lastSpaceWidth = 0;
        } else {
          width = Math.max(width, currentLineWidth);
          currentLineWidth = glyphWidth;
        }
        isBroken = true;
        continue;
      }
      currentLineWidth += glyphWidth;
      currentLineHeight = Math.max(glyphHeight, currentLineHeight);
    }
    width = Math.max(width, currentLineWidth);
    height += currentLineHeight + this.extraHeight;
    return {
      width: WIDTH_FACTOR * width,
      height,
      isBroken
    };
  }
};
function measureToString(m) {
  if (typeof m === "string") {
    return "0px";
  }
  return Number.isInteger(m) ? `${m}px` : `${m.toFixed(2)}px`;
}
var converters = {
  anchorType(node, style) {
    const parent = node[$getSubformParent]();
    if (!parent || parent.layout && parent.layout !== "position") {
      return;
    }
    if (!("transform" in style)) {
      style.transform = "";
    }
    switch (node.anchorType) {
      case "bottomCenter":
        style.transform += "translate(-50%, -100%)";
        break;
      case "bottomLeft":
        style.transform += "translate(0,-100%)";
        break;
      case "bottomRight":
        style.transform += "translate(-100%,-100%)";
        break;
      case "middleCenter":
        style.transform += "translate(-50%,-50%)";
        break;
      case "middleLeft":
        style.transform += "translate(0,-50%)";
        break;
      case "middleRight":
        style.transform += "translate(-100%,-50%)";
        break;
      case "topCenter":
        style.transform += "translate(-50%,0)";
        break;
      case "topRight":
        style.transform += "translate(-100%,0)";
        break;
    }
  },
  dimensions(node, style) {
    const parent = node[$getSubformParent]();
    let width = node.w;
    const height = node.h;
    if (parent.layout && parent.layout.includes("row")) {
      const extra = parent[$extra];
      const colSpan = node.colSpan;
      let w;
      if (colSpan === -1) {
        w = extra.columnWidths.slice(extra.currentColumn).reduce((a, x) => a + x, 0);
        extra.currentColumn = 0;
      } else {
        w = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, x) => a + x, 0);
        extra.currentColumn = (extra.currentColumn + node.colSpan) % extra.columnWidths.length;
      }
      if (!isNaN(w)) {
        width = node.w = w;
      }
    }
    if (width !== "") {
      style.width = measureToString(width);
    } else {
      style.width = "auto";
    }
    if (height !== "") {
      style.height = measureToString(height);
    } else {
      style.height = "auto";
    }
  },
  position(node, style) {
    const parent = node[$getSubformParent]();
    if (parent && parent.layout && parent.layout !== "position") {
      return;
    }
    style.position = "absolute";
    style.left = measureToString(node.x);
    style.top = measureToString(node.y);
  },
  rotate(node, style) {
    if (node.rotate) {
      if (!("transform" in style)) {
        style.transform = "";
      }
      style.transform += `rotate(-${node.rotate}deg)`;
      style.transformOrigin = "top left";
    }
  },
  presence(node, style) {
    switch (node.presence) {
      case "invisible":
        style.visibility = "hidden";
        break;
      case "hidden":
      case "inactive":
        style.display = "none";
        break;
    }
  },
  hAlign(node, style) {
    if (node[$nodeName] === "para") {
      switch (node.hAlign) {
        case "justifyAll":
          style.textAlign = "justify-all";
          break;
        case "radix":
          style.textAlign = "left";
          break;
        default:
          style.textAlign = node.hAlign;
      }
    } else {
      switch (node.hAlign) {
        case "left":
          style.alignSelf = "start";
          break;
        case "center":
          style.alignSelf = "center";
          break;
        case "right":
          style.alignSelf = "end";
          break;
      }
    }
  },
  margin(node, style) {
    if (node.margin) {
      style.margin = node.margin[$toStyle]().margin;
    }
  }
};
function setMinMaxDimensions(node, style) {
  const parent = node[$getSubformParent]();
  if (parent.layout === "position") {
    if (node.minW > 0) {
      style.minWidth = measureToString(node.minW);
    }
    if (node.maxW > 0) {
      style.maxWidth = measureToString(node.maxW);
    }
    if (node.minH > 0) {
      style.minHeight = measureToString(node.minH);
    }
    if (node.maxH > 0) {
      style.maxHeight = measureToString(node.maxH);
    }
  }
}
function layoutText(text, xfaFont, margin, lineHeight, fontFinder, width) {
  const measure = new TextMeasure(xfaFont, margin, lineHeight, fontFinder);
  if (typeof text === "string") {
    measure.addString(text);
  } else {
    text[$pushGlyphs](measure);
  }
  return measure.compute(width);
}
function layoutNode(node, availableSpace) {
  let height = null;
  let width = null;
  let isBroken = false;
  if ((!node.w || !node.h) && node.value) {
    let marginH = 0;
    let marginV = 0;
    if (node.margin) {
      marginH = node.margin.leftInset + node.margin.rightInset;
      marginV = node.margin.topInset + node.margin.bottomInset;
    }
    let lineHeight = null;
    let margin = null;
    if (node.para) {
      margin = /* @__PURE__ */ Object.create(null);
      lineHeight = node.para.lineHeight === "" ? null : node.para.lineHeight;
      margin.top = node.para.spaceAbove === "" ? 0 : node.para.spaceAbove;
      margin.bottom = node.para.spaceBelow === "" ? 0 : node.para.spaceBelow;
      margin.left = node.para.marginLeft === "" ? 0 : node.para.marginLeft;
      margin.right = node.para.marginRight === "" ? 0 : node.para.marginRight;
    }
    let font = node.font;
    if (!font) {
      const root = node[$getTemplateRoot]();
      let parent = node[$getParent]();
      while (parent !== root) {
        if (parent.font) {
          font = parent.font;
          break;
        }
        parent = parent[$getParent]();
      }
    }
    const maxWidth = !node.w ? availableSpace.width : node.w;
    const fontFinder = node[$globalData].fontFinder;
    if (node.value.exData && node.value.exData[$content] && node.value.exData.contentType === "text/html") {
      const res = layoutText(node.value.exData[$content], font, margin, lineHeight, fontFinder, maxWidth);
      width = res.width;
      height = res.height;
      isBroken = res.isBroken;
    } else {
      const text = node.value[$text]();
      if (text) {
        const res = layoutText(text, font, margin, lineHeight, fontFinder, maxWidth);
        width = res.width;
        height = res.height;
        isBroken = res.isBroken;
      }
    }
    if (width !== null && !node.w) {
      width += marginH;
    }
    if (height !== null && !node.h) {
      height += marginV;
    }
  }
  return {
    w: width,
    h: height,
    isBroken
  };
}
function computeBbox(node, html, availableSpace) {
  let bbox;
  if (node.w !== "" && node.h !== "") {
    bbox = [node.x, node.y, node.w, node.h];
  } else {
    if (!availableSpace) {
      return null;
    }
    let width = node.w;
    if (width === "") {
      if (node.maxW === 0) {
        const parent = node[$getSubformParent]();
        if (parent.layout === "position" && parent.w !== "") {
          width = 0;
        } else {
          width = node.minW;
        }
      } else {
        width = Math.min(node.maxW, availableSpace.width);
      }
      html.attributes.style.width = measureToString(width);
    }
    let height = node.h;
    if (height === "") {
      if (node.maxH === 0) {
        const parent = node[$getSubformParent]();
        if (parent.layout === "position" && parent.h !== "") {
          height = 0;
        } else {
          height = node.minH;
        }
      } else {
        height = Math.min(node.maxH, availableSpace.height);
      }
      html.attributes.style.height = measureToString(height);
    }
    bbox = [node.x, node.y, width, height];
  }
  return bbox;
}
function fixDimensions(node) {
  const parent = node[$getSubformParent]();
  if (parent.layout && parent.layout.includes("row")) {
    const extra = parent[$extra];
    const colSpan = node.colSpan;
    let width;
    if (colSpan === -1) {
      width = extra.columnWidths.slice(extra.currentColumn).reduce((a, w) => a + w, 0);
    } else {
      width = extra.columnWidths.slice(extra.currentColumn, extra.currentColumn + colSpan).reduce((a, w) => a + w, 0);
    }
    if (!isNaN(width)) {
      node.w = width;
    }
  }
  if (parent.layout && parent.layout !== "position") {
    node.x = node.y = 0;
  }
  if (node.layout === "table") {
    if (node.w === "" && Array.isArray(node.columnWidths)) {
      node.w = node.columnWidths.reduce((a, x) => a + x, 0);
    }
  }
}
function layoutClass(node) {
  switch (node.layout) {
    case "position":
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
    default:
      return "xfaPosition";
  }
}
function toStyle(node, ...names) {
  const style = /* @__PURE__ */ Object.create(null);
  for (const name of names) {
    const value = node[name];
    if (value === null) {
      continue;
    }
    if (converters.hasOwnProperty(name)) {
      converters[name](node, style);
      continue;
    }
    if (value instanceof XFAObject) {
      const newStyle = value[$toStyle]();
      if (newStyle) {
        Object.assign(style, newStyle);
      } else {
        warn(`(DEBUG) - XFA - style for ${name} not implemented yet`);
      }
    }
  }
  return style;
}
function createWrapper(node, html) {
  const {
    attributes
  } = html;
  const {
    style
  } = attributes;
  const wrapper = {
    name: "div",
    attributes: {
      class: ["xfaWrapper"],
      style: /* @__PURE__ */ Object.create(null)
    },
    children: []
  };
  attributes.class.push("xfaWrapped");
  if (node.border) {
    const {
      widths,
      insets
    } = node.border[$extra];
    let width, height;
    let top = insets[0];
    let left = insets[3];
    const insetsH = insets[0] + insets[2];
    const insetsW = insets[1] + insets[3];
    switch (node.border.hand) {
      case "even":
        top -= widths[0] / 2;
        left -= widths[3] / 2;
        width = `calc(100% + ${(widths[1] + widths[3]) / 2 - insetsW}px)`;
        height = `calc(100% + ${(widths[0] + widths[2]) / 2 - insetsH}px)`;
        break;
      case "left":
        top -= widths[0];
        left -= widths[3];
        width = `calc(100% + ${widths[1] + widths[3] - insetsW}px)`;
        height = `calc(100% + ${widths[0] + widths[2] - insetsH}px)`;
        break;
      case "right":
        width = insetsW ? `calc(100% - ${insetsW}px)` : "100%";
        height = insetsH ? `calc(100% - ${insetsH}px)` : "100%";
        break;
    }
    const classNames = ["xfaBorder"];
    if (isPrintOnly(node.border)) {
      classNames.push("xfaPrintOnly");
    }
    const border = {
      name: "div",
      attributes: {
        class: classNames,
        style: {
          top: `${top}px`,
          left: `${left}px`,
          width,
          height
        }
      },
      children: []
    };
    for (const key of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) {
      if (style[key] !== void 0) {
        border.attributes.style[key] = style[key];
        delete style[key];
      }
    }
    wrapper.children.push(border, html);
  } else {
    wrapper.children.push(html);
  }
  for (const key of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) {
    if (style[key] !== void 0) {
      wrapper.attributes.style[key] = style[key];
      delete style[key];
    }
  }
  if (style.position === "absolute") {
    wrapper.attributes.style.position = "absolute";
  } else {
    wrapper.attributes.style.position = "relative";
  }
  delete style.position;
  if (style.alignSelf) {
    wrapper.attributes.style.alignSelf = style.alignSelf;
    delete style.alignSelf;
  }
  return wrapper;
}
function fixTextIndent(styles) {
  const indent = getMeasurement(styles.textIndent, "0px");
  if (indent >= 0) {
    return;
  }
  const align = styles.textAlign === "right" ? "right" : "left";
  const name = "padding" + (align === "left" ? "Left" : "Right");
  const padding = getMeasurement(styles[name], "0px");
  styles[name] = `${padding - indent}px`;
}
function setAccess(node, classNames) {
  switch (node.access) {
    case "nonInteractive":
      classNames.push("xfaNonInteractive");
      break;
    case "readOnly":
      classNames.push("xfaReadOnly");
      break;
    case "protected":
      classNames.push("xfaDisabled");
      break;
  }
}
function isPrintOnly(node) {
  return node.relevant.length > 0 && !node.relevant[0].excluded && node.relevant[0].viewname === "print";
}
function setPara(node, nodeStyle, value) {
  if (value.attributes.class && value.attributes.class.includes("xfaRich")) {
    if (nodeStyle) {
      if (node.h === "") {
        nodeStyle.height = "auto";
      }
      if (node.w === "") {
        nodeStyle.width = "auto";
      }
    }
    if (node.para) {
      const valueStyle = value.attributes.style;
      valueStyle.display = "flex";
      valueStyle.flexDirection = "column";
      switch (node.para.vAlign) {
        case "top":
          valueStyle.justifyContent = "start";
          break;
        case "bottom":
          valueStyle.justifyContent = "end";
          break;
        case "middle":
          valueStyle.justifyContent = "center";
          break;
      }
      const paraStyle = node.para[$toStyle]();
      for (const [key, val] of Object.entries(paraStyle)) {
        if (!(key in valueStyle)) {
          valueStyle[key] = val;
        }
      }
    }
  }
}
function setFontFamily(xfaFont, fontFinder, style) {
  const name = stripQuotes(xfaFont.typeface);
  const typeface = fontFinder.find(name);
  style.fontFamily = `"${name}"`;
  if (typeface) {
    const {
      fontFamily
    } = typeface.regular.cssFontInfo;
    if (fontFamily !== name) {
      style.fontFamily = `"${fontFamily}"`;
    }
    if (style.lineHeight) {
      return;
    }
    const pdfFont = selectFont(xfaFont, typeface);
    if (pdfFont && pdfFont.lineHeight > 0) {
      style.lineHeight = Math.max(1.2, pdfFont.lineHeight);
    } else {
      style.lineHeight = 1.2;
    }
  }
}
function createLine(node, children) {
  return {
    name: "div",
    attributes: {
      class: [node.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
    },
    children
  };
}
function flushHTML(node) {
  if (!node[$extra]) {
    return null;
  }
  const attributes = node[$extra].attributes;
  const html = {
    name: "div",
    attributes,
    children: node[$extra].children
  };
  if (node[$extra].failingNode) {
    const htmlFromFailing = node[$extra].failingNode[$flushHTML]();
    if (htmlFromFailing) {
      if (node.layout.endsWith("-tb")) {
        html.children.push(createLine(node, [htmlFromFailing]));
      } else {
        html.children.push(htmlFromFailing);
      }
    }
  }
  if (html.children.length === 0) {
    return null;
  }
  return html;
}
function addHTML(node, html, bbox) {
  const extra = node[$extra];
  const availableSpace = extra.availableSpace;
  const [x, y, w, h] = bbox;
  switch (node.layout) {
    case "position": {
      extra.width = Math.max(extra.width, x + w);
      extra.height = Math.max(extra.height, y + h);
      extra.children.push(html);
      break;
    }
    case "lr-tb":
    case "rl-tb":
      if (!extra.line || extra.attempt === 1) {
        extra.line = createLine(node, []);
        extra.children.push(extra.line);
        extra.numberInLine = 0;
      }
      extra.numberInLine += 1;
      extra.line.children.push(html);
      if (extra.attempt === 0) {
        extra.currentWidth += w;
        extra.height = Math.max(extra.height, extra.prevHeight + h);
      } else {
        extra.currentWidth = w;
        extra.prevHeight = extra.height;
        extra.height += h;
        extra.attempt = 0;
      }
      extra.width = Math.max(extra.width, extra.currentWidth);
      break;
    case "rl-row":
    case "row": {
      extra.children.push(html);
      extra.width += w;
      extra.height = Math.max(extra.height, h);
      const height = measureToString(extra.height);
      for (const child of extra.children) {
        child.attributes.style.height = height;
      }
      break;
    }
    case "table": {
      extra.width = Math.min(availableSpace.width, Math.max(extra.width, w));
      extra.height += h;
      extra.children.push(html);
      break;
    }
    case "tb": {
      extra.width = availableSpace.width;
      extra.height += h;
      extra.children.push(html);
      break;
    }
  }
}
function getAvailableSpace(node) {
  const availableSpace = node[$extra].availableSpace;
  const marginV = node.margin ? node.margin.topInset + node.margin.bottomInset : 0;
  const marginH = node.margin ? node.margin.leftInset + node.margin.rightInset : 0;
  switch (node.layout) {
    case "lr-tb":
    case "rl-tb":
      if (node[$extra].attempt === 0) {
        return {
          width: availableSpace.width - marginH - node[$extra].currentWidth,
          height: availableSpace.height - marginV - node[$extra].prevHeight
        };
      }
      return {
        width: availableSpace.width - marginH,
        height: availableSpace.height - marginV - node[$extra].height
      };
    case "rl-row":
    case "row":
      const width = node[$extra].columnWidths.slice(node[$extra].currentColumn).reduce((a, x) => a + x);
      return {
        width,
        height: availableSpace.height - marginH
      };
    case "table":
    case "tb":
      return {
        width: availableSpace.width - marginH,
        height: availableSpace.height - marginV - node[$extra].height
      };
    case "position":
    default:
      return availableSpace;
  }
}
function getTransformedBBox(node) {
  let w = node.w === "" ? NaN : node.w;
  let h = node.h === "" ? NaN : node.h;
  let [centerX, centerY] = [0, 0];
  switch (node.anchorType || "") {
    case "bottomCenter":
      [centerX, centerY] = [w / 2, h];
      break;
    case "bottomLeft":
      [centerX, centerY] = [0, h];
      break;
    case "bottomRight":
      [centerX, centerY] = [w, h];
      break;
    case "middleCenter":
      [centerX, centerY] = [w / 2, h / 2];
      break;
    case "middleLeft":
      [centerX, centerY] = [0, h / 2];
      break;
    case "middleRight":
      [centerX, centerY] = [w, h / 2];
      break;
    case "topCenter":
      [centerX, centerY] = [w / 2, 0];
      break;
    case "topRight":
      [centerX, centerY] = [w, 0];
      break;
  }
  let x, y;
  switch (node.rotate || 0) {
    case 0:
      [x, y] = [-centerX, -centerY];
      break;
    case 90:
      [x, y] = [-centerY, centerX];
      [w, h] = [h, -w];
      break;
    case 180:
      [x, y] = [centerX, centerY];
      [w, h] = [-w, -h];
      break;
    case 270:
      [x, y] = [centerY, -centerX];
      [w, h] = [-h, w];
      break;
  }
  return [node.x + x + Math.min(0, w), node.y + y + Math.min(0, h), Math.abs(w), Math.abs(h)];
}
function checkDimensions(node, space) {
  if (node[$getTemplateRoot]()[$extra].firstUnsplittable === null) {
    return true;
  }
  if (node.w === 0 || node.h === 0) {
    return true;
  }
  const ERROR = 2;
  const parent = node[$getSubformParent]();
  const attempt = parent[$extra] && parent[$extra].attempt || 0;
  const [, y, w, h] = getTransformedBBox(node);
  switch (parent.layout) {
    case "lr-tb":
    case "rl-tb":
      if (attempt === 0) {
        if (!node[$getTemplateRoot]()[$extra].noLayoutFailure) {
          if (node.h !== "" && Math.round(h - space.height) > ERROR) {
            return false;
          }
          if (node.w !== "") {
            if (Math.round(w - space.width) <= ERROR) {
              return true;
            }
            if (parent[$extra].numberInLine === 0) {
              return space.height > 0;
            }
            return false;
          }
          return space.width > 0;
        }
        if (node.w !== "") {
          return Math.round(w - space.width) <= ERROR;
        }
        return space.width > 0;
      }
      if (node[$getTemplateRoot]()[$extra].noLayoutFailure) {
        return true;
      }
      if (node.h !== "" && Math.round(h - space.height) > ERROR) {
        return false;
      }
      if (node.w === "" || Math.round(w - space.width) <= ERROR) {
        return space.height > 0;
      }
      if (parent[$isThereMoreWidth]()) {
        return false;
      }
      return space.height > 0;
    case "table":
    case "tb":
      if (node[$getTemplateRoot]()[$extra].noLayoutFailure) {
        return true;
      }
      if (node.h !== "" && !node[$isSplittable]()) {
        return Math.round(h - space.height) <= ERROR;
      }
      if (node.w === "" || Math.round(w - space.width) <= ERROR) {
        return space.height > 0;
      }
      if (parent[$isThereMoreWidth]()) {
        return false;
      }
      return space.height > 0;
    case "position":
      if (node[$getTemplateRoot]()[$extra].noLayoutFailure) {
        return true;
      }
      if (node.h === "" || Math.round(h + y - space.height) <= ERROR) {
        return true;
      }
      const area = node[$getTemplateRoot]()[$extra].currentContentArea;
      return h + y > area.h;
    case "rl-row":
    case "row":
      if (node[$getTemplateRoot]()[$extra].noLayoutFailure) {
        return true;
      }
      if (node.h !== "") {
        return Math.round(h - space.height) <= ERROR;
      }
      return true;
    default:
      return true;
  }
}
var TEMPLATE_NS_ID = NamespaceIds.template.id;
var SVG_NS = "http://www.w3.org/2000/svg";
var MAX_ATTEMPTS_FOR_LRTB_LAYOUT = 2;
var MAX_EMPTY_PAGES = 3;
function hasMargin(node) {
  return node.margin && (node.margin.topInset || node.margin.rightInset || node.margin.bottomInset || node.margin.leftInset);
}
function _setValue(templateNode, value) {
  if (!templateNode.value) {
    const nodeValue = new Value({});
    templateNode[$appendChild](nodeValue);
    templateNode.value = nodeValue;
  }
  templateNode.value[$setValue](value);
}
function* getContainedChildren(node) {
  for (const child of node[$getChildren]()) {
    if (child instanceof SubformSet) {
      yield* child[$getContainedChildren]();
      continue;
    }
    yield child;
  }
}
function setTabIndex(node) {
  while (node) {
    if (!node.traversal || node[$tabIndex]) {
      return;
    }
    let next = null;
    for (const child of node.traversal[$getChildren]()) {
      if (child.operation === "next") {
        next = child;
        break;
      }
    }
    if (!next || !next.ref) {
      return;
    }
    const root = node[$getTemplateRoot]();
    node[$tabIndex] = ++root[$tabIndex];
    const ref = root[$searchNode](next.ref, node);
    if (!ref) {
      return;
    }
    node = ref[0];
  }
}
function valueToHtml(value) {
  return HTMLResult.success({
    name: "div",
    attributes: {
      class: ["xfaRich"],
      style: /* @__PURE__ */ Object.create(null)
    },
    children: [{
      name: "span",
      attributes: {
        style: /* @__PURE__ */ Object.create(null)
      },
      value
    }]
  });
}
function setFirstUnsplittable(node) {
  const root = node[$getTemplateRoot]();
  if (root[$extra].firstUnsplittable === null) {
    root[$extra].firstUnsplittable = node;
    root[$extra].noLayoutFailure = true;
  }
}
function unsetFirstUnsplittable(node) {
  const root = node[$getTemplateRoot]();
  if (root[$extra].firstUnsplittable === node) {
    root[$extra].noLayoutFailure = false;
  }
}
function handleBreak(node) {
  if (node[$extra]) {
    return false;
  }
  node[$extra] = /* @__PURE__ */ Object.create(null);
  if (node.targetType === "auto") {
    return false;
  }
  const root = node[$getTemplateRoot]();
  let target = null;
  if (node.target) {
    target = root[$searchNode](node.target, node[$getParent]());
    if (!target) {
      return false;
    }
    target = target[0];
  }
  const {
    currentPageArea,
    currentContentArea
  } = root[$extra];
  if (node.targetType === "pageArea") {
    if (!(target instanceof PageArea)) {
      target = null;
    }
    if (node.startNew) {
      node[$extra].target = target || currentPageArea;
      return true;
    } else if (target && target !== currentPageArea) {
      node[$extra].target = target;
      return true;
    }
    return false;
  }
  if (!(target instanceof ContentArea)) {
    target = null;
  }
  const pageArea = target && target[$getParent]();
  let index;
  if (node.startNew) {
    if (target) {
      const contentAreas = pageArea.contentArea.children;
      index = contentAreas.findIndex((e) => e === target) - 1;
    } else {
      index = currentPageArea.contentArea.children.findIndex((e) => e === currentContentArea);
    }
  } else if (target && target !== currentContentArea) {
    const contentAreas = pageArea.contentArea.children;
    index = contentAreas.findIndex((e) => e === target) - 1;
  } else {
    return false;
  }
  node[$extra].target = pageArea === currentPageArea ? null : pageArea;
  node[$extra].index = index;
  return true;
}
function handleOverflow(node, extraNode, space) {
  const root = node[$getTemplateRoot]();
  const saved = root[$extra].noLayoutFailure;
  const savedMethod = extraNode[$getSubformParent];
  extraNode[$getSubformParent] = () => node;
  root[$extra].noLayoutFailure = true;
  const res = extraNode[$toHTML](space);
  node[$addHTML](res.html, res.bbox);
  root[$extra].noLayoutFailure = saved;
  extraNode[$getSubformParent] = savedMethod;
}
var AppearanceFilter = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "appearanceFilter");
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Arc = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "arc",
      /* hasChildren = */
      true
    );
    this.circular = getInteger({
      data: attributes.circular,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.hand = getStringOption(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.startAngle = getFloat({
      data: attributes.startAngle,
      defaultValue: 0,
      validate: (x) => true
    });
    this.sweepAngle = getFloat({
      data: attributes.sweepAngle,
      defaultValue: 360,
      validate: (x) => true
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.edge = null;
    this.fill = null;
  }
  [$toHTML]() {
    const edge = this.edge ? this.edge : new Edge({});
    const edgeStyle = edge[$toStyle]();
    const style = /* @__PURE__ */ Object.create(null);
    if (this.fill && this.fill.presence === "visible") {
      Object.assign(style, this.fill[$toStyle]());
    } else {
      style.fill = "transparent";
    }
    style.strokeWidth = measureToString(edge.presence === "visible" ? edge.thickness : 0);
    style.stroke = edgeStyle.color;
    let arc;
    const attributes = {
      xmlns: SVG_NS,
      style: {
        width: "100%",
        height: "100%",
        overflow: "visible"
      }
    };
    if (this.startAngle === 0 && this.sweepAngle === 360) {
      arc = {
        name: "ellipse",
        attributes: {
          xmlns: SVG_NS,
          cx: "50%",
          cy: "50%",
          rx: "50%",
          ry: "50%",
          style
        }
      };
    } else {
      const startAngle = this.startAngle * Math.PI / 180;
      const sweepAngle = this.sweepAngle * Math.PI / 180;
      const largeArc = this.sweepAngle - this.startAngle > 180 ? 1 : 0;
      const [x1, y1, x2, y2] = [50 * (1 + Math.cos(startAngle)), 50 * (1 - Math.sin(startAngle)), 50 * (1 + Math.cos(sweepAngle)), 50 * (1 - Math.sin(sweepAngle))];
      arc = {
        name: "path",
        attributes: {
          xmlns: SVG_NS,
          d: `M ${x1} ${y1} A 50 50 0 ${largeArc} 0 ${x2} ${y2}`,
          vectorEffect: "non-scaling-stroke",
          style
        }
      };
      Object.assign(attributes, {
        viewBox: "0 0 100 100",
        preserveAspectRatio: "none"
      });
    }
    const svg = {
      name: "svg",
      children: [arc],
      attributes
    };
    const parent = this[$getParent]()[$getParent]();
    if (hasMargin(parent)) {
      return HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [svg]
      });
    }
    svg.attributes.style.position = "absolute";
    return HTMLResult.success(svg);
  }
};
var Area$1 = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "area",
      /* hasChildren = */
      true
    );
    this.colSpan = getInteger({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    });
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relevant = getRelevant(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.x = getMeasurement(attributes.x, "0pt");
    this.y = getMeasurement(attributes.y, "0pt");
    this.desc = null;
    this.extras = null;
    this.area = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
  }
  *[$getContainedChildren]() {
    yield* getContainedChildren(this);
  }
  [$isTransparent]() {
    return true;
  }
  [$addHTML](html, bbox) {
    const [x, y, w, h] = bbox;
    this[$extra].width = Math.max(this[$extra].width, x + w);
    this[$extra].height = Math.max(this[$extra].height, y + h);
    this[$extra].children.push(html);
  }
  [$getAvailableSpace]() {
    return this[$extra].availableSpace;
  }
  [$toHTML](availableSpace) {
    const style = toStyle(this, "position");
    const attributes = {
      style,
      id: this[$uid],
      class: ["xfaArea"]
    };
    if (isPrintOnly(this)) {
      attributes.class.push("xfaPrintOnly");
    }
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const children = [];
    this[$extra] = {
      children,
      width: 0,
      height: 0,
      availableSpace
    };
    const result = this[$childrenToHTML]({
      filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
      include: true
    });
    if (!result.success) {
      if (result.isBreak()) {
        return result;
      }
      delete this[$extra];
      return HTMLResult.FAILURE;
    }
    style.width = measureToString(this[$extra].width);
    style.height = measureToString(this[$extra].height);
    const html = {
      name: "div",
      attributes,
      children
    };
    const bbox = [this.x, this.y, this[$extra].width, this[$extra].height];
    delete this[$extra];
    return HTMLResult.success(html, bbox);
  }
};
var Assist = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "assist",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.role = attributes.role || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.speak = null;
    this.toolTip = null;
  }
  [$toHTML]() {
    return this.toolTip && this.toolTip[$content] ? this.toolTip[$content] : null;
  }
};
var Barcode = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "barcode",
      /* hasChildren = */
      true
    );
    this.charEncoding = getKeyword({
      data: attributes.charEncoding ? attributes.charEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: (k) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-[0-9]{2}/)
    });
    this.checksum = getStringOption(attributes.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
    this.dataColumnCount = getInteger({
      data: attributes.dataColumnCount,
      defaultValue: -1,
      validate: (x) => x >= 0
    });
    this.dataLength = getInteger({
      data: attributes.dataLength,
      defaultValue: -1,
      validate: (x) => x >= 0
    });
    this.dataPrep = getStringOption(attributes.dataPrep, ["none", "flateCompress"]);
    this.dataRowCount = getInteger({
      data: attributes.dataRowCount,
      defaultValue: -1,
      validate: (x) => x >= 0
    });
    this.endChar = attributes.endChar || "";
    this.errorCorrectionLevel = getInteger({
      data: attributes.errorCorrectionLevel,
      defaultValue: -1,
      validate: (x) => x >= 0 && x <= 8
    });
    this.id = attributes.id || "";
    this.moduleHeight = getMeasurement(attributes.moduleHeight, "5mm");
    this.moduleWidth = getMeasurement(attributes.moduleWidth, "0.25mm");
    this.printCheckDigit = getInteger({
      data: attributes.printCheckDigit,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.rowColumnRatio = getRatio(attributes.rowColumnRatio);
    this.startChar = attributes.startChar || "";
    this.textLocation = getStringOption(attributes.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
    this.truncate = getInteger({
      data: attributes.truncate,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.type = getStringOption(attributes.type ? attributes.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
    this.upsMode = getStringOption(attributes.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.wideNarrowRatio = getRatio(attributes.wideNarrowRatio);
    this.encrypt = null;
    this.extras = null;
  }
};
var Bind = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "bind",
      /* hasChildren = */
      true
    );
    this.match = getStringOption(attributes.match, ["once", "dataRef", "global", "none"]);
    this.ref = attributes.ref || "";
    this.picture = null;
  }
};
var BindItems = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bindItems");
    this.connection = attributes.connection || "";
    this.labelRef = attributes.labelRef || "";
    this.ref = attributes.ref || "";
    this.valueRef = attributes.valueRef || "";
  }
};
var Bookend = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "bookend");
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var BooleanElement = class extends Option01 {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "boolean");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$toHTML](availableSpace) {
    return valueToHtml(this[$content] === 1 ? "1" : "0");
  }
};
var Border = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "border",
      /* hasChildren = */
      true
    );
    this.break = getStringOption(attributes.break, ["close", "open"]);
    this.hand = getStringOption(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.corner = new XFAObjectArray(4);
    this.edge = new XFAObjectArray(4);
    this.extras = null;
    this.fill = null;
    this.margin = null;
  }
  [$toStyle]() {
    const edges = this.edge.children.slice();
    if (edges.length < 4) {
      const defaultEdge = edges[edges.length - 1] || new Edge({});
      for (let i = edges.length; i < 4; i++) {
        edges.push(defaultEdge);
      }
    }
    const edgeStyles = edges.map((node) => {
      const style2 = node[$toStyle]();
      style2.color = style2.color || "#000000";
      return style2;
    });
    const widths = edges.map((edge) => edge.thickness);
    const insets = [0, 0, 0, 0];
    if (this.margin) {
      insets[0] = this.margin.topInset;
      insets[1] = this.margin.rightInset;
      insets[2] = this.margin.bottomInset;
      insets[3] = this.margin.leftInset;
    }
    this[$extra] = {
      widths,
      insets
    };
    const style = /* @__PURE__ */ Object.create(null);
    if (this.margin) {
      Object.assign(style, this.margin[$toStyle]());
    }
    if (this.fill && this.fill.presence === "visible") {
      Object.assign(style, this.fill[$toStyle]());
    }
    if (this.corner.children.some((node) => node.radius !== 0)) {
      const cornerStyles = this.corner.children.map((node) => node[$toStyle]());
      if (cornerStyles.length === 2 || cornerStyles.length === 3) {
        const last = cornerStyles[cornerStyles.length - 1];
        for (let i = cornerStyles.length; i < 4; i++) {
          cornerStyles.push(last);
        }
      }
      style.borderRadius = cornerStyles.map((s) => s.radius).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        style.borderStyle = "";
        break;
      case "inactive":
        style.borderStyle = "none";
        break;
      default:
        style.borderStyle = edgeStyles.map((s) => s.style).join(" ");
        break;
    }
    style.borderWidth = edgeStyles.map((s) => s.width).join(" ");
    style.borderColor = edgeStyles.map((s) => s.color).join(" ");
    return style;
  }
};
var Break = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "break",
      /* hasChildren = */
      true
    );
    this.after = getStringOption(attributes.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.afterTarget = attributes.afterTarget || "";
    this.before = getStringOption(attributes.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.beforeTarget = attributes.beforeTarget || "";
    this.bookendLeader = attributes.bookendLeader || "";
    this.bookendTrailer = attributes.bookendTrailer || "";
    this.id = attributes.id || "";
    this.overflowLeader = attributes.overflowLeader || "";
    this.overflowTarget = attributes.overflowTarget || "";
    this.overflowTrailer = attributes.overflowTrailer || "";
    this.startNew = getInteger({
      data: attributes.startNew,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
};
var BreakAfter = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "breakAfter",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.startNew = getInteger({
      data: attributes.startNew,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.target = attributes.target || "";
    this.targetType = getStringOption(attributes.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.script = null;
  }
};
var BreakBefore = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "breakBefore",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.startNew = getInteger({
      data: attributes.startNew,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.target = attributes.target || "";
    this.targetType = getStringOption(attributes.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.script = null;
  }
  [$toHTML](availableSpace) {
    this[$extra] = {};
    return HTMLResult.FAILURE;
  }
};
var Button = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "button",
      /* hasChildren = */
      true
    );
    this.highlight = getStringOption(attributes.highlight, ["inverted", "none", "outline", "push"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [$toHTML](availableSpace) {
    return HTMLResult.success({
      name: "button",
      attributes: {
        id: this[$uid],
        class: ["xfaButton"],
        style: {}
      },
      children: []
    });
  }
};
var Calculate = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "calculate",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.override = getStringOption(attributes.override, ["disabled", "error", "ignore", "warning"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.message = null;
    this.script = null;
  }
};
var Caption = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "caption",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.placement = getStringOption(attributes.placement, ["left", "bottom", "inline", "right", "top"]);
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.reserve = Math.ceil(getMeasurement(attributes.reserve));
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.font = null;
    this.margin = null;
    this.para = null;
    this.value = null;
  }
  [$setValue](value) {
    _setValue(this, value);
  }
  [$getExtra](availableSpace) {
    if (!this[$extra]) {
      let {
        width,
        height
      } = availableSpace;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          width = this.reserve <= 0 ? width : this.reserve;
          break;
        case "top":
        case "bottom":
          height = this.reserve <= 0 ? height : this.reserve;
          break;
      }
      this[$extra] = layoutNode(this, {
        width,
        height
      });
    }
    return this[$extra];
  }
  [$toHTML](availableSpace) {
    if (!this.value) {
      return HTMLResult.EMPTY;
    }
    const value = this.value[$toHTML](availableSpace).html;
    if (!value) {
      return HTMLResult.EMPTY;
    }
    const savedReserve = this.reserve;
    if (this.reserve <= 0) {
      const {
        w,
        h
      } = this[$getExtra](availableSpace);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = w;
          break;
        case "top":
        case "bottom":
          this.reserve = h;
          break;
      }
    }
    const children = [];
    if (typeof value === "string") {
      children.push({
        name: "#text",
        value
      });
    } else {
      children.push(value);
    }
    const style = toStyle(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        if (this.reserve > 0) {
          style.width = measureToString(this.reserve);
        }
        break;
      case "top":
      case "bottom":
        if (this.reserve > 0) {
          style.height = measureToString(this.reserve);
        }
        break;
    }
    setPara(this, null, value);
    this.reserve = savedReserve;
    return HTMLResult.success({
      name: "div",
      attributes: {
        style,
        class: ["xfaCaption"]
      },
      children
    });
  }
};
var Certificate = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "certificate");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Certificates = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "certificates",
      /* hasChildren = */
      true
    );
    this.credentialServerPolicy = getStringOption(attributes.credentialServerPolicy, ["optional", "required"]);
    this.id = attributes.id || "";
    this.url = attributes.url || "";
    this.urlPolicy = attributes.urlPolicy || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encryption = null;
    this.issuers = null;
    this.keyUsage = null;
    this.oids = null;
    this.signing = null;
    this.subjectDNs = null;
  }
};
var CheckButton = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "checkButton",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.mark = getStringOption(attributes.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
    this.shape = getStringOption(attributes.shape, ["square", "round"]);
    this.size = getMeasurement(attributes.size, "10pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [$toHTML](availableSpace) {
    const style = toStyle("margin");
    const size = measureToString(this.size);
    style.width = style.height = size;
    let type;
    let className;
    let groupId;
    const field = this[$getParent]()[$getParent]();
    const items = field.items.children.length && field.items.children[0][$toHTML]().html || [];
    const exportedValue = {
      on: (items[0] || "on").toString(),
      off: (items[1] || "off").toString()
    };
    const value = field.value && field.value[$text]() || "off";
    const checked = value === exportedValue.on || void 0;
    const container = field[$getSubformParent]();
    const fieldId = field[$uid];
    let dataId;
    if (container instanceof ExclGroup) {
      groupId = container[$uid];
      type = "radio";
      className = "xfaRadio";
      dataId = container[$data] && container[$data][$uid] || container[$uid];
    } else {
      type = "checkbox";
      className = "xfaCheckbox";
      dataId = field[$data] && field[$data][$uid] || field[$uid];
    }
    const input = {
      name: "input",
      attributes: {
        class: [className],
        style,
        fieldId,
        dataId,
        type,
        checked,
        xfaOn: exportedValue.on
      }
    };
    if (groupId) {
      input.attributes.name = groupId;
    }
    return HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [input]
    });
  }
};
var ChoiceList = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "choiceList",
      /* hasChildren = */
      true
    );
    this.commitOn = getStringOption(attributes.commitOn, ["select", "exit"]);
    this.id = attributes.id || "";
    this.open = getStringOption(attributes.open, ["userControl", "always", "multiSelect", "onEntry"]);
    this.textEntry = getInteger({
      data: attributes.textEntry,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [$toHTML](availableSpace) {
    const style = toStyle(this, "border", "margin");
    const ui = this[$getParent]();
    const field = ui[$getParent]();
    const children = [];
    if (field.items.children.length > 0) {
      const items = field.items;
      let displayedIndex = 0;
      let saveIndex = 0;
      if (items.children.length === 2) {
        displayedIndex = items.children[0].save;
        saveIndex = 1 - displayedIndex;
      }
      const displayed = items.children[displayedIndex][$toHTML]().html;
      const values = items.children[saveIndex][$toHTML]().html;
      let selected = false;
      const value = field.value && field.value[$text]() || "";
      for (let i = 0, ii = displayed.length; i < ii; i++) {
        const option = {
          name: "option",
          attributes: {
            value: values[i] || displayed[i]
          },
          value: displayed[i]
        };
        if (values[i] === value) {
          option.attributes.selected = selected = true;
        }
        children.push(option);
      }
      if (!selected) {
        children.splice(0, 0, {
          name: "option",
          attributes: {
            hidden: true,
            selected: true
          },
          value: " "
        });
      }
    }
    const selectAttributes = {
      class: ["xfaSelect"],
      fieldId: field[$uid],
      dataId: field[$data] && field[$data][$uid] || field[$uid],
      style
    };
    if (this.open === "multiSelect") {
      selectAttributes.multiple = true;
    }
    return HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [{
        name: "select",
        children,
        attributes: selectAttributes
      }]
    });
  }
};
var Color = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "color",
      /* hasChildren = */
      true
    );
    this.cSpace = getStringOption(attributes.cSpace, ["SRGB"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.value = attributes.value ? getColor(attributes.value) : "";
    this.extras = null;
  }
  [$hasSettableValue]() {
    return false;
  }
  [$toStyle]() {
    return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
};
var Comb = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "comb");
    this.id = attributes.id || "";
    this.numberOfCells = getInteger({
      data: attributes.numberOfCells,
      defaultValue: 0,
      validate: (x) => x >= 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Connect = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "connect",
      /* hasChildren = */
      true
    );
    this.connection = attributes.connection || "";
    this.id = attributes.id || "";
    this.ref = attributes.ref || "";
    this.usage = getStringOption(attributes.usage, ["exportAndImport", "exportOnly", "importOnly"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.picture = null;
  }
};
var ContentArea = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "contentArea",
      /* hasChildren = */
      true
    );
    this.h = getMeasurement(attributes.h);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relevant = getRelevant(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = getMeasurement(attributes.w);
    this.x = getMeasurement(attributes.x, "0pt");
    this.y = getMeasurement(attributes.y, "0pt");
    this.desc = null;
    this.extras = null;
  }
  [$toHTML](availableSpace) {
    const left = measureToString(this.x);
    const top = measureToString(this.y);
    const style = {
      left,
      top,
      width: measureToString(this.w),
      height: measureToString(this.h)
    };
    const classNames = ["xfaContentarea"];
    if (isPrintOnly(this)) {
      classNames.push("xfaPrintOnly");
    }
    return HTMLResult.success({
      name: "div",
      children: [],
      attributes: {
        style,
        class: classNames,
        id: this[$uid]
      }
    });
  }
};
var Corner = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "corner",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.inverted = getInteger({
      data: attributes.inverted,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.join = getStringOption(attributes.join, ["square", "round"]);
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.radius = getMeasurement(attributes.radius);
    this.stroke = getStringOption(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = getMeasurement(attributes.thickness, "0.5pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [$toStyle]() {
    const style = toStyle(this, "visibility");
    style.radius = measureToString(this.join === "square" ? 0 : this.radius);
    return style;
  }
};
var DateElement = class extends ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "date");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$finalize]() {
    const date = this[$content].trim();
    this[$content] = date ? new Date(date) : null;
  }
  [$toHTML](availableSpace) {
    return valueToHtml(this[$content] ? this[$content].toString() : "");
  }
};
var DateTime = class extends ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "dateTime");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$finalize]() {
    const date = this[$content].trim();
    this[$content] = date ? new Date(date) : null;
  }
  [$toHTML](availableSpace) {
    return valueToHtml(this[$content] ? this[$content].toString() : "");
  }
};
var DateTimeEdit = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "dateTimeEdit",
      /* hasChildren = */
      true
    );
    this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.picker = getStringOption(attributes.picker, ["host", "none"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [$toHTML](availableSpace) {
    const style = toStyle(this, "border", "font", "margin");
    const field = this[$getParent]()[$getParent]();
    const html = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: field[$uid],
        dataId: field[$data] && field[$data][$uid] || field[$uid],
        class: ["xfaTextfield"],
        style
      }
    };
    return HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [html]
    });
  }
};
var Decimal = class extends ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "decimal");
    this.fracDigits = getInteger({
      data: attributes.fracDigits,
      defaultValue: 2,
      validate: (x) => true
    });
    this.id = attributes.id || "";
    this.leadDigits = getInteger({
      data: attributes.leadDigits,
      defaultValue: -1,
      validate: (x) => true
    });
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$finalize]() {
    const number = parseFloat(this[$content].trim());
    this[$content] = isNaN(number) ? null : number;
  }
  [$toHTML](availableSpace) {
    return valueToHtml(this[$content] !== null ? this[$content].toString() : "");
  }
};
var DefaultUi = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "defaultUi",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
};
var Desc = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "desc",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
};
var DigestMethod = class extends OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var DigestMethods = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "digestMethods",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.digestMethod = new XFAObjectArray();
  }
};
var Draw = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "draw",
      /* hasChildren = */
      true
    );
    this.anchorType = getStringOption(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    });
    this.h = attributes.h ? getMeasurement(attributes.h) : "";
    this.hAlign = getStringOption(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.locale = attributes.locale || "";
    this.maxH = getMeasurement(attributes.maxH, "0pt");
    this.maxW = getMeasurement(attributes.maxW, "0pt");
    this.minH = getMeasurement(attributes.minH, "0pt");
    this.minW = getMeasurement(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(attributes.relevant);
    this.rotate = getInteger({
      data: attributes.rotate,
      defaultValue: 0,
      validate: (x) => x % 90 === 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? getMeasurement(attributes.w) : "";
    this.x = getMeasurement(attributes.x, "0pt");
    this.y = getMeasurement(attributes.y, "0pt");
    this.assist = null;
    this.border = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.value = null;
    this.setProperty = new XFAObjectArray();
  }
  [$setValue](value) {
    _setValue(this, value);
  }
  [$toHTML](availableSpace) {
    if (this.presence === "hidden" || this.presence === "inactive") {
      return HTMLResult.EMPTY;
    }
    fixDimensions(this);
    const savedW = this.w;
    const savedH = this.h;
    const {
      w,
      h,
      isBroken
    } = layoutNode(this, availableSpace);
    if (w && this.w === "") {
      if (isBroken && this[$getSubformParent]()[$isThereMoreWidth]()) {
        return HTMLResult.FAILURE;
      }
      this.w = w;
    }
    if (h && this.h === "") {
      this.h = h;
    }
    setFirstUnsplittable(this);
    if (!checkDimensions(this, availableSpace)) {
      this.w = savedW;
      this.h = savedH;
      return HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const style = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    setMinMaxDimensions(this, style);
    if (style.margin) {
      style.padding = style.margin;
      delete style.margin;
    }
    const classNames = ["xfaDraw"];
    if (this.font) {
      classNames.push("xfaFont");
    }
    if (isPrintOnly(this)) {
      classNames.push("xfaPrintOnly");
    }
    const attributes = {
      style,
      id: this[$uid],
      class: classNames
    };
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const html = {
      name: "div",
      attributes,
      children: []
    };
    const assist = this.assist ? this.assist[$toHTML]() : null;
    if (assist) {
      html.attributes.title = assist;
    }
    const bbox = computeBbox(this, html, availableSpace);
    const value = this.value ? this.value[$toHTML](availableSpace).html : null;
    if (value === null) {
      this.w = savedW;
      this.h = savedH;
      return HTMLResult.success(createWrapper(this, html), bbox);
    }
    html.children.push(value);
    setPara(this, style, value);
    this.w = savedW;
    this.h = savedH;
    return HTMLResult.success(createWrapper(this, html), bbox);
  }
};
var Edge = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "edge",
      /* hasChildren = */
      true
    );
    this.cap = getStringOption(attributes.cap, ["square", "butt", "round"]);
    this.id = attributes.id || "";
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.stroke = getStringOption(attributes.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = getMeasurement(attributes.thickness, "0.5pt");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [$toStyle]() {
    const style = toStyle(this, "visibility");
    Object.assign(style, {
      linecap: this.cap,
      width: measureToString(this.thickness),
      color: this.color ? this.color[$toStyle]() : "#000000",
      style: ""
    });
    if (this.presence !== "visible") {
      style.style = "none";
    } else {
      switch (this.stroke) {
        case "solid":
          style.style = "solid";
          break;
        case "dashDot":
          style.style = "dashed";
          break;
        case "dashDotDot":
          style.style = "dashed";
          break;
        case "dashed":
          style.style = "dashed";
          break;
        case "dotted":
          style.style = "dotted";
          break;
        case "embossed":
          style.style = "ridge";
          break;
        case "etched":
          style.style = "groove";
          break;
        case "lowered":
          style.style = "inset";
          break;
        case "raised":
          style.style = "outset";
          break;
      }
    }
    return style;
  }
};
var Encoding = class extends OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Encodings = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "encodings",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encoding = new XFAObjectArray();
  }
};
var Encrypt$1 = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "encrypt",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = null;
  }
};
var EncryptData = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "encryptData",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.operation = getStringOption(attributes.operation, ["encrypt", "decrypt"]);
    this.target = attributes.target || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
};
var Encryption$1 = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "encryption",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new XFAObjectArray();
  }
};
var EncryptionMethod = class extends OptionObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var EncryptionMethods = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "encryptionMethods",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.encryptionMethod = new XFAObjectArray();
  }
};
var Event = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "event",
      /* hasChildren = */
      true
    );
    this.activity = getStringOption(attributes.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
    this.id = attributes.id || "";
    this.listen = getStringOption(attributes.listen, ["refOnly", "refAndDescendents"]);
    this.name = attributes.name || "";
    this.ref = attributes.ref || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.encryptData = null;
    this.execute = null;
    this.script = null;
    this.signData = null;
    this.submit = null;
  }
};
var ExData = class extends ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "exData");
    this.contentType = attributes.contentType || "";
    this.href = attributes.href || "";
    this.id = attributes.id || "";
    this.maxLength = getInteger({
      data: attributes.maxLength,
      defaultValue: -1,
      validate: (x) => x >= -1
    });
    this.name = attributes.name || "";
    this.rid = attributes.rid || "";
    this.transferEncoding = getStringOption(attributes.transferEncoding, ["none", "base64", "package"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$isCDATAXml]() {
    return this.contentType === "text/html";
  }
  [$onChild](child) {
    if (this.contentType === "text/html" && child[$namespaceId] === NamespaceIds.xhtml.id) {
      this[$content] = child;
      return true;
    }
    if (this.contentType === "text/xml") {
      this[$content] = child;
      return true;
    }
    return false;
  }
  [$toHTML](availableSpace) {
    if (this.contentType !== "text/html" || !this[$content]) {
      return HTMLResult.EMPTY;
    }
    return this[$content][$toHTML](availableSpace);
  }
};
var ExObject = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "exObject",
      /* hasChildren = */
      true
    );
    this.archive = attributes.archive || "";
    this.classId = attributes.classId || "";
    this.codeBase = attributes.codeBase || "";
    this.codeType = attributes.codeType || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
};
var ExclGroup = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "exclGroup",
      /* hasChildren = */
      true
    );
    this.access = getStringOption(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = attributes.accessKey || "";
    this.anchorType = getStringOption(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    });
    this.h = attributes.h ? getMeasurement(attributes.h) : "";
    this.hAlign = getStringOption(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.layout = getStringOption(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.maxH = getMeasurement(attributes.maxH, "0pt");
    this.maxW = getMeasurement(attributes.maxW, "0pt");
    this.minH = getMeasurement(attributes.minH, "0pt");
    this.minW = getMeasurement(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? getMeasurement(attributes.w) : "";
    this.x = getMeasurement(attributes.x, "0pt");
    this.y = getMeasurement(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.connect = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
  }
  [$isBindable]() {
    return true;
  }
  [$hasSettableValue]() {
    return true;
  }
  [$setValue](value) {
    for (const field of this.field.children) {
      if (!field.value) {
        const nodeValue = new Value({});
        field[$appendChild](nodeValue);
        field.value = nodeValue;
      }
      field.value[$setValue](value);
    }
  }
  [$isThereMoreWidth]() {
    return this.layout.endsWith("-tb") && this[$extra].attempt === 0 && this[$extra].numberInLine > 0 || this[$getParent]()[$isThereMoreWidth]();
  }
  [$isSplittable]() {
    const parent = this[$getSubformParent]();
    if (!parent[$isSplittable]()) {
      return false;
    }
    if (this[$extra]._isSplittable !== void 0) {
      return this[$extra]._isSplittable;
    }
    if (this.layout === "position" || this.layout.includes("row")) {
      this[$extra]._isSplittable = false;
      return false;
    }
    if (parent.layout && parent.layout.endsWith("-tb") && parent[$extra].numberInLine !== 0) {
      return false;
    }
    this[$extra]._isSplittable = true;
    return true;
  }
  [$flushHTML]() {
    return flushHTML(this);
  }
  [$addHTML](html, bbox) {
    addHTML(this, html, bbox);
  }
  [$getAvailableSpace]() {
    return getAvailableSpace(this);
  }
  [$toHTML](availableSpace) {
    if (this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
      return HTMLResult.EMPTY;
    }
    fixDimensions(this);
    const children = [];
    const attributes = {
      id: this[$uid],
      class: []
    };
    setAccess(this, attributes.class);
    if (!this[$extra]) {
      this[$extra] = /* @__PURE__ */ Object.create(null);
    }
    Object.assign(this[$extra], {
      children,
      attributes,
      attempt: 0,
      line: null,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || Infinity, availableSpace.width),
        height: Math.min(this.h || Infinity, availableSpace.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const isSplittable = this[$isSplittable]();
    if (!isSplittable) {
      setFirstUnsplittable(this);
    }
    if (!checkDimensions(this, availableSpace)) {
      return HTMLResult.FAILURE;
    }
    availableSpace = {
      width: this.w === "" ? availableSpace.width : this.w,
      height: this.h === "" ? availableSpace.height : this.h
    };
    const filter = /* @__PURE__ */ new Set(["field"]);
    if (this.layout.includes("row")) {
      const columnWidths = this[$getSubformParent]().columnWidths;
      if (Array.isArray(columnWidths) && columnWidths.length > 0) {
        this[$extra].columnWidths = columnWidths;
        this[$extra].currentColumn = 0;
      }
    }
    const style = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
    const classNames = ["xfaExclgroup"];
    const cl = layoutClass(this);
    if (cl) {
      classNames.push(cl);
    }
    if (isPrintOnly(this)) {
      classNames.push("xfaPrintOnly");
    }
    attributes.style = style;
    attributes.class = classNames;
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
    const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
    for (; this[$extra].attempt < maxRun; this[$extra].attempt++) {
      if (isLrTb && this[$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
        this[$extra].numberInLine = 0;
      }
      const result = this[$childrenToHTML]({
        filter,
        include: true
      });
      if (result.success) {
        break;
      }
      if (result.isBreak()) {
        return result;
      }
      if (isLrTb && this[$extra].attempt === 0 && this[$extra].numberInLine === 0 && !this[$getTemplateRoot]()[$extra].noLayoutFailure) {
        this[$extra].attempt = maxRun;
        break;
      }
    }
    if (!isSplittable) {
      unsetFirstUnsplittable(this);
    }
    if (this[$extra].attempt === maxRun) {
      if (!isSplittable) {
        delete this[$extra];
      }
      return HTMLResult.FAILURE;
    }
    let marginH = 0;
    let marginV = 0;
    if (this.margin) {
      marginH = this.margin.leftInset + this.margin.rightInset;
      marginV = this.margin.topInset + this.margin.bottomInset;
    }
    const width = Math.max(this[$extra].width + marginH, this.w || 0);
    const height = Math.max(this[$extra].height + marginV, this.h || 0);
    const bbox = [this.x, this.y, width, height];
    if (this.w === "") {
      style.width = measureToString(width);
    }
    if (this.h === "") {
      style.height = measureToString(height);
    }
    const html = {
      name: "div",
      attributes,
      children
    };
    const assist = this.assist ? this.assist[$toHTML]() : null;
    if (assist) {
      html.attributes.title = assist;
    }
    delete this[$extra];
    return HTMLResult.success(createWrapper(this, html), bbox);
  }
};
var Execute = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "execute");
    this.connection = attributes.connection || "";
    this.executeType = getStringOption(attributes.executeType, ["import", "remerge"]);
    this.id = attributes.id || "";
    this.runAt = getStringOption(attributes.runAt, ["client", "both", "server"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Extras = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "extras",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.extras = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
  // (Spec) The XFA template grammar defines the extras and desc elements,
  // which can be used to add human-readable or machine-readable
  // data to a template.
};
var Field = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "field",
      /* hasChildren = */
      true
    );
    this.access = getStringOption(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = attributes.accessKey || "";
    this.anchorType = getStringOption(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    });
    this.h = attributes.h ? getMeasurement(attributes.h) : "";
    this.hAlign = getStringOption(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.locale = attributes.locale || "";
    this.maxH = getMeasurement(attributes.maxH, "0pt");
    this.maxW = getMeasurement(attributes.maxW, "0pt");
    this.minH = getMeasurement(attributes.minH, "0pt");
    this.minW = getMeasurement(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(attributes.relevant);
    this.rotate = getInteger({
      data: attributes.rotate,
      defaultValue: 0,
      validate: (x) => x % 90 === 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? getMeasurement(attributes.w) : "";
    this.x = getMeasurement(attributes.x, "0pt");
    this.y = getMeasurement(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.format = null;
    this.items = new XFAObjectArray(2);
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.validate = null;
    this.value = null;
    this.bindItems = new XFAObjectArray();
    this.connect = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
  }
  [$isBindable]() {
    return true;
  }
  [$setValue](value) {
    _setValue(this, value);
  }
  [$toHTML](availableSpace) {
    if (!this.ui) {
      this.ui = new Ui({});
      this.ui[$globalData] = this[$globalData];
      this[$appendChild](this.ui);
      let node;
      switch (this.items.children.length) {
        case 0:
          node = new TextEdit({});
          this.ui.textEdit = node;
          break;
        case 1:
          node = new CheckButton({});
          this.ui.checkButton = node;
          break;
        case 2:
          node = new ChoiceList({});
          this.ui.choiceList = node;
          break;
      }
      this.ui[$appendChild](node);
    }
    setTabIndex(this);
    if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) {
      return HTMLResult.EMPTY;
    }
    if (this.caption) {
      delete this.caption[$extra];
    }
    const caption = this.caption ? this.caption[$toHTML](availableSpace).html : null;
    const savedW = this.w;
    const savedH = this.h;
    if (this.w === "" || this.h === "") {
      let marginH = 0;
      let marginV = 0;
      if (this.margin) {
        marginH = this.margin.leftInset + this.margin.rightInset;
        marginV = this.margin.topInset + this.margin.bottomInset;
      }
      let width = null;
      let height = null;
      if (this.caption) {
        const {
          w,
          h,
          isBroken
        } = this.caption[$getExtra](availableSpace);
        if (isBroken && this[$getSubformParent]()[$isThereMoreWidth]()) {
          return HTMLResult.FAILURE;
        }
        width = w;
        height = h;
        if (this.ui.checkButton) {
          switch (this.caption.placement) {
            case "left":
            case "right":
            case "inline":
              width += this.ui.checkButton.size;
              break;
            case "top":
            case "bottom":
              height += this.ui.checkButton.size;
              break;
          }
        }
      }
      if (width && this.w === "") {
        this.w = Math.min(this.maxW <= 0 ? Infinity : this.maxW, Math.max(this.minW, width + marginH));
      }
      if (height && this.h === "") {
        this.h = Math.min(this.maxH <= 0 ? Infinity : this.maxH, Math.max(this.minH, height + marginV));
      }
    }
    fixDimensions(this);
    setFirstUnsplittable(this);
    if (!checkDimensions(this, availableSpace)) {
      this.w = savedW;
      this.h = savedH;
      return HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const style = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    setMinMaxDimensions(this, style);
    const classNames = ["xfaField"];
    if (this.font) {
      classNames.push("xfaFont");
    }
    if (isPrintOnly(this)) {
      classNames.push("xfaPrintOnly");
    }
    const attributes = {
      style,
      id: this[$uid],
      class: classNames
    };
    if (style.margin) {
      style.padding = style.margin;
      delete style.margin;
    }
    setAccess(this, classNames);
    if (this.name) {
      attributes.xfaName = this.name;
    }
    const children = [];
    const html = {
      name: "div",
      attributes,
      children
    };
    const assist = this.assist ? this.assist[$toHTML]() : null;
    if (assist) {
      html.attributes.title = assist;
    }
    const borderStyle = this.border ? this.border[$toStyle]() : null;
    const bbox = computeBbox(this, html, availableSpace);
    const ui = this.ui[$toHTML]().html;
    if (!ui) {
      Object.assign(style, borderStyle);
      return HTMLResult.success(createWrapper(this, html), bbox);
    }
    if (this[$tabIndex]) {
      if (ui.children && ui.children[0]) {
        ui.children[0].attributes.tabindex = this[$tabIndex];
      } else {
        ui.attributes.tabindex = this[$tabIndex];
      }
    }
    if (!ui.attributes.style) {
      ui.attributes.style = /* @__PURE__ */ Object.create(null);
    }
    if (this.ui.button) {
      Object.assign(ui.attributes.style, borderStyle);
    } else {
      Object.assign(style, borderStyle);
    }
    children.push(ui);
    if (this.value) {
      if (this.ui.imageEdit) {
        ui.children.push(this.value[$toHTML]().html);
      } else if (!this.ui.button) {
        let value = "";
        if (this.value.exData) {
          value = this.value.exData[$text]();
        } else {
          const htmlValue = this.value[$toHTML]().html;
          if (htmlValue !== null) {
            value = htmlValue.children[0].value;
          }
        }
        if (this.ui.textEdit && this.value.text && this.value.text.maxChars) {
          ui.children[0].attributes.maxLength = this.value.text.maxChars;
        }
        if (value) {
          if (ui.children[0].name === "textarea") {
            ui.children[0].attributes.textContent = value;
          } else {
            ui.children[0].attributes.value = value;
          }
        }
      }
    }
    if (!caption) {
      if (ui.attributes.class) {
        ui.attributes.class.push("xfaLeft");
      }
      this.w = savedW;
      this.h = savedH;
      return HTMLResult.success(createWrapper(this, html), bbox);
    }
    if (this.ui.button) {
      if (style.padding) {
        delete style.padding;
      }
      if (caption.name === "div") {
        caption.name = "span";
      }
      ui.children.push(caption);
      return HTMLResult.success(html, bbox);
    } else if (this.ui.checkButton) {
      caption.attributes.class[0] = "xfaCaptionForCheckButton";
    }
    if (!ui.attributes.class) {
      ui.attributes.class = [];
    }
    switch (this.caption.placement) {
      case "left":
        ui.children.splice(0, 0, caption);
        ui.attributes.class.push("xfaLeft");
        break;
      case "right":
        ui.children.push(caption);
        ui.attributes.class.push("xfaLeft");
        break;
      case "top":
        ui.children.splice(0, 0, caption);
        ui.attributes.class.push("xfaTop");
        break;
      case "bottom":
        ui.children.push(caption);
        ui.attributes.class.push("xfaTop");
        break;
      case "inline":
        ui.attributes.class.push("xfaLeft");
        break;
    }
    this.w = savedW;
    this.h = savedH;
    return HTMLResult.success(createWrapper(this, html), bbox);
  }
};
var Fill = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "fill",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
    this.linear = null;
    this.pattern = null;
    this.radial = null;
    this.solid = null;
    this.stipple = null;
  }
  [$toStyle]() {
    const parent = this[$getParent]();
    const style = /* @__PURE__ */ Object.create(null);
    let propName = "color";
    if (parent instanceof Border) {
      propName = "background";
    }
    if (parent instanceof Rectangle || parent instanceof Arc) {
      propName = "fill";
      style.fill = "white";
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      if (name === "extras" || name === "color") {
        continue;
      }
      const obj = this[name];
      if (!(obj instanceof XFAObject)) {
        continue;
      }
      style[propName] = obj[$toStyle](this.color);
      return style;
    }
    if (this.color) {
      style[propName] = this.color[$toStyle]();
    }
    return style;
  }
};
var Filter = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "filter",
      /* hasChildren = */
      true
    );
    this.addRevocationInfo = getStringOption(attributes.addRevocationInfo, ["", "required", "optional", "none"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.version = getInteger({
      data: this.version,
      defaultValue: 5,
      validate: (x) => x >= 1 && x <= 5
    });
    this.appearanceFilter = null;
    this.certificates = null;
    this.digestMethods = null;
    this.encodings = null;
    this.encryptionMethods = null;
    this.handler = null;
    this.lockDocument = null;
    this.mdp = null;
    this.reasons = null;
    this.timeStamp = null;
  }
};
var Float = class extends ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "float");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$finalize]() {
    const number = parseFloat(this[$content].trim());
    this[$content] = isNaN(number) ? null : number;
  }
  [$toHTML](availableSpace) {
    return valueToHtml(this[$content] !== null ? this[$content].toString() : "");
  }
};
var Font = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "font",
      /* hasChildren = */
      true
    );
    this.baselineShift = getMeasurement(attributes.baselineShift);
    this.fontHorizontalScale = getFloat({
      data: attributes.fontHorizontalScale,
      defaultValue: 100,
      validate: (x) => x >= 0
    });
    this.fontVerticalScale = getFloat({
      data: attributes.fontVerticalScale,
      defaultValue: 100,
      validate: (x) => x >= 0
    });
    this.id = attributes.id || "";
    this.kerningMode = getStringOption(attributes.kerningMode, ["none", "pair"]);
    this.letterSpacing = getMeasurement(attributes.letterSpacing, "0");
    this.lineThrough = getInteger({
      data: attributes.lineThrough,
      defaultValue: 0,
      validate: (x) => x === 1 || x === 2
    });
    this.lineThroughPeriod = getStringOption(attributes.lineThroughPeriod, ["all", "word"]);
    this.overline = getInteger({
      data: attributes.overline,
      defaultValue: 0,
      validate: (x) => x === 1 || x === 2
    });
    this.overlinePeriod = getStringOption(attributes.overlinePeriod, ["all", "word"]);
    this.posture = getStringOption(attributes.posture, ["normal", "italic"]);
    this.size = getMeasurement(attributes.size, "10pt");
    this.typeface = attributes.typeface || "Courier";
    this.underline = getInteger({
      data: attributes.underline,
      defaultValue: 0,
      validate: (x) => x === 1 || x === 2
    });
    this.underlinePeriod = getStringOption(attributes.underlinePeriod, ["all", "word"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.weight = getStringOption(attributes.weight, ["normal", "bold"]);
    this.extras = null;
    this.fill = null;
  }
  [$clean](builder) {
    super[$clean](builder);
    this[$globalData].usedTypefaces.add(this.typeface);
  }
  [$toStyle]() {
    const style = toStyle(this, "fill");
    const color = style.color;
    if (color) {
      if (color === "#000000") {
        delete style.color;
      } else if (!color.startsWith("#")) {
        style.background = color;
        style.backgroundClip = "text";
        style.color = "transparent";
      }
    }
    if (this.baselineShift) {
      style.verticalAlign = measureToString(this.baselineShift);
    }
    style.fontKerning = this.kerningMode === "none" ? "none" : "normal";
    style.letterSpacing = measureToString(this.letterSpacing);
    if (this.lineThrough !== 0) {
      style.textDecoration = "line-through";
      if (this.lineThrough === 2) {
        style.textDecorationStyle = "double";
      }
    }
    if (this.overline !== 0) {
      style.textDecoration = "overline";
      if (this.overline === 2) {
        style.textDecorationStyle = "double";
      }
    }
    style.fontStyle = this.posture;
    style.fontSize = measureToString(0.99 * this.size);
    setFontFamily(this, this[$globalData].fontFinder, style);
    if (this.underline !== 0) {
      style.textDecoration = "underline";
      if (this.underline === 2) {
        style.textDecorationStyle = "double";
      }
    }
    style.fontWeight = this.weight;
    return style;
  }
};
var Format = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "format",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.picture = null;
  }
};
var Handler = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "handler");
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Hyphenation = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "hyphenation");
    this.excludeAllCaps = getInteger({
      data: attributes.excludeAllCaps,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.excludeInitialCap = getInteger({
      data: attributes.excludeInitialCap,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.hyphenate = getInteger({
      data: attributes.hyphenate,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.id = attributes.id || "";
    this.pushCharacterCount = getInteger({
      data: attributes.pushCharacterCount,
      defaultValue: 3,
      validate: (x) => x >= 0
    });
    this.remainCharacterCount = getInteger({
      data: attributes.remainCharacterCount,
      defaultValue: 3,
      validate: (x) => x >= 0
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.wordCharacterCount = getInteger({
      data: attributes.wordCharacterCount,
      defaultValue: 7,
      validate: (x) => x >= 0
    });
  }
};
var Image = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "image");
    this.aspect = getStringOption(attributes.aspect, ["fit", "actual", "height", "none", "width"]);
    this.contentType = attributes.contentType || "";
    this.href = attributes.href || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.transferEncoding = getStringOption(attributes.transferEncoding, ["base64", "none", "package"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$toHTML]() {
    let buffer = this[$globalData].images && this[$globalData].images.get(this.href);
    if (!buffer && (this.href || !this[$content])) {
      return HTMLResult.EMPTY;
    }
    if (!buffer && this.transferEncoding === "base64") {
      buffer = stringToBytes(atob(this[$content]));
    }
    if (!buffer) {
      return HTMLResult.EMPTY;
    }
    const blob = new Blob([buffer], {
      type: this.contentType
    });
    let style;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        style = {
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "none":
        style = {
          width: "100%",
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "width":
        style = {
          width: "100%",
          objectFit: "fill"
        };
        break;
    }
    return HTMLResult.success({
      name: "img",
      attributes: {
        class: ["xfaImage"],
        style,
        src: URL.createObjectURL(blob)
      }
    });
  }
};
var ImageEdit = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "imageEdit",
      /* hasChildren = */
      true
    );
    this.data = getStringOption(attributes.data, ["link", "embed"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [$toHTML](availableSpace) {
    if (this.data === "embed") {
      return HTMLResult.success({
        name: "div",
        children: [],
        attributes: {}
      });
    }
    return HTMLResult.EMPTY;
  }
};
var Integer = class extends ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "integer");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$finalize]() {
    const number = parseInt(this[$content].trim(), 10);
    this[$content] = isNaN(number) ? null : number;
  }
  [$toHTML](availableSpace) {
    return valueToHtml(this[$content] !== null ? this[$content].toString() : "");
  }
};
var Issuers = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "issuers",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new XFAObjectArray();
  }
};
var Items = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "items",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.ref = attributes.ref || "";
    this.save = getInteger({
      data: attributes.save,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
  [$toHTML]() {
    const output = [];
    for (const child of this[$getChildren]()) {
      output.push(child[$text]());
    }
    return HTMLResult.success(output);
  }
};
var Keep = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "keep",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    const options = ["none", "contentArea", "pageArea"];
    this.intact = getStringOption(attributes.intact, options);
    this.next = getStringOption(attributes.next, options);
    this.previous = getStringOption(attributes.previous, options);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
};
var KeyUsage = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "keyUsage");
    const options = ["", "yes", "no"];
    this.crlSign = getStringOption(attributes.crlSign, options);
    this.dataEncipherment = getStringOption(attributes.dataEncipherment, options);
    this.decipherOnly = getStringOption(attributes.decipherOnly, options);
    this.digitalSignature = getStringOption(attributes.digitalSignature, options);
    this.encipherOnly = getStringOption(attributes.encipherOnly, options);
    this.id = attributes.id || "";
    this.keyAgreement = getStringOption(attributes.keyAgreement, options);
    this.keyCertSign = getStringOption(attributes.keyCertSign, options);
    this.keyEncipherment = getStringOption(attributes.keyEncipherment, options);
    this.nonRepudiation = getStringOption(attributes.nonRepudiation, options);
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Line = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "line",
      /* hasChildren = */
      true
    );
    this.hand = getStringOption(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.slope = getStringOption(attributes.slope, ["\\", "/"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.edge = null;
  }
  [$toHTML]() {
    const parent = this[$getParent]()[$getParent]();
    const edge = this.edge ? this.edge : new Edge({});
    const edgeStyle = edge[$toStyle]();
    const style = /* @__PURE__ */ Object.create(null);
    const thickness = edge.presence === "visible" ? edge.thickness : 0;
    style.strokeWidth = measureToString(thickness);
    style.stroke = edgeStyle.color;
    let x1, y1, x2, y2;
    let width = "100%";
    let height = "100%";
    if (parent.w <= thickness) {
      [x1, y1, x2, y2] = ["50%", 0, "50%", "100%"];
      width = style.strokeWidth;
    } else if (parent.h <= thickness) {
      [x1, y1, x2, y2] = [0, "50%", "100%", "50%"];
      height = style.strokeWidth;
    } else {
      if (this.slope === "\\") {
        [x1, y1, x2, y2] = [0, 0, "100%", "100%"];
      } else {
        [x1, y1, x2, y2] = [0, "100%", "100%", 0];
      }
    }
    const line = {
      name: "line",
      attributes: {
        xmlns: SVG_NS,
        x1,
        y1,
        x2,
        y2,
        style
      }
    };
    const svg = {
      name: "svg",
      children: [line],
      attributes: {
        xmlns: SVG_NS,
        width,
        height,
        style: {
          overflow: "visible"
        }
      }
    };
    if (hasMargin(parent)) {
      return HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [svg]
      });
    }
    svg.attributes.style.position = "absolute";
    return HTMLResult.success(svg);
  }
};
var Linear = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "linear",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["toRight", "toBottom", "toLeft", "toTop"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [$toStyle](startColor) {
    startColor = startColor ? startColor[$toStyle]() : "#FFFFFF";
    const transf = this.type.replace(/([RBLT])/, " $1").toLowerCase();
    const endColor = this.color ? this.color[$toStyle]() : "#000000";
    return `linear-gradient(${transf}, ${startColor}, ${endColor})`;
  }
};
var LockDocument = class extends ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "lockDocument");
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$finalize]() {
    this[$content] = getStringOption(this[$content], ["auto", "0", "1"]);
  }
};
var Manifest = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "manifest",
      /* hasChildren = */
      true
    );
    this.action = getStringOption(attributes.action, ["include", "all", "exclude"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.ref = new XFAObjectArray();
  }
};
var Margin = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "margin",
      /* hasChildren = */
      true
    );
    this.bottomInset = getMeasurement(attributes.bottomInset, "0");
    this.id = attributes.id || "";
    this.leftInset = getMeasurement(attributes.leftInset, "0");
    this.rightInset = getMeasurement(attributes.rightInset, "0");
    this.topInset = getMeasurement(attributes.topInset, "0");
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [$toStyle]() {
    return {
      margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset)
    };
  }
};
var Mdp = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "mdp");
    this.id = attributes.id || "";
    this.permissions = getInteger({
      data: attributes.permissions,
      defaultValue: 2,
      validate: (x) => x === 1 || x === 3
    });
    this.signatureType = getStringOption(attributes.signatureType, ["filler", "author"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Medium = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "medium");
    this.id = attributes.id || "";
    this.imagingBBox = getBBox(attributes.imagingBBox);
    this.long = getMeasurement(attributes.long);
    this.orientation = getStringOption(attributes.orientation, ["portrait", "landscape"]);
    this.short = getMeasurement(attributes.short);
    this.stock = attributes.stock || "";
    this.trayIn = getStringOption(attributes.trayIn, ["auto", "delegate", "pageFront"]);
    this.trayOut = getStringOption(attributes.trayOut, ["auto", "delegate"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Message$1 = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "message",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.text = new XFAObjectArray();
  }
};
var NumericEdit = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "numericEdit",
      /* hasChildren = */
      true
    );
    this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [$toHTML](availableSpace) {
    const style = toStyle(this, "border", "font", "margin");
    const field = this[$getParent]()[$getParent]();
    const html = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: field[$uid],
        dataId: field[$data] && field[$data][$uid] || field[$uid],
        class: ["xfaTextfield"],
        style
      }
    };
    return HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [html]
    });
  }
};
var Occur = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "occur",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.initial = getInteger({
      data: attributes.initial,
      defaultValue: 1,
      validate: (x) => true
    });
    this.max = getInteger({
      data: attributes.max,
      defaultValue: 1,
      validate: (x) => true
    });
    this.min = getInteger({
      data: attributes.min,
      defaultValue: 1,
      validate: (x) => true
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
};
var Oid = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "oid");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Oids = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "oids",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.oid = new XFAObjectArray();
  }
};
var Overflow = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "overflow");
    this.id = attributes.id || "";
    this.leader = attributes.leader || "";
    this.target = attributes.target || "";
    this.trailer = attributes.trailer || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$getExtra]() {
    if (!this[$extra]) {
      const parent = this[$getParent]();
      const root = this[$getTemplateRoot]();
      const target = root[$searchNode](this.target, parent);
      const leader = root[$searchNode](this.leader, parent);
      const trailer = root[$searchNode](this.trailer, parent);
      this[$extra] = {
        target: target && target[0] || null,
        leader: leader && leader[0] || null,
        trailer: trailer && trailer[0] || null,
        addLeader: false,
        addTrailer: false
      };
    }
    return this[$extra];
  }
};
var PageArea = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "pageArea",
      /* hasChildren = */
      true
    );
    this.blankOrNotBlank = getStringOption(attributes.blankOrNotBlank, ["any", "blank", "notBlank"]);
    this.id = attributes.id || "";
    this.initialNumber = getInteger({
      data: attributes.initialNumber,
      defaultValue: 1,
      validate: (x) => true
    });
    this.name = attributes.name || "";
    this.numbered = getInteger({
      data: attributes.numbered,
      defaultValue: 1,
      validate: (x) => true
    });
    this.oddOrEven = getStringOption(attributes.oddOrEven, ["any", "even", "odd"]);
    this.pagePosition = getStringOption(attributes.pagePosition, ["any", "first", "last", "only", "rest"]);
    this.relevant = getRelevant(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.desc = null;
    this.extras = null;
    this.medium = null;
    this.occur = null;
    this.area = new XFAObjectArray();
    this.contentArea = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.subform = new XFAObjectArray();
  }
  [$isUsable]() {
    if (!this[$extra]) {
      this[$extra] = {
        numberOfUse: 0
      };
      return true;
    }
    return !this.occur || this.occur.max === -1 || this[$extra].numberOfUse < this.occur.max;
  }
  [$cleanPage]() {
    delete this[$extra];
  }
  [$getNextPage]() {
    if (!this[$extra]) {
      this[$extra] = {
        numberOfUse: 0
      };
    }
    const parent = this[$getParent]();
    if (parent.relation === "orderedOccurrence") {
      if (this[$isUsable]()) {
        this[$extra].numberOfUse += 1;
        return this;
      }
    }
    return parent[$getNextPage]();
  }
  [$getAvailableSpace]() {
    return this[$extra].space || {
      width: 0,
      height: 0
    };
  }
  [$toHTML]() {
    if (!this[$extra]) {
      this[$extra] = {
        numberOfUse: 1
      };
    }
    const children = [];
    this[$extra].children = children;
    const style = /* @__PURE__ */ Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      style.width = measureToString(this.medium.short);
      style.height = measureToString(this.medium.long);
      this[$extra].space = {
        width: this.medium.short,
        height: this.medium.long
      };
      if (this.medium.orientation === "landscape") {
        const x = style.width;
        style.width = style.height;
        style.height = x;
        this[$extra].space = {
          width: this.medium.long,
          height: this.medium.short
        };
      }
    } else {
      warn("XFA - No medium specified in pageArea: please file a bug.");
    }
    this[$childrenToHTML]({
      filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
      include: true
    });
    this[$childrenToHTML]({
      filter: /* @__PURE__ */ new Set(["contentArea"]),
      include: true
    });
    return HTMLResult.success({
      name: "div",
      children,
      attributes: {
        class: ["xfaPage"],
        id: this[$uid],
        style,
        xfaName: this.name
      }
    });
  }
};
var PageSet = class _PageSet extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "pageSet",
      /* hasChildren = */
      true
    );
    this.duplexImposition = getStringOption(attributes.duplexImposition, ["longEdge", "shortEdge"]);
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relation = getStringOption(attributes.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
    this.relevant = getRelevant(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.occur = null;
    this.pageArea = new XFAObjectArray();
    this.pageSet = new XFAObjectArray();
  }
  [$cleanPage]() {
    for (const page of this.pageArea.children) {
      page[$cleanPage]();
    }
    for (const page of this.pageSet.children) {
      page[$cleanPage]();
    }
  }
  [$isUsable]() {
    return !this.occur || this.occur.max === -1 || this[$extra].numberOfUse < this.occur.max;
  }
  [$getNextPage]() {
    if (!this[$extra]) {
      this[$extra] = {
        numberOfUse: 1,
        pageIndex: -1,
        pageSetIndex: -1
      };
    }
    if (this.relation === "orderedOccurrence") {
      if (this[$extra].pageIndex + 1 < this.pageArea.children.length) {
        this[$extra].pageIndex += 1;
        const pageArea = this.pageArea.children[this[$extra].pageIndex];
        return pageArea[$getNextPage]();
      }
      if (this[$extra].pageSetIndex + 1 < this.pageSet.children.length) {
        this[$extra].pageSetIndex += 1;
        return this.pageSet.children[this[$extra].pageSetIndex][$getNextPage]();
      }
      if (this[$isUsable]()) {
        this[$extra].numberOfUse += 1;
        this[$extra].pageIndex = -1;
        this[$extra].pageSetIndex = -1;
        return this[$getNextPage]();
      }
      const parent = this[$getParent]();
      if (parent instanceof _PageSet) {
        return parent[$getNextPage]();
      }
      this[$cleanPage]();
      return this[$getNextPage]();
    }
    const pageNumber = this[$getTemplateRoot]()[$extra].pageNumber;
    const parity = pageNumber % 2 === 0 ? "even" : "odd";
    const position = pageNumber === 0 ? "first" : "rest";
    let page = this.pageArea.children.find((p) => p.oddOrEven === parity && p.pagePosition === position);
    if (page) {
      return page;
    }
    page = this.pageArea.children.find((p) => p.oddOrEven === "any" && p.pagePosition === position);
    if (page) {
      return page;
    }
    page = this.pageArea.children.find((p) => p.oddOrEven === "any" && p.pagePosition === "any");
    if (page) {
      return page;
    }
    return this.pageArea.children[0];
  }
};
var Para = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "para",
      /* hasChildren = */
      true
    );
    this.hAlign = getStringOption(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.lineHeight = attributes.lineHeight ? getMeasurement(attributes.lineHeight, "0pt") : "";
    this.marginLeft = attributes.marginLeft ? getMeasurement(attributes.marginLeft, "0pt") : "";
    this.marginRight = attributes.marginRight ? getMeasurement(attributes.marginRight, "0pt") : "";
    this.orphans = getInteger({
      data: attributes.orphans,
      defaultValue: 0,
      validate: (x) => x >= 0
    });
    this.preserve = attributes.preserve || "";
    this.radixOffset = attributes.radixOffset ? getMeasurement(attributes.radixOffset, "0pt") : "";
    this.spaceAbove = attributes.spaceAbove ? getMeasurement(attributes.spaceAbove, "0pt") : "";
    this.spaceBelow = attributes.spaceBelow ? getMeasurement(attributes.spaceBelow, "0pt") : "";
    this.tabDefault = attributes.tabDefault ? getMeasurement(this.tabDefault) : "";
    this.tabStops = (attributes.tabStops || "").trim().split(/\s+/).map((x, i) => i % 2 === 1 ? getMeasurement(x) : x);
    this.textIndent = attributes.textIndent ? getMeasurement(attributes.textIndent, "0pt") : "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.vAlign = getStringOption(attributes.vAlign, ["top", "bottom", "middle"]);
    this.widows = getInteger({
      data: attributes.widows,
      defaultValue: 0,
      validate: (x) => x >= 0
    });
    this.hyphenation = null;
  }
  [$toStyle]() {
    const style = toStyle(this, "hAlign");
    if (this.marginLeft !== "") {
      style.paddingLeft = measureToString(this.marginLeft);
    }
    if (this.marginRight !== "") {
      style.paddingight = measureToString(this.marginRight);
    }
    if (this.spaceAbove !== "") {
      style.paddingTop = measureToString(this.spaceAbove);
    }
    if (this.spaceBelow !== "") {
      style.paddingBottom = measureToString(this.spaceBelow);
    }
    if (this.textIndent !== "") {
      style.textIndent = measureToString(this.textIndent);
      fixTextIndent(style);
    }
    if (this.lineHeight > 0) {
      style.lineHeight = measureToString(this.lineHeight);
    }
    if (this.tabDefault !== "") {
      style.tabSize = measureToString(this.tabDefault);
    }
    if (this.tabStops.length > 0)
      ;
    if (this.hyphenatation) {
      Object.assign(style, this.hyphenatation[$toStyle]());
    }
    return style;
  }
};
var PasswordEdit = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "passwordEdit",
      /* hasChildren = */
      true
    );
    this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.passwordChar = attributes.passwordChar || "*";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
};
var Pattern = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "pattern",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [$toStyle](startColor) {
    startColor = startColor ? startColor[$toStyle]() : "#FFFFFF";
    const endColor = this.color ? this.color[$toStyle]() : "#000000";
    const width = 5;
    const cmd = "repeating-linear-gradient";
    const colors = `${startColor},${startColor} ${width}px,${endColor} ${width}px,${endColor} ${2 * width}px`;
    switch (this.type) {
      case "crossHatch":
        return `${cmd}(to top,${colors}) ${cmd}(to right,${colors})`;
      case "crossDiagonal":
        return `${cmd}(45deg,${colors}) ${cmd}(-45deg,${colors})`;
      case "diagonalLeft":
        return `${cmd}(45deg,${colors})`;
      case "diagonalRight":
        return `${cmd}(-45deg,${colors})`;
      case "horizontal":
        return `${cmd}(to top,${colors})`;
      case "vertical":
        return `${cmd}(to right,${colors})`;
    }
    return "";
  }
};
var Picture$1 = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "picture");
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Proto = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "proto",
      /* hasChildren = */
      true
    );
    this.appearanceFilter = new XFAObjectArray();
    this.arc = new XFAObjectArray();
    this.area = new XFAObjectArray();
    this.assist = new XFAObjectArray();
    this.barcode = new XFAObjectArray();
    this.bindItems = new XFAObjectArray();
    this.bookend = new XFAObjectArray();
    this.boolean = new XFAObjectArray();
    this.border = new XFAObjectArray();
    this.break = new XFAObjectArray();
    this.breakAfter = new XFAObjectArray();
    this.breakBefore = new XFAObjectArray();
    this.button = new XFAObjectArray();
    this.calculate = new XFAObjectArray();
    this.caption = new XFAObjectArray();
    this.certificate = new XFAObjectArray();
    this.certificates = new XFAObjectArray();
    this.checkButton = new XFAObjectArray();
    this.choiceList = new XFAObjectArray();
    this.color = new XFAObjectArray();
    this.comb = new XFAObjectArray();
    this.connect = new XFAObjectArray();
    this.contentArea = new XFAObjectArray();
    this.corner = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.dateTimeEdit = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.defaultUi = new XFAObjectArray();
    this.desc = new XFAObjectArray();
    this.digestMethod = new XFAObjectArray();
    this.digestMethods = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.edge = new XFAObjectArray();
    this.encoding = new XFAObjectArray();
    this.encodings = new XFAObjectArray();
    this.encrypt = new XFAObjectArray();
    this.encryptData = new XFAObjectArray();
    this.encryption = new XFAObjectArray();
    this.encryptionMethod = new XFAObjectArray();
    this.encryptionMethods = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.execute = new XFAObjectArray();
    this.extras = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.fill = new XFAObjectArray();
    this.filter = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.font = new XFAObjectArray();
    this.format = new XFAObjectArray();
    this.handler = new XFAObjectArray();
    this.hyphenation = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.imageEdit = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.issuers = new XFAObjectArray();
    this.items = new XFAObjectArray();
    this.keep = new XFAObjectArray();
    this.keyUsage = new XFAObjectArray();
    this.line = new XFAObjectArray();
    this.linear = new XFAObjectArray();
    this.lockDocument = new XFAObjectArray();
    this.manifest = new XFAObjectArray();
    this.margin = new XFAObjectArray();
    this.mdp = new XFAObjectArray();
    this.medium = new XFAObjectArray();
    this.message = new XFAObjectArray();
    this.numericEdit = new XFAObjectArray();
    this.occur = new XFAObjectArray();
    this.oid = new XFAObjectArray();
    this.oids = new XFAObjectArray();
    this.overflow = new XFAObjectArray();
    this.pageArea = new XFAObjectArray();
    this.pageSet = new XFAObjectArray();
    this.para = new XFAObjectArray();
    this.passwordEdit = new XFAObjectArray();
    this.pattern = new XFAObjectArray();
    this.picture = new XFAObjectArray();
    this.radial = new XFAObjectArray();
    this.reason = new XFAObjectArray();
    this.reasons = new XFAObjectArray();
    this.rectangle = new XFAObjectArray();
    this.ref = new XFAObjectArray();
    this.script = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
    this.signData = new XFAObjectArray();
    this.signature = new XFAObjectArray();
    this.signing = new XFAObjectArray();
    this.solid = new XFAObjectArray();
    this.speak = new XFAObjectArray();
    this.stipple = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
    this.subjectDN = new XFAObjectArray();
    this.subjectDNs = new XFAObjectArray();
    this.submit = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.textEdit = new XFAObjectArray();
    this.time = new XFAObjectArray();
    this.timeStamp = new XFAObjectArray();
    this.toolTip = new XFAObjectArray();
    this.traversal = new XFAObjectArray();
    this.traverse = new XFAObjectArray();
    this.ui = new XFAObjectArray();
    this.validate = new XFAObjectArray();
    this.value = new XFAObjectArray();
    this.variables = new XFAObjectArray();
  }
};
var Radial = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "radial",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["toEdge", "toCenter"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [$toStyle](startColor) {
    startColor = startColor ? startColor[$toStyle]() : "#FFFFFF";
    const endColor = this.color ? this.color[$toStyle]() : "#000000";
    const colors = this.type === "toEdge" ? `${startColor},${endColor}` : `${endColor},${startColor}`;
    return `radial-gradient(circle at center, ${colors})`;
  }
};
var Reason = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "reason");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Reasons = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "reasons",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.reason = new XFAObjectArray();
  }
};
var Rectangle = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "rectangle",
      /* hasChildren = */
      true
    );
    this.hand = getStringOption(attributes.hand, ["even", "left", "right"]);
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.corner = new XFAObjectArray(4);
    this.edge = new XFAObjectArray(4);
    this.fill = null;
  }
  [$toHTML]() {
    const edge = this.edge.children.length ? this.edge.children[0] : new Edge({});
    const edgeStyle = edge[$toStyle]();
    const style = /* @__PURE__ */ Object.create(null);
    if (this.fill && this.fill.presence === "visible") {
      Object.assign(style, this.fill[$toStyle]());
    } else {
      style.fill = "transparent";
    }
    style.strokeWidth = measureToString(edge.presence === "visible" ? edge.thickness : 0);
    style.stroke = edgeStyle.color;
    const corner = this.corner.children.length ? this.corner.children[0] : new Corner({});
    const cornerStyle = corner[$toStyle]();
    const rect = {
      name: "rect",
      attributes: {
        xmlns: SVG_NS,
        width: "100%",
        height: "100%",
        x: 0,
        y: 0,
        rx: cornerStyle.radius,
        ry: cornerStyle.radius,
        style
      }
    };
    const svg = {
      name: "svg",
      children: [rect],
      attributes: {
        xmlns: SVG_NS,
        style: {
          overflow: "visible"
        },
        width: "100%",
        height: "100%"
      }
    };
    const parent = this[$getParent]()[$getParent]();
    if (hasMargin(parent)) {
      return HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [svg]
      });
    }
    svg.attributes.style.position = "absolute";
    return HTMLResult.success(svg);
  }
};
var RefElement = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "ref");
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Script$1 = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "script");
    this.binding = attributes.binding || "";
    this.contentType = attributes.contentType || "";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.runAt = getStringOption(attributes.runAt, ["client", "both", "server"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var SetProperty = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "setProperty");
    this.connection = attributes.connection || "";
    this.ref = attributes.ref || "";
    this.target = attributes.target || "";
  }
};
var SignData = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "signData",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.operation = getStringOption(attributes.operation, ["sign", "clear", "verify"]);
    this.ref = attributes.ref || "";
    this.target = attributes.target || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
};
var Signature$1 = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "signature",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["PDF1.3", "PDF1.6"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.border = null;
    this.extras = null;
    this.filter = null;
    this.manifest = null;
    this.margin = null;
  }
};
var Signing = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "signing",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.certificate = new XFAObjectArray();
  }
};
var Solid = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "solid",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
  }
  [$toStyle](startColor) {
    return startColor ? startColor[$toStyle]() : "#FFFFFF";
  }
};
var Speak = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "speak");
    this.disable = getInteger({
      data: attributes.disable,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.id = attributes.id || "";
    this.priority = getStringOption(attributes.priority, ["custom", "caption", "name", "toolTip"]);
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Stipple = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "stipple",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.rate = getInteger({
      data: attributes.rate,
      defaultValue: 50,
      validate: (x) => x >= 0 && x <= 100
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [$toStyle](bgColor) {
    const alpha = this.rate / 100;
    return Util.makeHexColor(Math.round(bgColor.value.r * (1 - alpha) + this.value.r * alpha), Math.round(bgColor.value.g * (1 - alpha) + this.value.g * alpha), Math.round(bgColor.value.b * (1 - alpha) + this.value.b * alpha));
  }
};
var Subform = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "subform",
      /* hasChildren = */
      true
    );
    this.access = getStringOption(attributes.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.allowMacro = getInteger({
      data: attributes.allowMacro,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.anchorType = getStringOption(attributes.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({
      data: attributes.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    });
    this.columnWidths = (attributes.columnWidths || "").trim().split(/\s+/).map((x) => x === "-1" ? -1 : getMeasurement(x));
    this.h = attributes.h ? getMeasurement(attributes.h) : "";
    this.hAlign = getStringOption(attributes.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = attributes.id || "";
    this.layout = getStringOption(attributes.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.locale = attributes.locale || "";
    this.maxH = getMeasurement(attributes.maxH, "0pt");
    this.maxW = getMeasurement(attributes.maxW, "0pt");
    this.mergeMode = getStringOption(attributes.mergeMode, ["consumeData", "matchTemplate"]);
    this.minH = getMeasurement(attributes.minH, "0pt");
    this.minW = getMeasurement(attributes.minW, "0pt");
    this.name = attributes.name || "";
    this.presence = getStringOption(attributes.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(attributes.relevant);
    this.restoreState = getStringOption(attributes.restoreState, ["manual", "auto"]);
    this.scope = getStringOption(attributes.scope, ["name", "none"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.w = attributes.w ? getMeasurement(attributes.w) : "";
    this.x = getMeasurement(attributes.x, "0pt");
    this.y = getMeasurement(attributes.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.bookend = null;
    this.border = null;
    this.break = null;
    this.calculate = null;
    this.desc = null;
    this.extras = null;
    this.keep = null;
    this.margin = null;
    this.occur = null;
    this.overflow = null;
    this.pageSet = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.variables = null;
    this.area = new XFAObjectArray();
    this.breakAfter = new XFAObjectArray();
    this.breakBefore = new XFAObjectArray();
    this.connect = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.proto = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
  }
  [$getSubformParent]() {
    const parent = this[$getParent]();
    if (parent instanceof SubformSet) {
      return parent[$getSubformParent]();
    }
    return parent;
  }
  [$isBindable]() {
    return true;
  }
  [$isThereMoreWidth]() {
    return this.layout.endsWith("-tb") && this[$extra].attempt === 0 && this[$extra].numberInLine > 0 || this[$getParent]()[$isThereMoreWidth]();
  }
  *[$getContainedChildren]() {
    yield* getContainedChildren(this);
  }
  [$flushHTML]() {
    return flushHTML(this);
  }
  [$addHTML](html, bbox) {
    addHTML(this, html, bbox);
  }
  [$getAvailableSpace]() {
    return getAvailableSpace(this);
  }
  [$isSplittable]() {
    const parent = this[$getSubformParent]();
    if (!parent[$isSplittable]()) {
      return false;
    }
    const contentArea = this[$getTemplateRoot]()[$extra].currentContentArea;
    if (this.overflow && this.overflow[$getExtra]().target === contentArea) {
      return false;
    }
    if (this[$extra]._isSplittable !== void 0) {
      return this[$extra]._isSplittable;
    }
    if (this.layout === "position" || this.layout.includes("row")) {
      this[$extra]._isSplittable = false;
      return false;
    }
    if (this.keep && this.keep.intact !== "none") {
      this[$extra]._isSplittable = false;
      return false;
    }
    if (parent.layout && parent.layout.endsWith("-tb") && parent[$extra].numberInLine !== 0) {
      return false;
    }
    this[$extra]._isSplittable = true;
    return true;
  }
  [$toHTML](availableSpace) {
    if (this.break) {
      if (this.break.after !== "auto" || this.break.afterTarget !== "") {
        const node = new BreakAfter({
          targetType: this.break.after,
          target: this.break.afterTarget,
          startNew: this.break.startNew.toString()
        });
        node[$globalData] = this[$globalData];
        this[$appendChild](node);
        this.breakAfter.push(node);
      }
      if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
        const node = new BreakBefore({
          targetType: this.break.before,
          target: this.break.beforeTarget,
          startNew: this.break.startNew.toString()
        });
        node[$globalData] = this[$globalData];
        this[$appendChild](node);
        this.breakBefore.push(node);
      }
      if (this.break.overflowTarget !== "") {
        const node = new Overflow({
          target: this.break.overflowTarget,
          leader: this.break.overflowLeader,
          trailer: this.break.overflowTrailer
        });
        node[$globalData] = this[$globalData];
        this[$appendChild](node);
        this.overflow.push(node);
      }
      this[$removeChild](this.break);
      this.break = null;
    }
    if (this.presence === "hidden" || this.presence === "inactive") {
      return HTMLResult.EMPTY;
    }
    if (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) {
      warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
    }
    if (this.breakBefore.children.length >= 1) {
      const breakBefore = this.breakBefore.children[0];
      if (handleBreak(breakBefore)) {
        return HTMLResult.breakNode(breakBefore);
      }
    }
    if (this[$extra] && this[$extra].afterBreakAfter) {
      return HTMLResult.EMPTY;
    }
    fixDimensions(this);
    const children = [];
    const attributes = {
      id: this[$uid],
      class: []
    };
    setAccess(this, attributes.class);
    if (!this[$extra]) {
      this[$extra] = /* @__PURE__ */ Object.create(null);
    }
    Object.assign(this[$extra], {
      children,
      line: null,
      attributes,
      attempt: 0,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || Infinity, availableSpace.width),
        height: Math.min(this.h || Infinity, availableSpace.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const root = this[$getTemplateRoot]();
    const currentContentArea = root[$extra].currentContentArea;
    const savedNoLayoutFailure = root[$extra].noLayoutFailure;
    if (this.overflow) {
      root[$extra].noLayoutFailure = root[$extra].noLayoutFailure || this.overflow[$getExtra]().target === currentContentArea;
    }
    const isSplittable = this[$isSplittable]();
    if (!isSplittable) {
      setFirstUnsplittable(this);
    }
    if (!checkDimensions(this, availableSpace)) {
      return HTMLResult.FAILURE;
    }
    const filter = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const columnWidths = this[$getSubformParent]().columnWidths;
      if (Array.isArray(columnWidths) && columnWidths.length > 0) {
        this[$extra].columnWidths = columnWidths;
        this[$extra].currentColumn = 0;
      }
    }
    const style = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign");
    const classNames = ["xfaSubform"];
    const cl = layoutClass(this);
    if (cl) {
      classNames.push(cl);
    }
    attributes.style = style;
    attributes.class = classNames;
    if (this.name) {
      attributes.xfaName = this.name;
    }
    if (this.overflow) {
      const overflowExtra = this.overflow[$getExtra]();
      if (overflowExtra.addLeader) {
        overflowExtra.addLeader = false;
        handleOverflow(this, overflowExtra.leader, availableSpace);
      }
    }
    const isLrTb = this.layout === "lr-tb" || this.layout === "rl-tb";
    const maxRun = isLrTb ? MAX_ATTEMPTS_FOR_LRTB_LAYOUT : 1;
    for (; this[$extra].attempt < maxRun; this[$extra].attempt++) {
      if (isLrTb && this[$extra].attempt === MAX_ATTEMPTS_FOR_LRTB_LAYOUT - 1) {
        this[$extra].numberInLine = 0;
      }
      const result2 = this[$childrenToHTML]({
        filter,
        include: true
      });
      if (result2.success) {
        break;
      }
      if (result2.isBreak()) {
        return result2;
      }
      if (isLrTb && this[$extra].attempt === 0 && this[$extra].numberInLine === 0 && !root[$extra].noLayoutFailure) {
        this[$extra].attempt = maxRun;
        break;
      }
    }
    if (!isSplittable) {
      unsetFirstUnsplittable(this);
    }
    root[$extra].noLayoutFailure = savedNoLayoutFailure;
    if (this[$extra].attempt === maxRun) {
      if (this.overflow) {
        this[$getTemplateRoot]()[$extra].overflowNode = this.overflow;
      }
      if (!isSplittable) {
        delete this[$extra];
      }
      return HTMLResult.FAILURE;
    }
    if (this.overflow) {
      const overflowExtra = this.overflow[$getExtra]();
      if (overflowExtra.addTrailer) {
        overflowExtra.addTrailer = false;
        handleOverflow(this, overflowExtra.trailer, availableSpace);
      }
    }
    let marginH = 0;
    let marginV = 0;
    if (this.margin) {
      marginH = this.margin.leftInset + this.margin.rightInset;
      marginV = this.margin.topInset + this.margin.bottomInset;
    }
    const width = Math.max(this[$extra].width + marginH, this.w || 0);
    const height = Math.max(this[$extra].height + marginV, this.h || 0);
    const bbox = [this.x, this.y, width, height];
    if (this.w === "") {
      style.width = measureToString(width);
    }
    if (this.h === "") {
      style.height = measureToString(height);
    }
    const html = {
      name: "div",
      attributes,
      children
    };
    const assist = this.assist ? this.assist[$toHTML]() : null;
    if (assist) {
      html.attributes.title = assist;
    }
    const result = HTMLResult.success(createWrapper(this, html), bbox);
    if (this.breakAfter.children.length >= 1) {
      const breakAfter = this.breakAfter.children[0];
      if (handleBreak(breakAfter)) {
        this[$extra].afterBreakAfter = result;
        return HTMLResult.breakNode(breakAfter);
      }
    }
    delete this[$extra];
    return result;
  }
};
var SubformSet = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "subformSet",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.relation = getStringOption(attributes.relation, ["ordered", "choice", "unordered"]);
    this.relevant = getRelevant(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.bookend = null;
    this.break = null;
    this.desc = null;
    this.extras = null;
    this.occur = null;
    this.overflow = null;
    this.breakAfter = new XFAObjectArray();
    this.breakBefore = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
  }
  *[$getContainedChildren]() {
    yield* getContainedChildren(this);
  }
  [$getSubformParent]() {
    let parent = this[$getParent]();
    while (!(parent instanceof Subform)) {
      parent = parent[$getParent]();
    }
    return parent;
  }
};
var SubjectDN = class extends ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "subjectDN");
    this.delimiter = attributes.delimiter || ",";
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$finalize]() {
    this[$content] = new Map(this[$content].split(this.delimiter).map((kv) => {
      kv = kv.split("=", 2);
      kv[0] = kv[0].trim();
      return kv;
    }));
  }
};
var SubjectDNs = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "subjectDNs",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.subjectDN = new XFAObjectArray();
  }
};
var Submit = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "submit",
      /* hasChildren = */
      true
    );
    this.embedPDF = getInteger({
      data: attributes.embedPDF,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.format = getStringOption(attributes.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
    this.id = attributes.id || "";
    this.target = attributes.target || "";
    this.textEncoding = getKeyword({
      data: attributes.textEncoding ? attributes.textEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: (k) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(k) || k.match(/iso-8859-[0-9]{2}/)
    });
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.xdpContent = attributes.xdpContent || "";
    this.encrypt = null;
    this.encryptData = new XFAObjectArray();
    this.signData = new XFAObjectArray();
  }
};
var Template$1 = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "template",
      /* hasChildren = */
      true
    );
    this.baseProfile = getStringOption(attributes.baseProfile, ["full", "interactiveForms"]);
    this.extras = null;
    this.subform = new XFAObjectArray();
  }
  [$finalize]() {
    if (this.subform.children.length === 0) {
      warn("XFA - No subforms in template node.");
    }
    if (this.subform.children.length >= 2) {
      warn("XFA - Several subforms in template node: please file a bug.");
    }
    this[$tabIndex] = 1e3;
  }
  [$isSplittable]() {
    return true;
  }
  [$searchNode](expr, container) {
    if (expr.startsWith("#")) {
      return [this[$ids].get(expr.slice(1))];
    }
    return searchNode(this, container, expr, true, true);
  }
  [$toHTML]() {
    if (!this.subform.children.length) {
      return HTMLResult.success({
        name: "div",
        children: []
      });
    }
    this[$extra] = {
      overflowNode: null,
      firstUnsplittable: null,
      currentContentArea: null,
      currentPageArea: null,
      noLayoutFailure: false,
      pageNumber: 1,
      pagePosition: "first",
      oddOrEven: "odd",
      blankOrNotBlank: "nonBlank"
    };
    const root = this.subform.children[0];
    root.pageSet[$cleanPage]();
    const pageAreas = root.pageSet.pageArea.children;
    const mainHtml = {
      name: "div",
      children: []
    };
    let pageArea = null;
    let breakBefore = null;
    let breakBeforeTarget = null;
    if (root.breakBefore.children.length >= 1) {
      breakBefore = root.breakBefore.children[0];
      breakBeforeTarget = breakBefore.target;
    } else if (root.subform.children.length >= 1 && root.subform.children[0].breakBefore.children.length >= 1) {
      breakBefore = root.subform.children[0].breakBefore.children[0];
      breakBeforeTarget = breakBefore.target;
    } else if (root.break && root.break.beforeTarget) {
      breakBefore = root.break;
      breakBeforeTarget = breakBefore.beforeTarget;
    } else if (root.subform.children.length >= 1 && root.subform.children[0].break && root.subform.children[0].break.beforeTarget) {
      breakBefore = root.subform.children[0].break;
      breakBeforeTarget = breakBefore.beforeTarget;
    }
    if (breakBefore) {
      const target = this[$searchNode](breakBeforeTarget, breakBefore[$getParent]());
      if (target instanceof PageArea) {
        pageArea = target;
        breakBefore[$extra] = {};
      }
    }
    if (!pageArea) {
      pageArea = pageAreas[0];
    }
    pageArea[$extra] = {
      numberOfUse: 1
    };
    const pageAreaParent = pageArea[$getParent]();
    pageAreaParent[$extra] = {
      numberOfUse: 1,
      pageIndex: pageAreaParent.pageArea.children.indexOf(pageArea),
      pageSetIndex: 0
    };
    let targetPageArea;
    let leader = null;
    let trailer = null;
    let hasSomething = true;
    let hasSomethingCounter = 0;
    let startIndex = 0;
    while (true) {
      if (!hasSomething) {
        mainHtml.children.pop();
        if (++hasSomethingCounter === MAX_EMPTY_PAGES) {
          warn("XFA - Something goes wrong: please file a bug.");
          return mainHtml;
        }
      } else {
        hasSomethingCounter = 0;
      }
      targetPageArea = null;
      this[$extra].currentPageArea = pageArea;
      const page = pageArea[$toHTML]().html;
      mainHtml.children.push(page);
      if (leader) {
        this[$extra].noLayoutFailure = true;
        page.children.push(leader[$toHTML](pageArea[$extra].space).html);
        leader = null;
      }
      if (trailer) {
        this[$extra].noLayoutFailure = true;
        page.children.push(trailer[$toHTML](pageArea[$extra].space).html);
        trailer = null;
      }
      const contentAreas = pageArea.contentArea.children;
      const htmlContentAreas = page.children.filter((node) => node.attributes.class.includes("xfaContentarea"));
      hasSomething = false;
      this[$extra].firstUnsplittable = null;
      this[$extra].noLayoutFailure = false;
      const flush = (index) => {
        const html = root[$flushHTML]();
        if (html) {
          hasSomething = hasSomething || html.children && html.children.length !== 0;
          htmlContentAreas[index].children.push(html);
        }
      };
      for (let i = startIndex, ii = contentAreas.length; i < ii; i++) {
        const contentArea = this[$extra].currentContentArea = contentAreas[i];
        const space = {
          width: contentArea.w,
          height: contentArea.h
        };
        startIndex = 0;
        if (leader) {
          htmlContentAreas[i].children.push(leader[$toHTML](space).html);
          leader = null;
        }
        if (trailer) {
          htmlContentAreas[i].children.push(trailer[$toHTML](space).html);
          trailer = null;
        }
        const html = root[$toHTML](space);
        if (html.success) {
          if (html.html) {
            hasSomething = hasSomething || html.html.children && html.html.children.length !== 0;
            htmlContentAreas[i].children.push(html.html);
          } else if (!hasSomething) {
            mainHtml.children.pop();
          }
          return mainHtml;
        }
        if (html.isBreak()) {
          const node = html.breakNode;
          flush(i);
          if (node.targetType === "auto") {
            continue;
          }
          if (node.leader) {
            leader = this[$searchNode](node.leader, node[$getParent]());
            leader = leader ? leader[0] : null;
          }
          if (node.trailer) {
            trailer = this[$searchNode](node.trailer, node[$getParent]());
            trailer = trailer ? trailer[0] : null;
          }
          if (node.targetType === "pageArea") {
            targetPageArea = node[$extra].target;
            i = Infinity;
          } else if (!node[$extra].target) {
            i = node[$extra].index;
          } else {
            targetPageArea = node[$extra].target;
            startIndex = node[$extra].index + 1;
            i = Infinity;
          }
          continue;
        }
        if (this[$extra].overflowNode) {
          const node = this[$extra].overflowNode;
          this[$extra].overflowNode = null;
          const overflowExtra = node[$getExtra]();
          const target = overflowExtra.target;
          overflowExtra.addLeader = overflowExtra.leader !== null;
          overflowExtra.addTrailer = overflowExtra.trailer !== null;
          flush(i);
          i = Infinity;
          if (target instanceof PageArea) {
            targetPageArea = target;
          } else if (target instanceof ContentArea) {
            const index = contentAreas.findIndex((e) => e === target);
            if (index !== -1) {
              i = index - 1;
            } else {
              targetPageArea = target[$getParent]();
              startIndex = targetPageArea.contentArea.children.findIndex((e) => e === target);
            }
          }
          continue;
        }
        flush(i);
      }
      this[$extra].pageNumber += 1;
      if (targetPageArea) {
        if (targetPageArea[$isUsable]()) {
          targetPageArea[$extra].numberOfUse += 1;
        } else {
          targetPageArea = null;
        }
      }
      pageArea = targetPageArea || pageArea[$getNextPage]();
    }
  }
};
var Text = class extends ContentObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "text");
    this.id = attributes.id || "";
    this.maxChars = getInteger({
      data: attributes.maxChars,
      defaultValue: 0,
      validate: (x) => x >= 0
    });
    this.name = attributes.name || "";
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$acceptWhitespace]() {
    return true;
  }
  [$onChild](child) {
    if (child[$namespaceId] === NamespaceIds.xhtml.id) {
      this[$content] = child;
      return true;
    }
    warn(`XFA - Invalid content in Text: ${child[$nodeName]}.`);
    return false;
  }
  [$onText](str) {
    if (this[$content] instanceof XFAObject) {
      return;
    }
    super[$onText](str);
  }
  [$toHTML](availableSpace) {
    if (typeof this[$content] === "string") {
      const html = valueToHtml(this[$content]).html;
      if (this[$content].includes("\u2029")) {
        html.name = "div";
        html.children = [];
        this[$content].split("\u2029").map((para) => (
          // Convert a paragraph into a set of <span> (for lines)
          // separated by <br>.
          para.split(/[\u2028\n]/).reduce((acc, line) => {
            acc.push({
              name: "span",
              value: line
            }, {
              name: "br"
            });
            return acc;
          }, [])
        )).forEach((lines) => {
          html.children.push({
            name: "p",
            children: lines
          });
        });
      } else if (/[\u2028\n]/.test(this[$content])) {
        html.name = "div";
        html.children = [];
        this[$content].split(/[\u2028\n]/).forEach((line) => {
          html.children.push({
            name: "span",
            value: line
          }, {
            name: "br"
          });
        });
      }
      return HTMLResult.success(html);
    }
    return this[$content][$toHTML](availableSpace);
  }
};
var TextEdit = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "textEdit",
      /* hasChildren = */
      true
    );
    this.allowRichText = getInteger({
      data: attributes.allowRichText,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.hScrollPolicy = getStringOption(attributes.hScrollPolicy, ["auto", "off", "on"]);
    this.id = attributes.id || "";
    this.multiLine = attributes.multiLine || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.vScrollPolicy = getStringOption(attributes.vScrollPolicy, ["auto", "off", "on"]);
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [$clean](builder) {
    super[$clean](builder);
    const parent = this[$getParent]();
    const defaultValue = parent instanceof Draw ? 1 : 0;
    this.multiLine = getInteger({
      data: this.multiLine,
      defaultValue,
      validate: (x) => x === 0 || x === 1
    });
  }
  [$toHTML](availableSpace) {
    const style = toStyle(this, "border", "font", "margin");
    let html;
    const field = this[$getParent]()[$getParent]();
    if (this.multiLine === 1) {
      html = {
        name: "textarea",
        attributes: {
          dataId: field[$data] && field[$data][$uid] || field[$uid],
          fieldId: field[$uid],
          class: ["xfaTextfield"],
          style
        }
      };
    } else {
      html = {
        name: "input",
        attributes: {
          type: "text",
          dataId: field[$data] && field[$data][$uid] || field[$uid],
          fieldId: field[$uid],
          class: ["xfaTextfield"],
          style
        }
      };
    }
    return HTMLResult.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [html]
    });
  }
};
var Time = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "time");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
  [$finalize]() {
    const date = this[$content].trim();
    this[$content] = date ? new Date(date) : null;
  }
  [$toHTML](availableSpace) {
    return valueToHtml(this[$content] ? this[$content].toString() : "");
  }
};
var TimeStamp = class extends XFAObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "timeStamp");
    this.id = attributes.id || "";
    this.server = attributes.server || "";
    this.type = getStringOption(attributes.type, ["optional", "required"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var ToolTip = class extends StringObject {
  constructor(attributes) {
    super(TEMPLATE_NS_ID, "toolTip");
    this.id = attributes.id || "";
    this.rid = attributes.rid || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Traversal = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "traversal",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.traverse = new XFAObjectArray();
  }
};
var Traverse = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "traverse",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.operation = getStringOption(attributes.operation, ["next", "back", "down", "first", "left", "right", "up"]);
    this.ref = attributes.ref || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.script = null;
  }
  get name() {
    return this.operation;
  }
  [$isTransparent]() {
    return false;
  }
};
var Ui = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "ui",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.picture = null;
    this.barcode = null;
    this.button = null;
    this.checkButton = null;
    this.choiceList = null;
    this.dateTimeEdit = null;
    this.defaultUi = null;
    this.imageEdit = null;
    this.numericEdit = null;
    this.passwordEdit = null;
    this.signature = null;
    this.textEdit = null;
  }
  [$toHTML](availableSpace) {
    for (const name of Object.getOwnPropertyNames(this)) {
      if (name === "extras" || name === "picture") {
        continue;
      }
      const obj = this[name];
      if (!(obj instanceof XFAObject)) {
        continue;
      }
      return obj[$toHTML](availableSpace);
    }
    return HTMLResult.EMPTY;
  }
};
var Validate$1 = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "validate",
      /* hasChildren = */
      true
    );
    this.formatTest = getStringOption(attributes.formatTest, ["warning", "disabled", "error"]);
    this.id = attributes.id || "";
    this.nullTest = getStringOption(attributes.nullTest, ["disabled", "error", "warning"]);
    this.scriptTest = getStringOption(attributes.scriptTest, ["error", "disabled", "warning"]);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.extras = null;
    this.message = null;
    this.picture = null;
    this.script = null;
  }
};
var Value = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "value",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.override = getInteger({
      data: attributes.override,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.relevant = getRelevant(attributes.relevant);
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.arc = null;
    this.boolean = null;
    this.date = null;
    this.dateTime = null;
    this.decimal = null;
    this.exData = null;
    this.float = null;
    this.image = null;
    this.integer = null;
    this.line = null;
    this.rectangle = null;
    this.text = null;
    this.time = null;
  }
  [$setValue](value) {
    const parent = this[$getParent]();
    if (parent instanceof Field) {
      if (parent.ui && parent.ui.imageEdit) {
        if (!this.image) {
          this.image = new Image({});
        }
        this.image[$content] = value[$content];
        return;
      }
    }
    const valueName = value[$nodeName];
    if (this[valueName] !== null) {
      this[valueName][$content] = value[$content];
      return;
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      const obj = this[name];
      if (obj instanceof XFAObject) {
        this[name] = null;
        this[$removeChild](obj);
      }
    }
    this[value[$nodeName]] = value;
    this[$appendChild](value);
  }
  [$text]() {
    if (this.exData) {
      return this.exData[$content][$text]().trim();
    }
    for (const name of Object.getOwnPropertyNames(this)) {
      if (name === "image") {
        continue;
      }
      const obj = this[name];
      if (obj instanceof XFAObject) {
        return (obj[$content] || "").toString().trim();
      }
    }
    return null;
  }
  [$toHTML](availableSpace) {
    for (const name of Object.getOwnPropertyNames(this)) {
      const obj = this[name];
      if (!(obj instanceof XFAObject)) {
        continue;
      }
      return obj[$toHTML](availableSpace);
    }
    return HTMLResult.EMPTY;
  }
};
var Variables = class extends XFAObject {
  constructor(attributes) {
    super(
      TEMPLATE_NS_ID,
      "variables",
      /* hasChildren = */
      true
    );
    this.id = attributes.id || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.manifest = new XFAObjectArray();
    this.script = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
  [$isTransparent]() {
    return true;
  }
};
var TemplateNamespace = class _TemplateNamespace {
  static [$buildXFAObject](name, attributes) {
    if (_TemplateNamespace.hasOwnProperty(name)) {
      const node = _TemplateNamespace[name](attributes);
      node[$setSetAttributes](attributes);
      return node;
    }
    return void 0;
  }
  static appearanceFilter(attrs) {
    return new AppearanceFilter(attrs);
  }
  static arc(attrs) {
    return new Arc(attrs);
  }
  static area(attrs) {
    return new Area$1(attrs);
  }
  static assist(attrs) {
    return new Assist(attrs);
  }
  static barcode(attrs) {
    return new Barcode(attrs);
  }
  static bind(attrs) {
    return new Bind(attrs);
  }
  static bindItems(attrs) {
    return new BindItems(attrs);
  }
  static bookend(attrs) {
    return new Bookend(attrs);
  }
  static boolean(attrs) {
    return new BooleanElement(attrs);
  }
  static border(attrs) {
    return new Border(attrs);
  }
  static break(attrs) {
    return new Break(attrs);
  }
  static breakAfter(attrs) {
    return new BreakAfter(attrs);
  }
  static breakBefore(attrs) {
    return new BreakBefore(attrs);
  }
  static button(attrs) {
    return new Button(attrs);
  }
  static calculate(attrs) {
    return new Calculate(attrs);
  }
  static caption(attrs) {
    return new Caption(attrs);
  }
  static certificate(attrs) {
    return new Certificate(attrs);
  }
  static certificates(attrs) {
    return new Certificates(attrs);
  }
  static checkButton(attrs) {
    return new CheckButton(attrs);
  }
  static choiceList(attrs) {
    return new ChoiceList(attrs);
  }
  static color(attrs) {
    return new Color(attrs);
  }
  static comb(attrs) {
    return new Comb(attrs);
  }
  static connect(attrs) {
    return new Connect(attrs);
  }
  static contentArea(attrs) {
    return new ContentArea(attrs);
  }
  static corner(attrs) {
    return new Corner(attrs);
  }
  static date(attrs) {
    return new DateElement(attrs);
  }
  static dateTime(attrs) {
    return new DateTime(attrs);
  }
  static dateTimeEdit(attrs) {
    return new DateTimeEdit(attrs);
  }
  static decimal(attrs) {
    return new Decimal(attrs);
  }
  static defaultUi(attrs) {
    return new DefaultUi(attrs);
  }
  static desc(attrs) {
    return new Desc(attrs);
  }
  static digestMethod(attrs) {
    return new DigestMethod(attrs);
  }
  static digestMethods(attrs) {
    return new DigestMethods(attrs);
  }
  static draw(attrs) {
    return new Draw(attrs);
  }
  static edge(attrs) {
    return new Edge(attrs);
  }
  static encoding(attrs) {
    return new Encoding(attrs);
  }
  static encodings(attrs) {
    return new Encodings(attrs);
  }
  static encrypt(attrs) {
    return new Encrypt$1(attrs);
  }
  static encryptData(attrs) {
    return new EncryptData(attrs);
  }
  static encryption(attrs) {
    return new Encryption$1(attrs);
  }
  static encryptionMethod(attrs) {
    return new EncryptionMethod(attrs);
  }
  static encryptionMethods(attrs) {
    return new EncryptionMethods(attrs);
  }
  static event(attrs) {
    return new Event(attrs);
  }
  static exData(attrs) {
    return new ExData(attrs);
  }
  static exObject(attrs) {
    return new ExObject(attrs);
  }
  static exclGroup(attrs) {
    return new ExclGroup(attrs);
  }
  static execute(attrs) {
    return new Execute(attrs);
  }
  static extras(attrs) {
    return new Extras(attrs);
  }
  static field(attrs) {
    return new Field(attrs);
  }
  static fill(attrs) {
    return new Fill(attrs);
  }
  static filter(attrs) {
    return new Filter(attrs);
  }
  static float(attrs) {
    return new Float(attrs);
  }
  static font(attrs) {
    return new Font(attrs);
  }
  static format(attrs) {
    return new Format(attrs);
  }
  static handler(attrs) {
    return new Handler(attrs);
  }
  static hyphenation(attrs) {
    return new Hyphenation(attrs);
  }
  static image(attrs) {
    return new Image(attrs);
  }
  static imageEdit(attrs) {
    return new ImageEdit(attrs);
  }
  static integer(attrs) {
    return new Integer(attrs);
  }
  static issuers(attrs) {
    return new Issuers(attrs);
  }
  static items(attrs) {
    return new Items(attrs);
  }
  static keep(attrs) {
    return new Keep(attrs);
  }
  static keyUsage(attrs) {
    return new KeyUsage(attrs);
  }
  static line(attrs) {
    return new Line(attrs);
  }
  static linear(attrs) {
    return new Linear(attrs);
  }
  static lockDocument(attrs) {
    return new LockDocument(attrs);
  }
  static manifest(attrs) {
    return new Manifest(attrs);
  }
  static margin(attrs) {
    return new Margin(attrs);
  }
  static mdp(attrs) {
    return new Mdp(attrs);
  }
  static medium(attrs) {
    return new Medium(attrs);
  }
  static message(attrs) {
    return new Message$1(attrs);
  }
  static numericEdit(attrs) {
    return new NumericEdit(attrs);
  }
  static occur(attrs) {
    return new Occur(attrs);
  }
  static oid(attrs) {
    return new Oid(attrs);
  }
  static oids(attrs) {
    return new Oids(attrs);
  }
  static overflow(attrs) {
    return new Overflow(attrs);
  }
  static pageArea(attrs) {
    return new PageArea(attrs);
  }
  static pageSet(attrs) {
    return new PageSet(attrs);
  }
  static para(attrs) {
    return new Para(attrs);
  }
  static passwordEdit(attrs) {
    return new PasswordEdit(attrs);
  }
  static pattern(attrs) {
    return new Pattern(attrs);
  }
  static picture(attrs) {
    return new Picture$1(attrs);
  }
  static proto(attrs) {
    return new Proto(attrs);
  }
  static radial(attrs) {
    return new Radial(attrs);
  }
  static reason(attrs) {
    return new Reason(attrs);
  }
  static reasons(attrs) {
    return new Reasons(attrs);
  }
  static rectangle(attrs) {
    return new Rectangle(attrs);
  }
  static ref(attrs) {
    return new RefElement(attrs);
  }
  static script(attrs) {
    return new Script$1(attrs);
  }
  static setProperty(attrs) {
    return new SetProperty(attrs);
  }
  static signData(attrs) {
    return new SignData(attrs);
  }
  static signature(attrs) {
    return new Signature$1(attrs);
  }
  static signing(attrs) {
    return new Signing(attrs);
  }
  static solid(attrs) {
    return new Solid(attrs);
  }
  static speak(attrs) {
    return new Speak(attrs);
  }
  static stipple(attrs) {
    return new Stipple(attrs);
  }
  static subform(attrs) {
    return new Subform(attrs);
  }
  static subformSet(attrs) {
    return new SubformSet(attrs);
  }
  static subjectDN(attrs) {
    return new SubjectDN(attrs);
  }
  static subjectDNs(attrs) {
    return new SubjectDNs(attrs);
  }
  static submit(attrs) {
    return new Submit(attrs);
  }
  static template(attrs) {
    return new Template$1(attrs);
  }
  static text(attrs) {
    return new Text(attrs);
  }
  static textEdit(attrs) {
    return new TextEdit(attrs);
  }
  static time(attrs) {
    return new Time(attrs);
  }
  static timeStamp(attrs) {
    return new TimeStamp(attrs);
  }
  static toolTip(attrs) {
    return new ToolTip(attrs);
  }
  static traversal(attrs) {
    return new Traversal(attrs);
  }
  static traverse(attrs) {
    return new Traverse(attrs);
  }
  static ui(attrs) {
    return new Ui(attrs);
  }
  static validate(attrs) {
    return new Validate$1(attrs);
  }
  static value(attrs) {
    return new Value(attrs);
  }
  static variables(attrs) {
    return new Variables(attrs);
  }
};
function createText(content) {
  const node = new Text({});
  node[$content] = content;
  return node;
}
var Binder = class {
  constructor(root) {
    this.root = root;
    this.datasets = root.datasets;
    if (root.datasets && root.datasets.data) {
      this.data = root.datasets.data;
    } else {
      this.data = new XmlObject(NamespaceIds.datasets.id, "data");
    }
    this.emptyMerge = this.data[$getChildren]().length === 0;
    this.root.form = this.form = root.template[$clone]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    this._bindElement(this.form, this.data);
    return this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(formNode, data, picture) {
    formNode[$data] = data;
    if (formNode[$hasSettableValue]()) {
      if (data[$isDataValue]()) {
        const value = data[$getDataValue]();
        formNode[$setValue](createText(value));
      } else if (formNode instanceof Field && formNode.ui && formNode.ui.choiceList && formNode.ui.choiceList.open === "multiSelect") {
        const value = data[$getChildren]().map((child) => child[$content].trim()).join("\n");
        formNode[$setValue](createText(value));
      } else if (this._isConsumeData()) {
        warn(`XFA - Nodes haven't the same type.`);
      }
    } else if (!data[$isDataValue]() || this._isMatchTemplate()) {
      this._bindElement(formNode, data);
    } else {
      warn(`XFA - Nodes haven't the same type.`);
    }
  }
  _findDataByNameToConsume(name, isValue, dataNode, global) {
    if (!name) {
      return null;
    }
    let generator, match;
    for (let i = 0; i < 3; i++) {
      generator = dataNode[$getRealChildrenByNameIt](
        name,
        /* allTransparent = */
        false,
        /* skipConsumed = */
        true
      );
      while (true) {
        match = generator.next().value;
        if (!match) {
          break;
        }
        if (isValue === match[$isDataValue]()) {
          return match;
        }
      }
      if (dataNode[$namespaceId] === NamespaceIds.datasets.id && dataNode[$nodeName] === "data") {
        break;
      }
      dataNode = dataNode[$getParent]();
    }
    if (!global) {
      return null;
    }
    generator = this.data[$getRealChildrenByNameIt](
      name,
      /* allTransparent = */
      true,
      /* skipConsumed = */
      false
    );
    match = generator.next().value;
    if (match) {
      return match;
    }
    generator = this.data[$getAttributeIt](
      name,
      /* skipConsumed = */
      true
    );
    match = generator.next().value;
    if (match && match[$isDataValue]()) {
      return match;
    }
    return null;
  }
  _setProperties(formNode, dataNode) {
    if (!formNode.hasOwnProperty("setProperty")) {
      return;
    }
    for (const {
      ref,
      target,
      connection
    } of formNode.setProperty.children) {
      if (connection) {
        continue;
      }
      if (!ref) {
        continue;
      }
      const nodes = searchNode(
        this.root,
        dataNode,
        ref,
        false,
        false
        /* = useCache */
      );
      if (!nodes) {
        warn(`XFA - Invalid reference: ${ref}.`);
        continue;
      }
      const [node] = nodes;
      if (!node[$isDescendent](this.data)) {
        warn(`XFA - Invalid node: must be a data node.`);
        continue;
      }
      const targetNodes = searchNode(
        this.root,
        formNode,
        target,
        false,
        false
        /* = useCache */
      );
      if (!targetNodes) {
        warn(`XFA - Invalid target: ${target}.`);
        continue;
      }
      const [targetNode] = targetNodes;
      if (!targetNode[$isDescendent](formNode)) {
        warn(`XFA - Invalid target: must be a property or subproperty.`);
        continue;
      }
      const targetParent = targetNode[$getParent]();
      if (targetNode instanceof SetProperty || targetParent instanceof SetProperty) {
        warn(`XFA - Invalid target: cannot be a setProperty or one of its properties.`);
        continue;
      }
      if (targetNode instanceof BindItems || targetParent instanceof BindItems) {
        warn(`XFA - Invalid target: cannot be a bindItems or one of its properties.`);
        continue;
      }
      const content = node[$text]();
      const name = targetNode[$nodeName];
      if (targetNode instanceof XFAAttribute) {
        const attrs = /* @__PURE__ */ Object.create(null);
        attrs[name] = content;
        const obj = Reflect.construct(Object.getPrototypeOf(targetParent).constructor, [attrs]);
        targetParent[name] = obj[name];
        continue;
      }
      if (!targetNode.hasOwnProperty($content)) {
        warn(`XFA - Invalid node to use in setProperty`);
        continue;
      }
      targetNode[$data] = node;
      targetNode[$content] = content;
      targetNode[$finalize]();
    }
  }
  _bindItems(formNode, dataNode) {
    if (!formNode.hasOwnProperty("items") || !formNode.hasOwnProperty("bindItems") || formNode.bindItems.isEmpty()) {
      return;
    }
    for (const item of formNode.items.children) {
      formNode[$removeChild](item);
    }
    formNode.items.clear();
    const labels = new Items({});
    const values = new Items({});
    formNode[$appendChild](labels);
    formNode.items.push(labels);
    formNode[$appendChild](values);
    formNode.items.push(values);
    for (const {
      ref,
      labelRef,
      valueRef,
      connection
    } of formNode.bindItems.children) {
      if (connection) {
        continue;
      }
      if (!ref) {
        continue;
      }
      const nodes = searchNode(
        this.root,
        dataNode,
        ref,
        false,
        false
        /* = useCache */
      );
      if (!nodes) {
        warn(`XFA - Invalid reference: ${ref}.`);
        continue;
      }
      for (const node of nodes) {
        if (!node[$isDescendent](this.datasets)) {
          warn(`XFA - Invalid ref (${ref}): must be a datasets child.`);
          continue;
        }
        const labelNodes = searchNode(
          this.root,
          node,
          labelRef,
          true,
          false
          /* = useCache */
        );
        if (!labelNodes) {
          warn(`XFA - Invalid label: ${labelRef}.`);
          continue;
        }
        const [labelNode] = labelNodes;
        if (!labelNode[$isDescendent](this.datasets)) {
          warn(`XFA - Invalid label: must be a datasets child.`);
          continue;
        }
        const valueNodes = searchNode(
          this.root,
          node,
          valueRef,
          true,
          false
          /* = useCache */
        );
        if (!valueNodes) {
          warn(`XFA - Invalid value: ${valueRef}.`);
          continue;
        }
        const [valueNode] = valueNodes;
        if (!valueNode[$isDescendent](this.datasets)) {
          warn(`XFA - Invalid value: must be a datasets child.`);
          continue;
        }
        const label = createText(labelNode[$text]());
        const value = createText(valueNode[$text]());
        labels[$appendChild](label);
        labels.text.push(label);
        values[$appendChild](value);
        values.text.push(value);
      }
    }
  }
  _bindOccurrences(formNode, matches, picture) {
    let baseClone;
    if (matches.length > 1) {
      baseClone = formNode[$clone]();
    }
    this._bindValue(formNode, matches[0], picture);
    this._setProperties(formNode, matches[0]);
    this._bindItems(formNode, matches[0]);
    if (matches.length === 1) {
      return;
    }
    const parent = formNode[$getParent]();
    const name = formNode[$nodeName];
    const pos = parent[$indexOf](formNode);
    for (let i = 1, ii = matches.length; i < ii; i++) {
      const match = matches[i];
      const clone = baseClone[$clone]();
      clone.occur.min = 1;
      clone.occur.max = 1;
      clone.occur.initial = 1;
      parent[name].push(clone);
      parent[$insertAt](pos + i, clone);
      this._bindValue(clone, match, picture);
      this._setProperties(clone, match);
      this._bindItems(clone, match);
    }
  }
  _createOccurrences(formNode) {
    if (!this.emptyMerge) {
      return;
    }
    const {
      occur
    } = formNode;
    if (!occur || occur.initial <= 1) {
      return;
    }
    const parent = formNode[$getParent]();
    const name = formNode[$nodeName];
    for (let i = 0, ii = occur.initial; i < ii; i++) {
      const clone = formNode[$clone]();
      clone.occur.min = 1;
      clone.occur.max = 1;
      clone.occur.initial = 1;
      parent[name].push(clone);
      parent[$appendChild](clone);
    }
  }
  _getOccurInfo(formNode) {
    const {
      occur
    } = formNode;
    const dataName = formNode.name;
    if (!occur || !dataName) {
      return [1, 1];
    }
    const max = occur.max === -1 ? Infinity : occur.max;
    return [occur.min, max];
  }
  _bindElement(formNode, dataNode) {
    const uselessNodes = [];
    this._createOccurrences(formNode);
    for (const child of formNode[$getChildren]()) {
      if (child[$data]) {
        continue;
      }
      if (this._mergeMode === void 0 && child[$nodeName] === "subform") {
        this._mergeMode = child.mergeMode === "consumeData";
        const dataChildren = dataNode[$getChildren]();
        if (dataChildren.length > 0) {
          this._bindOccurrences(child, [dataChildren[0]], null);
        } else if (this.emptyMerge) {
          const dataChild = child[$data] = new XmlObject(dataNode[$namespaceId], child.name || "root");
          dataNode[$appendChild](dataChild);
          this._bindElement(child, dataChild);
        }
        continue;
      }
      if (!child[$isBindable]()) {
        continue;
      }
      let global = false;
      let picture = null;
      let ref = null;
      let match = null;
      if (child.bind) {
        switch (child.bind.match) {
          case "none":
            this._bindElement(child, dataNode);
            continue;
          case "global":
            global = true;
            break;
          case "dataRef":
            if (!child.bind.ref) {
              warn(`XFA - ref is empty in node ${child[$nodeName]}.`);
              this._bindElement(child, dataNode);
              continue;
            }
            ref = child.bind.ref;
            break;
        }
        if (child.bind.picture) {
          picture = child.bind.picture[$content];
        }
      }
      const [min, max] = this._getOccurInfo(child);
      if (ref) {
        match = searchNode(
          this.root,
          dataNode,
          ref,
          true,
          false
          /* = useCache */
        );
        if (match === null) {
          match = createDataNode(this.data, dataNode, ref);
          if (!match) {
            continue;
          }
          if (this._isConsumeData()) {
            match[$consumed] = true;
          }
          this._bindElement(child, match);
          continue;
        } else {
          if (this._isConsumeData()) {
            match = match.filter((node) => !node[$consumed]);
          }
          if (match.length > max) {
            match = match.slice(0, max);
          } else if (match.length === 0) {
            match = null;
          }
          if (match && this._isConsumeData()) {
            match.forEach((node) => {
              node[$consumed] = true;
            });
          }
        }
      } else {
        if (!child.name) {
          this._bindElement(child, dataNode);
          continue;
        }
        if (this._isConsumeData()) {
          const matches = [];
          while (matches.length < max) {
            const found = this._findDataByNameToConsume(child.name, child[$hasSettableValue](), dataNode, global);
            if (!found) {
              break;
            }
            found[$consumed] = true;
            matches.push(found);
          }
          match = matches.length > 0 ? matches : null;
        } else {
          match = dataNode[$getRealChildrenByNameIt](
            child.name,
            /* allTransparent = */
            false,
            /* skipConsumed = */
            this.emptyMerge
          ).next().value;
          if (!match) {
            match = child[$data] = new XmlObject(dataNode[$namespaceId], child.name);
            if (this.emptyMerge) {
              match[$consumed] = true;
            }
            dataNode[$appendChild](match);
            this._setProperties(child, match);
            this._bindItems(child, match);
            this._bindElement(child, match);
            continue;
          }
          if (this.emptyMerge) {
            match[$consumed] = true;
          }
          match = [match];
        }
      }
      if (match) {
        if (match.length < min) {
          warn(`XFA - Must have at least ${min} occurrences: ${formNode[$nodeName]}.`);
          continue;
        }
        this._bindOccurrences(child, match, picture);
      } else if (min > 0) {
        this._setProperties(child, dataNode);
        this._bindItems(child, dataNode);
        this._bindElement(child, dataNode);
      } else {
        uselessNodes.push(child);
      }
    }
    uselessNodes.forEach((node) => node[$getParent]()[$removeChild](node));
  }
};
var DataHandler = class {
  constructor(root, data) {
    this.data = data;
    this.dataset = root.datasets || null;
  }
  serialize(storage) {
    const stack = [[-1, this.data[$getChildren]()]];
    while (stack.length > 0) {
      const last = stack[stack.length - 1];
      const [i, children] = last;
      if (i + 1 === children.length) {
        stack.pop();
        continue;
      }
      const child = children[++last[0]];
      const storageEntry = storage.get(child[$uid]);
      if (storageEntry) {
        child[$setValue](storageEntry);
      } else {
        const attributes = child[$getAttributes]();
        for (const value of attributes.values()) {
          const entry = storage.get(value[$uid]);
          if (entry) {
            value[$setValue](entry);
            break;
          }
        }
      }
      const nodes = child[$getChildren]();
      if (nodes.length > 0) {
        stack.push([-1, nodes]);
      }
    }
    const buf = [`<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">`];
    if (this.dataset) {
      for (const child of this.dataset[$getChildren]()) {
        if (child[$nodeName] !== "data") {
          child[$toString](buf);
        }
      }
    }
    this.data[$toString](buf);
    buf.push("</xfa:datasets>");
    return buf.join("");
  }
};
var CONFIG_NS_ID = NamespaceIds.config.id;
var Acrobat = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "acrobat",
      /* hasChildren = */
      true
    );
    this.acrobat7 = null;
    this.autoSave = null;
    this.common = null;
    this.validate = null;
    this.validateApprovalSignatures = null;
    this.submitUrl = new XFAObjectArray();
  }
};
var Acrobat7 = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "acrobat7",
      /* hasChildren = */
      true
    );
    this.dynamicRender = null;
  }
};
var ADBE_JSConsole = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
};
var ADBE_JSDebugger = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
};
var AddSilentPrint = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "addSilentPrint");
  }
};
var AddViewerPreferences = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "addViewerPreferences");
  }
};
var AdjustData = class extends Option10 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "adjustData");
  }
};
var AdobeExtensionLevel = class extends IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "adobeExtensionLevel", 0, (n) => n >= 1 && n <= 8);
  }
};
var Agent = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "agent",
      /* hasChildren = */
      true
    );
    this.name = attributes.name ? attributes.name.trim() : "";
    this.common = new XFAObjectArray();
  }
};
var AlwaysEmbed = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "alwaysEmbed");
  }
};
var Amd = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "amd");
  }
};
var Area = class extends XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "area");
    this.level = getInteger({
      data: attributes.level,
      defaultValue: 0,
      validate: (n) => n >= 1 && n <= 3
    });
    this.name = getStringOption(attributes.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
};
var Attributes = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "attributes", ["preserve", "delegate", "ignore"]);
  }
};
var AutoSave = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "autoSave", ["disabled", "enabled"]);
  }
};
var Base = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "base");
  }
};
var BatchOutput = class extends XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "batchOutput");
    this.format = getStringOption(attributes.format, ["none", "concat", "zip", "zipCompress"]);
  }
};
var BehaviorOverride = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "behaviorOverride");
  }
  [$finalize]() {
    this[$content] = new Map(this[$content].trim().split(/\s+/).filter((x) => x.includes(":")).map((x) => x.split(":", 2)));
  }
};
var Cache = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "cache",
      /* hasChildren = */
      true
    );
    this.templateCache = null;
  }
};
var Change = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "change");
  }
};
var Common = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "common",
      /* hasChildren = */
      true
    );
    this.data = null;
    this.locale = null;
    this.localeSet = null;
    this.messaging = null;
    this.suppressBanner = null;
    this.template = null;
    this.validationMessaging = null;
    this.versionControl = null;
    this.log = new XFAObjectArray();
  }
};
var Compress = class extends XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compress");
    this.scope = getStringOption(attributes.scope, ["imageOnly", "document"]);
  }
};
var CompressLogicalStructure = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compressLogicalStructure");
  }
};
var CompressObjectStream = class extends Option10 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "compressObjectStream");
  }
};
var Compression = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "compression",
      /* hasChildren = */
      true
    );
    this.compressLogicalStructure = null;
    this.compressObjectStream = null;
    this.level = null;
    this.type = null;
  }
};
var Config = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "config",
      /* hasChildren = */
      true
    );
    this.acrobat = null;
    this.present = null;
    this.trace = null;
    this.agent = new XFAObjectArray();
  }
};
var Conformance = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "conformance", ["A", "B"]);
  }
};
var ContentCopy = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "contentCopy");
  }
};
var Copies = class extends IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "copies", 1, (n) => n >= 1);
  }
};
var Creator = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "creator");
  }
};
var CurrentPage = class extends IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "currentPage", 0, (n) => n >= 0);
  }
};
var Data$1 = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "data",
      /* hasChildren = */
      true
    );
    this.adjustData = null;
    this.attributes = null;
    this.incrementalLoad = null;
    this.outputXSL = null;
    this.range = null;
    this.record = null;
    this.startNode = null;
    this.uri = null;
    this.window = null;
    this.xsl = null;
    this.excludeNS = new XFAObjectArray();
    this.transform = new XFAObjectArray();
  }
};
var Debug = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "debug",
      /* hasChildren = */
      true
    );
    this.uri = null;
  }
};
var DefaultTypeface = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "defaultTypeface");
    this.writingScript = getStringOption(attributes.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
};
var Destination = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
};
var DocumentAssembly = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "documentAssembly");
  }
};
var Driver = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "driver",
      /* hasChildren = */
      true
    );
    this.name = attributes.name ? attributes.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
};
var DuplexOption = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
};
var DynamicRender = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "dynamicRender", ["forbidden", "required"]);
  }
};
var Embed = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "embed");
  }
};
var Encrypt = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encrypt");
  }
};
var Encryption = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "encryption",
      /* hasChildren = */
      true
    );
    this.encrypt = null;
    this.encryptionLevel = null;
    this.permissions = null;
  }
};
var EncryptionLevel = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "encryptionLevel", ["40bit", "128bit"]);
  }
};
var Enforce = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "enforce");
  }
};
var Equate = class extends XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "equate");
    this.force = getInteger({
      data: attributes.force,
      defaultValue: 1,
      validate: (n) => n === 0
    });
    this.from = attributes.from || "";
    this.to = attributes.to || "";
  }
};
var EquateRange = class extends XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "equateRange");
    this.from = attributes.from || "";
    this.to = attributes.to || "";
    this._unicodeRange = attributes.unicodeRange || "";
  }
  get unicodeRange() {
    const ranges = [];
    const unicodeRegex = /U\+([0-9a-fA-F]+)/;
    const unicodeRange = this._unicodeRange;
    for (let range of unicodeRange.split(",").map((x) => x.trim()).filter((x) => !!x)) {
      range = range.split("-", 2).map((x) => {
        const found = x.match(unicodeRegex);
        if (!found) {
          return 0;
        }
        return parseInt(found[1], 16);
      });
      if (range.length === 1) {
        range.push(range[0]);
      }
      ranges.push(range);
    }
    return shadow(this, "unicodeRange", ranges);
  }
};
var Exclude = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "exclude");
  }
  [$finalize]() {
    this[$content] = this[$content].trim().split(/\s+/).filter((x) => x && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(x));
  }
};
var ExcludeNS = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "excludeNS");
  }
};
var FlipLabel = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
};
var FontInfo = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "fontInfo",
      /* hasChildren = */
      true
    );
    this.embed = null;
    this.map = null;
    this.subsetBelow = null;
    this.alwaysEmbed = new XFAObjectArray();
    this.defaultTypeface = new XFAObjectArray();
    this.neverEmbed = new XFAObjectArray();
  }
};
var FormFieldFilling = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "formFieldFilling");
  }
};
var GroupParent = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "groupParent");
  }
};
var IfEmpty = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
};
var IncludeXDPContent = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "includeXDPContent");
  }
};
var IncrementalLoad = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "incrementalLoad", ["none", "forwardOnly"]);
  }
};
var IncrementalMerge = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "incrementalMerge");
  }
};
var Interactive = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "interactive");
  }
};
var Jog = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
};
var LabelPrinter = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "labelPrinter",
      /* hasChildren = */
      true
    );
    this.name = getStringOption(attributes.name, ["zpl", "dpl", "ipl", "tcpl"]);
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
};
var Layout = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "layout", ["paginate", "panel"]);
  }
};
var Level = class extends IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "level", 0, (n) => n > 0);
  }
};
var Linearized = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "linearized");
  }
};
var Locale$1 = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "locale");
  }
};
var LocaleSet$1 = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "localeSet");
  }
};
var Log = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "log",
      /* hasChildren = */
      true
    );
    this.mode = null;
    this.threshold = null;
    this.to = null;
    this.uri = null;
  }
};
var MapElement = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "map",
      /* hasChildren = */
      true
    );
    this.equate = new XFAObjectArray();
    this.equateRange = new XFAObjectArray();
  }
};
var MediumInfo = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "mediumInfo",
      /* hasChildren = */
      true
    );
    this.map = null;
  }
};
var Message = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "message",
      /* hasChildren = */
      true
    );
    this.msgId = null;
    this.severity = null;
  }
};
var Messaging = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "messaging",
      /* hasChildren = */
      true
    );
    this.message = new XFAObjectArray();
  }
};
var Mode = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "mode", ["append", "overwrite"]);
  }
};
var ModifyAnnots = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "modifyAnnots");
  }
};
var MsgId = class extends IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "msgId", 1, (n) => n >= 1);
  }
};
var NameAttr = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "nameAttr");
  }
};
var NeverEmbed = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "neverEmbed");
  }
};
var NumberOfCopies = class extends IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "numberOfCopies", null, (n) => n >= 2 && n <= 5);
  }
};
var OpenAction = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "openAction",
      /* hasChildren = */
      true
    );
    this.destination = null;
  }
};
var Output = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "output",
      /* hasChildren = */
      true
    );
    this.to = null;
    this.type = null;
    this.uri = null;
  }
};
var OutputBin = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "outputBin");
  }
};
var OutputXSL = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "outputXSL",
      /* hasChildren = */
      true
    );
    this.uri = null;
  }
};
var Overprint = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "overprint", ["none", "both", "draw", "field"]);
  }
};
var Packets = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "packets");
  }
  [$finalize]() {
    if (this[$content] === "*") {
      return;
    }
    this[$content] = this[$content].trim().split(/\s+/).filter((x) => ["config", "datasets", "template", "xfdf", "xslt"].includes(x));
  }
};
var PageOffset = class extends XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pageOffset");
    this.x = getInteger({
      data: attributes.x,
      defaultValue: "useXDCSetting",
      validate: (n) => true
    });
    this.y = getInteger({
      data: attributes.y,
      defaultValue: "useXDCSetting",
      validate: (n) => true
    });
  }
};
var PageRange = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pageRange");
  }
  [$finalize]() {
    const numbers = this[$content].trim().split(/\s+/).map((x) => parseInt(x, 10));
    const ranges = [];
    for (let i = 0, ii = numbers.length; i < ii; i += 2) {
      ranges.push(numbers.slice(i, i + 2));
    }
    this[$content] = ranges;
  }
};
var Pagination = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
};
var PaginationOverride = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
};
var Part = class extends IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "part", 1, (n) => false);
  }
};
var Pcl = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "pcl",
      /* hasChildren = */
      true
    );
    this.name = attributes.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.pageOffset = null;
    this.staple = null;
    this.xdc = null;
  }
};
var Pdf = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "pdf",
      /* hasChildren = */
      true
    );
    this.name = attributes.name || "";
    this.adobeExtensionLevel = null;
    this.batchOutput = null;
    this.compression = null;
    this.creator = null;
    this.encryption = null;
    this.fontInfo = null;
    this.interactive = null;
    this.linearized = null;
    this.openAction = null;
    this.pdfa = null;
    this.producer = null;
    this.renderPolicy = null;
    this.scriptModel = null;
    this.silentPrint = null;
    this.submitFormat = null;
    this.tagged = null;
    this.version = null;
    this.viewerPreferences = null;
    this.xdc = null;
  }
};
var Pdfa = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "pdfa",
      /* hasChildren = */
      true
    );
    this.amd = null;
    this.conformance = null;
    this.includeXDPContent = null;
    this.part = null;
  }
};
var Permissions = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "permissions",
      /* hasChildren = */
      true
    );
    this.accessibleContent = null;
    this.change = null;
    this.contentCopy = null;
    this.documentAssembly = null;
    this.formFieldFilling = null;
    this.modifyAnnots = null;
    this.plaintextMetadata = null;
    this.print = null;
    this.printHighQuality = null;
  }
};
var PickTrayByPDFSize = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "pickTrayByPDFSize");
  }
};
var Picture = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "picture");
  }
  // TODO: check the validity of the picture clause.
  // See page 1150 in the spec.
};
var PlaintextMetadata = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "plaintextMetadata");
  }
};
var Presence = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
};
var Present = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "present",
      /* hasChildren = */
      true
    );
    this.behaviorOverride = null;
    this.cache = null;
    this.common = null;
    this.copies = null;
    this.destination = null;
    this.incrementalMerge = null;
    this.layout = null;
    this.output = null;
    this.overprint = null;
    this.pagination = null;
    this.paginationOverride = null;
    this.script = null;
    this.validate = null;
    this.xdp = null;
    this.driver = new XFAObjectArray();
    this.labelPrinter = new XFAObjectArray();
    this.pcl = new XFAObjectArray();
    this.pdf = new XFAObjectArray();
    this.ps = new XFAObjectArray();
    this.submitUrl = new XFAObjectArray();
    this.webClient = new XFAObjectArray();
    this.zpl = new XFAObjectArray();
  }
};
var Print = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "print");
  }
};
var PrintHighQuality = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printHighQuality");
  }
};
var PrintScaling = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printScaling", ["appdefault", "noScaling"]);
  }
};
var PrinterName = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "printerName");
  }
};
var Producer = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "producer");
  }
};
var Ps = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "ps",
      /* hasChildren = */
      true
    );
    this.name = attributes.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.staple = null;
    this.xdc = null;
  }
};
var Range = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "range");
  }
  [$finalize]() {
    this[$content] = this[$content].trim().split(/\s*,\s*/, 2).map((range) => range.split("-").map((x) => parseInt(x.trim(), 10))).filter((range) => range.every((x) => !isNaN(x))).map((range) => {
      if (range.length === 1) {
        range.push(range[0]);
      }
      return range;
    });
  }
};
var Record = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "record");
  }
  [$finalize]() {
    this[$content] = this[$content].trim();
    const n = parseInt(this[$content], 10);
    if (!isNaN(n) && n >= 0) {
      this[$content] = n;
    }
  }
};
var Relevant = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "relevant");
  }
  [$finalize]() {
    this[$content] = this[$content].trim().split(/\s+/);
  }
};
var Rename = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "rename");
  }
  [$finalize]() {
    this[$content] = this[$content].trim();
    if (this[$content].toLowerCase().startsWith("xml") || this[$content].match(new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u"))) {
      warn("XFA - Rename: invalid XFA name");
    }
  }
};
var RenderPolicy = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "renderPolicy", ["server", "client"]);
  }
};
var RunScripts = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "runScripts", ["both", "client", "none", "server"]);
  }
};
var Script = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "script",
      /* hasChildren = */
      true
    );
    this.currentPage = null;
    this.exclude = null;
    this.runScripts = null;
  }
};
var ScriptModel = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "scriptModel", ["XFA", "none"]);
  }
};
var Severity = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
};
var SilentPrint = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "silentPrint",
      /* hasChildren = */
      true
    );
    this.addSilentPrint = null;
    this.printerName = null;
  }
};
var Staple = class extends XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "staple");
    this.mode = getStringOption(attributes.mode, ["usePrinterSetting", "on", "off"]);
  }
};
var StartNode = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "startNode");
  }
};
var StartPage = class extends IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "startPage", 0, (n) => true);
  }
};
var SubmitFormat = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
};
var SubmitUrl = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "submitUrl");
  }
};
var SubsetBelow = class extends IntegerObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "subsetBelow", 100, (n) => n >= 0 && n <= 100);
  }
};
var SuppressBanner = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "suppressBanner");
  }
};
var Tagged = class extends Option01 {
  constructor(attributes) {
    super(CONFIG_NS_ID, "tagged");
  }
};
var Template = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "template",
      /* hasChildren = */
      true
    );
    this.base = null;
    this.relevant = null;
    this.startPage = null;
    this.uri = null;
    this.xsl = null;
  }
};
var Threshold = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "threshold", ["trace", "error", "information", "warning"]);
  }
};
var To = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
};
var TemplateCache = class extends XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "templateCache");
    this.maxEntries = getInteger({
      data: attributes.maxEntries,
      defaultValue: 5,
      validate: (n) => n >= 0
    });
  }
};
var Trace = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "trace",
      /* hasChildren = */
      true
    );
    this.area = new XFAObjectArray();
  }
};
var Transform = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "transform",
      /* hasChildren = */
      true
    );
    this.groupParent = null;
    this.ifEmpty = null;
    this.nameAttr = null;
    this.picture = null;
    this.presence = null;
    this.rename = null;
    this.whitespace = null;
  }
};
var Type = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
};
var Uri$1 = class extends StringObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "uri");
  }
};
var Validate = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
};
var ValidateApprovalSignatures = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validateApprovalSignatures");
  }
  [$finalize]() {
    this[$content] = this[$content].trim().split(/\s+/).filter((x) => ["docReady", "postSign"].includes(x));
  }
};
var ValidationMessaging = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
};
var Version = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
};
var VersionControl = class extends XFAObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "VersionControl");
    this.outputBelow = getStringOption(attributes.outputBelow, ["warn", "error", "update"]);
    this.sourceAbove = getStringOption(attributes.sourceAbove, ["warn", "error"]);
    this.sourceBelow = getStringOption(attributes.sourceBelow, ["update", "maintain"]);
  }
};
var ViewerPreferences = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "viewerPreferences",
      /* hasChildren = */
      true
    );
    this.ADBE_JSConsole = null;
    this.ADBE_JSDebugger = null;
    this.addViewerPreferences = null;
    this.duplexOption = null;
    this.enforce = null;
    this.numberOfCopies = null;
    this.pageRange = null;
    this.pickTrayByPDFSize = null;
    this.printScaling = null;
  }
};
var WebClient = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "webClient",
      /* hasChildren = */
      true
    );
    this.name = attributes.name ? attributes.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
};
var Whitespace = class extends OptionObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
};
var Window = class extends ContentObject {
  constructor(attributes) {
    super(CONFIG_NS_ID, "window");
  }
  [$finalize]() {
    const pair = this[$content].trim().split(/\s*,\s*/, 2).map((x) => parseInt(x, 10));
    if (pair.some((x) => isNaN(x))) {
      this[$content] = [0, 0];
      return;
    }
    if (pair.length === 1) {
      pair.push(pair[0]);
    }
    this[$content] = pair;
  }
};
var Xdc = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "xdc",
      /* hasChildren = */
      true
    );
    this.uri = new XFAObjectArray();
    this.xsl = new XFAObjectArray();
  }
};
var Xdp$1 = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "xdp",
      /* hasChildren = */
      true
    );
    this.packets = null;
  }
};
var Xsl = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "xsl",
      /* hasChildren = */
      true
    );
    this.debug = null;
    this.uri = null;
  }
};
var Zpl = class extends XFAObject {
  constructor(attributes) {
    super(
      CONFIG_NS_ID,
      "zpl",
      /* hasChildren = */
      true
    );
    this.name = attributes.name ? attributes.name.trim() : "";
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
};
var ConfigNamespace = class _ConfigNamespace {
  static [$buildXFAObject](name, attributes) {
    if (_ConfigNamespace.hasOwnProperty(name)) {
      return _ConfigNamespace[name](attributes);
    }
    return void 0;
  }
  static acrobat(attrs) {
    return new Acrobat(attrs);
  }
  static acrobat7(attrs) {
    return new Acrobat7(attrs);
  }
  static ADBE_JSConsole(attrs) {
    return new ADBE_JSConsole(attrs);
  }
  static ADBE_JSDebugger(attrs) {
    return new ADBE_JSDebugger(attrs);
  }
  static addSilentPrint(attrs) {
    return new AddSilentPrint(attrs);
  }
  static addViewerPreferences(attrs) {
    return new AddViewerPreferences(attrs);
  }
  static adjustData(attrs) {
    return new AdjustData(attrs);
  }
  static adobeExtensionLevel(attrs) {
    return new AdobeExtensionLevel(attrs);
  }
  static agent(attrs) {
    return new Agent(attrs);
  }
  static alwaysEmbed(attrs) {
    return new AlwaysEmbed(attrs);
  }
  static amd(attrs) {
    return new Amd(attrs);
  }
  static area(attrs) {
    return new Area(attrs);
  }
  static attributes(attrs) {
    return new Attributes(attrs);
  }
  static autoSave(attrs) {
    return new AutoSave(attrs);
  }
  static base(attrs) {
    return new Base(attrs);
  }
  static batchOutput(attrs) {
    return new BatchOutput(attrs);
  }
  static behaviorOverride(attrs) {
    return new BehaviorOverride(attrs);
  }
  static cache(attrs) {
    return new Cache(attrs);
  }
  static change(attrs) {
    return new Change(attrs);
  }
  static common(attrs) {
    return new Common(attrs);
  }
  static compress(attrs) {
    return new Compress(attrs);
  }
  static compressLogicalStructure(attrs) {
    return new CompressLogicalStructure(attrs);
  }
  static compressObjectStream(attrs) {
    return new CompressObjectStream(attrs);
  }
  static compression(attrs) {
    return new Compression(attrs);
  }
  static config(attrs) {
    return new Config(attrs);
  }
  static conformance(attrs) {
    return new Conformance(attrs);
  }
  static contentCopy(attrs) {
    return new ContentCopy(attrs);
  }
  static copies(attrs) {
    return new Copies(attrs);
  }
  static creator(attrs) {
    return new Creator(attrs);
  }
  static currentPage(attrs) {
    return new CurrentPage(attrs);
  }
  static data(attrs) {
    return new Data$1(attrs);
  }
  static debug(attrs) {
    return new Debug(attrs);
  }
  static defaultTypeface(attrs) {
    return new DefaultTypeface(attrs);
  }
  static destination(attrs) {
    return new Destination(attrs);
  }
  static documentAssembly(attrs) {
    return new DocumentAssembly(attrs);
  }
  static driver(attrs) {
    return new Driver(attrs);
  }
  static duplexOption(attrs) {
    return new DuplexOption(attrs);
  }
  static dynamicRender(attrs) {
    return new DynamicRender(attrs);
  }
  static embed(attrs) {
    return new Embed(attrs);
  }
  static encrypt(attrs) {
    return new Encrypt(attrs);
  }
  static encryption(attrs) {
    return new Encryption(attrs);
  }
  static encryptionLevel(attrs) {
    return new EncryptionLevel(attrs);
  }
  static enforce(attrs) {
    return new Enforce(attrs);
  }
  static equate(attrs) {
    return new Equate(attrs);
  }
  static equateRange(attrs) {
    return new EquateRange(attrs);
  }
  static exclude(attrs) {
    return new Exclude(attrs);
  }
  static excludeNS(attrs) {
    return new ExcludeNS(attrs);
  }
  static flipLabel(attrs) {
    return new FlipLabel(attrs);
  }
  static fontInfo(attrs) {
    return new FontInfo(attrs);
  }
  static formFieldFilling(attrs) {
    return new FormFieldFilling(attrs);
  }
  static groupParent(attrs) {
    return new GroupParent(attrs);
  }
  static ifEmpty(attrs) {
    return new IfEmpty(attrs);
  }
  static includeXDPContent(attrs) {
    return new IncludeXDPContent(attrs);
  }
  static incrementalLoad(attrs) {
    return new IncrementalLoad(attrs);
  }
  static incrementalMerge(attrs) {
    return new IncrementalMerge(attrs);
  }
  static interactive(attrs) {
    return new Interactive(attrs);
  }
  static jog(attrs) {
    return new Jog(attrs);
  }
  static labelPrinter(attrs) {
    return new LabelPrinter(attrs);
  }
  static layout(attrs) {
    return new Layout(attrs);
  }
  static level(attrs) {
    return new Level(attrs);
  }
  static linearized(attrs) {
    return new Linearized(attrs);
  }
  static locale(attrs) {
    return new Locale$1(attrs);
  }
  static localeSet(attrs) {
    return new LocaleSet$1(attrs);
  }
  static log(attrs) {
    return new Log(attrs);
  }
  static map(attrs) {
    return new MapElement(attrs);
  }
  static mediumInfo(attrs) {
    return new MediumInfo(attrs);
  }
  static message(attrs) {
    return new Message(attrs);
  }
  static messaging(attrs) {
    return new Messaging(attrs);
  }
  static mode(attrs) {
    return new Mode(attrs);
  }
  static modifyAnnots(attrs) {
    return new ModifyAnnots(attrs);
  }
  static msgId(attrs) {
    return new MsgId(attrs);
  }
  static nameAttr(attrs) {
    return new NameAttr(attrs);
  }
  static neverEmbed(attrs) {
    return new NeverEmbed(attrs);
  }
  static numberOfCopies(attrs) {
    return new NumberOfCopies(attrs);
  }
  static openAction(attrs) {
    return new OpenAction(attrs);
  }
  static output(attrs) {
    return new Output(attrs);
  }
  static outputBin(attrs) {
    return new OutputBin(attrs);
  }
  static outputXSL(attrs) {
    return new OutputXSL(attrs);
  }
  static overprint(attrs) {
    return new Overprint(attrs);
  }
  static packets(attrs) {
    return new Packets(attrs);
  }
  static pageOffset(attrs) {
    return new PageOffset(attrs);
  }
  static pageRange(attrs) {
    return new PageRange(attrs);
  }
  static pagination(attrs) {
    return new Pagination(attrs);
  }
  static paginationOverride(attrs) {
    return new PaginationOverride(attrs);
  }
  static part(attrs) {
    return new Part(attrs);
  }
  static pcl(attrs) {
    return new Pcl(attrs);
  }
  static pdf(attrs) {
    return new Pdf(attrs);
  }
  static pdfa(attrs) {
    return new Pdfa(attrs);
  }
  static permissions(attrs) {
    return new Permissions(attrs);
  }
  static pickTrayByPDFSize(attrs) {
    return new PickTrayByPDFSize(attrs);
  }
  static picture(attrs) {
    return new Picture(attrs);
  }
  static plaintextMetadata(attrs) {
    return new PlaintextMetadata(attrs);
  }
  static presence(attrs) {
    return new Presence(attrs);
  }
  static present(attrs) {
    return new Present(attrs);
  }
  static print(attrs) {
    return new Print(attrs);
  }
  static printHighQuality(attrs) {
    return new PrintHighQuality(attrs);
  }
  static printScaling(attrs) {
    return new PrintScaling(attrs);
  }
  static printerName(attrs) {
    return new PrinterName(attrs);
  }
  static producer(attrs) {
    return new Producer(attrs);
  }
  static ps(attrs) {
    return new Ps(attrs);
  }
  static range(attrs) {
    return new Range(attrs);
  }
  static record(attrs) {
    return new Record(attrs);
  }
  static relevant(attrs) {
    return new Relevant(attrs);
  }
  static rename(attrs) {
    return new Rename(attrs);
  }
  static renderPolicy(attrs) {
    return new RenderPolicy(attrs);
  }
  static runScripts(attrs) {
    return new RunScripts(attrs);
  }
  static script(attrs) {
    return new Script(attrs);
  }
  static scriptModel(attrs) {
    return new ScriptModel(attrs);
  }
  static severity(attrs) {
    return new Severity(attrs);
  }
  static silentPrint(attrs) {
    return new SilentPrint(attrs);
  }
  static staple(attrs) {
    return new Staple(attrs);
  }
  static startNode(attrs) {
    return new StartNode(attrs);
  }
  static startPage(attrs) {
    return new StartPage(attrs);
  }
  static submitFormat(attrs) {
    return new SubmitFormat(attrs);
  }
  static submitUrl(attrs) {
    return new SubmitUrl(attrs);
  }
  static subsetBelow(attrs) {
    return new SubsetBelow(attrs);
  }
  static suppressBanner(attrs) {
    return new SuppressBanner(attrs);
  }
  static tagged(attrs) {
    return new Tagged(attrs);
  }
  static template(attrs) {
    return new Template(attrs);
  }
  static templateCache(attrs) {
    return new TemplateCache(attrs);
  }
  static threshold(attrs) {
    return new Threshold(attrs);
  }
  static to(attrs) {
    return new To(attrs);
  }
  static trace(attrs) {
    return new Trace(attrs);
  }
  static transform(attrs) {
    return new Transform(attrs);
  }
  static type(attrs) {
    return new Type(attrs);
  }
  static uri(attrs) {
    return new Uri$1(attrs);
  }
  static validate(attrs) {
    return new Validate(attrs);
  }
  static validateApprovalSignatures(attrs) {
    return new ValidateApprovalSignatures(attrs);
  }
  static validationMessaging(attrs) {
    return new ValidationMessaging(attrs);
  }
  static version(attrs) {
    return new Version(attrs);
  }
  static versionControl(attrs) {
    return new VersionControl(attrs);
  }
  static viewerPreferences(attrs) {
    return new ViewerPreferences(attrs);
  }
  static webClient(attrs) {
    return new WebClient(attrs);
  }
  static whitespace(attrs) {
    return new Whitespace(attrs);
  }
  static window(attrs) {
    return new Window(attrs);
  }
  static xdc(attrs) {
    return new Xdc(attrs);
  }
  static xdp(attrs) {
    return new Xdp$1(attrs);
  }
  static xsl(attrs) {
    return new Xsl(attrs);
  }
  static zpl(attrs) {
    return new Zpl(attrs);
  }
};
var CONNECTION_SET_NS_ID = NamespaceIds.connectionSet.id;
var ConnectionSet = class extends XFAObject {
  constructor(attributes) {
    super(
      CONNECTION_SET_NS_ID,
      "connectionSet",
      /* hasChildren = */
      true
    );
    this.wsdlConnection = new XFAObjectArray();
    this.xmlConnection = new XFAObjectArray();
    this.xsdConnection = new XFAObjectArray();
  }
};
var EffectiveInputPolicy = class extends XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "effectiveInputPolicy");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var EffectiveOutputPolicy = class extends XFAObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "effectiveOutputPolicy");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Operation = class extends StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "operation");
    this.id = attributes.id || "";
    this.input = attributes.input || "";
    this.name = attributes.name || "";
    this.output = attributes.output || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var RootElement = class extends StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "rootElement");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var SoapAction = class extends StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "soapAction");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var SoapAddress = class extends StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "soapAddress");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var Uri = class extends StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "uri");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var WsdlAddress = class extends StringObject {
  constructor(attributes) {
    super(CONNECTION_SET_NS_ID, "wsdlAddress");
    this.id = attributes.id || "";
    this.name = attributes.name || "";
    this.use = attributes.use || "";
    this.usehref = attributes.usehref || "";
  }
};
var WsdlConnection = class extends XFAObject {
  constructor(attributes) {
    super(
      CONNECTION_SET_NS_ID,
      "wsdlConnection",
      /* hasChildren = */
      true
    );
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.effectiveInputPolicy = null;
    this.effectiveOutputPolicy = null;
    this.operation = null;
    this.soapAction = null;
    this.soapAddress = null;
    this.wsdlAddress = null;
  }
};
var XmlConnection = class extends XFAObject {
  constructor(attributes) {
    super(
      CONNECTION_SET_NS_ID,
      "xmlConnection",
      /* hasChildren = */
      true
    );
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.uri = null;
  }
};
var XsdConnection = class extends XFAObject {
  constructor(attributes) {
    super(
      CONNECTION_SET_NS_ID,
      "xsdConnection",
      /* hasChildren = */
      true
    );
    this.dataDescription = attributes.dataDescription || "";
    this.name = attributes.name || "";
    this.rootElement = null;
    this.uri = null;
  }
};
var ConnectionSetNamespace = class _ConnectionSetNamespace {
  static [$buildXFAObject](name, attributes) {
    if (_ConnectionSetNamespace.hasOwnProperty(name)) {
      return _ConnectionSetNamespace[name](attributes);
    }
    return void 0;
  }
  static connectionSet(attrs) {
    return new ConnectionSet(attrs);
  }
  static effectiveInputPolicy(attrs) {
    return new EffectiveInputPolicy(attrs);
  }
  static effectiveOutputPolicy(attrs) {
    return new EffectiveOutputPolicy(attrs);
  }
  static operation(attrs) {
    return new Operation(attrs);
  }
  static rootElement(attrs) {
    return new RootElement(attrs);
  }
  static soapAction(attrs) {
    return new SoapAction(attrs);
  }
  static soapAddress(attrs) {
    return new SoapAddress(attrs);
  }
  static uri(attrs) {
    return new Uri(attrs);
  }
  static wsdlAddress(attrs) {
    return new WsdlAddress(attrs);
  }
  static wsdlConnection(attrs) {
    return new WsdlConnection(attrs);
  }
  static xmlConnection(attrs) {
    return new XmlConnection(attrs);
  }
  static xsdConnection(attrs) {
    return new XsdConnection(attrs);
  }
};
var DATASETS_NS_ID = NamespaceIds.datasets.id;
var Data = class extends XmlObject {
  constructor(attributes) {
    super(DATASETS_NS_ID, "data", attributes);
  }
  [$isNsAgnostic]() {
    return true;
  }
};
var Datasets = class extends XFAObject {
  constructor(attributes) {
    super(
      DATASETS_NS_ID,
      "datasets",
      /* hasChildren = */
      true
    );
    this.data = null;
    this.Signature = null;
  }
  [$onChild](child) {
    const name = child[$nodeName];
    if (name === "data" && child[$namespaceId] === DATASETS_NS_ID || name === "Signature" && child[$namespaceId] === NamespaceIds.signature.id) {
      this[name] = child;
    }
    this[$appendChild](child);
  }
};
var DatasetsNamespace = class _DatasetsNamespace {
  static [$buildXFAObject](name, attributes) {
    if (_DatasetsNamespace.hasOwnProperty(name)) {
      return _DatasetsNamespace[name](attributes);
    }
    return void 0;
  }
  static datasets(attributes) {
    return new Datasets(attributes);
  }
  static data(attributes) {
    return new Data(attributes);
  }
};
var LOCALE_SET_NS_ID = NamespaceIds.localeSet.id;
var CalendarSymbols = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "calendarSymbols",
      /* hasChildren = */
      true
    );
    this.name = "gregorian";
    this.dayNames = new XFAObjectArray(2);
    this.eraNames = null;
    this.meridiemNames = null;
    this.monthNames = new XFAObjectArray(2);
  }
};
var CurrencySymbol = class extends StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "currencySymbol");
    this.name = getStringOption(attributes.name, ["symbol", "isoname", "decimal"]);
  }
};
var CurrencySymbols = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "currencySymbols",
      /* hasChildren = */
      true
    );
    this.currencySymbol = new XFAObjectArray(3);
  }
};
var DatePattern = class extends StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "datePattern");
    this.name = getStringOption(attributes.name, ["full", "long", "med", "short"]);
  }
};
var DatePatterns = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "datePatterns",
      /* hasChildren = */
      true
    );
    this.datePattern = new XFAObjectArray(4);
  }
};
var DateTimeSymbols = class extends ContentObject {
  // TODO: spec unclear about the format of the array.
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "dateTimeSymbols");
  }
};
var Day = class extends StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "day");
  }
};
var DayNames = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "dayNames",
      /* hasChildren = */
      true
    );
    this.abbr = getInteger({
      data: attributes.abbr,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.day = new XFAObjectArray(7);
  }
};
var Era = class extends StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "era");
  }
};
var EraNames = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "eraNames",
      /* hasChildren = */
      true
    );
    this.era = new XFAObjectArray(2);
  }
};
var Locale = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "locale",
      /* hasChildren = */
      true
    );
    this.desc = attributes.desc || "";
    this.name = "isoname";
    this.calendarSymbols = null;
    this.currencySymbols = null;
    this.datePatterns = null;
    this.dateTimeSymbols = null;
    this.numberPatterns = null;
    this.numberSymbols = null;
    this.timePatterns = null;
    this.typeFaces = null;
  }
};
var LocaleSet = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "localeSet",
      /* hasChildren = */
      true
    );
    this.locale = new XFAObjectArray();
  }
};
var Meridiem = class extends StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "meridiem");
  }
};
var MeridiemNames = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "meridiemNames",
      /* hasChildren = */
      true
    );
    this.meridiem = new XFAObjectArray(2);
  }
};
var Month = class extends StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "month");
  }
};
var MonthNames = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "monthNames",
      /* hasChildren = */
      true
    );
    this.abbr = getInteger({
      data: attributes.abbr,
      defaultValue: 0,
      validate: (x) => x === 1
    });
    this.month = new XFAObjectArray(12);
  }
};
var NumberPattern = class extends StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberPattern");
    this.name = getStringOption(attributes.name, ["full", "long", "med", "short"]);
  }
};
var NumberPatterns = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "numberPatterns",
      /* hasChildren = */
      true
    );
    this.numberPattern = new XFAObjectArray(4);
  }
};
var NumberSymbol = class extends StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "numberSymbol");
    this.name = getStringOption(attributes.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
};
var NumberSymbols = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "numberSymbols",
      /* hasChildren = */
      true
    );
    this.numberSymbol = new XFAObjectArray(5);
  }
};
var TimePattern = class extends StringObject {
  constructor(attributes) {
    super(LOCALE_SET_NS_ID, "timePattern");
    this.name = getStringOption(attributes.name, ["full", "long", "med", "short"]);
  }
};
var TimePatterns = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "timePatterns",
      /* hasChildren = */
      true
    );
    this.timePattern = new XFAObjectArray(4);
  }
};
var TypeFace = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "typeFace",
      /* hasChildren = */
      true
    );
    this.name = attributes.name | "";
  }
};
var TypeFaces = class extends XFAObject {
  constructor(attributes) {
    super(
      LOCALE_SET_NS_ID,
      "typeFaces",
      /* hasChildren = */
      true
    );
    this.typeFace = new XFAObjectArray();
  }
};
var LocaleSetNamespace = class _LocaleSetNamespace {
  static [$buildXFAObject](name, attributes) {
    if (_LocaleSetNamespace.hasOwnProperty(name)) {
      return _LocaleSetNamespace[name](attributes);
    }
    return void 0;
  }
  static calendarSymbols(attrs) {
    return new CalendarSymbols(attrs);
  }
  static currencySymbol(attrs) {
    return new CurrencySymbol(attrs);
  }
  static currencySymbols(attrs) {
    return new CurrencySymbols(attrs);
  }
  static datePattern(attrs) {
    return new DatePattern(attrs);
  }
  static datePatterns(attrs) {
    return new DatePatterns(attrs);
  }
  static dateTimeSymbols(attrs) {
    return new DateTimeSymbols(attrs);
  }
  static day(attrs) {
    return new Day(attrs);
  }
  static dayNames(attrs) {
    return new DayNames(attrs);
  }
  static era(attrs) {
    return new Era(attrs);
  }
  static eraNames(attrs) {
    return new EraNames(attrs);
  }
  static locale(attrs) {
    return new Locale(attrs);
  }
  static localeSet(attrs) {
    return new LocaleSet(attrs);
  }
  static meridiem(attrs) {
    return new Meridiem(attrs);
  }
  static meridiemNames(attrs) {
    return new MeridiemNames(attrs);
  }
  static month(attrs) {
    return new Month(attrs);
  }
  static monthNames(attrs) {
    return new MonthNames(attrs);
  }
  static numberPattern(attrs) {
    return new NumberPattern(attrs);
  }
  static numberPatterns(attrs) {
    return new NumberPatterns(attrs);
  }
  static numberSymbol(attrs) {
    return new NumberSymbol(attrs);
  }
  static numberSymbols(attrs) {
    return new NumberSymbols(attrs);
  }
  static timePattern(attrs) {
    return new TimePattern(attrs);
  }
  static timePatterns(attrs) {
    return new TimePatterns(attrs);
  }
  static typeFace(attrs) {
    return new TypeFace(attrs);
  }
  static typeFaces(attrs) {
    return new TypeFaces(attrs);
  }
};
var SIGNATURE_NS_ID = NamespaceIds.signature.id;
var Signature = class extends XFAObject {
  constructor(attributes) {
    super(
      SIGNATURE_NS_ID,
      "signature",
      /* hasChildren = */
      true
    );
  }
};
var SignatureNamespace = class _SignatureNamespace {
  static [$buildXFAObject](name, attributes) {
    if (_SignatureNamespace.hasOwnProperty(name)) {
      return _SignatureNamespace[name](attributes);
    }
    return void 0;
  }
  static signature(attributes) {
    return new Signature(attributes);
  }
};
var STYLESHEET_NS_ID = NamespaceIds.stylesheet.id;
var Stylesheet = class extends XFAObject {
  constructor(attributes) {
    super(
      STYLESHEET_NS_ID,
      "stylesheet",
      /* hasChildren = */
      true
    );
  }
};
var StylesheetNamespace = class _StylesheetNamespace {
  static [$buildXFAObject](name, attributes) {
    if (_StylesheetNamespace.hasOwnProperty(name)) {
      return _StylesheetNamespace[name](attributes);
    }
    return void 0;
  }
  static stylesheet(attributes) {
    return new Stylesheet(attributes);
  }
};
var XDP_NS_ID = NamespaceIds.xdp.id;
var Xdp = class extends XFAObject {
  constructor(attributes) {
    super(
      XDP_NS_ID,
      "xdp",
      /* hasChildren = */
      true
    );
    this.uuid = attributes.uuid || "";
    this.timeStamp = attributes.timeStamp || "";
    this.config = null;
    this.connectionSet = null;
    this.datasets = null;
    this.localeSet = null;
    this.stylesheet = new XFAObjectArray();
    this.template = null;
  }
  [$onChildCheck](child) {
    const ns = NamespaceIds[child[$nodeName]];
    return ns && child[$namespaceId] === ns.id;
  }
};
var XdpNamespace = class _XdpNamespace {
  static [$buildXFAObject](name, attributes) {
    if (_XdpNamespace.hasOwnProperty(name)) {
      return _XdpNamespace[name](attributes);
    }
    return void 0;
  }
  static xdp(attributes) {
    return new Xdp(attributes);
  }
};
var XHTML_NS_ID = NamespaceIds.xhtml.id;
var VALID_STYLES = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
var StyleMapping = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (value) => value === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (value) => `scaleX(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (value) => `scaleY(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (value, original) => {
  value = original.fontSize = getMeasurement(value);
  return measureToString(0.99 * value);
}], ["letter-spacing", (value) => measureToString(getMeasurement(value))], ["line-height", (value) => measureToString(getMeasurement(value))], ["margin", (value) => measureToString(getMeasurement(value))], ["margin-bottom", (value) => measureToString(getMeasurement(value))], ["margin-left", (value) => measureToString(getMeasurement(value))], ["margin-right", (value) => measureToString(getMeasurement(value))], ["margin-top", (value) => measureToString(getMeasurement(value))], ["text-indent", (value) => measureToString(getMeasurement(value))], ["font-family", (value) => value]]);
var spacesRegExp = /\s+/g;
var crlfRegExp = /[\r\n]+/g;
function mapStyle(styleStr, fontFinder) {
  const style = /* @__PURE__ */ Object.create(null);
  if (!styleStr) {
    return style;
  }
  const original = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of styleStr.split(";").map((s) => s.split(":", 2))) {
    const mapping = StyleMapping.get(key);
    if (mapping === "") {
      continue;
    }
    let newValue = value;
    if (mapping) {
      if (typeof mapping === "string") {
        newValue = mapping;
      } else {
        newValue = mapping(value, original);
      }
    }
    if (key.endsWith("scale")) {
      if (style.transform) {
        style.transform = `${style[key]} ${newValue}`;
      } else {
        style.transform = newValue;
      }
    } else {
      style[key.replaceAll(/-([a-zA-Z])/g, (_, x) => x.toUpperCase())] = newValue;
    }
  }
  if (style.fontFamily) {
    setFontFamily({
      typeface: style.fontFamily,
      weight: style.fontWeight || "normal",
      posture: style.fontStyle || "normal",
      size: original.fontSize || 0
    }, fontFinder, style);
  }
  fixTextIndent(style);
  return style;
}
function checkStyle(node) {
  if (!node.style) {
    return "";
  }
  return node.style.trim().split(/\s*;\s*/).filter((s) => !!s).map((s) => s.split(/\s*:\s*/, 2)).filter(([key, value]) => {
    if (key === "font-family") {
      node[$globalData].usedTypefaces.add(value);
    }
    return VALID_STYLES.has(key);
  }).map((kv) => kv.join(":")).join(";");
}
var NoWhites = /* @__PURE__ */ new Set(["body", "html"]);
var XhtmlObject = class extends XmlObject {
  constructor(attributes, name) {
    super(XHTML_NS_ID, name);
    this.style = attributes.style || "";
  }
  [$clean](builder) {
    super[$clean](builder);
    this.style = checkStyle(this);
  }
  [$acceptWhitespace]() {
    return !NoWhites.has(this[$nodeName]);
  }
  [$onText](str) {
    str = str.replace(crlfRegExp, "");
    if (!this.style.includes("xfa-spacerun:yes")) {
      str = str.replace(spacesRegExp, " ");
    }
    if (str) {
      this[$content] += str;
    }
  }
  [$pushGlyphs](measure, mustPop = true) {
    const xfaFont = /* @__PURE__ */ Object.create(null);
    const margin = {
      top: NaN,
      bottom: NaN,
      left: NaN,
      right: NaN
    };
    let lineHeight = null;
    for (const [key, value] of this.style.split(";").map((s) => s.split(":", 2))) {
      switch (key) {
        case "font-family":
          xfaFont.typeface = stripQuotes(value);
          break;
        case "font-size":
          xfaFont.size = getMeasurement(value);
          break;
        case "font-weight":
          xfaFont.weight = value;
          break;
        case "font-style":
          xfaFont.posture = value;
          break;
        case "letter-spacing":
          xfaFont.letterSpacing = getMeasurement(value);
          break;
        case "margin":
          const values = value.split(/ \t/).map((x) => getMeasurement(x));
          switch (values.length) {
            case 1:
              margin.top = margin.bottom = margin.left = margin.right = values[0];
              break;
            case 2:
              margin.top = margin.bottom = values[0];
              margin.left = margin.right = values[1];
              break;
            case 3:
              margin.top = values[0];
              margin.bottom = values[2];
              margin.left = margin.right = values[1];
              break;
            case 4:
              margin.top = values[0];
              margin.left = values[1];
              margin.bottom = values[2];
              margin.right = values[3];
              break;
          }
          break;
        case "margin-top":
          margin.top = getMeasurement(value);
          break;
        case "margin-bottom":
          margin.bottom = getMeasurement(value);
          break;
        case "margin-left":
          margin.left = getMeasurement(value);
          break;
        case "margin-right":
          margin.right = getMeasurement(value);
          break;
        case "line-height":
          lineHeight = getMeasurement(value);
          break;
      }
    }
    measure.pushData(xfaFont, margin, lineHeight);
    if (this[$content]) {
      measure.addString(this[$content]);
    } else {
      for (const child of this[$getChildren]()) {
        if (child[$nodeName] === "#text") {
          measure.addString(child[$content]);
          continue;
        }
        child[$pushGlyphs](measure);
      }
    }
    if (mustPop) {
      measure.popFont();
    }
  }
  [$toHTML](availableSpace) {
    const children = [];
    this[$extra] = {
      children
    };
    this[$childrenToHTML]({});
    if (children.length === 0 && !this[$content]) {
      return HTMLResult.EMPTY;
    }
    return HTMLResult.success({
      name: this[$nodeName],
      attributes: {
        href: this.href,
        style: mapStyle(this.style, this[$globalData].fontFinder)
      },
      children,
      value: this[$content] || ""
    });
  }
};
var A = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "a");
    this.href = attributes.href || "";
  }
};
var B = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "b");
  }
  [$pushGlyphs](measure) {
    measure.pushFont({
      weight: "bold"
    });
    super[$pushGlyphs](measure);
    measure.popFont();
  }
};
var Body = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "body");
  }
  [$toHTML](availableSpace) {
    const res = super[$toHTML](availableSpace);
    const {
      html
    } = res;
    if (!html) {
      return HTMLResult.EMPTY;
    }
    html.name = "div";
    html.attributes.class = ["xfaRich"];
    return res;
  }
};
var Br = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "br");
  }
  [$text]() {
    return "\n";
  }
  [$pushGlyphs](measure) {
    measure.addString("\n");
  }
  [$toHTML](availableSpace) {
    return HTMLResult.success({
      name: "br"
    });
  }
};
var Html = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "html");
  }
  [$toHTML](availableSpace) {
    const children = [];
    this[$extra] = {
      children
    };
    this[$childrenToHTML]({});
    if (children.length === 0) {
      return HTMLResult.success({
        name: "div",
        attributes: {
          class: ["xfaRich"],
          style: {}
        },
        value: this[$content] || ""
      });
    }
    if (children.length === 1) {
      const child = children[0];
      if (child.attributes && child.attributes.class.includes("xfaRich")) {
        return HTMLResult.success(child);
      }
    }
    return HTMLResult.success({
      name: "div",
      attributes: {
        class: ["xfaRich"],
        style: {}
      },
      children
    });
  }
};
var I = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "i");
  }
  [$pushGlyphs](measure) {
    measure.pushFont({
      posture: "italic"
    });
    super[$pushGlyphs](measure);
    measure.popFont();
  }
};
var Li = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "li");
  }
};
var Ol = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "ol");
  }
};
var P = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "p");
  }
  [$pushGlyphs](measure) {
    super[$pushGlyphs](
      measure,
      /* mustPop = */
      false
    );
    measure.addString("\n");
    measure.addPara();
    measure.popFont();
  }
  [$text]() {
    return super[$text]() + "\n";
  }
};
var Span = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "span");
  }
};
var Sub = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "sub");
  }
};
var Sup = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "sup");
  }
};
var Ul = class extends XhtmlObject {
  constructor(attributes) {
    super(attributes, "ul");
  }
};
var XhtmlNamespace = class _XhtmlNamespace {
  static [$buildXFAObject](name, attributes) {
    if (_XhtmlNamespace.hasOwnProperty(name)) {
      return _XhtmlNamespace[name](attributes);
    }
    return void 0;
  }
  static a(attributes) {
    return new A(attributes);
  }
  static b(attributes) {
    return new B(attributes);
  }
  static body(attributes) {
    return new Body(attributes);
  }
  static br(attributes) {
    return new Br(attributes);
  }
  static html(attributes) {
    return new Html(attributes);
  }
  static i(attributes) {
    return new I(attributes);
  }
  static li(attributes) {
    return new Li(attributes);
  }
  static ol(attributes) {
    return new Ol(attributes);
  }
  static p(attributes) {
    return new P(attributes);
  }
  static span(attributes) {
    return new Span(attributes);
  }
  static sub(attributes) {
    return new Sub(attributes);
  }
  static sup(attributes) {
    return new Sup(attributes);
  }
  static ul(attributes) {
    return new Ul(attributes);
  }
};
var NamespaceSetUp = {
  config: ConfigNamespace,
  connection: ConnectionSetNamespace,
  datasets: DatasetsNamespace,
  localeSet: LocaleSetNamespace,
  signature: SignatureNamespace,
  stylesheet: StylesheetNamespace,
  template: TemplateNamespace,
  xdp: XdpNamespace,
  xhtml: XhtmlNamespace
};
var UnknownNamespace = class {
  constructor(nsId) {
    this.namespaceId = nsId;
  }
  [$buildXFAObject](name, attributes) {
    return new XmlObject(this.namespaceId, name, attributes);
  }
};
var Root = class extends XFAObject {
  constructor(ids) {
    super(-1, "root", /* @__PURE__ */ Object.create(null));
    this.element = null;
    this[$ids] = ids;
  }
  [$onChild](child) {
    this.element = child;
    return true;
  }
  [$finalize]() {
    super[$finalize]();
    if (this.element.template instanceof Template$1) {
      this[$ids].set($root, this.element);
      this.element.template[$resolvePrototypes](this[$ids]);
      this.element.template[$ids] = this[$ids];
    }
  }
};
var Empty = class extends XFAObject {
  constructor() {
    super(-1, "", /* @__PURE__ */ Object.create(null));
  }
  [$onChild](_) {
    return false;
  }
};
var Builder = class {
  constructor() {
    this._namespaceStack = [];
    this._nsAgnosticLevel = 0;
    this._namespacePrefixes = /* @__PURE__ */ new Map();
    this._namespaces = /* @__PURE__ */ new Map();
    this._nextNsId = Math.max(...Object.values(NamespaceIds).map(({
      id
    }) => id));
    this._currentNamespace = new UnknownNamespace(++this._nextNsId);
  }
  buildRoot(ids) {
    return new Root(ids);
  }
  build({
    nsPrefix,
    name,
    attributes,
    namespace,
    prefixes
  }) {
    const hasNamespaceDef = namespace !== null;
    if (hasNamespaceDef) {
      this._namespaceStack.push(this._currentNamespace);
      this._currentNamespace = this._searchNamespace(namespace);
    }
    if (prefixes) {
      this._addNamespacePrefix(prefixes);
    }
    if (attributes.hasOwnProperty($nsAttributes)) {
      const dataTemplate = NamespaceSetUp.datasets;
      const nsAttrs = attributes[$nsAttributes];
      let xfaAttrs = null;
      for (const [ns, attrs] of Object.entries(nsAttrs)) {
        const nsToUse = this._getNamespaceToUse(ns);
        if (nsToUse === dataTemplate) {
          xfaAttrs = {
            xfa: attrs
          };
          break;
        }
      }
      if (xfaAttrs) {
        attributes[$nsAttributes] = xfaAttrs;
      } else {
        delete attributes[$nsAttributes];
      }
    }
    const namespaceToUse = this._getNamespaceToUse(nsPrefix);
    const node = namespaceToUse && namespaceToUse[$buildXFAObject](name, attributes) || new Empty();
    if (node[$isNsAgnostic]()) {
      this._nsAgnosticLevel++;
    }
    if (hasNamespaceDef || prefixes || node[$isNsAgnostic]()) {
      node[$cleanup] = {
        hasNamespace: hasNamespaceDef,
        prefixes,
        nsAgnostic: node[$isNsAgnostic]()
      };
    }
    return node;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(nsName) {
    let ns = this._namespaces.get(nsName);
    if (ns) {
      return ns;
    }
    for (const [name, {
      check
    }] of Object.entries(NamespaceIds)) {
      if (check(nsName)) {
        ns = NamespaceSetUp[name];
        if (ns) {
          this._namespaces.set(nsName, ns);
          return ns;
        }
        break;
      }
    }
    ns = new UnknownNamespace(++this._nextNsId);
    this._namespaces.set(nsName, ns);
    return ns;
  }
  _addNamespacePrefix(prefixes) {
    for (const {
      prefix,
      value
    } of prefixes) {
      const namespace = this._searchNamespace(value);
      let prefixStack = this._namespacePrefixes.get(prefix);
      if (!prefixStack) {
        prefixStack = [];
        this._namespacePrefixes.set(prefix, prefixStack);
      }
      prefixStack.push(namespace);
    }
  }
  _getNamespaceToUse(prefix) {
    if (!prefix) {
      return this._currentNamespace;
    }
    const prefixStack = this._namespacePrefixes.get(prefix);
    if (prefixStack && prefixStack.length > 0) {
      return prefixStack[prefixStack.length - 1];
    }
    warn(`Unknown namespace prefix: ${prefix}.`);
    return null;
  }
  clean(data) {
    const {
      hasNamespace,
      prefixes,
      nsAgnostic
    } = data;
    if (hasNamespace) {
      this._currentNamespace = this._namespaceStack.pop();
    }
    if (prefixes) {
      prefixes.forEach(({
        prefix
      }) => {
        this._namespacePrefixes.get(prefix).pop();
      });
    }
    if (nsAgnostic) {
      this._nsAgnosticLevel--;
    }
  }
};
var XFAParser = class _XFAParser extends XMLParserBase {
  constructor() {
    super();
    this._builder = new Builder();
    this._stack = [];
    this._globalData = {
      usedTypefaces: /* @__PURE__ */ new Set()
    };
    this._ids = /* @__PURE__ */ new Map();
    this._current = this._builder.buildRoot(this._ids);
    this._errorCode = XMLParserErrorCode.NoError;
    this._whiteRegex = /^\s+$/;
    this._nbsps = /\xa0+/g;
  }
  parse(data) {
    this.parseXml(data);
    if (this._errorCode !== XMLParserErrorCode.NoError) {
      return void 0;
    }
    this._current[$finalize]();
    return this._current.element;
  }
  onText(text) {
    text = text.replace(this._nbsps, (match) => match.slice(1) + " ");
    if (this._current[$acceptWhitespace]()) {
      this._current[$onText](text);
      return;
    }
    if (this._whiteRegex.test(text)) {
      return;
    }
    this._current[$onText](text.trim());
  }
  onCdata(text) {
    this._current[$onText](text);
  }
  _mkAttributes(attributes, tagName) {
    let namespace = null;
    let prefixes = null;
    const attributeObj = /* @__PURE__ */ Object.create({});
    for (const {
      name,
      value
    } of attributes) {
      if (name === "xmlns") {
        if (!namespace) {
          namespace = value;
        } else {
          warn(`XFA - multiple namespace definition in <${tagName}>`);
        }
      } else if (name.startsWith("xmlns:")) {
        const prefix = name.substring("xmlns:".length);
        if (!prefixes) {
          prefixes = [];
        }
        prefixes.push({
          prefix,
          value
        });
      } else {
        const i = name.indexOf(":");
        if (i === -1) {
          attributeObj[name] = value;
        } else {
          let nsAttrs = attributeObj[$nsAttributes];
          if (!nsAttrs) {
            nsAttrs = attributeObj[$nsAttributes] = /* @__PURE__ */ Object.create(null);
          }
          const [ns, attrName] = [name.slice(0, i), name.slice(i + 1)];
          let attrs = nsAttrs[ns];
          if (!attrs) {
            attrs = nsAttrs[ns] = /* @__PURE__ */ Object.create(null);
          }
          attrs[attrName] = value;
        }
      }
    }
    return [namespace, prefixes, attributeObj];
  }
  _getNameAndPrefix(name, nsAgnostic) {
    const i = name.indexOf(":");
    if (i === -1) {
      return [name, null];
    }
    return [name.substring(i + 1), nsAgnostic ? "" : name.substring(0, i)];
  }
  onBeginElement(tagName, attributes, isEmpty) {
    const [namespace, prefixes, attributesObj] = this._mkAttributes(attributes, tagName);
    const [name, nsPrefix] = this._getNameAndPrefix(tagName, this._builder.isNsAgnostic());
    const node = this._builder.build({
      nsPrefix,
      name,
      attributes: attributesObj,
      namespace,
      prefixes
    });
    node[$globalData] = this._globalData;
    if (isEmpty) {
      node[$finalize]();
      if (this._current[$onChild](node)) {
        node[$setId](this._ids);
      }
      node[$clean](this._builder);
      return;
    }
    this._stack.push(this._current);
    this._current = node;
  }
  onEndElement(name) {
    const node = this._current;
    if (node[$isCDATAXml]() && typeof node[$content] === "string") {
      const parser = new _XFAParser();
      parser._globalData = this._globalData;
      const root = parser.parse(node[$content]);
      node[$content] = null;
      node[$onChild](root);
    }
    node[$finalize]();
    this._current = this._stack.pop();
    if (this._current[$onChild](node)) {
      node[$setId](this._ids);
    }
    node[$clean](this._builder);
  }
  onError(code) {
    this._errorCode = code;
  }
};
var XFAFactory = class _XFAFactory {
  constructor(data) {
    try {
      this.root = new XFAParser().parse(_XFAFactory._createDocument(data));
      const binder = new Binder(this.root);
      this.form = binder.bind();
      this.dataHandler = new DataHandler(this.root, binder.getData());
      this.form[$globalData].template = this.form;
    } catch (e) {
      warn(`XFA - an error occurred during parsing and binding: ${e}`);
    }
  }
  isValid() {
    return this.root && this.form;
  }
  _createPages() {
    try {
      this.pages = this.form[$toHTML]();
      this.dims = this.pages.children.map((c) => {
        const {
          width,
          height
        } = c.attributes.style;
        return [0, 0, parseInt(width), parseInt(height)];
      });
    } catch (e) {
      warn(`XFA - an error occurred during layout: ${e}`);
    }
  }
  getBoundingBox(pageIndex) {
    return this.dims[pageIndex];
  }
  get numberPages() {
    if (!this.pages) {
      this._createPages();
    }
    return this.dims.length;
  }
  setImages(images) {
    this.form[$globalData].images = images;
  }
  setFonts(fonts) {
    this.form[$globalData].fontFinder = new FontFinder(fonts);
    const missingFonts = [];
    for (let typeface of this.form[$globalData].usedTypefaces) {
      typeface = stripQuotes(typeface);
      const font = this.form[$globalData].fontFinder.find(typeface);
      if (!font) {
        missingFonts.push(typeface);
      }
    }
    if (missingFonts.length > 0) {
      return missingFonts;
    }
    return null;
  }
  appendFonts(fonts, reallyMissingFonts) {
    this.form[$globalData].fontFinder.add(fonts, reallyMissingFonts);
  }
  getPages() {
    if (!this.pages) {
      this._createPages();
    }
    const pages = this.pages;
    this.pages = null;
    return pages;
  }
  serializeData(storage) {
    return this.dataHandler.serialize(storage);
  }
  static _createDocument(data) {
    if (!data["/xdp:xdp"]) {
      return data["xdp:xdp"];
    }
    return Object.values(data).join("");
  }
};
var XRef = class {
  constructor(stream, pdfManager) {
    this.stream = stream;
    this.pdfManager = pdfManager;
    this.entries = [];
    this.xrefstms = /* @__PURE__ */ Object.create(null);
    this._cacheMap = /* @__PURE__ */ new Map();
    this.stats = {
      streamTypes: /* @__PURE__ */ Object.create(null),
      fontTypes: /* @__PURE__ */ Object.create(null)
    };
    this._newRefNum = null;
  }
  getNewRef() {
    if (this._newRefNum === null) {
      this._newRefNum = this.entries.length;
    }
    return Ref.get(this._newRefNum++, 0);
  }
  resetNewRef() {
    this._newRefNum = null;
  }
  setStartXRef(startXRef) {
    this.startXRefQueue = [startXRef];
  }
  parse(recoveryMode = false) {
    let trailerDict;
    if (!recoveryMode) {
      trailerDict = this.readXRef();
    } else {
      warn("Indexing all PDF objects");
      trailerDict = this.indexObjects();
    }
    trailerDict.assignXref(this);
    this.trailer = trailerDict;
    let encrypt;
    try {
      encrypt = trailerDict.get("Encrypt");
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
    }
    if (isDict(encrypt)) {
      const ids = trailerDict.get("ID");
      const fileId = ids && ids.length ? ids[0] : "";
      encrypt.suppressEncryption = true;
      this.encrypt = new CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
    }
    let root;
    try {
      root = trailerDict.get("Root");
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn(`XRef.parse - Invalid "Root" reference: "${ex}".`);
    }
    if (isDict(root) && root.has("Pages")) {
      this.root = root;
    } else {
      if (!recoveryMode) {
        throw new XRefParseException();
      }
      throw new FormatError("Invalid root reference");
    }
  }
  processXRefTable(parser) {
    if (!("tableState" in this)) {
      this.tableState = {
        entryNum: 0,
        streamPos: parser.lexer.stream.pos,
        parserBuf1: parser.buf1,
        parserBuf2: parser.buf2
      };
    }
    const obj = this.readXRefTable(parser);
    if (!isCmd(obj, "trailer")) {
      throw new FormatError("Invalid XRef table: could not find trailer dictionary");
    }
    let dict = parser.getObj();
    if (!isDict(dict) && dict.dict) {
      dict = dict.dict;
    }
    if (!isDict(dict)) {
      throw new FormatError("Invalid XRef table: could not parse trailer dictionary");
    }
    delete this.tableState;
    return dict;
  }
  readXRefTable(parser) {
    const stream = parser.lexer.stream;
    const tableState = this.tableState;
    stream.pos = tableState.streamPos;
    parser.buf1 = tableState.parserBuf1;
    parser.buf2 = tableState.parserBuf2;
    let obj;
    while (true) {
      if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
        if (isCmd(obj = parser.getObj(), "trailer")) {
          break;
        }
        tableState.firstEntryNum = obj;
        tableState.entryCount = parser.getObj();
      }
      let first = tableState.firstEntryNum;
      const count = tableState.entryCount;
      if (!Number.isInteger(first) || !Number.isInteger(count)) {
        throw new FormatError("Invalid XRef table: wrong types in subsection header");
      }
      for (let i = tableState.entryNum; i < count; i++) {
        tableState.streamPos = stream.pos;
        tableState.entryNum = i;
        tableState.parserBuf1 = parser.buf1;
        tableState.parserBuf2 = parser.buf2;
        const entry = {};
        entry.offset = parser.getObj();
        entry.gen = parser.getObj();
        const type = parser.getObj();
        if (type instanceof Cmd) {
          switch (type.cmd) {
            case "f":
              entry.free = true;
              break;
            case "n":
              entry.uncompressed = true;
              break;
          }
        }
        if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
          throw new FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`);
        }
        if (i === 0 && entry.free && first === 1) {
          first = 0;
        }
        if (!this.entries[i + first]) {
          this.entries[i + first] = entry;
        }
      }
      tableState.entryNum = 0;
      tableState.streamPos = stream.pos;
      tableState.parserBuf1 = parser.buf1;
      tableState.parserBuf2 = parser.buf2;
      delete tableState.firstEntryNum;
      delete tableState.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free) {
      throw new FormatError("Invalid XRef table: unexpected first object");
    }
    return obj;
  }
  processXRefStream(stream) {
    if (!("streamState" in this)) {
      const streamParameters = stream.dict;
      const byteWidths = streamParameters.get("W");
      let range = streamParameters.get("Index");
      if (!range) {
        range = [0, streamParameters.get("Size")];
      }
      this.streamState = {
        entryRanges: range,
        byteWidths,
        entryNum: 0,
        streamPos: stream.pos
      };
    }
    this.readXRefStream(stream);
    delete this.streamState;
    return stream.dict;
  }
  readXRefStream(stream) {
    let i, j;
    const streamState = this.streamState;
    stream.pos = streamState.streamPos;
    const byteWidths = streamState.byteWidths;
    const typeFieldWidth = byteWidths[0];
    const offsetFieldWidth = byteWidths[1];
    const generationFieldWidth = byteWidths[2];
    const entryRanges = streamState.entryRanges;
    while (entryRanges.length > 0) {
      const first = entryRanges[0];
      const n = entryRanges[1];
      if (!Number.isInteger(first) || !Number.isInteger(n)) {
        throw new FormatError(`Invalid XRef range fields: ${first}, ${n}`);
      }
      if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
        throw new FormatError(`Invalid XRef entry fields length: ${first}, ${n}`);
      }
      for (i = streamState.entryNum; i < n; ++i) {
        streamState.entryNum = i;
        streamState.streamPos = stream.pos;
        let type = 0, offset = 0, generation = 0;
        for (j = 0; j < typeFieldWidth; ++j) {
          type = type << 8 | stream.getByte();
        }
        if (typeFieldWidth === 0) {
          type = 1;
        }
        for (j = 0; j < offsetFieldWidth; ++j) {
          offset = offset << 8 | stream.getByte();
        }
        for (j = 0; j < generationFieldWidth; ++j) {
          generation = generation << 8 | stream.getByte();
        }
        const entry = {};
        entry.offset = offset;
        entry.gen = generation;
        switch (type) {
          case 0:
            entry.free = true;
            break;
          case 1:
            entry.uncompressed = true;
            break;
          case 2:
            break;
          default:
            throw new FormatError(`Invalid XRef entry type: ${type}`);
        }
        if (!this.entries[first + i]) {
          this.entries[first + i] = entry;
        }
      }
      streamState.entryNum = 0;
      streamState.streamPos = stream.pos;
      entryRanges.splice(0, 2);
    }
  }
  indexObjects() {
    const TAB = 9, LF = 10, CR = 13, SPACE = 32;
    const PERCENT = 37, LT = 60;
    function readToken(data, offset) {
      let token = "", ch = data[offset];
      while (ch !== LF && ch !== CR && ch !== LT) {
        if (++offset >= data.length) {
          break;
        }
        token += String.fromCharCode(ch);
        ch = data[offset];
      }
      return token;
    }
    function skipUntil(data, offset, what) {
      const length2 = what.length, dataLength = data.length;
      let skipped = 0;
      while (offset < dataLength) {
        let i = 0;
        while (i < length2 && data[offset + i] === what[i]) {
          ++i;
        }
        if (i >= length2) {
          break;
        }
        offset++;
        skipped++;
      }
      return skipped;
    }
    const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
    const endobjRegExp = /\bendobj[\b\s]$/;
    const nestedObjRegExp = /\s+(\d+\s+\d+\s+obj[\b\s<])$/;
    const CHECK_CONTENT_LENGTH = 25;
    const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
    const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
    const objBytes = new Uint8Array([111, 98, 106]);
    const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0;
    const stream = this.stream;
    stream.pos = 0;
    const buffer = stream.getBytes(), length = buffer.length;
    let position = stream.start;
    const trailers = [], xrefStms = [];
    while (position < length) {
      let ch = buffer[position];
      if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
        ++position;
        continue;
      }
      if (ch === PERCENT) {
        do {
          ++position;
          if (position >= length) {
            break;
          }
          ch = buffer[position];
        } while (ch !== LF && ch !== CR);
        continue;
      }
      const token = readToken(buffer, position);
      let m;
      if (token.startsWith("xref") && (token.length === 4 || /\s/.test(token[4]))) {
        position += skipUntil(buffer, position, trailerBytes);
        trailers.push(position);
        position += skipUntil(buffer, position, startxrefBytes);
      } else if (m = objRegExp.exec(token)) {
        const num = m[1] | 0, gen = m[2] | 0;
        let contentLength, startPos = position + token.length, updateEntries = false;
        if (!this.entries[num]) {
          updateEntries = true;
        } else if (this.entries[num].gen === gen) {
          try {
            const parser = new Parser({
              lexer: new Lexer(stream.makeSubStream(startPos))
            });
            parser.getObj();
            updateEntries = true;
          } catch (ex) {
            if (ex instanceof ParserEOFException) {
              warn(`indexObjects -- checking object (${token}): "${ex}".`);
            } else {
              updateEntries = true;
            }
          }
        }
        if (updateEntries) {
          this.entries[num] = {
            offset: position - stream.start,
            gen,
            uncompressed: true
          };
        }
        while (startPos < buffer.length) {
          const endPos = startPos + skipUntil(buffer, startPos, objBytes) + 4;
          contentLength = endPos - position;
          const checkPos = Math.max(endPos - CHECK_CONTENT_LENGTH, startPos);
          const tokenStr = bytesToString(buffer.subarray(checkPos, endPos));
          if (endobjRegExp.test(tokenStr)) {
            break;
          } else {
            const objToken = nestedObjRegExp.exec(tokenStr);
            if (objToken && objToken[1]) {
              warn('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.');
              contentLength -= objToken[1].length;
              break;
            }
          }
          startPos = endPos;
        }
        const content = buffer.subarray(position, position + contentLength);
        const xrefTagOffset = skipUntil(content, 0, xrefBytes);
        if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
          xrefStms.push(position - stream.start);
          this.xrefstms[position - stream.start] = 1;
        }
        position += contentLength;
      } else if (token.startsWith("trailer") && (token.length === 7 || /\s/.test(token[7]))) {
        trailers.push(position);
        position += skipUntil(buffer, position, startxrefBytes);
      } else {
        position += token.length + 1;
      }
    }
    for (let i = 0, ii = xrefStms.length; i < ii; ++i) {
      this.startXRefQueue.push(xrefStms[i]);
      this.readXRef(
        /* recoveryMode */
        true
      );
    }
    let trailerDict;
    for (let i = 0, ii = trailers.length; i < ii; ++i) {
      stream.pos = trailers[i];
      const parser = new Parser({
        lexer: new Lexer(stream),
        xref: this,
        allowStreams: true,
        recoveryMode: true
      });
      const obj = parser.getObj();
      if (!isCmd(obj, "trailer")) {
        continue;
      }
      const dict = parser.getObj();
      if (!isDict(dict)) {
        continue;
      }
      try {
        const rootDict = dict.get("Root");
        if (!(rootDict instanceof Dict)) {
          continue;
        }
        const pagesDict = rootDict.get("Pages");
        if (!(pagesDict instanceof Dict)) {
          continue;
        }
        const pagesCount = pagesDict.get("Count");
        if (!Number.isInteger(pagesCount)) {
          continue;
        }
      } catch (ex) {
        continue;
      }
      if (dict.has("ID")) {
        return dict;
      }
      trailerDict = dict;
    }
    if (trailerDict) {
      return trailerDict;
    }
    throw new InvalidPDFException("Invalid PDF structure.");
  }
  readXRef(recoveryMode = false) {
    const stream = this.stream;
    const startXRefParsedCache = /* @__PURE__ */ new Set();
    try {
      while (this.startXRefQueue.length) {
        const startXRef = this.startXRefQueue[0];
        if (startXRefParsedCache.has(startXRef)) {
          warn("readXRef - skipping XRef table since it was already parsed.");
          this.startXRefQueue.shift();
          continue;
        }
        startXRefParsedCache.add(startXRef);
        stream.pos = startXRef + stream.start;
        const parser = new Parser({
          lexer: new Lexer(stream),
          xref: this,
          allowStreams: true
        });
        let obj = parser.getObj();
        let dict;
        if (isCmd(obj, "xref")) {
          dict = this.processXRefTable(parser);
          if (!this.topDict) {
            this.topDict = dict;
          }
          obj = dict.get("XRefStm");
          if (Number.isInteger(obj)) {
            const pos = obj;
            if (!(pos in this.xrefstms)) {
              this.xrefstms[pos] = 1;
              this.startXRefQueue.push(pos);
            }
          }
        } else if (Number.isInteger(obj)) {
          if (!Number.isInteger(parser.getObj()) || !isCmd(parser.getObj(), "obj") || !isStream(obj = parser.getObj())) {
            throw new FormatError("Invalid XRef stream");
          }
          dict = this.processXRefStream(obj);
          if (!this.topDict) {
            this.topDict = dict;
          }
          if (!dict) {
            throw new FormatError("Failed to read XRef stream");
          }
        } else {
          throw new FormatError("Invalid XRef stream header");
        }
        obj = dict.get("Prev");
        if (Number.isInteger(obj)) {
          this.startXRefQueue.push(obj);
        } else if (isRef(obj)) {
          this.startXRefQueue.push(obj.num);
        }
        this.startXRefQueue.shift();
      }
      return this.topDict;
    } catch (e) {
      if (e instanceof MissingDataException) {
        throw e;
      }
      info("(while reading XRef): " + e);
    }
    if (recoveryMode) {
      return void 0;
    }
    throw new XRefParseException();
  }
  getEntry(i) {
    const xrefEntry = this.entries[i];
    if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
      return xrefEntry;
    }
    return null;
  }
  fetchIfRef(obj, suppressEncryption = false) {
    if (obj instanceof Ref) {
      return this.fetch(obj, suppressEncryption);
    }
    return obj;
  }
  fetch(ref, suppressEncryption = false) {
    if (!(ref instanceof Ref)) {
      throw new Error("ref object is not a reference");
    }
    const num = ref.num;
    const cacheEntry = this._cacheMap.get(num);
    if (cacheEntry !== void 0) {
      if (cacheEntry instanceof Dict && !cacheEntry.objId) {
        cacheEntry.objId = ref.toString();
      }
      return cacheEntry;
    }
    let xrefEntry = this.getEntry(num);
    if (xrefEntry === null) {
      this._cacheMap.set(num, xrefEntry);
      return xrefEntry;
    }
    if (xrefEntry.uncompressed) {
      xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
    } else {
      xrefEntry = this.fetchCompressed(ref, xrefEntry, suppressEncryption);
    }
    if (isDict(xrefEntry)) {
      xrefEntry.objId = ref.toString();
    } else if (isStream(xrefEntry)) {
      xrefEntry.dict.objId = ref.toString();
    }
    return xrefEntry;
  }
  fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {
    const gen = ref.gen;
    let num = ref.num;
    if (xrefEntry.gen !== gen) {
      throw new XRefEntryException(`Inconsistent generation in XRef: ${ref}`);
    }
    const stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
    const parser = new Parser({
      lexer: new Lexer(stream),
      xref: this,
      allowStreams: true
    });
    const obj1 = parser.getObj();
    const obj2 = parser.getObj();
    const obj3 = parser.getObj();
    if (obj1 !== num || obj2 !== gen || !(obj3 instanceof Cmd)) {
      throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
    }
    if (obj3.cmd !== "obj") {
      if (obj3.cmd.startsWith("obj")) {
        num = parseInt(obj3.cmd.substring(3), 10);
        if (!Number.isNaN(num)) {
          return num;
        }
      }
      throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
    }
    if (this.encrypt && !suppressEncryption) {
      xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
    } else {
      xrefEntry = parser.getObj();
    }
    if (!isStream(xrefEntry)) {
      if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
        assert(xrefEntry !== void 0, 'fetchUncompressed: The "xrefEntry" cannot be undefined.');
      }
      this._cacheMap.set(num, xrefEntry);
    }
    return xrefEntry;
  }
  fetchCompressed(ref, xrefEntry, suppressEncryption = false) {
    const tableOffset = xrefEntry.offset;
    const stream = this.fetch(Ref.get(tableOffset, 0));
    if (!isStream(stream)) {
      throw new FormatError("bad ObjStm stream");
    }
    const first = stream.dict.get("First");
    const n = stream.dict.get("N");
    if (!Number.isInteger(first) || !Number.isInteger(n)) {
      throw new FormatError("invalid first and n parameters for ObjStm stream");
    }
    let parser = new Parser({
      lexer: new Lexer(stream),
      xref: this,
      allowStreams: true
    });
    const nums = new Array(n);
    const offsets = new Array(n);
    for (let i = 0; i < n; ++i) {
      const num = parser.getObj();
      if (!Number.isInteger(num)) {
        throw new FormatError(`invalid object number in the ObjStm stream: ${num}`);
      }
      const offset = parser.getObj();
      if (!Number.isInteger(offset)) {
        throw new FormatError(`invalid object offset in the ObjStm stream: ${offset}`);
      }
      nums[i] = num;
      offsets[i] = offset;
    }
    const start = (stream.start || 0) + first;
    const entries = new Array(n);
    for (let i = 0; i < n; ++i) {
      const length = i < n - 1 ? offsets[i + 1] - offsets[i] : void 0;
      if (length < 0) {
        throw new FormatError("Invalid offset in the ObjStm stream.");
      }
      parser = new Parser({
        lexer: new Lexer(stream.makeSubStream(start + offsets[i], length, stream.dict)),
        xref: this,
        allowStreams: true
      });
      const obj = parser.getObj();
      entries[i] = obj;
      if (isStream(obj)) {
        continue;
      }
      const num = nums[i], entry = this.entries[num];
      if (entry && entry.offset === tableOffset && entry.gen === i) {
        if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
          assert(obj !== void 0, 'fetchCompressed: The "obj" cannot be undefined.');
        }
        this._cacheMap.set(num, obj);
      }
    }
    xrefEntry = entries[xrefEntry.gen];
    if (xrefEntry === void 0) {
      throw new XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
    }
    return xrefEntry;
  }
  async fetchIfRefAsync(obj, suppressEncryption) {
    if (obj instanceof Ref) {
      return this.fetchAsync(obj, suppressEncryption);
    }
    return obj;
  }
  async fetchAsync(ref, suppressEncryption) {
    try {
      return this.fetch(ref, suppressEncryption);
    } catch (ex) {
      if (!(ex instanceof MissingDataException)) {
        throw ex;
      }
      await this.pdfManager.requestRange(ex.begin, ex.end);
      return this.fetchAsync(ref, suppressEncryption);
    }
  }
  getCatalogObj() {
    return this.root;
  }
};
var DEFAULT_USER_UNIT = 1;
var LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
var Page = class {
  constructor({
    pdfManager,
    xref,
    pageIndex,
    pageDict,
    ref,
    globalIdFactory,
    fontCache,
    builtInCMapCache,
    standardFontDataCache,
    globalImageCache,
    nonBlendModesSet,
    xfaFactory
  }) {
    this.pdfManager = pdfManager;
    this.pageIndex = pageIndex;
    this.pageDict = pageDict;
    this.xref = xref;
    this.ref = ref;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    this.standardFontDataCache = standardFontDataCache;
    this.globalImageCache = globalImageCache;
    this.nonBlendModesSet = nonBlendModesSet;
    this.evaluatorOptions = pdfManager.evaluatorOptions;
    this.resourcesPromise = null;
    this.xfaFactory = xfaFactory;
    const idCounters = {
      obj: 0
    };
    this._localIdFactory = class extends globalIdFactory {
      static createObjId() {
        return `p${pageIndex}_${++idCounters.obj}`;
      }
      static getPageObjId() {
        return `page${ref.toString()}`;
      }
    };
  }
  /**
   * @private
   */
  _getInheritableProperty(key, getArray = false) {
    const value = getInheritableProperty({
      dict: this.pageDict,
      key,
      getArray,
      stopWhenFound: false
    });
    if (!Array.isArray(value)) {
      return value;
    }
    if (value.length === 1 || !isDict(value[0])) {
      return value[0];
    }
    return Dict.merge({
      xref: this.xref,
      dictArray: value
    });
  }
  get content() {
    return this.pageDict.getArray("Contents");
  }
  get resources() {
    return shadow(this, "resources", this._getInheritableProperty("Resources") || Dict.empty);
  }
  _getBoundingBox(name) {
    if (this.xfaData) {
      return this.xfaData.bbox;
    }
    const box = this._getInheritableProperty(
      name,
      /* getArray = */
      true
    );
    if (Array.isArray(box) && box.length === 4) {
      if (box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
        return box;
      }
      warn(`Empty /${name} entry.`);
    }
    return null;
  }
  get mediaBox() {
    return shadow(this, "mediaBox", this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX);
  }
  get cropBox() {
    return shadow(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
  }
  get userUnit() {
    let obj = this.pageDict.get("UserUnit");
    if (!isNum(obj) || obj <= 0) {
      obj = DEFAULT_USER_UNIT;
    }
    return shadow(this, "userUnit", obj);
  }
  get view() {
    const {
      cropBox,
      mediaBox
    } = this;
    let view;
    if (cropBox === mediaBox || isArrayEqual(cropBox, mediaBox)) {
      view = mediaBox;
    } else {
      const box = Util.intersect(cropBox, mediaBox);
      if (box && box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
        view = box;
      } else {
        warn("Empty /CropBox and /MediaBox intersection.");
      }
    }
    return shadow(this, "view", view || mediaBox);
  }
  get rotate() {
    let rotate = this._getInheritableProperty("Rotate") || 0;
    if (rotate % 90 !== 0) {
      rotate = 0;
    } else if (rotate >= 360) {
      rotate %= 360;
    } else if (rotate < 0) {
      rotate = (rotate % 360 + 360) % 360;
    }
    return shadow(this, "rotate", rotate);
  }
  /**
   * @returns {Promise<BaseStream>}
   */
  getContentStream() {
    return this.pdfManager.ensure(this, "content").then((content) => {
      if (content instanceof BaseStream) {
        return content;
      }
      if (Array.isArray(content)) {
        return new StreamsSequenceStream(content);
      }
      return new NullStream();
    });
  }
  get xfaData() {
    if (this.xfaFactory) {
      return shadow(this, "xfaData", {
        bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
      });
    }
    return shadow(this, "xfaData", null);
  }
  save(handler, task, annotationStorage) {
    const partialEvaluator = new PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      options: this.evaluatorOptions
    });
    return this._parsedAnnotations.then(function(annotations) {
      const newRefsPromises = [];
      for (const annotation of annotations) {
        if (!annotation.mustBePrinted(annotationStorage)) {
          continue;
        }
        newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage).catch(function(reason) {
          warn(`save - ignoring annotation data during "${task.name}" task: "${reason}".`);
          return null;
        }));
      }
      return Promise.all(newRefsPromises);
    });
  }
  loadResources(keys) {
    if (!this.resourcesPromise) {
      this.resourcesPromise = this.pdfManager.ensure(this, "resources");
    }
    return this.resourcesPromise.then(() => {
      const objectLoader = new ObjectLoader(this.resources, keys, this.xref);
      return objectLoader.load();
    });
  }
  getOperatorList({
    handler,
    sink,
    task,
    intent,
    renderInteractiveForms,
    annotationStorage
  }) {
    const contentStreamPromise = this.getContentStream();
    const resourcesPromise = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]);
    const partialEvaluator = new PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      options: this.evaluatorOptions
    });
    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
    const pageListPromise = dataPromises.then(([contentStream]) => {
      const opList = new OperatorList(intent, sink);
      handler.send("StartRenderPage", {
        transparency: partialEvaluator.hasBlendModes(this.resources, this.nonBlendModesSet),
        pageIndex: this.pageIndex,
        intent
      });
      return partialEvaluator.getOperatorList({
        stream: contentStream,
        task,
        resources: this.resources,
        operatorList: opList
      }).then(function() {
        return opList;
      });
    });
    return Promise.all([pageListPromise, this._parsedAnnotations]).then(function([pageOpList, annotations]) {
      if (annotations.length === 0) {
        pageOpList.flush(true);
        return {
          length: pageOpList.totalLength
        };
      }
      const annotationIntent = intent.startsWith("oplist-") ? intent.split("-")[1] : intent;
      const opListPromises = [];
      for (const annotation of annotations) {
        if (annotationIntent === "display" && annotation.mustBeViewed(annotationStorage) || annotationIntent === "print" && annotation.mustBePrinted(annotationStorage)) {
          opListPromises.push(annotation.getOperatorList(partialEvaluator, task, renderInteractiveForms, annotationStorage).catch(function(reason) {
            warn(`getOperatorList - ignoring annotation data during "${task.name}" task: "${reason}".`);
            return null;
          }));
        }
      }
      return Promise.all(opListPromises).then(function(opLists) {
        pageOpList.addOp(OPS.beginAnnotations, []);
        for (const opList of opLists) {
          pageOpList.addOpList(opList);
        }
        pageOpList.addOp(OPS.endAnnotations, []);
        pageOpList.flush(true);
        return {
          length: pageOpList.totalLength
        };
      });
    });
  }
  extractTextContent({
    handler,
    task,
    normalizeWhitespace,
    includeMarkedContent,
    sink,
    combineTextItems
  }) {
    const contentStreamPromise = this.getContentStream();
    const resourcesPromise = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
    return dataPromises.then(([contentStream]) => {
      const partialEvaluator = new PartialEvaluator({
        xref: this.xref,
        handler,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        standardFontDataCache: this.standardFontDataCache,
        globalImageCache: this.globalImageCache,
        options: this.evaluatorOptions
      });
      return partialEvaluator.getTextContent({
        stream: contentStream,
        task,
        resources: this.resources,
        normalizeWhitespace,
        includeMarkedContent,
        combineTextItems,
        sink
      });
    });
  }
  async getStructTree() {
    const structTreeRoot = await this.pdfManager.ensureCatalog("structTreeRoot");
    if (!structTreeRoot) {
      return null;
    }
    const structTree = await this.pdfManager.ensure(this, "_parseStructTree", [structTreeRoot]);
    return structTree.serializable;
  }
  /**
   * @private
   */
  _parseStructTree(structTreeRoot) {
    const tree = new StructTreePage(structTreeRoot, this.pageDict);
    tree.parse();
    return tree;
  }
  getAnnotationsData(intent) {
    return this._parsedAnnotations.then(function(annotations) {
      const annotationsData = [];
      for (let i = 0, ii = annotations.length; i < ii; i++) {
        if (!intent || intent === "display" && annotations[i].viewable || intent === "print" && annotations[i].printable) {
          annotationsData.push(annotations[i].data);
        }
      }
      return annotationsData;
    });
  }
  get annotations() {
    const annots = this._getInheritableProperty("Annots");
    return shadow(this, "annotations", Array.isArray(annots) ? annots : []);
  }
  get _parsedAnnotations() {
    const parsedAnnotations = this.pdfManager.ensure(this, "annotations").then(() => {
      const annotationPromises = [];
      for (const annotationRef of this.annotations) {
        annotationPromises.push(AnnotationFactory.create(
          this.xref,
          annotationRef,
          this.pdfManager,
          this._localIdFactory,
          /* collectFields */
          false
        ).catch(function(reason) {
          warn(`_parsedAnnotations: "${reason}".`);
          return null;
        }));
      }
      return Promise.all(annotationPromises).then(function(annotations) {
        return annotations.filter((annotation) => !!annotation);
      });
    });
    return shadow(this, "_parsedAnnotations", parsedAnnotations);
  }
  get jsActions() {
    const actions = collectActions(this.xref, this.pageDict, PageActionEventType);
    return shadow(this, "jsActions", actions);
  }
};
var PDF_HEADER_SIGNATURE = new Uint8Array([37, 80, 68, 70, 45]);
var STARTXREF_SIGNATURE = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
var ENDOBJ_SIGNATURE = new Uint8Array([101, 110, 100, 111, 98, 106]);
var FINGERPRINT_FIRST_BYTES = 1024;
var EMPTY_FINGERPRINT = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
var PDF_HEADER_VERSION_REGEXP = /^[1-9]\.[0-9]$/;
function find(stream, signature, limit = 1024, backwards = false) {
  if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
    assert(limit > 0, 'The "limit" must be a positive integer.');
  }
  const signatureLength = signature.length;
  const scanBytes = stream.peekBytes(limit);
  const scanLength = scanBytes.length - signatureLength;
  if (scanLength <= 0) {
    return false;
  }
  if (backwards) {
    const signatureEnd = signatureLength - 1;
    let pos = scanBytes.length - 1;
    while (pos >= signatureEnd) {
      let j = 0;
      while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) {
        j++;
      }
      if (j >= signatureLength) {
        stream.pos += pos - signatureEnd;
        return true;
      }
      pos--;
    }
  } else {
    let pos = 0;
    while (pos <= scanLength) {
      let j = 0;
      while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
        j++;
      }
      if (j >= signatureLength) {
        stream.pos += pos;
        return true;
      }
      pos++;
    }
  }
  return false;
}
var PDFDocument = class {
  constructor(pdfManager, arg) {
    let stream;
    if (isStream(arg)) {
      stream = arg;
    } else if (isArrayBuffer(arg)) {
      stream = new Stream(arg);
    } else {
      throw new Error("PDFDocument: Unknown argument type");
    }
    if (stream.length <= 0) {
      throw new InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
    }
    this.pdfManager = pdfManager;
    this.stream = stream;
    this.xref = new XRef(stream, pdfManager);
    this._pagePromises = [];
    this._version = null;
    const idCounters = {
      font: 0
    };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${pdfManager.docId}`;
      }
      static createFontId() {
        return `f${++idCounters.font}`;
      }
      static createObjId() {
        unreachable("Abstract method `createObjId` called.");
      }
      static getPageObjId() {
        unreachable("Abstract method `getPageObjId` called.");
      }
    };
  }
  parse(recoveryMode) {
    this.xref.parse(recoveryMode);
    this.catalog = new Catalog(this.pdfManager, this.xref);
    if (this.catalog.version) {
      this._version = this.catalog.version;
    }
  }
  get linearization() {
    let linearization = null;
    try {
      linearization = Linearization.create(this.stream);
    } catch (err) {
      if (err instanceof MissingDataException) {
        throw err;
      }
      info(err);
    }
    return shadow(this, "linearization", linearization);
  }
  get startXRef() {
    const stream = this.stream;
    let startXRef = 0;
    if (this.linearization) {
      stream.reset();
      if (find(stream, ENDOBJ_SIGNATURE)) {
        startXRef = stream.pos + 6 - stream.start;
      }
    } else {
      const step = 1024;
      const startXRefLength = STARTXREF_SIGNATURE.length;
      let found = false, pos = stream.end;
      while (!found && pos > 0) {
        pos -= step - startXRefLength;
        if (pos < 0) {
          pos = 0;
        }
        stream.pos = pos;
        found = find(stream, STARTXREF_SIGNATURE, step, true);
      }
      if (found) {
        stream.skip(9);
        let ch;
        do {
          ch = stream.getByte();
        } while (isWhiteSpace(ch));
        let str = "";
        while (ch >= /* Space = */
        32 && ch <= /* '9' = */
        57) {
          str += String.fromCharCode(ch);
          ch = stream.getByte();
        }
        startXRef = parseInt(str, 10);
        if (isNaN(startXRef)) {
          startXRef = 0;
        }
      }
    }
    return shadow(this, "startXRef", startXRef);
  }
  // Find the header, get the PDF format version and setup the
  // stream to start from the header.
  checkHeader() {
    const stream = this.stream;
    stream.reset();
    if (!find(stream, PDF_HEADER_SIGNATURE)) {
      return;
    }
    stream.moveStart();
    const MAX_PDF_VERSION_LENGTH = 12;
    let version = "", ch;
    while ((ch = stream.getByte()) > /* Space = */
    32) {
      if (version.length >= MAX_PDF_VERSION_LENGTH) {
        break;
      }
      version += String.fromCharCode(ch);
    }
    if (!this._version) {
      this._version = version.substring(5);
    }
  }
  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }
  get numPages() {
    if (this.xfaFactory) {
      return shadow(this, "numPages", this.xfaFactory.numberPages);
    }
    const linearization = this.linearization;
    const num = linearization ? linearization.numPages : this.catalog.numPages;
    return shadow(this, "numPages", num);
  }
  /**
   * @private
   */
  _hasOnlyDocumentSignatures(fields, recursionDepth = 0) {
    const RECURSION_LIMIT = 10;
    if (!Array.isArray(fields)) {
      return false;
    }
    return fields.every((field) => {
      field = this.xref.fetchIfRef(field);
      if (!(field instanceof Dict)) {
        return false;
      }
      if (field.has("Kids")) {
        if (++recursionDepth > RECURSION_LIMIT) {
          warn("_hasOnlyDocumentSignatures: maximum recursion depth reached");
          return false;
        }
        return this._hasOnlyDocumentSignatures(field.get("Kids"), recursionDepth);
      }
      const isSignature = isName(field.get("FT"), "Sig");
      const rectangle = field.get("Rect");
      const isInvisible = Array.isArray(rectangle) && rectangle.every((value) => value === 0);
      return isSignature && isInvisible;
    });
  }
  get xfaData() {
    const acroForm = this.catalog.acroForm;
    if (!acroForm) {
      return null;
    }
    const xfa = acroForm.get("XFA");
    const entries = {
      "xdp:xdp": "",
      template: "",
      datasets: "",
      config: "",
      connectionSet: "",
      localeSet: "",
      stylesheet: "",
      "/xdp:xdp": ""
    };
    if (isStream(xfa) && !xfa.isEmpty) {
      try {
        entries["xdp:xdp"] = stringToUTF8String(xfa.getString());
        return entries;
      } catch (_) {
        warn("XFA - Invalid utf-8 string.");
        return null;
      }
    }
    if (!Array.isArray(xfa) || xfa.length === 0) {
      return null;
    }
    for (let i = 0, ii = xfa.length; i < ii; i += 2) {
      let name;
      if (i === 0) {
        name = "xdp:xdp";
      } else if (i === ii - 2) {
        name = "/xdp:xdp";
      } else {
        name = xfa[i];
      }
      if (!entries.hasOwnProperty(name)) {
        continue;
      }
      const data = this.xref.fetchIfRef(xfa[i + 1]);
      if (!isStream(data) || data.isEmpty) {
        continue;
      }
      try {
        entries[name] = stringToUTF8String(data.getString());
      } catch (_) {
        warn("XFA - Invalid utf-8 string.");
        return null;
      }
    }
    return entries;
  }
  get xfaFactory() {
    if (this.pdfManager.enableXfa && this.formInfo.hasXfa && !this.formInfo.hasAcroForm) {
      const data = this.xfaData;
      return shadow(this, "xfaFactory", data ? new XFAFactory(data) : null);
    }
    return shadow(this, "xfaFaxtory", null);
  }
  get isPureXfa() {
    return this.xfaFactory && this.xfaFactory.isValid();
  }
  get htmlForXfa() {
    if (this.xfaFactory) {
      return this.xfaFactory.getPages();
    }
    return null;
  }
  async loadXfaImages() {
    const xfaImagesDict = await this.pdfManager.ensureCatalog("xfaImages");
    if (!xfaImagesDict) {
      return;
    }
    const keys = xfaImagesDict.getKeys();
    const objectLoader = new ObjectLoader(xfaImagesDict, keys, this.xref);
    await objectLoader.load();
    const xfaImages = /* @__PURE__ */ new Map();
    for (const key of keys) {
      const stream = xfaImagesDict.get(key);
      if (!isStream(stream)) {
        continue;
      }
      xfaImages.set(key, stream.getBytes());
    }
    this.xfaFactory.setImages(xfaImages);
  }
  async loadXfaFonts(handler, task) {
    const acroForm = await this.pdfManager.ensureCatalog("acroForm");
    if (!acroForm) {
      return;
    }
    const resources = await acroForm.getAsync("DR");
    if (!(resources instanceof Dict)) {
      return;
    }
    const objectLoader = new ObjectLoader(resources, ["Font"], this.xref);
    await objectLoader.load();
    const fontRes = resources.get("Font");
    if (!(fontRes instanceof Dict)) {
      return;
    }
    const options = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
    options.useSystemFonts = false;
    const partialEvaluator = new PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: -1,
      idFactory: this._globalIdFactory,
      fontCache: this.catalog.fontCache,
      builtInCMapCache: this.catalog.builtInCMapCache,
      standardFontDataCache: this.catalog.standardFontDataCache,
      options
    });
    const operatorList = new OperatorList();
    const pdfFonts = [];
    const initialState = {
      get font() {
        return pdfFonts[pdfFonts.length - 1];
      },
      set font(font) {
        pdfFonts.push(font);
      },
      clone() {
        return this;
      }
    };
    const fonts = /* @__PURE__ */ new Map();
    fontRes.forEach((fontName, font) => {
      fonts.set(fontName, font);
    });
    const promises = [];
    for (const [fontName, font] of fonts) {
      const descriptor = font.get("FontDescriptor");
      if (!(descriptor instanceof Dict)) {
        continue;
      }
      let fontFamily = descriptor.get("FontFamily");
      fontFamily = fontFamily.replace(/[ ]+([0-9])/g, "$1");
      const fontWeight = descriptor.get("FontWeight");
      const italicAngle = -descriptor.get("ItalicAngle");
      const cssFontInfo = {
        fontFamily,
        fontWeight,
        italicAngle
      };
      if (!validateCSSFont(cssFontInfo)) {
        continue;
      }
      promises.push(partialEvaluator.handleSetFont(
        resources,
        [Name.get(fontName), 1],
        /* fontRef = */
        null,
        operatorList,
        task,
        initialState,
        /* fallbackFontDict = */
        null,
        /* cssFontInfo = */
        cssFontInfo
      ).catch(function(reason) {
        warn(`loadXfaFonts: "${reason}".`);
        return null;
      }));
    }
    await Promise.all(promises);
    const missingFonts = this.xfaFactory.setFonts(pdfFonts);
    if (!missingFonts) {
      return;
    }
    options.ignoreErrors = true;
    promises.length = 0;
    pdfFonts.length = 0;
    const reallyMissingFonts = /* @__PURE__ */ new Set();
    for (const missing of missingFonts) {
      if (!getXfaFontWidths(`${missing}-Regular`)) {
        reallyMissingFonts.add(missing);
      }
    }
    if (reallyMissingFonts.size) {
      missingFonts.push("PdfJS-Fallback");
    }
    for (const missing of missingFonts) {
      if (reallyMissingFonts.has(missing)) {
        continue;
      }
      for (const fontInfo of [{
        name: "Regular",
        fontWeight: 400,
        italicAngle: 0
      }, {
        name: "Bold",
        fontWeight: 700,
        italicAngle: 0
      }, {
        name: "Italic",
        fontWeight: 400,
        italicAngle: 12
      }, {
        name: "BoldItalic",
        fontWeight: 700,
        italicAngle: 12
      }]) {
        const name = `${missing}-${fontInfo.name}`;
        const widths = getXfaFontWidths(name);
        const dict = new Dict(null);
        dict.set("BaseFont", Name.get(name));
        dict.set("Type", Name.get("Font"));
        dict.set("Subtype", Name.get("TrueType"));
        dict.set("Encoding", Name.get("WinAnsiEncoding"));
        const descriptor = new Dict(null);
        descriptor.set("Widths", widths);
        dict.set("FontDescriptor", descriptor);
        promises.push(partialEvaluator.handleSetFont(
          resources,
          [Name.get(name), 1],
          /* fontRef = */
          null,
          operatorList,
          task,
          initialState,
          /* fallbackFontDict = */
          dict,
          /* cssFontInfo = */
          {
            fontFamily: missing,
            fontWeight: fontInfo.fontWeight,
            italicAngle: fontInfo.italicAngle
          }
        ).catch(function(reason) {
          warn(`loadXfaFonts: "${reason}".`);
          return null;
        }));
      }
    }
    await Promise.all(promises);
    this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts);
  }
  async serializeXfaData(annotationStorage) {
    if (this.xfaFactory) {
      return this.xfaFactory.serializeData(annotationStorage);
    }
    return null;
  }
  get formInfo() {
    const formInfo = {
      hasFields: false,
      hasAcroForm: false,
      hasXfa: false,
      hasSignatures: false
    };
    const acroForm = this.catalog.acroForm;
    if (!acroForm) {
      return shadow(this, "formInfo", formInfo);
    }
    try {
      const fields = acroForm.get("Fields");
      const hasFields = Array.isArray(fields) && fields.length > 0;
      formInfo.hasFields = hasFields;
      const xfa = acroForm.get("XFA");
      formInfo.hasXfa = Array.isArray(xfa) && xfa.length > 0 || isStream(xfa) && !xfa.isEmpty;
      const sigFlags = acroForm.get("SigFlags");
      const hasSignatures = !!(sigFlags & 1);
      const hasOnlyDocumentSignatures = hasSignatures && this._hasOnlyDocumentSignatures(fields);
      formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
      formInfo.hasSignatures = hasSignatures;
    } catch (ex) {
      if (ex instanceof MissingDataException) {
        throw ex;
      }
      warn(`Cannot fetch form information: "${ex}".`);
    }
    return shadow(this, "formInfo", formInfo);
  }
  get documentInfo() {
    const DocumentInfoValidators = {
      Title: isString,
      Author: isString,
      Subject: isString,
      Keywords: isString,
      Creator: isString,
      Producer: isString,
      CreationDate: isString,
      ModDate: isString,
      Trapped: isName
    };
    let version = this._version;
    if (typeof version !== "string" || !PDF_HEADER_VERSION_REGEXP.test(version)) {
      warn(`Invalid PDF header version number: ${version}`);
      version = null;
    }
    const docInfo = {
      PDFFormatVersion: version,
      IsLinearized: !!this.linearization,
      IsAcroFormPresent: this.formInfo.hasAcroForm,
      IsXFAPresent: this.formInfo.hasXfa,
      IsCollectionPresent: !!this.catalog.collection,
      IsSignaturesPresent: this.formInfo.hasSignatures
    };
    let infoDict;
    try {
      infoDict = this.xref.trailer.get("Info");
    } catch (err) {
      if (err instanceof MissingDataException) {
        throw err;
      }
      info("The document information dictionary is invalid.");
    }
    if (isDict(infoDict)) {
      for (const key of infoDict.getKeys()) {
        const value = infoDict.get(key);
        if (DocumentInfoValidators[key]) {
          if (DocumentInfoValidators[key](value)) {
            docInfo[key] = typeof value !== "string" ? value : stringToPDFString(value);
          } else {
            info(`Bad value in document info for "${key}".`);
          }
        } else if (typeof key === "string") {
          let customValue;
          if (isString(value)) {
            customValue = stringToPDFString(value);
          } else if (isName(value) || isNum(value) || isBool(value)) {
            customValue = value;
          } else {
            info(`Unsupported value in document info for (custom) "${key}".`);
            continue;
          }
          if (!docInfo.Custom) {
            docInfo.Custom = /* @__PURE__ */ Object.create(null);
          }
          docInfo.Custom[key] = customValue;
        }
      }
    }
    return shadow(this, "documentInfo", docInfo);
  }
  get fingerprints() {
    function validate(data) {
      return typeof data === "string" && data.length > 0 && data !== EMPTY_FINGERPRINT;
    }
    function hexString(hash) {
      const buf = [];
      for (let i = 0, ii = hash.length; i < ii; i++) {
        const hex = hash[i].toString(16);
        buf.push(hex.padStart(2, "0"));
      }
      return buf.join("");
    }
    const idArray = this.xref.trailer.get("ID");
    let hashOriginal, hashModified;
    if (Array.isArray(idArray) && validate(idArray[0])) {
      hashOriginal = stringToBytes(idArray[0]);
      if (idArray[1] !== idArray[0] && validate(idArray[1])) {
        hashModified = stringToBytes(idArray[1]);
      }
    } else {
      hashOriginal = calculateMD5(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
    }
    return shadow(this, "fingerprints", [hexString(hashOriginal), hashModified ? hexString(hashModified) : null]);
  }
  _getLinearizationPage(pageIndex) {
    const {
      catalog,
      linearization
    } = this;
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("!PRODUCTION || TESTING")) {
      assert(linearization && linearization.pageFirst === pageIndex, "_getLinearizationPage - invalid pageIndex argument.");
    }
    const ref = Ref.get(linearization.objectNumberFirst, 0);
    return this.xref.fetchAsync(ref).then((obj) => {
      if (isDict(obj, "Page") || isDict(obj) && !obj.has("Type") && obj.has("Contents")) {
        if (ref && !catalog.pageKidsCountCache.has(ref)) {
          catalog.pageKidsCountCache.put(ref, 1);
        }
        return [obj, ref];
      }
      throw new FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
    }).catch((reason) => {
      info(reason);
      return catalog.getPageDict(pageIndex);
    });
  }
  getPage(pageIndex) {
    if (this._pagePromises[pageIndex] !== void 0) {
      return this._pagePromises[pageIndex];
    }
    const {
      catalog,
      linearization
    } = this;
    if (this.xfaFactory) {
      return Promise.resolve(new Page({
        pdfManager: this.pdfManager,
        xref: this.xref,
        pageIndex,
        pageDict: Dict.empty,
        ref: null,
        globalIdFactory: this._globalIdFactory,
        fontCache: catalog.fontCache,
        builtInCMapCache: catalog.builtInCMapCache,
        standardFontDataCache: catalog.standardFontDataCache,
        globalImageCache: catalog.globalImageCache,
        nonBlendModesSet: catalog.nonBlendModesSet,
        xfaFactory: this.xfaFactory
      }));
    }
    const promise = linearization && linearization.pageFirst === pageIndex ? this._getLinearizationPage(pageIndex) : catalog.getPageDict(pageIndex);
    return this._pagePromises[pageIndex] = promise.then(([pageDict, ref]) => {
      return new Page({
        pdfManager: this.pdfManager,
        xref: this.xref,
        pageIndex,
        pageDict,
        ref,
        globalIdFactory: this._globalIdFactory,
        fontCache: catalog.fontCache,
        builtInCMapCache: catalog.builtInCMapCache,
        standardFontDataCache: catalog.standardFontDataCache,
        globalImageCache: catalog.globalImageCache,
        nonBlendModesSet: catalog.nonBlendModesSet,
        xfaFactory: null
      });
    });
  }
  checkFirstPage() {
    return this.getPage(0).catch(async (reason) => {
      if (reason instanceof XRefEntryException) {
        this._pagePromises.length = 0;
        await this.cleanup();
        throw new XRefParseException();
      }
    });
  }
  fontFallback(id, handler) {
    return this.catalog.fontFallback(id, handler);
  }
  async cleanup(manuallyTriggered = false) {
    return this.catalog ? this.catalog.cleanup(manuallyTriggered) : clearPrimitiveCaches();
  }
  /**
   * @private
   */
  _collectFieldObjects(name, fieldRef, promises) {
    const field = this.xref.fetchIfRef(fieldRef);
    if (field.has("T")) {
      const partName = stringToPDFString(field.get("T"));
      if (name === "") {
        name = partName;
      } else {
        name = `${name}.${partName}`;
      }
    }
    if (!promises.has(name)) {
      promises.set(name, []);
    }
    promises.get(name).push(AnnotationFactory.create(
      this.xref,
      fieldRef,
      this.pdfManager,
      this._localIdFactory,
      /* collectFields */
      true
    ).then((annotation) => annotation && annotation.getFieldObject()).catch(function(reason) {
      warn(`_collectFieldObjects: "${reason}".`);
      return null;
    }));
    if (field.has("Kids")) {
      const kids = field.get("Kids");
      for (const kid of kids) {
        this._collectFieldObjects(name, kid, promises);
      }
    }
  }
  get fieldObjects() {
    if (!this.formInfo.hasFields) {
      return shadow(this, "fieldObjects", Promise.resolve(null));
    }
    const allFields = /* @__PURE__ */ Object.create(null);
    const fieldPromises = /* @__PURE__ */ new Map();
    for (const fieldRef of this.catalog.acroForm.get("Fields")) {
      this._collectFieldObjects("", fieldRef, fieldPromises);
    }
    const allPromises = [];
    for (const [name, promises] of fieldPromises) {
      allPromises.push(Promise.all(promises).then((fields) => {
        fields = fields.filter((field) => !!field);
        if (fields.length > 0) {
          allFields[name] = fields;
        }
      }));
    }
    return shadow(this, "fieldObjects", Promise.all(allPromises).then(() => allFields));
  }
  get hasJSActions() {
    const promise = this.pdfManager.ensureDoc("_parseHasJSActions");
    return shadow(this, "hasJSActions", promise);
  }
  /**
   * @private
   */
  async _parseHasJSActions() {
    const [catalogJsActions, fieldObjects] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    if (catalogJsActions) {
      return true;
    }
    if (fieldObjects) {
      return Object.values(fieldObjects).some((fieldObject) => fieldObject.some((object) => object.actions !== null));
    }
    return false;
  }
  get calculationOrderIds() {
    const acroForm = this.catalog.acroForm;
    if (!acroForm || !acroForm.has("CO")) {
      return shadow(this, "calculationOrderIds", null);
    }
    const calculationOrder = acroForm.get("CO");
    if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
      return shadow(this, "calculationOrderIds", null);
    }
    const ids = calculationOrder.filter(isRef).map((ref) => ref.toString());
    if (ids.length === 0) {
      return shadow(this, "calculationOrderIds", null);
    }
    return shadow(this, "calculationOrderIds", ids);
  }
};
function parseDocBaseUrl(url) {
  if (url) {
    const absoluteUrl = createValidAbsoluteUrl(url);
    if (absoluteUrl) {
      return absoluteUrl.href;
    }
    warn(`Invalid absolute docBaseUrl: "${url}".`);
  }
  return null;
}
var BasePdfManager = class _BasePdfManager {
  constructor() {
    if (this.constructor === _BasePdfManager) {
      unreachable("Cannot initialize BasePdfManager.");
    }
  }
  get docId() {
    return this._docId;
  }
  get password() {
    return this._password;
  }
  get docBaseUrl() {
    return this._docBaseUrl;
  }
  onLoadedStream() {
    unreachable("Abstract method `onLoadedStream` called");
  }
  ensureDoc(prop, args) {
    return this.ensure(this.pdfDocument, prop, args);
  }
  ensureXRef(prop, args) {
    return this.ensure(this.pdfDocument.xref, prop, args);
  }
  ensureCatalog(prop, args) {
    return this.ensure(this.pdfDocument.catalog, prop, args);
  }
  getPage(pageIndex) {
    return this.pdfDocument.getPage(pageIndex);
  }
  fontFallback(id, handler) {
    return this.pdfDocument.fontFallback(id, handler);
  }
  loadXfaFonts(handler, task) {
    return this.pdfDocument.loadXfaFonts(handler, task);
  }
  loadXfaImages() {
    return this.pdfDocument.loadXfaImages();
  }
  serializeXfaData(annotationStorage) {
    return this.pdfDocument.serializeXfaData(annotationStorage);
  }
  cleanup(manuallyTriggered = false) {
    return this.pdfDocument.cleanup(manuallyTriggered);
  }
  async ensure(obj, prop, args) {
    unreachable("Abstract method `ensure` called");
  }
  requestRange(begin, end) {
    unreachable("Abstract method `requestRange` called");
  }
  requestLoadedStream() {
    unreachable("Abstract method `requestLoadedStream` called");
  }
  sendProgressiveData(chunk) {
    unreachable("Abstract method `sendProgressiveData` called");
  }
  updatePassword(password) {
    this._password = password;
  }
  terminate(reason) {
    unreachable("Abstract method `terminate` called");
  }
};
var LocalPdfManager = class extends BasePdfManager {
  constructor(docId, data, password, evaluatorOptions, enableXfa, docBaseUrl) {
    super();
    this._docId = docId;
    this._password = password;
    this._docBaseUrl = parseDocBaseUrl(docBaseUrl);
    this.evaluatorOptions = evaluatorOptions;
    this.enableXfa = enableXfa;
    const stream = new Stream(data);
    this.pdfDocument = new PDFDocument(this, stream);
    this._loadedStreamPromise = Promise.resolve(stream);
  }
  async ensure(obj, prop, args) {
    const value = obj[prop];
    if (typeof value === "function") {
      return value.apply(obj, args);
    }
    return value;
  }
  requestRange(begin, end) {
    return Promise.resolve();
  }
  requestLoadedStream() {
  }
  onLoadedStream() {
    return this._loadedStreamPromise;
  }
  terminate(reason) {
  }
};
var NetworkPdfManager = class extends BasePdfManager {
  constructor(docId, pdfNetworkStream, args, evaluatorOptions, enableXfa, docBaseUrl) {
    super();
    this._docId = docId;
    this._password = args.password;
    this._docBaseUrl = parseDocBaseUrl(docBaseUrl);
    this.msgHandler = args.msgHandler;
    this.evaluatorOptions = evaluatorOptions;
    this.enableXfa = enableXfa;
    this.streamManager = new ChunkedStreamManager(pdfNetworkStream, {
      msgHandler: args.msgHandler,
      length: args.length,
      disableAutoFetch: args.disableAutoFetch,
      rangeChunkSize: args.rangeChunkSize
    });
    this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
  }
  async ensure(obj, prop, args) {
    try {
      const value = obj[prop];
      if (typeof value === "function") {
        return value.apply(obj, args);
      }
      return value;
    } catch (ex) {
      if (!(ex instanceof MissingDataException)) {
        throw ex;
      }
      await this.requestRange(ex.begin, ex.end);
      return this.ensure(obj, prop, args);
    }
  }
  requestRange(begin, end) {
    return this.streamManager.requestRange(begin, end);
  }
  requestLoadedStream() {
    this.streamManager.requestAllChunks();
  }
  sendProgressiveData(chunk) {
    this.streamManager.onReceiveData({
      chunk
    });
  }
  onLoadedStream() {
    return this.streamManager.onLoadedStream();
  }
  terminate(reason) {
    this.streamManager.abort(reason);
  }
};
var PDFWorkerStream = class {
  constructor(msgHandler) {
    this._msgHandler = msgHandler;
    this._contentLength = null;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFWorkerStreamReader = class {
  constructor(msgHandler) {
    this._msgHandler = msgHandler;
    this.onProgress = null;
    this._contentLength = null;
    this._isRangeSupported = false;
    this._isStreamingSupported = false;
    const readableStream = this._msgHandler.sendWithStream("GetReader");
    this._reader = readableStream.getReader();
    this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((data) => {
      this._isStreamingSupported = data.isStreamingSupported;
      this._isRangeSupported = data.isRangeSupported;
      this._contentLength = data.contentLength;
    });
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value: void 0,
        done: true
      };
    }
    return {
      value: value.buffer,
      done: false
    };
  }
  cancel(reason) {
    this._reader.cancel(reason);
  }
};
var PDFWorkerStreamRangeReader = class {
  constructor(begin, end, msgHandler) {
    this._msgHandler = msgHandler;
    this.onProgress = null;
    const readableStream = this._msgHandler.sendWithStream("GetRangeReader", {
      begin,
      end
    });
    this._reader = readableStream.getReader();
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value: void 0,
        done: true
      };
    }
    return {
      value: value.buffer,
      done: false
    };
  }
  cancel(reason) {
    this._reader.cancel(reason);
  }
};
var WorkerTask = class {
  constructor(name) {
    this.name = name;
    this.terminated = false;
    this._capability = createPromiseCapability();
  }
  get finished() {
    return this._capability.promise;
  }
  finish() {
    this._capability.resolve();
  }
  terminate() {
    this.terminated = true;
  }
  ensureNotTerminated() {
    if (this.terminated) {
      throw new Error("Worker task was terminated");
    }
  }
};
var WorkerMessageHandler = class _WorkerMessageHandler {
  static setup(handler, port) {
    let testMessageProcessed = false;
    handler.on("test", function wphSetupTest(data) {
      if (testMessageProcessed) {
        return;
      }
      testMessageProcessed = true;
      if (!(data instanceof Uint8Array)) {
        handler.send("test", null);
        return;
      }
      const supportTransfers = data[0] === 255;
      handler.postMessageTransfers = supportTransfers;
      handler.send("test", {
        supportTransfers
      });
    });
    handler.on("configure", function wphConfigure(data) {
      setVerbosityLevel(data.verbosity);
    });
    handler.on("GetDocRequest", function wphSetupDoc(data) {
      return _WorkerMessageHandler.createDocumentHandler(data, port);
    });
  }
  static createDocumentHandler(docParams, port) {
    let pdfManager;
    let terminated = false;
    let cancelXHRs = null;
    const WorkerTasks = [];
    const verbosity = getVerbosityLevel();
    const apiVersion = docParams.apiVersion;
    const workerVersion = typeof PDFJSDev !== "undefined" && !PDFJSDev.test("TESTING") ? PDFJSDev.eval("BUNDLE_VERSION") : null;
    if (apiVersion !== workerVersion) {
      throw new Error(`The API version "${apiVersion}" does not match the Worker version "${workerVersion}".`);
    }
    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
      const enumerableProperties = [];
      for (const property in []) {
        enumerableProperties.push(property);
      }
      if (enumerableProperties.length) {
        throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + enumerableProperties.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
      }
      if ((typeof PDFJSDev === "undefined" || PDFJSDev.test("SKIP_BABEL")) && typeof ReadableStream === "undefined") {
        throw new Error("The browser/environment lacks native support for critical functionality used by the PDF.js library (e.g. `ReadableStream`); please use a `legacy`-build instead.");
      }
    }
    const docId = docParams.docId;
    const docBaseUrl = docParams.docBaseUrl;
    const workerHandlerName = docParams.docId + "_worker";
    let handler = new MessageHandler(workerHandlerName, docId, port);
    handler.postMessageTransfers = docParams.postMessageTransfers;
    function ensureNotTerminated() {
      if (terminated) {
        throw new Error("Worker was terminated");
      }
    }
    function startWorkerTask(task) {
      WorkerTasks.push(task);
    }
    function finishWorkerTask(task) {
      task.finish();
      const i = WorkerTasks.indexOf(task);
      WorkerTasks.splice(i, 1);
    }
    async function loadDocument(recoveryMode) {
      await pdfManager.ensureDoc("checkHeader");
      await pdfManager.ensureDoc("parseStartXRef");
      await pdfManager.ensureDoc("parse", [recoveryMode]);
      if (!recoveryMode) {
        await pdfManager.ensureDoc("checkFirstPage");
      }
      const isPureXfa = await pdfManager.ensureDoc("isPureXfa");
      if (isPureXfa) {
        const task = new WorkerTask("loadXfaFonts");
        startWorkerTask(task);
        await Promise.all([pdfManager.loadXfaFonts(handler, task).catch((reason) => {
        }).then(() => finishWorkerTask(task)), pdfManager.loadXfaImages()]);
      }
      const [numPages, fingerprints] = await Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("fingerprints")]);
      const htmlForXfa = isPureXfa ? await pdfManager.ensureDoc("htmlForXfa") : null;
      return {
        numPages,
        fingerprints,
        htmlForXfa
      };
    }
    function getPdfManager(data, evaluatorOptions, enableXfa) {
      const pdfManagerCapability = createPromiseCapability();
      let newPdfManager;
      const source = data.source;
      if (source.data) {
        try {
          newPdfManager = new LocalPdfManager(docId, source.data, source.password, evaluatorOptions, enableXfa, docBaseUrl);
          pdfManagerCapability.resolve(newPdfManager);
        } catch (ex) {
          pdfManagerCapability.reject(ex);
        }
        return pdfManagerCapability.promise;
      }
      let pdfStream, cachedChunks = [];
      try {
        pdfStream = new PDFWorkerStream(handler);
      } catch (ex) {
        pdfManagerCapability.reject(ex);
        return pdfManagerCapability.promise;
      }
      const fullRequest = pdfStream.getFullReader();
      fullRequest.headersReady.then(function() {
        if (!fullRequest.isRangeSupported) {
          return;
        }
        const disableAutoFetch = source.disableAutoFetch || fullRequest.isStreamingSupported;
        newPdfManager = new NetworkPdfManager(docId, pdfStream, {
          msgHandler: handler,
          password: source.password,
          length: fullRequest.contentLength,
          disableAutoFetch,
          rangeChunkSize: source.rangeChunkSize
        }, evaluatorOptions, enableXfa, docBaseUrl);
        for (let i = 0; i < cachedChunks.length; i++) {
          newPdfManager.sendProgressiveData(cachedChunks[i]);
        }
        cachedChunks = [];
        pdfManagerCapability.resolve(newPdfManager);
        cancelXHRs = null;
      }).catch(function(reason) {
        pdfManagerCapability.reject(reason);
        cancelXHRs = null;
      });
      let loaded = 0;
      const flushChunks = function() {
        const pdfFile = arraysToBytes(cachedChunks);
        if (source.length && pdfFile.length !== source.length) {
          warn("reported HTTP length is different from actual");
        }
        try {
          newPdfManager = new LocalPdfManager(docId, pdfFile, source.password, evaluatorOptions, enableXfa, docBaseUrl);
          pdfManagerCapability.resolve(newPdfManager);
        } catch (ex) {
          pdfManagerCapability.reject(ex);
        }
        cachedChunks = [];
      };
      const readPromise = new Promise(function(resolve, reject) {
        const readChunk = function({
          value,
          done
        }) {
          try {
            ensureNotTerminated();
            if (done) {
              if (!newPdfManager) {
                flushChunks();
              }
              cancelXHRs = null;
              return;
            }
            loaded += arrayByteLength(value);
            if (!fullRequest.isStreamingSupported) {
              handler.send("DocProgress", {
                loaded,
                total: Math.max(loaded, fullRequest.contentLength || 0)
              });
            }
            if (newPdfManager) {
              newPdfManager.sendProgressiveData(value);
            } else {
              cachedChunks.push(value);
            }
            fullRequest.read().then(readChunk, reject);
          } catch (e) {
            reject(e);
          }
        };
        fullRequest.read().then(readChunk, reject);
      });
      readPromise.catch(function(e) {
        pdfManagerCapability.reject(e);
        cancelXHRs = null;
      });
      cancelXHRs = function(reason) {
        pdfStream.cancelAllRequests(reason);
      };
      return pdfManagerCapability.promise;
    }
    function setupDoc(data) {
      function onSuccess(doc) {
        ensureNotTerminated();
        handler.send("GetDoc", {
          pdfInfo: doc
        });
      }
      function onFailure(ex) {
        ensureNotTerminated();
        if (ex instanceof PasswordException) {
          const task = new WorkerTask(`PasswordException: response ${ex.code}`);
          startWorkerTask(task);
          handler.sendWithPromise("PasswordRequest", ex).then(function({
            password
          }) {
            finishWorkerTask(task);
            pdfManager.updatePassword(password);
            pdfManagerReady();
          }).catch(function() {
            finishWorkerTask(task);
            handler.send("DocException", ex);
          });
        } else if (ex instanceof InvalidPDFException || ex instanceof MissingPDFException || ex instanceof UnexpectedResponseException || ex instanceof UnknownErrorException) {
          handler.send("DocException", ex);
        } else {
          handler.send("DocException", new UnknownErrorException(ex.message, ex.toString()));
        }
      }
      function pdfManagerReady() {
        ensureNotTerminated();
        loadDocument(false).then(onSuccess, function(reason) {
          ensureNotTerminated();
          if (!(reason instanceof XRefParseException)) {
            onFailure(reason);
            return;
          }
          pdfManager.requestLoadedStream();
          pdfManager.onLoadedStream().then(function() {
            ensureNotTerminated();
            loadDocument(true).then(onSuccess, onFailure);
          });
        });
      }
      ensureNotTerminated();
      const evaluatorOptions = {
        maxImageSize: data.maxImageSize,
        disableFontFace: data.disableFontFace,
        ignoreErrors: data.ignoreErrors,
        isEvalSupported: data.isEvalSupported,
        fontExtraProperties: data.fontExtraProperties,
        useSystemFonts: data.useSystemFonts,
        cMapUrl: data.cMapUrl,
        standardFontDataUrl: data.standardFontDataUrl
      };
      getPdfManager(data, evaluatorOptions, data.enableXfa).then(function(newPdfManager) {
        if (terminated) {
          newPdfManager.terminate(new AbortException("Worker was terminated."));
          throw new Error("Worker was terminated");
        }
        pdfManager = newPdfManager;
        pdfManager.onLoadedStream().then(function(stream) {
          handler.send("DataLoaded", {
            length: stream.bytes.byteLength
          });
        });
      }).then(pdfManagerReady, onFailure);
    }
    handler.on("GetPage", function wphSetupGetPage(data) {
      return pdfManager.getPage(data.pageIndex).then(function(page) {
        return Promise.all([pdfManager.ensure(page, "rotate"), pdfManager.ensure(page, "ref"), pdfManager.ensure(page, "userUnit"), pdfManager.ensure(page, "view")]).then(function([rotate, ref, userUnit, view]) {
          return {
            rotate,
            ref,
            userUnit,
            view
          };
        });
      });
    });
    handler.on("GetPageIndex", function wphSetupGetPageIndex({
      ref
    }) {
      const pageRef = Ref.get(ref.num, ref.gen);
      return pdfManager.ensureCatalog("getPageIndex", [pageRef]);
    });
    handler.on("GetDestinations", function wphSetupGetDestinations(data) {
      return pdfManager.ensureCatalog("destinations");
    });
    handler.on("GetDestination", function wphSetupGetDestination(data) {
      return pdfManager.ensureCatalog("getDestination", [data.id]);
    });
    handler.on("GetPageLabels", function wphSetupGetPageLabels(data) {
      return pdfManager.ensureCatalog("pageLabels");
    });
    handler.on("GetPageLayout", function wphSetupGetPageLayout(data) {
      return pdfManager.ensureCatalog("pageLayout");
    });
    handler.on("GetPageMode", function wphSetupGetPageMode(data) {
      return pdfManager.ensureCatalog("pageMode");
    });
    handler.on("GetViewerPreferences", function(data) {
      return pdfManager.ensureCatalog("viewerPreferences");
    });
    handler.on("GetOpenAction", function(data) {
      return pdfManager.ensureCatalog("openAction");
    });
    handler.on("GetAttachments", function wphSetupGetAttachments(data) {
      return pdfManager.ensureCatalog("attachments");
    });
    handler.on("GetJavaScript", function wphSetupGetJavaScript(data) {
      return pdfManager.ensureCatalog("javaScript");
    });
    handler.on("GetDocJSActions", function wphSetupGetDocJSActions(data) {
      return pdfManager.ensureCatalog("jsActions");
    });
    handler.on("GetPageJSActions", function({
      pageIndex
    }) {
      return pdfManager.getPage(pageIndex).then(function(page) {
        return pdfManager.ensure(page, "jsActions");
      });
    });
    handler.on("GetOutline", function wphSetupGetOutline(data) {
      return pdfManager.ensureCatalog("documentOutline");
    });
    handler.on("GetOptionalContentConfig", function(data) {
      return pdfManager.ensureCatalog("optionalContentConfig");
    });
    handler.on("GetPermissions", function(data) {
      return pdfManager.ensureCatalog("permissions");
    });
    handler.on("GetMetadata", function wphSetupGetMetadata(data) {
      return Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadata")]);
    });
    handler.on("GetMarkInfo", function wphSetupGetMarkInfo(data) {
      return pdfManager.ensureCatalog("markInfo");
    });
    handler.on("GetData", function wphSetupGetData(data) {
      pdfManager.requestLoadedStream();
      return pdfManager.onLoadedStream().then(function(stream) {
        return stream.bytes;
      });
    });
    handler.on("GetStats", function wphSetupGetStats(data) {
      return pdfManager.ensureXRef("stats");
    });
    handler.on("GetAnnotations", function({
      pageIndex,
      intent
    }) {
      return pdfManager.getPage(pageIndex).then(function(page) {
        return page.getAnnotationsData(intent);
      });
    });
    handler.on("GetFieldObjects", function(data) {
      return pdfManager.ensureDoc("fieldObjects");
    });
    handler.on("HasJSActions", function(data) {
      return pdfManager.ensureDoc("hasJSActions");
    });
    handler.on("GetCalculationOrderIds", function(data) {
      return pdfManager.ensureDoc("calculationOrderIds");
    });
    handler.on("SaveDocument", function({
      isPureXfa,
      numPages,
      annotationStorage,
      filename
    }) {
      pdfManager.requestLoadedStream();
      const promises = [pdfManager.onLoadedStream(), pdfManager.ensureCatalog("acroForm"), pdfManager.ensureDoc("xref"), pdfManager.ensureDoc("startXRef")];
      if (isPureXfa) {
        promises.push(pdfManager.serializeXfaData(annotationStorage));
      } else {
        for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
          promises.push(pdfManager.getPage(pageIndex).then(function(page) {
            const task = new WorkerTask(`Save: page ${pageIndex}`);
            return page.save(handler, task, annotationStorage).finally(function() {
              finishWorkerTask(task);
            });
          }));
        }
      }
      return Promise.all(promises).then(function([stream, acroForm, xref, startXRef, ...refs]) {
        let newRefs = [];
        let xfaData = null;
        if (isPureXfa) {
          xfaData = refs[0];
          if (!xfaData) {
            return stream.bytes;
          }
        } else {
          for (const ref of refs) {
            newRefs = ref.filter((x) => x !== null).reduce((a, b) => a.concat(b), newRefs);
          }
          if (newRefs.length === 0) {
            return stream.bytes;
          }
        }
        const xfa = acroForm instanceof Dict && acroForm.get("XFA") || [];
        let xfaDatasets = null;
        if (Array.isArray(xfa)) {
          for (let i = 0, ii = xfa.length; i < ii; i += 2) {
            if (xfa[i] === "datasets") {
              xfaDatasets = xfa[i + 1];
            }
          }
        } else {
          warn("Unsupported XFA type.");
        }
        let newXrefInfo = /* @__PURE__ */ Object.create(null);
        if (xref.trailer) {
          const infoObj = /* @__PURE__ */ Object.create(null);
          const xrefInfo = xref.trailer.get("Info") || null;
          if (xrefInfo instanceof Dict) {
            xrefInfo.forEach((key, value) => {
              if (isString(key) && isString(value)) {
                infoObj[key] = stringToPDFString(value);
              }
            });
          }
          newXrefInfo = {
            rootRef: xref.trailer.getRaw("Root") || null,
            encryptRef: xref.trailer.getRaw("Encrypt") || null,
            newRef: xref.getNewRef(),
            infoRef: xref.trailer.getRaw("Info") || null,
            info: infoObj,
            fileIds: xref.trailer.get("ID") || null,
            startXRef,
            filename
          };
        }
        xref.resetNewRef();
        return incrementalUpdate({
          originalData: stream.bytes,
          xrefInfo: newXrefInfo,
          newRefs,
          xref,
          datasetsRef: xfaDatasets,
          xfaData
        });
      });
    });
    handler.on("GetOperatorList", function wphSetupRenderPage(data, sink) {
      const pageIndex = data.pageIndex;
      pdfManager.getPage(pageIndex).then(function(page) {
        const task = new WorkerTask(`GetOperatorList: page ${pageIndex}`);
        startWorkerTask(task);
        const start = verbosity >= VerbosityLevel.INFOS ? Date.now() : 0;
        page.getOperatorList({
          handler,
          sink,
          task,
          intent: data.intent,
          renderInteractiveForms: data.renderInteractiveForms,
          annotationStorage: data.annotationStorage
        }).then(function(operatorListInfo) {
          finishWorkerTask(task);
          if (start) {
            info(`page=${pageIndex + 1} - getOperatorList: time=${Date.now() - start}ms, len=${operatorListInfo.length}`);
          }
          sink.close();
        }, function(reason) {
          finishWorkerTask(task);
          if (task.terminated) {
            return;
          }
          handler.send("UnsupportedFeature", {
            featureId: UNSUPPORTED_FEATURES.errorOperatorList
          });
          sink.error(reason);
        });
      });
    });
    handler.on("GetTextContent", function wphExtractText(data, sink) {
      const pageIndex = data.pageIndex;
      sink.onPull = function(desiredSize) {
      };
      sink.onCancel = function(reason) {
      };
      pdfManager.getPage(pageIndex).then(function(page) {
        const task = new WorkerTask("GetTextContent: page " + pageIndex);
        startWorkerTask(task);
        const start = verbosity >= VerbosityLevel.INFOS ? Date.now() : 0;
        page.extractTextContent({
          handler,
          task,
          sink,
          normalizeWhitespace: data.normalizeWhitespace,
          includeMarkedContent: data.includeMarkedContent,
          combineTextItems: data.combineTextItems
        }).then(function() {
          finishWorkerTask(task);
          if (start) {
            info(`page=${pageIndex + 1} - getTextContent: time=${Date.now() - start}ms`);
          }
          sink.close();
        }, function(reason) {
          finishWorkerTask(task);
          if (task.terminated) {
            return;
          }
          sink.error(reason);
        });
      });
    });
    handler.on("GetStructTree", function wphGetStructTree(data) {
      return pdfManager.getPage(data.pageIndex).then(function(page) {
        return pdfManager.ensure(page, "getStructTree");
      });
    });
    handler.on("FontFallback", function(data) {
      return pdfManager.fontFallback(data.id, handler);
    });
    handler.on("Cleanup", function wphCleanup(data) {
      return pdfManager.cleanup(
        /* manuallyTriggered = */
        true
      );
    });
    handler.on("Terminate", function wphTerminate(data) {
      terminated = true;
      const waitOn = [];
      if (pdfManager) {
        pdfManager.terminate(new AbortException("Worker was terminated."));
        const cleanupPromise = pdfManager.cleanup();
        waitOn.push(cleanupPromise);
        pdfManager = null;
      } else {
        clearPrimitiveCaches();
      }
      if (cancelXHRs) {
        cancelXHRs(new AbortException("Worker was terminated."));
      }
      for (const task of WorkerTasks) {
        waitOn.push(task.finished);
        task.terminate();
      }
      return Promise.all(waitOn).then(function() {
        handler.destroy();
        handler = null;
      });
    });
    handler.on("Ready", function wphReady(data) {
      setupDoc(docParams);
      docParams = null;
    });
    return workerHandlerName;
  }
  static initializeFromPort(port) {
    const handler = new MessageHandler("worker", "main", port);
    _WorkerMessageHandler.setup(handler, port);
    handler.send("ready", null);
  }
};
function isMessagePort(maybePort) {
  return typeof maybePort.postMessage === "function" && "onmessage" in maybePort;
}
if (typeof window === "undefined" && !isNodeJS && typeof self !== "undefined" && isMessagePort(self)) {
  WorkerMessageHandler.initializeFromPort(self);
}

export {
  MessageHandler,
  WorkerTask,
  WorkerMessageHandler,
  worker_exports
};
//# sourceMappingURL=chunk-N5VMUTKB.js.map
